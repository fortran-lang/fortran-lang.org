{
    "name": "j3-fortran/fortran_proposals",
    "issues": [
        {
            "number": 260,
            "user": "klausler",
            "date": "2022-04-26 19:09:14+00:00",
            "title": "\"-2147483648\" should be a valid expression (again)",
            "text": "Assume 32-bit two's-complement as the default kind of integer.  It turns out that the expression \"-2147483648\" is conforming in FORTRAN '77 but at best questionable and at worst nonconforming in Fortran '90 or later.\nFORTRAN '77' defined an integer constant (4.3.1) as a signed digit string.  Fortran '90's grammar, on the other hand, parses a signed integer literal as the application of a unary minus to an unsigned digit string.  In the case of \"-2147483648\", the integer literal to be negated is not a valid number in the range of the default kind of integer.\nReferences to Fortran 2018: A primary (R1001) can be a literal-constant (R605) which can be an int-literal-constant (R708) which does not allow for a sign.  So the minus sign is an add-op (R1009) being used in a level-2-expr (R1006).\nOddly, a complex-literal-constant (R718) can have a signed-int-literal-constant as its real or imaginary parts, so \"(-2147483648,-2147483648)\" is not a problem in that context.  A signed-int-literal-constant may also appear in some other contexts, e.g. DATA statements.",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 259,
            "user": "MichaelSiehl",
            "date": "2022-04-24 20:15:52+00:00",
            "title": "Extending the FAIL IMAGE statement to allow to fail remote images",
            "text": "I did already discuss this earlier here: https://fortran-lang.discourse.group/t/force-all-images-to-crash-if-one-crashes/2985/22 . Thus, let me just repeat some of my comments here:\nThe FAIL IMAGE statement  is of limited practical use for the programmer as it can only fail the executing image.\nThe FAIL IMAGE statement would be more useful if it would allow to fail remote images as well, as the programmer can develop techniques to get hints as if a remote image is a candidate for an image failure. Without such a feature the raising and detection of failed images is solely left to the run-time. Thus, raising (remote) image failure is one aspect where the Fortran programmer has no low-level access to yet.\n\u2018Is it possible to make the FAIL IMAGE statement so that it can fail remote images as well, i.e. to implement a new intrinsic function FAIL_IMAGE ( image ) that would do that job?\u2019\nFrom my current understanding, and from a Fortran programmer\u2019s viewpoint, a customized fault detection and recovery would be a three-step process (step 2. is the reason for my demand here):\n\n\nDetection of Failed Images\nThe Fortran 2018 programmer can already detect any failed images through failing (missing or delayed) atomic data transfer(s). (This requires a programming model that constantly does fain-grained switches between sending and receiving on the images).\n\n\nMarking Images as Failed Images\nAfter detection of failed images the Fortran programmer should be able to (remotely) mark these images as failed images using something like a FAIL_IMAGE function. That is what I am asking for here, because this alone would give enough low-level access to the programmer for implementing the recovery process, as it should allow to leave a CHANGE TEAM construct gracefully in the presence of failed images.\n\n\nRecovery Process\nWithout the possibility for the Fortran programmer to mark failed images, we can only STOP (not ERROR STOP) all the remaining active images of a coarray team with (a) failed image(s). Thus, the main advantage of such failed images features would be to not lose more images than necessary in a recovery process.\n\n\nOf course, I am talking about a customized detection of failed images using F18 low-level features: Simply said, we can already detect missing atomic data transfers (with the remote image numbers), which is in most cases due to delayed atomic data transfers but may also be due to failed images (i.e. algorithm failure or hardware failure). The process can be refined so that the cases of delayed atomic data transfer could be identified in most cases, so that we\u2019d be able to minimize the cases of missing atomic data transfers to a smaller number that could symbolize a number of failed images (with the image numbers).\nThus, we already have a number of images (one or more, and with image numbers) that we want to be treated as failed images, but we only can\u2019t give this to the run-time yet, because the FAIL IMAGE statement does only fail the executing image. In principle, all we possibly need would be such an intrinsic function FAIL_IMAGE(image) (if such could possibly be implemented, or something else) as a means to give the results of our customized failed images detection to the run-time, and that the current team could reconfigure itself to exclude the (customized) failed images from further execution with image control statements. Then, we could use a customized recovery process as well.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": []
        },
        {
            "number": 258,
            "user": "w6ws",
            "date": "2022-04-24 16:24:02+00:00",
            "title": "Add simple sorting intrinsics",
            "text": "Most languages have sorting procedures in their libraries, and some even have them as operators.  Various Fortran implementations have had sorting procedures in their libraries for many many years - yet none are called in a standardized way.  Another approach might be to use C Interop to call C's qsort.  However it is not as user-friendly as simply calling an intrinsic.  It also has performance problems due to the lack of inlining of the required comparison procedure.\nI'd like to propose two sets of simple intrinsic functions that accept 1D array arguments of intrinsic types (e.g., integers, reals, and character strings - maybe logicals), and either return a sorted version of the input, or an integer permutation vector (\"grade\").  The latter should have an optional argument for stability.  Using the old HPF function names as examples, but minus HPF's funky DIM= argument:\nresult = GRADE_DOWN (ARG[, STABLE=logical_scalar])  ! returns permutation vector for accessing input in descending order\nresult = GRADE_UP (ARG[, STABLE=logical_scalar])  ! returns permutation vector for accessing input in ascending order\nresult = SORT_DOWN (ARG)  ! returns input in descending order\nresult = SORT_UP (ARG)  ! returns input in ascending order\nI like having them in functional form for use in expressions.  However I could see also adding intrinsic subroutine versions of SORT_[UP|DOWN] for doing in-place sorts.  For example:\ncall SORT_INPLACE_DOWN (ARG)\ncall SORT_INPLACE_UP (ARG)\nThe GRADE versions are especially useful with sorting arrays of derived types.  Once the permutation vector has been obtained, the individual elements can be accessed or permuted as needed:\ntype(mytype_t), allocatable :: my_array(:), my_sorted_array(:)\ninteger, allocatable :: perm_vector(:)\n:\nperm_vector = GRADE_UP (my_array%key_value)\nmy_sorted_array = my_array(perm_vector)\nor even:\nmy_sorted_array = my_array(GRADE_UP (my_array%key_value))",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "wyphan",
                    "date": "2022-04-24 16:33:22+00:00",
                    "text": "If I remember correctly, this is already implemented as part of the Fortran\nstandard library [fortran-lang/stdlib](https://github.com/fortran-lang/stdlib)\n\u2026\nOn Sun, Apr 24, 2022, 12:24 Walter Spector ***@***.***> wrote:\n Most languages have sorting procedures in their libraries, and some even\n have them as operators. Various Fortran implementations have had sorting\n procedures in their libraries for many many years - yet none are called in\n a standardized way. Another approach might be to use C Interop to call C's\n qsort. However it is not as user-friendly as simply calling an intrinsic.\n It also has performance problems due to the lack of inlining of the\n required comparison procedure.\n\n I'd like to propose two sets of simple intrinsic functions that accept 1D\n array arguments of intrinsic types (e.g., integers, reals, and character\n strings - maybe logicals), and either return a sorted version of the input,\n or an integer permutation vector (\"grade\"). The latter should have an\n optional argument for stability. Using the old HPF function names as\n examples, but minus HPF's funky DIM= argument:\n\n result = GRADE_DOWN (ARG[, STABLE=logical_scalar]) ! returns permutation\n vector for accessing input in descending order\n result = GRADE_UP (ARG[, STABLE=logical_scalar]) ! returns permutation\n vector for accessing input in ascending order\n\n result = SORT_DOWN (ARG) ! returns input in descending order\n result = SORT_UP (ARG) ! returns input in ascending order\n\n I like having them in functional form for use in expressions. However I\n could see also adding intrinsic subroutine versions of SORT_[UP|DOWN] for\n doing in-place sorts. For example:\n\n call SORT_INPLACE_DOWN (ARG)\n call SORT_INPLACE_UP (ARG)\n\n The GRADE versions are especially useful with sorting arrays of derived\n types. Once the permutation vector has been obtained, the individual\n elements can be accessed or permuted as needed:\n\n type(mytype_t), allocatable :: my_array(:), my_sorted_array(:)\n integer, allocatable :: perm_vector(:)\n :\n perm_vector = GRADE_UP (my_array%key_value)\n my_sorted_array = my_array(perm_vector)\n\n or even:\n\n my_sorted_array = my_array(GRADE_UP (my_array%key_value))\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#258>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AMERY5HRW4AVIE5KKZRIFNLVGVYSZANCNFSM5UGOXWPQ>\n .\n You are receiving this because you are subscribed to this thread.Message\n ID: ***@***.***>"
                },
                {
                    "user": "w6ws",
                    "date": "2022-04-24 16:40:39+00:00",
                    "text": "Hi,\n\u00a0\nYes there are sorting procedures there.\u00a0 I made a few suggestions on them - some of which were accepted.\u00a0 However this proposal differs a bit in a few ways.\u00a0 In particular using a functional form so they can be used in expressions.\n\u00a0\nWalter\n\u00a0\n-----Original Message-----\nFrom: j3-fortran/fortran_proposals\nSent: Apr 24, 2022 9:33 AM\nTo: j3-fortran/fortran_proposals\nCc: Walter Spector , Author\nSubject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics (Issue #258)\n\u00a0\n\u00a0\nIf I remember correctly, this is already implemented as part of the Fortran\nstandard library [fortran-lang/stdlib](github.com/fortran-lang/stdlib).\nOn Sun, Apr 24, 2022, 12:24 Walter Spector ***@***.***> wrote:\n Most languages have sorting procedures in their libraries, and some even\n have them as operators. Various Fortran implementations have had sorting\n procedures in their libraries for many many years - yet none are called in\n a standardized way. Another approach might be to use C Interop to call C's\n qsort. However it is not as user-friendly as simply calling an intrinsic.\n It also has performance problems due to the lack of inlining of the\n required comparison procedure.\n\n I'd like to propose two sets of simple intrinsic functions that accept 1D\n array arguments of intrinsic types (e.g., integers, reals, and character\n strings - maybe logicals), and either return a sorted version of the input,\n or an integer permutation vector (\"grade\"). The latter should have an\n optional argument for stability. Using the old HPF function names as\n examples, but minus HPF's funky DIM= argument:\n\n result = GRADE_DOWN (ARG[, STABLE=logical_scalar]) ! returns permutation\n vector for accessing input in descending order\n result = GRADE_UP (ARG[, STABLE=logical_scalar]) ! returns permutation\n vector for accessing input in ascending order\n\n result = SORT_DOWN (ARG) ! returns input in descending order\n result = SORT_UP (ARG) ! returns input in ascending order\n\n I like having them in functional form for use in expressions. However I\n could see also adding intrinsic subroutine versions of SORT_[UP|DOWN] for\n doing in-place sorts. For example:\n\n call SORT_INPLACE_DOWN (ARG)\n call SORT_INPLACE_UP (ARG)\n\n The GRADE versions are especially useful with sorting arrays of derived\n types. Once the permutation vector has been obtained, the individual\n elements can be accessed or permuted as needed:\n\n type(mytype_t), allocatable :: my_array(:), my_sorted_array(:)\n integer, allocatable :: perm_vector(:)\n :\n perm_vector = GRADE_UP (my_array%key_value)\n my_sorted_array = my_array(perm_vector)\n\n or even:\n\n my_sorted_array = my_array(GRADE_UP (my_array%key_value))\n\n \u2014\n Reply to this email directly, view it on GitHub\n , or\n unsubscribe\n\n .\n You are receiving this because you are subscribed to this thread.Message\n ID: ***@***.***>\n\n\u2014\nReply to this email directly, view it on GitHub (#258 (comment)), or unsubscribe (https://github.com/notifications/unsubscribe-auth/ABCNQO74URLDZWPFTRQOQRDVGVZVZANCNFSM5UGOXWPQ).\nYou are receiving this because you authored the thread.Message ID:\n\n\u00a0"
                },
                {
                    "user": "wyphan",
                    "date": "2022-04-24 16:49:00+00:00",
                    "text": "The DIM= argument can be optional. Then the GRADE_DOWN and GRADE_UP intrinsic functions can be made ELEMENTAL so it applies to arrays. Maybe add an AXIS= argument too to indicate which dimensions of the array will be sorted."
                },
                {
                    "user": "w6ws",
                    "date": "2022-04-24 16:53:32+00:00",
                    "text": "I found the DIM= in the original HPF specs to be confusing and ultimately not very useful.\u00a0 It just complicated, both from an implementation and usability point of view, what should have been a very simple API.\u00a0 So I'm not personally a proponent of it.\n\u00a0\nWalter\n\u00a0\n-----Original Message-----\nFrom: j3-fortran/fortran_proposals\nSent: Apr 24, 2022 9:49 AM\nTo: j3-fortran/fortran_proposals\nCc: Walter Spector , Author\nSubject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics (Issue #258)\n\u00a0\n\u00a0\nThe DIM= argument can be optional. Then the GRADE_DOWN and GRADE_UP intrinsic functions can be made ELEMENTAL so it applies to arrays. Maybe add an AXIS= argument too to indicate which dimensions of the array will be sorted.\n\u2014\nReply to this email directly, view it on GitHub (#258 (comment)), or unsubscribe (https://github.com/notifications/unsubscribe-auth/ABCNQO2D5WZHQ5AEHH42QQLVGV3QNANCNFSM5UGOXWPQ).\nYou are receiving this because you authored the thread.Message ID:\n\n\u00a0"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-24 17:00:47+00:00",
                    "text": "Mathematical definitions are in my dissertation. If you\u2019d like to speak to the original designer and implementor grade up and down in APL It is Luther Woodrum and he can be reached at\nlex@skyelogic.org"
                },
                {
                    "user": "w6ws",
                    "date": "2022-04-24 17:21:44+00:00",
                    "text": "LOL!\u00a0 Yes, I learned a bit about APL back in college (on a DECsystem-10).\u00a0 My copy of the classic Sandra Pakin APL/360 manual from those days uses the terms \"grade up\" and \"grade down\" for the respective operators.\u00a0 So I thought it was fun that the HPF group used the same for their functions.\u00a0 It is also interesting that HPF 1 only had the grade functions.\u00a0 HPF 2.0 added the sort functions.\n\u00a0\nI also have a copy of Ken Iversons \"A Programming Language\".\u00a0 It has quite a lot of prose on ranking and sorting, but doesn't specifically use those terms.\n\u00a0\nWalter\n\u00a0\n-----Original Message-----\nFrom: j3-fortran/fortran_proposals\nSent: Apr 24, 2022 10:00 AM\nTo: j3-fortran/fortran_proposals\nCc: Walter Spector , Author\nSubject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics (Issue #258)\n\u00a0\n\u00a0\nMathematical definitions are in my dissertation. If you\u2019d like to speak to the original designer and implementor grade up and down in APL It is Luther Woodrum and he can be reached at\n***@***.*** ***@***.***)\n\u2014\nReply to this email directly, view it on GitHub (#258 (comment)), or unsubscribe (https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3VGV44TANCNFSM5UGOXWPQ).\nYou are receiving this because you authored the thread.Message ID:\n\n\u00a0"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-24 17:35:54+00:00",
                    "text": "Like I said , contact Luther for history and details.\nOn Sun, Apr 24, 2022 at 1:21 PM Walter Spector ***@***.***> wrote:\n LOL!  Yes, I learned a bit about APL back in college (on a DECsystem-10).\n My copy of the classic Sandra Pakin APL/360 manual from those days uses the\n terms \"grade up\" and \"grade down\" for the respective operators.  So I\n thought it was fun that the HPF group used the same for their functions.\n It is also interesting that HPF 1 only had the grade functions.  HPF 2.0\n added the sort functions.\n\n I also have a copy of Ken Iversons \"A Programming Language\".  It has quite\n a lot of prose on ranking and sorting, but doesn't specifically use those\n terms.\n\n Walter\n\n -----Original Message-----\n From: j3-fortran/fortran_proposals\n Sent: Apr 24, 2022 10:00 AM\n To: j3-fortran/fortran_proposals\n Cc: Walter Spector , Author\n Subject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics\n (Issue #258)\n\n\n Mathematical definitions are in my dissertation. If you\u2019d like to speak to\n the original designer and implementor grade up and down in APL It is Luther\n Woodrum and he can be reached at\n ***@***.*** ***@***.***)\n \u2014\n Reply to this email directly, view it on GitHub (\n #258 (comment)),\n or unsubscribe (\n https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3VGV44TANCNFSM5UGOXWPQ\n ).\n You are receiving this because you authored the thread.Message ID:\n\n\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#258 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ABVSNFA3B5YDWLJ6TWVCAL3VGV7LFANCNFSM5UGOXWPQ>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>\n\n-- \n\"Great spirits have always encountered violent opposition from mediocre\nminds\" - Albert Einstein"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-24 17:37:16+00:00",
                    "text": "That\u2019s because it was Luther\u2019s idea not Kens.\nThat\u2019s why it\u2019s not in kens book .\nOn Sun, Apr 24, 2022 at 1:21 PM Walter Spector ***@***.***> wrote:\n LOL!  Yes, I learned a bit about APL back in college (on a DECsystem-10).\n My copy of the classic Sandra Pakin APL/360 manual from those days uses the\n terms \"grade up\" and \"grade down\" for the respective operators.  So I\n thought it was fun that the HPF group used the same for their functions.\n It is also interesting that HPF 1 only had the grade functions.  HPF 2.0\n added the sort functions.\n\n I also have a copy of Ken Iversons \"A Programming Language\".  It has quite\n a lot of prose on ranking and sorting, but doesn't specifically use those\n terms.\n\n Walter\n\n -----Original Message-----\n From: j3-fortran/fortran_proposals\n Sent: Apr 24, 2022 10:00 AM\n To: j3-fortran/fortran_proposals\n Cc: Walter Spector , Author\n Subject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics\n (Issue #258)\n\n\n Mathematical definitions are in my dissertation. If you\u2019d like to speak to\n the original designer and implementor grade up and down in APL It is Luther\n Woodrum and he can be reached at\n ***@***.*** ***@***.***)\n \u2014\n Reply to this email directly, view it on GitHub (\n #258 (comment)),\n or unsubscribe (\n https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3VGV44TANCNFSM5UGOXWPQ\n ).\n You are receiving this because you authored the thread.Message ID:\n\n\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#258 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ABVSNFA3B5YDWLJ6TWVCAL3VGV7LFANCNFSM5UGOXWPQ>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>\n\n-- \n\"Great spirits have always encountered violent opposition from mediocre\nminds\" - Albert Einstein"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-24 19:28:43+00:00",
                    "text": "Ken never had indexing either. Luther was the first to introduce any kind\nof indexing in APL.\nBTW, he also has mucho patents on his sorting algorithms.\n\nOn Sun, Apr 24, 2022 at 1:37 PM Lenore Mullin ***@***.***>\nwrote:\n\u2026\n That\u2019s because it was Luther\u2019s idea not Kens.\n That\u2019s why it\u2019s not in kens book .\n\n\n On Sun, Apr 24, 2022 at 1:21 PM Walter Spector ***@***.***>\n wrote:\n\n> LOL!  Yes, I learned a bit about APL back in college (on a\n> DECsystem-10).  My copy of the classic Sandra Pakin APL/360 manual from\n> those days uses the terms \"grade up\" and \"grade down\" for the respective\n> operators.  So I thought it was fun that the HPF group used the same for\n> their functions.  It is also interesting that HPF 1 only had the grade\n> functions.  HPF 2.0 added the sort functions.\n>\n> I also have a copy of Ken Iversons \"A Programming Language\".  It has\n> quite a lot of prose on ranking and sorting, but doesn't specifically use\n> those terms.\n>\n> Walter\n>\n> -----Original Message-----\n> From: j3-fortran/fortran_proposals\n> Sent: Apr 24, 2022 10:00 AM\n> To: j3-fortran/fortran_proposals\n> Cc: Walter Spector , Author\n> Subject: Re: [j3-fortran/fortran_proposals] Add simple sorting intrinsics\n> (Issue #258)\n>\n>\n> Mathematical definitions are in my dissertation. If you\u2019d like to speak\n> to the original designer and implementor grade up and down in APL It is\n> Luther Woodrum and he can be reached at\n> ***@***.*** ***@***.***)\n> \u2014\n> Reply to this email directly, view it on GitHub (\n> #258 (comment)),\n> or unsubscribe (\n> https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3VGV44TANCNFSM5UGOXWPQ\n> ).\n> You are receiving this because you authored the thread.Message ID:\n>\n>\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <#258 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABVSNFA3B5YDWLJ6TWVCAL3VGV7LFANCNFSM5UGOXWPQ>\n> .\n> You are receiving this because you commented.Message ID:\n> ***@***.***>\n>\n --\n \"Great spirits have always encountered violent opposition from mediocre\n minds\" - Albert Einstein\n\n\n-- \n\"Great spirits have always encountered violent opposition from mediocre\nminds\" - Albert Einstein"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-25 12:40:53+00:00",
                    "text": "That's very funny.\nI was the one who first implemented mulidimensionaional arrays\nof more than two. All the ones before that were only for\nmatrices, two dimensions.\n\nI implemented 7 dimensions.\n\nLW\n\u2026\nOn Sun, 24 Apr 2022, Lenore Mullin wrote:\n Ken never had indexing either. Luther was the first to introduce any kind of\n indexing in APL.BTW, he also has mucho patents on his sorting algorithms.\n\n On Sun, Apr 24, 2022 at 1:37 PM Lenore Mullin ***@***.***>\n wrote:\n       That\u2019s because it was Luther\u2019s idea not Kens.\n That\u2019s why it\u2019s not in kens book .\n\n\n On Sun, Apr 24, 2022 at 1:21 PM Walter Spector\n ***@***.***> wrote:\n\n       LOL!\u00a0 Yes, I learned a bit about APL back in college (on a\n       DECsystem-10).\u00a0 My copy of the classic Sandra Pakin\n       APL/360 manual from those days uses the terms \"grade up\"\n       and \"grade down\" for the respective operators.\u00a0 So I\n       thought it was fun that the HPF group used the same for\n       their functions.\u00a0 It is also interesting that HPF 1 only\n       had the grade functions.\u00a0 HPF 2.0 added the sort\n       functions.\n       \u00a0\n       I also have a copy of Ken Iversons \"A Programming\n       Language\".\u00a0 It has quite a lot of prose on ranking and\n       sorting, but doesn't specifically use those terms.\n       \u00a0\n       Walter\n       \u00a0\n       -----Original Message-----\n       From: j3-fortran/fortran_proposals\n       Sent: Apr 24, 2022 10:00 AM\n       To: j3-fortran/fortran_proposals\n       Cc: Walter Spector , Author\n       Subject: Re: [j3-fortran/fortran_proposals] Add simple\n       sorting intrinsics (Issue #258)\n       \u00a0\n       \u00a0\n       Mathematical definitions are in my dissertation. If you\u2019d\n       like to speak to the original designer and implementor\n       grade up and down in APL It is Luther Woodrum and he can\n       be reached at\n       ***@***.*** ***@***.***)\n       \u2014\n       Reply to this email directly, view it on GitHub(#258 (comment)\n       07878967), or unsubscribe(https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3V\n       GV44TANCNFSM5UGOXWPQ).\n       You are receiving this because you authored the\n       thread.Message ID:\n\n       \u00a0\n\n       \u2014\n       Reply to this email directly, view it on GitHub, or\n       unsubscribe.\n       You are receiving this because youcommented.[ABVSNFEJ7TVCTOPYCEAQSIDVGV7LFA5CNFSM5UGOXWP2YY3PNVWWK3TUL52HS4DF\n       VREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOIIEPFVA.gif]\n       Message ID:\n       ***@***.***>\n\n --\n \"Great spirits have always encountered violent opposition from\n mediocre minds\" - Albert Einstein\n\n\n\n --\n \"Great spirits have always encountered violent opposition from mediocre\n minds\" - Albert Einstein"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-25 12:44:23+00:00",
                    "text": "Exactly!\n\u2026\nOn Mon, Apr 25, 2022 at 8:40 AM Luther Woodrum ***@***.***> wrote:\n That's very funny.\n I was the one who first implemented mulidimensionaional arrays\n of more than two. All the ones before that were only for\n matrices, two dimensions.\n\n I implemented 7 dimensions.\n\n LW\n\n On Sun, 24 Apr 2022, Lenore Mullin wrote:\n\n > Ken never had indexing either. Luther was the first to introduce any\n kind of\n > indexing in APL.BTW, he also has mucho patents on his sorting algorithms.\n >\n > On Sun, Apr 24, 2022 at 1:37 PM Lenore Mullin ***@***.***>\n > wrote:\n >       That\u2019s because it was Luther\u2019s idea not Kens.\n > That\u2019s why it\u2019s not in kens book .\n >\n >\n > On Sun, Apr 24, 2022 at 1:21 PM Walter Spector\n > ***@***.***> wrote:\n >\n >       LOL!  Yes, I learned a bit about APL back in college (on a\n >       DECsystem-10).  My copy of the classic Sandra Pakin\n >       APL/360 manual from those days uses the terms \"grade up\"\n >       and \"grade down\" for the respective operators.  So I\n >       thought it was fun that the HPF group used the same for\n >       their functions.  It is also interesting that HPF 1 only\n >       had the grade functions.  HPF 2.0 added the sort\n >       functions.\n >\n >       I also have a copy of Ken Iversons \"A Programming\n >       Language\".  It has quite a lot of prose on ranking and\n >       sorting, but doesn't specifically use those terms.\n >\n >       Walter\n >\n >       -----Original Message-----\n >       From: j3-fortran/fortran_proposals\n >       Sent: Apr 24, 2022 10:00 AM\n >       To: j3-fortran/fortran_proposals\n >       Cc: Walter Spector , Author\n >       Subject: Re: [j3-fortran/fortran_proposals] Add simple\n >       sorting intrinsics (Issue #258)\n >\n >\n >       Mathematical definitions are in my dissertation. If you\u2019d\n >       like to speak to the original designer and implementor\n >       grade up and down in APL It is Luther Woodrum and he can\n >       be reached at\n >       ***@***.*** ***@***.***)\n >       \u2014\n >       Reply to this email directly, view it on GitHub(\n #258 (comment)\n >       07878967), or unsubscribe(\n https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQOVONHV2BV3V\n >       GV44TANCNFSM5UGOXWPQ).\n >       You are receiving this because you authored the\n >       thread.Message ID:\n >\n >\n >\n >       \u2014\n >       Reply to this email directly, view it on GitHub, or\n >       unsubscribe.\n >       You are receiving this because\n youcommented.[ABVSNFEJ7TVCTOPYCEAQSIDVGV7LFA5CNFSM5UGOXWP2YY3PNVWWK3TUL52HS4DF\n >       VREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOIIEPFVA.gif]\n >       Message ID:\n >       ***@***.***>\n >\n > --\n > \"Great spirits have always encountered violent opposition from\n > mediocre minds\" - Albert Einstein\n >\n >\n >\n > --\n > \"Great spirits have always encountered violent opposition from mediocre\n > minds\" - Albert Einstein\n >\n >\n\n-- \n\"Great spirits have always encountered violent opposition from mediocre\nminds\" - Albert Einstein"
                },
                {
                    "user": "womenflyplanes",
                    "date": "2022-04-25 14:14:22+00:00",
                    "text": "Bye the way, how long has fortran had multidimensional arrays?\nLW\n\u2026\nOn Mon, 25 Apr 2022, Lenore Mullin wrote:\n Exactly!\n\n On Mon, Apr 25, 2022 at 8:40 AM Luther Woodrum ***@***.***> wrote:\n       That's very funny.\n       I was the one who first implemented mulidimensionaional arrays\n       of more than two. All the ones before that were only for\n       matrices, two dimensions.\n\n       I implemented 7 dimensions.\n\n       LW\n\n       On Sun, 24 Apr 2022, Lenore Mullin wrote:\n\n       > Ken never had indexing either. Luther was the first to\n       introduce any kind of\n       > indexing in APL.BTW, he also has mucho patents on his sorting\n       algorithms.\n       >\n       > On Sun, Apr 24, 2022 at 1:37 PM Lenore Mullin\n       ***@***.***>\n       > wrote:\n       >\u00a0 \u00a0 \u00a0 \u00a0That\u2019s because it was Luther\u2019s idea not Kens.\n       > That\u2019s why it\u2019s not in kens book .\n       >\n       >\n       > On Sun, Apr 24, 2022 at 1:21 PM Walter Spector\n       > ***@***.***> wrote:\n       >\n       >\u00a0 \u00a0 \u00a0 \u00a0LOL!\u00a0 Yes, I learned a bit about APL back in college (on\n       a\n       >\u00a0 \u00a0 \u00a0 \u00a0DECsystem-10).\u00a0 My copy of the classic Sandra Pakin\n       >\u00a0 \u00a0 \u00a0 \u00a0APL/360 manual from those days uses the terms \"grade up\"\n       >\u00a0 \u00a0 \u00a0 \u00a0and \"grade down\" for the respective operators.\u00a0 So I\n       >\u00a0 \u00a0 \u00a0 \u00a0thought it was fun that the HPF group used the same for\n       >\u00a0 \u00a0 \u00a0 \u00a0their functions.\u00a0 It is also interesting that HPF 1 only\n       >\u00a0 \u00a0 \u00a0 \u00a0had the grade functions.\u00a0 HPF 2.0 added the sort\n       >\u00a0 \u00a0 \u00a0 \u00a0functions.\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\u00a0 \u00a0 \u00a0 \u00a0I also have a copy of Ken Iversons \"A Programming\n       >\u00a0 \u00a0 \u00a0 \u00a0Language\".\u00a0 It has quite a lot of prose on ranking and\n       >\u00a0 \u00a0 \u00a0 \u00a0sorting, but doesn't specifically use those terms.\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\u00a0 \u00a0 \u00a0 \u00a0Walter\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\u00a0 \u00a0 \u00a0 \u00a0-----Original Message-----\n       >\u00a0 \u00a0 \u00a0 \u00a0From: j3-fortran/fortran_proposals\n       >\u00a0 \u00a0 \u00a0 \u00a0Sent: Apr 24, 2022 10:00 AM\n       >\u00a0 \u00a0 \u00a0 \u00a0To: j3-fortran/fortran_proposals\n       >\u00a0 \u00a0 \u00a0 \u00a0Cc: Walter Spector , Author\n       >\u00a0 \u00a0 \u00a0 \u00a0Subject: Re: [j3-fortran/fortran_proposals] Add simple\n       >\u00a0 \u00a0 \u00a0 \u00a0sorting intrinsics (Issue #258)\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\u00a0 \u00a0 \u00a0 \u00a0Mathematical definitions are in my dissertation. If\n       you\u2019d\n       >\u00a0 \u00a0 \u00a0 \u00a0like to speak to the original designer and implementor\n       >\u00a0 \u00a0 \u00a0 \u00a0grade up and down in APL It is Luther Woodrum and he can\n       >\u00a0 \u00a0 \u00a0 \u00a0be reached at\n       >\u00a0 \u00a0 \u00a0 \u00a0***@***.*** ***@***.***)\n       >\u00a0 \u00a0 \u00a0 \u00a0\u2014\n       >\u00a0 \u00a0 \u00a0 \u00a0Reply to this email directly, view it onGitHub(#258 (comment)\n       ent-11\n       >\u00a0 \u00a0 \u00a0 \u00a007878967), orunsubscribe(https://github.com/notifications/unsubscribe-auth/ABCNQO35Q4BDQ\n       OVONHV2BV3V\n       >\u00a0 \u00a0 \u00a0 \u00a0GV44TANCNFSM5UGOXWPQ).\n       >\u00a0 \u00a0 \u00a0 \u00a0You are receiving this because you authored the\n       >\u00a0 \u00a0 \u00a0 \u00a0thread.Message ID:\n       >\n       >\u00a0 \u00a0 \u00a0 \u00a0\u00a0\n       >\n       >\u00a0 \u00a0 \u00a0 \u00a0\u2014\n       >\u00a0 \u00a0 \u00a0 \u00a0Reply to this email directly, view it on GitHub, or\n       >\u00a0 \u00a0 \u00a0 \u00a0unsubscribe.\n       >\u00a0 \u00a0 \u00a0 \u00a0You are receiving this becauseyoucommented.[ABVSNFEJ7TVCTOPYCEAQSIDVGV7LFA5CNFSM5UGOXWP2YY3PNVWWK3TUL52HS\n       4DF\n       >\u00a0 \u00a0 \u00a0 \u00a0VREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOIIEPFVA.gif]\n       >\u00a0 \u00a0 \u00a0 \u00a0Message ID:\n       >\u00a0 \u00a0 \u00a0\n       ***@***.***>\n       >\n       > --\n       > \"Great spirits have always encountered violent opposition from\n       > mediocre minds\" - Albert Einstein\n       >\n       >\n       >\n       > --\n       > \"Great spirits have always encountered violent opposition from\n       mediocre\n       > minds\" - Albert Einstein\n       >\n       >\n\n --\n \"Great spirits have always encountered violent opposition from mediocre\n minds\" - Albert Einstein"
                }
            ]
        },
        {
            "number": 257,
            "user": "septcolor",
            "date": "2022-04-21 01:49:36+00:00",
            "title": "Allow more readable integer assignment in the namelist input",
            "text": "I have been using namelist input files extensively in my codes. While they are very useful, one weak point is that integer assignment allows only this kind of \"raw\" notation\n...\npar%nsteps = 1000000\npar%nsteps2 = 100000\npar%nsteps3 = 10000000\n...\n\n(here, par is some parameter object). Very often, the number of steps like above is rather large, which is often not very readable. I tried using the usual notation like\n...\npar%nsteps = 10**6\npar%nsteps2 = 10**5\npar%nsteps3 = 10**7\n...\n\nbut it interferes with the special meaning of * in the namelist and results in a runtime error. So I wish some other syntax would be available, e.g.,\n...\npar%nsteps = 1_000_000\npar%nsteps2 = 100_000\npar%nsteps3 = 10_000_000\n...\n\nor\n...\npar%nsteps = 10^6\npar%nsteps2 = 10^5\npar%nsteps3 = 10^7\n...\n\nIf the symbols like * or ^ are not acceptable, some kind of \"math\" string (e.g. m\"...\") may be useful for internal conversion (from math strings to integer in this case).\n...\npar%nsteps = m\" 10**6 \"\npar%nsteps2 = m\" 10**5 \"\npar%nsteps3 = m\" 10**7 \"\n...\n\nApart from the specific syntax, I hope I can also write nsteps = 2 * 10^7 rather than nsteps = 20000000, because I need to count the number of zeros every time with mouse cursor.\n(Edit) Because the math evaluation like sqrt() seems like too far as a request, I deleted it from the original post. My intention is not a \"general\" expression evaluator, but just the above kind of large integers (at the moment).",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2022-04-21 02:15:33+00:00",
                    "text": "@septcolor ,\nToward your first item, how about using the scientific format instead which is already supported?\n   real :: x\n   namelist / dat / x\n   character(len=:), allocatable :: s\n   s = \"&dat x=1e6 /\"\n   read( s, nml=dat )\n   print *, \"x = \", x\nend\n\nC:\\temp>gfortran p.f90 -o p.exe\nC:\\temp>p.exe\nx =    1000000.00\n\nAs to your second suggestion, it appears a bridge too far.  As you pointed out, you already have the problem with the repeat count (*) that makes the multiplication operation complicated.  And that's just the beginning of complexity.\nYou might consider an expression evaluator library instead that you integrate with your codes and which then parse string \"data\" to evaluate the expressions."
                },
                {
                    "user": "septcolor",
                    "date": "2022-04-21 02:38:34+00:00",
                    "text": "Hi @FortranFan ,\n(Edit: I have just updated the original post and title, such that it focuses only on large integers (which is one of my \"pain points\" for namelist input.)\nThanks much for your suggestion. I've just tried your snippet, but noticed that x is real (and yes, in this case the scientific notation works!). However, if the namelist variable is integer, it results in a runtime error (at least for Gfortran-10), as follows...\n   integer :: x\n   namelist / dat / x\n   character(len=:), allocatable :: s\n   s = \"&dat x=1e6 /\"\n   read( s, nml=dat )\n   print *, \"x = \", x\nend\n\n$ gfortran-10 test.f90 && ./a.out\nFortran runtime error: Cannot match namelist object name e6\n\nAnd I agree that the namelist input has a lot of \"weird\" rules (maybe for historical reasons), so I wonder if there could be some way to entirely work around those limitations, while keeping the convenience of namelist input.\nRE expression evaluators, that would be one approach if I really want math expressions in the input files. But one of the most appealing points of namelist (to me) is that it can fill values directly in the specified components of a given derived type. I usually set up \"parameter type\" objects and read all parameters, e.g., as\nsubroutine X_readpar( par )   !! where X is some tag/name/etc\ntype(Xpar_t) :: par\nnamelist / Xinp / par\n...\nread( file, nml = Xinp )\n...\n\nand the caller passes par as a component of a parent type\ncall  X_readpar( xobj % par )     !! where obj is an instance of type X, for example\n\nProbably, this kind of \"direct filling\" of type components cannot be done via 3rd-party expression evaluators. Another approach is to use external input libraries like TOML, which may read in values into some dictionary object inside Fortran. However, in this case I have to copy necessary type components again from the dictionary to the derived-type object manually, which is just too tedious (to me) if the number of parameters is large... (One method may be to use such a dictionary directly inside the program, but I guess the code becomes more verbose everywhere, probably, as compared to just using the type components.)"
                }
            ]
        },
        {
            "number": 256,
            "user": "sblionel",
            "date": "2022-03-28 13:55:27+00:00",
            "title": "Option to have interoperable types packed",
            "text": "I was helping someone in the ifort forum where they wanted to declare a derived type for the BMP (bitmap) file header. This is a 14-byte structure with two misaligned 32-bit integers. The problem is that there is no standard Fortran way to declare this. A SEQUENCE type allows the compiler to insert padding but doesn't specify it - some compilers do by default, some don't. An interoperable type requires padding if the \"companion C processor\" would do so, and in the absence of #pragma pack, they generally would.\nI would like to see an option for declaring an interoperable type that says \"do what the C processor would do if #pragma pack were in effect\". A possible syntax would be:\ntype, bind(C,PACK) :: mytype\nGiven my usual dislike of one-way options, I'd also want to see NOPACK as a choice.",
            "is_open": false,
            "labels": [
                "unsubmitted",
                "Fortran 202y",
                "Clause 7",
                "Clause 18"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-03-28 19:43:02+00:00",
                    "text": "Some target architectures signal bus errors on misaligned memory references; others don't (at least not on some types of references) but can suffer silent performance degradation.  So supporting misaligned components in general would be hard to make portable.  You'd have to worry about whether to allow them as actual arguments and pointer targets, too.\nPossible alternative solution for this use case, assuming that it was trying to use unformatted I/O on BMP files: make unformatted I/O of sequence &/or interoperable types skip over padding; i.e., the on-disk data would be packed, but the in-core data would be aligned.  Easy to do, and wouldn't affect \"normal\" programs a all.\nAre there use cases for misaligned components other than serialization and deserialization?  It seems like this BMP case could also be handled in portable Fortran pretty easily with TRANSFER to/from a byte array."
                },
                {
                    "user": "sblionel",
                    "date": "2022-03-28 21:13:16+00:00",
                    "text": "There are numerous APIs I have seen with misaligned fields, and the C headers for them have #pragma pack. I agree, and in fact suggested to the user, that TRANSFER here would not be too annoying, but I can imagine other cases where it would be more complex. As I see it, this is an improvement to interoperability that is easy to explain and has minimal impact on the language."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-28 21:26:53+00:00",
                    "text": "Be advised, \"#pragma pack\" is not part of a C/C++ standard; neither is GCC's __attribute__((packed)).\nWill there be restrictions on references to misaligned components?  Pointers to them?  Usage as actual arguments?  This is a feature that will have some subtle implications, if you want misaligned components to be first-class variables.  For example, passing a misaligned component as an actual argument associated with an dummy with the TARGET attribute requires additional semantics in the subclause that effectively limits the lifetime of validity of a pointer that's been aimed at the dummy argument, so as to allow for copy in/out.\n(Unless you want to simply state that the program does anything but TRANSFER() and unformatted I/O with misaligned components at its own risk, which would be what \"minimal impact\" on Fortran would have to look like.)"
                },
                {
                    "user": "sblionel",
                    "date": "2022-03-29 07:08:32+00:00",
                    "text": "Thanks for that insight, @klausler . I am not conversant with the C standard and had thought that #pragma pack was standard. Now that I know it isn\u2019t, I would not support this.\nI don\u2019t see the issues you do with misaligned components - Fortran programs deal with these all the time in other contexts."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-29 16:41:14+00:00",
                    "text": "Thanks for that insight, @klausler . I am not conversant with the C standard and had thought that #pragma pack was standard. Now that I know it isn\u2019t, I would not support this.\nI don\u2019t see the issues you do with misaligned components - Fortran programs deal with these all the time in other contexts.\n\n#pragma  is standard, but the specific pragmas are not.  #pragma pack is certainly a de facto standard.  I think that you could define this feature in a usable way without needed to define it in terms of ISO C/C++ standards."
                }
            ]
        },
        {
            "number": 255,
            "user": "aradi",
            "date": "2022-03-17 09:57:20+00:00",
            "title": "Forbidden assignment for derived types",
            "text": "When designing robust containers, it would be handy, if the assignment could be forbidden. Currently, this is only possible with overriding the assignment an raise an error at run-time, if it was invoked, but it would be desirable to get a compile time error instead.\nThe program below (as a very simple model for a container with finalizer) results in a double deallocation. If the assignment could be forbidden, the compiler would refuse to compile it.\nmodule mytype_module\n  implicit none\n\n  type :: mytype\n    integer, pointer :: ptr(:) => null()\n  contains\n    ! Forbid this type in any assignments (proposed syntax)\n    ! generic :: assignment(=) => null()\n    final :: mytype_final\n  end type mytype\n\ncontains\n\n  subroutine mytype_final(this)\n    type(mytype), intent(inout) :: this\n    if (associated(this%ptr)) deallocate(this%ptr)\n  end subroutine mytype_final\n\nend module mytype_module\n\n\nprogram test_mytype\n  use mytype_module\n  implicit none\n\n  type(mytype), allocatable :: inst1, inst2\n\n  allocate(inst1)\n  allocate(inst1%ptr(100), source=0)\n  ! This should generate a compiler error\n  inst2 = inst1\n  deallocate(inst1)\n  ! This will cause havoc due to double deallocation\n  deallocate(inst2)\n\nend program test_mytype\nOne would have to think, how deal with this during type extension, but probably would following work:\n\nAn extending type inherits the forbidden assignment from the parent type.\nAn extending type can not declare the assignment forbidden, if it was not done so in the parent type.\nAn extending type is allowed to declare a defined assignment, even if the assignment was forbidden in the parent type.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-03-17 16:18:18+00:00",
                    "text": "Fortran has intrinsic (\"default\") assignment, type-bound defined assignment (scalar only), and defined assignment via INTERFACE.  Which of these do you propose to disable with the new feature?"
                },
                {
                    "user": "aradi",
                    "date": "2022-03-17 16:44:20+00:00",
                    "text": "I'd say all of them, if possible, otherwise it would not make much sense. A type with a disabled assignment should not be accepted as argument of a subroutine which is in an interface assignment(=) block. A type with disabled assignment should not be allowed to stay on the LHS or RHS of an assignment a = b, independent, whether the defined or the intrinsic assignment would have to be invoked in the particular case."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-04-03 02:18:05+00:00",
                    "text": "@aradi,\nAs discussed elsewhere, you know well a poor Fortranner's approach to a \"smart pointer\" facility via a wrapper/container type toward your component with the POINTER attribute with such a wrapper type including a defined assignment provides a functional solution per the current standard.  The use case you show in the original post can  then work, say like this\nmodule mytype_module\n  use dat_m, only : dat_t !<-- USE a wrapper/container derived type with a defined assignment\n  type :: mytype\n    type(dat_t) :: dat\n  end type mytype\nend module mytype_module\nwhere a program does not encounter any of the problems with the instructions you've pointed out as being of concern, such as the assignment (inst2=inst1) or the deallocation of an RHS object (inst1).\nIn light of above and considering the lengths to which the standard seeks to make intrinsic assignment secure and useful, what you propose appears like taking a sledgehammer to a situation that is at times a gotcha upon unsuspecting Fortranners.  It will be unclear for a while how the readers as well as a standards committee will view the suggestion; I will be highly reluctant to vote to proceed with it if I were in such a situation.\nInstead of a solution proposal to forbid assignment in derived types, I suggest you first reach out to WG5 and J3 members and seek their views on the matter i.e., a \"raw pointer\" component in a derived type can be rather problematic and the authors have to take particular precautions such as with a wrapper type including a defined assignment in order to ensure safe consumption by users of such a type.  And that in the absence of support toward generics in the language, it can involve considerable \"boilerplate\" code which would need to be duplicated for each type, kind, and rank that may need to be wrapped in order to be consumed with the POINTER attribute.  You can then digest and distil the feedback to learn of the canonical view from the current members on this issue."
                }
            ]
        },
        {
            "number": 254,
            "user": "klausler",
            "date": "2022-03-14 18:11:52+00:00",
            "title": "Explicit lower bounds should be respected",
            "text": "subroutine gotcha(a)\n  real, intent(in) :: a(42:)\n  print *, lbound(a, dim=1)\nend subroutine\n\ncan print 42 or 1 depending on the size of the assumed-shape dummy argument.\nThis behavior is needlessly confusing, prevents a compiler from accepting some usage of LBOUND() in constant expressions, and raises obvious questions about underspecified semantics in the CFI_xxx APIs that establish lower bounds.\nEither LBOUND() should be adjusted or a new intrinsic function that is LBOUND() without the astonishing semantics should be added, and the semantics of lower bounds in the CFI_xxx APIs clarified in this edge case.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2022-03-14 18:25:15+00:00",
                    "text": "It seems it prints 1 for this:\nprogram x\nreal :: b(0)\ncall gotcha(b)\n\ncontains\n\nsubroutine gotcha(a)\n  real, intent(in) :: a(42:)\n  print *, lbound(a, dim=1)\nend subroutine\n\nend\nAnd 42 for any other size of b."
                },
                {
                    "user": "nncarlson",
                    "date": "2022-03-14 21:59:43+00:00",
                    "text": "Wow, I was not aware of this bizarre special case behavior of lbound until now.  What on earth was the motivation?  I often use the dim argument (I find it a real nuisance that lbound returns an array for a rank-1 array) assuming that it did the sensible thing. I've apparently just been lucky so far, but am wiser now."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-14 22:05:26+00:00",
                    "text": "LBOUND() without DIM= also substitutes 1 for an explicit lower bound on an empty dimension."
                },
                {
                    "user": "certik",
                    "date": "2022-03-14 22:30:19+00:00",
                    "text": "I find it a real nuisance that lbound returns an array for a rank-1 array\n\nThe same here. It just doesn't seem worth it, so I just use the default lower bound 1 in most of my procedures.\nRegarding the motivation for the above behavior, this program:\nprogram x\n\n    real :: b(0)\n\n    call gotcha(b)\n\ncontains\n\nsubroutine gotcha(a)\n  real, intent(in) :: a(42:)\n  print *, lbound(a, dim=1)\n  print *, ubound(a, dim=1)\nend subroutine\n\nend\nPrints:\n           1\n           0\n\nSo if you loop from lbound to ubound, the loop will be empty (as it should). So that works. Probably it would have been better if the program above printed:\n42\n41\n\nOr something like that."
                }
            ]
        },
        {
            "number": 253,
            "user": "everythingfunctional",
            "date": "2022-03-13 01:54:21+00:00",
            "title": "Simple Functions in Constant Expressions",
            "text": "The 202X standard will include a new attribute for procedures, simple. If a procedure is simple it depends on, and uses only its arguments, and calls only simple procedures. This means that, in theory, if a simple function's arguments are themselves constant expressions, it could be evaluated before program startup. I contend that this would be quite valuable for defining named constants of derived types whose components are private. For example given a string type defined like\nmodule string_m\n  implicit none\n  private\n  public :: string_t\n  type :: string_t\n    private\n    character(len=:), allocatable :: str_\n  end type\n\n  interface string_t\n    module procedure constructor\n  end interface\ncontains\n  simple function constructor(str) result(string)\n    character(len=*), intent(in) :: str\n    type(string_t) :: string\n\n    string%str_ = str\n  end function\nend module\nIt should be possible to define something like the following\ntype(string_t), parameter :: lines(*) =  &\n    [ string_t(\"Hello, World!\") &\n    , string_t(\"It's a great day!\") &\n    , string_t(\"Hooray Fortran!\") &\n    ]",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2022-03-13 02:39:43+00:00",
                    "text": "@everythingfunctional ,\nSIMPLE procedures, as developed in Fortran 202X, are not limited by constant expression considerations.\nPlease see this #214 which proposes CONSTEXPR procedures instead for user-defined functions in constant expressions.  There is a reason for this: there are certain difficult complications with Fortran standard semantics when it comes to allowing executable statements and constructs in constant expressions.\nConsider the string%str_ = str statement in your example code: I will spare commentary but you know there is a lot \"underneath\" this statement with allocation-upon-assignment that many a implementation handles only during run-time.   For these, what you propose is effectively a no-no.\nI have surmised improved compile-time computing is only amenable in Fortran with a rather limited set of instructions.  Having the ability to define them as CONSTEXPR procedures that essentially only include constant expression statements themselves which then enable certain code reuse and yield all the attendant benefits will be a good one to achieve for enhanced compile-time computing in Fortran 202Y.\nHence it will be helpful if you and others who see value in this proposal would also give a thumbs up for #214.\nThank you,"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-16 17:15:33+00:00",
                    "text": "@FortranFan , you honed right in on the complications and saw through my attempt not to specifically mention them. However, your assumption that constant expressions must be known at compile time is not quite true. In fact, the standard says nothing about compile time. It would be perfectly reasonable for constant expressions to be computed immediately prior to program execution (i.e. at program startup). In fact there are languages which do this. I believe initializing a constant value of a type with pointer members in C++ (i.e. it's components must be allocated on the heap), or even just a user defined constructor, is done exactly this way.\nPart of my reason for asking for this feature is specifically because I want to be able to define constants of types with allocatable components. Let alone be able to have those types keep their components private. I'll admit there might be some complications involved with this that I'm not quite seeing, but as far as being able to implement such a feature, I think it's absolutely feasible within the current standard."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-03-22 03:59:18+00:00",
                    "text": "@everythingfunctional wrote Mar. 16, 2022 1:15 PM EDT:\n\nyour assumption that constant expressions must be known at compile time is not quite true. In fact, the standard says nothing about compile time. It would be perfectly reasonable for constant expressions to be computed immediately prior to program execution (i.e. at program startup). In fact there are languages which do this.\n\nNote\n\nmy comments re: compile-time were only directed at the practitioners particularly with what they understand now re: the use of Fortran with current processors that involve compilation.  And how getting a fair amount of computing completed during that compilation phase can be beneficial in their programs.  I understand clearly the language standard says nothing about compile-time.\nFrom the language standard point-of-view, the existing semantics appear to be such at almost anything which constitutes an executable-construct is effectively a no-no in constant expressions, particularly what the language defines as action-stmt notwithstanding the assignment-stmt here refers to a variable and not a named constant:\nSure it may be viable with some processors to compute certain expressions and instructions prior to execution.  But as noticed time and again that does not help one bit with proposals to the standard.  The suggested changes and extensions have to fit with the entirety of the existing semantics and that is where the problems lie given how the \"limitations\" have been built into the language with constant expressions.\n\n\nI really think an attempt to get the standard to allow SIMPLE functions in constant expressions will not gain traction with the committee."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-22 16:34:22+00:00",
                    "text": "Poor persevering programmers preparing processors for practitioners can, perhaps, put some run-time \"constant\" expressions into play (initializer expressions), but perusing your published PDF produces a plethora of prohibited possibilities.  A plurality of points where \"scalar-int-constant-expr\" appears must positively produce proper constants, per se, post parsing.  Ponder real(kind=simplefunc()) :: x patiently."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-22 16:48:06+00:00",
                    "text": "real(kind=simplefunc()) :: x\n\nI see. This actually does pose a potential problem if the expression cannot be fully evaluated at compile time. But I still contend that CONSTEXPR would restrict one to what is effectively already doable via named constants (i.e. the parameter attribute).\nPerhaps I'm trying to apply this idea too broadly by utilizing an already existing aspect of the language. Perhaps what I'm really after is a new designation, something like \"initialization expression\". These could include the use of simple functions, and many places that require constant expressions now, could be relaxed to allow for initialization expressions. The kind value for an intrinsic type would then be a place that still requires a constant expression."
                },
                {
                    "user": "certik",
                    "date": "2022-03-22 18:42:01+00:00",
                    "text": "real(kind=simplefunc()) :: x\n\nIn LFortran we do two passes over the AST (Abstract Syntax Tree, the result of parsing), in the first pass we figure out types of all functions and variables (symbols), and we evaluate an expression like kind = simplefunc(), and currently such expressions can only use constants, arithmetic operations and intrinsic function calls, so it can be straightforwardly evaluated in the compiler itself, without executing any Fortran code (for example if you call sin(x), then we call our own implementation in C++). Then in the second pass we finish compiling the bodies of all functions and resolve all variables to (now existing) symbols in the symbol table.\nThis approach would obviously break if simplefunc() is a user defined function, as it would require to compile this function first and execute it, while figuring out the types of symbols.\nHowever, I think that can be done, I think one can allow executing of any function at compile time: as long as the function(s) can be actually compiled (all the types are known), then we can execute them while still compiling other code. Perhaps we can restrict it to only allow calling user defined functions from other modules, so we can still use the above two pass approach for a given module, but if another module is already compiled, we can execute functions from it. For example the Jai language allows executing of any code (including the whole program!) at compile time.\nThere is also a security and a performance implication: right now no user code is being run at compile time, only code that is already implemented in the compiler, so as long as there are no bugs in the compiler, it is currently safe to compile the whole code. Once we allow executing any random code at compile time, all kinds of things can happen:\n\nThe code could be malicious, so it could potentially be unsafe to compile Fortran code\nIt could take a very long time (including never finishing!) to compile Fortran code, if the user function is slow"
                },
                {
                    "user": "gklimowicz",
                    "date": "2022-03-24 16:50:34+00:00",
                    "text": "I may be an idiot, but how does using SIMPLE functions in initialization expressions work in a world of separate compilation? Only the interface may be known at compile time, not the implementation."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 17:08:16+00:00",
                    "text": "how does using SIMPLE functions in initialization expressions work in a world of separate compilation?\n\nThe expression isn't computed at compile time, it's computed at run time, prior to beginning execution of the main program."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 17:14:33+00:00",
                    "text": "In fact, it's a bit odd to me that compilers felt it acceptable that\nreal, parameter :: y = sin(1.0)\nprint *, y\nand\nreal :: x, y\n\nx = 1.0\ny = sin(x)\nprint *, y\nmight produce different outputs, since one math library would be used at compile time, but a different one used at run time."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 18:28:49+00:00",
                    "text": "I did think of a case that a proposal will need to prevent, a named constant defined in terms of a simple function that references it. I.e.\nmodule foo\n  implicit none\n\n  integer, parameter :: UH_OH = bar()\ncontains\n  simple function bar()\n    integer :: bar\n\n    bar = UH_OH\n  end function\nend module"
                },
                {
                    "user": "gklimowicz",
                    "date": "2022-03-24 18:30:10+00:00",
                    "text": "Yeah, that was the sort of thing I was thinking."
                },
                {
                    "user": "certik",
                    "date": "2022-03-24 18:33:36+00:00",
                    "text": "might produce different outputs, since one math library would be used at compile time, but a different one used at run time.\n\nWith optimizations enabled, as a user I would expect both to produce a compile time value, in this case identical value computed using the compile time (slow but more accurate) math library."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 18:44:19+00:00",
                    "text": "As a user, I'd expect the following program to always output \"T\", no matter what. But what are the actual chances of that? You can easily link to a math library that is different from the one used by the compiler. The choice of optimizations and link time options should not affect whether this program outputs \"T\" or \"F\". x = sin(1.0) should always be computed at program startup time, not compile time. If that's true, why can't user defined simple functions also be used there?\nprogram huh\n  implicit none\n  real, parameter :: x = sin(1.0)\n  real :: y\n\n  y = 1.0\n  print *, x == sin(y)\nend program"
                },
                {
                    "user": "certik",
                    "date": "2022-03-24 18:47:33+00:00",
                    "text": "Regarding your last example, one approach could be that the compiler only uses the \"more accurate\" math library when optimizations are enabled, thus this should still return T in most simple cases. In the standard \"Debug\" mode, the compiler can call the exact same math library for both compile time and runtime, thus also returning T.\nOn a broader issue, I never compare floating point numbers directly like this, but always with abs(x - sin(y)) < eps, in which case this will return T no matter what."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 18:52:55+00:00",
                    "text": "the compiler can call the exact same math library for both compile time and runtime\n\nThe compiler doesn't know the runtime math library. I.e.\n$ gfortran -c huh.f90 -o huh.o\n$ ld huh.o -lmkl -lgfortran -o huh # I don't know exactly what all the necessary libraries are, but you get the idea"
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 18:53:25+00:00",
                    "text": "As a user, I'd expect the following program to always output \"T\", no matter what.\n\nThat expectation turns out to be impossible in the face of separate compilation and link steps."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 19:00:44+00:00",
                    "text": "That expectation turns out to be impossible in the face of separate compilation and link steps.\n\nI think that's an artifact of current implementations, not a required implication of the standard. Nothing says that sin(1.0) must be evaluated at compile time, even in a constant expression. That calculation could be deferred to program startup and still be in conformance with the standard."
                },
                {
                    "user": "certik",
                    "date": "2022-03-24 19:03:02+00:00",
                    "text": "As @klausler said, if you want separate compilation and link steps, and as you @everythingfunctional showed that you can choose the runtime library later, it's hard to do, except deferring the evaluation of sin to runtime, but the problem is, as @klausler's example above (real(kind=simplefunc()) :: x) shows, sometimes you need to evaluate it at compile time, you can't defer it to runtime. I do think in most practical cases, such as your floating point example, things can be done at runtime though, just not in all cases."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 19:05:25+00:00",
                    "text": "real(kind=merge(kind(0.d0), kind(0.), sin(1.0) < cos(1.0)) :: x"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 19:20:26+00:00",
                    "text": "real(kind=merge(kind(0.d0), kind(0.), sin(1.0) < cos(1.0)) :: x\n\n\nThat one is at least definitely standards conforming. How about this one though?\nreal(kind=real_kinds(int(sin(1.5707963)))) :: x\nWhether or not that is standards conforming depends on the quality of the implementation of the sin function used at compile time. IMHO the allowance of implementation dependent functions in constant expressions was a mistake. To allow that mistake to get in the way of adding a feature to the language that implies deferring calculations of some constants to program startup time is a further mistake in my mind."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 19:46:21+00:00",
                    "text": "selected_real_kind is implementation-dependent, but I never see it used outside a constant expression that's necessary for typing at compilation time.\nIt is a strength of Fortran that nearly every intrinsic function, including most functions in the IEEE intrinsic modules, is available for use in constant expressions.  It takes a huge amount of effort to implement them fully -- see f18's here for an example that's nearly complete -- but it gives Fortran one of its few advantages over C++."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 20:16:33+00:00",
                    "text": "selected_real_kind is implementation-dependent, but I never see it used outside a constant expression that's necessary for typing at compilation time.\n\nIt seems I keep making broad generalizations where I should be more reserved and nuanced. I do appreciate all the insights this discussion has elicited.\nIt seems defining what I'm after will require more effort than I initially anticipated, but I'm still convinced much of it should be technically feasible and desirable. Being able to write what I have in my initial example is still something worth working towards I think."
                },
                {
                    "user": "certik",
                    "date": "2022-03-24 20:28:27+00:00",
                    "text": "@everythingfunctional if you are ok with manually inlining your functions, it looks like you can already do quite a bit at compile time: https://fortran-lang.discourse.group/t/computing-at-compile-time/3044"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 20:37:42+00:00",
                    "text": "That is a cool demonstration, but it still lacks two features I'd like.\n\nto be able to reuse somebody's existing library without having to manually inline all their calculations\nbe able to define constants of derived types with private and/or allocatable components"
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 21:00:01+00:00",
                    "text": "to be able to reuse somebody's existing library without having to manually inline all their calculations\n\n\nAllowing statement functions in constant expressions and modules would cover most of the use cases for that need, and would be way easier to implement than a constexpr function.  Yes, I know about statement functions being obsolescent, but they've been in the language since literally day 1 (longer than functions and subroutines) and aren't going anywhere.\n\n\nbe able to define constants of derived types with private and/or allocatable components\n\n\nWhat's wrong with using a function from the type's definition module to construct and return these, other than being unable to reference that function from an initialization expression?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-24 22:22:33+00:00",
                    "text": "other than being unable to reference that function from an initialization expression\n\nthat's exactly what I'm after\n\nAllowing statement functions in constant expressions and modules\n\nThat's an interesting idea, but are statement functions pure or simple? If you could designate them simple, I think that could be workable."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 23:01:35+00:00",
                    "text": "Statement functions can be considered pure if they reference only pure functions.  They're just wrappers around expressions, and contain no statements per se.  They can similarly also be considered simple if they reference no variables other than their arguments.  Either way, it's a trivial derived attribute."
                },
                {
                    "user": "klausler",
                    "date": "2022-03-24 23:12:05+00:00",
                    "text": "other than being unable to reference that function from an initialization expression\n\nthat's exactly what I'm after\n\nInitializers of variables, default initializers of components, or both?  They're not exactly the same problem, and may have distinct solution options."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-25 00:55:11+00:00",
                    "text": "Both. But I think allowing it in default initialization of components requires at least thinking about the context of initialization of variables. For example\ntype :: foo\n  integer :: bar = baz()\nend type\ntype(foo), parameter :: buzz = foo()\nOrdinarily the intrinsic structure constructor has optional arguments for components with default initializers, and they can be used to initialize a named constant of that type. So by allowing simple functions to be used in default initialization of components, you're kind of forced to allow them for named constants by proxy. That or carve out a weird exception for types who's default initializers aren't constant expressions.\nI think a spec like:\nAn initialization expression may contain a constant expression, or simple functions with actual arguments that are themselves initialization expressions.\nAn initialization expression can be used to define the value of a named constant, the initial value of a saved variable or the default value of a component of a derived type.\nA named constant whose value is not a constant expression may not be used in a constant expression.\nThat last statement is the weird bit with strange complications/implications, but gets around the problems in real(kind=simplefunc()) :: x because the kind parameter still requires a constant expression.\nThere's probably still some problematic aspects I haven't considered somewhere in there, but it seems like the right direction."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2022-03-28 02:11:40+00:00",
                    "text": "Just wanted to share experiences from the C++ world involving this kind of stuff.\nhttps://youtu.be/OcyAmlTZfgg"
                }
            ]
        },
        {
            "number": 252,
            "user": "egiovan",
            "date": "2022-03-12 10:41:34+00:00",
            "title": "Array broadcasting in expressions ",
            "text": "Array broadcasting is very common in Python with numpy and in Matlab.\nBoradcasting means that in an array expression if an array has a unitary dimension along an axis that dimension is automatically expanded to match the size of the other array. For example if an array has size [3,1] and another has size [1,4] both array are expanded as they have size [3,4]. In the actual Fortran one has to use spread to achieve the same result.\nAnother nice feature of numpy is the possibility to add unitary dimensions on the fly with None. Python example:\na = np.ones(2)\nb= np.ones(3)\na[:,None] * b[None,:]\n\nMoreover some functions that reduce the dimensionality like sum can have an extra arguments keepdims that doesn't reduce the dimensionality but make that dimension unitary. This is useful as one can write (in Python) somenthing like:\na/np.mean(a, axis=0,keepdims=True)\nSo I suggest the following feature:\nUse the symbol \"+\" (or whatever other symbol) to add a dimension to a section of an array. The function sum and other that reduce the dimensionality should have an extra keyword argument like keepdims that doesn't eliminate that dimension.\nAs an example:\ninteger :: a(3), b(4), c(3,4), d(4), i\na = [(i=1,3)]\nb = [(i=1,4)]\nc = a(:,+) + b(+,:)\nd = c/sum(c, dim=1, keepdim=.true.)\n\nContrary  what happen to Matlab and Python adding the extra dimension is obligatory (no implicit unary dimensions).",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2022-03-12 14:45:25+00:00",
                    "text": "@egiovan good idea especially about making it explicit. Do you know if this approach would allow all NumPy's broadcasting features? Or is there still some broadcasting operation in NumPy that your proposal still would not allow?"
                },
                {
                    "user": "egiovan",
                    "date": "2022-03-13 10:37:48+00:00",
                    "text": "As far as I know it is all you need.\nNumpy has also functions that returns broadcasted views of list of  arrays like:\nhttps://numpy.org/doc/stable/reference/generated/numpy.broadcast_arrays.html\nI think the broadcasted view can be obtained with a stride equal to zero. But it would be a mess as it cannot be definable, in python there is a warning when you try to assign values to broadcasted views. so I'm contrary to import a feature like this one.\nWhile sections with added unitary dimensions are perfectly safe, definable, etc.\nThe point is that you may not know, in general, if an expression will involve broadcasting at compile time (except for those simple examples), so at run time the processor has to check the extent of all the arrays involved in the array expression, and that may affect the speed. On the other hand it may be safer to require the processor to report if in array expressions the dimensions are not compatible. It may make the program a little slower but safer (with an explicit loop the burden should be all on the shoulder of the programmer)."
                },
                {
                    "user": "egiovan",
                    "date": "2022-03-13 13:11:03+00:00",
                    "text": "To make things more explicit one can add an attribute to arrays, like broadcastable which indicates that any unitary dimension of that array can be expanded.\nA section with an added dimension with \"+\" like in the previous example will be broadcastable, and the return of a function like the sum with keepdim will be broadcastable.\nAll other array expressions can remain as before, without the overhead to check the extent of all the involved arrays.\nBroadcastable pointers may have additional unitary dimension added in pointer assignments, like in\nptr(:, +) => b"
                },
                {
                    "user": "klausler",
                    "date": "2022-03-14 17:54:11+00:00",
                    "text": "SPREAD can be implemented without duplicating data.  This proposal seems to me to boil down to an automatic application of a non-duplicating SPREAD.  It might be better to use SPREAD and insist on better implementations."
                },
                {
                    "user": "egiovan",
                    "date": "2022-03-14 18:15:02+00:00",
                    "text": "I think it will also be clearer. For example:\ninteger :: a(2), b(3), c(4), d(2,3,4)\n\nd = a(: , + , +) * b(+, : ,+) * c(+, +, :) \n\nI wouldn't use spread in that case, it will be a mess.\nI would use a \"do concurrent\" in actual Fortran\ninteger :: i, j, k\ndo concurrent(i=1:2, j=1:3, k=1:4)\n   d(i, j, k) = a(i) * b(j) * d(k)\nenddo"
                }
            ]
        },
        {
            "number": 251,
            "user": "everythingfunctional",
            "date": "2022-03-03 02:39:48+00:00",
            "title": "Usable polymorphism in coarrays",
            "text": "Currently there are constraints preventing the use of polymorphism in coarrays. Specifically\n\nC917 (R911) Except as an actual argument to an intrinsic inquiry function or as the designator in a type parameter inquiry, a data-ref shall not be a coindexed object that has a polymorphic allocatable potential subobject component.\n\nand\n\nC918 Except as an actual argument to an intrinsic inquiry function or as the designator in a type parameter inquiry, if the rightmost part-ref is polymorphic, no other part-ref shall be coindexed.\n\nI suspect that it would be possible to rewrite these constraints in such a way to allow reference to a polymorphic entity on another image without allowing one image to perform an allocation on another. My proposed rewriting would be\n\nC917 If data-ref is a coindexed object that has a polymorphic allocatable potential subobject component it shall not appear in a variable definition context\n\nand\n\nC918 If the rightmost part-ref is polymorphic and any other part-ref is coindexed, the data-ref shall not appear in a variable definition context.\n\nI'm not sure if I've got the wording quite right, but I think this is doable.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-03-07 17:16:13+00:00",
                    "text": "These new versions of the constraints would be easy to check, and I haven't been able to come up with a failure mode that they might enable.  SGTM."
                }
            ]
        },
        {
            "number": 250,
            "user": "Soulagenda",
            "date": "2022-02-18 04:08:03+00:00",
            "title": "Allow for Variable expressions in Select Case",
            "text": "Because I tried to do this and it didn't work, so I am making a request for it to work.  I think it would be nice if it worked.\nIt went something like this\n\nInteger ::  iVar\nInteger, Allocatable :: VA, VB, VC, VD(:), VE, VF, VG, VH, VI, VJ   !They all will have a unique value\nReal, Allocatable :: VarArray(:)\nDoConcurrent (iVar:1, NVar)\nSelect Case (iVar)\nCase (VA, VB, VD, VE)\n...instruction1\nCase (VG, VH)\n.....instruction2\nCase Default\nEnd Select\nEnd do\n\nI am about to make myself dizzy attempting to create logic with if statements along with checking allocations and whatever else I'll have to do to make it work.\nIt would be nice for variables to be allowed in the Case() and those that are not allocated can be automatically ignored. I would use it for unique integers but in case some have equal value, select case will just choose the first case that has a match. For example, if iVar=VB=VG then the code will execute instructions for VB.\nThough this may result in some unintended consequences in code behavior for developers who may not be initially careful in ensuring uniqueness of variable values or properly tracking allocations. Such potential mishaps can be highlighted with warnings.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": []
        },
        {
            "number": 249,
            "user": "Beliavsky",
            "date": "2022-02-10 20:51:51+00:00",
            "title": "Allow alphanumeric line labels as goto target",
            "text": "On Fortran Discourse it was suggested (and I agree) that alphanumeric line labels be allowed, since\ngo to error_controller\n...\nerror_controller: If (error) then\n\nis more legible than\ngo to 1234\n...\n1234 If (error) then",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-02-10 21:00:38+00:00",
                    "text": "This will lead to ambiguity in cases like\ncharacter(80) fmt = \"('do you mean this one?')\"\nfmt: format('or this one?')\nwrite (6, fmt)\n\n      integer to, toto, tototo\n      to: continue\n      toto: continue\n      tototo: continue\n      assigntototototo\n\n      doiii=1,10\n      i: continue\n      ii: continue\n\ninteger label\nassign 1 to label\ngo to label\n1 print *, 'this one?'\nreturn\nlabel: print *, 'or this one?'"
                },
                {
                    "user": "Beliavsky",
                    "date": "2022-02-10 21:10:48+00:00",
                    "text": "Can the ambiguity be avoided by requiring that the line label not have the same name as any variable or named constant in the program unit?"
                },
                {
                    "user": "klausler",
                    "date": "2022-02-10 21:13:02+00:00",
                    "text": "That would invalidate existing conformant code."
                },
                {
                    "user": "certik",
                    "date": "2022-02-10 23:24:12+00:00",
                    "text": "One could perhaps allow the same labels and variable names, but not allowing to jump to them if they are the same. But the parsing can indeed be quite tricky, we should only do it if it doesn't complicate the parser further."
                },
                {
                    "user": "egiovan",
                    "date": "2022-03-09 17:40:02+00:00",
                    "text": "One may restrict the alphanumeric line label only to continue statements except when continue is terminating a loop.\nStrictly  speaking the assign statement is deleted feature, but I understand that the compilers have to support it anyway.\nAs a deleted feature it may continue to use only numeric labels.  The same for the do, the label if present, should be numeric. Moreover the new syntax may have the precedence.\nSo your first case will be illegal, the second compilation error as assign needs a numeric label, the third compilation error without an enddo, and the last one  print *,\"or this one\" as the new syntax should take the precedence."
                }
            ]
        },
        {
            "number": 248,
            "user": "Beliavsky",
            "date": "2022-02-01 13:47:02+00:00",
            "title": "add topics",
            "text": "I suggest that the topics fortran fortran202y be added in the About section. The generics repo https://github.com/j3-fortran/generics has those labels.",
            "is_open": true,
            "labels": [],
            "comments": []
        },
        {
            "number": 247,
            "user": "awvwgk",
            "date": "2022-01-27 19:49:05+00:00",
            "title": "Require ABI compatibility in ISO_Fortran_binding.h",
            "text": "Following a discussion on the Fortran-lang discourse (https://fortran-lang.discourse.group/t/2652) about ABI compatibility with ISO_Fortran_binding.h, I want to open this thread to discuss whether it is possible / feasible to require ABI compatibility for the CFI_* procedures and descriptors in a future revision on the standard.\nMotivation\n\nC provides a remarkable ABI compatibility across different compilers, which is available in Fortran via the Fortran 2008 and earlier bind(c) and iso_c_binding constructs\nextending this promise of ABI compatibility to the CFI_* procedures and descriptors would allow to develop robust interfaces from other languages to Fortran, which can work for all available conforming Fortran compilers\na language that cannot parse the C header should be able to define an interface via the CFI_* procedures, e.g. it should be possible with the Fortran 2008 C intercompatibility features to define the CFI_* descriptors and procedures independently of the actual vendor\n\nProposed changes\n\ndefine order of components in CFI_* descriptors\ndefine that the CFI_* procedures must be implemented as functions and cannot be macros which resolve to different functions\ndefine a robust way to store vendor specific data without interfering with ABI compatibility (e.g. as void* pointer in descriptor)\n\nThis is my first time contributing here. I'm looking forward to your feedback.",
            "is_open": true,
            "labels": [
                "Clause 18"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-01-27 20:01:53+00:00",
                    "text": "You would also need to:\n\ndefine specific integer values for all of the macros for CFI_type_XXX codes, attributes, &c.\ndefine specific types for all of the CFI typedefs (CFI_rank_t, CFI_index_t, CFI_attribute_t, &c.)\ndefine specific values for the CFI_XXX error codes\nconvince vendors to make necessary incompatible changes to their products\nconvince their users to recompile their codes\n\nSee https://github.com/llvm/llvm-project/blob/main/flang/include/flang/ISO_Fortran_binding.h for a complete example."
                },
                {
                    "user": "awvwgk",
                    "date": "2022-01-27 20:41:14+00:00",
                    "text": "convince vendors to make necessary incompatible changes to their products\nconvince their users to recompile their codes\n\n\nIndeed, this is an issue. It would be ABI breakage rather than API breakage, given that ABI compatibility is not guaranteed at the moment it might be feasible and still be a backwards compatible change in the standard. Correct?"
                },
                {
                    "user": "klausler",
                    "date": "2022-01-27 20:58:07+00:00",
                    "text": "convince vendors to make necessary incompatible changes to their products\nconvince their users to recompile their codes\n\n\nIndeed, this is an issue. It would be ABI breakage rather than API breakage, given that ABI breakage is not guaranteed at the moment it might be feasible and still be a backwards compatible change in the standard. Correct?\n\nI don't understand your question; but changing any of the values, types, or component orders in a compiler's ISO_Fortran_binding.h file is going to be a change that would prevent previously-compiled code from successfully linking with newly-compiled code when C interoperability is being used.  (Or even when it is not -- f18 uses this \"interoperable\" descriptor as its only Fortran data descriptor as well.)\nIf J3 had done a better job defining ISO_Fortran_binding.h with specific types, values, and struct layouts, we would have be able to use interoperable interfaces to link Fortran code compiled with different Fortran compilers, not just with C.  So what you propose would be great, had it been done 14 year ago.  At this point, though, it seems vanishingly unlikely that you would be able to convince any vendor to change their ISO_Fortran_binding.h file."
                }
            ]
        },
        {
            "number": 246,
            "user": "rikardn",
            "date": "2022-01-25 09:30:18+00:00",
            "title": "A simpler sign function",
            "text": "The current SIGN function is called the \"sign transfer function\" and takes two arguments making it a bit surprising. A plain one argument SIGN-function for all numeric types would be a nice addition.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2022-01-25 15:06:16+00:00",
                    "text": "Indeed, it is confusing to me also. I would expect a function that you call just like sign(x)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2022-01-25 16:15:41+00:00",
                    "text": "I always have to look up what the two argument are. And then also empirically figure out what it's going to do with 0."
                },
                {
                    "user": "certik",
                    "date": "2022-01-25 16:25:57+00:00",
                    "text": "Exactly, in fact I don't remember right now which ways the arguments to sign go. I have to look it up every single time."
                },
                {
                    "user": "klausler",
                    "date": "2022-01-25 17:10:07+00:00",
                    "text": "What would a one-argument SIGN function compute?  (If it's -1, 0, or 1, then Fortran already has that.  Oops, no, it doesn't, I confused it with \"signum\" in Haskell)"
                },
                {
                    "user": "rikardn",
                    "date": "2022-01-25 18:26:17+00:00",
                    "text": "As far as I can read in \"Modern Fortran explained\" by Metcalf et al. the only function named SIGN is the sign(a, b). The proposal would be to have a one argument version sign(a) that would return -1, 0 or 1 for all numeric a. I see that the current sign doesn't return 0, but instead give a positive sign for 0.\nI found the rationale for the sign(a, b). It is required by the IEEE 754 floating point standard to have a function\nsourceFormat copySign(source, source) (section 5.5.1 in IEEE Std 754-2008). This would be the current sign function in Fortran. This also explains why 0.0 would be positive since this number has the sign bit set to 0 in the IEEE 754 representation. Potentially -0.0 would give the opposite sign. With this background perhaps the proposed one argument sign would add to the confusion."
                },
                {
                    "user": "klausler",
                    "date": "2022-01-25 20:45:47+00:00",
                    "text": "That's the \"signum\" function of mathematics (and Haskell).  I was wrong when I said it was in Fortran -- the standard has a \"signum\" function, but it's in a code example."
                },
                {
                    "user": "gklimowicz",
                    "date": "2022-01-26 16:36:18+00:00",
                    "text": "Maybe we should add signum. Too late for 202x, but 202y...\nOr would there be any issue with having the second argument to \"sign\" become optional?"
                },
                {
                    "user": "klausler",
                    "date": "2022-01-26 16:48:02+00:00",
                    "text": "Maybe we should add signum. Too late for 202x, but 202y...\nOr would there be any issue with having the second argument to \"sign\" become optional?\n\nHaving the same name mean two completely different things based on the argument count?  Yes, that's an issue."
                },
                {
                    "user": "klausler",
                    "date": "2022-01-26 19:35:25+00:00",
                    "text": "Another \"issue\": if the second (B=) argument to SIGN were made optional, one wouldn't necessarily know at compilation time whether the intrinsic was meant to be a sign transfer or a signum until run time if the actual argument were an optional dummy argument being forwarded, a pointer, or an allocatable."
                }
            ]
        },
        {
            "number": 245,
            "user": "klausler",
            "date": "2022-01-23 20:06:59+00:00",
            "title": "Why enforce C1406?",
            "text": "\"C1406 (R1409) A scoping unit shall not directly reference an intrinsic module and a nonintrinsic module of the same name.\"\nIt might be confusing to have (say) a user-defined ISO_FORTRAN_ENV module in a program and reference it in a scope along with the intrinsic module of the same name, but so long as the USE statements are qualified with INTRINSIC and NON_INTRINSIC, there's no ambiguity.  So why impose this constraint?  It feels a bit like a restriction from an early implementation was resolved by fiat.\n(The constraint would have some justification if Fortran had module-qualified name references, but it doesn't.)",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2022-01-25 21:41:03+00:00",
                    "text": "One possible justification for C1406 has occurred to me: after the first USE, INTRINSIC or USE, NON_INTRINSIC of a particular module name in a scoping unit, later USE statements of the same module name don't have to also include the explicit INTRINSIC/NON_INTRINSIC.  It's not much, but it's reasonable.  Closing this issue."
                }
            ]
        },
        {
            "number": 244,
            "user": "omaclaren",
            "date": "2022-01-12 00:00:20+00:00",
            "title": "Allow array comprehension syntax in implied do loop",
            "text": "I would love the ability to do array comprehensions (a la Julia), i.e. the analogue of list comprehensions (Python, Haskell etc) in modern Fortran. This would be a syntactic extension to implied do loops as discussed here:\nhttps://fortran-lang.discourse.group/t/array-comprehensions-in-fortran/2517\nA suggested syntax (with example implementation) is given in this thread:\nhttps://fortran-lang.discourse.group/t/array-comprehensions-in-fortran/2517/10\nwhich is:\nlhs = [(some_expression(i), i = initial, final, step where condition(i))]\n\nThe thread also discusses why do concurrent doesn't quite work for this, even though it supports a condition (in short, the size and indexing of the array satisfying the condition are not known in advance).\nThis is also essentially a shorthand for (the more functional programming version):\na = [(i = initial, final, step)]\nb = pack(some_expression(a), condition(a))\n\nbut avoids having to explicitly construct a and then filter (pack) it. Array/list comprehensions are widely used for array construction as well as data analysis in e.g. Python.\nFinally, this relates somewhat to issues #116 and #241, in that these + the current syntax might allow expressions like\n[(some_expression(ai), for ai in array where condition(ai))]\n\nwhich would allow for even more simple, flexible array construction/filtering in the style of list comprehensions.\nI believe these extensions are very much in the 'spirit' of expressing mathematical concepts in modern Fortran, being based directly on the mathematical concept of set comprehensions, e.g. (https://en.wikipedia.org/wiki/List_comprehension)\n\nIt follows the form of the mathematical set-builder notation (set comprehension) as distinct from the use of map and filter functions\n\nwhile also being close to an existing construct (implied do loops).\nThanks!\n(edit: fixed some typos)",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2022-01-12 18:20:33+00:00",
                    "text": "Thanks for proposing this! I've been missing exactly this feature from Fortran also."
                },
                {
                    "user": "jvdp1",
                    "date": "2022-01-12 18:51:22+00:00",
                    "text": "Similarly to this idea, there is also trueloc and falseloc recently introduced in stdlib"
                }
            ]
        },
        {
            "number": 243,
            "user": "Beliavsky",
            "date": "2022-01-10 17:50:30+00:00",
            "title": "Let new_line() be the same as new_line('A')",
            "text": "Can the argument of the new_line function be made optional, so that new_line() is equivalent to new_line('A')? I don't often see Fortranners specify a character kind, and new_line will often be concatenated with character variables or literals of the default kind, so if the argument is made optional, in most cases just new_line() will be what they want.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "Beliavsky",
                    "date": "2022-02-01 13:44:17+00:00",
                    "text": "The suggestion has received support from only other person (now three people), and one person has downvoted. I guess the argument against it is that the user can just define\ncharacter (len=*), parameter :: new_line_char = new_line(\"A\")\nand use new_line_char."
                }
            ]
        },
        {
            "number": 242,
            "user": "plevold",
            "date": "2022-01-03 15:02:18+00:00",
            "title": "Relax restrictions on actual argument for allocatable polymorphic dummy argument with intent(in) and intent(out)",
            "text": "If I'm reading the standard correctly, then section 12.5.2.5 \u00a72 puts restrictions on actual arguments where the dummy argument is allocatable and polymorphic:\n\nThe actual argument shall be polymorphic if and only if the associated dummy argument is polymorphic, and either both the actual and dummy arguments shall be unlimited polymorphic, or the declared type of the actual argument shall be the same as the declared type of the dummy argument.\n\nand the following Note 12.27:\n\nThe dynamic type of a polymorphic allocatable or pointer dummy argument may change as a result of execution of an ALLOCATE statement or pointer assignment in the subprogram. Because of this the corresponding actual argument needs to be polymorphic and have a declared type that is the same as the declared type of the dummy argument or an extension of that type. However, type compatibility requires that the declared type of the dummy argument be the same as, or an extension of, the type of the actual argument. Therefore, the dummy and actual arguments need to have the same declared type.\n\nI believe this is too restrictive for arguments with intent(in) and intent(out):\nWhen the intent is in then it is sufficient that the actual argument is type compatible with the dummy argument as no allocate or redefinition can take place (though an allocated check can). This will also make the use of a dummy allocatable consistent with a dummy optional.\nWhen the intent is out then it is sufficient that the actual argument is type compatible with the dummy argument because the dummy argument can (should) not be used before it has been allocated inside the subprogram.\nHere is a simple example that illustrates how the latter could be useful:\nmodule some_mod\n    implicit none\n\n    type, abstract :: base_t\n    end type\n\n\n    type, abstract, extends(base_t) :: sub_t\n        integer :: i\n    end type\n\n\n    type, extends(sub_t) :: my_t\n        integer :: j\n    end type\n\n\ncontains\n\n\n    subroutine sub1(val)\n        class(sub_t), allocatable, intent(out) :: val\n\n        val = my_t(3, 4)\n    end subroutine\n\nend module\n\n\nprogram main\n    use some_mod\n\n    class(base_t), allocatable :: base\n\n    ! This works, but is very verbose\n    block\n        class(sub_t), allocatable :: sub\n\n        call sub1(sub)\n        call move_alloc(sub, base)\n    end block\n\n    ! However this porduces a compile error\n    call sub1(base)\n\n    select type(base)\n        type is (my_t)\n            print *, base%i, base%j\n    end select\nend program",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": []
        },
        {
            "number": 241,
            "user": "jacobwilliams",
            "date": "2021-12-13 02:38:00+00:00",
            "title": "for loop",
            "text": "Not sure if this has already been proposed or not. But I keep wishing Fortran had something like the python for style loops like this:\nfor x in [10, 23, 1]:\n   do_something(x)\nor with zip:\nfor x,y in zip([10,23,1], ['a', 'b', 'cc']):\n  do_something(x,y)\nof course, the fortran way would be something like that:\ninteger :: i  ! just a counter\ninteger,dimension(3),parameter :: vals = [10, 23, 1]\ncharacter(len=2),dimension(3),parameter :: cals = ['a ', 'b ', 'cc']\ndo i = 1, 3\n  call do_something(vals(i), cals(i))\nend do\nWhat do people think?\nI don't know what the syntax would be...\nfor (x => [10, 23, 1], c => ['a ', 'b ', 'cc'])\n  call do_something(x,c)\nend for",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-12-13 05:48:18+00:00",
                    "text": "Yes, Julia also has this feature. I think this can be done, it would bring Fortran closer to Python and Julia."
                },
                {
                    "user": "cmacmackin",
                    "date": "2021-12-13 18:57:32+00:00",
                    "text": "I like the idea. I think maybe we should use something different than pointer assignment for the syntax though. This is because\n\nIt makes it look like the counter variable is being associated with the entire array.\nUsing a new operator (e.g., ->) leaves open the possibility that it could be overridden for derived types, giving the possibility of custom iterators.\n\nWe don't need to think out all the technicalities of how such custom iterators would be implemented right now, but we can at least leave the possibility open for the future."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-12-13 21:17:17+00:00",
                    "text": "Another option is a new .in. operator."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-12-14 15:44:11+00:00",
                    "text": "I have wanted the same thing and support the proposal, but note that Impure elemental subroutines can simulate for loops over collections"
                },
                {
                    "user": "waynelapierre",
                    "date": "2022-01-20 18:45:19+00:00",
                    "text": "how about this syntax?\ndo [x, y] .in. [[10, 23, 1], ['a', 'b', 'cc']]\n  do_something(x, y)\nend do"
                }
            ]
        },
        {
            "number": 240,
            "user": "ivan-pi",
            "date": "2021-11-11 11:11:53+00:00",
            "title": "Intrinsics for mathematical constants",
            "text": "This issue originates from one of the questions at the HPFPC (High-Performance computing with Fortran Promoting Consortium) symposium (https://site.hpfpc.org/home/events/parallel_fortran_sympo5)\nIn the requests & questions list we can read\n\nQ27: The standard should include some physical constants such as pi. It is more helpful if they can used without using any modules, similarly to intrinsic procedures.\nA27: This would not be a big addition to the language, but it has not been requested.\n\nThis has also been suggested and discussed at length in one of the stdlib issues: fortran-lang/stdlib#99\nCurrent status\nIn most Fortran codes today, users rely upon statements like:\nreal(wp), parameter :: pi = 4*atan(1.0_wp) ! or\nreal(wp), parameter :: pi = 2*acos(0.0_wp)\nreal(wp), parameter :: e = exp(1.0_wp)\n\nthat are collected in a constants module, leading to duplication of effort and potential errors.\nPersonally, I often re-declare pi locally in each module (to lazy to use a module) and find myself wondering which trigonometric function am I supposed to use in my head or drawing a unit circle on a sheet of paper.\nOther programming languages\nOther languages are also known to provide such constants, e.g. in C the header file math.h provides the following:\n\nM_E:     The base of natural logarithms.\nM_LOG2E: The logarithm to base 2 of M_E.\nM_LOG10E: The logarithm to base 10 of M_E.\nM_LN2: The natural logarithm of 2.\nM_LN10: The natural logarithm of 10.\nM_PI: Pi, the ratio of a circle\u2019s circumference to its diameter.\nM_PI_2: Pi divided by two.\nM_PI_4: Pi divided by four.\nM_1_PI: The reciprocal of pi (1/pi).\nM_2_PI: Two times the reciprocal of pi.\nM_2_SQRTPI: Two times the reciprocal of the square root of pi.\nM_SQRT2: The square root of two.\nM_SQRT1_2: The reciprocal of the square root of two (also the square root of 1/2).\n\nJulia also provides the constants for im (imaginary unit), pi, \u212f (the constant \u212f), Catalan's constant, Euler's constant, and the golden ratio, among others.\nPython provides math.pi, math.e, and math.tau (2 times pi) to available precision (presumably C double in most implementations).\nSolution\nThe solution could be provided in terms of intrinsic functions, e.g.\npure function math_pi(kind) real(pi)\n   integer, kind :: kind  ! not valid Fortran\n   real(kind=kind) :: pi\n\nwhich accept an integer kind argument. This is still kind of verbose, but users can always use a parameter:\nreal(wp), parameter :: pi = math_pi(wp)\nor an associate construct:\nassociate(pi => math_pi(wp), e => math_e(wp))\n...\nend associate\nif they want a shorter variable name.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2021-11-11 11:30:55+00:00",
                    "text": "Note in C, the constants are of type double, implemented as macro substitutions. A GNU C library extension also provides constants of type long double, by appending the a lowercase character l to their names.\nSince the Fortran standard does not specify a preprocessor, intrinsic functions with a kind specifier seem like the cleanest solution. An optimizing compiler can easily unwind the function call and substitute the constant with the desired precision."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-11 17:13:04+00:00",
                    "text": "A more idiomatic interface would be to pass an unused real argument whose kind (not value) determines the kind of the result..  This interface could be implemented in current Fortran without adding intrinsics."
                },
                {
                    "user": "certik",
                    "date": "2021-11-11 17:26:58+00:00",
                    "text": "As a user I think my preferred way is still to just import them from some module, such as math_constants or just constants:\nuse math_constants, only: pi\n\nBut I don't now how to do it to work with the different kinds properly. As a practical approach, just providing them in double precision would be enough for all my use cases. But I can see how this is not ideal, we really want this to work for all kinds well.\n@klausler suggestion would work today:\nreal(wp), parameter :: x = 1\nreal(wp), parameter :: pi = math_pi(x)\n\nBut it's quite verbose."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-11-11 18:39:29+00:00",
                    "text": "This needs to be part of the generics feature in Fortran 202y. Not only do we need to be able to define routines and classes that can use any real (or integer, etc.) kind, but that needs to also trickle down to parameters. The kind in the parameter has to be able to inherit that somehow, without having to define multiple ones for each kind (which is basically impossible...which is the problem we have now), or give up on parameters altogether. Not having this is one of the reasons parameterized derived types are mostly useless."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-11 19:04:15+00:00",
                    "text": "Since you mention generics, in C++ I sometimes see programmers use the following pattern:\ntemplate <typename T> T pi_const() {\n  return static_cast<T>(3.14159265358979323846);\n}\nUsage looks like:\nauto pi = pi_const<double>()\nI guess the answer from @klausler would be one of the arguments against new intrinsic functions. It is similar to some of the intrinsic functions, like newline or kind (roughly). Instead of declaring an unused variable you can always just use a literal constant to achieve resolution of the correct interface, e.g:\nmodule math\n  implicit none\n  private\n  public :: math_pi\n  interface math_pi\n    module procedure math_pi_sp\n    module procedure math_pi_dp\n  end interface\ncontains\npure function math_pi_sp(a)\n  integer, parameter :: sp = kind(1.0e0)\n  real(sp), intent(in) :: a\n  pi = 3.14159265358979323846264338327950288_sp\nend function\npure function math_pi_dp(a) result(pi)\n  integer, parameter :: dp = kind(1.0d0)\n  real(dp), intent(in) :: a\n  pi = 3.14159265358979323846264338327950288_dp\nend function\nend module\n\nprogram circle\nuse math\nimplicit none\ninteger, parameter :: dp = kind(1.0d0)\n\nreal(dp), parameter :: pi = math_pi(1.0_dp)\nreal(dp) :: radius, area\n\nwrite(*,*) \"Enter circle radius\"\nread(*,*) radius\narea = pi * radius**2\nwrite(*,*) \"Circle area = \", area\nend program\nThis feels okay-ish. Perhaps this is the best available approach to use in stdlib."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-11 19:22:25+00:00",
                    "text": "The kind in the parameter has to be able to inherit that somehow, without having to define multiple ones for each kind (which is basically impossible...which is the problem we have now), or give up on parameters altogether. Not having this is one of the reasons parameterized derived types are mostly useless.\n\n@jacobwilliams, could you elaborate please? I fail to see how adding math constants relates to parameterized derived types. The first part of your answer relates to #91 if I understood correctly.\nApart from the boilerplate in the implementation, I don't think the Fortran approach:\nreal(dp), parameter :: pi = math_pi(1.0_dp)\nis much worse than the C++ approach used in practice (C++ of course being a language famous for generic capabilities):\nconst double pi = pi_const<double>()\nThe C solution using macros is convenient, but limited to double precision. The same can be done easily with Fortran or Python:\nfrom math import pi\nprint(\"pi = {}\".format(pi))\ninclude <math.h>\nprintf(\"pi = %f\\n\",M_PI);\nuse math, only: pi\nwrite(*,*) \"pi = \", pi\nend"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-11-12 00:58:48+00:00",
                    "text": "@ivan-pi writes Nov. 11, 2021, 6:11 AM EST:\n\n.. The solution could be provided in terms of intrinsic functions ..\n\nPlease see the link in the original post of #46, an alternate solution I had proposed a couple of years ago toward such needs is a proper enumeration type facility in Fortran.\nMy proposal had \"built-in\" Generics i.e., the enumerator constants in an enumeration type can be of any intrinsic type as part of the definition of the enumeration type itself.\nHere are some extracted bits from that proposal:\n\nd) where the underlying type of enumerators in an integer with a\nspecified kind e.g.,\n enum :: MY_HASH_CODES(integer(kind=INT64))\n    enumerator :: FOO = Z\"d76aa478\"\n    enumerator :: BAR = Z\"e8c7b756\"\n    ..\n end enum\n\ne) an enumeration type where the underlying type of elements in the\nenumerated list is that of the LOGICAL intrinsic type.  An example\nwith the defaul logical kind is shown below though it is expected\nother supported logical kinds can be used also.\n enum :: VALVE_STATE(logical)\n    enumerator :: OPEN = .true.\n    enumerator :: CLOSED = .false.\n end enum\n\nf) an enumeration type where the underlying type of elements in the\nenumerator list is that of the CHARACTER intrinsic type. An\nexample with the defaul characted kind is shown below though\nit is expected other supported character kinds can be used also.\n enum :: LNG_CONSTITUENT(character(len=*))\n    enumerator :: N2 = \"Nitrogen\"\n    enumerator :: C1 = \"Methane\"\n    enumerator :: C2 = \"Ethane\"\n    enumerator :: C3 = \"Propane\"\n    ..\n end enum\n\ng) an enumeration type where the underlying type of elements in the\nenumerator list is that of the REAL intrinsic type.  An\nexample with a user-defined kind is shown below and it is\nexpected other supported real kinds can also be used similarly.\n integer, parameter :: R8 = selected_real_kind( p=12 )\n enum :: PHYS_CHEM_CONSTANTS(real(kind=R8)) ! SI units\n    enumerator :: MU = 1.66053906660E-27_r8 ! Atomic mass constant\n    enumerator :: NA = 6.02214076E23_r8     ! Avogadro number\n    enumerator :: K = 1.380649E-23_r8       ! Boltzmann constant\n    enumerator :: R = 8.314462618_r8        ! Molar gas constant\n    ..\n end enum\n\n\n..\n\na) \"cast\" the enumerator value to an object of an intrinsic type using\nthe intrinsic conversion functions e.g.,\n..\n ii) REAL intrinsic\n     real, parameter :: Rgas=real(PHYS_CHEM_CONSTANTS%R, kind(Rgas))\n\n\n..\n\n\n\nthat it will be possible for an enumeration type to be the selector in\nan ASSOCIATE construct e.g., with reference to 1g above,\ntype(PHYS_CHEM_CONSTANTS) :: k\n..\nassociate ( CONST => PHYS_CHEM_CONSTANTS )\n..\nk = CONST%k\n..\nend associate\n\n\nthat it is possible for an enumerator to be the selector in an\nASSOCIATE construct e.g., with reference to 1e above,\nassociate ( foo => MY_HASH_CODES%FOO )\n..\nend associate\nassociate ( R => real(PHYS_CHEM_CONSTANTS%R, kind=..) )\n..\nDensity = P/R/T\n..\nend associate\n\n\n\nOnce such a comprehensive facility were to be added to the language, my vision was \"intrinsic enumerations\" a la \"intrinsic named constants\" in some \"intrinsic modules\" (along the lines of ISO_FORTRAN_ENV, IEEE_ARITHMETIC, etc.).  Intrinsic enumerations for, say, MATH can then offer PI, E, and so forth for those users who would like to use them.\nThe proposal was seen as too comprehensive for the \"minor revision\" that is Fortran 202X and it failed to get any support.\nBut I maintain a proper enumeration type is the way to facilitate the use of many literal constants, be they of any intrinsic type, by the practitioners in their Fortran code."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-12 09:49:10+00:00",
                    "text": "Thanks @FortranFan for the link. I like your proposed syntax for enumerators and think it would offer safer Fortran usage outside of the traditional scientific computing domain.\nRelated to the current issue, I can't see how would it allow practitioners to select the right kind:\nenum :: math_sp(real(sp))\n  enumerator :: pi = 4*atan(1.0_sp)\n  enumerator :: e = exp(1.0_sp)\nend enum\n\nenum :: math_dp(real(dp))\n  enumerator :: pi = 4*atan(1.0_dp)\n  enumerator :: e = exp(1.0_dp)\nend enum\nIn the stdlib thread on mathematical constants, some practitioners were against using a derived type as a \"pseudo\" enumerator, for the sole reason that it felt wrong to them to have to retrieve constants using the % operator. I think it's a case of de gustibus non disputandum est.\nIf I return to the original post, two questions that should be answered first are:\n\nDo we support adding mathematical constants (or functions/enums/derived types to retrieve them)  and if yes, can they be in global namespace or should they be part of an intrinsic module?\nHow do we allow practitioners to retrieve constants with the right kind, without resorting to expressions like 4*atan(1.0_wp) or exp(1.0_wp)?\n\nIf the answer from the majority is they are fine with a module, this can be done in stdlib with the approach @klausler suggested. If it is preferable to have pi built-in, we need to discuss further. By built-in I mean something along the following lines would be valid Fortran program:\nreal :: pi = 3.14 ! shadows intrinsic pi, be it function or literal constant\n\nblock\nintrinsic :: pi \nprint *, pi  ! or pi(1.0d0), prints 3.14... \nend block\n\nI am afraid there would be opposition to having many short names like pi, e, and others. Other names like the Archimedes's constant or Euler's number are cumbersome. So prepending the names with M_ like C does, or math like Python, seems to be desirable.\nA third alternative, what Julia does, is that the core mathematical constants are handled as special values of type \"Irrational\". These values get converted to floating point numbers without intermediate rounding when used in mathematical expressions.\nThis is an elegant solution which I guess could be done in Fortran too, but is cumbersome for implementation, and would need to be taken care of on the compiler side to guarantee the expressions get replaced with floating point numbers for minimum overhead."
                },
                {
                    "user": "certik",
                    "date": "2021-11-12 15:21:14+00:00",
                    "text": "The most natural for me would be to redo how Fortran handles mixed precision. But that's a big task and probably not possible to do at this point.\nBut as a user I would like to just create a math_constants module with:\nreal(decimal), parameter :: pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 \n\nwhich would be \"exact\" (in this case 100 digits) and then I would like to use it as:\nreal(sp) :: r4\nreal(dp) :: r8\nr4 = sqrt(pi)*pi\nr8 = sqrt(pi)*pi\n\nand it would just work. It would do the operations with the single or double precision, say in here:\nr4 = r4 * pi\nr8 = r8 * pi\n\nIn the first line it would use a single precision multiplication, in the second line it would use a double precision multiplication. So there would be no runtime overhead.\nIn fact, as a user I would like exactly this behavior for any numbers such as:\nr4 = r4 * 8.15\nr8 = r8 * 8.15\n\nAs I said, this would require to rethink how mixed precision is done. As discussed elsewhere, in Fortran the precision is inferred from the right hand side, never from the left hand side. So 8.15 or \"pi\" would have to be a new type, \"decimal\" (with the exact decimal digits as you write them) and then it would be cast down to whatever accuracy is needed. However, I think this approach hits some obstacles how Fortran traditionally does things."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-11-12 16:47:21+00:00",
                    "text": "Consider this PDT example. Say you write to write a solver that works for any real kind. You get pretty far and then you realize that you have a bunch of parameters that need to be that same kind. It's basically impossible to do that. Functions are not really what you want (and you can't have functions for every real number). You just want to use parameters, which is the most natural way to do this with Fortran. PDT is basically a half-baked generic feature that never went anywhere and was never fixed. A real generic feature would account for this somehow.\nI don't know what the syntax should look like, but I don't think we should have to use functions or derived types just to specify numeric parameters.\nmodule test\n\nuse iso_fortran_env \n\nimplicit none \n\nprivate\n\ntype,public  :: solver(rk, n)\n    integer,kind :: rk = real64\n    integer,len  :: n  = 0\n    real(rk) :: t\n    real(rk),dimension(n) :: x\n   contains\n   procedure :: solve => rk8\nend type solver\n\ncontains \n    subroutine rk8(me,t0,x0,dt)\n    implicit none\n    class(solver(rk=real64,n=*)),intent(inout) :: me\n    real(me%rk),intent(in) :: t0 \n    real(me%rk),dimension(me%n),intent(in) :: x0 \n    real(me%rk),intent(in) :: dt \n\n    real(me%rk),parameter :: coefficient_1 = 1.0_me%rk / 23.0_me%rk   ! not possible\n\n   ...\n    end subroutine rk8\n\nend module test"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-12 17:52:51+00:00",
                    "text": "Here's an example of a PDT for performing LU factorization:\nmodule lu_pdt\n\n  implicit none \n  private\n\n  public :: lu_workspace, factorize\n\n  type :: lu_workspace(wp,n)\n    integer, kind :: wp\n    integer, len :: n\n    real(wp) :: a(n,n)\n    real(wp) :: b(n)\n    integer :: ipiv(n)\n    logical :: factorized = .false.\n  end type\n\n  interface factorize\n    module procedure factorize_sp\n    module procedure factorize_dp\n  end interface\n\n  integer, parameter :: sp = kind(1.0e0)\n  integer, parameter :: dp = kind(1.0d0)\n\ncontains\n\n  subroutine factorize_sp(this,info)\n    type(lu_workspace(sp,*)), intent(inout) :: this\n    integer, intent(out), optional :: info  \n\n    integer :: info_\n    external :: sgetrf\n\n    if (.not. this%factorized) then\n      call sgetrf(this%n,this%n,this%a,this%n,this%ipiv,info_)\n      if (info_ == 0) then\n        this%factorized = .true.\n      end if\n      if (present(info)) info = info_\n    else\n      return\n    end if\n\n  end subroutine\n\n  subroutine factorize_dp(this,info)\n    type(lu_workspace(dp,*)), intent(inout) :: this\n    integer, intent(out), optional :: info  \n\n    integer :: info_\n    external :: dgetrf\n\n    if (.not. this%factorized) then\n      call dgetrf(this%n,this%n,this%a,this%n,this%ipiv,info_)\n      if (info_ == 0) then\n        this%factorized = .true.\n      end if\n      if (present(info)) info = info_\n    else\n      return\n    end if\n\n  end subroutine\n\nend module\n\nprogram main\n\n  use lu_pdt\n  implicit none\n\n  integer, parameter :: sp = kind(1.0e0)\n  integer, parameter :: dp = kind(1.0d0)\n\n  type(lu_workspace(dp,:)), allocatable :: work\n  integer :: info\n\n  allocate(lu_workspace(dp,n=3) :: work)\n\n  work%a = reshape(&\n    [real(dp) :: 4, 2, -1, -3, 1, 2, 1, 3, -5], &\n    [3,3])\n\n  work%b = [real(dp) :: -10, 0, 17]\n\n  call factorize(work,info)\n  print *, \"info = \", info\n\nend program\nI couldn't test it fully because I am missing LAPACK on this PC. But gfortran is able to compile it. If I make factorize a type-bound method then it breaks. You are right it's a half-baked feature, but I think we haven't even begun to explore what it offers in terms of simplified API'S.\nWith some include statements (read poor man's templates), you could make it support all allowable real kinds and even mixed-precision (apart from the calls to the LAPACK routines). Granted, it\u00b4s verbose and the methods wouldn't be type-bound (no chance for polymorphism), but it can still work to some degree.\nIf you look at some of the Julia packages, e.g. Pardiso.jl, they also use the style of passing a solver object to a function:\nps = PardisoSolver()\n\nA = sparse(rand(10, 10))\nB = rand(10, 2)\nX = zeros(10, 2)\nsolve!(ps, X, A, B)"
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-11-12 18:11:26+00:00",
                    "text": "In the context of your Runge Kutta PDT, the solve function would like like this:\ntype, public  :: solver(rk, n)\n    integer, kind :: rk = real64\n    integer, len  :: n  = 0\n    real(rk) :: t\n    real(rk), dimension(n) :: x\nend type solver\n\ngeneric :: solve => rk4_sp, rk4_dp\n\ncontains\n    subroutine rk4_sp(me,t0,x0,dt)\n    use prec, only: wp => sp\n    include 'rk4.inc'\n    end subroutine rk4_sp\n    subroutine rk4_dp(me,t0,x0,dt)\n    use prec, only: wp => dp\n    include 'rk4.inc'\n    end subroutine rk4_dp\nand the include file would be\n! rk4.inc\n    type(solver(rk=wp,n=*)), intent(inout) :: me\n    real(wp),intent(in) :: t0 \n    real(wp),dimension(me%n),intent(in) :: x0 \n    real(wp),intent(in) :: dt \n\n    real(wp),parameter :: coefficient_1 = 1.0_wp / 23.0_wp\n    ! ..."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-12 18:19:23+00:00",
                    "text": "A simple module parameterization facility would avoid the need for file inclusion and preprocessing tricks."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-11-12 19:26:30+00:00",
                    "text": "The problem with include, aside from the interface duplication you have to do, is that there's no way to make it work with any real kinds the compiler supports, without either knowing what they are in advance, or going outside of Fortran (some sort of preprocessor/introspection tricks)."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-12 19:33:57+00:00",
                    "text": "The problem with include, aside from the interface duplication you have to do, is that there's no way to make it work with any real kinds the compiler supports, without either knowing what they are in advance, or going outside of Fortran (some sort of preprocessor/introspection tricks).\n\nThat's right, and that's why a module instantiation facility would need to be able to instantiate a module over a set of values.  Easy to define and easy to implement."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-11-13 05:41:23+00:00",
                    "text": "@ivan-pi writes Nov. 12, 2021 12:52 PM EST:\n\n.. @FortranFan ..\nRelated to the current issue, I can't see how would it allow practitioners to select the right kind:\n\nThe proposal I mentioned above tries to make it possible for practitioners and implementations to offer a \"grouping\" of related named constants (say math), hence enum's, with consistent floating-point representations.\nI envision a program to define a single enum of suitable floating-point representation for a given set of constants, say for math:\ninteger, parameter :: HP = selected_real_kind( p=xx ) !<-- or ieee_selected_real_kind(..), etc.\n\nenum :: math(real(hp))\n   enumerator :: PI = 3.14159265358979323846264338327950288.._hp\n   enumerator :: e = ..\n   ..\nend enum\nAnd for the code to consume the constants as scoped enumerations, say enum_nameXenumerator where X can be %, ::, etc.\nThe key is to have convenient grouping of constants that are all tied together with consistent floating-point representation."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-11-13 06:02:46+00:00",
                    "text": "A simple module parameterization facility would avoid the need for file inclusion and preprocessing tricks.\n\nI personally think the boat for module parameterization has long sailed, it is needless complication considering what has been introduced into the language with Fortran 2003 thru' 2018 with PDTs and GENERIC statements.  A better approach now will be to simply build on this in a way that will greatly simplify the consumption of generic types on the client side.  Say as follows\n   generic, kind :: RK => real32, real64, real128 !<-- define a GENERIC for KINDs a la GENERIC interfaces currently\n\n   type, public  :: solver(k, n)\n      integer, kind :: k = <RK> !<-- use some symbols to designate a GENERIC set, shown here with angle brackets\n      integer, len  :: n  = 0\n      real(k) :: t\n      real(k), dimension(n) :: x\n   end type solver\n\ncontains\n\n    subroutine solve(me,t0,x0,dt)\n       type(solver(k=<RK>,n=*)), intent(inout) :: me\n       real(<RK>),intent(in) :: t0 \n       real(<RK>),dimension(me%n),intent(in) :: x0 \n       real(<RK>),intent(in) :: dt \n       ..\n      \n    end subroutine\nThe processor should then be able to do the semantics by substitution and build up the generic interface solve.\nThe advantage with this can be that the code on the client side to use such as a PDT with a generic interface for procedures will be the same as that currently.  It's only on the \"library\" side that code duplication is reduced greatly via a GENERIC mechanism."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-13 18:16:56+00:00",
                    "text": "That only works for integer kind values.  It doesn't work for more general types, such as a data structure module parameterized over arbitrary types."
                },
                {
                    "user": "certik",
                    "date": "2021-11-13 18:26:57+00:00",
                    "text": "Actually having modules like:\nuse constants_sp, only: pi\nuse constants_dp, only: pi\nuse constants_qp, only: pi\n\nwould work also I think. But it doesn't feel \"right\" to me either."
                }
            ]
        },
        {
            "number": 239,
            "user": "Beliavsky",
            "date": "2021-11-03 14:22:05+00:00",
            "title": "Allow implicit none to appear before use statements",
            "text": "Currently implicit none must appear after use statements in a module or main program.  Could this restriction be removed? As long as Fortran has implicit typing, implicit none should appear at the beginning of a main program or module. It would convenient if you could just put it on the second line of source files and look for it there, instead of looking for it under any number of use statements.\nI would not call this a big improvement, but unless it is difficult for compiler writers to implement, it may be worth doing.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-11-03 15:46:22+00:00",
                    "text": "Indeed. I also feel it would be much more natural right after the program or module. (I edited your post, you said it currently appears before use, so I changed it to after use.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-11-03 16:48:37+00:00",
                    "text": "@Beliavsky wrote Nov. 3, 2021 10:22 AM EDT:\n\nCurrently implicit none must appear after use statements in a module or main program. Could this restriction be removed?\n\nMy hunch is there will be a lot of resistance to this among the committee.\nNote the semantics of implicit none are but part of those with the implicit statement.\nThe current ordering appears to be intended to allow instructions such as the following and to keep matters simpler for the compiler implementations:\n   use foo_m, only : foo_t\n   ..\n   implicit type(foo_t) (f)  !<-- implicit mapping of type(foo_t) to letter 'f' so that any undeclared object\n                             !    beginning with letter 'f' is *implicitly* of type(foo_t)\nA less troublesome but a wholesome and truly valuable step forward for Fortran will be #218.  Then coders don't have to bother at all about their \"desired\" place for implicit none; that will be the default."
                },
                {
                    "user": "certik",
                    "date": "2021-11-03 16:58:08+00:00",
                    "text": "@FortranFan good points. One option is to allow the implicit both after and before use. That way if you use implicit type(foo_t) (f)  then you have to put it after use, but implicit none can come before."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-03 17:44:14+00:00",
                    "text": "The problem here isn't that implicit none isn't allowed before a use, it's that use (and import) are required to appear first.  That's what could be relaxed -- both of them could really appear anywhere in a specification-part, including this particular  desired use case (after implicit none).\nSo long as the names that 'use' and import pull into the scope are distinct, there's no semantic ambiguity introduced by allowing them to appear later; and when the names clash(*) with others in the scope, that's a situation that a compiler already has to cope with today since it can arise using just use and import.  Ditto with forward references to derived types, that's already possible in Fortran.\n((*) not all cases of having a name already in scope and being equivalent to a name from a use/import are errors)"
                },
                {
                    "user": "ashe2",
                    "date": "2021-11-04 20:37:01+00:00",
                    "text": "Another option would be to allow use, import, and implicit none statements to occur together in any order at the beginning of a specification part. Other implicit statements would not be allowed in this part so it wouldn't add new forward referencing.\nimplicit none is already treating differently from other implicit statements in that the latter can occur after parameter statements. Also, other implicit statements shouldn't be used in new code, at least in my opinion."
                }
            ]
        },
        {
            "number": 238,
            "user": "Leonard-Reuter",
            "date": "2021-11-01 15:00:40+00:00",
            "title": "Add augmented assignment proposal",
            "text": "Added proposal for augmented assignment with +.=, /.= etc. following the discussion in #113",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-11-01 15:45:31+00:00",
                    "text": "Thanks for writing it up!\nIn order for this proposal to have a chance, in my opinion we have to address existing and past committee criticisms.\nYou should reference previous proposals, I think there were some.\nAnd then we need to go into the J3 mailinglist (I added a link in one of the comments in #113), and address every objection. Otherwise the same objections will be given and the proposal rejected."
                }
            ]
        },
        {
            "number": 237,
            "user": "Beliavsky",
            "date": "2021-11-01 13:38:46+00:00",
            "title": "Make cmplx with non-default real arguments and unspecified kind obsolescent",
            "text": "I suggest that when the x and y arguments of cmplx are both of a real type other than default real or that when only x is present and is not a default real that it be obsolescent to not specify the kind argument of cmplx. The expression\ncmplx(1.0d0,1.0d0)\ndoes not produce a double precision complex number, although a casual reader may think it does. It's anomalous, because other intrinsics such as sin or sum return reals of the same kind as the argument. To avoid errors one should be forced to write\ncmplx(1.0d0,1.0d0,kind=some_kind)\nIt will be not be obsolescent to write\ncmplx(1.0,1.0)\nsince no silent conversion is performed here.\nStarting from scratch, cmplx(1.0d0,1.0d0) should return a double precision complex value, but I am wary of changing the meaning of valid code.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-11-01 14:25:52+00:00",
                    "text": "Indeed. I think at the very least, compilers should warn about this."
                }
            ]
        },
        {
            "number": 236,
            "user": "aradi",
            "date": "2021-10-19 09:02:01+00:00",
            "title": "Exceptions in Fortran",
            "text": "Based on the discussion on fortran-lang.discourse about the ErrorFx library, a mechanism for exception like error handling should be created.\nErrorFx demonstrates, that such a mechanism is possible with current Fortran already. But it needs a lot of boiler plate code, which in ErrorFx are currently substituted by Fypp-macros. I drafted a possible syntax for all the scenarios we can already handle in ErrorFx. I'd also provide equivalent Fortran code, but probably we can already start discussion, in case somebody sees some general flaws in the concept.\n! All errors are extensions of a base type\ntype, extends(fatal_error) :: io_error\n  character(:), allocatable :: name\n  integer :: unit = - 1\nend type io_error\n\ntype, extends(fatal_error) :: allocation_error\n  integer :: allocation_size\nend type allocation_error\n  \n\nsubroutine subroutine_with_error(...) throws(io_error, allocation_error)\n  ...\n  throw io_error(name=\"somefile.dat\")\n ...\nend subroutine subroutine_with_error\n\n\nfunction function_with_error(...) result(...) throws(io_error)\n  ...\n  throw io_error(unit=9)\n  ...\nend function function_with error\n\n\n! Propagating error upwards\ntry call subroutine_with_error()\n\n! Propagating error upwards in function call\ni = try function_with_error()\n\n! Catching if any error thrown and assign a default value in that case\ni = try function_with_error() else -1\n\n! The classical try-catch block\n! errorvar is the name of the local variable representing the error which was caught\n! If an error is not handled here, it will be automatically propagated upwards\ntry catch (errorvar)\n  i = function_with_error\n  ! or altenatively\n  call subroutine_with_error()\ncatch (io_error)\n  ! do something\n  print *, \"UNIT:\", errorvar%unit\n  ! We pass it upwards as a more generic error\n  throw fatal_error :: errorvar\ncatch (some_other_error)\n  ! do something else for this error\nend try catch\n\n! A call to a subroutine or a function with error outside of a try should trigger a compiler error\ncall subroutine_with_error()  ! should trigger compiler error\ni = function_with_error()   ! should trigger compiler error as well",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "aradi",
                    "date": "2021-10-19 09:34:10+00:00",
                    "text": "Actually, if we wanted to omit the central error type and take out inheritance from the game, we could just allow the user to declare arbitrary types (with some constraints, like no pointers in them) as \"throwable\" without having them to derive from a base class, e.g.\ntype, throwable :: io_error\n  character(:), allocatable :: filename\n  integer :: unit = -1\nend type io_error\nThat would be probably even more \"fortranic\". Maybe then catch will need a catch all clause, as the errors were not hierarchical any more, so a catch(fatal_error) won't catch everything:\ntry catch (errorvarname)\n...\ncatch all\n  ! things to do, if the error type is irrelevant.\n  ! As we don't know what the type is, no\n  ! access to errorvarname is allowed here\nend try catch"
                },
                {
                    "user": "certik",
                    "date": "2021-10-19 16:48:53+00:00",
                    "text": "@aradi thanks for opening up an issue for this to start a discussion.\nSo the single line try syntax is very good:\n! Propagating error upwards\ntry call subroutine_with_error()\n\n! Propagating error upwards in function call\ni = try function_with_error()\n\n! Catching if any error thrown and assign a default value in that case\ni = try function_with_error() else -1\n\nIt greatly simplifies error handling, but it is just nicer syntax for what can be done already, as you have shown with your ErrorFx library. For reference, to make this proposal standalone, the proposal is that this code:\nsubroutine routine_propagating_error(..., error)\n  ...\n  type(fatal_error), allocatable, intent(out) :: error\n  ...\n  ! If error happend, we propagate it upwards, otherwise we continue\n  try call routine_with_possible_error(...)\n  print \"(a)\", \"Apparently no error occured\"\n  ...\nend subroutine routine_propagating_error\nis equivalent to:\nsubroutine routine_propagating_error(..., error)\n  ...\n  type(fatal_error), allocatable, intent(out) :: error\n  ...\n  call routine_with_possible_error(..., error)\n  ! If error happend, we propagate it upwards, otherwise we continue\n  if (allocated(error)) return\n  print \"(a)\", \"Apparently no error occured\"\n  ...\nend subroutine routine_propagating_error\nThere is no \"magic\" behind the scene.\nCan you write what this code is equivalent to:\ntry catch (errorvar)\n  i = function_with_error\n  ! or altenatively\n  call subroutine_with_error()\ncatch (io_error)\n  ! do something\n  print *, \"UNIT:\", errorvar%unit\n  ! We pass it upwards as a more generic error\n  throw fatal_error :: errorvar\ncatch (some_other_error)\n  ! do something else for this error\nend try catch\nI think we have not discussed this part yet."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-20 13:35:15+00:00",
                    "text": "@certik To ease the communication and discussion, I've created the FException repository which contains the new syntax for all cases I've considered so far (throwing error, propagating error, catching error, error in functions) and also the equivalent Fortran 2008 code. (They can be compiled and executed).\nI've slightly changed the syntax for the assignment to\ntry i = function_with_error(...)\nto be more similar to the try call version (and because the try should relate to the entire expression, not just to the function call.\nA try-catch construct of the form (see catch_exception_fxy.f90)\ntry catch\n  call subroutine_throwing_error(ii)\n  !call subroutine_throwing_error2(...)\ncatch (io_error as errorvar)\n  print \"(a)\", \"main: caught io_error\"\n  if (allocated(errorvar%message)) print \"(2a)\", \"Message: \", errorvar%message\n  if (allocated(errorvar%filename)) print \"(2a)\", \"File name: \", errovar%filename\n  print \"(a,i0)\", \"Unit: \", errovar%unit\ncatch all\n  print \"(a)\", \"main: obtained some error, but I did not care to obtain its details\"\nend try\n\nwould be substituted with (see catch_exception.f90)\ntry_catch: block\n  class(*), allocatable, target :: internal_errorvar\n\n  try: block\n    call subroutine_throwing_error(ii, internal_errorvar)\n    if (allocated(internal_errorvar)) exit try\n    ! call subroutine_throwing_error2(..., internal_errorvar)\n    ! if (allocated(internal_errorvar)) exit try\n    exit try_catch\n  end block try\n\n select type (internal_errorvar)\n  type is (io_error)\n    catch_io_error: block\n      type(io_error), pointer :: errorvar\n      errorvar => internal_errorvar\n      print \"(a)\", \"main: caught io_error\"\n      if (allocated(errorvar%message)) print \"(2a)\", \"Message: \", errorvar%message\n      if (allocated(errorvar%filename)) print \"(2a)\", \"File name: \", errorvar%filename\n      print \"(a,i0)\", \"Unit: \", errorvar%unit\n      exit try_catch\n    end block catch_io_error\n  class default\n    print \"(a)\", \"main: obtained some error, but I did not care to obtain its details\"\n  end select\nend block try_catch\n\nOf course, apart of transforming the new syntax into the equivalent Fortran 2008 code, the compiler will need to check, whether all possible exceptions, which the code in the try block could throw, had been handled. If not, they must be either propagated upwards (provided the containing scopes throws(..) clause contains the unhandled exception types) or the compiler must stop with an appropriate error message."
                },
                {
                    "user": "certik",
                    "date": "2021-10-20 13:40:20+00:00",
                    "text": "I see, nice. I didn't know you can exit from a \"block\".\nWhat is nice about this approach to exception handling is that there are no extra features needed in the compiler \"backend\", no long jumps, no stack unwinding, no magic. All this is is just a nicer syntax, checked by the compiler's \"frontend\", but underneath using current Fortran features, so regarding questions like performance there is no additional overhead over what you would need to write by hand anyway.\n@aradi, regarding try i = function_with_error(...), what about: try i = (function_with_error(...)**2 + 1)*another_function_with_error(...)? Would the try propagate in the whole expression to any function that returns an error? In which case the error can always be propagated as an extra argument (whether subroutine or a function). This would eliminate the need for theResult<T> type, which is not as easy to do in Fortran."
                },
                {
                    "user": "certik",
                    "date": "2021-10-20 13:57:18+00:00",
                    "text": "Finally, exceptions have been discussed a lot in this repository. Here are other relevant threads: #6, #66, #172.\nSee this C++ paper about a try proposal for C++: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf\nSee this thread in J3 about approaches to exceptions for Fortran:\n\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-February/011256.html\n\nIn particular, a \"status\" variable:\n\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-February/011257.html\n\nCopying the relevant part here:\n\nTo make it clear what I am talking about, here is an example code in current Fortran:\nhttps://gist.github.com/certik/bd8235d2e1d049b22fcd1016f4914430\nHere is my original \"try\" proposal:\nhttps://gist.github.com/certik/d950b7468228ff6f7d8bbc680a0943a7\nand here is the new \"status\" proposal:\nhttps://gist.github.com/certik/2293270ac39f2589ae702ed751f405f8\n\nIn particular, the \"original try proposal\" is very similar to your \"try\" above. It doesn't throw allocatable derived type, but just an integer, although I think it probably can be extended to other types. But it's the same idea. The \"status proposal\" adds a status attribute to the return error value, and then the compiler knows to handle it if it is hot handled explicitly. Just a variation on the above theme.\nThe main objection to the \"status\" proposal from the J3 thread above is that\n\nThere is no simple way of accommodating all of the\nvarious schemes that libraries have for reporting problems. For example,\nsome of the Windows API routines return zero on failure and make you\ncall GetLastError to get the \"real\" error., others return zero on\nsuccess and an error code on failure. Any attempt to standardize how a\n\"status\" argument should behave is, I feel, doomed to failure.\n\nI think that is true that whatever we propose does not directly map into every possible error handling mechanism that a library might use. I think the idea of the above proposal (and its variations) is that it allows a simple solid mechanism to handle errors in Fortran that people can use, but don't have to. If they choose to use it, it should work for almost any use case, but one must adapt the library a bit. Perhaps gradually."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-20 14:24:18+00:00",
                    "text": "@aradi, regarding try i = function_with_error(...), what about: try i = (function_with_error(...)**2 + 1)*another_function_with_error(...)? Would the try propagate in the whole expression to any function that returns an error? In which case the error can always be propagated as an extra argument (whether subroutine or a function). This would eliminate the need for theResult<T> type, which is not as easy to do in Fortran.\nIndeed, I've tried to play around with the analog to Result<T>, but that is a mess in current Fortran, as you have to create a wrapper type for every function result type. Although, that may get more straightforward, if templates appear in Fortran (202y?)...\n\nI think, the try should apply to the entire rhs of the assignment (and even to the assignment itself, if we ever allow user defined assignments to throw exceptions...). I have no idea, how compilers deal wit the evaluation of complex expressions, but in current Fortran one would have to decompose the expression in its parts with maximally one error-throwing function call, then make the call, store the temporary result, make the check for the error, and then continue with the other parts of the expression. The one-liner\ntry res = function_throwing_error1(ierror)&\n    & + function_throwing_error2(ierror)\nhas the Fortran equivalent\n    try: block\n      integer :: tmpres1, tmpres2\n      tmpres1 = function_throwing_error1(ierror, internal_errorvar)\n      if (allocated(internal_errorvar)) return\n      tmpres2 = function_throwing_error2(ierror, internal_errorvar)\n      if (allocated(internal_errorvar)) return\n      res = tmpres1 + tmpres2\n    end block try\n(See also funcexpr_exception.f90 and funcexpr_exception_fxy.f90.)\nThe biggest problem I have with this variable extending approach, that we would be not allowed to use the exception mechanism in pure functions, while pure subroutines would be no problem. Of course, whether a function, which can throw an exception, should be considered pure or not, is something to discuss. (And for sure, one would have to disable exceptions for elemental procedures.)"
                },
                {
                    "user": "certik",
                    "date": "2021-10-20 14:28:08+00:00",
                    "text": "I have no idea, how compilers deal wit the evaluation of complex expressions, but in current Fortran one would have to decompose the expression in its parts with maximally one error-throwing function call, then make the call, store the temporary result, make the check for the error, and then continue with the other parts of the expression.\n\nYes, that's exactly how it would work. I don't see a problem from the implementation perspective. I don't know if there can be some issues with the Fortran standard, if we are breaking some rule about Fortran's expression evaluation.\n\nThe biggest problem I have with this variable extending approach, that we would be not allowed to use the exception mechanism in pure functions, while pure subroutines would be no problem.\n\nWhy cannot the function by pure that uses this mechanism?"
                },
                {
                    "user": "aradi",
                    "date": "2021-10-20 14:30:21+00:00",
                    "text": "Why cannot the function by pure that uses this mechanism?\n\nIIRC, pure functions can only have intent(in) arguments."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-20 14:38:17+00:00",
                    "text": "As for the status-proposal: I think, our current approach is superior. There is no scenario, where a program would be error stopped due to an exception. Rather, we would force the programmer to either handle the exception or propagate it upwards. Code, which does not do any of the two (e.g. which tries to ignore an exception) would be simply invalid.\nIf the programmer wanted to stop the code due to an exception, it would have to happen explicitly, e.g.\ntry catch\n  call subroutine_throwing_error(...)\ncatch all\n  error stop \"Routine failed and I don't want to deal with it\"\nend try\n\nAll intrinsic commands/routines (allocate, open, etc.) should still use their old way of reporting errors via integer flags. But the programmer should have a way to easily propagate this error up, if wanted:\nopen(file=\"test.dat\", ..., iostat=iostat)\nif (iostat /= 0) throw io_error(message=\"Could not open file\", file=\"test.dat\")\n\nThe exception io_error is defined by the programmer, with arbitrary content, whatever makes sense in that project. The only thing forced upon the programmer is the necessity to handle/propagate errors if an error throwing procedure was invoked."
                },
                {
                    "user": "certik",
                    "date": "2021-10-20 20:10:51+00:00",
                    "text": "Yes, I like this overall design so far. That's where a compiler comes in, to enforce that the error is handled one way or another. The way it is enforced in your library currently is that it will fail at runtime when the error object gets deallocated, which is the only way I think it can be done currently, but if it is part of the language, then it will get enforced at compile time, which I think is much better."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-30 16:47:00+00:00",
                    "text": "@certik In case, you want to prototype it in LFortran, I've found a blog entry about the error handling implementation in Swift. I think, this lightweight solution should be exactly, what we should be heading for.\nActually, thinking about Swifts strategy, we could also consider to use a simple throws clause without an explicit list of the error types thrown by the routine:\nsubroutine subroutine_with_error(...) throws\n  ...\n  throw io_error(name=\"somefile.dat\")\n ...\nend subroutine subroutine_with_error\nThis would then simplify interface declarations as well, as one would not have to list all the errors explicitly. And we should go with the Swift convention, that an routine, which does not throw an error, matches an interface, which allows for error throwing (but not the other way around). We should then probably also require, that every try catch structure must have a catch all clause, unless the embedding routine itself has the throws clause. That way, it remains a simple compile time decision, whether a given routine may throw an error or not.\nLast, but not least, we could also easily mimic Switfs try? and try! constructs. By allowing for a  try ... else ... in an assignment, we could provide an even superior alternative for their try?, where the default value is set explicitely:\n! some_value contains either the return value of function_throwing_error (if no error occured) or -1 (if error occured)\nsome_value = try function_throwing_error() else -1\nAnd the try! construct (which would stop in case the call throws an error), could be probably implemented with a special keyword\nsome_value = try_stop function_throwing_error()\nThe try_stop construct could also be used for subroutine calls, if the error should lead to an immediate stop:\n! Would stop the code, if the subroutine has thrown an error\ntry_stop call subroutine_throwing_error()"
                },
                {
                    "user": "certik",
                    "date": "2021-10-30 18:28:30+00:00",
                    "text": "I think the Swift's approach is essentially like Rusts or Zigs, except that Swift handles this automatically, so the error is not exposee explicitly as a type, but the compiler does the equivalent thing: it stores the error as a return type (in a special register) and checks it in the caller.\nThat is a design that we can also pursue -- just add some keywords like throws, which would instruct the compiler to return the error flag (either success or with an error struct).\nNotice that all these designs (Rust, Zig, Swift) have one thing in common: no long jump, no stack unwinding like traditional C++ exceptions. Just syntax sugar for returning the error as a result of a function or subroutine. They differ how the error is returned (whether explicitly, or implicitly)."
                }
            ]
        },
        {
            "number": 235,
            "user": "LydiaMarieWilliamson",
            "date": "2021-10-12 23:46:30+00:00",
            "title": "Multi-threading & appropriating/reinventing PAUSE, ENTRY, STOP, CALL, RETURN for use with it.",
            "text": "Adding the simplest multi-threading primitives that can be conceived, that would also happen to bring us one step closer to a bona fide implementation of the PI-calculus.\n(0A) Thread-local variables & declarations (a prerequisite to what follows).\n(0B) A \"channel\" descriptor type; similar to the \"unit\" descriptor type used with files.\n(1) Spawning new threads.\nSPAWN Function / Subroutine - works like a function or subroutine call, except it starts and runs in a new thread on its own thread-local space.\n(2) Exiting a thread\nSTOP - now appropriated to serve as a routine that removes the thread's locals and stack and space, and ends execution.\nRETURN - treated as equivalent to STOP, when the return takes place at the top level of a thread.\n(3) Pausing\nPAUSE Channel IOList\nStops the thread, to await activation from elsewhere (either from another thread, an exception or interrupt).\nExpects values to be assigned to the variables by whoever reactivates the thread.\nA routine may have multiple calls to PAUSE within it; each of them being treated as a separate entry point to the routine.\nThe multiple entry point facility in Fortran is appropriated for reuse in this new capacity.\nThe READ statement may also be used as equivalent to a PAUSE, when the read is done on a Channel.\nThe ENTRY statement is appropriated for reuse as a call to PAUSE.\n(4) Resuming\nRESUME Channel IOList\nResumes whatever thread is waiting on the given Channel and sends it the indicated value(s).\nA WRITE statement may also be used as equivalent to RESUME, when the write is done on a Channel.\nA CALL on an ENTRY point is appropriated for reuse as a call to RESUME.\n(5) Appropriating CALL and RETURN\nA semantic equivalence is mandated of the form:\n(a) A CALL to a function or routine X is treated as equivalent to a spawn on X, followed immediately by a PAUSE on a fictitous channel X_C, as if the function were a separate thread, which the calling thread is then set to wait on.\n(b) A RETURN from within a function or routine X is treated as equivalent to a resume on X_C, followed immediately by a STOP, as if the function's \"thread\" were eliminated, after the calling thread is resumed.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": []
        },
        {
            "number": 234,
            "user": "Beliavsky",
            "date": "2021-10-12 12:40:45+00:00",
            "title": "Syntax to initialize variables in declarations without SAVE",
            "text": "It is convenient to give a variable a value at the time it is declared, but in a procedure\ninteger :: i=0\nhas the implicit save attribute, which may not be wanted, and which many new Fortran programmers stumble over. I suggest adding an init attribute so that\ninteger, init :: i=0, j=1\nhas the same meaning as\ninteger :: i,j\ni = 0\nj = 1\n\nThen the programmer can set the value of a variable in a declaration with the init, save, or parameter attribute, depending the desired behavior.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-10-12 14:31:37+00:00",
                    "text": "This is a duplicate of #40 (comment), but keep it here as a top level issue, so that it is not buried in comments. However, every body please do read all the comments there, so that we do not repeat the discussion.\nOther relevant issues:\n\n#129\n#83\n#79"
                }
            ]
        },
        {
            "number": 233,
            "user": "klausler",
            "date": "2021-10-01 18:52:16+00:00",
            "title": "Clarification needed on host association vs implicit typing in specification expressions",
            "text": "In this example, there are references to a variable \"m\" in the specification parts of contained subroutines, yet there is no (other) mention of \"m\" in the host.\nmodule module\n contains\n  subroutine host(j)\n    ! Although \"m\" never appears in the specification or executable\n    ! parts of this subroutine, both of its contained subroutines\n    ! might be accessing it via host association.\n    integer, intent(in out) :: j\n    call inner1(j)\n    call inner2(j)\n   contains\n    subroutine inner1(n)\n      integer(kind(m)), intent(in) :: n\n      m = n + 1\n    end subroutine\n    subroutine inner2(n)\n      integer(kind(m)), intent(out) :: n\n      n = m + 2\n    end subroutine\n  end subroutine\nend module\n\nprogram demo\n  use module\n  integer :: k\n  k = 0\n  call host(k)\n  print *, k\nend\n\nSome Fortran compilers (seem to) interpret \"m\" as being host-associated in the inner procedures; others (seem to) interpret \"m\" as an implicitly typed local variable in the inner procedures.  Both interpretations seem allowed by 10.1.11(6): A variable in a specification expression shall have its type and type parameters, if any, specified by a previous declaration in the same scoping unit, by the implicit typing rules in effect for the scoping unit, or by host or use association.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2021-10-02 17:09:06+00:00",
                    "text": "@klausler posted Oct. 1, 2021, 2:52 PM EDT\n\n.. Some Fortran compilers (seem to) interpret \"m\" as being host-associated in the inner procedures; others (seem to) interpret \"m\" as an implicitly typed local variable in the inner procedures. Both interpretations seem allowed by 10.1.11(6) ..\n\nI suggest also sending this to the J3 mailing list for feedback, the J3 Interp subgroup can likely provide best guidance here.\nMy hunch (implicit bias may be): the standard intends to interpret \"m\" as an implicitly typed local variable in the inner procedures."
                }
            ]
        },
        {
            "number": 232,
            "user": "Beliavsky",
            "date": "2021-09-29 15:58:30+00:00",
            "title": "Format similar to f0.d but with a leading zero",
            "text": "I wish there were a format similar to f0.d for real numbers, maybe z0.d or fz0.d, that printed a leading zero for abs(x) < 1, so that\nwrite (*,\"(*(1x,z0.2))\") 0.34,-0.34\ngave\n0.34 -0.34\ninstead of\n.34 -.34\nI think it is generally recommended to use a leading zero to increase legibility and avoid errors where the decimal point is not noticed. I often use the f0.d format, but if z0.d existed, I would always use it instead. The z0.d format sometimes produces longer output, but most people who need small output files are not storing their results as plain text.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-10-01 20:38:45+00:00",
                    "text": "The Z edit descriptor is already claimed for hexadecimal formatting, unfortunately.\nThe current standard allows a Fortran implementation to emit a zero for F0.d editing when no digit would otherwise appear before the decimal symbol, and requires a zero there when no digit would otherwise appear.  I agree that it would be a good thing to have finer control over the output."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-10-02 16:44:55+00:00",
                    "text": "@Beliavsky writes Sep. 29, 2021, 11:58 AM EDT:\n\nI wish there were a format similar to f0.d for real numbers, maybe z0.d or fz0.d\n\nNote the discussion elsewhere with the use of 'Z\" in Fortran with hexadecimal notation, including edit descriptor.\nIn the mean time, try making do with g edit descriptor e.g., g0.2"
                },
                {
                    "user": "sblionel",
                    "date": "2021-10-08 19:16:40+00:00",
                    "text": "Fortran 202X has control over leading zeros in F format. See https://j3-fortran.org/doc/year/19/19-156r1.txt for details."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-10-12 12:32:15+00:00",
                    "text": "Closing this issue since the requested functionality has already been approved."
                }
            ]
        },
        {
            "number": 231,
            "user": "abensonca",
            "date": "2021-09-27 20:33:05+00:00",
            "title": "Finalization of class arrays; interpretation of standards",
            "text": "I'm working (with much help from Paul Thomas) on adding finalization on intrinsic assignment to gfortran. There are a few instances where I'm unclear on precisely what is required by the standard, so would be very grateful for any insight any one here can offer.\nThis example considers finalization of a class array:\nmodule testmode\n  implicit none\n\n  character(4) :: scope = \"MAIN\"\n\n  logical, parameter :: instrument = .false.\n\n  type :: simple\n    character(4) :: scope\n    integer :: ind\n  contains\n    final :: destructor1, destructor2\n  end type simple\n\n  type, extends(simple) :: complicated\n    real :: rind\n  contains\n    final :: destructor3, destructor4\n  end type complicated\n\n  integer :: check_scalar\n  integer :: check_array(4)\n  real :: check_real\n  real :: check_rarray(4)\n  integer :: final_count = 0\n\ncontains\n\n  subroutine destructor1(self)\n    type(simple), intent(inout) :: self\n    print *, \"destructor1(\", self%scope, \") \", self%ind\n  end subroutine destructor1\n\n  subroutine destructor2(self)\n    type(simple), intent(inout) :: self(:)\n    print *, \"destructor2(\", self(1)%scope, \") \", self%ind\n  end subroutine destructor2\n\n  subroutine destructor3(self)\n    type(complicated), intent(inout) :: self\n    print *, \"destructor3(\", self%scope, \") \", self%rind\n  end subroutine destructor3\n\n  subroutine destructor4(self)\n    type(complicated), intent(inout) :: self(:)\n    if (size(self, 1) .gt. 0) then\n      print *, \"destructor4(\", self(1)%scope, \") \", size(self%rind), self%rind\n    else\n      print *, \"destructor4\"\n    end if\n  end subroutine destructor4\n\n  function constructor1(ind) result(res)\n    type(simple), allocatable :: res\n    integer, intent(in) :: ind\n    scope = \"CTR1\"\n    allocate (res, source = simple (\"SOUR\", ind))\n    res%scope = scope\n  end function constructor1\n\n  function constructor2(ind, rind) result(res)\n    class(simple), allocatable :: res(:)\n    integer, intent(in) :: ind(:)\n    real, intent(in), optional :: rind(:)\n    type(complicated), allocatable :: src(:)\n    integer :: sz\n    integer :: i\n    scope = \"CTR2\"\n    if (present (rind)) then\n      sz = min (size (ind, 1), size (rind, 1))\n      src  = [(complicated (\"SOUR\", ind(i), rind(i)), i = 1, sz)]\n      allocate (res, source = src)\n      src%scope = \"SRC \"\n      res%scope=scope\n    else\n      sz = size (ind, 1)\n      allocate (res, source = [(simple (scope, ind(i)), i = 1, sz)])\n    end if\n  end function constructor2\nend module testmode\n\nprogram test_final\n  use testmode\n  implicit none\n\n  class(simple), allocatable :: MyClassArray(:)\n\n! *****************\n! Class assignments\n! *****************\n\n  allocate (MyClassArray, source = [complicated(scope, 1, 2.0),complicated(scope, 3, 4.0)])\n  print *, \"[3] ...until here. Both call the rank-1 finalizer for the extended &\n            type but ifort calls the rank-0 finalizer for the parent type, while &\n            gfortran uses the rank-1 finalizer.\"\n  deallocate (MyClassArray)\nend program test_final\n\nWith gfortran (including the patches for finalization on intrinsic assignment that I'm working on), this results in:\n [3] ...until here. Both call the rank-1 finalizer for the extended type but ifort calls the rank-0 finalizer for the parent type, while gfortran uses the rank-1 finalizer.\n destructor4(MAIN)            2   2.00000000       4.00000000    \n destructor2(MAIN)            1           3\n\nwhich shows that, when deallocating 'MyClassArray', the rank-1 finalizer for the extended type 'complicated' is called, and then the rank-1 finalizer for the parent type 'simple' is called.\nBut, under ifort I get:\n [3] ...until here. Both call the rank-1 finalizer for the extended type but ifo\n rt calls the rank-0 finalizer for the parent type, while gfortran uses the rank\n -1 finalizer.\n destructor4(MAIN)            2   2.000000       4.000000    \n destructor1(MAIN)            1\n destructor1(MAIN)            3\n\nshowing that the rank-1 finalizer is called for the extended type, but then the scalar finalizer of the parent type is called twice, once for each element in the array.\nifort's behavior seems incorrect here (based on my reading of the F2018 standards), but I'd be interested to hear anyone's opinion on this.\nThanks,\nAndrew",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-09-27 21:35:32+00:00",
                    "text": "Hi @abensonca thanks for your work on gfortran and for asking here. Is your question the same as #146, or different?"
                },
                {
                    "user": "abensonca",
                    "date": "2021-09-27 21:43:22+00:00",
                    "text": "Hi @certik - I read through #146 and I don't think my question here is the same issue. In this case I'm not concerned about the order of the finalization. Instead my concern is whether it is ever correct to call a non elemental scalar finalizer subroutine on elements of a rank-1 derived-type array? The Intel compiler is doing this - it calls a rank-1 finalizer on the extended type of the array, but then calls a (non-elemental) scalar finalizer on the parent type of each element of the array. This seems wrong to me."
                },
                {
                    "user": "nncarlson",
                    "date": "2021-09-27 22:06:11+00:00",
                    "text": "I think Intel's behavior is incorrect as well.  The process described in paragraph 7.5.6.2 (3) essentially recurses to (1), and I'm not aware of any other place in the standard that speaks to this.\nI compiled your example with the NAG 7.0 compiler and it behaves like you've described for gfortran."
                },
                {
                    "user": "klausler",
                    "date": "2021-09-27 22:17:43+00:00",
                    "text": "@abensonca (repeating what I wrote to you on Discourse) - the answer is that no, a non-ELEMENTAL final subroutine with a scalar argument should not be called elementally, and so ifort is broken.  (And an ELEMENTAL final subroutine should be called only when there's no other final subroutine with a matching rank.)\nThis applies at each level of typing, so if a parent type has (say) a rank-1 final subroutine, and an extension of that derived type has only an ELEMENTAL final subroutine, then a vector of the extended type will be finalized by calling the extended type's final subroutine for each element, and then the parent's final procedure will be called (once) for the parent component of the vector."
                },
                {
                    "user": "abensonca",
                    "date": "2021-09-27 22:27:39+00:00",
                    "text": "Thanks @nncarlson and @klausler for your help on this."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-09-28 16:38:02+00:00",
                    "text": "@abensonca wrote Sep 27, 2021 4:33 PM EDT:\n\nifort's behavior seems incorrect here (based on my reading of the F2018 standards), but I'd be interested to hear anyone's opinion on this.\n\nFor whatever it's worth and I'm open to being proved wrong on this: I think Intel Fortran's finalization process toward the code in the original post vis-a-vis the standard is entirely acceptable.\nNote the standard is (purposefully I think) not prescriptive when it comes to the finalization process, there is a desired end state of a finalized entity in the standard even as it is not clearly spelled out.  Nonetheless the standard effectively permits the processors multiple pathways to arrive at that end state.  Comparison of those pathways, which is what the original post attempts, is not particularly meaningful in this context, at least as the standard is currently written.\nSection 7.5.6.2 The finalization process in 18-007r1 document toward the 2018 standard by and large gives a lot of leeway to the processor and there are no numbered rules or constraints in this section enforcing the program or processor behavior.\nTaking into consideration the first paragraph in section 7.5.6.2 and the numbered bullets therein in conjunction with section 7.5.7 on type extension, a fair argument can be made the finalization process in the following code is analogous to the one in the original post:\nmodule m\n   type :: a_t\n   contains\n      final :: f_a_r0\n   end type\n   type :: b_t\n      type(a_t) :: a\n   contains\n      final :: f_b_r0, f_b_r1\n   end type \ncontains\n   subroutine f_a_r0( a )\n      type(a_t), intent(inout) :: a\n      print *, \"finalizer rank-0 a_t\"\n   end subroutine \n   subroutine f_b_r0( b )\n      type(b_t), intent(inout) :: b\n      print *, \"finalizer rank-0 b_t\"\n   end subroutine \n   subroutine f_b_r1( b )\n      type(b_t), intent(inout) :: b(:)\n      print *, \"finalizer rank-1 b_t\"\n   end subroutine \nend module\n   use m\n   block\n      type(b_t) :: foo(3)\n   end block\nend \nAnd for this, a standard-conforming processor can be expected to yield the following program behavior:\n\nC:\\Temp>ifort /standard-semantics f.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.3.0 Build 20210609_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.29.30038.1\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:f.exe\n-subsystem:console\nf.obj\nC:\\Temp>f.exe\nfinalizer rank-1 b_t\nfinalizer rank-0 a_t\nfinalizer rank-0 a_t\nfinalizer rank-0 a_t\n\nas does Intel Fortran and NAG Fortran (though not gfortran**).\nOstensibly the 2 processors in this case simply follow the steps in section 7.5.6.2 and there is no argument to be made about any processor nonconformance with the simple code here.  The key sentences in the standard are \"If the entity being finalized is an array, each finalizable component of each element of that entity is finalized separately\" followed by \"If the entity is of extended type and the parent type is finalizable, the parent component is finalized\"\nAnd what Intel Fortran does with the code in the original post is consistent with this and I think it is conformant with the standard.\n** gfortran has gaps when it comes to finalization of nonallocatable but finalizable objects, the code here is an example of this.\n@abensonca, you may be interested in including this case in your work."
                },
                {
                    "user": "abensonca",
                    "date": "2021-09-28 16:41:23+00:00",
                    "text": "@FortranFan That does seem like a reasonable interpretation of the standard. And thanks for pointing out the limitation of gfortran with finalizing non-allocatable objects - I'll add this to my test cases and see if it's possible to fix this behavior."
                },
                {
                    "user": "abensonca",
                    "date": "2021-10-18 14:42:04+00:00",
                    "text": "A follow-on to the above case:\nmodule testmode\n  implicit none\n\n  character(4) :: scope = \"MAIN\"\n\n  logical, parameter :: instrument = .false.\n\n  type :: simple\n    character(4) :: scope\n    integer :: ind\n  contains\n    final :: destructor1, destructor2\n  end type simple\n\n  type, extends(simple) :: complicated\n    real :: rind\n  contains\n    final :: destructor3, destructor4\n  end type complicated\n\n  integer :: check_scalar\n  integer :: check_array(4)\n  real :: check_real\n  real :: check_rarray(4)\n  integer :: final_count = 0\n\ncontains\n\n  subroutine destructor1(self)\n    type(simple), intent(inout) :: self\n    print *, \"destructor1(\", self%scope, \") \", self%ind\n  end subroutine destructor1\n\n  subroutine destructor2(self)\n    type(simple), intent(inout) :: self(:)\n    print *, \"destructor2(\", self(1)%scope, \") \", self%ind\n  end subroutine destructor2\n\n  subroutine destructor3(self)\n    type(complicated), intent(inout) :: self\n    print *, \"destructor3(\", self%scope, \") \", self%rind\n  end subroutine destructor3\n\n  subroutine destructor4(self)\n    type(complicated), intent(inout) :: self(:)\n    if (size(self, 1) .gt. 0) then\n      print *, \"destructor4(\", self(1)%scope, \") \", size(self%rind), self%rind\n    else\n      print *, \"destructor4\"\n    end if\n  end subroutine destructor4\n\n  function constructor1(ind) result(res)\n    type(simple), allocatable :: res\n    integer, intent(in) :: ind\n    scope = \"CTR1\"\n    allocate (res, source = simple (\"SOUR\", ind))\n    res%scope = scope\n  end function constructor1\n\n  function constructor2(ind, rind) result(res)\n    class(simple), allocatable :: res(:)\n    integer, intent(in) :: ind(:)\n    real, intent(in), optional :: rind(:)\n    type(complicated), allocatable :: src(:)\n    integer :: sz\n    integer :: i\n    scope = \"CTR2\"\n    if (present (rind)) then\n      sz = min (size (ind, 1), size (rind, 1))\n      src  = [(complicated (\"SOUR\", ind(i), rind(i)), i = 1, sz)]\n      allocate (res, source = src)\n      src%scope = \"SRC \"\n      res%scope=scope\n    else\n      sz = size (ind, 1)\n      allocate (res, source = [(simple (scope, ind(i)), i = 1, sz)])\n    end if\n  end function constructor2\nend module testmode\n\nprogram test_final\n  use testmode\n  implicit none\n\n  type(simple), allocatable :: MyType, MyType2\n  type(simple), allocatable :: MyTypeArray(:)\n  type(simple) :: ThyType = simple(\"MAIN\", 21), ThyType2 = simple(\"MAIN\", 22)\n  class(simple), allocatable :: MyClass\n  class(simple), allocatable :: MyClassArray(:)\n\n! *****************\n! Class assignments\n! *****************\n\n  allocate (MyClassArray, source = [complicated(scope, 1, 2.0),complicated(scope, 3, 4.0)])\n  print *, \"[3] ...esuntil here. Both call the rank-1 finalizer for the extended &\n            type but ifort calls the rank-0 finalizer for the parent type, while &\n            gfortran uses the rank-1 finalizer.\"\n  deallocate (MyClassArray)\n  print *, \"After deallocation of MyClassArray.\"\n  print *, \"Now MyClassArray = constructor2 ([10,20], [10.0,20.0])\"\n  print *, \"ifort continues to use the rank-1 finalizer for the parent type.\"\n  print *, \"[4] Both call extended + parent finalizers twice but, the second time &\n       ifort shows the component 'rind' as having size 0\"\n  MyClassArray = constructor2 ([10,20], [10.0,20.0])\n\nend program test_final\n\nThe modified gfortran I'm working on outputs:\n [3] ...esuntil here. Both call the rank-1 finalizer for the extended type but ifort calls the rank-0 finalizer for the parent type, while gfortran uses the rank-1 finalizer.\n destructor4(MAIN)            2   2.00000000       4.00000000    \n destructor2(MAIN)            1           3\n After deallocation of MyClassArray.\n Now MyClassArray = constructor2 ([10,20], [10.0,20.0])\n ifort continues to use the rank-1 finalizer for the parent type.\n [4] Both call extended + parent finalizers twice but, the second time ifort shows the component 'rind' as having size 0\n destructor4(SRC )            2   10.0000000       20.0000000    \n destructor2(SRC )           10          20\n destructor4(CTR2)            2   10.0000000       20.0000000    \n destructor2(CTR2)           10          20\n\nwhile ifort outputs:\n [3] ...esuntil here. Both call the rank-1 finalizer for the extended type but i\n fort calls the rank-0 finalizer for the parent type, while gfortran uses the ra\n nk-1 finalizer.\n destructor4(MAIN)            2   2.000000       4.000000    \n destructor1(MAIN)            1\n destructor1(MAIN)            3\n After deallocation of MyClassArray.\n Now MyClassArray = constructor2 ([10,20], [10.0,20.0])\n ifort continues to use the rank-1 finalizer for the parent type.\n [4] Both call extended + parent finalizers twice but, the second time ifort sho\n ws the component 'rind' as having size 0\n destructor4(SRC )            2   10.00000       20.00000    \n destructor1(SRC )           10\n destructor1(SRC )           20\n destructor4\n destructor1(CTR2)           10\n destructor1(CTR2)           20\n\nThe last statement in this example assigns to MyClassArray. As stated in the output, both gfortran and ifort call the extended & parent type finalizers twice (once for the src object used in constructor2(), and once for the object returned by constructor2(). But, for ifort, for the second call to the finalizer ifort shows the component rind as having zero size (and valgrind shows some \"invalid read\" errors here).\nifort's behavior seems broken here, but I'd be interested and grateful if anyone can show results for this code with NAG or other compilers for comparison."
                }
            ]
        },
        {
            "number": 230,
            "user": "ivan-pi",
            "date": "2021-09-24 11:55:32+00:00",
            "title": "Proposal web-page generation (meta)",
            "text": "Looking at some recent (self-hosted) proposals to the C++ standard library, e.g. P1935R0 A C++ Approach to Physical Units, there appears to be a template available to generate a nicely styled webpage.\nDoes the current proposal format allow something like to be done already? Perhaps if proposals were written in Markdown or Restructured Text, a tool could be built that would 1) output a simply txt file proposal as expected by the committee, and 2) generate a HTML webpage.\nDisadvantages:\n\ninvolves more tools, making the process more complicated\ncould introduce bias, with proposals that are \"pretty\"-formatted receiving more attention (or vice versa)\n\nAdvantages:\n\ndocument layout (headings, sections, etc.) help guide the eye\nhyper-links actually work\nformatted code snippets\npossible to include images, diagrams and other content which can be displayed by a browser",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-09-24 13:38:08+00:00",
                    "text": "Great idea indeed. Then we can setup a CI in this repository that accepts Markdown + some metadata, there are several options, here is one alternative:\n\nhttps://gitlab.com/lfortran/web/www.lfortran.org/-/raw/8e9b73fe1ae12ae1d1b01ac4ecddd9f0149c3999/content/blog/lfortran-mvp.md\n\nYou can see the metadata at the top. Then we process it and report any errors. If the tool \"accepts\" it, then it can exactly generate the txt proposal to be uploaded at: https://j3-fortran.org/doc/meeting in the expected format. And it can also then process it and generate a nice html proposal for easy reading."
                }
            ]
        },
        {
            "number": 229,
            "user": "dalon-work",
            "date": "2021-09-22 10:43:44+00:00",
            "title": "Add keyword to support inlining across modules",
            "text": "The idea is pretty simple: Allow marking public module functions/subroutines with a keyword such as 'inline' or 'export'. This requires the compiler to place the implementation, and not just the interface of the subroutine in the binary module file. Modules that use this 'inlined' module will be able to see the implementation of the subroutine and potentially inline it. The decision to inline or not is left up to the compiler.\nThis would replace many uses of #include for performance reasons, and would have the greatest benefits for small functions where the function call overhead is comparable to the actual work of the function.\nThis would give us the benefits of modules, while still allowing an important optimization that fortran currently misses, and removing a preprocessor peril.\nYou could argue that Link-Time Optimization has already made this idea obsolete, but I'm not convinced LTO has become ubiquitous?\nThoughts?",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-09-22 14:54:26+00:00",
                    "text": "On this theme, LFortran currently places all implementations in the mod file, precisely so that they can be inlined later on. I strongly suspect inlinging at link time is too late, I think the best way is to inline at the \"Fortran level\". I don't know yet however if it is sustainable to include all implementations in the mod file, or whether we should only include those that the user selects using the \"inline\" keyword (alternatively the compiler could always include just those functions that are candidates for inlining, skipping large functions). But I will know the answer once we can compile large production codes, probably in a year or so."
                },
                {
                    "user": "zerothi",
                    "date": "2022-04-11 10:07:39+00:00",
                    "text": "I would prefer not going this path.\nC++ and other languages has tons of these features, while these are good shortterm C++ is now becoming a beast with so many additional keywords that does this and that. It effectively becomes too hard to understand the code (something I think fortran is trying to maintain, and should).\nI agree that inlining would be nice, but I am afraid this will fill fortran code with official and non-official keyword extensions."
                },
                {
                    "user": "perazz",
                    "date": "2022-04-26 16:25:14+00:00",
                    "text": "I was about to suggest the same feature and I found it was proposed already so I'm going to give it my additional \"thumbs up\" here.\nI see most of the features for F202Y are making it converge toward being \"C++-like\" and this would be no stranger,\nbut I believe one of the major (only?) reasons people are still coding Fortran besides backward compatibility is SPEED.\nBeing able to inline functions across modules at compile time is very strongly needed IMHO because, with all modern structures like classes, modules, submodules, code goes scattered across files and the impossibility to do compile-time inlining across them is a very severe limitation that can make Fortran much slower than C/C++.\nConsider this example: Having a very basic module/class for 3D points, with some very simple overloaded operators:\ntype :: vec3\n   real(real64) :: x,y,z\n   contains\n      procedure, private :: vec3_sum_vec3\n      generic :: operator(+) => vec3_sum_vec3\nend type vec3 \n\ncontains\n\nelemental type(vec3) function vec3_sum_vec3(a,b) result(c)\n   class(vec3), intent(in) :: a,b\n   c%x=a%x+b%x\n   c%y=a%y+b%y\n   c%z=a%z+b%z\nend function vec3_sum_vec3\n\n\nFunction vec3_sum_vec3 is going to get called a gazillion amount of times across any code that makes usage of this class; yes, the class could be extended, so the inline feature could be prescribed in all inherited variants."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-04-26 17:51:15+00:00",
                    "text": "Fortran 202X introduces SIMPLE procedures that can also be ELEMENTAL.\nThe vec3_sum_vec3 example in the post above is in principle a simple procedure; starting Fortran 202X, it can be CLAUSEd as such.  This can be a clear indication to the compiler such a procedure can be inlined if the compiler can estimate a benefit with it.\nIf a procedure is not simple or even pure, chances are rather high inlining will prove costly.\nThus a question for @certik and everyone with compiler development expertise: can the already available CLAUSEs such as SIMPLE (and ELEMENTAL, and perhaps even PURE) be the \"clues\" for compilers here for greater performance and optimization?  That is after all also the purpose of these CLAUSEs.\nWhy introduce any additional keywords into the language?"
                },
                {
                    "user": "perazz",
                    "date": "2022-04-26 18:46:06+00:00",
                    "text": "I agree there's too many function clauses already and that the philosophy is to leave the compiler \"do the hard work\";\nI guess my point on inlining was about forcing the compiler do it instead of just allowing it,\nI believe any other SIMPLE/PURE clauses could be a prerequisite to it.\nAnother way to achieve this behavior could be to force type-bound procedures being included in the module file?\nThat would nicely connect to old-style file inclusion, and would not require new keywords. Think of something like:\ntype :: vec3\n   real(real64) :: x,y,z\n   contains\n      procedure, include, private :: vec3_sum_vec3\n      generic :: operator(+) => vec3_sum_vec3\nend type vec3 \n\nOr, on a procedure interface:\nmodule vec3_m\n\npublic, include :: vec3_sum_vec3\n\n[...]"
                },
                {
                    "user": "certik",
                    "date": "2022-04-26 18:57:55+00:00",
                    "text": "I think that this is something that we should implement in a compiler and experiment with before we propose it. In C++ the inline keyword is not forcing the compiler to inline it either. So from that perspective, the simple or pure keyword can act in the same way.\nWe could also introduce an inline keyword that will force the compiler to always inline, and we can experiment with it. LFortran has a function inlining optimization (prototype so far) and I think it can inline across module boundaries, as the compiler sees the whole code. We still have to implement criteria when the function should be inlined. Typically some kind of heuristics.\nAs a user, I think I would like to be able to tell the compiler to always inline a certain function."
                },
                {
                    "user": "gklimowicz",
                    "date": "2022-04-27 17:07:32+00:00",
                    "text": "Fortran 202X introduces SIMPLE procedures that can also be ELEMENTAL.\n...\nIf a procedure is not simple or even pure, chances are rather high inlining will prove costly.\nThus a question for @certik and everyone with compiler development expertise: can the already available CLAUSEs such as SIMPLE (and ELEMENTAL or perhaps PURE) be the \"clues\" for compilers here for greater performance and optimization? That is after all also the purpose of these CLAUSEs.\n\nI favor this tactic. I would like to see this level of inlining treated as a \"quality of implementation\" issue until we have more formal experience with it. (My uninformed guess is that some compilers already do the inlining.)"
                },
                {
                    "user": "klausler",
                    "date": "2022-04-27 17:14:45+00:00",
                    "text": "Suggestion: if a keyword be added (INLINE or whatever), have it imply some semantics.  Some things can be difficult to handle in a compiler when inline expansion is taking place, and a keyword would prohibit their use in a subprogram in a way that is analogous to the restrictions that one accepts when using PURE or DO CONCURRENT.  An obvious item on that list would be to prohibit local objects with the SAVE attribute (explicit or implied)."
                },
                {
                    "user": "dalon-work",
                    "date": "2022-04-28 02:32:23+00:00",
                    "text": "Thanks everyone for the interest!\nWhat I've found most interesting in this conversation is that the LFortran compiler places implementations in the binary module file by default. Do other compilers do that?\nThe closest analogue to my original request that I know of is in the new C++20 module system. If a templated function is 'exported', then the entire body of the function has to be placed in the resulting binary module file so the function can be instantiated later. The C++ standard doesn't speak of the actual implementation details, so it is unclear if the definition of a non-templated function will end up in the binary module file. There seems to be, IMHO, an unspoken expectation by those who write/speak about C++20 modules that this will be the case.\nAs for forcing inlining, most languages I know have some mechanism for doing so, but it's never at the language level. It's always some sort of compiler-specific thing.\nC/C++ - every compiler as their own way of specifying it\nJulia - @inline macro\nRust - #[inline(always)] function attribute - (works across crate boundaries!!)\nSince Fortran likes to leave things up to the compilers, perhaps this discussion will at least encourage compiler writers to do this optimization for 'small' functions so they can be inlined across module boundaries.\nFor those compilers that choose not to do this optimization, there is always LTO..."
                },
                {
                    "user": "certik",
                    "date": "2022-04-28 03:48:08+00:00",
                    "text": "What I've found most interesting in this conversation is that the LFortran compiler places implementations in the binary module file by default. Do other compilers do that?\n\nI think the Zig compiler also has access to all the code when compiling the main program, unless I am mistaken."
                },
                {
                    "user": "perazz",
                    "date": "2022-04-28 07:05:05+00:00",
                    "text": "I'm no expert in assembly code, but I've entered my example in godbolt and it looks like:\n\ngfortran 11.3 (older ones look similar) will inline both scalar and array versions of the function with -O3; with -O2, only the array version is inlined\nvec3_sum_vec3 is inlined even if it's got no elemental or pure clauses.\nifort 2021 seems to always inline.\n\nI couldn't put the module in a physically separate file from the main program there, that would have tested the exact scenario I am referring to."
                }
            ]
        },
        {
            "number": 228,
            "user": "Beliavsky",
            "date": "2021-09-10 15:53:13+00:00",
            "title": "Make passing an intent(in) argument to a procedure with unspecified intent obsolescent",
            "text": "Compilers do not warn you if you pass an intent(in) argument as an argument with unspecified intent to another procedure. This allows you to inadvertently write code where an intent(in) argument changes its value within a procedure, for example\nmodule m\nimplicit none\ncontains\nsubroutine foo(i)\ninteger, intent(in) :: i\ncall increment(i)\nend subroutine foo\n\nsubroutine increment(i)\ninteger :: i\n! integer, intent(in out) :: i ! will not compile if this line uncommented\ni = i+1\nend subroutine increment\nend module m\n\nprogram main\nuse m, only: foo\nimplicit none\ninteger :: i\ni = 3\ncall foo(i)\nprint*,i ! gives output 4\nend program main \n\nI suggest that passing an intent(in) variable to a procedure as an argument that is not intent(in) be made obsolescent, so that compilers will warn about this. The user could add intents where needed, make copies of intent(in) arguments passed to procedures without intents, or ignore or turn off the warning. There is much modern Fortran code with intents that calls Fortran 77 code without intents, so making it illegal will not be feasible for a long time.\nFor pure and elemental procedures, the language is strict. A pure procedure can only call procedures that are declared pure or elemental. It is not enough that those procedures satisfy the properties of pure procedures. I am suggesting that the requirements for intent(in) be similarly strengthened. This idea has been discussed on Fortran Discourse.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-09-10 22:37:10+00:00",
                    "text": "There is a distinction to be made between procedures with explicit interfaces and no INTENT vs. procedures with implicit interfaces.  The \"Fortran 77 code without intents\" that you mention are procedures with implicit interfaces, not procedures with explicit interfaces and no INTENT."
                },
                {
                    "user": "certik",
                    "date": "2021-09-11 17:48:57+00:00",
                    "text": "As @klausler said, I always call F77 code by writing an explicit interface and specify intent. Then I think there is no problem and even old code will work with the above proposed warning on."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-09-20 17:06:52+00:00",
                    "text": "If it was up to me Fortran would:\n\nrequire intent to be specified for all dummy arguments\nnot allow routines without explicit interfaces (i.e., all routines must be in modules or have an interface specified)."
                },
                {
                    "user": "certik",
                    "date": "2021-09-20 18:48:50+00:00",
                    "text": "Thanks @jacobwilliams. Added both into https://gitlab.com/lfortran/lfortran/-/issues/450. I think this can be fixed by a compiler simply giving an error. I bet a lot of people would enable such a mode even by default. (Obviously one could turn it off.)"
                }
            ]
        },
        {
            "number": 227,
            "user": "klausler",
            "date": "2021-09-09 21:02:34+00:00",
            "title": "Minor: missing constraint on END INTERFACE generic-spec (R1504)",
            "text": "(I found the thing that I had thought was an omitted constraint in the standard, so never mind.)",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 226,
            "user": "sblionel",
            "date": "2021-09-03 18:29:50+00:00",
            "title": "Deprecate D edit descriptor",
            "text": "The D format edit descriptor is a relic of the original (1957) FORTRAN, where DOUBLE PRECISION was a distinct datatype from REAL. It no longer serves a useful purpose, and was not extended when variants of the E descriptor (Ew.dEe, EN, ES) were added, so there is already an asymmetry. The various E edit descriptors can be used for all REAL kinds.\nI propose adding the D edit descriptor to the Obsolescent list for 202Y. This would not affect the use of D as an exponent letter in literal constants or in formatted input.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Fortran 202y",
                "Clause 13"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-09-07 17:02:01+00:00",
                    "text": "All of the six Fortran compilers to which I have access emit 0.10D+09 for PRINT '(D10.2)', 1.0D8.  Other output forms would be conforming (0.10E+09, 0.10+009) but that's what you get today.\nQ format output editing is a thing in XLF, and it's just like D except for the letter that comes out before the exponent.  You don't have to worry about deprecating it (obviously) but maybe it exists because some users like to see visual cues of precision in the output of some programs.\nWhile you're at this, consider also deprecating or deleting 0.10+009 (with no E or D) as a conforming option for the output of (Ew.d) (no Ee).  I can't find an implementation that emits it, and it may be an truly dead aspect of the language."
                },
                {
                    "user": "sblionel",
                    "date": "2021-09-07 17:19:02+00:00",
                    "text": "No, 0.10+009 would not be standard-conforming. The standard specifies omitting the exponent letter only if the decimal exponent is between 100 and 999. This could not be deprecated, unless you wanted to introduce an incompatible change in behavior (such as filling the field with asterisks.) It's also not a syntax term that could be deprecated. But see also https://j3-fortran.org/doc/year/21/21-172.txt\n(Intel Fortran currently has a bug where it will emit .10+009 for that value with an E0.2E3 format, and similar any time w=0. I reported it.)\nQ as an edit descriptor has different meanings across compilers. In the DEC-heritage compilers it is used during input and transmits the number of remaining characters in the record to the next list item."
                },
                {
                    "user": "klausler",
                    "date": "2021-09-07 17:42:35+00:00",
                    "text": "Please refer to table 13.1 in Fortran 2018; the part for \"Dw.d\" allows \"D+zz\", \"E+zz\", or \"+0zz\" when ABS(exp)<=99.  At least in my PDF."
                },
                {
                    "user": "sblionel",
                    "date": "2021-09-07 17:58:19+00:00",
                    "text": "Ah, right - somehow I overlooked that. I haven't ever seen an implementation choose that."
                },
                {
                    "user": "sblionel",
                    "date": "2021-09-08 23:47:44+00:00",
                    "text": "I suppose it would be feasible to remove that alternate form from the standard - we have changed behaviors before. It wouldn't invalidate any existing programs, but compilers claiming to support the new standard simply wouldn't emit that form (not that I think any do now.)"
                }
            ]
        },
        {
            "number": 225,
            "user": "FortranFan",
            "date": "2021-08-26 03:47:41+00:00",
            "title": "A new category of outmoded features: Retired",
            "text": "Background\nFortran standard revisions starting Fortran 90 include 2 categories of \"outmoded features\": Deleted and Obsolescent.\nWith Deleted features, the standard makes their status clear, such features are simply \"not included\" starting with the revision the features get placed in that category.\nThe Obsolescent category however is indistinct: the features in this category remain included in the standard albeit with a smaller type size; additionally, newer feature additions to the standard need to integrate with them.  A revealing example of this issue is fixed-form source, which has been obsolescent since the Fortran 95 revision that was published nearly 25 years ago, and the feature set under development as part of \"Conditional Expressions\" in Fortran 202X wherein the proposed and voted-upon solution was predicated by the need to work with both source forms.\nAnd note the standard states, \"A future revision of this part of ISO/IEC 1539 might delete an obsolescent feature if its use has become insignificant.\"  Note the operative phrase, \"if its use has become insignificant.\"  There is no objective method amenable to anyone including the Fortran standard body to ascertain when the use of obsolescent feature has become insignificant.  Consider implicit mapping which is not yet obsolescent: one is hard-pressed to point to a single codebase among the vast number of known and now increasingly public codebases that truly and purposefully employs the implicit mapping facility in the standard.  Yet the refrain remains there are significant investments with such a feature remaining in existing software and thus the feature cannot be deleted.\nThe situation then is the near impossibility of deleting an obsolescent feature when the continued presence and support of outmoded features hinders the advancement of the language and hurts its image and the goodwill around it.\nProposal\nIntroduce a new category termed Retired to unburden future revisions of the standard.  It is expected the standard body and the Community shall collaborate to determine the attributes of features marked as Retired.  The initial expectation with Retired features is\n\nthey are those that were first marked as Obsolescent,\nonce a feature is retired in a given standard revision, new feature introductions in that revision and subsequent revisions shall not be required to integrate with the retired feature with the possibility being also of the retired features being incompatible with subsequent new features,\nwhere a standard-conforming processor shall be asked to have the ability to detect and report them as such i.e., to the extent it is reasonable for a processor to do so within the rules and constraints in the standard; this is the same as included in the current standard with obsolescent features,\nthe retired features are identified in the standard by a relegation of all the details pertaining to its semantics and syntax to a certain location such as Annex xx (xx depending on the standard revision document),\nthe standard text on the retired features being considered as frozen, meaning no further edits or enhancements to the text of the standard shall be made to such features.\nthey are the ones that are on the slate for consideration toward eventual deletion from the standard.  That is, the order can be an outmoded feature goes to being Obsolescent first, then Retired, followed by Deleted.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "rouson",
                    "date": "2021-08-28 20:20:19+00:00",
                    "text": "I like this idea. It would be interesting to hear the Editor's perspective on the feasibility of this proposal.  For features that have a section of the standard devoted to them, it would be straightforward to move that section to an annex.  What about when the feature interact with another feature in some way that needs to be mentioned in a different section?  If these additional references to the retired feature are also moved to the annex, it might make parts of the standard tricky to use."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-29 17:02:09+00:00",
                    "text": "@rouson writes Aug. 28, 2021, 4:20 PM EDT:\n\nI like this idea. It would be interesting to hear the Editor's perspective on the feasibility of this proposal. For features that have a section of the standard devoted to them, it would be straightforward to move that section to an annex. What about when the feature interact with another feature in some way that needs to be mentioned in a different section? If these additional references to the retired feature are also moved to the annex, it might make parts of the standard tricky to use.\n\nGlad to read, \"I like this idea\".  I appreciate your comments and agree entirely with the concerns.\nBut I think things are coming to a head with Fortran i.e., the modern incarnation starting with the ISO/IEC 1539 : 1990 revision.\nModern Fortran is arriving (or has arrived) at the proverbial \"fork in the road\": to paraphrase Frost, does Fortran now take the easy path, one that is highly comforting to and strongly preferred by the dominant majority among the standard bearers and which addresses mostly some immediate needs only at considerable harm to longer-term innovation and advancement; or, embrace the harder path (fork) that requires more effort and attention to vision and be brave and which can strengthen the language, its advancement and its application toward the bigger challenges facing humanity whether it be climate change,  energy demands, pandemics, etc.\nFew things in life are easy; if they were, there would be no need for computers or computing generally.  Humanity could have made do with the digits on their hands, or having invented abacus, been content with it.\nNow, consider ANSI X3.9 1978, ISO 1539-1980 document that pursued full language and a subset language demarcations: \"FORTRAN 77 is a revision of American National Standard FORTRAN, ANSI X3.9-1966. It describes two levels of the FORTRAN language, referred to as FORTRAN and Subset FORTRAN. FORTRAN is the full language and appears on the righthand pages; Subset FORTRAN is a subset of the full language and appears on the lefthand pages.\"\nImagine the effort on the writers of 1539-1980 to layout the subset language on the lefthand pages and the FULL language on the righthand pages!\nThe proposal here is not specifically demanding the same approaches as pursued previously be adopted exactly, not by any means.  The suggestion here is mostly to be inspired.  When there were needs, those who preceded in Fortran's journey did the hard yards.  There is so much an Editor (or an Editorial Board) can do now to achieve more with lesser effort with modern document management tools and collaborative approaches and crowdsourcing.  If there is a will, there will be a way.\nRather than preserve the status quo, can something be done with the standard document itself to move beyond aspects that have long been obsolescent but which yet need to be taken into account in future directions?"
                }
            ]
        },
        {
            "number": 224,
            "user": "brandongc",
            "date": "2021-08-25 17:36:58+00:00",
            "title": "scan clause for `do concurrent reduce`",
            "text": "OpenMP has a scan clause for reductions.\nThere is some nontrivial design space in good concurrent implementations of this primitive:\n\nhttp://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\nhttps://software.intel.com/content/www/us/en/develop/articles/openmp-simd-for-inclusiveexclusive-scans.html",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-08-25 18:03:16+00:00",
                    "text": "Indeed, I have heard from multiple people that we should consider adding it. Kokkos has it too: https://github.com/kokkos/kokkos/wiki/Kokkos::parallel_scan"
                }
            ]
        },
        {
            "number": 223,
            "user": "brandongc",
            "date": "2021-08-25 17:33:46+00:00",
            "title": "additional co array collectives",
            "text": "In particular an inclusive and exclusive scan would be useful for several applications, but I think a case could be made for other collectives such allreduce and alltoall too.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": []
        },
        {
            "number": 222,
            "user": "brandongc",
            "date": "2021-08-25 16:49:47+00:00",
            "title": "`log2` instrinsic",
            "text": "Currently the standard has log and log10 functions, but no log2.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-08-25 16:51:34+00:00",
                    "text": "Good candidate for stdlib."
                }
            ]
        },
        {
            "number": 221,
            "user": "everythingfunctional",
            "date": "2021-08-25 15:22:33+00:00",
            "title": "A shorthand for immutability",
            "text": "There is already a method of specifying immutable local values (i.e. calculate once, reference multiple times), but often results in some inconvenience/verbosity. For example\nassociate(val1 => (some_expr))\n  associate(val2 => val1 + another_expr)\n    associate(val3 => val2 + yet_another_expr)\n      result = val1 + val2 * val3\n    end associate\n  end associate\nend associate\nI have seen it requested in a few places that the end associate be made optional, but I think that deserves a different keyword. I would propose let. Thus\nlet val1 = some_expr\nwould be exactly equivalent to\nassociate(val1 => (some_expr))\n  ! following code\nend associate\nend ! of enclosing scope\nwhich would simplify the example above to\nlet val1 = some_expr\nlet val2 = val1 + another_expr\nlet val3 = val2 + yet_another_expr\nresult = val1 + val2 * val3\nThis has the benefit of making it clear that associate is not being used to alias, and thus any following assignment to the value is prohibited (e.g. the variable is immutable). It also enables automatic types for local variables, albeit with the side-effect (IMO benefit) that they can only be assigned to once.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-08-25 15:24:23+00:00",
                    "text": "In addition to let, we can also consider let mut for a mutable assignment, just like in Rust: https://doc.rust-lang.org/std/keyword.let.html"
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 15:28:56+00:00",
                    "text": "So this proposal I think is equivalent to C++'s auto (#129):\nlet val1 = some_expr\nlet mut val2 = val1 + another_expr\n\nis equivalent to:\nconst auto val1 = some_expr;\nauto val2 = val1 + another_expr;\n\nAnd so all my objections from #129 apply here also. Mainly that the code is actually less readable because it is not clear what type val1 is. The same objection already applies to associate. Rust allows you to optionally specify the type (let thing1: i32 = 100;), I wonder if we could do the same here."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-25 15:45:30+00:00",
                    "text": "Some languages use var for that. I somewhat prefer that to let mut, and then we can allow the optional type-spec for let, but not for var, as that would kind of defeat the point. I.e.\nlet [type-spec ::] val = some_expr\nvar var1 = expr ! var is now \"declared\" with the type of expr, but may also be reassigned to"
                },
                {
                    "user": "klausler",
                    "date": "2021-08-25 15:50:42+00:00",
                    "text": "The syntax that you propose is ambiguous with assignment-stmt in fixed form."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-25 15:59:34+00:00",
                    "text": "I suppose that's true, but as fixed-form is obsolescent (IMO) it would be reasonable for that feature not to be available in fixed form.  Of course there are plenty of other opinions on that front."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-25 16:03:17+00:00",
                    "text": "@everythingfunctional writes Aug. 25, 2021, 11:22 AM EDT:\n\nI have seen it requested in a few places that the end associate be made optional, but I think that deserves a different keyword. I would propose let.\n\nTo make \"end associate be made optional\" means, in my mind, to introduce an ASSOCIATE statement form to complement the ASSOCIATE block construct.\nMy observation remains Fortran has a long history of statement-construct pairs, from IF to WHERE.\nI firmly believe ASSOCIATE statement form will be the better Fortrannesque way to introduce the concept of the original post (which is primarily about verbosity though) into the language.  ASSOCIATE statement form will integrate better into the current standard the semantics to be brought in to satisfy different needs of Fortranners in terms of mutability c.f., what is mentioned upthread with mut.\nI personally will be firmly opposed to introducing something like let."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-25 16:18:57+00:00",
                    "text": "See this and this."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 16:44:22+00:00",
                    "text": "@FortranFan if you wouldn't mind, to keep our conversations focused, in the future can you please post more general comments into issues like #59 (and/or create new ones), and then just provide a quick link here. That way we can separate general discussion about \"vision\" from a technical discussion about a let feature; while at the same time keeping in mind these general issues which are connected to it.\nUpdate: Thank you @FortranFan for opening up the other issues and linking them here!"
                },
                {
                    "user": "rouson",
                    "date": "2021-08-25 23:01:08+00:00",
                    "text": "I suppose that's true, but as fixed-form is obsolescent (IMO) it would be reasonable for that feature not to be available in fixed form.\n\nIt would also be reasonable to delete an obsolescent feature that has had a better alternative  (free form) for nearly the entire lifetime of some of the younger people in this dialogue.  If a generation of Fortran programmers has gone from kindergarten to service on the language standard body in the time since a better alternative entered the language, it has to be time to jettison the obsolescent feature that conflicts with a compelling new proposal.   Compiler developers who must support the obsolescent feature can require a flag to enable the support for the obsolescent feature and let users know that the flag precludes the use of the newer conflicting feature."
                },
                {
                    "user": "rouson",
                    "date": "2021-08-25 23:10:30+00:00",
                    "text": "@FortranFan writes Aug. 25, 2021, 11:22 AM EDT:\nTo make \"end associate be made optional\" means, in my mind, to introduce an ASSOCIATE statement form to complement the ASSOCIATE block construct.\nMy observation remains Fortran has a long history of statement-construct pairs, from IF to WHERE.\n\nI like this idea and agree that it nicely mirrors other features.\n\nI personally will be firmly opposed to introducing something like let.\n\nI agree with everything you wrote except the last sentence.    I like your suggestion of the associate statement better than I like let even though I originally liked let.   Let's keep discussions as open as possible, especially in the early phases of considering a proposal.  At least let's not draw lines in the sand on the very day a proposal is made."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-25 23:37:12+00:00",
                    "text": "To make \"end associate be made optional\" means, in my mind, to introduce an ASSOCIATE statement form to complement the ASSOCIATE block construct.\nMy observation remains Fortran has a long history of statement-construct pairs, from IF to WHERE.\n\nI'm tempted to agree with this, and that it probably would be the more \"Fortranique\" way, but I don't like that it is effectively two separate features masquerading as one: create an alias, and create an immutable variable. I'd prefer if we're adding a new feature to make it clear that they are two separate things by having two different keywords. I could live with an ASSOCIATE statement, but it's not my first choice."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-26 23:40:59+00:00",
                    "text": "I suppose that's true, but as fixed-form is obsolescent (IMO) it would be reasonable for that feature not to be available in fixed form. Of course there are plenty of other opinions on that front.\n\nPlease see #225.  If the obsolescent category were defined with some \"teeth\" in the standard, or an outmoded feature at issue (like fixed-form source here) were placed in a different category as retired, then an ideation phase will not be hindered similarly."
                },
                {
                    "user": "klausler",
                    "date": "2021-08-27 00:28:01+00:00",
                    "text": "You should perhaps consider the option of limiting the scope of the immutable captured expression value to be something other than just \"from here to the end of the BLOCK or executable-part\".  Otherwise, you'll have to come up with semantics for things like\ndo j=1,n\n  let(x=a(j)+b(j))\nend do\n! can x be used here?  does it capture the last value?  what if n==0?\n\nand\nif (flag) then\n  let(x=a+b)\nelse\n  let(x=c+d)\nend if\n! can x be used here?\n\nIf you make the name a construct entity (19.1, 19.4) owned by the enclosing construct, if any, and finesse the scoping a little to isolate THEN parts from ELSE parts (and various cases from each other in SELECT, &c., you get the idea), you would dodge these concerns, which I think you have to worry about with your original statement of the scope having essentially an implied END ASSOCIATE before the end of the enclosing scope."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-27 01:13:30+00:00",
                    "text": "I don't like that it is effectively two separate features masquerading as one: create an alias, and create an immutable variable.\n\nIn order to achieve effective immutability in a local scope, Fortran offers options, 2 of which are rather convenient: a) named constant and b) intent(in), particularly with a contained procedure.  Then there is the ASSOCIATE construct, as stated above.  And ASSOCIATE statement is something that can complement the construct entity and it will be a good addition.  Taken together, all these options would cover such a large percentage of the needs that it should be more than good enough for a perennially resource-constrained language such as Fortran."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-27 11:44:36+00:00",
                    "text": "If you make the name a construct entity (19.1, 19.4) owned by the enclosing construct\n\nExactly the kind of insight I look forward to seeing from this community. I like the idea.\n\nIn order to achieve effective immutability in a local scope, Fortran offers options, 2 of which are rather convenient: a) named constant and b) intent(in), particularly with a contained procedure.\n\nI don't think these are convenient.\na) does not work for values that are not constant expressions\nb) is even more verbose than nested associate blocks, and harder to follow\nIt's not that I don't think an ASSOCIATE statement wouldn't be usable, it's that it communicates two different things to the reader at the same time. One has to parse the rhs to understand whether the variable can be assigned to later or not."
                },
                {
                    "user": "rouson",
                    "date": "2021-08-27 12:01:18+00:00",
                    "text": "To use an old expression we don\u2019t hear often  anymore, Brad just took the\nwords right out of my mouth. For the past ~24 hours, I\u2019ve been thinking of\nexpressing precisely the same sentiment.  I probably would have done so\nalready if my computer hadn\u2019t died yesterday.\n\nI want to be clear that what we are discussing  is a much bigger point than\nmany might realize.  Working with immutable state  is  central to the\nfunctional programming paradigm. As Fortran has evolved to support multiple\nprogramming paradigms, some have gotten a lot more attention and explicit\nsupport than others.  Object-oriented, parallel, and array programming have\nextensive feature sets in Fortran.  Hopefully generic programming will too\nin Fortran 202Y.\n\nFunctional programming support is limited and little-used.   Think about\nhow rare it is to see pure procedures. And before this exchange, how many\npeople even knew that associating with an expression defines immutable\nstate?  Those who work closely with me know that this practice has now\nbecome ubiquitous in my Fortran programming.  I rarely declare local\nvariables anymore and only when I have a specific need such as a loop\nindex, but I also eschew loops in favor of array statements and elemental\nprocedures whenever possible.   I rather like the idea of calling out\nimmutability in a new and more prominent way than hiding it as a special\ncase of a feature that most people probably don\u2019t use often.\n\nDamian\n\u2026\nOn Wed, Aug 25, 2021 at 16:37 Brad Richardson ***@***.***> wrote:\n To make \"end associate be made optional\" means, in my mind, to introduce\n an ASSOCIATE statement form to complement the ASSOCIATE block construct.\n\n My observation remains Fortran has a long history of statement-construct\n pairs, from IF to WHERE.\n\n I'm tempted to agree with this, and that it probably would be the more\n \"Fortranique\" way, but I don't like that it is effectively two separate\n features masquerading as one: create an alias, and create an immutable\n variable. I'd prefer if we're adding a new feature to make it clear that\n they are two separate things by having two different keywords. I could live\n with an ASSOCIATE statement, but it's not my first choice.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#221 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ADEANBG3G7I4P4LSF7KXCWLT6V5DHANCNFSM5CZKUNRA>\n .\n Triage notifications on the go with GitHub Mobile for iOS\n <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n or Android\n <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n ."
                },
                {
                    "user": "certik",
                    "date": "2021-08-27 14:12:31+00:00",
                    "text": "Thank you everybody for the discussion, this is very helpful!\nI think this should be prototyped in a compiler, and let's simply use it and see how it looks and feels."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-27 21:24:03+00:00",
                    "text": "@rouson writes Aug. 27, 2021 8:21 PM EDT:\n\nWorking with immutable state is central to the functional programming paradigm.\n\n@rouson , perhaps you can open up a new issue thread toward better support toward the functional programming paradigm in Fortran?  And perhaps also drive a comprehensive review of the needs and benefits with this paradigm in a set of domains (are they still in scientific and technical computing) with use cases and examples, even if in abstract algorithmic terms and/or with other languages?  And what Fortran offers currently (there is of course PURE and ELEMENTAL, and now SIMPLE).  Then consider what other facilities would bring benefits and how to integrate them all together better in Fortran.\nIt will be really good if attempts are not made instead to one-plus facilities like with let that comes across rather foreign to Fortran especially when you have a broader goal.  One-plussing brings with it the dangers of premature optimization Knuth warned out, in this instance with language design and its coherency of course."
                },
                {
                    "user": "certik",
                    "date": "2021-08-28 03:05:00+00:00",
                    "text": "It will be really good if attempts are not made instead to one-plus facilities like with let that comes across rather foreign to Fortran especially when you have a broader goal. One-plussing brings with it the dangers of premature optimization Knuth warned out, in this instance with language design and its coherency of course.\n\nGood point @FortranFan. I agree that we should have a broader vision for Fortran with regards to functional programming, if we want to go that way, and then ensure that let or whatever other proposal fits well with that vision. I don't have a strong feeling either way."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-28 15:04:46+00:00",
                    "text": "@rouson writes Aug. 27, 2021 8:01 PM EDT:\n\n.. Working with immutable state  is  central to the functional programming paradigm.. Functional programming support is limited and little-used .. I rarely declare local variables anymore ..\n\nFrom what I have seen, the notion of immutability outside the contexts of named constant and INTENT(IN) function parameters (dummy arguments) is highly overrated.  To quote the great Bard, it really is much ado about nothing.  It's one of those theoretical computer science premises that may sound alright on paper but which in our experience falls apart the minute the \"rubber hits the road.\"\nAs to not using local variables and its connection with functional programming, it surely is aspirational when it comes to good coding practices.  But it's up to the library authors to aspire to it.  The question then becomes what tools they require to achieve it in Fortran.  However as I write above, that is a separate and broader discussion and separate from considerations of immutability.\nA simple example I usually give is the Euclidean algorithm to find the greatest common divisor of two positive integers: apart from any outstanding bugs (it only had limited testing) and any aspects of a generic algorithm (any kind integer e.g., 64-bit) and style considerations, the following is a perfectly reasonable function in Fortran:\nmodule euclid_m\ncontains\n   elemental function gcd( m, n )\n   ! Find the greatest common advisor of two positive integers\n      ! Argument list\n      integer, intent(in) :: m, n\n      ! Function result\n      integer :: gcd\n      ! Local variables\n      integer :: lvar, tmp\n      if ( (m <= 0).or.(n <= 0) ) error stop \"m,n must be positive.\"\n      if ( m < n ) then \n         gcd = m ; lvar = n\n      else\n         gcd = n ; lvar = m\n      end if\n      loop_gcd: do\n         if ( lvar == 0 ) exit loop_gcd\n         tmp = gcd\n         gcd = lvar\n         lvar = mod( tmp, lvar )\n      end do loop_gcd\n   end function \nend module\n\nThe above with the simple driver program\n   use euclid_m\n   integer :: a, b\n   a = 46332 ; b = 71162\n   print *, \"a = \", a, \"; b = \", b\n   print *, \"gcd(a,b) = \", gcd(a, b), \"; expected result is 26\" \nend\nwith any current standard-conforming processor should yield:\n\na =  46332 ; b =  71162\ngcd(a,b) =  26 ; expected result is 26\n\nNow, keeping in mind everything around Fortran with its strong legacy of Fortran of nearly 75 years and all the great effort in its standard development with facilities toward better functional programming and the accompanying constraints imply:\n\nit simply will be insensible, not to mention nonconforming, for the dummy arguments to be anything other INTENT(IN),\nthe use of local variables in this prime case of an Euclidean function is well-justified,\nthere is no real use case here for the local tmp variable to be immutable.\n\nThen consider a \"textbook\" case of an equivalent code in Rust that touts its drive for functional programming and which too may be the basis for the let suggestion in the original post\nfn gcd(mut n: u64, mut m: u64) -> u64 {\n    assert!(n !=0 && m != 0);\n    while m != 0 {\n        if m < n {\n            let t = m;\n            m = n;\n            n = t;\n        }\n        m = m % n;\n    }\n    n\n}\nGoing strictly by the number of typed characters above, sure the code in Fortran is more verbose than in Rust.  However the verbosity in Fortran is inherent to its design and it's also beneficial; regardless, it's divorced from any immutability aspects here.  Looking at the Rust code though, there are instead far bigger issues of significant concern:\n\nhaving built a major edifice around immutability with \"patterns\" and considerations of functional programming, it had to bring in exceptions with mut with let as well as function parameters c.f. the function prototype, \"gcd(mut n: u64, mut m: u64).\"  That is arguably a failure in Rust when one creates a rule and has to proceed to immediately pair with an exception.  This is highly objectionable in the context of Fortran and its modern journey starting with Fortran 90.\nWithin the scope of the if construct (\"if m < n\") within the loop, there is hardly much of anything to be gained by having t immutable as with 'let t = m;\"\n\nGoing by this, one can even argue there is hardly much of anything to be \"imported\" into Fortran from Rust such as let.\nThis is why I suggested above to take a broader view of the functional paradigm with fully worked out use cases, even if they are in abstract algorithmic terms or minimal working examples from other languages.  To take some isolated code snippets and start building solutions around them is detrimental, in my opinion.  It's something which has been quite problematic with several feature introductions in recent Fortran standard revisions also and which has led to suboptimal facilities and the approach is better avoided from now on."
                },
                {
                    "user": "certik",
                    "date": "2021-08-28 16:52:26+00:00",
                    "text": "@FortranFan that is where I am coming from also, thanks for writing it up. This is a really good discussion.\nI think let might be similar to const in C++, where my understanding of the culture and experience there, the main advantage is to help programmers, not the compiler. Having the code \"const correct\" allows the compiler to prevent the user to modify things that were not meant to be modified.\n\n\nhaving built a major edifice around immutability with \"patterns\" and considerations of functional programming, it had to bring in exceptions with mut with let as well as function parameters c.f. the function prototype, \"gcd(mut n: u64, mut m: u64).\" That is arguably a failure in Rust when one creates a rule and has to proceed to immediately pair with an exception. This is highly objectionable in the context of Fortran and its modern journey starting with Fortran 90.\n\n\nI think you are onto something here, but I didn't understand your argument. Can you elaborate on this? My understanding is that Rust does not have exceptions: https://doc.rust-lang.org/book/ch09-00-error-handling.html, you have to return the error as a result, and Rust has some syntax that helps making this smooth. The Zig language follows a very similar approach I think."
                },
                {
                    "user": "rouson",
                    "date": "2021-08-28 20:45:55+00:00",
                    "text": "@FortranFan thanks for the example.  I agree that local variables can be indispensable. The original issue description by @everythingfunctional did not mention functional programming so I took us off-course by bringing it up.  Apologies.  I think the original use cases suffice for what was being proposed.  If we can communicate more intention to the reader and to the compiler and thereby clarify code and prevent mistakes (.e.g., mistakenly modifying data), then I think those are good things in their own right, independent of the programming paradigm that inspired them.\nJust in case it's not clear from earlier comments, associate ensures immutability when associating with an expression but allows for partial mutability when associating with a variable or object.  Associating with a variable still leaves the variable's value mutable but not its allocation status, for example.  These subtleties make using associate tricky.  When I first started using it, I didn't realize that associate names do not inherit the allocatable attribute.  I mistakenly expected automatic (re)allocation on assignment and that mistake cost me time in debugging.  The thing I like best about let is that the programmer and the reader won't have to think about such subtleties as the value being mutable but not the allocation status."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-28 21:57:00+00:00",
                    "text": "I didn't understand your argument. Can you elaborate on this? My understanding is that Rust does not have exceptions\n\n@certik, when I mentioned \"exception\" I only meant it as in ordinary English usage as illustrated in this quote! :-)"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-12-08 16:20:52+00:00",
                    "text": "Besides making end associate optional, an alternative would be to allow end associate to pertain to a list of named variables, so that the sample code in the OP could be written\nassociate(val1 => (some_expr))\n  associate(val2 => val1 + another_expr)\n    associate(val3 => val2 + yet_another_expr)\n      result = val1 + val2 * val3\nend associate (val1, val2, val3)\n\nIt would resemble the syntax deallocate(val1, val2, val3). I don't mind a single end associate statement, but having many end associate statements at the end of a program unit is so verbose and tedious that many Fortranners will use good old local variables instead."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-12-17 16:38:12+00:00",
                    "text": "As an alternative to a bunch of end associate statements at the end of a program unit, one could introduce a statement\nend associate_all that terminates all associations previously defined."
                },
                {
                    "user": "Beliavsky",
                    "date": "2022-03-02 20:19:00+00:00",
                    "text": "If end associate is made optional in general, I assume it would still be required if the associate appeared in a loop. Maybe you could make a rule that any associate in a loop created in a loop is automatically ended upon leaving the loop, but that seems tricky."
                },
                {
                    "user": "Meriipu",
                    "date": "2022-03-12 05:12:09+00:00",
                    "text": "Besides making end associate optional, an alternative would be to allow end associate to pertain to a list of named variables, so that the sample code in the OP could be written\nassociate(val1 => (some_expr))\n  associate(val2 => val1 + another_expr)\n    associate(val3 => val2 + yet_another_expr)\n      result = val1 + val2 * val3\nend associate (val1, val2, val3)\n\nIt would resemble the syntax deallocate(val1, val2, val3). I don't mind a single end associate statement, but having many end associate statements at the end of a program unit is so verbose and tedious that many Fortranners will use good old local variables instead.\n\nIf verbosity from repeated statements is the issue why not just:\nassociate (val1 => expr1, val2 => expr2, ...)\nend associate\n\nor (with the alignment/spacing of personal preference):\nassociate (val1 => expr1, &\n           val2 => expr2, &\n           ...)\nend associate\n\ninstead? Assuming there is not some syntax ambiguities to associate I overlook here or there not being anything else I have misunderstood.\nI do not like the asymmetry between the 3 opening statements and the single close, and I really would not consider having many end associates to be \"verbose and tedious\" at all (and rather that it helps readability a bunch).\nnot too fond of short semi-cryptic (possibly inline) declarations like mut -- Fortran is not Rust after all."
                },
                {
                    "user": "Meriipu",
                    "date": "2022-03-12 05:16:50+00:00",
                    "text": "Oh right, I see now that the second associate depends on the value of the first so that combining them would not work too well, sorry.\nI still stand by what I said about asymmetry though."
                }
            ]
        },
        {
            "number": 220,
            "user": "klausler",
            "date": "2021-08-20 18:30:36+00:00",
            "title": "The scope of an implied DO index is wrong in DATA statements and array constructors.",
            "text": "Fortran 2018 in subclause 19.4 (paragraph 5) defines the scope of the index of a data-implied-do or ac-implied-do to be the implied DO loop.  But the scope should only be the \"body\" of the implied DO, and not its bounds expressions.  As things stand, in an example like:\n  integer, parameter :: j = 10\n  real :: a(10) = [(j, j=1, j)]\n\nthe current scoping rule forces the last j to refer to the index variable itself, which can't have a meaningful defined value at that point.\nMost of the Fortran compilers to which I have access fix this problem by interpreting the scope to be only the \"body\", usually with a warning, at least when the name is present in the enclosing scope (and not also an implied DO index, which is disallowed explicitly).\nThe same problem exists for DATA implied DO loops, but not I/O data transfer statement implied DO loops.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": []
        },
        {
            "number": 219,
            "user": "Beliavsky",
            "date": "2021-08-19 14:00:24+00:00",
            "title": "Have size(x) return -1 when x is an unallocated ALLOCATABLE array",
            "text": "To safely determine the size of an allocatable array one must first check that it is allocated, with code such as\nif (allocated(x)) then\n   n = size(x)\nelse\n   n = -1\nend if\n\nI suggest that the size of an unallocated allocatable array be defined as -1, so that the above code could just be replaced by\nn = size(x)\nThis would simplify code using allocatable arrays.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-08-19 15:15:21+00:00",
                    "text": "You could write a small library function with these odd semantics; why should they be in the standard language?"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-08-19 17:21:53+00:00",
                    "text": "@klausler Separate functions would be needed for each built-in data type and for user-defined types and classes. Maybe for ranks, too, but perhaps functions could be written with assumed rank arguments. I think it's better for the size function to return a value signaling an error than to crash."
                },
                {
                    "user": "klausler",
                    "date": "2021-08-19 17:40:27+00:00",
                    "text": "module mySizeModule\n contains\n  pure integer function mySize(x)\n    class(*), dimension(..), intent(in), optional :: x\n    mySize = -1\n    if (present(x)) mySize = size(x)\n  end function\nend module\n\nuse mySizeModule\ninteger, allocatable :: a(:), b(:)\nallocate(a(10))\nprint *, mySize(a), mySize(b)\nend"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-09-01 16:04:46+00:00",
                    "text": "Since one person has objected and no one has supported this idea, and since it has been shown how a generic function can be written to produce the requested behavior, I am closing the issue and withdrawing my proposal."
                }
            ]
        },
        {
            "number": 218,
            "user": "FortranFan",
            "date": "2021-07-30 22:54:00+00:00",
            "title": "Eliminate implicit mapping",
            "text": "Issue #90 proposes to eliminate implicit typing in Fortran.  There is strong resistance to this, there being a major concern that to \"eliminate implicit typing\", if pursued with any seriousness, will require a deletion of the IMPLICIT statement from the language.  There is great worry some existing code would break as a result.\nCan the Fortran community then coalesce to a somewhat simpler proposal, to eliminate implicit mapping instead?\nThe main aspect of such a proposal is to primarily change one sentence in the section on IMPLICIT statement to introduce the following:\n\"If a mapping is not specified for a letter, the default for a program unit or an interface body shall be NULL, and the default for a BLOCK construct, internal subprogram, or module subprogram is the mapping in the host scoping unit\"\nNote the current Fortran standard (document 18-007r1) instead states in section 8.7 IMPLICIT STATEMENT page 114, paragraph 3, lines 32-34, \"If a mapping is not specified for a letter, the default for a program unit or an interface body is default integer if the letter is I, J, ..., or N and default real otherwise, and the default for a BLOCK construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.\"\nThis one sentence in the current standard effectively ends up achieving backward compatibility with code written from the days of FORTRAN I where \"ICARUS was an integer unless specified as REAL\", to paraphrase a long-standing joke with FORTRAN!\nBut now almost all the code written from the days of FORTRAN 77 then has tried to avoid the fate of the legend and not drown while trying to only take flight via the explicit use of the IMPLICIT statement, IMPLICIT NONE overwhelmingly but IMPLICIT INTEGER(I-N), xx(A-H, O-Z) {xx = DOUBLE PRECISION, REAL, REAL*8, etc.].  This proposal intends not to affect in any adverse manner any such existing code that makes explicit use of IMPLICIT statements.\nThe intended benefit of this one change is to set in motion finally a positive change where IMPLICIT NONE becomes the default in any and all program units and in all the interface bodies, gone will be the need to ensure the inclusion of implicit none in a list of explicit interfaces:\ninterface\n   function foo(..) result(..)\n      [import .. ]\n      implicit none !<-- Per current standard, forget this and face peril\n      ..\n   end function\n   function bar(..) result(..)\n      [import .. ]\n      implicit none !<-- Per current standard, forget this and face peril\n      ..\n   end function\n   subroutine foobar(..)\n      [import .. ]\n      implicit none !<-- Per current standard, forget this and face peril\n      ..\n   end subroutine\nend interface\nAlmost every processor tries to offer a compiler option to enforce the gist of this proposal, with fpm and LFortran considering making this even the default.  Why not standardize all such good intent?\nWhat say you all, can you support this for Fortran 202Y?  Please keep in mind even with 202Y, it may be year 2040 by the time this can become practicable.  Is it not time now to start giving this a serious consideration?",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "jacobwilliams",
                    "date": "2021-07-31 15:58:22+00:00",
                    "text": "I don't understand quite how this differs from #90. By \"eliminate implicit typing\" I mean that any variables not explicitly declared (or declared by implicit double precision (a-h), etc. in any context would be a syntax error. Is that not what this is?"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-07-31 19:49:37+00:00",
                    "text": "@jacobwilliams wrote July 31, 2021 11:58 AM EDT:\n\nI don't understand quite how this differs from #90. By \"eliminate implicit typing\" I mean that any variables not explicitly declared (or declared by implicit double precision (a-h), etc. in any context would be a syntax error. Is that not what this is?\n\nThis proposal differs in the sense it tries to be very specific and it strives to state what exactly is meant, and what particular aspect(s) in the Fortran standard will be addressed for improvement.\nSure the original post in this thread does not get into the fully detailed mode but that is intentional; ultimately, such effort will be completed by the Fortran standards committee no matter what.\nNonetheless the words in this original post here are an attempt with a \"sharpened pencil\" beyond \"one-liners\", intended both to convey scope and benefits better and to allay concerns."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-09-20 16:56:17+00:00",
                    "text": "Ah, I see what you are saying now (based on your comments here. What you are calling \"implicit mapping\" here, I was calling \"implicit typing\" in #90. I never proposed getting rid of the implicit statements (I don't think that's a good idea and will never happen anyway). So, this is the same thing I was proposing."
                }
            ]
        },
        {
            "number": 217,
            "user": "klausler",
            "date": "2021-07-28 22:28:13+00:00",
            "title": "Clarification needed for required behavior in output edge case",
            "text": "character(11) :: buffer(3)\ncharacter(10) :: quotes = '\"\"\"\"\"\"\"\"\"\"'\nwrite(buffer,*,delim=\"QUOTE\") quotes\nprint 1, buffer\n1 format('>',a10,'<')\nend\n\nA Fortran implementation is required to emit two adjacent (\"on the external medium\") instances of the delimiter character whenever there is one in effect and it appears in a character value in list-directed and NAMELIST output.  The two instances of the delimiter are not allowed to have a record boundary between them, perhaps because delimited character output should be suitable for later use as list-directed input, which forbids a record separator between the repeated delimiters.\nIt is impossible to satisfy this requirement when the first instance of the delimiter character falls at the end of a fixed-length record, including the important case of internal output to a character array.  It is not clear what the best behavior should be when this actually happens, and existing Fortran implementations differ in their executions of the sample program above.  Two crash due to fixed output record overflow, one fails to duplicate the delimiter in any case, and two cross the record boundary (one with odd extra spaces inserted later).\nI suspect that the onus may be on the program(mer) to avoid getting into this situation at the execution of a conforming program, but no existing implementation responds with a useful run-time error that might explain the infraction.",
            "is_open": true,
            "labels": [],
            "comments": []
        },
        {
            "number": 216,
            "user": "Jellby",
            "date": "2021-07-15 07:46:19+00:00",
            "title": "Specify module entities that are accessible by default (not necessarily all public)",
            "text": "Module variables and procedures can be private or public. As far as I understand, private entities simply cannot be accessed from the outside at all (by other program units useing the module), while all public entities are immediately accessible by anyone who uses the module without (only).\nFor convenience, and to help structure the entities in a module, it would be useful to have the possibility of specifying entities that can be accessed, but which must be explicitly specified with only. For example:\nmodule foo\n  integer, parameter, private :: fortytwo\n  integer, public :: const = fortytwo, version = 3\n  default :: const ! suggested syntax\nend module foo\n\nWith this, use foo would get access to const only, while use foo, only: const, version would get access to both variables.\nIf an empty default list is specified (maybe with default none), it would enforce the use of only in any use attempt for the module.",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-07-15 11:39:03+00:00",
                    "text": "Is this to provide some kind of a \"public facing API\"? I usually create a new module just for that and expose the public API. If the user wants to access the \"private API\", they have load the other modules directly."
                }
            ]
        },
        {
            "number": 215,
            "user": "jme52",
            "date": "2021-07-14 12:01:43+00:00",
            "title": "Add INTRINSIC module nature to the index.",
            "text": "This is a proposal of a minor edition to the index, which I am aware is nonnormative material (but very useful).\nAll references are to N2184, although the same issue exists in the current standard.\nINTRINSIC is an attribute, a statement, and a module-nature (see R1410).\nAt the moment, both the INTRINSIC attribute and the INTRINSIC statement have entries in the index, but the INTRINSIC module-nature does not appear in the index at all.\nThe only other module-nature allowed, \"NON_INTRINSIC\", has an entry in the index, pointing to the page that contains R1410.  The same is true for \"module-nature (R1410)\".\nI think that, for consistency and completeness, there should be an \"INTRINSIC module nature\" entry in the index, pointing to R1410 (with the page number in boldface).",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2021-09-03 18:45:43+00:00",
                    "text": "To close this out - email sent to @jme52  back in July:\nHi Jos\u00e9,\nI had a discussion on this with Malcolm Cohen, the standard's editor. He is not in favor of indexing \"intrinsic module\" as it appears almost 500 places in the standard. He proposed instead that he would index:\nINTRINSIC module nature\nNON_INTRINSIC module nature\nwhich I think would accomplish what you want."
                }
            ]
        },
        {
            "number": 214,
            "user": "FortranFan",
            "date": "2021-07-04 16:18:58+00:00",
            "title": "Add CONSTEXPR procedures in Fortran",
            "text": "\"Constexpr as much as possible\" or in other words, utilize as much compile-time computing as viable is a mantra that's increasingly becoming important in many modern codes based on C++17 (and later revisions) toward scientific and technical computing in industry, especially in process simulations and modeling.\nImproved constexpr in C++17 is particularly valuable when one needs to construct large named constants arrays for use in simulations based on other constants (e.g., coefficients in engineering correlations, results from prior simulation runs, results from first-principles models to be applied in reduced-order models, etc.).  These are all use cases that are rather similar to some threads that have come up at Fortran-lang.org:\n\nUser defined functions in constant expressions\nThread-safe initialization of shared module data (OpenMP)\n\nAn option can be to introduce a CONSTEXPR attribute to functions in Fortran combined with appropriate semantics and constraints which can allow such a nonintrinsic i.e., user-defined functions to be used in constant expressions.\nSuch an option appears consistent, in my view , with the evolution path of Fortran with PURE/ELEMENTAL procedures in Fortran 95 to SIMPLE procedures in Fortran 202X.\nThe introduction of such a CONSTEXPR procedure in a future Fortran standard, say 202Y, will greatly enhance compile-time computing facilities in Fortran and it holds the promise of great benefit in scientific and technical computing.\nSome further reading here",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-08-02 15:39:21+00:00",
                    "text": "C++'s constexpr is useful for computing values that are needed at compilation time.  Large named constant arrays that must be present before execution begins are not the same use case; they can be computed once at build time and written to an unformatted file, for example, but their contents do not determine types.  I think you should concentrate your use case justification for a Fortran constexpr upon the calculation of things that are needed for compilation and are typically implemented today via preprocessor macros or via INCLUDE of precalculated values."
                },
                {
                    "user": "certik",
                    "date": "2021-08-03 12:59:09+00:00",
                    "text": "Another approach worth investigating is Zig's comptime feature:\n\nhttps://ziglang.org/documentation/master/#comptime\nhttps://kristoff.it/blog/what-is-zig-comptime/"
                }
            ]
        },
        {
            "number": 213,
            "user": "certik",
            "date": "2021-06-26 21:08:26+00:00",
            "title": "Initial draft of conditional expression intrinsic paper",
            "text": "The paper explains the motivation.\nThe other two referenced papers are:\n\nhttps://j3-fortran.org/doc/year/21/21-157.txt\nhttps://j3-fortran.org/doc/year/21/21-159.txt\n\n@klausler, @milancurcic, would you have time to please review this and help me polish it? I would like to submit this for Monday's vote also.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-06-26 21:24:05+00:00",
                    "text": "I believe this idea (not a specific proposal though) was discussed by the committee and the following feedback is summarized in:\n\n#183 (comment)\n#183 (comment)\n\nHalf the arguments are with issues that come up with extending merge, so we already avoid them by introducing a new intrinsic. The other half of the arguments we should address.\nThe first counter argument is harder chaining, but I think you just put the extra parenthesis at the end. Not too bad, it still seams more readable overall than alternatives.\nThe stronger counter argument is that this does not behave like a function, the ifthen is effectively a new syntax. At that point we might as well introduce new syntax. How to address this? The best argument I can come up is optional arguments, which can get passed through to another function with an optional argument and they are not evaluated ahead of time, as it would not work if the argument is not present. In a similar sense, the arguments of ifthen can be such \"optional style\" arguments that are not evaluated at the call site, but only (optionally) inside the function (similar to how present(x) works). So the concept is not completely new to Fortran. Is there a better way to address this argument?"
                },
                {
                    "user": "zjibben",
                    "date": "2021-06-27 01:07:59+00:00",
                    "text": "One other not-a-function aspect is that a conditional expression can return an actual variable, not just the value. So it can be used in intent(out) contexts like allocate(x, stat=ifthen(logical, stat1, stat2)). I don't imagine there's a precedent for that kind of behavior for a function. Still, the point stands that there's a precedent for function-looking things not really behaving like functions.\nBut your paper looks good and should invite discussion."
                },
                {
                    "user": "certik",
                    "date": "2021-06-27 04:11:46+00:00",
                    "text": "* In this approach, `consequent` and `alternative` must be type compatible. This is a restriction relative to the keyword (and other) forms, where you could do:\n  ```\n  res = if cond then 1 else 1.234\n  ```\n\n\nFirst of all, the keyword version would be:\nres = if (cond) then (1) else (1.234) endif\n\nand my understanding is that it would be exactly equivalent to:\nres = ifthen(cond, 1, 1.234)\n\nThe restriction on consequent and alternative would be exactly the same. So either both integers or both reals (depending on the type of res, or perhaps somehow figured out from consequent and alternative, or perhaps it would not be allowed unless the types are exactly the same), and the default Fortran implicit casting rules apply."
                },
                {
                    "user": "certik",
                    "date": "2021-06-27 04:20:10+00:00",
                    "text": "So it can be used in intent(out) contexts like allocate(x, stat=ifthen(logical, stat1, stat2))\n\nIsn't this semantically exactly the same as:\nallocate(x, stat=if (logical) then (stat1) else (stat2) endif)\n\nI would think both could return a variable. But I haven't thought of it like this. I would expect both if ... endif and ifthen to always return a value."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-06-27 04:31:13+00:00",
                    "text": "Yes, actually my second comment and examples are completely irrelevant, the keyword form has the same restriction for types. It wasn't obvious to me that it would have to have it, but it does simplify things."
                },
                {
                    "user": "certik",
                    "date": "2021-06-27 04:53:05+00:00",
                    "text": "I pushed in answers to some common objections. @milancurcic, @zjibben let me know if you have any other feedback, or if I should upload as is."
                },
                {
                    "user": "certik",
                    "date": "2021-06-27 05:03:27+00:00",
                    "text": "Thanks @milancurcic for the quick review. I think @zjibben implicitly approved it, so I am going to go ahead and upload it."
                },
                {
                    "user": "certik",
                    "date": "2021-06-27 05:16:37+00:00",
                    "text": "Ok there it is: https://j3-fortran.org/doc/year/21/21-165.txt"
                },
                {
                    "user": "ashe2",
                    "date": "2021-06-28 23:02:56+00:00",
                    "text": "What if you have this conforming program unit:\nfunction f(cond, a, b)\n  logical :: cond\n  real :: f, a, b\n  f = ifthen(cond, a, b)\nend\n\nWould this feature change the meaning of it? I.e. ifthen would change from an external to an intrinsic?"
                },
                {
                    "user": "klausler",
                    "date": "2021-06-29 15:01:15+00:00",
                    "text": "What if you have this conforming program unit:\nfunction f(cond, a, b)\n  logical :: cond\n  real :: f, a, b\n  f = ifthen(cond, a, b)\nend\n\nWould this feature change the meaning of it? I.e. ifthen would change from an external to an intrinsic?\n\nNot if the program had a declaration of ifthen; a use, interface, external, &c would do.  (But not just a declaration of its result type; if ifthen became an intrinsic, something like complex ifthen would then be completely ignored.  Kind of a bug in the language, IMO.)"
                },
                {
                    "user": "ashe2",
                    "date": "2021-06-29 18:12:02+00:00",
                    "text": "Would this feature change the meaning of it? I.e. ifthen would change from an external to an intrinsic?\n\nNot if the program had a declaration of ifthen; a use, interface, external, &c would do.\n\nAs the example didn't have a declaration of ifthen, the meaning would change, right?\nIs this a backward compatibility problem for any new intrinsic procedure?"
                },
                {
                    "user": "klausler",
                    "date": "2021-06-29 19:26:01+00:00",
                    "text": "Would this feature change the meaning of it? I.e. ifthen would change from an external to an intrinsic?\n\nNot if the program had a declaration of ifthen; a use, interface, external, &c would do.\n\nAs the example didn't have a declaration of ifthen, the meaning would change, right?\nIs this a backward compatibility problem for any new intrinsic procedure?\n\nYes, and yes.  This is always a consideration when standard or extension intrinsic functions are added.  If you use IMPLICIT NONE(EXTERNAL) , you're safe."
                }
            ]
        },
        {
            "number": 212,
            "user": "Euler-37",
            "date": "2021-06-25 07:39:16+00:00",
            "title": "Add complex number Descriptor",
            "text": "add descriptor to dispay format complex data\n(1) format(CF10.4) <-format(\"(\",F10.4,\",\",F10.4,\")\")\n(2) format(CES12.5) <-format(\"(\",ES12.5,\",\",ES12.5,\")\")\n(3) Experimental , add python like format\nformat(ZF10.4) <- format(F10.4,\"+\",F10.4,\"j\")\nformat(ZES12.5) <-format(ES12.5,\"+\",ES12.5,\"j\")",
            "is_open": true,
            "labels": [
                "Clause 13"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-07-01 20:36:53+00:00",
                    "text": "I think both of these could be implemented in stdlib first."
                },
                {
                    "user": "Euler-37",
                    "date": "2021-07-02 01:42:28+00:00",
                    "text": "I think both of these could be implemented in stdlib first.\n\nYes , (feature) disp they prepare to add function disp ,It is a good feature."
                },
                {
                    "user": "klausler",
                    "date": "2021-08-02 15:46:29+00:00",
                    "text": "Examples (1) and (2) are surprising omissions in Fortran; implementing them would be straightforward and valuable.  List-directed and NAMELIST output of COMPLEX already exist in the language in this parenthesized form, with an adjustable comma character too.\nExample (3) is more dubious.  The FORMAT edit descriptor \"Z\" is already taken for another purpose, and emitting a form of complex output that differs from those used in Fortran source code is less compelling."
                }
            ]
        },
        {
            "number": 211,
            "user": "zjibben",
            "date": "2021-06-22 00:20:39+00:00",
            "title": "June J3/WG5 Meeting",
            "text": "@certik and I will use this issue to keep the community updated on the work of the June 2021 J3/WG5 joint virtual meeting.\nThe agenda is here. The documents for this meeting are here.\nMonday 6/21/21\n\nPublic access to J3 documents\nReviewing liaison roles\nIEEE liaison report\nMPI liaison report\nOpenMP liaison report\nFlang liaison report\nFortran-Lang liaison report (will update with correct link)\n\nData:\n\n21-141: Passed, unanimous consent.\n\nEdit:\n\n21-145: Passed, unanimous consent.\n21-143: Passed, unanimous consent.\n\nWednesday 6/23/21\nData:\n\n21-135r1: No action.\n21-136r1: No action.\n\nHPC:\n\n21-142r2: Passed, unanimous consent.\n\nEdit:\n\n21-158: Passed, unanimous consent.\n\nInterp:\n\n21-137: Passed, 9 yes / 6 no / 1 abstain.\n21-138r1: No action.\n\nGenerics:\n\n21-144r2:\n\nstraw votes: y/n/undecided\nALG-1: 21 / 3 / 2\nALG-2: 19 / 1 / 6\nALG-3: 17 / 3 / 6\nALG-4: withdrawn\nALG-5: 21 / 0 / 5\n\n\n\nWednesday 6/30/21\nJoR:\n\n21-161: Passed, unanimous consent\n\nHPC:\n\n21-107r2: Passed, unanimous consent\n\nEdit:\n\n21-166: Passed, unanimous consent\n\nData:\n\n21-157r2: Passed, unanimous consent\n21-162r1: Passed, unanimous consent\n21-168: Passed, unanimous consent\n21-169r1: Passed as amended, 7 for / 6 against / 2 abstaining\n\nInterp:\n\n21-134r2: Passed, unanimous consent. (straw vote 19/0/9 for/against/undecided)\n21-139r1: Passed, 8 for / 5 against / 2 abstaining.\n21-146r1: Passed, unanimous consent.\n21-150: Passed, unanimous consent.\n21-151: Passed as amended, unanimous consent.\n21-167: Passed with alternate edits, unanimous consent.\n\nGenerics:\n\n21-144r4: straw votes...\n\nCONCEPTS-1: 11 / 2 / 14\nCONCEPTS-2: 9 / 4 / 13\nCONCEPTS-3: 12 / 3 / 12\n\n\n\nWG5:\n\n21-155: 15 for / 0 against / 0 abstaining",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-06-22 17:05:21+00:00",
                    "text": "21-143 mentions cshift but neglected to also fix eoshift."
                }
            ]
        },
        {
            "number": 210,
            "user": "Beliavsky",
            "date": "2021-06-01 13:18:59+00:00",
            "title": "Which non-uniform random number generators should be in the standard?",
            "text": "Random normal deviates are commonly needed and are available in many other scientific computing languages, such as Matlab, R, Python/Numpy, Julia, and C++, so I think Fortran should also have a random_normal() subroutine, analogous to random_number().",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-06-01 15:36:20+00:00",
                    "text": "I think this would be a good fit for stdlib, would you mind proposing it there?"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-06-01 16:09:52+00:00",
                    "text": "@certik\nI think people are already working on non-uniform RNG, including normal deviates, in stdlib, for example fortran-lang/stdlib#240 . There are many known statistical distributions to sample from, and I'm not sure that everything that will be implemented in stdlib should be in the standard, but I think normal variates should be."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-06-01 16:45:28+00:00",
                    "text": "According to a post by John D. Cook, the C++ standard includes\nGenerating from non-uniform distributions\nDistributions directly supported\nBernoulli\nBinomial\nExponential\nGamma\nGeometric\nNormal (Gaussian)\nPoisson\nbut not\nCauchy\nChi squared\nStudent t\nSnedecor F\nWeibull\nRayleigh\nDistributions that can be sampled easily, if not very efficiently, given a normal RNG, may not be needed in the standard -- examples are the Student's t and chi-squared distributions."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-06-01 20:56:56+00:00",
                    "text": "Here are links to lists of non-uniform RNG in R, NumPy, SciPy, Matlab statistics toolbox"
                },
                {
                    "user": "peteroupc",
                    "date": "2021-06-05 20:09:03+00:00",
                    "text": "According to a post by John D. Cook, the C++ standard includes\nGenerating from non-uniform distributions\nDistributions directly supported\nBernoulli\nBinomial\nExponential\nGamma\nGeometric\nNormal (Gaussian)\nPoisson\nbut not\nCauchy\nChi squared\nStudent t\nSnedecor F\nWeibull\nRayleigh\n\nThat post refers to the Technical Report 1 extensions of C++, which predated C++11 which introduced <random> and its distributions for the first time in the main standard.  In C++11, of the distributions listed here, only the Rayleigh distribution is not offered there."
                }
            ]
        },
        {
            "number": 209,
            "user": "Beliavsky",
            "date": "2021-05-25 11:56:35+00:00",
            "title": "Subscripting array-valued expressions as if they were arrays",
            "text": "In Julia and some another languages, you can subscript array expressions as if they were arrays. So in Julia\n    (1:3).^4  = [1, 16, 81]\n    ((1:3).^4)[2]  = 16\n\nWould that be hard to implement in Fortran? It would make some code shorter by removing the need to instead\n(1) declare an array\n(2) set the array to an expression\n(3) subscript the array",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2021-05-25 17:29:22+00:00",
                    "text": "Given the standard allows\n   associate ( x => [ 1, 2, 3 ]**4 )\n      print *, x(2) \n   end associate\nend\nthat takes care of about half the \"needs\", you may not get much response."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-10-19 18:31:59+00:00",
                    "text": "Steve Kargl explains some of the issues with subscripting expressions here. I will be closing this issue."
                },
                {
                    "user": "certik",
                    "date": "2021-10-19 22:43:22+00:00",
                    "text": "We should document the associate thing at https://fortran-lang.org/learn/ as a workaround."
                }
            ]
        },
        {
            "number": 208,
            "user": "RobertVanAmerongen",
            "date": "2021-05-24 13:49:04+00:00",
            "title": "length of a name",
            "text": "The Fortran standard has a limit on the length of a name, i.e .the number of characters: 63. Working with Vulkan give some problems as some of the named constants are (much) longer than this limit. The current core version (verson 1.2) have more than 20 of these cases. Some of the extensions also have some of that. Not only too long named constants are seen, also with a few function names. Can the limit be increased ? Maybe 127 ? ( to start with)\nRobert",
            "is_open": true,
            "labels": [
                "Clause 6"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2021-06-06 06:01:04+00:00",
                    "text": "With a concrete use case like this, I think it'd be viable to propose this for F202Y."
                }
            ]
        },
        {
            "number": 207,
            "user": "Beliavsky",
            "date": "2021-05-24 11:49:29+00:00",
            "title": "Allow RESULT to appear in declaration",
            "text": "The declaration of the RESULT variable in a Fortran function looks the declaration of a local variable. I suggest that you be allowed to specify that it is the result in the declaration, so that you could write\npure function variance_vec(xx,xxmean)\n! compute the variance of xx(:)\nreal(kind=dp), intent(in)           :: xx(:)   ! data for which variance computed\nreal(kind=dp), intent(in), optional :: xxmean  ! mean to use in oomputing variance\nreal(kind=dp), result               :: xvar    ! result\n<snip>\nend function variance_vec\n\ninstead of\npure function variance_vec(xx,xxmean) result(xvar)\n! compute the variance of xx(:)\nreal(kind=dp), intent(in)           :: xx(:)   ! data for which variance computed\nreal(kind=dp), intent(in), optional :: xxmean  ! mean to use in oomputing variance\nreal(kind=dp)                       :: xvar    ! result\n<snip>\nend function variance_vec\n\nMaybe you could allow RESULT to appear twice (but consistently) so that the following is allowed:\npure function variance_vec(xx,xxmean) result(xvar)\n! compute the variance of xx(:)\nreal(kind=dp), intent(in)           :: xx(:)   ! data for which variance computed\nreal(kind=dp), intent(in), optional :: xxmean  ! mean to use in oomputing variance\nreal(kind=dp), result               :: xvar    ! result\n<snip>\nend function variance_vec\n\nThe downside of this proposal is that Fortran would have three ways of declaring a function. An alternative is to allow function results to be declared INTENT(OUT), so you could write\npure function variance_vec(xx,xxmean) result(xvar)\n! compute the variance of xx(:)\nreal(kind=dp), intent(in)           :: xx(:)   ! data for which variance computed\nreal(kind=dp), intent(in), optional :: xxmean  ! mean to use in oomputing variance\nreal(kind=dp), intent(out)          :: xvar    ! result\n<snip>\nend function variance_vec\n\nIf people think any of these ideas have merit, I can narrow this proposal to one of them.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-05-24 17:06:02+00:00",
                    "text": "How is this an improvement to the language?"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-05-30 21:53:35+00:00",
                    "text": "No one has expressed support for any of the suggestions, and I am not sure about them, so I am closing this issue."
                }
            ]
        },
        {
            "number": 206,
            "user": "fabrice-ducos",
            "date": "2021-05-20 10:16:51+00:00",
            "title": "Allow short-circuit evaluation of operators on explicit user's demand",
            "text": "The Fortran standard has never mandated short-circuit evaluation of logical operators from the early versions of the language.\nThis sometimes forces application developers to use nested if statements (e.g. when the second test depends on the outcome of the first one) where it can be done more succintly (and in a more readable form) with languages designed with short-circuit evaluation.\nIt is of course not possible to change the default behaviour of the language, and sometimes it is desirable NOT to perform short-circuit evaluation. In some cases, the compiler may perform some clever optimizations by changing the order of evaluation, and there is no doubt that some well established Fortran libraries leverage this feature.\nBut most of the time, for new developments and not backwards compatibility, short circuit evaluation leads to more straightforward and readable statements in my opinion (and eases migration of algorithms from other languages). Of course, one can rely in some cases on compiler's flags to force this behaviour, but that is non portable and bug-prone.\nBesides, many newcomers (and even old-timers!) in Fortran are not aware of this feature and assume erroneously that short-circuit applies in Fortran like in other languages they have learned first. This can lead to very difficult bugs to fix.\nI have been practising Fortran programming professionnally for 20 years now (along with other langages including C++, Java, Python, etc) and I see no reason for not providing a standard construct to force a snippet of code to perform short circuit evaluation at the user's explicit demand (in the spirit of \"implicit none\").\nBest regards",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-05-20 14:24:19+00:00",
                    "text": "Related: #19."
                },
                {
                    "user": "fabrice-ducos",
                    "date": "2021-05-20 14:47:46+00:00",
                    "text": "Thank you for your reply. Indeed, this topic has already been addressed.\nI will therefore close this issue."
                },
                {
                    "user": "certik",
                    "date": "2021-05-20 15:09:00+00:00",
                    "text": "@fabrice-ducos thanks for bringing this up. Go ahead and submit any comments or feedback to #19 then. If you have any other comments or proposals, please do not hesitate to open new issues."
                },
                {
                    "user": "fabrice-ducos",
                    "date": "2021-05-20 15:30:18+00:00",
                    "text": "Thank you dear @certik . Don't hesitate to add a link to my remarks #206 at #19 if you wish to revive the topic.\nFrom the discussion, I understand that a proposal is already on the worklist of the committee.\nEDIT: you already did ;)"
                }
            ]
        },
        {
            "number": 205,
            "user": "Beliavsky",
            "date": "2021-05-13 20:40:31+00:00",
            "title": "Treat unused variable as error?",
            "text": "Should the declaration of a variable or parameter that is never referenced be treated as an error? Compilers would still be able to compile code with unused variables, but codes compiled with a standard conformance option would not be allowed to have unused variables or parameters. Variables and parameter that are public in a module but not used in it would be allowed, but never-referenced private variables and parameters would be flagged.\nThis suggestion is in the spirit of making IMPLICIT NONE the default -- break bad code to encourage modernization. Some compilers already have options to warn about unused variables, and to turn such warnings into errors. The question is whether compilers should be required to have this capability.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-05-13 20:47:16+00:00",
                    "text": "Define \"unused\", please.  Is x unused in 0 * purefunc(x)?  Or MERGE(0,x,.true.)?  Or DO j=1,0; y = x; END DO?"
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-05-13 20:54:09+00:00",
                    "text": "Maybe I should use the term \"never referenced\". If the code would still compile if the variable were never declared and IMPLICIT NONE was in place, the variable can be considered never referenced (unless it is a public module variable)."
                },
                {
                    "user": "nncarlson",
                    "date": "2021-05-13 21:27:31+00:00",
                    "text": "Conceivably for a local variable, but absolutely not in general. Consider a type bound procedure with a dummy argument that is not referenced, but whose interface is fixed because it is defined by a parent class.  Such a rule would require the procedure to do something artificial with the argument just to avoid an error.  A warning is perfectly adequate."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-05-16 20:49:16+00:00",
                    "text": "I was not sure this idea was good when I proposed it, and no one else seems strongly in favor of it, so I am closing this issue."
                },
                {
                    "user": "certik",
                    "date": "2022-04-24 02:51:40+00:00",
                    "text": "Probably not as a language feature, but what Rust does is that it warns you if a variable is unused, and you can prefix the variable with an underscore to silence the warning. So something similar can be implemented in Fortran compilers."
                }
            ]
        },
        {
            "number": 204,
            "user": "acikek",
            "date": "2021-04-29 02:59:18+00:00",
            "title": "Allow argument declarations of the same name as the parent non-recursive function or subroutine",
            "text": "This seems like an oversight. Currently, this is considered a syntax error. Since, in non-recursive functions or subroutines, itself cannot be called, there is no reason to disallow this. Here is an example:\n! Non-recursive\nsubroutine example(example) ! Syntax error\n  implicit none\n  integer :: example\nend subroutine example",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-04-29 17:26:47+00:00",
                    "text": "subroutine example(example)\n  integer :: example\n  call foo(example)\nend subroutine\n\nWhich example gets passed?"
                },
                {
                    "user": "acikek",
                    "date": "2021-04-29 22:08:00+00:00",
                    "text": "Looks like that's an oversight on my part. Nonetheless, the integer variable. If you were going to pass the subroutine as an argument, you wouldn't have one of the arguments for itself be named the same. As far as I'm aware, many languages allow this scope redefinition."
                },
                {
                    "user": "acikek",
                    "date": "2021-04-30 00:16:47+00:00",
                    "text": "I don't like the idea anymore after you brought that to my attention, although I'd like this issue to stay open in case there's any more comments to address."
                }
            ]
        },
        {
            "number": 203,
            "user": "Beliavsky",
            "date": "2021-04-12 22:24:30+00:00",
            "title": "Allow procedure calls to be annotated with INTENTs? ",
            "text": "Some languages, such as Python and Matlab/Octave, let you return multiple entities from a function, for example\nmean, sd = stats(x)\nIn Fortran you can use a subroutine to do this,\ncall stats(x,mean,sd)\nbut it is not clear from the calling code what the inputs and outputs are. I suggest that Fortran be extended to allow procedure calls to be annotated by the INTENTs of the procedure. Then you could write\ncall stats(in: x, out: mean, out: sd)\nto call\nsubroutine stats(x,mean,sd)\nreal, intent(in) :: x(:)\nreal, intent(out) :: mean,sd\n...\nend subroutine stats\n\nYou could only annotate with in: inout: or out: if the corresponding procedure argument had the same declaration. For subroutines with many arguments, I often write a comment saying what the outputs are, but assertions checked by the compiler would be better. Maybe annotating procedure calls could help the compiler better optimize the code, since it would know what variables are not changed by the procedure call.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-04-12 22:31:53+00:00",
                    "text": "Why not use well-named keyword arguments?"
                },
                {
                    "user": "nshaffer",
                    "date": "2021-04-13 00:43:38+00:00",
                    "text": "Why not use well-named keyword arguments?\n\nCalling library code. This would be really great for calling LAPACK for example, where most routines return results by overwriting inputs."
                }
            ]
        },
        {
            "number": 202,
            "user": "rouson",
            "date": "2021-04-06 06:05:07+00:00",
            "title": "A new category of standard features: experimental",
            "text": "Motivation\nForall and do concurrent are commonly assumed to offer the potential for better performance than do loops, but both were ultimately found to have design problems that preclude important optimizations, notably parallelization, in important use cases.  Fortran 2018 declares forall obsolescent but attempts to improve upon do concurrent despite known  standard-conforming use cases that a compiler cannot safely, or even in principle, parallelize.  A proposal was submitted to J3 to address do concurrent parallelization, but the committee did not adopt the proposal, presumably because the proposal changes the semantics of existing, standard-conforming code.\nThe value that the committee places on not breaking existing codes makes a replacement feature attractive.  The problems found in forall and do concurrent suggest anticipating the likelihood that any replacement will need future revisions to ensure the desired aim even if those revisions break existing code.\nProposal\nAnnex B of the Fortran 2018 standard lists the first two categories of features enumerated below.  I propose to add the third:\n\nDeleted features were \"redundant and considered largely unused in Fortran 90 or 2008.\"\nObsolescent features are those which \"were redundant and for which better methods were available in Fortran 90.\"\nExperimental  features could change in a future standard in ways that are incompatible with the current standard.\n\nExperimental features that survive 2 or 3 standards without incompatible changes could be removed from the list of experimental features.\nUse Case\nAn experimental new feature designed to be very similar to do concurrent but with parallelizable semantics could minimize the work of the committee, the compiler developers, and the user community wishing to refactor codes to leverage the new feature.  Most importantly, with users forewarned, the committee could update experimental features in subsequent standards even if the updates break existing code.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-04-06 16:09:30+00:00",
                    "text": "I support this 100%, thank you Damian for opening it. I would go even further and suggest any bigger feature to go into experimental first, such as any feature that does not yet have a prior compiler implementation and hasn't been tested in code by the wider community. The \"do concurrent\" is a prime example. As we experiment with ways to efficiently parallelize on GPUs, there might be more additions (perhaps specifying array memory layout, or specifying where an array should live) that I would not like in the \"Main\", but would be great to have in \"Experimental\", so that we can experiment with it."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-04-06 16:23:09+00:00",
                    "text": "When it comes to DO PARALLEL or any such new facilities, my personal opinion is to lead R&D - thus Experimental - effort(s) to prototype the feature in some open-source compiler platform(s) such as LFortran and/or LLVM, and/or GCC/gfortran and converge on the optimal solution.  And then strive to standardize the features based on results and lessons learned.\nWith all due respect, I do not think a 3rd category in the standard is viable or even advisable."
                },
                {
                    "user": "tskeith",
                    "date": "2021-04-06 16:48:58+00:00",
                    "text": "The Java standard has something similar, preview features: https://openjdk.java.net/jeps/12\n\nA preview feature is a new feature of the Java language, Java Virtual Machine, or Java SE API that is fully specified, fully implemented, and yet impermanent. It is available in a JDK feature release to provoke developer feedback based on real world use; this may lead to it becoming permanent in a future Java SE Platform.\n\nOf course, Java is not precisely comparable to Fortran because all new features are implemented before being standardized."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-06 17:39:04+00:00",
                    "text": "I am in favor of this idea. We beta test everything else in this industry, why not features of the language themselves. As @tskeith pointed out, there is some precedence for this in at least one other standardized language. Rust is another example of a language with this property (see their \"Unstable Features\"), even if it isn't standardized.\nBut I'm not sure this is either sufficient, or maybe even necessary to get what you actually want; for compiler writers to implement new features to be tested out before they get permanently etched into the standard. Compiler writers already have enough trouble keeping up with the new standards. I worry this may give them an excuse to put off implementing these features. On the whole I think it does put us in a better position though, because at least then we don't have to individually convince them to implement features that aren't in the standard."
                },
                {
                    "user": "klausler",
                    "date": "2021-04-06 18:19:48+00:00",
                    "text": "I agree that the \"rank agnostic array addressing\" feature is a candidate for this category; it's a trainwreck, and its purpose could be more easily attained with far simpler language tweaks.  But that's its own discussion.\nHere's a problematic objection that will be raised to quash this idea: language features are usually interdependent, and often in subtle ways.  Adding a \"feature\" to the standard often involves edits to many clauses and new constraints in nonobvious places.  Some features, like coarrays, become pervasive throughout the document.\nSo, suppose one wants to add a feature in this new experimental category.  Where do you describe its interactions with all of the other aspects of the language?  You can't really just package up all of the necessary edits for a nontrivial feature into a \"patch\" that then becomes a subclause, but you really really can't distribute the changes over the rest of the document either.  This gets harder with experimental features that have unavoidable interactions with each other.\nI think this idea will get shot down quickly unless you guys have a good description of how experimental features would appear in an appendix (or whatever) and be able to address all of the interactions with the standard language and other experiments.  It may be that the descriptions of these features would be more useful if they remained outside the document entirely until proven (or not) in implementations.  You probably also want to be able to edit/fix/extend these descriptions at a much faster cadence than the committee process allows, too; more iterations will generate better results."
                },
                {
                    "user": "rouson",
                    "date": "2021-04-07 01:36:16+00:00",
                    "text": "Thanks to all who have provided feedback so far.  My primary concern is that the committee's understandable reluctance to break existing codes and/or delete features leaves us stuck for long periods with a feature that is known to be broken (forall) or known to have significant problems that cannot be addressed without breaking existing codes (do concurrent).\n@everythingfunctional great point. The wide variability in implementation speeds makes me wonder whether the determining factor is something other than what's in the standard.  We have at least one Fortran 2018 compiler while there are several that aren't even 2008-compliant yet.  I don't think it's the standard itself that makes the key difference in implementation speed.\n@klausler I'm imagining that experimental features get integrated into the standard in the same way as any other feature.  The only change to the standard would be listing experimental features in Annex B as a way to signal that the committee will be willing to make changes that are incompatible with previous standards if it becomes clear that the feature has significant problems that need to be addressed."
                }
            ]
        },
        {
            "number": 201,
            "user": "zerothi",
            "date": "2021-03-24 11:56:51+00:00",
            "title": "Kind specification implicit from context",
            "text": "Problem\nCurrently real are by definition floating point values. So when assigning constants to a double precision you'll get conversion losses\nprogram test\n  real(8), parameter :: const = 1.4435435345345\n  real(8), parameter :: const2 = 1./3.\n  real(8), parameter :: const3 = 1./4.\n\n  print *, const\n  print *, const2\n  print *, const3\n\nend program test\nthe output will be:\n   1.4435435533523560     \n  0.33333334326744080     \n  0.25000000000000000 \nto much surprise of some users.\nCurrent way\nUsers are forced to explicitly denote the important constants as proper kinds. I.e. simple integers or reals that are well defined may not be affected. The solution to the above would be:\n real(8), parameter :: const = 1.4435435345345_8\n  real(8), parameter :: const2 = 1./3._8\n  real(8), parameter :: const3 = 1./4.\nnote not all are needed.\nThis alters the output to:\n   1.4435435345345000     \n  0.33333333333333331     \n  0.25000000000000000     \nSuggestion\n\nWhen doing math that is stored in a certain floating or integer kind specification (LHS), it would be natural to bump up every constant written on the RHS to the equivalent kind specification.\nWhen doing any math that gets printed every constant written should be bumped up to the highest kind specification in the expression\n\nOne needs to distinguish the two situations.\nConsider this:\nprogram test\n real(8), parameter :: const = 1./3.\n print *, 1./3. * 4._8\nin both the above cases 1. and 3. should automatically be bumped to the kind=8 specification as noted in the parameter declaration and by use of one kind=8\nAnother benefit is that complicated inline math would be much easier to write without worrying about kind-specifications.\nNote that all of the same considerations of the above should apply to integer and complex data types.\nBreaking code\nI hardly think this would break codes in undesirable ways. In fact, what it would do is ensure correct handling in many codes since the kind specification is not necessary in many cases any more. So results may change, but I would argue that there are no cases where one wants to do less precision math (on purpose) and store in higher precision variables.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "awehrfritz",
                    "date": "2021-03-24 12:46:46+00:00",
                    "text": "This is indeed one of the rather annoying and nasty surprises of Fortran's floating point handling. So, I for one would really appreciate a feature like this.\nI think the most irritating issue with the current behaviour is that\nreal(8), parameter :: const2 = 1./3.\nyields\n  0.33333334326744080\nAt first I would have thought that the value should just be truncated and zero-padded, but I do realise that this would be as wrong as the current value.\nA quite nice summary of these issues can be found here:\nhttps://www.fortran90.org/src/best-practices.html#floating-point-numbers\nhttps://www.fortran90.org/src/gotchas.html#floating-point-numbers-gotcha\nCurrently, the only reliable way I found to deal with this is via compiler flags, especially if one deals with codes that contain bits and pieces from various sources (as is the case with a lot of Fortran codes especially)."
                },
                {
                    "user": "zerothi",
                    "date": "2021-03-24 13:02:01+00:00",
                    "text": "Currently, the only reliable way I found to deal with this is via compiler flags, especially if one deals with codes that contain bits and pieces from various sources (as is the case with a lot of Fortran codes especially).\n\nYes. That could be one existing approach. However, this would only work if your code is using a consistent precision all around. I.e. mixed precision codes would be difficult to handle through compiler flags, or it could have some performance issues at least. Having this built-in the standard would clarify and make a lot of things easier."
                },
                {
                    "user": "certik",
                    "date": "2021-03-24 21:14:31+00:00",
                    "text": "One question is to get this into the standard, where I can see objections about \"backwards incompatibility\". However, this issue I think can be completely fixed by a compiler that would warn or refuse to compile your first example. I just created an issue for this in LFortran:\nhttps://gitlab.com/lfortran/lfortran/-/issues/305\nIn general I would like LFortran to have a mode that is \"pedantic\" and does not allow such code. Similar with \"implicit none\" if you forget to specify it, it will refuse to compile your code. That way it will force you to write correct code (that will correctly work with other compilers today), without needing to change the standard.\nI believe that is the easiest way to get these issues fixed in practice."
                },
                {
                    "user": "zerothi",
                    "date": "2021-03-25 07:42:01+00:00",
                    "text": "One question is to get this into the standard, where I can see objections about \"backwards incompatibility\"....\n\nI sort of had this feeling that perhaps there could be some backwards incompatibility. However, I think that the backwards incompatibility is a \"random\" fluctuation of numbers (as shown in the prior example). You never know which numbers gets appended in double precision. Here the clarity is implicit.\n\nHowever, this issue I think can be completely fixed by a compiler that would warn or refuse to compile your first example. I just created an issue for this in LFortran:\n\nYeah, compiler flags for checking this would also be awesome -fpedantic-kind or something similar.  have just opened up a \"bug\" @ gfortran see here\n\n...\nI believe that is the easiest way to get these issues fixed in practice.\n\nYeah, you are probably right, but my feeling is that nobody does this by intent. And if so they can easily be explicit. I think this would save more code than it breaks, if it actually will break anything. :)"
                },
                {
                    "user": "zerothi",
                    "date": "2021-03-25 10:44:50+00:00",
                    "text": "For gfortran -Wconversion and -Wconversion-extra could be used."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-03-25 12:29:09+00:00",
                    "text": "KIND inference implicitly from context can cause significant problems in terms of backward compatibility.\nThe issue is really is with the KIND of REAL (and INTEGER) literal constants and arguments and results of intrinsic subprograms.\nA proposal such as #78 will be a good approach for Fortran."
                },
                {
                    "user": "zerothi",
                    "date": "2021-03-25 12:34:18+00:00",
                    "text": "KIND inference implicitly from context can cause significant problems in terms of backward compatibility.\n\nCould you give an example where this would cause significant problems? I have tried to think of one that is really a problem, but I can't come up with anything but \"unintended\" assignment as mentioned above."
                },
                {
                    "user": "wclodius2",
                    "date": "2021-04-07 20:40:47+00:00",
                    "text": "Sometimes legacy codes have strict restrictions on backwards compatibility, i.e. results may have to be reproducible to the last bit. That will not be fulfilled if the precision of the expression in the following example changes\nREAL(DP), PARAMETER :: EXAMPLE = 1./3."
                }
            ]
        },
        {
            "number": 200,
            "user": "sigfig",
            "date": "2021-03-20 10:45:17+00:00",
            "title": "improve specification of non-constant array shape declarations and pdt initialization",
            "text": "fortran as specified has some semantic gaps in the interpretation of the restricted scalar expressions used in procedure interfaces, the interpretation of automatic array declarations using the dimension attribute, and the interpretation of parameterized derived type initialization in type declarations. this seems to be a substantial conformance issue, gfortran ifort and cuda fortran all have noticeable differences in how these language features are interpreted. i've found a few cases in gfortran and ifort where fortran 2003 compliant code will cause crashes during compilation. this is especially noticeable when using type parameters, pdts with integer, len parameters are largely unusable in programs where they would otherwise provide a lot of benefit, due to incomplete implementations and lack of testing. recent specification changes are no help here, after reviewing the semantics in fortran 2018, i have no idea how to implement these features myself without ignoring most of the rules.\non the fortran language spec side i believe there's a straightforward remedy for making compliance feasible:\n\nsplit the roles of specification expressions, further constraining the expressions that can be used in \"shape expressions\"\nmerge all the existing rules for non-constant array shapes, coarray shapes, and integer, len type parameters into one section on resolving dynamic and assumed shapes\nintroduce an operational interpretation of dynamic shape expressions into the spec\n\npart 1 only entails removing the already unusable primaries, intrinisics, and inquiries from usage in shape expressions. part 2 is a spec simplification, no semantics are changed, they're just deduplicated and the intended interpretation is made more explicit, without adding any new concepts.\npart 3 is the substantial change, to be useful it requires a non-trivial amount of reinterpretation and the addition of many new rules.\nmy proposal to make this easy in both specification and implementation is to introduce just one new semantic construction that corresponds to an integer constraint interpretation of the scalar expressions used in procedure interfaces. this is opposed to the current imperative expression evaluation interpretation of the same syntax.\nthis addition would require adding a notion of a \"shape invariant\", a few different classes of shape invariants, and resolution rules distinct from expression evaluation.\nthat seems to be a much broader scope of changes than other proposals, but it does seem like a constraint interpretation fits a lot closer to the existing semantics of shape expressions in fortran. as a trivial example, a matmul interface:\nfunction f(x, y, z, l, r) result(o)\n  integer :: x, y, z\n  real, dimension(x, y) :: l\n  real, dimension(y, z) :: r\n  real, dimension(x, z) :: o\nend function f\nthe required shape validation checks could be evaluated from top to bottom, from bottom to top, or in parallel, with no meaningful differences. we don't really have expression reduction available here either, either the interface is satisfiable or it isn't, there are no intermediate states in which a subset of this interface could be meaningfully satisfiable. if we introduced data dependencies or inequalities, we would arrive at an ordering, but it won't necessarily be an ordering over a set of statements, or over expressions. any ordering induced by an interface is an arbitrary lattice over variable relations. these look a lot more like simultaneous constraints than sequential statements.\nthis reinterpretation has a substantial upside with respect to specification effort: pdt initialization constraints can always be transcluded into the constraint set of the interface that declares the type, no extra rules are needed. additionally, the admissable intrinsic functions and requirements on specification functions admit easy constraint propagation. on the implementation side, the consequences of this sort of change unquestionably adds complexity to a compiler. the material benefit for compiler projects is that pdts and statement expressions are no longer a murky area, and users can successfully write a parameterized matrix type without filing bug reports.\nthis presentation is eliding over many caveats you may be able to notice. i've drafted a proposal document that elaborates on the shape invariant representation, static semantics, and implementation strategies, but it's super long so i didn't want to bomb the proposals repo before getting initial feedback. fortran makes this approach mostly easy but it does throw in some quirks, let me know if any of you have better ideas.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "sigfig",
                    "date": "2021-03-21 02:09:30+00:00",
                    "text": "after rereading this post seems a bit more ambiguous compared to my other notes, so to be explicit, this proposal would introduce constraints as a semantic concept only in the language specification, not a programming construct accessible to fortran programmers. constraints are only intended to highlight the complexity class of resolving dynamic array shapes in fortran, and to make it more obvious how to write a conforming compiler. adopting this proposal would only entail reorganizing and rewording the rules related to shape expressions in the spec."
                },
                {
                    "user": "certik",
                    "date": "2021-03-21 12:01:07+00:00",
                    "text": "Thanks @sigfig for the proposal. Do you think a Fortran standard conformance testsuite (#57) would help here? It seems it would help at least identify the bugs in the compiler regarding some feature, such as array bounds checking in a subroutine interface, or the PDT. As well as to \"specify\" in detailed examples what it means to have a certain feature.\nThe other part of your proposal is to reorganize the Fortran standard document to make it easier to write a Fortran compiler."
                },
                {
                    "user": "sigfig",
                    "date": "2021-03-22 00:01:20+00:00",
                    "text": "if i was implementing a new compiler i'd absolutely want a canonical test suite for this set of features. in fortran evaluating these shape expressions constitutes a pretty big chunk of the dynamic semantics regarding memory management, and implementing them requires adding a lot of state tracking inside of a compiler, so good test coverage is really important. i haven't tried to enumerate the cases i'd want supported as unit tests, but this seems a bit difficult. the generality of the expression class used, scoping, and interaction with other rules for derived types produces a pretty sprawling tree of cases to test and provide canonical interpretations for. gfortran has the most publicly available test cases for these features, there's about 50 of them, but their coverage is not even close to guaranteeing any of it works as specified.\nto make conformance really easy i'd go for property-based testing measured against a canonical interpreter. i've had success with this before for typed dsl projects, but i'm not sure if it's appropriate for fortran. to write the canonical interpreter for testing, the rules for shape expressions definitely need to be made more explicit than they are in fortran 2018. the constraint representation i'm proposing here achieves that (it's adapted from a previous dsl project of mine), but there are lots of other options if this proposal isn't ideal."
                },
                {
                    "user": "certik",
                    "date": "2021-03-22 02:18:31+00:00",
                    "text": "Regarding the test suite, I think everybody agrees we need a lot more thorough compiler independent test suite for all Fortran features. That should be further discussed at #57.\nWe can keep discussing the other parts of your proposals here."
                }
            ]
        },
        {
            "number": 199,
            "user": "zjibben",
            "date": "2021-02-23 00:38:26+00:00",
            "title": " February/March 2021 J3 meeting",
            "text": "@certik and I will use this issue to keep the community updated on the work of the J3 Committee at the February/March 2021 (virtual) meeting.\nThe agenda is here. The documents for this meeting are here.\nMonday 2/22/21\n\nIEEE report 21-114\n\nJoR:\n\n21-101: Similar to a paper removed in the last meeting, but with some parts removed. Straw vote: First set of edits: 10, remove feature: 11, undecided: 2.\n\nEdit:\n\n21-106 Passed unanimous consent.\n\nTuesday 2/23/21\nJoR:\n\n21-101: Passed, unanimous consent for alternative #2 edits to remove the feature.\n21-115r1: Straw 19/0/3/2 (a/b/c/undecided). Delayed for final version.\n21-117r1: Withdrawn to add intro material.\n\nData:\n\n21-110: Straw vote for section 2: 17/2/7 (for/against/undecided). Section 3: 11/1/14. Add select case: 21/1/3. Deferred until Monday.\n21-111: Withdrawn, no current action. We expect the feature to be discussed again in the future for 202y.\n\nHPC:\n\n21-103r2: Passed, unanimous consent\n\nInterp:\n\n21-113: Passed, unanimous consent\n\nEdit:\n\n21-108r1: Passed, unanimous consent\n\nMonday 3/1/21\nJoR:\n\n21-115r2: Passed as amended, unanimous consent.\n21-117r2: Passed as amended, 11 for / 1 against / 3 abstention.\n\nData:\n\n21-110r1: Passed, unanimous consent.\n21-120r1: Straw vote on stat argument (23 stat / 2 clamp / 0 undecided). Straw vote on behavior (12 crash / 8 clamp / 5 undecided). More discussion and vote Tuesday.\n\nTuesday 3/2/21\nJoR:\n\n21-122r2: Passed, unanimous consent.\n\nData:\n\n21-121: Passed, unanimous consent.\n21-120r2: Straw vote (10 stat arg / 5 clamp / 2 subroutine / 7 error / 0 undecided). Runoff (13 stat arg / 9 error). Passed as amended with stat argument option, 9 for / 4 against / 1 abstention.\n21-132: Passed as amended, unanimous consent.\n\nHPC:\n\n21-102r1: Passed as amended, unanimous consent.\n21-105r1: Passed, unanimous consent.\n21-119r1: Passed, unanimous consent.\n21-124: Passed, 11 for / 2 against / 1 abstention.\n\nInterp:\n\n21-123: Straw vote (21 recommended / 3 best / 2 alternative / 1 undecided). Passed with \"recommended\" amendment, unanimous consent.\n21-128r1: Straw vote (14 for attribute / 9 against attribute / 3 undecided). Passed, 6 for / 5 against / 3 abstentions.\n\nEdit:\n\n21-126r1: Passed, unanimous consent.\n21-127: Passed, unanimous consent.\n21-129: Passed, unanimous consent.\n\nEmeritus status:\n\n21-130: Passed as amended, unanimous consent.\n21-131: Passed as amended, unanimous consent.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-02-23 01:00:03+00:00",
                    "text": "I also created a Discourse topic for a wider discussion about the meeting (if anyone wants to):\nhttps://fortran-lang.discourse.group/t/february-2021-fortran-standard-committee-meeting/750\nand announced on Twitter: https://twitter.com/OndrejCertik/status/1364014062032412673"
                }
            ]
        },
        {
            "number": 198,
            "user": "klausler",
            "date": "2021-02-11 23:53:42+00:00",
            "title": "An explicit type for a generic intrinsic function should not be allowed",
            "text": "This program conforms to Fortran 2018:\ninteger :: cos\nprint *, cos(3.14159)\nend\n\nand prints -1.00000, or some other amount of zeroes, with every Fortran compiler to which I have access.  The call to cos() returns a REAL no matter what the explicit type declaration may be.  One compiler emits a warning.\nAn explicit type-declaration-stmt for a generic intrinsic function is defined to have \"no effect\" (subclause 8.2, paragraph 3).\nThis behavior is unintuitive at best, useful only for stumping Fortran programmers as a trivia question, and may even perhaps be dangerous -- implementations are free to extend their lists of intrinsic procedures, and a name clash could silently break existing code that uses an implicit interface.\nThis feature should be deleted.  Existing programs with currently ignored type declarations could be trivially brought up to date without ambiguity or loss of compatibility by simply deleting the declarations.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-02-12 01:17:00+00:00",
                    "text": "The standards from FORTRAN '77 through Fortran 2008 all had language in them about how a type-declaration-stmt for a generic intrinsic function would not remove the generic nature of the name; the language about the type-declaration-stmt having \"no effect\" on a generic intrinsic is a recent update in Fortran 2018."
                }
            ]
        },
        {
            "number": 197,
            "user": "rweed",
            "date": "2021-02-10 02:05:09+00:00",
            "title": "Implement true arrays of fortran pointers",
            "text": "I'm writing some C-interop code that interfaces with C code that returns arrays of pointers to structures. Trying to unwind the multiple indirection (pointers to pointer to pointers) and load them into arrays of derived types containing pointers is to mind mind very clunky and forces you to use derived type component access syntax just to get to the pointer. I would like to propose the following:\nBorrowing syntax from co-arrays, let a set of braces (AKA curly brackets) signal an array of Fortran pointers.\nExample\nReal, Pointer :: aptr(:) {10}\nor\nType(Cstruct), Pointer :: astruct {:}\netc.\nExtensions would also be required  to ALLOCATE and C_F_POINTER but I not certain what is the best syntax for those yet so any suggestions would be welcome. I think something like this would be useful in place of trying to use arrays of Type(C_PTR)s (which is legal) instead of actual Fortran pointers. Just thought I would throw this out to see if anyone else thinks this has merit. I'm sure there are a lot of gotcha's I'm not seeing.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": []
        },
        {
            "number": 196,
            "user": "everythingfunctional",
            "date": "2021-02-10 01:39:36+00:00",
            "title": "Enable Polymorphic Outputs",
            "text": "Is there any change that could be made to the language to allow for polymorphic outputs (or outputs with polymorphic components) from pure procedures. As mentioned in #189, there are currently a couple of constraints that disallow this. This significantly conflicts with a functional programming style, as evidenced by a few of my open source libraries; namely erloff, parff, and jsonff. Nothing impure is done anywhere within those libraries, but large swaths of them cannot be marked as pure because of these constraints.\nAs has been explained to me, the primary reason those constraints exist is that at compile time it cannot be guaranteed that a polymorphic entity won't have a dynamic type with an impure final subroutine. It would seem to me that adding a purefinal attribute to a type, restricting a type and any extended types to having pure final subroutines would be a straightforward fix for this.\nDoes anyone else have any ideas? Would there be support for a paper? What are the chances we could get this into 202X, or would it have to wait til 202Y?",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "rouson",
                    "date": "2021-03-30 20:54:06+00:00",
                    "text": "Let's write a paper to demonstrate the use case and then submit the paper when the committee is considering new features for F202Y."
                }
            ]
        },
        {
            "number": 195,
            "user": "milancurcic",
            "date": "2021-02-04 21:14:16+00:00",
            "title": "Revise SPLIT",
            "text": "I apologize for the delay on this. I lost track of how fast the J3 meeting was approaching.\nHopefully, it should be simple enough proposal to merge and upload.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2021-02-09 16:04:24+00:00",
                    "text": "Which other languages or standard libraries have the third form of split?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-09 17:58:40+00:00",
                    "text": "The closest I could find are:\n\nC strtok\nPython str.find\n\nAnd both are different from the 3rd form of split.\nstrtok modifies the string in-place and returns a pointer to the next token.\nstr.find is more akin to the 3rd form of split because it doesn't modify the string and it returns an integer index. Two key differences are that str.find accepts an input argument start that is not modified in-place like pos, and that you can search for a substring rather than a single character from a set of delimiters."
                },
                {
                    "user": "certik",
                    "date": "2021-02-09 18:39:39+00:00",
                    "text": "The arguments I saw at the J3 mailinglists are good arguments for keeping the 3rd. But it worries me that Fortran would be the only language having it, which leaves a strong suspicion in me that it might not be that useful as people might think."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-02-09 18:53:36+00:00",
                    "text": "Well at least C, C++, and Python have it, but the APIs are different.\nI think it would be useful, but it has a misleading name. I think Python got it right. str.find tells you exactly what it is.\nAnd Fortran intrinsics INDEX and SCAN are similar to the 3rd form of string."
                },
                {
                    "user": "klausler",
                    "date": "2021-02-09 19:00:26+00:00",
                    "text": "Can you articulate a compelling reason for why these new capabilities have to be intrinsic in the standard language rather than packaged in a standard library?  Something like \"the interface can't be specified in Fortran\" or \"this can't be implemented efficiently in Fortran\" or \"only a compiler can do this special processing\" would be nice."
                },
                {
                    "user": "certik",
                    "date": "2021-02-10 00:01:33+00:00",
                    "text": "@klausler exactly. I can't articulate it and I would prefer if such functionality was first present in a standard library, such as stdlib, or simply as a separate package first, as Milan has implemented here:\nhttps://github.com/milancurcic/fortran202x_split\nand get some usage of it. That is how we discovered the issue with the 3rd form of split."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-02-10 00:14:59+00:00",
                    "text": "Since many on the mailing list seem to want to keep the third form, an option for a different name might be NEXT_SEPARATOR. I could also be convinced that the first two forms should be named TOKENIZE. But I'm also partly just trying to reserve the name SPLIT so I can write one with the interface that makes sense to me.\ninterface\n  pure function split(string, separators) result(strings)\n    type(varying_string), intent(in) :: string\n    type(varying_string), intent(in) :: separators(:)\n    type(varying_string), allocatable :: strings(:)\n  end function\nend interface"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-12 20:00:36+00:00",
                    "text": "This paper was taken over by @richardbleikamp and discussed at the meeting 223.\nTL;DR:\n\nFirst two forms are tentatively named TOKENIZE.\nThird form will be its own intrinsic and called SPLIT.\nTOKENIZE won't accept coarrays and coindexed objects as arguments.\nTOKENIZE and SPLIT will be simple subroutines.\n\nHere's the paper that passed."
                },
                {
                    "user": "certik",
                    "date": "2021-03-12 21:00:40+00:00",
                    "text": "@milancurcic awesome, thanks for pushing this. Do you want to update your \"reference\" implementation with the few changes?"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-03-12 21:15:08+00:00",
                    "text": "I will, very soon, and still have yet to add tests and work out a kink in the SPLIT (old 3rd form) implementation. Once there, we'll submit a PR to stdlib."
                }
            ]
        },
        {
            "number": 194,
            "user": "certik",
            "date": "2021-01-19 19:23:09+00:00",
            "title": "Develop criteria for inclusion of special functions",
            "text": "Currently Fortran implements special functions in an inconsistent way.\nAs an example, sin, cos, exp are supported for all complex arguments. But the error function is only available for real arguments (complex implementation provided as a library). The Bessel functions are only defined for integer orders (I had to implement my own for half integer orders).\nWe should develop criteria by which to decide what special functions belong into standard Fortran, and which don't.\nThere are several ways to go about it. The three main approaches that come to my mind are listed below, there are probably others (please propose them below).\nOption 1\n\nFortran should have no special functions, but rather those should be delegated to libraries such as stdlib.\n\nAs a consequence, the Bessel functions already in Fortran should be deprecated.\nOption 2\n\nWe decide on classes of special functions to include, and we should include all (complex) variants and all parameters.\n\nAs a consequence, we should add the remaining Bessel functions, and erf for complex arguments.\nOption 3\n\nWe decide on subset of a class of special functions, based for example on what is provided by libm (part of GNU libc).\n\nThat seems to be the current approach.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2021-01-19 19:37:12+00:00",
                    "text": "Option 4\nFortran should support correctly-rounded implementations of the special functions in table 9.1 of IEEE 754-2008, as amended or extended in later revisions.  Other special functions not already in the language should be included only when strong guarantees about rounding can be supported."
                },
                {
                    "user": "certik",
                    "date": "2021-01-19 19:38:14+00:00",
                    "text": "Here are two more ideas:\nOption 5\n\nImplement all special functions that people ask for in stdlib first. This will provide a solid (trusted) reference implementation that is being used by (hopefully) a lot of people. Then the most frequented special functions could be considered for inclusion into Fortran itself. Or perhaps left in stdlib if stdlib becomes popular.\n\nOption 6\n\nAs fpm becomes more popular, ensure good implementations of special functions are available as libraries, implemented correctly and easy to use as dependencies as fpm packages. Later on, we can consider adding them to stdlib or the Fortran standard itself.\n\n\nThe advantages of Option 5 and 6 are that they are low friction, but they provide high value: as an example, I had to implement my own implementation of Bessel functions because the (Fortran) implementation in SciPy was providing incorrect values in some cases."
                }
            ]
        },
        {
            "number": 193,
            "user": "difference-scheme",
            "date": "2021-01-17 18:09:28+00:00",
            "title": "Allow the default constructors of derived-types to initialize private fields",
            "text": "One of the most annoying restrictions in the language is that Fortran's default constructors for derived types do not always allow one to initialize the private fields of these types. That is, if one has a derived type like the following,\ntype :: AClass\n   private\n   class(BClass), allocatable :: b\ncontains\n   procedure :: some_method_of_aclass_that_uses_b\nend type AClass\n\n\nas it happens extremely frequently in object-oriented programming, then the language will typically forbid passing some instance of BClass to the default constructor that generates objects of type AClass, e.g. the following, perfectly reasonable code, would not be allowed\nsubroutine some_other_procedure(b)\n   class(BClass), intent(in) :: b\n      \n   ! local declaration of an object of AClass\n   class(AClass), allocatable :: a\n\n   ! initialization using default constructor of AClass\n   a = AClass(b)\nend subroutine some_other_procedure\n\n\nif some_other_procedure is not a part of the module in which AClass is declared. One has to either\n\nremove the private access specifier from the  AClass derived type, in order to be able to use the default constructor, which is unacceptable in object-oriented programming, since the latter relies critically on implementation hiding, or\nwrite a user-defined constructor (despite the obvious triviality of the above example), with all the hoop-jumping and verbosity that this involves in Fortran, like overloading the name of the derived type, etc.\nput all these declarations into the same module, which is rarely possible in practice.\n\nThe net result presently is that the object-oriented programmer has to write user-defined constructors for all but the very simplest of his classes (namely those that contain no fields at all)!\nAllowing the initialization of private components by Fortran's default constructors, even if these are called from external scoping units, would go a long way in removing some of the drudgery that the language presently imposes on object-oriented programmers.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2021-01-19 03:26:42+00:00",
                    "text": "You will know Fortran is not, and likely never will be, a fully class-based, object-oriented language the way are some other programming languages e.g., Java.  Limitations with adopting OO approaches in Fortran are going to remain because of how the language evolves with ISO IEC standards process, committee consensus where language bloat and resource constraints all around, particularly with compiler implementations, are a matter of major concern.\nUnder the circumstances, some verbosity with custom initialization procedures is what programmers have to author in order to workaround such aspects.  What really are the issues - beyond verbosity - with this such workarounds is the question.  You may find the point - oh, it's way too verbose even for trivial situations - to be insufficient to convince a committee."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-21 20:52:47+00:00",
                    "text": "To answer the question \"what really are the issues - beyond verbosity - with such workarounds\":\nThe language is inconsistent.\nIt provides a single feature (the derived type) to support both the notions of \"structures\", and \"classes\" (as they are called in other languages) in a unified manner. Hence, the programmer can rightly expect that the language's main facility to construct such derived types (the default constructor) will work equally well for both these application cases, i.e. structures and classes.\nWell, it doesn't.\nIt works for structures, but not (in general) for classes (where implementation hiding is of paramount importance). I consider this a design flaw in the language, a \"wart\" as such things have been called in the past. It makes the language inconsistent, and hence nonintuitive to use, especially for newbies.\nGood, consistent design would provide a single default means to construct instances of both cases, consistent with the language's aim of offering only a single feature to support both structures and classes. It is ok if the language wishes to offer more functionality (like, e.g., user-defined constructors) than the bare minimum required by consistency, but the bare minimum (the default constructor) must work!\nSo, my proposal is essentially one of \"wart removal\", as it has been done repeatedly in the past."
                },
                {
                    "user": "klausler",
                    "date": "2021-01-21 21:00:11+00:00",
                    "text": "What specific change are you proposing -- simply ignoring accessibility of components in a structure constructor?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-21 21:13:12+00:00",
                    "text": "@difference-scheme , I understand that most of the time one wants a public constructor whose arguments are simply the components of my type, but if we make that public by default then I don't see how I can prevent users of some module from using and relying on it in cases where I don't want that to be the case."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-21 21:26:49+00:00",
                    "text": "@klausler My aim so far was simply to point out the problem, not necessarily to show a specific way to overcome it.\nI could imagine, that simply ignoring the accessibility of components in a structure constructor might lead to a lot of trouble. This needs to be thought through by someone with much more insight into how Fortran handles access attributes than myself."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-21 21:55:42+00:00",
                    "text": "@everythingfunctional I am not sure I understood your concern.\nWhat does \"that\" refer to in your sentence \"but if we make that public\"? The constructor/underlying derived type itself?\nThe problem I pointed out is one related to access attributes of derived type components, not of derived types themselves!"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-21 22:04:42+00:00",
                    "text": "In Fortran, the derived type name and its default constructor have the same name. However, the default constructor is not made public along with the type if any of its components (without default initializers) are private. If you're suggesting that the default constructor should be made public even if its components are private, that can cause an issue, because I no longer have a way of making the default constructor private if the type is public. There are times where that is exactly what I want to do. I want to have complete control over how users of my type are allowed to construct instances of it, so that I can prevent them from being able to construct an object with inconsistent internal state."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-21 22:25:56+00:00",
                    "text": "@difference-scheme wrote Jan 21, 2021 3:51 PM EST:\n\n.. It works for structures, but not (in general) for classes ..\n\nPer the Fortran standard, there is no such distinction.  Fortran language has intrinsic types and derived types.\nThe issue here is with PRIVATE components for a derived type: programmers have 2 options:\n\nWhen applicable, employ default initialization of derived type components e.g.,\n\ntype :: BClass\n   integer :: n = 0\nend type\n\nWhen default initialization is inapplicable such as with components of allocatable attribute, one may employ a generic interface with the same name as the derived type e.g.,\n\ninterface BClass\n   module procedure Construct_BClass1\n   module procedure Construct_BClass2\n   ..\nend interface\nSo then the matter becomes some programmer finding it too \"verbose\" and/or added work having to code one or more such functions (Construct_BClass1, etc.).\nMy point is if the verbosity and/or the tedium on the designer of the derived type (BClass) to do the above is the issue, this will not make priority.\nHence my question above as to what really are the issues - beyond verbosity - with the facilities in the current language."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-21 23:35:02+00:00",
                    "text": "@everythingfunctional \"However, the default constructor is not made public along with the type if any of its components (without default initializers) are private.\"\nCould you point me to the Section number in the document of the Fortran 2018 standard where this is stated/discussed? Thanks."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-21 23:44:36+00:00",
                    "text": "Sure. In Section 7.5.10 Construction of derived-type values, there are two constraints when taken together imply the way I phrased it.\nC799 (R756) A component-spec shall be provided for a nonallocatable component unless it has default initialization\nC7102 (R756) The type name and all components of the type for which a component-spec appears shall be accessible in the scoping unit containing the structure constructor."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-22 00:15:12+00:00",
                    "text": "@everythingfunctional wrote Jan 21, 2021 6:44 PM EST:\n\n.. Section 7.5.10 Construction of derived-type values, there are two constraints when taken together imply the way I phrased it. ..\n\n@everythingfunctional ,\nPlease note the standard isn't prohibitive the way your statement would come across since a reader might overlook the parenthesis.  This is given what those constraints do not cover when it comes to PRIVATE derived type components with ALLOCATABLE attribute in addition to those with default initialization.\nmodule m\n   type :: t\n      private\n      integer, public :: n = 0\n      real :: x = 99.0\n      character(len=:), allocatable :: s\n   end type\ncontains\n   subroutine print_t( a )\n      type(t) , intent(in) :: a\n      print *, \"a%n: \", a%n\n      print *, \"a%x: \", a%x\n      print *, \"Is a%s allocated? \", allocated(a%s)\n   end subroutine \nend module\n   use m\n   type(t) :: foo\n   foo = t( n=42 )\n   call print_t( foo )\nend \nFrom what I can deduce, this example conforms and a couple of processors agree.\n\nC:\\Temp>ifort /standard-semantics /warn:all /stand:f18 c.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.1.2 Build 20201208_000000\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.26.28806.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:c.exe\n-subsystem:console\nc.obj\nC:\\Temp>c.exe\na%n:  42\na%x:  99.00000\nIs a%s allocated?  F\nC:\\Temp>gfortran -Wall -std=f2018 c.f90 -o gcc-c.exe\nC:\\Temp>gcc-c.exe\na%n:           42\na%x:    99.0000000\nIs a%s allocated?  F\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-22 00:23:29+00:00",
                    "text": "As I commented upthread, an author of a derived type can implement one or more functions to add to the generic interface in a manner that does satisfy the rules toward generic resolution in the standard.  The consumer can then \"construct\" using the default structure constructor or the one added to the interface depending on the situation.  See below.\nmodule m\n   type :: t\n      private\n      integer, public :: n = 0\n      real :: x = 99.0\n      character(len=:), allocatable :: s\n   end type\n   interface t\n      module procedure construct_t_1\n   end interface \ncontains\n   subroutine print_t( a )\n      type(t) , intent(in) :: a\n      print *, \"a%n: \", a%n\n      print *, \"a%x: \", a%x\n      print *, \"Is a%s allocated? \", allocated(a%s)\n      if ( allocated(a%s) ) then\n         print *, \"a%s: \", a%s\n      end if    \n   end subroutine\n   function construct_t_1( s ) result(new_t)\n      ! Argument list\n      character(len=*), intent(in) :: s\n      ! Function result\n      type(t) :: new_t\n      new_t%s = s\n   end function \nend module\n   use m\n   type(t) :: foo\n   type(t) :: bar\n   foo = t( n=42 )\n   call print_t( foo )\n   bar = t( s=\"Hello\" )\n   call print_t( bar )\nend \n\nC:\\Temp>ifort /standard-semantics /warn:all /stand:f18 c.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.1.2 Build 20201208_000000\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.26.28806.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:c.exe\n-subsystem:console\nc.obj\nC:\\Temp>c.exe\na%n:  42\na%x:  99.00000\nIs a%s allocated?  F\na%n:  0\na%x:  99.00000\nIs a%s allocated?  T\na%s: Hello\nC:\\Temp>gfortran -Wall -std=f2018 c.f90 -o gcc-c.exe\nC:\\Temp>gcc-c.exe\na%n:           42\na%x:    99.0000000\nIs a%s allocated?  F\na%n:            0\na%x:    99.0000000\nIs a%s allocated?  T\na%s: Hello\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-22 00:28:54+00:00",
                    "text": "As worded, the original post and the subsequent comments by OP come across as the case where an author (or author(s)) is unwilling to do the bit of extra work to extend the generic interface as I show in my previous comment.  The hesitation can be due to added verbosity, programmer time, or laxity, or whatever.\nGiven where things are with Fortran though with all the resource constraints, especially with committee time, this will then be a rather low priority.  Hence my suggestion to provide more of a justification with more detailed examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-22 01:20:09+00:00",
                    "text": "@FortranFan , your example does not have any private components without default initializers, hence it does not contradict my statement or the constraints in the standard."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-01-22 01:21:45+00:00",
                    "text": "@FortranFan , oh, I see. You just meant if someone skipped my parenthetical. Yes, my statement is not quite correct without that parenthetical."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-22 19:05:09+00:00",
                    "text": "@everythingfunctional\n\nHowever, the default constructor is not made public along with the type if any of its components (without default initializers) are private.\n\n\nSure. In Section 7.5.10 Construction of derived-type values, there are two constraints when taken together imply the way I phrased it.\nC799 (R756) A component-spec shall be provided for a nonallocatable component unless it has default initialization\nC7102 (R756) The type name and all components of the type for which a component-spec appears shall be accessible in the scoping unit containing the structure constructor.\n\nJust to wrap this up.\nYour first statement, that I quoted above, is wrong. In particular, it does not follow in any way from the two constraints of the Fortran standard cited in your second statement.\nThere is an implicit assumption in your whole argument/concern, namely that the access specifiers of derived type components (appearing in a component-spec) affect in some way the accessibility of the type itself, and accordingly its structure constructor. This is wrong.\nDerived types as a whole have their own access specifiers, that are independent of the access specifiers of their components. The standard is very clear about this. Section \"7.5.2.2. Accessibility\" states (I'm quoting from the draft for ballot of the 2018 standard, so the numbering might not be the final one):\n\"The accessibility of a type name is determined as specified in 8.5.2. [i.e. by its own access specifier].The accessibility of a type name does not affect, and is not affected by, the accessibility of its components and type-bound procedures.\"\nThe comment in brackets in the above quote is mine. So, in summary, Section 7.5.2.2. of the standard invalidates your entire concern."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-22 20:42:08+00:00",
                    "text": "@klausler After some thought, and after I had a look into the standard, here is the specific change that I propose. The aforementioned constraint C7102:\n\nC7102 (R756) The type name and all components of the type for which a component-spec appears shall be accessible in the scoping unit containing the structure constructor.\n\nshould be relaxed/changed to:\n\"The type name shall be accessible in the scoping unit calling the structure constructor.\"\nThis essentially follows your suggestion of ignoring the accessibilty of components during the initialization process.\nI have come to the conclusion that it doesn't make any sense to honour the privacy/accessibility of something that doesn't exist (in memory, because it hasn't been initialized) yet. Notice, that I have also changed the word \"containing\" (which I find ambiguous) into \"calling\" (but this is a minor thing).\nI believe this change should be backwards compatible, as it simply relaxes a former, more stringent, constraint.\nI'd be grateful for any feedback that you might have. Kudos for your original suggestion!"
                },
                {
                    "user": "klausler",
                    "date": "2021-01-22 20:50:08+00:00",
                    "text": "I don't think this is a good idea.  If a component is private, the designer of the derived type has chosen to hide that part of the implementation from the interface."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-22 21:03:17+00:00",
                    "text": "@klausler Yes, but private or not, he (the designer) still needs to initialize that component.\nThe change would simply bring the default structure constructor on an equal footing with a user-defined constructor. The latter is allowed to effect such initialization, then why should we deny the same right to the structure constructor? It is as much associated to the derived type as a user-defined constructor is!"
                },
                {
                    "user": "klausler",
                    "date": "2021-01-22 21:13:11+00:00",
                    "text": "The interface to a user-defined constructor (a generic interface with the same name as the derived type) is under control of the designer of the type, who can hide or expose aspects of the implementation as they see fit.  Allowing private components to appear in a structure constructor would expose parts of the implementation that the type's designer has chosen to hide.\nWhen components are inaccessible, the implementation is free to remove them, change their types, rename them, and extend them without worrying about needing clients to make concomitant changes, so long as the published interface remains unchanged.  Ignoring accessibility restrictions for structure constructors would wreck that guarantee."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-22 21:33:55+00:00",
                    "text": "@klausler I see your point. Thanks for the feedback."
                },
                {
                    "user": "difference-scheme",
                    "date": "2021-01-23 00:40:38+00:00",
                    "text": "From @klausler's last comment, I have to conclude that (due to the very way the language is designed) it is impossible to avoid the aforementioned asymmetry between default/structure constructors and user-defined constructors, without breaking the principle of information hiding in some form. I will therefore close this issue."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-23 01:51:47+00:00",
                    "text": "@difference-scheme wrote Jan. 22, 2021 7:40 PM EST:\n\n.. aforementioned asymmetry between default/structure constructors and user-defined constructors..\n\nThis point is wrong, there is no such asymmetry."
                }
            ]
        },
        {
            "number": 192,
            "user": "urbanjost",
            "date": "2021-01-09 04:35:01+00:00",
            "title": "Allowing an INTEGER array as a LUN on WRITE() statements",
            "text": "I have seen code many times with conditional execution of WRITE statements and loops repeatedly executing a WRITE statement using multiple LUNs to provide logging, verbose modes, and debug modes.  Aside from the possibility of side-effects\nfrom functions called on the WRITE statements (which current methods have an issue with as well) I was wondering what thoughts there might be on allowing the LUN to be an INTEGER array, including of zero length (in which case I would prefer it be a no-op for efficiency). To illustrate the concept\nI put together a little sample program.\nprogram testit\n! Possible use cases, hopefully intuitively obvious would be such as :\nuse,intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit\nlogical :: verbose_on=.true.\ninteger,allocatable :: luns(:)\ninteger :: log\n   ! assuming verbose_on and luns() are set in a module or global area and there are many WRITE\n   ! statements thoughout the program\n   if(verbose_on)then\n      luns=[stdout]\n   else\n      luns=[integer ::]\n   endif\n   write(luns,*)'verbose or debug message (one of many throughout the program)'\n\n   ! when you want to duplicate output in multiple files\n   open(newunit=log,file='record.log')\n   luns=[log,stdout]\n   write(luns,*)'message'\n\nend program testit",
            "is_open": true,
            "labels": [
                "Clause 12"
            ],
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2021-01-10 02:38:26+00:00",
                    "text": "As a working example of the basic concept, here is procedure called WRT() that simulates a basic list-directed write statement\nthat can take up to ten intrinsic scalar variables and an array as a LUN for anyone interested in experimenting with the concept.\nmodule M_wrt\nuse, intrinsic :: iso_fortran_env, only : stderr=>error_unit\nprivate\npublic :: wrt\ncontains\nfunction str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, nospace)\nimplicit none\nclass(*),intent(in),optional  :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9\nlogical,intent(in),optional   :: nospace\ncharacter(len=:), allocatable :: str\ncharacter(len=4096)           :: line\ninteger                       :: istart, increment\n   if(present(nospace))then\n      increment=merge(1,2,nospace)\n   else\n      increment=2\n   endif\n   istart=1\n   line=''\n   if(present(g0))call print_g(g0)\n   if(present(g1))call print_g(g1)\n   if(present(g2))call print_g(g2)\n   if(present(g3))call print_g(g3)\n   if(present(g4))call print_g(g4)\n   if(present(g5))call print_g(g5)\n   if(present(g6))call print_g(g6)\n   if(present(g7))call print_g(g7)\n   if(present(g8))call print_g(g8)\n   if(present(g9))call print_g(g9)\n   str=trim(line)\ncontains\nsubroutine print_g(g)\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128\nclass(*),intent(in) :: g\n   select type(g)\n      type is (integer(kind=int8));     write(line(istart:),'(i0)') g\n      type is (integer(kind=int16));    write(line(istart:),'(i0)') g\n      type is (integer(kind=int32));    write(line(istart:),'(i0)') g\n      type is (integer(kind=int64));    write(line(istart:),'(i0)') g\n      type is (real(kind=real32));      write(line(istart:),'(1pg0)') g\n      type is (real(kind=real64));      write(line(istart:),'(1pg0)') g\n      type is (real(kind=real128));     write(line(istart:),'(1pg0)') g  !*! NOTE: nvfortran does not support this type\n      type is (logical);                write(line(istart:),'(l1)') g\n      type is (character(len=*));       write(line(istart:),'(a)') trim(g)\n      type is (complex);                write(line(istart:),'(\"(\",1pg0,\",\",1pg0,\")\")') g\n   end select\n   istart=len_trim(line)+increment\nend subroutine print_g\nend function str\nsubroutine wrt(luns,g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,iostat)\nimplicit none\ninteger,intent(in)           :: luns(:)\nclass(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9\ninteger,intent(out),optional :: iostat\ninteger                      :: i\ncharacter(len=256)           :: msg\n   do i=1,size(luns)\n      write(luns(i),'(a)',iostat=iostat,iomsg=msg)str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9)\n      if(iostat.ne.0)then\n         write(stderr,'(*(g0))')'<ERROR>*write*:',trim(msg)\n      endif\n   enddo\nend subroutine wrt\nend module M_wrt\nA simple use of the WRT() procedure demonstrates it can take arbitrary scalars and write to no files\nor multiple files depending on the size and contents of the LUN array.\nprogram demo_wrt\nuse, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit\nuse M_wrt, only: wrt\nimplicit none\ninteger,allocatable :: luns(:)\ninteger :: iostat=0\n   luns=[integer ::] ! a null list allows for turning off verbose or debug mode output \n   call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)\n   write(*,*)'IOSTAT=',iostat\n   luns=[stderr,stdout] ! multiple files can be used to create a log file\n   call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)\n   write(*,*)'IOSTAT=',iostat\n   ! unlike direct use of WRITE a function can be used as a list of LUNS if it returns an INTEGER array.\nend program demo_wrt\nThe wrt() procedure should be able to take up to any nine intrinsic scalars of the types listed:\ngfortran demo.f90;./a.out\n IOSTAT=           0\nTWO FILES: 2147483647 PI= 3.1415926535897931\nTWO FILES: 2147483647 PI= 3.1415926535897931\n IOSTAT=           0\n[urbanjs@localhost ~]$ ifort demo.f90;./a.out\n IOSTAT=           0\nTWO FILES: 2147483647 PI= 3.141592653589793\nTWO FILES: 2147483647 PI= 3.141592653589793\n IOSTAT=           0\nNote the default is to place a space between output values. This can be suppressed using \"nospace=.true\"."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-10 17:03:10+00:00",
                    "text": "Should the Fortran committee decide to pursue this - note it'll likely require a lot of effort and convincing and influencing - it will be a long wait (years) before an implementation starts to support the facility.\nIn the meantime, practitioners who are interested in this can consider a workaround with IMPURE ELEMENTAL and try to work within the stipulations of this option:\nmodule m\ncontains\n   impure elemental subroutine write_dat( lun, dat )\n      integer, intent(in)  :: lun\n      class(*), intent(in) :: dat\n      select type ( dat )\n         type is ( integer )\n            write( lun, advance=\"no\", fmt=\"(*(g0,1x))\" ) dat\n         type is ( character(len=*) )\n            write( lun, advance=\"no\", fmt=\"(*(g0,1x))\" ) trim(dat)\n      end select\n   end subroutine\nend module\n   use, intrinsic :: iso_fortran_env, only : stdout => output_unit\n   use m, only : write_dat\n   integer :: luns(2)\n   open( newunit=luns(1), file=\"foo.dat\" )\n   luns(2) = stdout\n   call write_dat( luns, \"Hello World!\" )\n   call write_dat( luns, \"The answer is\" )\n   call write_dat( luns, 42 )\nend\n\nC:\\Temp>gfortran -Wall -std=f2018 io.f90 -o io.exe\nC:\\Temp>io.exe\nHello World! The answer is 42\nC:\\Temp>type foo.dat\nHello World! The answer is 42\nC:\\Temp>"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-01-10 18:15:15+00:00",
                    "text": "It had not occurred to me that calling an elemental function with a zero-sized array conditionally executed the function, but it makes sense on reflection. Worked fine when I added calls with the EMPTY array.\nmodule m \ncontains \n   impure elemental subroutine write_dat( lun, dat ) \n      integer, intent(in)  :: lun \n      class(*), intent(in) :: dat \n      select type ( dat ) \n         type is ( integer ) \n            write( lun, advance=\"no\", fmt=\"(*(g0,1x))\" ) dat \n         type is ( character(len=*) ) \n            write( lun, advance=\"no\", fmt=\"(*(g0,1x))\" ) trim(dat) \n      end select \n   end subroutine \nend module \n   use, intrinsic :: iso_fortran_env, only : stdout => output_unit \n   use m, only : write_dat \n   integer :: luns(2) \n   integer :: empty(0) \n   open( newunit=luns(1), file=\"foo.dat\" ) \n   luns(2) = stdout \n   call write_dat( luns, \"Hello World!\" ) \n   call write_dat( luns, \"The answer is\" ) \n   call write_dat( luns, 42 ) \n   call write_dat( luns, NEW_LINE('A') ) \n    \n   call write_dat( empty, \"AGAIN:Hello World!\" ) \n   call write_dat( empty, \"The answer is\" ) \n   call write_dat( empty, 42 ) \n   call write_dat( luns, NEW_LINE('A') ) \nend"
                }
            ]
        },
        {
            "number": 191,
            "user": "Beliavsky",
            "date": "2021-01-03 20:11:45+00:00",
            "title": "Add format string corresponding to list-directed I/O",
            "text": "I suggest that format string \"(LD)\" be added that corresponds to list-directed READ and WRITE in READ and WRITE statements. Having such a format would allow read (unit,fmt) and write (unit,fmt) to handle both formatted and list-directed output, removing the need for if blocks such as\nif (format_present) then\n   write (unit,fmt) a,b\nelse \n   write (unit,*) a,b\nend if\n\nThe idea was proposed and discussed here, where Ron Shephard explains how it would simplify reading data.  The \"(LD)\" syntax was suggested by Bill Long.",
            "is_open": true,
            "labels": [
                "Clause 13"
            ],
            "comments": []
        },
        {
            "number": 190,
            "user": "FortranFan",
            "date": "2020-12-24 02:40:42+00:00",
            "title": "Assignments in PURE subprograms with a dummy argument of a POINTER attribute",
            "text": "The issue mentioned by @klausler in #189 can do with a separate discussion thread on its own:\n\nIf you're looking for weirdness with assignments in pure subprograms, try this one: it's not valid to store through a pointer dummy argument to a pure subprogram, even when the pointer has been allocated in the subprogram.\n\nTwo rather similar external subprograms are subsequently provided, one identified as \"subroutine bad\" and the other, \"subroutine good\".\nHas there been a formal interp response by the Fortran committee on this, or a discussion at the J3/WG5 mailing list?",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-12-24 16:47:40+00:00",
                    "text": "@FortranFan wrote Dec. 23, 2020 9:40 PM EST:\n\n.. Has there been a formal interp response by the Fortran committee on this, or a discussion at the J3/WG5 mailing list?\n\nMy reason for this question is the issue mentioned by @klausler , \"it's not valid to store through a pointer dummy argument to a pure subprogram, even when the pointer has been allocated in the subprogram.\" and especially in the context of the 2 provided examples appears inaccurate vis-\u00e0-vis current Fortran standard.\nSomething is amiss, this can do with additional discussion in this thread so as not to distract from the topic in #189."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-24 18:00:54+00:00",
                    "text": "Consider the case of \"bad\" in the 2 examples mentioned in #189 ,\nsubroutine bad(p)\n  real, pointer :: p\n  allocate(p)\n  p = 3.14159\nend subroutine\n@klausler mentioned in the context of f18,\n\nthere is \"weirdness with assignments in pure subprograms\n\"it's not valid to store through a pointer dummy argument to a pure subprogram, even when the pointer has been allocated in the subprogram\"\n\"This pattern was caught by f18 in Whizard sources, and it's a pain, but those are the rules in Fortran 2018. (IMO the rule about pointer dummy arguments should not apply when they have INTENT(OUT).)\"\n\nIt's unclear to me how these points are related to the subroutine bad in those 2 examples.\nConsider below a calling program with that subroutine - note marked as PURE to make it relevant: is there a Fortran processor that in any way supports the point, \"it's not valid to store through a pointer dummy argument to a pure subprogram, even when the pointer has been allocated in the subprogram.\"  I fail to see it with gfortran and Intel Fortran, these 2 compilers process it as I expect per Fortran standard.\npure subroutine bad(p)\n  real, pointer :: p\n  allocate(p)\n  p = 3.14159\nend subroutine\nprogram test\n   interface\n      pure subroutine bad(p)\n        real, pointer :: p\n      end subroutine\n   end interface\n   real, pointer :: x\n   integer :: istat\n   character(len=256) :: imsg\n   call bad( x )\n   if ( associated(x) ) then\n      print *, \"x = \", x, \"; expected is 3.14159\"\n      deallocate(x, stat=istat, errmsg=imsg)\n      if ( istat /= 0 ) then\n         print *, \"deallocation of x failed: \", new_line(\"\"), imsg\n         stop\n      end if\n      x => null()\n   else\n      print *, \"x is unexpectedly disassociated\"\n   end if\nend program\nProcessor outputs:\n\nC:\\Temp>ifort /standard-semantics /warn:all /stand:f18 bad.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.1 Build 20201112_000000\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.26.28806.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:bad.exe\n-subsystem:console\nbad.obj\nC:\\Temp>bad.exe\nx =  3.141590 ; expected is 3.14159\nC:\\Temp>gfortran -Wall -std=f2018 bad.f90 -o gcc-bad.exe\nC:\\Temp>gcc-bad.exe\nx =    3.14159012     ; expected is 3.14159\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-24 18:02:06+00:00",
                    "text": "And re: \"(IMO the rule about pointer dummy arguments should not apply when they have INTENT(OUT).)\"\"\n\nwhat rule is that?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-12-30 15:51:54+00:00",
                    "text": "There is no such rule. Perhaps @klausler is misreading the restrictions related to pure functions. C1594 lists the restrictions on what a pure procedure can do with dummy arguments, and it says \"shall not be used ... (3) as the data-target in a pointer-assignment-stmt,\", but this constraint limits \"a pointer dummy argument of a pure function\" and so does not apply to a pointer dummy of a pure subroutine. I don't spot any more general restrictions on a pointer dummy of a pure subroutine.\nInterp F18/010 relates to pure procedure pointers, but that's a different thing."
                }
            ]
        },
        {
            "number": 189,
            "user": "everythingfunctional",
            "date": "2020-12-21 22:53:14+00:00",
            "title": "Constructing Objects With Polymorphic Components Not Possible in Pure Context?",
            "text": "Given the following constraints from the standard:\n\nC1585 The function result of a pure function shall not be both polymorphic and allocatable, or have a polymorphic allocatable ultimate component.\nC1588 An INTENT (OUT) dummy argument of a pure procedure shall not be polymorphic or have a polymorphic allocatable ultimate component.\n\nit seems it would not be possible to write (let alone call in a pure context) a constructor for an object with a polymorphic component that is pure.\nTo my mind this eliminates an entire class of data structures that one would find useful (and expect to be useable) in a pure context. For example, a simple binary tree of integers might be expected to be implemented like the following.\nmodule tree_m\n\nimplicit none\nprivate\npublic :: tree_t, node, leaf\n\ntype, abstract :: tree_t\ncontains\n  procedure(sum_i), deferred :: sum\nend type\n\nabstract interface\n  pure function sum_i(self) result(sum)\n    class(tree_t), intent(in) :: self\n    integer :: sum\n  end function\nend interface\n\ntype, extends(tree_t) :: node_t\n  private\n  class(tree_t), allocatable :: left, right\ncontains\n  procedure :: sum => node_sum\nend type\n\ntype, extends(tree_t) :: leaf_t\n  private\n  integer :: val\ncontains\n  procedure :: sum => leaf_sum\nend type\n\ncontains\n\npure function node_constructor(left, right) result(node) ! pure not allowed\n  class(tree_t), intent(in) :: left, right\n  type(node_t) :: node\n\n  allocate(node%left, source = left)\n  allocate(node%right, source = right)\nend function\n\npure function leaf_constructor(val) result(leaf)\n  integer, intent(in) :: val\n  type(leaf_t) :: leaf\n\n  leaf%val = val\nend function\n\npure function node_sum(self) result(sum)\n  class(node_t), intent(in) :: self\n  integer :: sum\n\n  sum = self%left%sum() + self%right%sum()\nend function\n\npure function leaf_sum(self) result(sum)\n  class(leaf_t), intent(in) :: self\n  integer :: sum\n\n  sum = self%val\nend function\n\nend module\nand then be able to use it like the following in a pure context.\nclass(tree_t), allocatable :: local_tree\ninteger :: total\n\nallocate(tree, source = node(node(leaf(1), leaf(2)), leaf(3)))\ntotal = tree%sum()\nBut, even though the node constructor\n\ndoes not modify its inputs\ndoes not reference (let alone modify) any other entities\ndoes not perform any IO\nit still cannot be made pure due to the above constraints.\n\nDoes anyone know why (or if) these constraints are necessary? It seems most compilers are not enforcing them.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-12-22 03:57:28+00:00",
                    "text": "@everythingfunctional ,\nPerhaps someone who was present during meetings 207 and 212 can provide you detailed feedback, but I think the following couple of papers can give you a bit of insight into the thought process by J3 committee that led to the tightening up the constraints in Fortran 2018 standard revision compared to Fortran 2003 which was more permissive in this regard:\nhttps://j3-fortran.org/doc/year/17/17-130r1.txt\nhttps://j3-fortran.org/doc/year/15/15-211.txt\nYou will notice the notion of a PURE procedure and the avoidance of side effects, as viewed in the context of Fortran, extends to a polymorphic entity to be not deallocated and to exclude the possibility where an impure finalizer may need to be invoked in such a context.  The two constraints you mention are then natural consequences of such requirements."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-22 15:22:53+00:00",
                    "text": "@FortranFan , thanks for the additional reading.\nMy understanding so far is that, because it's possible that some type that extends from the polymorphic entity might implement an impure finalizer, it's impossible to know whether the use of a polymorphic entity will definitely be pure.\nWould it be worth a proposal for a new annotation for types that states something to the effect of:\n\nThis type (and any types which derive from it) do not have impure finalizers\n\nThis, I think, would allow such types to safely be used as polymorphic entities in a pure context.\nAlso, since function results and intent(out) arguments are by definition unallocated on entry to the procedure, it's possible (likely even) that no deallocation or finalization would actually occur. One would need to explicitly assign to the entity twice, or explicitly deallocate for finalization to happen, which the compiler could in theory detect. However, calling a function with polymorphic result would require the result be deallocated and possibly finalized after the function call, as the result is just a temporary entity.\nThis brings to mind another question. Is there something in the standard that requires a temporary, an assignment and a deallocation for a statement like the following, or would the compiler be allowed to optimize that away?\npolymorphic_variable = polymorphic_function(with, args)\nBut that question probably deserves its own thread."
                },
                {
                    "user": "klausler",
                    "date": "2020-12-22 15:37:55+00:00",
                    "text": "You are correct; the prohibitions are meant to make it impossible for an impure final procedure to be called from a pure procedure.\nThere's a lot of ways in which final procedures are badly designed in Fortran."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-22 15:45:25+00:00",
                    "text": "I had another thought as well. What are the chances the following invokes an impure defined assignment?\npolymorhpic_intent_out = polymorphic_intent_in\nIn which case I would need to add to my above annotation to be\n\nThis type (and any types which derive from it) do not have impure finalizers or impure defined assignment"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-23 03:31:25+00:00",
                    "text": "@everythingfunctional wrote Dec. 22, 2020 10:44 AM EST:\n\n.. What are the chances the following invokes an impure defined assignment? ..\n\nWould you have access to NAG Fortran compiler?  It'll be interesting to try out such an assignment in a test reproducer and see the processor response.  I say this because the standard appears to disallow this but 2 compilers I tried fail to issue any diagnostic."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-23 03:39:02+00:00",
                    "text": "@everythingfunctional wrote in the original post on Dec. 21, 2020 5:53 PM EST:\n\n.. Does anyone know why (or if) these constraints are necessary? It seems most compilers are not enforcing them.\n\nRe: \"It seems most compilers are not enforcing them,\" it's possible I'm wrong about this, but it seems to me in the case of Intel Fortran and gfortran, the compiler implementation of the relevant semantics (and syntax) mostly occurred during the fairly long period between Fortran 2003 and 2018 standard revisions and the processors haven't fully caught up yet to the changes in Fortran 2018 relative to 2003 when it comes to PURE procedures."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-23 05:16:20+00:00",
                    "text": "@everythingfunctional wrote in the original post on Dec. 21, 2020 5:53 PM EST:\n\n.. To my mind this eliminates an entire class of data structures that one would find useful (and expect to be useable) in a pure context. ..\n\nPlease note though it will take a significant effort to illustrate whether the current standard really eliminates such data structures or whether the lack of adequate generics facility in the language forces one to resort to polymorphism as a poorer substitute for parameterization and generalization of data structures (and associated algorithms) resulting in bottlenecks due to the constraints mentioned in the original post.\nNote there will be considerable push back on any further changes to the standard on account of the possibility of alternate solutions albeit specialized approaches - see a modified and simple (not optimized) example using integer data below .  Some (or many) folks may view the possible alternates using standard features as adequate for the language until the facility for generics is established.\nmodule node_m\n! Node \"class\" toward a binary tree data structure\n   type :: node_t\n      private\n      integer :: m_dat = 0  !<== Note type of \"data\" in a node can be parameterized\n      type(node_t), allocatable :: m_left\n      type(node_t), allocatable :: m_right\n   contains\n      procedure, pass(node) :: reduce => reduce_node\n      procedure, pass(node) :: insert => insert_dat\n   end type\n   interface node_t\n      module procedure newnode\n   end interface\ncontains\n   elemental function newnode( dat ) result( node )\n      ! Argument list\n      integer, intent(in) :: dat\n      type(node_t) :: node\n      node%m_dat = dat\n      return\n   end function\n   elemental subroutine insert_dat( node, dat )\n      ! Argument list\n      class(node_t), intent(inout) :: node\n      integer, intent(in) :: dat\n      if ( dat <= node%m_dat ) then\n         if ( .not. allocated(node%m_left) ) then\n            node%m_left = newnode( dat )\n         else\n            call insert_dat( node%m_left, dat )\n         end if\n      else\n         if ( .not. allocated(node%m_right) ) then\n            node%m_right = newnode( dat )\n         else\n            call insert_dat( node%m_right, dat )\n         end if\n      end if\n   end subroutine\n   elemental function reduce_node( node ) result( r )\n      ! Argument list\n      class(node_t), intent(in) :: node\n      integer :: r\n      r = node%m_dat\n      if ( allocated(node%m_left) ) r = r + reduce_node(node%m_left)\n      if ( allocated(node%m_right) ) r = r + reduce_node(node%m_right)\n      return\n   end function\nend module\n\nmodule tree_m\n! Tree \"class\" to encapsulate the nodes in it\n   use node_m, only : node_t\n   type :: tree_t\n      private\n      type(node_t), allocatable :: m_root\n   contains\n      procedure, pass(this) :: insert => insert_node\n      procedure, pass(this) :: reduce => reduce_tree\n   end type\ncontains\n   elemental subroutine insert_node( this, dat )\n      ! Argument list\n      class(tree_t), intent(inout) :: this\n      integer, intent(in) :: dat\n      if (.not. allocated(this%m_root) ) then\n         this%m_root = node_t( dat )\n         return\n      end if\n      call this%m_root%insert( dat )\n   end subroutine\n   elemental function reduce_tree( this ) result( r )\n      ! Argument list\n      class(tree_t), intent(in) :: this\n      integer :: r\n      r = 0\n      if ( allocated(this%m_root) ) r = this%m_root%reduce()\n      return\n   end function\nend module\n\n! Calling program\n   use tree_m, only : tree_t\n   type(tree_t) :: tree\n   integer, allocatable :: dat(:)\n   integer :: i\n   dat = [ 14, 4, 13, 8, 3, 10, 6, 17, 1 ]\n   do i = 1, size(dat)\n      call tree%insert( dat(i) )\n   end do\n   print *, \"reduce(tree): \", tree%reduce(), \"; expected is \", sum(dat)\nend\nUpon execution using Intel Fortran,\n\nC:\\Temp>ifort /standard-semantics /warn:all /stand:f18 p.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.1 Build 20201112_000000\nCopyright (C) 1985-2020 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.26.28806.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:p.exe\n-subsystem:console\np.obj\nC:\\Temp>p.exe\nreduce(tree):  76 ; expected is  76\nC:\\Temp>"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-23 15:14:40+00:00",
                    "text": "@everythingfunctional wrote Dec. 22, 2020 10:44 AM EST:\n\n.. What are the chances the following invokes an impure defined assignment? ..\n\nWould you have access to NAG Fortran compiler? It'll be interesting to try out such an assignment in a test reproducer and see the processor response. I say this because the standard appears to disallow this but 2 compilers I tried fail to issue any diagnostic.\n\nThis was actually how I found out I was already doing this (i.e. violating the standard). Neither gfortran nor Intel complained. However, neither the standard nor NAG mention the reason for the constraint. There are a few other constraints near those that mention finalization, but it's not clear that they are directly related, and there is no mention of defined assignment anywhere.\nMy conclusion is that the semantics of the language (i.e. user defined assignment and finalization procedures) allow the possibility of sneaking impure code into places a naive reading would not expect it to be possible. Thus, even for generics, we will need to take care to close these loopholes to be able to mark procedures pure.\nFor example if you were to replace the integer in your tree with a type parameter, unless the constraints for that type parameter are defined as not allowing impure defined assignment or finalization, you could still slip some impure code in there."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-12-23 17:39:29+00:00",
                    "text": "@everythingfunctional wrote Dec. 23, 2020 10:14 AM EST:\n\n.. My conclusion is that the semantics of the language (i.e. user defined assignment and finalization procedures) allow the possibility of sneaking impure code into places a naive reading would not expect it to be possible. ..\nFor example if you were to replace the integer in your tree with a type parameter, unless the constraints for that type parameter are defined as not allowing impure defined assignment or finalization, you could still slip some impure code in there.\n\nIt seems to me in the context of user-defined data structures and algorithms operating with them, constraint C1595 technically shuts such doors to impurity:\n\"Any procedure referenced in a pure subprogram, including one referenced via a defined operation, defined assignment, defined input/output, or finalization, shall be pure.\"\nThe issue is processor support toward this and other such constraints, they're still lacking.  I just filed several support requests with Intel toward improved support in IFORT compiler."
                },
                {
                    "user": "klausler",
                    "date": "2020-12-23 20:09:50+00:00",
                    "text": "Whether defined assignment occurs for a given assignment-stmt is known at compilation time -- the test is in terms of the declared types of the variable and expression., not their dynamic types -- although the identity of the subroutine that implements the defined assignment can be overridden in the type-bound case.  The defined assignment subroutine must be pure if the defined assignment takes place in a pure context; and any override of a pure subroutine must also be pure.  So there's no hole here that I can see as an implementor.\nIf you're looking for weirdness with assignments in pure subprograms, try this one: it's not valid to store through a pointer dummy argument to a pure subprogram, even when the pointer has been allocated in the subprogram.\nsubroutine bad(p)\n  real, pointer :: p\n  allocate(p)\n  p = 3.14159\nend subroutine\n\nis not conforming, but is legal if rewritten to be\nsubroutine good(p)\n  real, pointer :: p\n  real, pointer :: q\n  allocate(q)\n  q = 3.14159\n  p => q\nend subroutine\n\nThis pattern was caught by f18 in Whizard sources, and it's a pain, but those are the rules in Fortran 2018.  (IMO the rule about pointer dummy arguments should not apply when they have INTENT(OUT).)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-12-23 21:27:59+00:00",
                    "text": "the test is in terms of the declared types of the variable and expression\n\nI see. I was under the impression that it might do run-time look up based on the actual type, but I suppose that might fail if the LHS has not yet been allocated. Thanks for the clarification."
                },
                {
                    "user": "klausler",
                    "date": "2020-12-23 22:12:24+00:00",
                    "text": "the test is in terms of the declared types of the variable and expression\n\nI see. I was under the impression that it might do run-time look up based on the actual type, but I suppose that might fail if the LHS has not yet been allocated. Thanks for the clarification.\n\nWe do a look-up, yes, but only to look for overrides in the case where it's clear that a type-bound assignment must be called and the variable and expression are not both monomorphic.."
                }
            ]
        },
        {
            "number": 188,
            "user": "sblionel",
            "date": "2020-11-09 00:39:55+00:00",
            "title": "Unions",
            "text": "For many years, I have heard complaints from users at the lack of unions in Fortran. DEC added unions as part of its STRUCTURE/RECORD extension in 1985, but J3/WG5 never seriously considered adding unions as far as I know. Some considered unions like EQUIVALENCE, a bad programming practice. In an ideal world, I would agree, but there are just too many places where non-Fortran APIs use unions (Windows API for one) and the lack of a way to represent these in Fortran is considered a defect.\nGiven that a common use of unions is in C-friendly APIs, I want to propose unions in the context of C interoperability. Here is my idea:\n\nSupport the DEC UNION/MAP syntax for interoperable types only\nDisallow types with an \"ultimate component\" of a union from: formatted I/O without DT, default initialization, structure constructors (only those that don't give names for all their components?). Am I missing anything? I thought about intrinsic assignment, but I think this is OK since an interoperable type can't contain a pointer, allocatable or coarray component. Basically, the things that imply a component order would be excluded.\n\nMany compilers already support the DEC syntax, so this would be relatively easy to implement.\nAs a reminder, it would look something like this:\ntype, bind(C) :: union_type\n  union\n    map \n      integer : I\n    end map\n    map\n      real :: R\n    end map\n  end union\nend type union_type\ntype(union_type) :: UR\n\nOne could then reference UR%I or UR%R which would share the same memory location. The DEC syntax didn't allow naming unions or maps - I am not sure there is a benefit in doing so.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Fortran 202y",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-11-09 01:36:35+00:00",
                    "text": "Thanks @sblionel for proposing this. That seems reasonable. Without this feature, what is the (current) way of interfacing a union in some C API?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-11-09 14:28:33+00:00",
                    "text": "The most straightforward way is to use the extension, if your compiler supports it. Otherwise you have to create separate type definitions for the alternate layouts and use TRANSFER to reinterpret the storage - messy.\nThe text about intrinsic assignment (10.2.1.3p14) will need some additional words on how to handle unions."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-11-09 23:08:28+00:00",
                    "text": "Feedback from peers as well as requests by Fortranners on other peer-to-peer sites toward Fortran online do indeed indicate adding the facility toward a union-type in Fortran is a really good idea, some can argue it is long overdue.\nBut all such feedback also indicate a UNION type is a first-class need in Fortran itself, it can be useful in simulations, etc.\nTherefore, the Fortran facility need not be in the context of interoperability with C only.  Rather, the facility in Fortran should have additional characteristics when it comes to interoperability with C.  One can see that with the CHARACTER type.\nFor example, UNION can perhaps be an attribute of a derived type in Fortran with certain restrictions: its components are all either intrinsic and/or other derived types of UNION types, there are no ALLOCATABLE components, nor are there any type-bound procedures allowed nor generic bindings and so forth similar to those with SEQUENCE types (but without any baggage of the SEQUENCE types for sure).  The semantics of a type with a UNION attribute will be such that the STORAGE_SIZE of an object of said type is sufficient to contain the largest of the type components.\nBut that the BIND(C, ..) attribute brings additional semantics into effect toward interoperability with a C companion processor where each component in a union-type needs to be interoperable and the storage aspects then follow those of the companion processor e.g., with respect to any padding considerations.\nRegardless, the DEC Fortran extension that includes MAP sections look not only unnecessary but also not modern for standard Fortran.  It will be preferable if the Fortran standard excluded anything with MAP that is currently in DEC Fortran.\nAlso, it should be possible for a derived type to have a component that of a derived type with a UNION attribute regardless of whether the hosting derived type is a UNION type.\nThus a facility can look like so:\ntype, UNION :: some_union_type  !<-- see the attribute\n   integer :: i\n   real :: r\nend type\n\ntype, UNION, BIND(C) :: some_interoperable_union_type\n   integer(c_int) :: i\n   real(c_float) :: r\nend type\n\ntype, UNION, BIND(C) :: some_other_interoperable_type\n   type(some_interoperable_union_type) :: foo\n   character(kind=c_char,len=1) :: bar(N) !<-- where N is a named constant, or a constant expression, etc.\nend type"
                },
                {
                    "user": "sblionel",
                    "date": "2020-11-10 00:43:47+00:00",
                    "text": "I'm sorry, @FortranFan , but I am having trouble understanding your suggestion. The DEC syntax provides much the same capability as C, allowing unions to be placed inside any type. It is very popular and well-understood. What is the use case of your version?\nI suggested restricting it to interoperable types because that's where the most common use is, and it means you don't have to come up with additional rules for things such as allocatable/pointer/coarray components."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-11-10 11:44:44+00:00",
                    "text": "@sblionel wrote Nov. 9, 2020 7:43 PM EST:\n\nI'm sorry, @FortranFan , but I am having trouble understanding your suggestion. The DEC syntax provides much the same capability as C, allowing unions to be placed inside any type. It is very popular and well-understood. What is the use case of your version?\n..\n\nThe use case(s) I am referring to include all the situations in a pure Fortran context, with no involvement of a companion C processor, where Fortranners have a need for a union type.\nThe scenarios I am referring can include something as simple as\n   type, union :: foo_t\n      double precision :: x\n      character(kind=K, len=N) :: s\n   end type\nwhere such a type is consumed using a processor with support toward DOUBLE PRECISION that conforms to Fortran standard but whose interoperability with a companion C processor is of no relevance to the program at hand.  And the same with the CHARACTER type whose kind K has no relevance to 'C_CHAR' kind and where the program logic can depend on the length 'N' of a scalar component 's'.\nAs I wrote in my earlier post, there is a genuine need for a union type in Fortran which is not restricted in any way by the interoperability considerations with a companion C processor.\nIt's common in simulations (e.g., Physics simulations of particles) to work with \"blobs\" of data where\n\non the computational side of the program, the blob holds pertinent data consisting of Fortran intrinsic types including the floating-point formats that conform to the Fortran standard but not necessarily those of a C processor, and other intrinsic types including INTEGER, CHARACTER, and LOGICAL.  But\non the data management side of the simulation program the blob may be an array of some primitive type supported by the Fortran processor and conformant to the Fortran standard e.g., an array of an arbitrary INTEGER or CHARACTER types that conform to Fortran standard but which have no relevance to a companion C processor,\n\nBut I acknowledge also the importance of a union type in the context of interoperation with a companion C processor, a common scenario being one on Windows OS e.g., where a Fortran program needs to work with user input on a console using Microsoft Windows API ReadConsoleInput.\nThat's why I suggest the thought process and vision toward such a feature in Fortran be broader and that the development of any proposal strives to include both of the above needs in order to serve the best interests of Fortran practitioners."
                },
                {
                    "user": "sblionel",
                    "date": "2020-11-27 22:17:47+00:00",
                    "text": "Given that EQUIVALENCE has been booted from the language, I'm doubtful that replacing it with a full-throated, distinct union type would get a warm reception. Nothing in my proposal precludes doing that later, but I'm focused on solving a particular problem in a way that I think would be acceptable to the committee - especially as many compilers already support it.\nType-casting is already possible in Fortran, albeit a bit clumsily, with C_LOC and C_F_POINTER. It seems to me that the use cases you mention can be handled by the proposal at hand."
                },
                {
                    "user": "RobertVanAmerongen",
                    "date": "2021-05-24 13:58:06+00:00",
                    "text": "With pleasure I read this proposal. I am working with Vulkan and at several places in the specs the union feature is used. Of course, we can circumvent any trouble by using TRANSFER, but I feel this bungly.\nI do not understand what is meant with \"Fortran 202y Unsubmitted\" but I will say: the sooner we have it, the better!\nRobert"
                }
            ]
        },
        {
            "number": 187,
            "user": "certik",
            "date": "2020-10-27 19:11:37+00:00",
            "title": "SPLIT intrinsic",
            "text": "US03 - SPLIT string intrinsic\n\nIncluded in the 202X draft: https://j3-fortran.org/doc/year/20/20-134.txt\nAPI change: https://j3-fortran.org/doc/year/20/20-139.txt (passed)",
            "is_open": true,
            "labels": [
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-10-27 19:16:11+00:00",
                    "text": "This is a great candidate for an stdlib implementation: fortran-lang/stdlib#241"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-28 03:09:24+00:00",
                    "text": "Definition of SPLIT is in 16.9.194 of 20-007."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-01 01:37:50+00:00",
                    "text": "I put an implementation here: https://github.com/milancurcic/fortran202x_split. I will request feedback in the stdlib issue."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-11-19 20:18:12+00:00",
                    "text": "We discussed the split API on a call on Tuesday. You can watch the recording here.\nOn the call we came to an overall tentative agreement that the 3rd form of split may be not appropriate or intuitive to be part of the split functionality. As a reminder, the 3 forms of split, after 20-007 and 20-139 are:\n\nSPLIT (STRING, SET, TOKENS [, SEPARATOR])\nSPLIT (STRING, SET, FIRST, LAST)\nSPLIT (STRING, SET, POS [, BACK])\n\nWhile we found that the first two forms are useful and meaningful for split, we also found that the 3rd form is not appropriate because it doesn't actually do any splitting. Instead, it does \"finding\", which is more akin to the intrinsic index. Bundling the 3rd form of the currently approved split with the other two may thus be confusing to Fortran programmers.\nWe decided to write a proposal against exclude the 3rd form in the split intrinsic for F202X. I have agreed to take a lead on it. I plan to have a PR draft in this repo by early December, so it can be discussed ahead of time both here and on the J3 mailing list and/or forum well ahead of time."
                }
            ]
        },
        {
            "number": 186,
            "user": "14NGiestas",
            "date": "2020-10-26 11:48:15+00:00",
            "title": "Unpacking variables from arrays",
            "text": "I usually unpack variables from arrays when it's meaningful, eg:\nsubroutine cool_stuff(self, coords)\n    integer(INT32) :: coords\n    ...\n    x = coords(1)\n    y = coords(2)\n    z = coords(3)\n    self % coolest = [x**2, y**2, z**2]\nend subroutine\nI would be nice if i could unpack variables from vectors, maybe in the args:\nsubroutine cool_stuff(self, [x, y, z])\n    integer(INT32) :: x, y, z\n    self % coolest = [x**2, y**2, z**2]\nend subroutine\nOr even something like this:\nsubroutine cool_stuff(self, coords)\n    integer(INT32) :: coords(3)\n    integer(INT32) :: x, y, z\n    [x, y, z] = coords\nend subroutine",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 15:12:10+00:00",
                    "text": "This is a subset of a feature in other languages called pattern matching, and is an incredibly convenient and useful feature. I too would like if it could be added."
                },
                {
                    "user": "certik",
                    "date": "2020-10-26 15:47:31+00:00",
                    "text": "This is a feature I have been missing also, and I use it frequently in Python. Perhaps something like this, following the Python approach with tuples:\nsubroutine cool_stuff(self, coords)\n    integer(INT32) :: coords(3)\n    integer(INT32) :: x, y, z\n    (x, y, z) = coords\nend subroutine"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 18:21:14+00:00",
                    "text": "To move the discussion forward a bit, I want to discuss a little bit about how this would probably work in Fortran. First, Fortran is a statically typed, compiled language, so for the simple use case - like deconstructing an array (or maybe deconstructing an object of known type), with a simple assignment statement, you would probably want to ensure at compile time that the pattern match cannot fail. I.e. for the statement [x, y, z] = coords, coords must be declared with size 3, and the same type and kind parameters as x, y, and z.\nNext, one would want to have a branching construct for possible matches. The most natural syntax would be (I think) to reuse the select construct like:\nselect case (coords)\ncase (Point_2D_t(x, y))\n  ! can now do stuff with x and y\ncase (Point_3D_t(x, y, z))\n  ! can now do stuff with x, y and z\ncase default\n  ! coords is still in scope, but we don't necessarily know it's type or components\nend select\nI don't think Fortran's type system is suited to check at compile time whether all possible matches have been accounted for, so I think a default branch would be required. Or, it could be that if one isn't specified, the processor must automatically insert one of the form:\ncase default\n  error stop \"Pattern match not satisfied for <select-expr>\"\nSince Fortran is an imperative language, there's also the possibility of just letting it fall through, and none of the branches are executed. This is the way existing select case and select type blocks work, so it would be consistent. However, if it is required, one could relax the restriction that the assignment statement form be guaranteed to succeed, and instead treat it more like syntactic sugar for the expanded form, where:\n[x, y, z] = coords\nis equivalent to\nselect case (coords)\ncase ([x, y, z])\n   ! all following statements\ncase default ! inserted at end of scope\n  error stop \"Pattern match not satisfied for 'coords'\"\nend select"
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-26 19:57:01+00:00",
                    "text": "At compile time the size is known, so this case is \"easily\" covered. At runtime we could just ensure that rhs has as many elements as lhs variables to unpack.\nThen one could do the following:\nselect case (size(coords))\ncase(1)\n[x] = coords\ncase(2)\n[x, y] = coords\ncase(3)\n[x, y, z] = coords\ndefault ! Extra: a pop-like behaviour\n[x, y, z, coords] = coords ! now the first three were unpacked and the remaining kept in the array (realloc is prob. needed here)\nend select"
                },
                {
                    "user": "certik",
                    "date": "2020-10-26 20:14:29+00:00",
                    "text": "Why cannot the following:\nsubroutine cool_stuff(coords)\ninteger, intent(in) :: coords(:)\ninteger :: x, y, z\n(x, y, z) = coords\n...\nend subroutine\njust be a syntactic sugar for:\nsubroutine cool_stuff(coords)\ninteger, intent(in) :: coords(:)\ninteger :: x, y, z\ninteger :: tmp(3)\ntmp = coords\nx = tmp(1)\ny = tmp(2)\nz = tmp(3)\n...\nend subroutine\nWith exactly the same semantics?\nSo if the size of coords is only known at runtime as in the above example, then tmp = coords would behave according to the current Fortran standard. And if coords is known at compile time, then tmp = coords would again behave according to the current Fortran standard."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-26 20:36:28+00:00",
                    "text": "Indeed. I rather use the square brackets than parenthesis since there's no concept of tuples in Fortran (AFAIK). I believe the tmp variable is not needed with the current Fortran standard, since:\n[x, y, z] = coords can be changed into x = coords(1); y = coords(2); z=coords(3)\nWe could also drop the brackets entirely too:\nx, y, z = coords to x = coords(1); y = coords(2); z=coords(3)\nand let the compiler do the rest."
                },
                {
                    "user": "certik",
                    "date": "2020-10-26 20:49:46+00:00",
                    "text": "@14NGiestas good point. With square brackets and your \"optimization\", this:\nsubroutine cool_stuff(coords)\ninteger, intent(in) :: coords(:)\ninteger :: x, y, z\n[x, y, z] = coords\n...\nend subroutine\nshould be equivalent to:\nsubroutine cool_stuff(coords)\ninteger, intent(in) :: coords(:)\ninteger :: x, y, z\nx = coords(1); y = coords(2); z = coords(3)\n...\nend subroutine"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 21:57:19+00:00",
                    "text": "I was thinking something like the following should also be possible:\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\ninteger :: thing1, thing2\nreal :: foo, bar, baz\n\nselect pattern(stuff)\npattern (child_1(x = thing1, y = thing2))\n  ! do stuff with thing1 and thing2\npattern (child_2(a = foo, b = bar, c = baz))\n  ! do stuff with foo, bar and baz\npattern default\n  ! if nothing matched\nend select\nend subroutine\n\nwhich I guess would be equivalent to\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\ninteger :: thing1, thing2\nreal :: foo, bar, baz\n\nselect type(stuff)\ntype is (child_1)\n  child_1(x = thing1, y = thing2) = stuff\n  ! do stuff with thing1 and thing2\ntype is (child_2)\n  child_2(a = foo, b = bar, c = baz) = stuff\n  ! do stuff with foo, bar and baz\nclass default default\n  ! if nothing matched\nend select\nend subroutine\n\nwhich would be equivalent to\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\ninteger :: thing1, thing2\nreal :: foo, bar, baz\n\nselect type(stuff)\ntype is (child_1)\n  thing1 = stuff%x; thing2 = stuff%y\n  ! do stuff with thing1 and thing2\ntype is (child_2)\n  foo = stuff%a; bar = stuff%b; baz = stuff%c\n  ! do stuff with foo, bar and baz\nclass default default\n  ! if nothing matched\nend select\nend subroutine"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 22:25:23+00:00",
                    "text": "And then, here's where things can get interesting, if you want to match specific values:\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\ninteger :: thing1, thing2\nreal :: foo, bar, baz\n\nselect pattern(stuff)\npattern (child_1(x = thing1, y = 1))\n  ! do stuff with thing1 knowing y was 1\npattern (child_1(x = thing1, y = 2))\n  ! do stuff with thing1 knowing y was 2\npattern (child_1(x = thing1, y = thing2))\n  ! do stuff with thing1 and thing2\npattern (child_2(a = foo, b = bar, c = baz))\n  ! do stuff with foo, bar and baz\npattern default\n  ! if nothing matched\nend select\nend subroutine\n\nsimilarly becomes\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\ninteger :: thing1, thing2\nreal :: foo, bar, baz\n\nselect type(stuff)\ntype is (child_1)\n  if (stuff%y == 1) then\n    thing1 = stuff%x\n    ! do stuff with thing1 knowing y was 1\n  else if (stuff%y == 2) then\n    thing1 = stuff%x\n    ! do stuff with thing1 knowing y was 2\n  else\n    thing1 = stuff%x; thing2 = stuff%y\n    ! do stuff with thing1 and thing 2\n  end if\ntype is (child_2)\n  foo = stuff%a; bar = stuff%b; baz = stuff%c\n  ! do stuff with foo, bar and baz\nclass default default\n  ! if nothing matched\nend select\nend subroutine"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 22:32:22+00:00",
                    "text": "Actually, I'd rather not have to declare the types of the destructured variables, and have it be more like\nsubroutine do_some_things(stuff)\nclass(base_t), intent(in) :: stuff\n\nselect type(stuff)\ntype is (child_1)\n  if (stuff%y == 1) then\n    associate(thing1 => (stuff%x))\n      ! do stuff with thing1 knowing y was 1\n    end associate\n  else if (stuff%y == 2) then\n    associate(thing1 => (stuff%x))\n      ! do stuff with thing1 knowing y was 2\n    end associate\n  else\n    associate(thing1 => (stuff%x); thing2 => (stuff%y))\n      ! do stuff with thing1 and thing 2\n    end associate\n  end if\ntype is (child_2)\n  associate(foo => (stuff%a); bar => (stuff%b); baz => (stuff%c))\n    ! do stuff with foo, bar and baz\n  end associate\nclass default default\n  ! if nothing matched\nend select\nend subroutine\n\nAlso note that I placed the parens around each value, making them expressions, and thus the destructured variables are immutable."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-27 00:26:40+00:00",
                    "text": "@everythingfunctional I think this is beyond the scope of this specific request, but it is really a pain to access the objects members in some cases and this overpowered select-case could shorten a lot of code logic, indeed. It deserves it's own issue thread, however. Personally, I miss some features to help access members, like a for-each iterator (do auto :: element in array), avoiding declaring integer sizes variables and nested array of objects in loops (context variables in general).\n@certik We could also allow allocatable arrays in the unpack syntax. This way, one could easily implement a poor's man queue and stack.\n..., allocatable :: array(:)\n!! Some special unpacks\n[pop_front, array] = array\n[array, pop_back] = array\n!! It would act like the \"inverse operation\" of the current standard:\narray = [array, push_back]\narray = [push_front, array]"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-27 00:38:18+00:00",
                    "text": "At compile time the size is known, so this case is easily covered. At runtime we could just ensure that rhs has as many elements as lhs variables to unpack.\n\nWhat happens if you're unpacking the result of a function that returns an allocatable array? Or would this not be allowed?"
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-27 00:47:34+00:00",
                    "text": "At compile time the size is known, so this case is easily covered. At runtime we could just ensure that rhs has as many elements as lhs variables to unpack.\n\nWhat happens if you're unpacking the result of a function that returns an allocatable array? Or would this not be allowed?\n\nThat would require a temporary :/\n[x, y, z] = self % get_coords()\n[pop, array] = self % get_array()\n..., allocatable :: tmp\ntmp = self % get_coords()\nx = tmp(1);  y = tmp(2);  z = tmp(3);\n\n..., allocatable :: tmp\ntmp = self % get_array()\npop = tmp(1);  array = tmp(2:)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-27 00:56:19+00:00",
                    "text": "That would require a temporary :/\n\nWell, technically it already requires a temporary, you just don't see it because the compiler takes care of it (although it can be optimized away in many cases). And if it's a language feature, the compiler can do what makes sense anyway. As a user, I'd be surprised if it didn't work.\nAs far as the additional pattern matching features being above and beyond the scope of the initial request, you're probably right, but hey, let's aim big."
                }
            ]
        },
        {
            "number": 185,
            "user": "certik",
            "date": "2020-10-12 20:40:33+00:00",
            "title": "October 2020 WG5/J3 meeting",
            "text": "Zach and I will use this issue to keep the community updated on the work of the WG5 and J3 Committees at the October 2020 (virtual) meeting.\nThe documents for this meeting are here.\nMonday 10/12/2020\nJoR:\n\n20-140: Passed with unanimous consent. This paper modifies examples for auto-allocating arguments to intrinsic procedures.\n20-141: As amended, passed with unanimous consent.\n20-139: Passed with unanimous consent. This paper changes the API for the new intrinsic for splitting strings. (Spec & syntax: 19-245r1)\n20-137: As amended, passed with unanimous consent. This paper adds edits clarifying backwards-compatibility-breaking changes on auto-reallocating strings in write statements.\n\nData:\n\n20-142: Passed, 11 for 2 against. May be backed out later if there is no syntax with strong support.\n\nHPC:\n\n20-145: Passed with unanimous consent.\n20-146: Passed with unanimous consent.\n\nTuesday (10/13/2020)\nGenerics:\n\n20-148: Discussed, to be revised and voted tomorrow.\n20-135: passed unanimously, as amended.\n20-144: withdrawn, resubmit tomorrow (associated discussion at #157)\n\nJoR:\n\n20-155: preliminary vote, rework for tomorrow.\n20-158r2: passed with unanimous consent.\n20-160: withdrawn, will resubmit tomorrow\n20-153r1: passed with unanimous consent\n\nWednesday (10/14/2020)\nInterp:\n\n20-138r1: As amended, passed with unanimous consent.\n20-149: As amended, passed with unanimous consent.\n20-152r1: Passed with unanimous consent, with the alternative edit.\n\nEdit:\n\n20-133r2: As amended, passed with unanimous consent.\n\nHPC:\n\n20-156: As amended, passed with unanimous consent.\n20-162: Withdrawn for revision.\n20-163: Passed with unanimous consent.\n\nGenerics:\n\n20-148r1: As amended, passed with unanimous consent.\n20-144r1: As amended, passed with 10 for and 3 against.\n\nJoR:\n\n20-160r2: As amended, passed with unanimous consent.\n20-155r1: Withdrawn.\n\nData:\n\n20-131: Passed with unanimous consent.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2020-10-13 22:08:34+00:00",
                    "text": "What was the outcome of the discussion on 20-135?"
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 22:10:18+00:00",
                    "text": "@klausler I just updated it, sorry about that."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-13 22:13:39+00:00",
                    "text": "@klausler I just updated it, sorry about that.\n\nThanks.  But 20-135 and 20-144 still seem weird to me.  Are there any use cases yet for these features?"
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 22:33:00+00:00",
                    "text": "Thanks. But 20-135 and 20-144 still seem weird to me. Are there any use cases yet for these features?\n\nThere were no new use cases presented. I raised the issue that there are objections against these features from the community, that it would be nice to address and resolve them."
                },
                {
                    "user": "gklimowicz",
                    "date": "2020-10-13 22:34:08+00:00",
                    "text": "Not actually solving a problem using them. Just example fragments."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-14 23:13:48+00:00",
                    "text": "Anything decided on Wednesday?"
                },
                {
                    "user": "zjibben",
                    "date": "2020-10-15 00:27:00+00:00",
                    "text": "@klausler I just updated with Wednesday's results."
                },
                {
                    "user": "mleair",
                    "date": "2020-10-15 19:07:29+00:00",
                    "text": "With regard to 20-135 and 20-144, @tclune  provided this use case:\nConsider a situation where a developer needs to pad arrays of various ranks (1-3) with halo (or guard) cells in each direction with a specified width and an optional pad value. The logic is nearly identical in each case except that it is otherwise awkward to declare the arrays and reference sections and such. The example implementation below is less than ideal because one still must resort to a clunky mechanism to create specific names for the otherwise overloaded interface. In practice, I would use FPP/CPP #include and macros to create unique names through token concatenation.\nThere are 2 files below. The include file with most of the meat and the module file that includes it 3 times.\nfile 'pad.inc':\n  REAL, RANK(N), INTENT(IN) :: ARRAY\n  INTEGER, INTENT(IN) :: WIDTH\n  REAL, OPTIONAL, INTENT(IN) :: PAD_VALUE\n  REAL, BOUNDS(1-WIDTH:SHAPE(ARRAY)+WIDTH),  :: PAD_ARRAY\n\n  IF (PRESENT(PAD_VALUE)) PAD_ARRAY = PAD_VALUE\n  PAD_ARRAY(@:SHAPE(ARRAY)) = ARRAY\n\nfile pad_mod.F90:\nMODULE PAD_MOD\n   IMPLICIT NONE\n   INTERFACE PAD_ARRAY\n      MODULE PROCEDURE :: PAD_ARRAY_1D\n      MODULE PROCEDURE :: PAD_ARRAY_2D\n      MODULE PROCEDURE :: PAD_ARRAY_3D\n   END INTERFACE PAD_ARRAY\n\nCONTAINS\n   \n   FUNCTION PAD_ARRAY_1D(ARRAY, WIDTH, PAD_VALUE)\n      INTEGER, PARAMETER :: N = 1\n      INCLUDE 'PAD_INC'\n   END FUNCTION PAD_ARRAY_1D\n\n   FUNCTION PAD_ARRAY_2D(ARRAY, WIDTH, PAD_VALUE)\n      INTEGER, PARAMETER :: N = 2\n      INCLUDE 'PAD_INC'\n   END FUNCTION PAD_ARRAY_2D\n\n   FUNCTION PAD_ARRAY_3D(ARRAY, WIDTH, PAD_VALUE)\n      INTEGER, PARAMETER :: N = 3\n      INCLUDE 'PAD_INC'\n   END FUNCTION PAD_ARRAY_3D\n\nEND MODULE PAD_MOD"
                },
                {
                    "user": "certik",
                    "date": "2020-10-15 19:14:26+00:00",
                    "text": "This is a great example of why I think this feature does not go far enough. I would like this to just be:\nMODULE PAD_MOD\n   IMPLICIT NONE\n\nCONTAINS\n   \n   FUNCTION PAD_ARRAY(ARRAY, WIDTH, PAD_VALUE)\n      INTEGER, PARAMETER :: N = RANK(ARRAY)\n      REAL, RANK(N), INTENT(IN) :: ARRAY\n      INTEGER, INTENT(IN) :: WIDTH\n      REAL, OPTIONAL, INTENT(IN) :: PAD_VALUE\n      REAL, BOUNDS(1-WIDTH:SHAPE(ARRAY)+WIDTH),  :: PAD_ARRAY\n\n     IF (PRESENT(PAD_VALUE)) PAD_ARRAY = PAD_VALUE\n     PAD_ARRAY(@:SHAPE(ARRAY)) = ARRAY\n   END FUNCTION\n\nEND MODULE PAD_MOD\nWould this work, and if not, why not?\nWell, I think it would not work because the rank is only known either at runtime, or at the point where this function is called. So this is in some sense a \"generic interface\". But I would like to be able to write code in Fortran like this, with no pre-processor, no include files. Just code that works for arrays of any rank.\nAn interesting question then is: is this a runtime or compile time polymorphism? Well, I think it can be both, with the same syntax. The compiler can choose to generate just one subroutine, that operates on the array descriptor at runtime appropriately. Or it can choose to \"instantiate\" this for whatever rank you actually use it for (say 1D and 3D only) and generate an efficient code just for this rank."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-15 19:27:18+00:00",
                    "text": "You cannot have circularly defined arguments:\n      INTEGER, PARAMETER :: N = RANK(ARRAY)\n      REAL, RANK(N), INTENT(IN) :: ARRAY\nThe solution is to have N come in by other means.  (E.g., a template parameter.)\nSo in that I agree the existing feature does not go far enough.  But having a template parameter, we would still need the current feature to implement what you wrote."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-15 19:42:16+00:00",
                    "text": "Is there any other use case?  This halo example would be easy to write without using this feature."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-15 20:00:33+00:00",
                    "text": "Yes.   I'm working on a couple more  for which I've shown how I would implement the use case in each revision from F2008 to F202y.\nThe example above was merely to show that the feature could be used in a generic context.  Daniel could not see that aspect from the examples in the paper which were just to demonstrate the syntax.        The real win is when we can combine this feature with something like template parameters."
                },
                {
                    "user": "mleair",
                    "date": "2020-10-15 20:02:09+00:00",
                    "text": "To address the comment by @tclune, perhaps the array in the parameter statement is the \"template parameter\". For example, using parameterized modules with modules pseudocode:\nMODULE MOD_RANK_2\n  REAL :: TARRAY(10, 10)\nEND MODULE MOD_RANK_2\n\nMODULE MOD (T)\n  USE T\n  CONTAINS\n   \n  FUNCTION PAD_ARRAY(ARRAY, WIDTH, PAD_VALUE)\n    INTEGER, PARAMETER :: N = RANK(TARRAY)\n    REAL, RANK(N), INTENT(IN) :: ARRAY\n     :\n  END FUNCTION PAD_ARRAY\nEND MODULE MOD\n\nPROGRAM P\n  USE MOD(MOD_RANK_2)\nEND\n\n\nThe above example could also be written in a template syntax if that's the direction we go. Also, I imagine a concepts syntax could also be introduced to require that the above module parameter incudes a TARRAY object."
                },
                {
                    "user": "certik",
                    "date": "2020-10-15 21:06:37+00:00",
                    "text": "I thought the way to do it is using the .. rank:\n   FUNCTION PAD_ARRAY(ARRAY, WIDTH, PAD_VALUE)\n      REAL, INTENT(IN) :: ARRAY(..)\n      INTEGER, INTENT(IN) :: WIDTH\n      REAL, OPTIONAL, INTENT(IN) :: PAD_VALUE\n      REAL, BOUNDS(1-WIDTH:SHAPE(ARRAY)+WIDTH),  :: PAD_ARRAY\n\n     IF (PRESENT(PAD_VALUE)) PAD_ARRAY = PAD_VALUE\n     PAD_ARRAY(@:SHAPE(ARRAY)) = ARRAY\n   END FUNCTION\nI guess you don't even need the N parameter in this case.\nP.S. We should be discussing this at #157."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-15 21:14:40+00:00",
                    "text": "The 2nd executable statement above won't work.   ARRAY can only be referenced (in a useful manner) within a SELECT RANK if it is of assumed rank.\nLike wise, the declaration of PAD_ARRAY cannot work like that.  The compiler needs to know the rank at compile time.      It's also not clear to me if it is legal to use SHAPE(ARRAY) in the declaration since ARRAY is assumed rank.    That seems like it ought to be able to work but I could not immediately spot wording in the standard that makes this clear.   Probably a Malcolm question in the near future, but we (generic subgroup) should at least make an effort to find words in the standard."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-15 21:20:12+00:00",
                    "text": "16.9.172.  SHAPE(A) works for any array A except an assumed-size array, including assumed-rank, (and oddly enough, an assumed-rank array associated with an assumed-size array)."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-15 23:03:54+00:00",
                    "text": "@klausler Thanks - that was what I was hoping for SHAPE.\nThe declaration of PAD_ARRAY is still illegal though.   The constraint added in the BOUNDS paper is:\nC821b  shall be a rank one integer array with\nconstant size.\nBecause ARRAY is assumed-rank,  SHAPE(ARRAY) is not of constant size."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-15 23:52:34+00:00",
                    "text": "That's a surprising restriction for a feature that is intended to be useful in rank-independent programming, and it should be easy to fix.  The language has assumed-rank dummy arguments already, and could accommodate other objects with unknown rank."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 00:36:20+00:00",
                    "text": "There is a difference between rank-independent and rank-agnostic.  (Well, I'm tired now, but I think there is a distinction to be made.)\nRegardless, I agree that it is at least a bit surprising at first blush this this is forbidden, but I disagree that it would be easy to fix.     The rank of PAD_ARRAY is not known at compile time.    Deferred-rank has been suggested and discussed (briefly) several times is recent years, and it would be considered a major new feature.\n\"Unknown rank\" for deferred-rank dummy arguments is possible because the dope vector can be found in the associated actual argument.    Very little can be done with them outside of a SELECT RANK statement which allows the compiler a place to generate the rank-dependent code."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 00:59:29+00:00",
                    "text": "After I walked away, I realized a simple example should crystalize why this is not easy to fix.   Should the compiler be able to diagnose whether any of the assignment statements below are legal?      We usually expect the compiler to diagnose when an array reference uses an incorrect number of simple subscripts.\nsubroutine s(a, b)\n   real, intent(in) :: a(..) ! assumed-rank\n   real, bounds(shape(a)) :: b \n\n   b(1) = 1\n   b(1,1) = 1\n   b(1,1,1) = 1\n\nend subroutine s\nThis restriction is relaxed a bit for the proposed @ syntax, where only run-time checking is possible, but the intent with BOUNDS and RANK was not to introduce a new type of array or to change the rules for existing mechanisms for accessing elements and array sections."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-16 01:06:28+00:00",
                    "text": "None of those assignments would be allowed if 'b' were an assumed-rank dummy argument either.  The situation would be similar in the event that BOUNDS had an argument of unknown length, as in your example."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 12:39:22+00:00",
                    "text": "I might not oppose a change to extend BOUNDS to declare two different types of arrays.   When the length is fixed, then array references can be made without the protection of SELECT RANK.  When the length is not fixed then the array could only be referenced (with the obvious exceptions) inside of SELECT RANK.      I think it could be confusing at times, as it may not always be easy for the user to tell whether or not the length is fixed.   More examples where it provides value might be useful to aid in the evaluation.\nI would be opposed to a change that ends up forcing even those cases with fixed size to be accessed within SELECT RANK clauses.\nA related thought:  SELECT RANK is not so bad when there is only one assumed-rank array involved.   Once there are multiple such arrays and even if you know they are all the same rank, you end up being forced to nest multiple select ranks.   E.g., consider the case where I have 3 such dummy arguments b1, b2, b3 and as a final step I want to add them and store the result back into b1.    Maybe they can only be rank 2 and 3 to keep this \"simple\".  To do this with the suggested extension of BOUNDS:\nreal, bounds(shape(a)) :: b1\nreal, bounds(shape(a)) :: b2\nreal, bounds(shape(a)) :: b3\n\nselect rank (b1)\nrank (2)\n   select rank(b2)\n   rank (2)\n      select rank(b3)\n      rank(2)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      rank(3)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      end select\n   rank (3)\n      select rank(b3)\n      rank(2)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      rank(3)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      end select\nrank (3)\n   select rank(b2)\n   rank (2)\n      select rank(b3)\n      rank(2)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      rank(3)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      end select\n   rank (3)\n      select rank(b3)\n      rank(2)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      rank(3)\n           b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\n      end select\n   end select\nend select\nIt would be much better if we could somehow enable such assignment statements to be moved out of the SELECT RANK block.   Maybe if all the subscripts are multi-subscripts (i.e., those with the @) we could remove the constraint.   We would need some very solid use cases, and recognize up front that this is a big enough change that other generic capabilities in F202y may be sacrificed in the process."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 14:06:17+00:00",
                    "text": "Thinking about it some more my last statement is not very useful.       Using the @ does not change the fact that the intermediate expressions are of unknown rank at compile time.    There would need to be a general facility in the language for handling expressions of unknown rank for something along the lines to work."
                },
                {
                    "user": "mleair",
                    "date": "2020-10-16 18:39:23+00:00",
                    "text": "Tom,\nWould a select rank that can take more than one array be useful in general? That is, the select rank would evaluate all the arrays in the list. If they are all the same rank, then execution branches to that rank case. Otherwise, execution branches to RANK DEFAULT (if provided) or to the end of the select rank construct. If RANK DEFAULT is provided, then the programmer could provide either a nested select rank or do something else (e.g., issue an error and abort).\nYour example using the extension:\nreal, bounds(shape(a)) :: b1\nreal, bounds(shape(a)) :: b2\nreal, bounds(shape(a)) :: b3\n\nselect rank (b1, b2, b3)\nrank (2)\n  b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b3(@:shape(b3))\nrank (3)\n  b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b3(@:shape(b3))\nrank default\n  stop 'Unexpected Rank in b1, b2, and/or b3'\nend select"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-16 18:48:32+00:00",
                    "text": "Tom,\nWould a select rank that can take more than one array be useful in general? That is, the select rank would evaluate all the arrays in the list. If they are all the same rank, then execution branches to that rank case. Otherwise, execution branches to RANK_DEFAULT (if provided) or to the end of the select rank construct. If RANK_DEFAULT is provided, then the programmer could provide either a nested select rank or do something else (e.g., issue an error and abort).\nYour example using the extension:\nreal, bounds(shape(a)) :: b1\nreal, bounds(shape(a)) :: b2\nreal, bounds(shape(a)) :: b3\n\nselect rank (b1, b2, b3)\nrank (2)\n  b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b3(@:shape(b3))\nrank (3)\n  b1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b3(@:shape(b3))\nrank_default\n  stop 'Unexpected Rank in b1, b2, and/or b3'\nend select\n\n\nSince the rank is a known constant in each RANK case, the @ notation doesn't seem necessary.\nreal, bounds(shape(a)) :: b1, b2, b3\nselect rank (b1, b2, b3)\nrank (2)\n  b1 = b1 + b2 + b3\nrank (3)\n  b1 = b1 + b2 + b3\nrank default\n  error stop 'you lose'\nend select\n\nor even\nreal, bounds(shape(a)) :: b1, b2, b3\nselect rank (b1, b2, b3)\nrank (2:3)\n  b1 = b1 + b2 + b3\nrank default\n  error stop 'you lose'\nend select\n\nwhich seems pretty elegant to me."
                },
                {
                    "user": "certik",
                    "date": "2020-10-16 19:13:32+00:00",
                    "text": "That is my point, the whole select rank does not seem necessary.\nreal, bounds(shape(a)) :: b1\nreal, bounds(shape(a)) :: b2\nreal, bounds(shape(a)) :: b3\n\nb1(@:shape(b1)) = b1(@:shape(b1)) + b2(@:shape(b2)) + b2(@:shape(b3))\nThe @ notation would imply select rank."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-19 16:01:18+00:00",
                    "text": "@klausler Right - in this particular case, whole arrays are appropriate and I was blinded by the details.   But there are certainly still fixed-rank cases where eg., some other aspect of the rank handling can take useful advantage of the @ notation.   The gather example I posted for instance.\n@certik   Conceptually, you are correct.  There is absolutely no reason for SELECT RANK from the user perspective - one can work out at run time everything that should happen.   From the compiler perspective, I am assured that it matters a great deal.          Not only are there various constraints that would need to be loosened, but I'm certain that there are a number of optimizations that are also lost in the general case.        It is quite possible that we can have the best of both worlds - \"potentially unoptimized\" if one uses @ and fully constrained if one does not.    But it is a funny situation, and I fully expect vendors to push back with cases we have not yet considered; saying that this is all a bridge too far.\nOn a related front, should we then allow:\ntype foo\n    real, allocatable :: arr(..)\nend type\nAfter all, the references can all be checked at run time to be certain that they are correct, and we now have syntax for allocating such arrays."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-19 16:06:21+00:00",
                    "text": "I should also say that when debating SELECT RANK, I did suggest an amendment that would allow\nSELECT RANK (arr)\nRANK (2:4)\n      CALL SUB(arr)\nEND SELECT RANK\nwhere SUB is suitable overloaded for the relevant ranks.    Or more generally any expression which is sensible for the specified ranks.   After all, it is fairly straightforward to preprocess this back into a fine-grained list of RANK clauses.    Vendors in the room quickly shot it down as being unworkable.    I cannot defend there statements, and it would be nice if a vendor could chime in here to provide some background on where the tradeoffs are here."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-19 16:13:27+00:00",
                    "text": "Fortran already has assumed rank ALLOCATABLE dummy arguments; deferred rank ALLOCATABLE variables and components would be easy to support.  More edits to the document than lines of code, I think.\nI don't know why a range of ranks would be considered difficult to implement, given a working implementation of the current SELECT RANK.  Error messages for anything in the contained statements might be hard to contextualize in a useful way with the value of the rank that leads to a particular error, but that's a quality of implementation concern."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-19 16:16:37+00:00",
                    "text": "Well, as someone who has wanted deferred rank for a very long time, I find these statements encouraging.   And I am somewhat amused that my current role makes me the voice of caution."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-19 16:22:58+00:00",
                    "text": "To be clear, \"easy to support\" does not mean \"easy to accomplish in J3\".  Or vice versa."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-19 16:26:15+00:00",
                    "text": "Certainly.       But I can only see as far as what is hard to change in the text.   I rely on vendors to tell me what is hard to implement.     At least one vendor (will not name publicly) has indicated to me that it may well make sense to support deferred rank arrays at some point but that it would be a major feature.    I did not press them to what degree it was because of the document or because of implementation.   I was just ecstatic that it was not immediately shot down as without merit."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-19 16:39:33+00:00",
                    "text": "Deferred rank array variables and components, in general, might have pitfalls; deferred rank ALLOCATABLE and POINTER arrays, on the other hand, would be pretty much the same thing as assumed rank dummy arguments."
                },
                {
                    "user": "certik",
                    "date": "2020-10-19 17:42:34+00:00",
                    "text": "@tclune this is the kind of discussion we have to have, let's keep it going. Together with a prototype compiler implementation, which I volunteer to attempt for promising proposals and I am hoping @klausler will also. :)"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-19 18:03:27+00:00",
                    "text": "@tclune this is the kind of discussion we have to have, let's keep it going. Together with a prototype compiler implementation, which I volunteer to attempt for promising proposals and I am hoping @klausler will also. :)\n\nWell, maybe.  I'm not on J3 and I'm somewhat less concerned with advocating for new standard features than I am about trying to keep more poorly designed features like DO CONCURRENT from being mandated, and I don't see how prototyping would help much with that goal."
                },
                {
                    "user": "certik",
                    "date": "2020-10-20 19:38:22+00:00",
                    "text": "Here is a great idea proposed by @longb:\ntemplate subroutine add(b1, b2, b3)\n  real,intent(inout) :: b1(..)\n  real,intent(in) :: b2(..)\n  real,intent(in) :: b3(..)\n\n  b1 = b1 + b2 + b3\n\nend subroutine add\nI wonder if the template modifier before subroutine (which I initially missed) is needed? As a user I wouldn't mind writing it without it. But I think the idea is that it explicitly states that the compiler will be \"instantiating\" this at the call site by mangling the subroutine name internally. I think that's fine."
                },
                {
                    "user": "mleair",
                    "date": "2020-10-20 19:47:20+00:00",
                    "text": "@certik As someone who is just getting back into J3 Committee work, I need to ask. Is the proposed template syntax written up somewhere? Or was it first mentioned just now on the J3 email list?"
                },
                {
                    "user": "certik",
                    "date": "2020-10-20 19:48:31+00:00",
                    "text": "@mleair this is the first time I saw it."
                },
                {
                    "user": "mleair",
                    "date": "2020-10-20 19:49:18+00:00",
                    "text": "OK. Thanks!"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-20 19:52:49+00:00",
                    "text": "Here is a great idea proposed by @longb:\ntemplate subroutine add(b1, b2, b3)\n  real,intent(inout) :: b1(..)\n  real,intent(in) :: b2(..)\n  real,intent(in) :: b3(..)\n\n  b1 = b1 + b2 + b3\n\nend subroutine add\nI wonder if the template modifier before subroutine (which I initially missed) is needed? As a user I wouldn't mind writing it without it. But I think the idea is that it explicitly states that the compiler will be \"instantiating\" this at the call site by mangling the subroutine name internally. I think that's fine.\n\nHow would the interface of that procedure declare that the ranks of the dummy arguments were either identical or (for b2 and b3) scalar?"
                },
                {
                    "user": "longb",
                    "date": "2020-10-20 19:58:33+00:00",
                    "text": "Hi Mark,\n\nThe 202X feature list is in WG5 paper N2165 - worth a read.\n\nThe last templates paper was from Meeting 217;  paper 18-281r1\n\nCheers,\nBIll\n On Oct 20, 2020, at 2:47 PM, mleair ***@***.***> wrote:\n\n\n @certik As someone who is just getting back into J3 Committee work, I need to ask. Is the proposed templay syntax written up soemwhere? Or was it first mentioned just now on the J3 email list?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\nBill Long                                                                       longb@hpe.com\nEngineer/Master , Fortran Technical Support &   voice:  651-605-9024\nBioinformatics Software Development                      fax:  651-605-9143\nHewlett Packard Enterprise/ 2131 Lindau Lane/  Suite 1000/  Bloomington, MN  55425"
                },
                {
                    "user": "certik",
                    "date": "2020-10-20 20:01:09+00:00",
                    "text": "How would the interface of that procedure declare that the ranks of the dummy arguments were either identical or (for b2 and b3) scalar?\n\nGood point. Following the \"strong concepts\" idea (that we seem to agree in the generics subgroup is the way to go), if the compiler compiles this routine and does not report an error, it should mean there is no problem with this code.\nThis means that the compiler must generate the compatible ranks as part of the function signature, and then at the call site if the user passes incompatible ranks, it must generate a nice message, without having to go over the code of add to determine that.\nSo the question is, whether the compiler can generate the list of compatible ranks (in this case it seems the requirement is that they either have to have the same rank, or some of them can be scalars). If the compiler cannot do that automatically, then I think the path is to require the user to specify that explicitly using some variation of the syntax proposed by @tclune."
                },
                {
                    "user": "certik",
                    "date": "2020-10-20 20:11:28+00:00",
                    "text": "Ok, so the paper 18-281r1 that @longb suggested above explains the template prefix proposal. One of the examples in the paper allows to write a procedure that works for any real kind, which seems to be exactly the issue #128."
                },
                {
                    "user": "longb",
                    "date": "2020-10-20 20:11:45+00:00",
                    "text": "On Oct 20, 2020, at 2:53 PM, Peter Klausler ***@***.***> wrote:\n\n\n Here is a great idea proposed by @longb:\n\n template subroutine add(b1, b2, b3\n )\n\n real,intent(inout) ::\n  b1(..)\n\n real,intent(in) ::\n  b2(..)\n\n real,intent(in) ::\n  b3(..)\n\n   b1\n = b1 + b2 +\n  b3\n\n\n end subroutine add\n I wonder if the template modifier before subroutine (which I initially missed) is needed? As a user I wouldn't mind writing it without it.\nThe word \u201ctemplate\u201d is just an addition to the current list of prefix modifiers (elemental, pure, impure, recursive, non_recursive).   It is a signal to the compiler that declaration usage in the subprogram is outside the restrictions for non-template subprograms.  IT is easier in the standard to have words like \u201cit template does not appear\u2026\u201d.  An underlying motivation for the template proposal is to leverage already existing ideas.   For example, assumed-kind would be allowed, as in\n\nreal(*),intent(in) :: b2(..)\n\nwith the KIND value assumed from the actual argument.\n But I think the idea is that it explicitly states that the compiler will be \"instantiating\" this at the call site by mangling the subroutine name internally. I think that's fine.\n\n How would the interface of that procedure declare that the ranks of the dummy arguments were either identical or (for b2 and b3) scalar?\nGood question.  The DATA and GENERIC subgroups have been busy coming up with ways in declarations to say \u201csame-{shape | type | class} -as\u201d . As a practical matter, when the compiler attempts the instantiation you will get an error if the assignment or additions are not legal.\n\nCheers,\nBill\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\nBill Long                                                                       longb@hpe.com\nEngineer/Master , Fortran Technical Support &   voice:  651-605-9024\nBioinformatics Software Development                      fax:  651-605-9143\nHewlett Packard Enterprise/ 2131 Lindau Lane/  Suite 1000/  Bloomington, MN  55425"
                },
                {
                    "user": "certik",
                    "date": "2020-10-20 20:18:14+00:00",
                    "text": "Good question. The DATA and GENERIC subgroups have been busy coming up with ways in declarations to say \u201csame-{shape | type | class} -as\u201d . As a practical matter, when the compiler attempts the instantiation you will get an error if the assignment or additions are not legal.\n\nI want to bring an important distinction here:\n\n\nweak or no concepts: the compiler will have to go over the code of add at each call site to determine if the code is semantically valid, and generate an error otherwise. Experience with C++ shows that such errors can become very hard to read, as they can be nested in subroutines, etc. and the error will typically come from some line such as a = b + c that the ranks are incorrect, but the user has no idea what caused it.\n\n\nstrong concepts: the compiler reports all errors based on the function signature at the call site, without a need to go over the internal code of add. This means faster compilation (the compiler only needs to pre-compile add once, and if no errors are detected at the time of compilation of the generic add, then there are no semantic error with that code, no matter how it is called) and better error messages at the call site if the user passes incompatible array ranks in.\n\n\nAt the generic subcommittee, we currently want to do \"strong concepts\", for the advantages stated above."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-20 22:48:39+00:00",
                    "text": "Good question. The DATA and GENERIC subgroups have been busy coming up with ways in declarations to say \u201csame-{shape | type | class} -as\u201d . As a practical matter, when the compiler attempts the instantiation you will get an error if the assignment or additions are not legal.\n\nEven with the proposed implicit rank and kind, one would still need the new F202x syntax for any local variables that needed to vary in the same manner."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-21 13:30:17+00:00",
                    "text": "The syntax that @longb suggests in this thread is intriguing due to its simplicity.      I'm fairly convinced that the approach is ultimately limited on several fronts.   First, and perhaps foremost is the strong concepts concern that @certik raised.    There is also the concern that Van Snyder raised in the J3 thread that it really does not address the issue of parameters for derived types.\nIt is possible that we end up wanting a bit of both.  E.g., Magne Haveraaen has argued that real world complexities can be reduced if one allows parameters on methods (type-bound procedures) that extend the parameters of the type to which they are bound.     Possibly the syntax suggested by @longb could be part of this broader approach.     I had envisioned something a bit more explicit, and it is definitely too early to start debating the differences with any seriousness.\nWe need use cases, lots of use cases, with which variant approaches can be assessed.     The big near-term challenge that I see is how to isolate, categorize, and ultimately prioritize \"micro\" use cases that are extracted from broader use cases.   And at this point, the thread should really be on the generics sister project."
                },
                {
                    "user": "certik",
                    "date": "2020-10-21 14:15:55+00:00",
                    "text": "I agree. Tom, you work on use cases, I am working on language comparisons, and I also volunteer to start a document that captures our discussions and how our ideas evolve, so that others can get up to speed quickly.\n\nLet's use the generics repository from now on.\n\u2026\nOn Wed, Oct 21, 2020, at 7:30 AM, Tom Clune wrote:\n\n\n The syntax that @longb <https://github.com/longb> suggests in this\n thread is intriguing due to its simplicity. I'm fairly convinced that\n the approach is ultimately limited on several fronts. First, and\n perhaps foremost is the strong concepts concern that @certik\n <https://github.com/certik> raised. There is also the concern that Van\n Snyder raised in the J3 thread that it really does not address the\n issue of parameters for derived types.\n\n It is possible that we end up wanting a bit of both. E.g., Magne\n Haveraaen has argued that real world complexities can be reduced if one\n allows parameters on methods (type-bound procedures) that *extend* the\n parameters of the type to which they are bound. Possibly the syntax\n suggested by @longb <https://github.com/longb> could be part of this\n broader approach. I had envisioned something a bit more explicit, and\n it is definitely too early to start debating the differences with any\n seriousness.\n\n We need use cases, lots of use cases, with which variant approaches can\n be assessed. The big near-term challenge that I see is how to isolate,\n categorize, and ultimately prioritize \"micro\" use cases that are\n extracted from broader use cases. And at this point, the thread should\n really be on the generics sister project.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#185 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWFHCUFLISPD5PLRIZTSL3O7VANCNFSM4SNKWX4Q>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-10-23 03:45:08+00:00",
                    "text": "Maybe what would be useful are RANKOF and SHAPEOF specifiers similar in spirit to the TYPEOF and CLASSOF specifiers of 202X."
                },
                {
                    "user": "longb",
                    "date": "2020-10-23 11:30:51+00:00",
                    "text": "On Oct 22, 2020, at 10:45 PM, William B. Clodius ***@***.***> wrote:\n\n\n Maybe what would be useful are RANKOF and SHAPEOF specifiers similar in spirit to the TYPEOF and CLASSOF specifiers of 202X.\nThere are already proposals for RANK and BOUNDS attributes.  RANK confusingly has the same spelling as the RANK intrinsic, so instead of RANKOF(X) we now have RANK(RANK(X)),   I think your proposed spellings are better.\n\nCheers,\nBIll\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\nBill Long                                                                       longb@hpe.com\nEngineer/Master , Fortran Technical Support &   voice:  651-605-9024\nBioinformatics Software Development                      fax:  651-605-9143\nHewlett Packard Enterprise/ 2131 Lindau Lane/  Suite 1000/  Bloomington, MN  55425"
                },
                {
                    "user": "tclune",
                    "date": "2020-10-23 12:33:54+00:00",
                    "text": "I agree that the situation is a bit inconsistent in a fairly trivial sense, but there are arguments for how things turned out.\n\nRelated aspects that I find amusing:\n\n(1) The true \u201coriginal sin\u201d on this front is the explicit TYPE() used to designate derived types back in F90. (And begrudgingly now allow for intrinsics).      Were it not for that, I would have spelled  TYPEOF(x) as TYPE(x).   The parens are read out loud as \u201cof\u201d.\n\n(2) Oddly it does not take much to make such redundant declarations acceptable.   Somehow  KIND=KIND(x) is more acceptable than RANK(RANK(x))  even though though there are punctuation marks in exactly the same places save for an extra trailing paren (which I very much doubt is the problem).\n\nCheers,\n\n- Tom\nOn Oct 23, 2020, at 7:31 AM, Bill Long ***@***.******@***.***>> wrote:\n On Oct 22, 2020, at 10:45 PM, William B. Clodius ***@***.******@***.***>> wrote:\n\n\n Maybe what would be useful are RANKOF and SHAPEOF specifiers similar in spirit to the TYPEOF and CLASSOF specifiers of 202X.\nThere are already proposals for RANK and BOUNDS attributes. RANK confusingly has the same spelling as the RANK intrinsic, so instead of RANKOF(X) we now have RANK(RANK(X)), I think your proposed spellings are better.\n\nCheers,\nBIll\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\nBill Long longb@hpe.com<mailto:longb@hpe.com>\nEngineer/Master , Fortran Technical Support & voice: 651-605-9024\nBioinformatics Software Development fax: 651-605-9143\nHewlett Packard Enterprise/ 2131 Lindau Lane/ Suite 1000/ Bloomington, MN 55425\n\n\n\n\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_j3-2Dfortran_fortran-5Fproposals_issues_185-23issuecomment-2D715285479&d=DwMFaQ&c=ApwzowJNAKKw3xye91w7BE1XMRKi2LN9kiMk5Csz9Zk&r=EDCdNzkccJ25Co3sjWrr1HlJQ3_CoIFWfekFE1ulcLI&m=NCv5fRaKxFoLClpI1Gefn4jnfP0YmLlghmVp3Ly9ypU&s=ogxpI0aIUrHNMDHdM5uF4Ii5ERZ-K7BIvsrPDYsSOwE&e=>, or unsubscribe<https://urldefense.proofpoint.com/v2/url?u=https-3A__github.com_notifications_unsubscribe-2Dauth_ABPP7YCLTOQYVCHKJOIUB7TSMFSPVANCNFSM4SNKWX4Q&d=DwMFaQ&c=ApwzowJNAKKw3xye91w7BE1XMRKi2LN9kiMk5Csz9Zk&r=EDCdNzkccJ25Co3sjWrr1HlJQ3_CoIFWfekFE1ulcLI&m=NCv5fRaKxFoLClpI1Gefn4jnfP0YmLlghmVp3Ly9ypU&s=bdVvenvu7R-TNKa49saPtREw4unGN_n6ObqygONO0zs&e=>."
                }
            ]
        },
        {
            "number": 184,
            "user": "zmiimz",
            "date": "2020-10-08 10:28:25+00:00",
            "title": "built-in unit testing",
            "text": "add unit testing feature directly into the language.\nMissing built-in unit testing is unacceptable freedom for any modern programming language and the development of critical software.  If we are positioning Fortran as something better than a formula translator, we need unit testing directly built-in to the language. Currently, there are some external modules/ unit testing frameworks for that purpose (see http://fortranwiki.org/fortran/show/Unit+testing+frameworks ), but implemented in completely different languages (Ruby, Perl, etc.), and/or with several limitations originated from the restrictions of Fortran language itself. Therefore, unit testing should be added ideally only after the implementation of \"standard library\", \"exception handling\" and m.b. after \"generic/metaprogramming\" features.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-08 14:24:38+00:00",
                    "text": "It depends on what you mean by \"unit testing\" and what you mean by \"built-in\". The definition I use for \"unit testing\" is executing a small \"unit\" of code (where small is a bit subjective), in isolation (i.e. it doesn't touch any external resources or any other pieces of production code), with known input(s), and verifying it produces the expected output(s) or behavior(s).\nFor me, I don't want my unit tests mixed in with my production code. I know there are some languages that enable, if not encourage that (Rust and maybe Python depending on the framework your using come to mind), but most languages I've used do not (Haskell, C++, Ruby, Javascript, Java, and many other's I haven't actually used).\nThe frameworks written in other languages are working around a limitation inherent in the kind of language that Fortran is, a compiled language without runtime reflection. Without that, you can't use Fortran to find the tests at run-time, you have to find them before compile time and construct a program that runs them. A sufficiently powerful preprocessor could make this doable \"in Fortran\", without having to invoke a separate tool prior to compilation, but that doesn't require any changes to the language itself (unless we want the standard to start defining prepocessor requirements too).\nDo you have an example of the kind of code and test you'd like to write, but currently can't, and what specifically the language might need in order to make it work?"
                },
                {
                    "user": "zmiimz",
                    "date": "2020-10-08 14:53:47+00:00",
                    "text": "You can find a good implementation example here https://dlang.org/spec/unittest.html  And yes, I suggest to have unit tests in the production code and to be able to run unit tests with every standard conforming compiler and without any external tool."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-08 15:03:30+00:00",
                    "text": "in isolation (i.e. it doesn't touch any external resources or any other pieces of production code), with known input(s)\n\nI don't understand this. How do you test production code then? At some point you need to call a function or subroutine that is to be used in production and check its result, no? Usually, it's only the production code that I want to test."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-08 16:00:16+00:00",
                    "text": "I don't understand this. How do you test production code then? At some point you need to call a function or subroutine that is to be used in production and check its result, no? Usually, it's only the production code that I want to test.\n\nRight, but you want to test only that one function or subroutine (unit) in a given unit test. If it wants to collaborate with some other resource (read from a file, print to screen, fire the missiles, etc.), you generally want to provide some sort of mock, stub, spy (whatever term you want to use) for it to use during the test. Otherwise it would be considered an integration test, since you're testing multiple units integrated together. Not that those kinds of tests aren't valuable as well, but they're not truly unit tests (at least by my definition)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-08 16:02:05+00:00",
                    "text": "Ah, I understand now, I agree. Indeed you wrote \"any other pieces of production code\". I should've read more carefully."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-08 16:08:44+00:00",
                    "text": "I suggest to have unit tests in the production code and to be able to run unit tests with every standard conforming compiler and without any external tool.\n\nIs the idea then that the tests are run as part of the compilation process, but not included in the resulting executable? Or that the executable is able to \"test itself\" in some secondary mode of operation? I'm not familiar with D, so that example isn't particularly enlightening for me. Is D a compiled or interpreted language? What are the mechanics of running the unit tests?"
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2020-11-19 16:08:43+00:00",
                    "text": "@zmiimz I agree, that unit testing in the standard (like it exists for Python) would be perfect. Yet, for the time being, I can highly recommend pFUnit.\nPS: Many other modern languages do also not have a built-in unit test capability (e.g. C++)"
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-16 14:02:25+00:00",
                    "text": "Rust and Julia, two rather recent languages, have direct support for unit testing.\nSince Fortran does not have (yet) a standard library it would be natural to have support for unit tests in the core language instead of relying on third-party libraries."
                },
                {
                    "user": "certik",
                    "date": "2021-06-16 17:12:43+00:00",
                    "text": "(We are working on the standard library: stdlib.)"
                }
            ]
        },
        {
            "number": 183,
            "user": "certik",
            "date": "2020-10-05 12:24:44+00:00",
            "title": "Conditional Expressions",
            "text": "Relevant papers:\n\nhttps://j3-fortran.org/doc/year/18/18-274.txt\nhttps://j3-fortran.org/doc/year/19/19-258.txt\nhttps://j3-fortran.org/doc/year/19/19-247r1.txt\nhttps://j3-fortran.org/doc/year/19/19-248.txt\n\nTaking the second example from the 18-274 paper:\n  IF (PRESENT(D)) THEN\n    CALL SUB(A,B,C,D)\n  ELSE IF (X<1) THEN\n    CALL SUB(A,B,C,EPSILON(X))\n  ELSE\n    CALL SUB(A,B,C,SPACING(X))\n  END IF\nOne proposed syntax is \"keyword syntax\":\nCALL SUB(A, B, C, IF (PRESENT(D) THEN D ELSE IF (X < 1) THEN EPSILON(X) ELSE SPACING(X) END IF)\nThe second proposed syntax is \"? syntax\":\nCALL SUB(A, B, C, ? (PRESENT(D) D :? (X < 1) EPSILON(X) : SPACING(X) ?)",
            "is_open": true,
            "labels": [
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-10-05 12:31:17+00:00",
                    "text": "Which of these do people find the most readable and least readable?\nMy own feeling (from most readable to least readable):\n\nOriginal\nkeyword syntax\n? syntax\n\nWe should also consider more use cases. I also asked at https://fortran-lang.discourse.group/t/202x-feature-conditional-expressions/329 to get more feedback on this feature."
                },
                {
                    "user": "dev-zero",
                    "date": "2020-10-05 13:13:16+00:00",
                    "text": "To be honest I find both variants suboptimal (the first one would make an if/else/endif block return a value when being used inline, and simply run code as usual when not, but would be easier to read) and I wonder whether there is really a need for general conditional expressions or whether a ternary operator would be sufficient. In the latter case I would suggest the Python-based syntax (which one could even nest):\nCALL SUB(A, B, C, D IF PRESENT(D) ELSE (EPSILON(X) IF (X < 1) ELSE SPACING(X)))"
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 13:22:26+00:00",
                    "text": "@dev-zero in your opinion, can you rate by readability / preference the three options above plus your proposed Python-based syntax?\nThe ternary operator (that you presumably like) is the \"? syntax\" which is one of the proposed ideas, but you also say they are \"suboptimal\", so I am confused."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-05 13:39:43+00:00",
                    "text": "From most to least readable:\n\nOriginal\nPython/@dev-zero syntax\nKeyword syntax\n? syntax\n\nCaveat: I use 2 in Python a lot so I'm used to it, thus my preference."
                },
                {
                    "user": "epagone",
                    "date": "2020-10-05 14:03:36+00:00",
                    "text": "FWIW my preference from most to least readable is:\n\nOriginal\nkeyword syntax\n? syntax\n\nAside the reduced readability, IMHO I cannot see any practical advantage in the new proposed expressions."
                },
                {
                    "user": "dev-zero",
                    "date": "2020-10-05 15:08:54+00:00",
                    "text": "My preference in terms of readability:\n\nOriginal\nPython-inspired syntax\nKeyword syntax\n? syntax\n\nAs for why I dislike the ? syntax and the difference to the Python-inspired operator:\nA general start and end marker ? for conditional expression would to me indicate that more complex conditional expressions should be possible at some point, with the only condition that all codepaths inside it have to return a compatible type, but that is with the current proposal not the case (nor should it be). On the other hand does the nesting as shown in the example above actually create (at least visually) an alias for ELSE IF: the :?, since the expression should actually be:\nCALL SUB(A, B, C, ? (PRESENT(D)) D : ? (X < 1) EPSILON(X) : SPACING(X) ? ?)\ncorrect? With the second to last ? omitted? Which I would find even less readable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 15:22:29+00:00",
                    "text": "I think the readability question might slightly be missing the point. The question isn't about how easy is it to see what the code is doing, but how easy is it to see the code's intent.\nTo me, an if-else block says the intent of the code is to do different things based on some conditions. The new feature allows one to specify the intent \"this variable (or argument) depends on some condition(s)\" more clearly.\nTo use the example from above, if I see\n  IF (PRESENT(D)) THEN\n    CALL SUB(A,B,C,D)\n  ELSE IF (X<1) THEN\n    CALL SUB(A,B,C,EPSILON(X))\n  ELSE\n    CALL SUB(A,B,C,SPACING(X))\n  END IF\n\nIt's not immediately obvious (especially in codes that are more complicated than this example) that we are definitely going to be calling sub in all cases, and the only difference is the value of the last argument. Whereas with\ncall SUB(A, B, C, IF (PRESENT(D)) THEN (D) ELSE IF (X < 1) THEN (EPSILON(X)) ELSE (SPACING(X) END IF)\n\nthat intent is put front and center without having to compare each branch in an entire if-else block.\nSo, my preferences would be  for\n\nKeyword syntax - most similar to existing Fortran syntax\nPython syntax - still quite likely to be easily understood by new programmers\n? syntax - similar to other languages, but not immediately obvious to new programmers"
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 15:29:52+00:00",
                    "text": "If the idea is to call SUB just once, to make the intent obvious, as @everythingfunctional correctly points out, then here is the alternative to the original:\n  IF (PRESENT(D)) THEN\n    D2 = D\n  ELSE IF (X<1) THEN\n    D2 = EPSILON(X)\n  ELSE\n    D2 = SPACING(X)\n  END IF\n  CALL SUB(A,B,C,D2)\nWhich I personally find more readable than:\nCALL SUB(A, B, C, IF (PRESENT(D) THEN D ELSE IF (X < 1) THEN EPSILON(X) ELSE SPACING(X) END IF)\nBut it is true you have to declare an extra variable (although the performance of the code should be identical with a good compiler)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-05 15:57:14+00:00",
                    "text": "Is a subset of this a good candidate for a stdlib function if_then_else(condition, expression1, expression2)?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 16:55:37+00:00",
                    "text": "Is a subset of this a good candidate for a stdlib function if_then_else(condition, expression1, expression2)?\n\nIt would be, but merge already would be sufficient, and the idea of the proposal is to not evaluate the unused expression (which merge can't do)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 17:01:30+00:00",
                    "text": "@certik , while you've removed the difficulty of seeing \"do we always call SUB in every case\", you've now introduced the ambiguity of \"do we always assign to D2 in every case?\" You're back to the exact same problem. You're using a multi-statement block to perform a single logical operation. A reader must inspect and evaluate every branch (the block as a whole) to understand it is performing a single logical operation."
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 17:05:29+00:00",
                    "text": "My understanding is that this feature was approved by WG5 for inclusion into 202X based on a survey, where people expressed a wish to have conditional expressions in Fortran, but I don't think there were concrete proposals how it would look like, just that the feature would be nice to have. @sblionel is that an accurate statement?\n@everythingfunctional explained well the main argument for conditional expressions is that they enforce a single logical operation to be assigned somewhere (as the result of the conditional expression).\nI agree that at this level of \"requirements\" it seems like a good idea and I am not against that (I use it sometimes in Python, although rarely; I never use the ? notation in C or C++). But when it comes down to syntax and how it would actually look like in Fortran, it seems less readable in practice to many people, and that is would should count. If a feature looks good in abstract terms, but does not look good in concrete (syntax) terms, in my opinion we should not put it in until it looks good both in abstract and concrete terms.\nA prior compiler implementation of this would be very helpful, so that we can play with it more, before putting it into the language."
                },
                {
                    "user": "pbrady",
                    "date": "2020-10-05 17:14:30+00:00",
                    "text": "Adopting ?: for a conditional expression but using a difference syntax from those languages which already use it for the same purpose (i.e. C, C++, Java, Javascript), is a bad idea and will only lead to confusion.  As someone who uses multiple languages, I would appreciate it if Fortran did not do anything weird here and go off the beaten path for no apparent reason."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-05 17:21:13+00:00",
                    "text": "I forgot: why aren't we just fixing MERGE() to guarantee non-evaluation of the operand that isn't selected?"
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 17:32:05+00:00",
                    "text": "@klausler the arguments that have been put forth against fixing merge are:\n\n\nMERGE is elemental. Conditional expressions are not.\n\n\nConditional expressions are a top-level single selection, so we can lift all the dynamic requirements that merge needs\n\n\nMERGE requires TSOURCE and FSOURCE to have the \"same type and type parameters\"\n\n\nI don't personally understand the arguments, but I think @everythingfunctional does? Brad, can you summarize here why we cannot extend merge? If we could just extend merge, that would be the best way forward I think."
                },
                {
                    "user": "sblionel",
                    "date": "2020-10-05 17:36:45+00:00",
                    "text": "My understanding is that this feature was approved by WG5 for inclusion into 202X based on a survey, where people expressed a wish to have conditional expressions in Fortran, but I don't think there were concrete proposals how it would look like, just that the feature would be nice to have. @sblionel is that an accurate statement?\n\nYes. The way we work is that WG5 outlines the general idea and J3 develops that into a specific proposal."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 17:37:13+00:00",
                    "text": "merge is elemental, and as such must evaluate both expressions to determine the shape of the result. The example is, if one argument to merge is a scalar and the other is an array, even if the scalar is the selected value, the array expression must still be evaluated to determine the shape of the result, because the result will still be an array with that shape, just with each value equal to the given scalar. The proposed conditional expressions would not be capable of that, because each expression must have the same rank."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 17:39:10+00:00",
                    "text": "@klausler , I actually proposed just that on the J3 discussion board, but Malcolm was able to give me convincing reasons against, along the lines of my previous comment."
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 17:53:37+00:00",
                    "text": "@everythingfunctional cannot the shape in merge be determined at compile time for both arguments?"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-05 17:53:52+00:00",
                    "text": "But MERGE() could guarantee evaluation of at most one of its first two arguments in the case where the third argument is scalar and the first two arguments have the same rank, yes?"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-05 17:54:30+00:00",
                    "text": "@everythingfunctional cannot the shape in merge be determined at compile time for both arguments?\n\nRank, yes, apart from assumed-rank dummy arguments, but not shape."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-05 18:23:40+00:00",
                    "text": "But MERGE() could guarantee evaluation of at most one of its first two arguments in the case where the third argument is scalar and the first two arguments have the same rank, yes?\n\nI suppose that's true. In fact, one could go a small step further and state that the \"unused\" argument is evaluated only if necessary to determine the resultant shape. I.e., if the array argument is selected, the scalar argument wouldn't need to be evaluated.\nHowever, that still wouldn't satisfy one of the use cases (although it's not one I find particularly compelling); conditionally supplying an optional argument. I think the proposed conditional expressions provide a clean way to provide that, with a convenient place to put the desired deferred evaluation functionality."
                },
                {
                    "user": "certik",
                    "date": "2020-10-05 18:50:57+00:00",
                    "text": "conditionally supplying an optional argument\n\nThis use case should by done by #22, that seems like a cleaner solution anyway.\nSo extending merge and implementing #22, we might be able to cover this feature."
                },
                {
                    "user": "sgeard",
                    "date": "2020-10-05 21:48:38+00:00",
                    "text": "I'd prefer to see something like\nselect\n    case (present(d))\n        call sub(a,b,c,d)\n    case (i<n) then case (a(i)==0)\n        call sub(a,b,c,epsilon(x))\n    case default\n        call sub(a,b,c,spacing(x))\nend select\nOr possibly use switch instead of select"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-06 15:26:18+00:00",
                    "text": "#22 is about providing a default value if an argument is not provided; it is about the callee. This proposal is about how an argument could be provided or not; it is about the caller.\nFor example, say if x < 0.1 I don't want to provide an argument to some procedure, how would merge be sufficient? What would you provide as the other argument? I.e.\ncall sub(a, merge(???, x, x < 0.1))"
                },
                {
                    "user": "certik",
                    "date": "2020-10-06 15:45:15+00:00",
                    "text": "@everythingfunctional how would that be written using conditional expressions? I don't think that's possible either, or am I missing something?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-06 16:19:13+00:00",
                    "text": "The proposal specifically allows for the else part to be omitted in cases of passing to optional arguments. So the example would be (in the case of the keyword syntax)\ncall sub(a, if (x >= 0.1) then (x))"
                },
                {
                    "user": "certik",
                    "date": "2020-10-06 16:27:01+00:00",
                    "text": "I see, I didn't realize that. Btw, I think the syntax is:\ncall sub(a, if (x >= 0.1) then (x) end if)\nor\ncall sub(a, if (x >= 0.1) then x end if)\nBut adding parentheses around x actually makes it more readable to me.\nWell, we can have some kind of syntax or keyword for merge, such as call sub(a, merge(*, x, x < 0.1)) or something like that, but I am not sure I like it."
                },
                {
                    "user": "klausler",
                    "date": "2020-10-06 16:28:31+00:00",
                    "text": "The proposal specifically allows for the else part to be omitted in cases of passing to optional arguments. So the example would be (in the case of the keyword syntax)\ncall sub(a, if (x >= 0.1) then (x))\n\n\nThe syntax (x) is an idiomatic way to turn a variable into an expression.  Will (x) above be a variable?  If so, would one need ((x)) to pass a copy of x as an expression?\nMaybe the concept of a conditionally-passed optional argument and a general conditional expression should be separated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-06 16:33:49+00:00",
                    "text": "Oops, yeah I forgot the end if in my example.\nI believe the parentheses are present in all of the examples in the syntax paper. I think they may be necessary to disambiguate in fixed-form syntax."
                },
                {
                    "user": "certik",
                    "date": "2020-10-06 18:42:21+00:00",
                    "text": "Btw. this:\ncall sub(a, if (x >= 0.1) then (x) end if)\nDoesn't look that bad compared to the original:\nif (x >= 0.1) then\n    call sub(a, x)\nelse\n    call sub(a)\nend if\nI still slightly prefer the original in this case, but perhaps for some more complicated case I would sometimes use the conditional expression."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-10-11 05:38:44+00:00",
                    "text": "Did not have time to read all the comments so this might have been covered but the closest I can think of using current standard Fortran would be\n      CALL SUB(A,B,C,MERGE(D, MERGE(EPSILON(X),SPACING(X),X<1.0), PRESENT(D)))\nIn a hopefully working example that would be\n   program whatif\n   implicit none\n   call testit(0.0)\n   call testit(1000.0,100.0)\n   call testit(10.0)\n   contains\n\n   subroutine testit(x,d)\n   real,intent(in)          :: x\n   real,intent(in),optional :: d\n   real                     :: a,b,c\n\n      CALL SUB(A,B,C,MERGE(D, MERGE(EPSILON(X),SPACING(X),X<1.0), PRESENT(D)))\n\n      write(*,*)a,b,c,merge(d,-99999.0,present(d))\n   end subroutine testit\n\n   end program whatif\n\n   subroutine sub(aa,bb,cc,dd)\n   real,intent(out) :: aa,bb,cc\n   real,intent(in)  :: dd\n      write(*,*)'SUB SEES=',dd\n      aa=dd;bb=2*dd;cc=dd**2\n   end subroutine sub\nResults:\n    SUB SEES=   1.19209290E-07\n      1.19209290E-07   2.38418579E-07   1.42108547E-14  -99999.0000\n    SUB SEES=   100.000000\n      100.000000       200.000000       10000.0000       100.000000\n    SUB SEES=   9.53674316E-07\n      9.53674316E-07   1.90734863E-06   9.09494702E-13  -99999.0000\n\nSo using that as a comparison and looking at the limitations it has\nin the new syntax if the fourth parameter were metamorphic or if the\nroutine was generic with different types allowed for D would all the\nexpressions have to be of the same type or not?\nWould everything always be evaluated or would it short-circuit? One of\nthe issues with the above statement would be if D/2 instead of D were\npassed to SUB() and D was not present evaluating D/2 would be problematic,\nas MERGE is allowed to evaluate all the expressions.\nThat being said I would prefer something less C-like that short-ciruits\nwith something closer to functional syntax like\ncall sub(a,b,c, if(present(d) <= d ;x<1.0 <=epsilon(x); spacing(x)) )\nwhere the semi-colon is intentional and means to short-circuit and where it looks like a function called IF\nthat has expressions of the form condition <= expression to use and the last field which has no condition\nwould be the default and if there were no last expression it would be the same as not present. maybe a name of USE()\ninstead of IF() would be good. The C syntax is one of my least-favorite syntaxs in any language.\nso my preference would be\n\noriginal\nsomething other than either of the proposals\n\nhow about\ncall sub(a,b,c,IF(present(d) USE d; x<1 USE epsilon(x); spacing(x) ) )\nin case the parameter does not have INTENT(IN) this could then be used like\nmyvar=IF(PRESENT(d) USE d; x<1 USE EPSILON(x); SPACING(x) )\ncall sub(a,b,c,myvar)"
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 05:30:17+00:00",
                    "text": "I have implemented a prototype of this into LFortran: https://gitlab.com/lfortran/lfortran/-/merge_requests/645/\nExample notebook: https://nbviewer.jupyter.org/urls/gitlab.com/lfortran/lfortran/-/raw/477cac615ca420377c7582f16294d05461bf7b8d/share/lfortran/nb/Conditional%20Expressions.ipynb\nIt doesn't implement the whole proposal, but it implements enough to be able to play with it."
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 15:14:32+00:00",
                    "text": "Two more syntax forms have been proposed.\nMixed form:\n IF ( logical-expression-1 ) ? expression-1\n[ : ( logical-expression-k ) ? expression-k ] ...\n: ( expression-n ) ENDIF\n\nexamples:\nif (i>0 .and. i<=size(a)) ? a(i) : (present(val)) ? val : 0.0 endif\nCALL SUB(A, B, C, IF (PRESENT(D) ? D : (X < 1) ? EPSILON(X) : SPACING(X) END IF)\nArrow form:\n( predicate -> consequent\n[ : predicate -> consequent ] ...\n: alternative )\n\nExamples:\n( abs(residual)<=tol -> 'ok' : 'did not converge' )\n( i>0 .and. i<=size(a) -> a(i) : present(val) -> val : 0.0 )\nCALL SUB(A, B, C, ( PRESENT(D) -> D : (X < 1) -> EPSILON(X) : SPACING(X) ))"
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 15:24:06+00:00",
                    "text": "Another suggestion is to amend the \"arrow\" form to simply use ? as in C (motivation: if the syntax is so close to C and C++, we should make is exactly the same, to prevent confusion):\nC syntax:\nExamples:\n( abs(residual)<=tol ? 'ok' : 'did not converge' )\n( i>0 .and. i<=size(a) ? a(i) : present(val) ? val : 0.0 )\nCALL SUB(A, B, C, ( PRESENT(D) ? D : (X < 1) ? EPSILON(X) : SPACING(X) ))"
                },
                {
                    "user": "certik",
                    "date": "2020-10-13 16:02:45+00:00",
                    "text": "The committee discussed yesterday why merge will not work, so I want to summarize it here:\n\nmerge has other uses that would not all work for conditional expression usage, the main one is that merge is elemental. The solution could be to use a new \"function\" such as ifthen.\nConsidering ifthen using a function like syntax has the following drawbacks:\n\nharder to do chaining (if/then/elif/elif/...), as you essentially have to have something like ifthen(.., ifthen(.., ifthen()), ..)\npossibly more confusing to users, as ifthen would look like a function, but does not work like a function, as some arguments will not be evaluated. ifthen at this point becomes a new syntax with new semantics that is not function like. We might as well introduce new syntax that does not look like a function call, such as all the alternatives under consideration above."
                },
                {
                    "user": "sgeard",
                    "date": "2020-10-13 16:41:37+00:00",
                    "text": "If the sub-clauses in an if were allowed to return a value - a bit like a lambda function in C++ you could have\ncall sub(a, b, c, if (present(d)) then d; elseif (x > 0.1); x; else; endif)\nPerhaps clearer with different brackets:\ncall sub(a, b, c, if {present(d)} then d; elseif {x > 0.1}; x; else; endif)\nReadability seems to be a problem with all the options so the second is probably preferable."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-26 21:11:07+00:00",
                    "text": "Did anyone considered the python's ternary syntax?\ncall sub(a, b, c, d if (present(d)) else (epsilon(x) if (x > 0.1) else spacing(x)))\ndropping the parenthesis as they aren't needed in this case:\ncall sub(a, b, c, d if present(d) else epsilon(x) if x > 0.1 else spacing(x))\nconditional-expr: consequent IF predicate ELSE (alternative | conditional-expr)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 21:24:19+00:00",
                    "text": "I pretty sure it has at least been mentioned, but I believe there was some resistance by compiler writers to syntax that requires look-ahead (or back-tracking) parsers. It's also not particularly \"Fortranic\"."
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-26 22:32:01+00:00",
                    "text": "I pretty sure it has at least been mentioned, but I believe there was some resistance by compiler writers to syntax that requires look-ahead (or back-tracking) parsers. It's also not particularly \"Fortranic\".\n\nIt was mentioned here by @dev-zero, indeed, but I don't think it got the deserved attention. It's way more \"Fortranic\" than '?' operator (from C family) IMHO, without the boilerplate of the original proposal:\n\nexplicitly typing then\n\nThe then can be omitted if there's only one consequence in if statement, in the current standard it's called logical IF.\nThe python-borrowed syntax allows to extend the logical IF behavior, with a else statement.\n\n\nexplicitly typing end if\n\nThe proposal it's supposed to be a one-liner rather than a block construct so... why?\n\n\n\nI can't say anything about the writers preferences, but I must say in a recent experience I've failed to write this kind of nested pattern in order to parse a simple key-value file xD.\n<conditional-expr> ::= <then-expr> IF <scalar-logical-expr>  ELSE (<else-expr> / <conditional-expr>)"
                },
                {
                    "user": "klausler",
                    "date": "2020-10-26 22:37:09+00:00",
                    "text": "Is XIFLELSE(1.) a \"conditional expression\" involving variables X and L or is it a reference to an external function?"
                },
                {
                    "user": "14NGiestas",
                    "date": "2020-10-26 22:45:44+00:00",
                    "text": "Is XIFLELSE(1.) a \"conditional expression\" involving variables X and L or is it a reference to an external function?\n\nSo you are saying that the fortran tokenizer get rid of all whitespace... hmpf that would be a problem indeed :/\nX IF L ELSE (1.) turns into XIFLELSE(1.) which is ambiguous (I think I figured out where I've failed in my VDF now xD)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-10-26 22:45:52+00:00",
                    "text": "Is XIFLELSE(1.) a \"conditional expression\" involving variables X and L or is it a reference to an external function?\n\nIn my opinion, with fixed-form source having been made obsolescent, at some point we should be allowed to stop worrying about how new features can expressed without significant whitespace. And so, XIFLELSE(1.) is a function call, and X IF L ELSE (1.) is a conditional expression. Unless there's some other reason I'm missing."
                },
                {
                    "user": "certik",
                    "date": "2020-10-27 19:32:35+00:00",
                    "text": "It was discussed at the October 2020 Fortran call that another good use case for this feature would be for array initializers. In Python you can do (I corrected the syntax, thanks to @ivan-pi's comment below):\n[x+1 if x >= 45 else x+5 for x in range(1, N+1)]\nSo in Fortran you could do:\n[ (if (x >= 45) then x+1 else x+5 endif, x = 1, N) ]\nSince conditional expressions are just expressions, this should just work."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-11-05 15:58:21+00:00",
                    "text": "In Python you can do:\n[x+1 for x in range(1,N+1) if x >= 45 else x+5]\n\nThis triggers a SyntaxError in Python. The correct way would be:\n[x + 1 if x > 45 else x+5 for x in range(1,N+1)]\nSo the syntax is\nexpression_if_true if condition else expression_if_false\n\nEdit: following Python if expression syntax, the example from above would be:\nCALL SUB(A, B, C, D IF PRESENT(D) ELSE (EPSILON(X) IF X < 1 ELSE SPACING(X)))\nIt seems fairly nice, you just need to remember the condition is in the middle.\nEdit2: Oops, I just noticed the posts from @14NGiestas above."
                },
                {
                    "user": "certik",
                    "date": "2021-06-23 21:19:05+00:00",
                    "text": "New syntax paper being proposed at the June 2021 J3 Committee meeting:\n\nhttps://j3-fortran.org/doc/year/21/21-157.txt"
                },
                {
                    "user": "klausler",
                    "date": "2021-06-23 21:24:38+00:00",
                    "text": "New syntax paper being proposed at the June 2021 J3 Committee meeting:\n\nhttps://j3-fortran.org/doc/year/21/21-157.txt\n\n\nWhat a mess!  Tell me again how this is supposed to be better than a MERGE() intrinsic with stronger non-evaluation guarantees, please."
                },
                {
                    "user": "certik",
                    "date": "2021-06-23 22:15:43+00:00",
                    "text": "@klausler thanks for the feedback. I personally think we should not do this feature at all (i.e. NO on the 21-157 proposal), as the two syntaxes (keyword and ?) seem worse than not doing this (based on the feedback both online above, as well as in private that I got). We can pursue the merge() idea and see if we can come up with a proposal."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-23 22:22:06+00:00",
                    "text": "@klausler thanks for the feedback. I personally think we should not do this feature at all (i.e. NO on the 21-157 proposal), as the two syntaxes (keyword and ?) seem worse than not doing this (based on the feedback both online above, as well as in private that I got). We can pursue the merge() idea and see if we can come up with a proposal.\n\nI'm sure we've talked about this.  In short, strengthen MERGE() so that when its mask (3rd) argument is scalar, and the TSOURCE&FSOURCE arguments have the same type and rank, it guarantees that exactly one of its TSOURCE/FSOURCE arguments are evaluated, and returns the appropriate value.  Or define a new intrinsic function with these guarantees."
                },
                {
                    "user": "sblionel",
                    "date": "2021-06-23 22:25:18+00:00",
                    "text": "The idea of modifying MERGE was discussed several meetings ago (I can't find which one). I liked the idea, but there were complaints that it would slow down MERGE for everyone and it failed."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-23 22:32:07+00:00",
                    "text": "The idea of modifying MERGE was discussed several meetings ago (I can't find which one). I liked the idea, but there were complaints that it would slow down MERGE for everyone and it failed.\n\nThat's astonishing and credible at the same time."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-23 22:32:33+00:00",
                    "text": "I use MERGE but hate the name, so how about \"CHOOSE\", and it would short-circuit and allow character variables of different lengths as arguments.  I think the short-circuit would be enough, but I would definitely want it to be able to work with optional parameters so it could be used with\nsubroutine a(opt)\ncharacter(len=*),intent(in),optional :: opt\ncharacter(len=:),allocatable :: opt_local\nopt_local=choose(lower(opt_local),'default',present(opt))\n   ...\nso \"lower\" would not be called on an undefined value."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-23 22:43:33+00:00",
                    "text": "I really do mean it to be different than MERGE; it would return the first or second argument, which could be of different size, not elementally using a mask, but just based on whether the third argument is T or F."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-23 22:46:49+00:00",
                    "text": "And I wish MERGE had been called PICK, given that SELECT is taken."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-23 22:47:06+00:00",
                    "text": "Whoops, I accidentally closed this issue by hitting the wrong button.  Fixing now."
                },
                {
                    "user": "certik",
                    "date": "2021-06-24 00:13:37+00:00",
                    "text": "Here is the discussion of a new intrinsic, say, ifthen by the committee: #183 (comment)"
                },
                {
                    "user": "certik",
                    "date": "2021-06-24 00:14:42+00:00",
                    "text": "Finally, here is another paper that we will vote on next Monday:\n\nhttps://j3-fortran.org/doc/year/21/21-159.txt\n\nThis is essentially the \"arrow form\": #183 (comment)\nWhat is your opinion on that one?"
                },
                {
                    "user": "klausler",
                    "date": "2021-06-24 00:41:56+00:00",
                    "text": "Finally, here is another paper that we will vote on next Monday:\n\nhttps://j3-fortran.org/doc/year/21/21-159.txt\n\nThis is essentially the \"arrow form\": #183 (comment)\nWhat is your opinion on that one?\n\nIt still changes the syntax of expressions, so it would affect parsing, AST definitions, &c.; this would be needless work in every implementation over and above the straightforward semantic analysis that a new intrinsic function would cost.  Tokenizing the new \"->' symbol correctly would impose a look-ahead requirement on tokenization of the current \"-\".  And it implies but does not specify the operator precedence of a \"cond-expr\" -- does it replace a current parenthesized expression in the syntax?  Can it be used as a variable?\nI hate it less than the first two (\"IF\" and the \"?\") but not by much.  I don't understand the aversion to using an intrinsic function; they're easy to parse, they nest in obvious ways, and they're more likely to be understood than new operator syntax."
                },
                {
                    "user": "certik",
                    "date": "2021-06-24 02:50:34+00:00",
                    "text": "I don't understand the aversion to using an intrinsic function; they're easy to parse, they nest in obvious ways, and they're more likely to be understood than new operator syntax.\n\nThe only arguments I've heard against an intrinsic function are summarized here: #183 (comment) (harder to do chaining, possibly more confusing due to some arguments not being evaluated)."
                },
                {
                    "user": "veryreverie",
                    "date": "2021-06-24 10:59:55+00:00",
                    "text": "Would this proposal be limited to use in function calls? And to one-line if statements?\nI'd like to suggest a slight frame-change, and propose allowing if statements which return values, e.g.\ny = if (x>0) then\n  x\nelse\n  0\nendif\n\nIf this syntax was included, then it gives you the power of \"conditional arguments\", and more besides. Like a lot of these proposals, this doesn't give you something you couldn't already do, but I feel like this is both clearer and more powerful than the existing alternatives, and as previously mentioned can be chained with other things like array initialisation.\nI don't believe this would conflict with existing syntax, in that I don't believe you can currently have statements with return values on their own (e.g. the line x on its own is not allowed).\nI guess you'd need to decide what to do if when there was no return value because there was no else clause. e.g. in y = if (x<0) then x endif if x>0. Personally I'd favour leaving y however it was before, probably with a compiler warning to suggest adding an else if y is not allocatable or an optional argument.\nI suppose also if if statements with return values were allowed, then for consistency the various select case, select type etc. statements should also be allowed to have return values.\nFor language consistency reasons, I'm against the other syntax options (as much as I personally like the pythonic syntax in python). I can see the arguments for dropping the then and endif parts of the one-line if statement,  but I think that if they're required in regular one-line if statements then they should also be required in one-line if statements with return values. I also think the proposed ifthen(x,y,z) function is not ideal, but better than nothing.\nFor clarity, my ranking of the proposed syntaxes is:\n\nif statements with return values.\nThe f(a, b, if (x) then y else z endif) syntax.\nSome kind of ifthen function.\nThe original syntax.\n[ Big gap ]\neverything else."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-24 15:03:25+00:00",
                    "text": "So you want Fortran parsers to be able to handle statements as parts of expressions, and add a new kind of expression-only statement.  What happens if one of your \"then\" or \"else\" parts is \"returning\" the value of a variable named ELSE?  or END?"
                },
                {
                    "user": "nshaffer",
                    "date": "2021-06-24 18:48:00+00:00",
                    "text": "I think all the proposed syntaxes are OK (just OK) for simple conditional expressions, but that they become very hard to read for compound conditional expressions. I can only speak for myself, but every example I read with compound conditional expressions I have to mentally step through branch-by-branch to make sure I understand what it's doing. Basically, in reading\ncall sub(a, b, c, ? (present(d) d :? (x < 1) epsilon(x) : spacing(x) ?)\n\nI mentally reconstruct\nblock \n  real :: d_\n  if (present(d)) then\n    d_ = d\n  else if (x<1) then\n    d_ = epsilon(x)\n  else\n    d_ = spacing(x)\n  end if\n  call sub(a,b,c,d_)\nend block\n\nIf I'm reading someone else's code, I'd much rather see the second form than the first (or any of it's proposed variations). Yes, it's verbose, but it's also obvious.\nI'm more partial to a function-like syntax, i.e., ifthen mentioned upthread (or whatever name). The fact that it's clumsy to chain was cited as a con, but to me it is a pro. It should be awkward to write hard-to-read code."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-06-24 18:57:12+00:00",
                    "text": "We started a poll to collect feedback on this feature. We\u2019ll present the results of the poll to the Committee on Monday when the proposals for this feature are due for discussion and a vote."
                },
                {
                    "user": "veryreverie",
                    "date": "2021-06-24 19:13:55+00:00",
                    "text": "So you want Fortran parsers to be able to handle statements as parts of expressions, and add a new kind of expression-only statement.\n\nIdeally, yes. I think it would add benefits to the language.\n\nWhat happens if one of your \"then\" or \"else\" parts is \"returning\" the value of a variable named ELSE? or END?\n\nI'm surprised these are not already reserved words. I guess a possible solution would be to require brackets or similar, so that the syntax would be\ny = if (x>0) then\n  (x)\nelse\n  (0)\nendif\n\nand with an interesting choice of variable names,\nif = if (end>else) then\n  (end)\nelse\n  (else)\nendif\n\nI guess this would also help with syntax parsing."
                },
                {
                    "user": "Beliavsky",
                    "date": "2021-06-24 19:42:44+00:00",
                    "text": "I support the function syntax. My suggested name for ifthen is lazy_merge, which would emphasize that this function behaves differently from other Fortran functions, where all arguments are evaluated. Lazy_pick or lazy_choose are also possible names."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-24 19:53:49+00:00",
                    "text": "This is not the same thing as lazy evaluation as the term is commonly understood in programming language theory."
                },
                {
                    "user": "certik",
                    "date": "2021-06-26 21:09:47+00:00",
                    "text": "@klausler here is a draft of a paper for the intrinsic approach: #213, can you please help me finish it, so that I can submit it to the committee as an alternative?"
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-26 22:54:39+00:00",
                    "text": "It is a lot easier to do in an interpreted language, and some might not like the reuse of IF but in a little scripting language I have where everything is a function IF acts like a function if given more than one parameter and only evaluates one of the following expressions depending on the results of the conditional, in the form  if(expression,eval_if_true, eval_if_false).  I have used it so long it seems natural to me. Trying to put that into a Fortran context it might look like\n program testit\ncontains\n   call passto(20)\n   call passto()\n\nsubroutine passto(a)\ninteger,optional :: a\ninteger          :: b\n   b=if(present(a),a,10)\n   write(*,*)b\nend subroutine passto\n\nend program testit\nI can think of some reasons that might be disliked, but I have seen a lot of comments about the complexity of some of the solutions and I have used that for a long time and it is pretty easy to type even interactively. The language also lets logicals return an integer and a lot of other un-Fortranish things so things like like doing a sum() of a bunch of expressions and being able to do something if 2 out of 3 are true is easy, or doing a max() or min() on a list of logical expressions makes sense; but now that there is ANY() and ALL() Fortran can do something similiar now. Of course only evaluating one of the expressions is easy in a scripting language and very much against standard Fortran behavior."
                }
            ]
        },
        {
            "number": 182,
            "user": "zjibben",
            "date": "2020-09-21 23:22:01+00:00",
            "title": "Add revised protected components & types proposal",
            "text": "Here is a revised version of the protected components proposal (#156). The next committee meeting is 3 weeks away (Oct 12) so I wanted to make sure we had time to discuss beforehand.\nTo recap, last time it became clear there were competing interests. I and others here and at LANL wanted an access specifier roughly in between private and public. Other committee members want something far more restrictive, something really unlike an access specifier and more analogous to the existing protected attribute for module data. This would act to really protect the data from virtually any modifications outside the module where the type was defined, and was far too restrictive to be useful for those of us who wanted an access specifier.\nThe best way forward seemed to be to tease apart these separate needs and provide tools to manage both. That way we all get what we want. This paper has specifications & syntax for protected components and protected types based on our withdrawn 20-121. If we're happy with it, I can either submit it as a paper or as a work item for the DATA subgroup.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "zjibben",
                    "date": "2020-09-21 23:22:27+00:00",
                    "text": "@aradi"
                },
                {
                    "user": "zjibben",
                    "date": "2020-09-24 18:13:47+00:00",
                    "text": "Thanks @aradi!\n\nThe protected type, which seems to be a monster with many-many implications and side-effects.\nI fear, that it would put the first one on hold due to numerous discussions on and problems with the second one.\n\nThis is definitely a valid concern. For our part, I wouldn't be proposing that monster feature at all (I don't see it as extremely useful personally). But when presented with protected components, the committee really wanted something extremely strong, and had lots of work towards that already. These specs derive from the work on those very restrictive protected components. It looks like if we want our more lightweight protected components, we need something strict to go with it. But we'll see as discussions develop, maybe seeing both alongside each other the committee will be willing to drop the heavy one. Hopefully the committee doesn't decide they don't see the value in our lighter protected components, deciding to go ahead with heavy-only, or decide the whole combination is more than they wanted and kill the whole concept.\n\nI'd suggest to keep the term protected for expressing read-only behaviour (of the derived type components), and use something else for defining persistent/undestroyable types (e.g. persistent).\n\nI like this, and have struggled to come up with an alternative name for \"protected type\". persistent is a good option, as it really just disables intrinsic assignment, allocation, deallocation, and automatic finalization. I'll include that along with the other name alternatives I now have at the end. I think naming will be a big point of discussion."
                },
                {
                    "user": "zjibben",
                    "date": "2020-09-24 18:43:18+00:00",
                    "text": "@certik thanks for the suggestion. I added a section on use-cases, which naturally was very detailed on what we want to see in protected components, but lighter for protected types. I tried to faithfully relay the motivation described to me by Van, and I think it ended up being similar to described by Malcolm in 19-135r1."
                },
                {
                    "user": "zjibben",
                    "date": "2021-06-15 22:19:48+00:00",
                    "text": "Tagging a few others who might be interested: @FortranFan @milancurcic @gklimowicz @tclune @vansnyder\nI think we got this into pretty good shape during our discussion in September, but I've added a bit more clarifying discussion. I'm planning to show this to the committee for our meeting next week. I think this approach offers enough flexibility to satisfy everyone, but we'll see how it goes."
                },
                {
                    "user": "vansnyder",
                    "date": "2021-06-15 23:55:24+00:00",
                    "text": "On Tue, 2021-06-15 at 15:20 -0700, Zach Jibben wrote:\n Tagging a few others who might be interested: @FortranFan\n @milancurcic @gklimowicz @tclune @vansnyder\n\n I think we got this into pretty good shape during our discussion in\n September, but I've added a bit more clarifying discussion. I'm\n planning to show this to the committee for our meeting next week. I\n think this approach offers enough flexibility to satisfy everyone,\n but we'll see how it goes.\n\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\nZach mentions that \"persistent\" types disable intrinsic assignment,\nallocation, deallocation, and automatic finalization.\n\nI assume this disabling does not apply in the scoping unit where the\ntype is defined.\n\nIn Ada '83, the \"limited\" attribute for a type did this. I don't\nremember in which level of requirements this was first introduced. It\nwas definitely in \"Steelman.\" I first proposed it in 97-114."
                },
                {
                    "user": "zjibben",
                    "date": "2021-06-16 00:37:37+00:00",
                    "text": "Hi Van, thanks for looking at this!\n\nI assume this disabling does not apply in the scoping unit where the type is defined.\n\nThis is correct, specification L3 allows for intrinsic assignment inside the module which defines the protected type."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-06-16 01:50:50+00:00",
                    "text": "@zjibben wrote 15 June 2021, 6:19 PM EDT:\n\nI've added a bit more clarifying discussion. I'm planning to show this to the committee for our meeting next week. I think this approach offers enough flexibility to satisfy everyone, but we'll see how it goes.\n\nGreat paper, Zach.  I read your revised version closely just now and you've covered everything that I can think of, especially with formal specifications toward the protected components feature that is of particular importance in many codes in my experience.\nMy only change will be on line 113: 'inadvertently'.\nI feel strongly this will be an excellent addition to Fortran 202X.  The discussion at the plenary on this paper will be of great interest, hope no technical surprises arise then."
                },
                {
                    "user": "aradi",
                    "date": "2021-06-16 07:38:56+00:00",
                    "text": "Good luck! Let's hope, this time the proposal gets further as last time."
                },
                {
                    "user": "zjibben",
                    "date": "2021-06-18 23:45:37+00:00",
                    "text": "Thank you everyone! The paper has been submitted: https://j3-fortran.org/doc/year/21/21-148.txt"
                }
            ]
        },
        {
            "number": 181,
            "user": "klausler",
            "date": "2020-09-14 23:05:36+00:00",
            "title": "Fortran should consider scrubbing unimplemented F'2003 features",
            "text": "For usage that conforms to the standard as of (say) Fortran 2003 but has not yet been implemented in any of the five or six major Fortran compilers, the standard should consider removing or deprecating the feature.  I contend that something that exists only in the standard after 17 years but isn't yet working correctly in any implementation or (one assumes) any production application is not really part of the language, and would not be missed if it were to be removed.\nI have several particular examples along these lines, but I would like to discuss the merits of the general principle first.  It's too easy otherwise to be distracted by \"well, I could think of a use for that\" when it comes to specific cases -- and as I describe below, there would be a means for retaining features that deserve to remain.\nMy selfish motivation, as an implementor, is a desire to avoid the wasted time and expense of supporting features that nobody will use if I do or miss if I don't.  But there might also be some benefit to users from overall simplification of the language.\nSo my specific proposal is this: Fortran 202x would contain a list of \"Possible Future Deprecations\" that enumerates usage from F'2003 and earlier that is demonstrably not implemented.  Each item would contain a minimal test program that conforms to the standard but is not capable of running anywhere.  Any item in that list that remains unimplemented as of Fortran 202Y would then become deprecated in that later standard.  This would provide a window in which pet unimplemented features could be saved from deletion by any implementor willing to demonstrate them in the meantime, or any user willing and able to force at least one vendor to do so.  And a similar list would appear in Fortran 202Y of F'2008 features not yet implemented by any compiler in its time frame.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-14 23:21:41+00:00",
                    "text": "As a general principle this seems fine to me and consistent with another principle that I would like the committee to eventually adopt: only standardize things that have a prior compiler implementation (preferably two).\nI would be curious to see the actual cases you found."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-15 02:25:23+00:00",
                    "text": "There are two items in F2003 that were controversial at the time and remain controversial: parameterized derived types (PDTs), and user defined derived type I/O (UDDTIO). Both were added at the urging of single national bodies:The British for PDTs, and Germany for UDDTIO. Great Britain had two members who were focussed on language orthogonality, and thought that if the intrinsic types could specify length and kind, then so should derived types and put in a lot of effort designing this feature. They persuaded much of the rest of the UK committee to their opinion. Germany had one active member who said he would veto the standard unless it had UDDTIO, and then after it was added vetoed the F2003 standard as too complex.\nI won't speak to UDDTIO, but I have experimented a little with PDTs for bitsets. As of gfortran 10.2 PDTs for my purposes were broken. ifort was in better shape, but the restrictions on how PDTs could be used made them impractical for bitsets. Maybe Cray's compiler is in better shape.\nAs to requiring compiler implementations before adoption, good luck with that. A small part of F90 was the adoption of MIL-STD 1753, which made some common compiler extension a requirement for military compilers. Substantial parts of F77, the rest of F90, almost all of F95, and essentially all of F03 lacked prior compiler implementation. The only parts of F95 which may have had compiler implementations were FORALL, which was a failure, and the bug fixes to allocatable, which were obvious and had a TS report. F)8 and F18 did have some partial compiler experience with co-arrays, but most of the rest of the additions were a blank slate.\nThere are good reasons for that. Steve Lionel has commented elsewhere on how DEC got burned adopting an early version of PARAMETER, and now its successor, INTEL, refuses to adopt non-standardized extensions. The other commercial compilers have the same attitude. gfortran follows the piecemeal interests of its developers. FLANG/F18 has limited funding. LFortran is in a very preliminary state. Currently adopting an extension faces the following hurdles:\n\nDeveloping an extension to a language as complicated as F18 is complicated. The preliminary work required before implementation is daunting. It is difficult to justify that investment in time and money unless you are certain your users will adopt that extension. Even then it may be difficult to justify the investment.\nThe standard bodies do all of that preliminary work for \"free\", but by the time a feature has been polished enough to be implementable most of the rest of a standard (or TS report) has been finished.\nUsers are reluctant to adopt a feature unless it has been standardized."
                },
                {
                    "user": "certik",
                    "date": "2020-09-15 06:23:47+00:00",
                    "text": "Thanks @wclodius2 for the historical background.\nRegarding prior implementation, the way it would most probably work is that it gets implemented in Flang/LFortran on a branch, but not merged into master. That way there is no maintenance cost for the compiler developers. People and the committee can play with the feature in the branch which would allow to answer the questions \"how difficult is to implement the proposal\" and \"is it actually useful as we are hoping\". Then we can talk about standardizing and a possible wider adoption of a given feature."
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-09-15 07:31:12+00:00",
                    "text": "There are two items in F2003 that were controversial at the time and remain controversial: parameterized derived types (PDTs), and user defined derived type I/O (UDDTIO).\n\nAt the risk of taking this thread off-track...\nIt may have been controversial, but at this point UDDTIO has been implemented in compilers (gfortran has supported it since v7.0). Personally, that always struck me as a useful feature and one that fit in well with other the ability to overload other operators. I was under the impression that there were some compilers to have implemented PDTs, although I agree that as they currently exist they are not practical for anything."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-15 13:41:14+00:00",
                    "text": "Several compilers claim to have implemented PDTs, http://fortranwiki.org/fortran/show/Fortran+2003+status <http://fortranwiki.org/fortran/show/Fortran+2003+status> including gfortran. I have only tested gfortran and Ifort.  in gfortrn PDTs in combination with abstract types are broken. Ifort seemed to be working, at least it gave understandable error messages that indicated that what I wanted to do with PDTs was not allowed by the standard,"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-15 17:17:07+00:00",
                    "text": "There's a useful distinction that can be made between the KIND and LEN genres of derived type parameters.  KIND derived type parameters are straightforward to implement and are broadly supported.  LEN derived type parameters are widely claimed to be supported, but it's not hard to write test cases using them that conform to the standard but can't be compiled by anybody."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-15 18:41:16+00:00",
                    "text": "I see that there's at least one downvote on the proposal; are you against deprecating and removing unimplemented features, or is your problem with the suggested process?"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-15 19:31:39+00:00",
                    "text": "I personally will be completely opposed to this.\nOne simply cannot allow the baby to thrown out with the bathwater.\nTo me, every indication is all the features in the Fortran 2003 standard made it into the language standard following all the usual tugs and pulls of a lengthy process that had strong elements of consensus with voting and give and take and collaboration, however questionable might have been certain aspects of the process.  I personally would do everything to respect the output of this long, drawn out effort that took a lot of contemplation and deliberation.  To debug (yes, a standard can have bugs too), to refine, to enhance, and to build upon the concepts and features, sure.  But to remove something in the standard starting 2003 revision, a no-no for me.  This will hold true for me for anything with 2008, 2018, and 202X revisions as well.\nAnother consideration is besides certain specific aspects of PDTs (gfortran being the exception here with a false start perhaps to its PDT implementation effort and a continued pause thereafter leading to a broken state) and perhaps miscellaneous aspects such as support for additional CHARACTER kinds e.g., toward ISO 10646 character set (which is kinda optional to processors any way), there are quite a few compilers providing rather comprehensive support for Fortran 2003.  One can credibly argue the missing aspects are either bugs due to a load of other issues (including perhaps the 'denseness' of the standardese, especially for those compiler writers who grew up outside the british 'commonwealth' locales) and a lack of a standard acceptance testing and QA/validation library or subtleties and intricacies requiring close attention that has not been demanded yet of these implementations by their customers.  With PDTs and Intel Fortran, that clearly was the case but I've been feeding them tons of test cases and they have been able to get their compiler fixed each time.\nBut now with PDTs, as I explain here, it is rather convenient and useful in design of good scientific software.  There are some use cases, particularly in the industry domain where I work, that are particularly well-suited for PDTs.  Perhaps in 20+ years if the standard with 202y and its processor implementations have sufficiently full-featured generics capabilities, PDTs may become superfluous.\nIn the meantime, considering Intel Fortran is nearly there with this feature in their attempt to serve customers like me (or more like an evangelist at this stage), deprecation of PDTs will be unconscionable.\nAdditionally, defined IO (aka UDDTIO) is a facility that is mostly a solved problem, it is implemented reasonably well in several compilers including gfortran, it is a nice-to-have feature that has proved convenient, particularly with serialization and deserialization of 'objects' in Fortran including with its NAMELIST aspect, something that helps boosts Fortran's image somewhat in terms of modernity.  There cannot be raison d'etre to deprecate this now either."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-15 19:58:43+00:00",
                    "text": "The proposal would not deprecate any feature that has even a single working implementation of that particular feature.  The features that you're defending are working in at least one compiler and are not going to go anywhere.  Instead, I'm thinking about features that remain unimplemented after nearly two decades.  What should be done with them?"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-15 20:19:42+00:00",
                    "text": "The proposal is too vague. If asked what aspects of F03 are unimplemented, my gut feeling would have been PDTs with LEN parameters, but according to FortranFan they have been implemented well enough in ifort to satisfy him. UDDTIO and UCS-4 have several implementations. What unimplemented aspects of F03 are you thinking of?"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-15 20:53:12+00:00",
                    "text": "I was hoping to be able to move from general principles to specific cases, not the other way around, since the problem of unimplemented features of long standing is a general one.  But if you need a specific case to consider as an example, take the feature of general non-deferred type parameter expressions in POINTER and ALLOCATABLE components:\n  TYPE :: T(N)\n    INTEGER, LEN :: N\n    TYPE(T(N+1)), POINTER :: P\n  END TYPE\n\nI don't know of a compiler that can cope with a non-constant and non-deferred type parameter expression in a POINTER or ALLOCATABLE component declaration.  It may be an oversight that they are allowed -- any bounds of POINTER and ALLOCATABLE component arrays are required to be deferred.  If their type parameter values were also required to be deferred, they'd obtain their values from assignments and ALLOCATE statements like bounds do.  So the general type expression, if it worked, would serve as a default to be used on ALLOCATE."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-15 22:27:13+00:00",
                    "text": "Subclause 4.3 of Fortran 2018 has a long list of features from earlier standards (F'77 through F'2008) that were deleted or modified in the latest standard, so there's some precedent for removing things that turned out to be problematic.  For example, a sequence type was allowed to have type parameters in F'2003 but not today.  Were these deletions and modifications controversial?  (Some of the F'77 behavior that's changed must have engendered some discussion about backward compatibility, I imagine.)  Is there a process by which problematic features in the language can be placed on these lists?"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-16 14:39:03+00:00",
                    "text": "Is there a process by which problematic features in the language can be placed on these lists?\nOne way is an interpretation request. If the request leads to the conclusion that a feature of the language is unimplementable, leads to a contradiction with other parts of the standard, or is otherwise undesirable then it may be removed. That being said an interpretation request against an F03 feature in 2020 feels odd to me. It would have been better done ten or fifteen years ago."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-16 18:43:11+00:00",
                    "text": "Is there a process by which problematic features in the language can be placed on these lists?\nOne way is an interpretation request. If the request leads to the conclusion that a feature of the language is unimplementable, leads to a contradiction with other parts of the standard, or is otherwise undesirable then it may be removed. That being said an interpretation request against an F03 feature in 2020 feels odd to me. It would have been better done ten or fifteen years ago.\n\nMaybe it would be better to address the root cause of unimplemented &/or unimplementable features getting into the standard in the first place, I guess, as Ondrej mentioned earlier."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-19 21:27:04+00:00",
                    "text": "@klausler wrote Sep 15, 2020 6:27 PM EDT:\n\nSubclause 4.3 of Fortran 2018 has a long list of features from earlier standards (F'77 through F'2008) that were deleted or modified in the latest standard, so there's some precedent for removing things that turned out to be problematic. ..\n\nExactly.  So as @wclodius2 mentioned, the process is in place for changes in a published standard with the committee, mostly via Interp requests.  What this appears to lead to, as you all know, is targeted refinements, corrections, specific sub-item removals, etc.\nGiven this, I don't understand the original proposal, especially with its reference to Fortran 2003 features and the \"not implemented\" aspect as determined by a processor failing an arbitrary test and the implications thereafter, whether it's wholesale deprecation of the facility.\nIf the matter is something specific such as non-deferred type parameters of components of POINTER/ALLOCATABLE attribute in a derived type, is this new proposal necessary?  Can it not suffice to use the process that led to the current standard having an incompatibility with the original F2003 such as \"Fortran 2003 permitted a sequence type to have type parameters; that is not permitted by this document\", \"Fortran 2003 permitted a statement function to be of parameterized derived type; this document does not permit that.\", etc.\nHow about starting with an Interp request first on this non-deferred type parameter issue?"
                }
            ]
        },
        {
            "number": 180,
            "user": "sblionel",
            "date": "2020-09-11 00:21:19+00:00",
            "title": "Intrinsics to return information on procedure name, source file name and line number",
            "text": "Many times in my career I saw users asking for a way to obtain the current procedure name, source file name and/or source file line number, for use in logging and error messages. Some compilers offer preprocessor macros for this, but it is not standardized and macros that result in a string are hard to use in Fortran.\nIntrinsic module ISO_FORTRAN_ENV already has two intrinsic functions COMPILER_OPTIONS and COMPILER_VERSION that return strings known to the compiler. I propose adding three more - the names I show here are for discussion purposes and different names might be desirable.\nPROCEDURE_NAME() returns a string that is the function-name or subroutine-name of the enclosing function or subroutine, upcased. (Case as it appears in the source file would be another choice.) A constraint would be that this can appear only in a subroutine or function. (If the procedure is in a module, does the module name also appear somehow? I think not.)\nSOURCE_FILE_NAME() returns an implementation-dependent string that represents the name of the source file in which the call appears. This can get tricky - full path? What about sources that have no name or include files?\nSOURCE_LINE_NUMBER() returns an integer representing the line number of the source file in which the call appears. Is it OK if it's just relative to the actual file (could be an include file)? Interaction with preprocessors (they have pragmas that can set the original line number.)\nAll of these would be valid in constant expressions.",
            "is_open": true,
            "labels": [
                "Fortran 202y",
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "cmacmackin",
                    "date": "2020-09-11 00:42:51+00:00",
                    "text": "Taking this a step further, we could also consider a functions which would return this sort of information for the entire callstack. Obviously that would not be safe to use in a constant expression. Many of the same questions apply, of course. Presumably the easiest thing to do would be return mangled procedure names generated during compilation, although I wouldn't imagine it would be too difficult to have an option for the compiler unmangle them. Personally, I'd like it if there were a way to see module names as part of the procedure name (e.g., MODULE_NAME[::SUBMODULE_NAME]::PROCEDURE_NAME)."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-11 14:04:27+00:00",
                    "text": "I think this will be very useful for Fortran practitioners.\nAs I inquired in the comp.lang.fortran thread where too this was mentioned, what technical concerns and possible objections can compiler writers and commercial vendors have with this?\nIn other words, in what way can this not be a no-brainer i.e., a just do it item?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-09-11 14:13:58+00:00",
                    "text": "These would be very useful. I often use the macros FILE and LINE (with preprocessor) to get these info."
                },
                {
                    "user": "certik",
                    "date": "2020-09-11 14:39:29+00:00",
                    "text": "I think these would be useful, thank you for proposing this @sblionel.\nOne objection from the committee that I can see coming is that the standard tries to describe Fortran in a way that is independent of the filesystem and filenames. I personally do not think that should be a problem, but it is one objection that might be raised against the SOURCE_FILE_NAME function."
                },
                {
                    "user": "sblionel",
                    "date": "2020-09-11 14:46:43+00:00",
                    "text": "I would not be in favor of extending this to a run-time stack trace. Generally, procedure names are not kept around after compilation, and some implementations may not have a way of retrieving names of callers.\nI can't think of any technical objection as this information is always available in the compilation phase where these would be processed. It would not require implementors to keep anything additional.\n@certik , this could be handled similarly to INCLUDE - there would be something like \"a processor-dependent string that represents the origin of the source text\". The wording for INCLUDE has \"An example of a possible valid interpretation is that char-literal-constant is the name of a file that contains the source text to be included.\" You're right that this needs to be carefully worded as to not imply a particular implementation. Indeed, some sources come from stdin or pipes. Maybe SOURCE_NAME would be a better choice. Certainly, a topic for discussion."
                },
                {
                    "user": "ashe2",
                    "date": "2020-09-11 16:17:00+00:00",
                    "text": "I think this will be very useful for Fortran practitioners.\nAs I inquired in the comp.lang.fortran thread where too this was mentioned, what technical concerns and possible objections can compiler writers and commercial vendors have with this?\nIn other words, in what way can this not be a no-brainer i.e., a just do it item?\n\nThe best way to show this is a no-brainer would be for someone to implement it in one of the open source compilers. Assuming that shows it is well-defined, straight-forward to implement, and useful, that would encourage the committee to standardize it and other implementors to implement it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-11 16:19:32+00:00",
                    "text": "@valtterib I agree and it is going to happen soon. I think @klausler and others might be very close to start implementing such prototypes in Flang, and we need few more months with LFortran to be able to do that also."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-11 16:41:54+00:00",
                    "text": "We already have __FILE__ and __LINE__ in the preprocessors available in all serious compilers."
                },
                {
                    "user": "sblionel",
                    "date": "2020-09-11 20:31:42+00:00",
                    "text": "As @klausler says, compilers already know how to do this from preprocessor macros. I don't think implementors need to be convinced that it's doable. Truly, the hard part is getting the words right in the standard. Some work is needed in a compiler to recognize an intrinsic module function as valid in a constant expression, but there is already precedent for that and compilers have their own ways of handling it."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-11 20:45:46+00:00",
                    "text": "But people can use __FILE__ and __LINE__ today.  What's the ROI on defining new intrinsic functions in the 202Y standard, implementing and testing them in multiple compilers, and shaking out the bugs and incompatibilities, just to get the same facilities with a different redundant spelling to users sometime in the 2030s?  Everyone would be better off if you just blessed the existing common preprocessor features already in use today."
                },
                {
                    "user": "sblionel",
                    "date": "2020-09-11 20:49:05+00:00",
                    "text": "They're not standard and some compilers don't support preprocessor macros by default.\nThis proposal was triggered by a request on c.l.f for a way to retrieve the current procedure name - I threw in source file and line number as obvious parallels that were requests I had seen before. Also note my comment about how hard it is to use string macros as character literals."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-11 21:07:04+00:00",
                    "text": "What's the problem with using __FILE__ as a character literal?"
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-11 21:10:52+00:00",
                    "text": "I think another point is that the value of __FILE__ and __LINE__  found in some output file may not be \"in sync\" with the current source codes. Although the same can be true for procedure names (i.e., new source codes may have different routine names), it is still much more informative to have procedure names rather than line numbers (which can even vary depending on newly added comments etc)."
                },
                {
                    "user": "tskeith",
                    "date": "2020-09-11 21:15:52+00:00",
                    "text": "I think the value of something like PROCEDURE_NAME() is limited if you can't uniquely identify the subprogram with it. That means you need some kind of fully-qualified name (at least optionally), or a way to get the names of the enclosing module, submodule, and host subprogram (if any)."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-11 21:18:11+00:00",
                    "text": "I think another point is that the value of __FILE__ and __LINE__ found in some output file may not be \"in sync\" with the current source codes. Although the same can be true for procedure names (i.e., new source codes may have different routine names), it is still much more informative to have procedure names rather than line numbers (which can even vary depending on newly added comments etc).\n\n__FILE__ and __LINE__ are, or should be, a pair of features that are not packaged with truly new capabilities that can extract the names of the containing program unit, its hosts, and its ancestor module.  Those names can't be known at preprocessing time, and will eventually have to reflect the values of module parameters, once we have them in the language."
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-11 21:27:11+00:00",
                    "text": "FWIW, this is my (pretty old) post in comp.lang.fortran when I got stuck with printing\n__LINE__ in (custom) stop and assert macros.\nhttps://groups.google.com/d/msg/comp.lang.fortran/KFB_mlmrNNg/jtggiPY7BgAJ\nMy last post there is like: \"I would like to have more robust preprocessing features\".\nRE additional information about module, submodule, and host subprogram (i.e., enclosing\nscopes), it seems that __PRETTY_FUNCTION__ and __MODULE__ etc do a nice job\nin other languages.\n(FWIW, I've posted a bit related example here)\nhttps://groups.google.com/forum/#!msg/comp.lang.fortran/HXdFCDagavs/7PDHF8T7AwAJ"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-11 21:48:07+00:00",
                    "text": "FWIW, this is my (pretty old) post in comp.lang.fortran when I got stuck with printing\n__LINE__ in (custom) stop and assert macros.\nhttps://groups.google.com/d/msg/comp.lang.fortran/KFB_mlmrNNg/jtggiPY7BgAJ\nMy last post there is like: \"I would like to have more robust preprocessing features\".\nRE additional information about module, submodule, and host subprogram (i.e., enclosing\nscopes), it seems that __PRETTY_FUNCTION__ and __MODULE__ etc do a nice job\nin other languages.\n(FWIW, I've posted a bit related example here)\nhttps://groups.google.com/forum/#!msg/comp.lang.fortran/HXdFCDagavs/7PDHF8T7AwAJ\n\nLooking at your comp.lang.fortran thread, I'm disappointed that stringizing doesn't work with gfortran:\n#define TO_STR(x) #x\n#define ASSERT(x) if (.not.(x)) error stop \"ASSERT(\"//#x//\") failed at \"//__FILE__//\" line \"//TO_STR(__LINE__)"
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2020-09-16 09:02:33+00:00",
                    "text": "#180 (comment)\n\nI would not be in favor of extending this to a run-time stack trace. Generally, procedure names are not kept around after compilation, and some implementations may not have a way of retrieving names of callers.\n\nsubroutine essy00_UnpackEnumValue (Object, ...)\n..\n!\n  call glob_subSetProcedures (\"essy00_UnpackEnumValue\") ! this call does set the stack trace to this current subroutine\n!\n..  \n!\n  call glob_subResetProcedures  ! this call does reset the stack trace to the calling subroutine or function\nend subroutine essy00_UnpackEnumValue\nIn my own codes I am using this technique in each and every subroutine/function to feed an user-defined stack trace. (I am using a simple naming convention, using a unique source file prefix, to make the procedure names unique as well). An user-defined error handler then uses the information from the stack trace to get current, calling, and returning procedure names for its error messages. \nWith the coarray runtime, an user-defined stack trace and error handler will provide tracing information and error messages through coarrays for remote access. All this is important because we should not expect to be able to debug sophisticated coarray codes as we could with sequential codes. \nSo yes, this proposal here could definitely help to avoid mistakes with hand coding the procedure names as arguments with my calls to the user-defined stack trace's glob_subSetProcedure subroutine. \ncheers"
                },
                {
                    "user": "certik",
                    "date": "2020-09-16 13:21:04+00:00",
                    "text": "I agree that stacktraces are important, but I think it should be the job of the compiler to give you those, you shouldn't need to store such subroutine information yourself.\n\u2026\nOn Wed, Sep 16, 2020, at 3:02 AM, Michael Siehl wrote:\n\n\n #180 (comment)\n <#180 (comment)>\n\n > I would not be in favor of extending this to a run-time stack trace. Generally, procedure names are not kept around after compilation, and some implementations may not have a way of retrieving names of callers.\n\n subroutine essy00_UnpackEnumValue (Object, ...)\n ..\n !\n   call glob_subSetProcedures (\"essy00_UnpackEnumValue\") ! this call\n does set the stack trace to this current subroutine\n !\n ..\n !\n   call OOOGglob_subResetProcedures  ! this call does reset the stack\n trace to the calling subroutine or function\n end subroutine OOOPessy00_UnpackEnumValue\n In my own codes I am using this technique in each and every\n subroutine/function to feed an user-defined stack trace. (I am using a\n simple naming convention, using a unique source file prefix, to make\n the procedure names unique as well). An user-defined error handler then\n uses the information from the stack trace to get current, calling, and\n returning procedure names for its error messages.\n\n With the coarray runtime, an user-defined stack trace and error handler\n will provide tracing information and error messages through coarrays\n for remote access. All this is important because we should not expect\n to be able to debug sophisticated coarray codes as we could with\n sequential codes.\n\n So yes, this proposal here could definitely help to avoid mistakes with\n hand coding the procedure names as arguments with my calls to the\n user-defined stack trace's glob_subSetProcedure subroutine.\n\n cheers\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#180 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWDHY7WJZBLYUJGBGG3SGB5LTANCNFSM4RGFZEQA>."
                },
                {
                    "user": "tskeith",
                    "date": "2020-09-16 14:33:59+00:00",
                    "text": "I agree that stacktraces are important, but I think it should be the job of the compiler to give you those, you shouldn't need to store such subroutine information yourself.\n\nStack traces can be useful, but I don't think that feature should be part of this proposal. This one is simple and straight-forward and should stay that way.\nA stack trace proposal would require analysis of the cost to programs that don't make use of the feature and a convincing argument that it adds enough value compared to, for example, using a debugger to get a stack trace."
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2020-09-16 16:51:02+00:00",
                    "text": "I agree that stacktraces are important, but I think it should be the job of the compiler to give you those, you shouldn't need to store such subroutine information yourself.\n\nStack traces can be useful, but I don't think that feature should be part of this proposal. This one is simple and straight-forward and should stay that way.\nA stack trace proposal would require analysis of the cost to programs that don't make use of the feature and a convincing argument that it adds enough value compared to, for example, using a debugger to get a stack trace.\n\nI agree. With Fortran, the topics of stack trace and error handling do extend to a distributed case and thus, can become much bigger than we could imagine yet. For example, error handling may become a mixture of local and distributed error handlers.\nTo me, it is still to early to further think about such yet, since I'm struggling with ifort getting my working OpenCoarrays codes to compile."
                }
            ]
        },
        {
            "number": 179,
            "user": "Jim-215-Fisher",
            "date": "2020-09-10 16:06:37+00:00",
            "title": "Arbitrary precision type",
            "text": "Does the stdlib include arbitrary precision data type? Currently, python, julia, c++, and java all have arbitrary precision data type.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-10 16:15:16+00:00",
                    "text": "No, but it seems to me a good candidate for stdlib. Then, if it shows to be useful we can propose it for the standard. Can you propose it in the stdlib repo?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 16:28:38+00:00",
                    "text": "In addition, I would like Fortran compilers to support arbitrary precision real types natively (as a real kind). I plan this for LFortran down the road."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-10 17:26:06+00:00",
                    "text": "There's a useful distinction to be made between \"arbitrary\" precision data types where the precision is known at compilation time and those whose precision is either not fixed at all or is at least deferred to execution time.\nAll of f18's REAL compilation-time arithmetic for constant folding, and decimal<->binary conversion during execution, are implemented with single C++ template classes that are instantiated for six different floating-point types, for example.  This would be pretty much impossible to accomplish in Fortran without parameterized modules or some other generic facility, and that's at least a decade away in the standard language (plus years more to wait for a first implementation, and then dealing with the bugs in the standard that can only be discovered by a first implementation and then become impossible to fix due to \"backward compatibility\").\nBut types with runtime precision (esp. INTEGER) would be easy to implement in Fortran using a derived type with a LEN type parameter -- if you could find a compiler where they work, correctly, or even at all.  So the best that we could do now would be a suite of arbitrary precision INTEGER and REAL types where the precision is dynamic and represented in a regular component of each value, and the bits are in an ALLOCATABLE component, with all the extra allocation overhead that implies."
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 18:21:41+00:00",
                    "text": "Speaking as a Fortran user, I would like to simply write code like this:\nreal(dp) :: s, x, dx\ninteger :: i, N\nN = 100\ndx = 1._dp / N\ns = 0\ndo i = 1, N\n    x = i*dx\n    s = s + sin(x)*dx\nend do\nprint *, \"Integral:\", s\nAnd then just change dp from \"double precison\" to \"100 decimal digits precision\". This already works with quadruple precision, and it would be nice to work with arbitrary (compile time) precision also.\nThen I also want a real kind that will use this library: http://arblib.org/ that automatically tracks the error for you. It works really great. I would like the \"print\" statement to print the error correctly (as Arb returns it), etc.\nAnd I would like the compiler to generate the most efficient code possible."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-10 18:31:13+00:00",
                    "text": "Speaking as a Fortran user, I would like to simply write code like this:\nreal(dp) :: s, x, dx\ninteger :: i, N\nN = 100\ndx = 1._dp / N\ns = 0\ndo i = 1, N\n    x = i*dx\n    s = s + sin(x)*dx\nend do\nprint *, \"Integral:\", s\nAnd then just change dp from \"double precison\" to \"100 decimal digits precision\". This already works with quadruple precision, and it would be nice to work with arbitrary (compile time) precision also.\nThen I also want a real kind that will use this library: http://arblib.org/ that automatically tracks the error for you. It works really great. I would like the \"print\" statement to print the error correctly (as Arb returns it), etc.\nAnd I would like the compiler to generate the most efficient code possible.\n\nThe most difficult part of implementing your example may be the call to sin(x)."
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 18:39:49+00:00",
                    "text": "Yes, all Fortran special functions should work. If the MPFR library is used, it can do those. The Arb library can also do those (and more)."
                }
            ]
        },
        {
            "number": 178,
            "user": "urbanjost",
            "date": "2020-09-04 18:57:56+00:00",
            "title": "support allocatable CHARACTER variables on GET_COMMAND() and GET_COMMAND_ARGUMENT()",
            "text": "prop.txt\nSince the strings being fetched via the GET_COMMAND() and GET_COMMAND_ARGUMENT() procedures are of indeterminate length and provided at run time a simple useful change to the intrinsics would be support of allocatable CHARACTER variables. The most recent example in the attachment limits itself to only allocating unallocated allocatable\nvariables per the topic discussions about how allocating an allocated variable could affect existing code, as the intrinsics allow allocated allocatable CHARACTER variables but do not reallocate them to the required length but return error -1 if their current length is exceeded.",
            "is_open": false,
            "labels": [
                "accepted",
                "Fortran 2023",
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-04 20:15:07+00:00",
                    "text": "Indeed (and the same with read, but that can be discussed in another issue).\nUntil this gets standardized, the subroutines from your proposal should go into stdlib. CC @milancurcic."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-04 20:22:07+00:00",
                    "text": "ALLOCATABLE CHARACTER arguments are already allowed, of course.  What I think is needed is the ability to pass an unallocated ALLOCATABLE CHARACTER.  That's currently not allowed, so extending the standard to support it would not invalidate any existing program (unlike the feature that J3 discussed at the February meeting that would reallocate an ALLOCATABLE CHARACTER entity if one were used for IOMSG= and other specifiers...)"
                },
                {
                    "user": "certik",
                    "date": "2020-09-04 20:39:57+00:00",
                    "text": "@klausler yes, if you read the prop.txt proposal above, it is about allowing to pass unallocated allocatable character and for them to be automatically allocated to the correct length."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-04 21:57:31+00:00",
                    "text": "Sorry for the confusion. You are both right. I changed the overload procedures to deallocate instead of use the pre-allocated string because I could not think of a use-case where I would not want to re-allocate. Now I see several reasons to put it back the way it was, including possibly causing an undetected truncation in existing code that uses the variable returned assuming it did not potentially change length, etc. I will put it back and look at hardening the example (which I just meant for demonstration purposes) for inclusion in stdlib. Of course that means putting a second line in the user code to ensure the variable is deallocated before the call in the general case, but off the cuff I can't think of an overload that would not require it without the additional of an additional parameter."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-06 03:28:05+00:00",
                    "text": "I updated the attachment and added a unit test and an optional argument REALLOC as a flag to reallocate an already allocated variable."
                },
                {
                    "user": "sblionel",
                    "date": "2020-09-11 00:06:35+00:00",
                    "text": "https://j3-fortran.org/doc/year/19/19-252r2.txt describes the feature asked for in the initial post, applying to all intrinsic procedures that have an INTENT(OUT) or INTENT(INOUT) argument where the value returned is \"as if by intrinsic assignment\", This handles both the unallocated and currently allocated cases."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-11 02:14:00+00:00",
                    "text": "Given the scope the body implies that really needs a new title. It covers more than \"Specification for auto-allocating processor messages\".   I was considering the same scope as that document implies, but wanted to initially be specific enough that issues like returning an array and elemental functions could be discussed with a smaller scope first but I see some of those issues covered. So what would that imply for NAMELIST output and for internal WRITE statements with / descriptors in the formats? Would an explicit / in a format imply an array on output and so be disallowed? Would you be guaranteed a single output line for an internal WRITE of a NAMELIST group? (that varied last time I looked from compiler to compiler. I believe it was the IBM compiler that required at least three elements and an array for an internal write of a NAMLIST group although I do not have access to that to verify it currently)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-11 02:20:47+00:00",
                    "text": "Digesting that a little more if a parameter is explicitly INTENT(OUT) it seems it should aleays be allocated on return instead of left unchanged, and I would argue that for any unallocated allocatable scalar, whether INTENT(INOUT) or INTENT(OUT), or you would likely have to test if the variable was unallocated upon return or always have and check a status variable to see if the return value of the status variable indicated no error and thus no message for options such as IOMSG for messages."
                },
                {
                    "user": "sblionel",
                    "date": "2022-04-23 19:58:56+00:00",
                    "text": "This is already in F2023 - not just for these two procedures but for all intrinsic subroutines with character output arguments. The introduction says, \"When a deferred-length allocatable actual\nargument of an intrinsic procedure is to be assigned character data, it is allocated by the processor to the\nlength of the data.\""
                },
                {
                    "user": "klausler",
                    "date": "2022-04-23 22:25:20+00:00",
                    "text": "Be advised, in the case of allocatable deferred-length character variables that are already in the allocated state, this feature in 202X is a silently incompatible change of existing behavior."
                },
                {
                    "user": "sblionel",
                    "date": "2022-04-23 22:31:07+00:00",
                    "text": "That was known, but considered to be the preferable behavior."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-04-23 23:36:52+00:00",
                    "text": "@sblionel wrote April 23, 2022, 6:31 PM EDT:\n\nThat was known, but considered to be the preferable behavior.\n\nMay be, but that does not make it right, not in the least bit.  It's a real travesty how the standard holds on to certain patently unsafe aspects in the language in the name of backward compatibility but in other situations, like with the feature in 202X, an incompatible change is introduced on account of an utterly silent voting bloc.  The practitioners of Fortran deserve a far better workflow on such decisions."
                },
                {
                    "user": "sblionel",
                    "date": "2022-04-24 00:14:50+00:00",
                    "text": "@FortranFan I find your post puzzling. This feature was put on the WG5 list in 2019 and it was first discussed in 2018 (https://j3-fortran.org/doc/year/18/18-279r1.txt) I have no clue what you mean by \"utterly silent voting bloc\".  It was discussed across at least three J3 meetings. It was also a popular feature in the survey I ran 2017 into 2018.\nThe consensus was that 1) allocatable deferred length character was a relatively new feature, 2) the old behavior was not what people wanted and required extra code to work around, 3) any existing workarounds would continue to work.\nYou're right that the committee is reluctant to change behaviors that would break existing programs. We felt that this case did not do that.\nWe do have protocols for eliminating unsafe practices, and have done so multiple times over the years."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-04-24 01:54:25+00:00",
                    "text": "@sblionel writes Apr 23, 2022, 8:14 PM EDT:\n\nI find your post puzzling. This feature was put on the WG5 list in 2019 and it was first discussed in 2018 (https://j3-fortran.org/doc/year/18/18-279r1.txt) I have no clue what you mean by \"utterly silent voting bloc\". It was discussed across at least three J3 meetings. It was also a popular feature in the survey I ran 2017 into 2018.\n\nI think you know exactly what is going on here.\nThe point of contention is the specific change related to the length parameter of the object.  Readers can consider the following example to better understand the issue:\n   character(len=:), allocatable :: cmd\n   allocate( character(len=20) :: cmd )\n   call get_command( cmd )\n   print *, len(cmd)\nend\nA processor conformant to current standard will allow the above program to output 20:\n\nC:\\temp>gfortran Example.f90 -o Example.exe\nC:\\temp>Example.exe\n20\n\n\nC:\\temp>ifort /standard-semantics Example.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.5.0 Build 20211109_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.31.31105.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:Example.exe\n-subsystem:console\nExample.obj\nC:\\temp>Example.exe\n20\n\nFollowing Fortran 202X though, a conformant processor will allow the program to output 11 or some such processor-dependent value which is different from what the current standard informs the user.\nThis is an unacceptable change given the constant refrain of backward compatibility.\nAnd there was inadequate discussion in the committee on this specific incompatible change that got introduced by how the feature was specified by the J3 subgroup.\nAlso the argument, \"allocatable deferred length character was a relatively new feature,\" was debatable because the \"allocatable deferred length character\" feature and the current behavior with GET_COMMAND (e.g., output of 20 above) and other such intrinsics got introduced starting Fortran 2003 published about 18 years ago.\nI believe an overwhelming majority of users find the overall item \"US14. Allow deferred-length character variables in more locations\" on the Fortran 202X worklist to be a good addition.  I do too.  That is not the argument here.  The issue is the change in behavior when it comes to already allocated allocatable character type argument,"
                },
                {
                    "user": "urbanjost",
                    "date": "2022-04-24 03:30:08+00:00",
                    "text": "I have not re-read it recently, but the last time i looked the proposal is that  GET_COMMAND will only allocate the variable if it is not already allocated,\nso it would still return 20.  If would only automatically allocate an unallocated variable.  Is that still not the case?  When I get some time I will reread, but that would keep it upward-compatible.\nAhh, it did change.  I would have preferred an option on GET_COMMAND to allow re-allocation as a compromise solution myself, but that is the preferred behavior enough for me that I have been using a wrapper around GET_COMMAND for a long time that does what the proposed change is, so it would not personally affect me;  but I am very surprised.  Somewhere along the line I think I proposed something like adding a \"REALLOC=.TRUE.\" optional argument because checking and deallocating would be ugly.\nIn practice, how many people are using an allocatable variable with GET_COMMAND where they have not queried the length with a previous GET_COMMAND call?  In the example, it seems unlikely someone would not use a fixed length variable if it was always 20,  and if allocatable have set the length with a query of the length first, in which case the change just eliminates the first call to GET_COMMAND, or if the first call is left in the same length will be returned anyway.\nI"
                },
                {
                    "user": "sblionel",
                    "date": "2022-04-24 14:04:46+00:00",
                    "text": "The text in 22-007r1, referring to all intrinsic procedures, is this:\n\"When an allocatable deferred-length character scalar corresponding to an INTENT (INOUT) or INTENT (OUT) argument is assigned a value, the value is assigned as if by intrinsic assignment.\" (16.9.1p3)  This is simple and easy to understand."
                },
                {
                    "user": "urbanjost",
                    "date": "2022-04-24 18:42:16+00:00",
                    "text": "Might be. Not sure what it means in English :>.   I don't think that is as simple as other schemes, or only marginally simpler. Now since most intrinsics are elemental the programmer has to remember that passing an allocatable scalar will behave differently than an array, that character variables behave differently than numeric with regard to allocatable variable,s ....  Somethings simple would have been \"all intrinsics return allocatable variables allocated\".  Makes sense for OUT arguments;  is easier to understand for functions than subroutines.  For the many versions of GETARG out there that are functions,  something like A=GETARG(1)  is clear that the LHS is returned first, and then assigned to A.  With subroutines this is another rule with inconsistencies to remember."
                },
                {
                    "user": "sblionel",
                    "date": "2022-04-24 18:50:53+00:00",
                    "text": "Note that it says scalar, so elemental doesn't apply. Besides, there are no elemental intrinsics with character OUT or INOUT arguments.  \"As if by intrinsic assignment\" is used frequently in the standard, and the explanation of what that does is straightforward."
                },
                {
                    "user": "urbanjost",
                    "date": "2022-04-24 19:32:56+00:00",
                    "text": "That is what I meant as one of the inconsistencies, that scalar is specifically specified. No intrinsic currently is CHARACTER and elemental but this hopefully some will be in the future. I know I have my own wrapper around get_arguments that returns a character array and a length array; not quite elemental but it returns an array.  I have a lot of string functions that are elemental, and hopefully the intrinsics will someday provide some of that functionality. In this particular case I am OK with the change personally, but as a general behavior that can be applied going forward, and because it causes an incompatible change with previous behavior I have some misgivings. Not being backward compatible if very \"un-Fortranic\". Personally, I only have a few small programs that call the intrinsics directly, as I almost always call something that takes Unix-like syntax like M_kracken or M_CLI2 or reads the arguments as a NAMELIST, and this change will let me simplify those interfaces (they all call GET_ARGUMENTS(1) once to get the length, and then allocate a variable, this change will make that simpler and cleaner)."
                },
                {
                    "user": "FortranFan",
                    "date": "2022-04-30 04:05:05+00:00",
                    "text": "Note that it says scalar, so elemental doesn't apply. Besides, there are no elemental intrinsics with character OUT or INOUT arguments. \"As if by intrinsic assignment\" is used frequently in the standard, and the explanation of what that does is straightforward.\n\nThe issue is not at all whether the revision as drafted toward Fortran 202X publication is straightforward or simple or useful, etc.  These are all beside the point.\nThe problem is as described by @urbanjost , \"because it causes an incompatible change with previous behavior I have some misgivings. Not being backward compatible if very \"un-Fortranic\"\""
                }
            ]
        },
        {
            "number": 177,
            "user": "wclodius2",
            "date": "2020-08-04 21:10:20+00:00",
            "title": "Assert",
            "text": "A paper on design by contract that, among other things, proposes the addition of an ASSERT statement\nto Fortran 202y.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-08-04 21:33:05+00:00",
                    "text": "Thank you @wclodius2, I read the proposal. Do requires and ensures do anything different from asserts other than being required to be in the prelude and conclusion of a procedure, respectively? Why not use just asserts?\nI have a slight preference for imperative mood for statements like this (require instead of requires, assert instead of asserts), which is consistent with other Fortran statements (allocate, deallocate, nullify, open, close, read, write, inquire, change team, form team, etc.)"
                },
                {
                    "user": "nncarlson",
                    "date": "2020-08-04 21:44:55+00:00",
                    "text": "I would find it useful to have an additional statement INSIST that behaves identically to ASSERT except that it is active in both development and deployment compilation modes; i.e., it is never a null operation."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-04 21:46:42+00:00",
                    "text": "The change is good.\n\u2026\n On Aug 4, 2020, at 3:15 PM, Milan Curcic ***@***.***> wrote:\n\n\n @milancurcic commented on this pull request.\n\n In proposals/assert/design_by_contract.txt <#177 (comment)>:\n\n > +REQUIRE and ENSURES can be thought of as either sub-program attributes\n +or executable statements. If treated as sub-program attributes then\n +the syntax could be something like\n +\n +  requires-stmt is EEQUIRES :: requires-expr-list\n +  ensures-stmt is ENSURES :: ensures-expr-list\n +\n +  requires-expr is logical-expr\n +  ensures-expr is logical-expr\n +\n +Constraint: requires-expr shall be a restricted expression.\n +\n +If thought of as run time expressions then the appropriate syntax may\n +be\n +\n +  requires-stmt is EEQUIRES( requires-expr-list )\n \u2b07\ufe0f Suggested change\n -  requires-stmt is EEQUIRES( requires-expr-list )\n +  requires-stmt is REQUIRES( requires-expr-list )\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub <#177 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOWNE4FYZCOMOYSYDI3R7B27RANCNFSM4PUZU5SA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-04 21:58:08+00:00",
                    "text": "Having them be different from assert calls them out to users of the procedure, and to automatic processing codes such as FORD. They naturally suggest documentation such as ASIN(X)  requires X>= -1, and X<=1, and ensures the result is >= -pi/2 and <= pi/2. The requires and ensures are aspects of the public interface of a procedure, and are important to users of the procedure, while assert is important only to the developer of the procedure.\n\u2026\n On Aug 4, 2020, at 3:33 PM, Milan Curcic ***@***.***> wrote:\n\n\n Thank you @wclodius2 <https://github.com/wclodius2>, I read the proposal. Do requires and ensures do anything different from asserts other than being required to be in the prelude and conclusion of a procedure, respectively? Why not use just asserts?\n\n I have a slight preference for imperative mood for statements like this (require instead of requires, assert instead of asserts), which is consistent with other Fortran statements (allocate, deallocate, nullify, open, close, read, write, inquire, change team, form team, etc.)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#177 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOTMKJL7B4JCHRSLATDR7B5B7ANCNFSM4PUZU5SA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-04 22:15:38+00:00",
                    "text": "FWIW I slightly prefer the active voice."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-05 16:51:52+00:00",
                    "text": "I don't seem to have write access to the repository, so I have to ask others to make changes for my approval. As it is always an executable construct ASSERT should always be in the active voice. Can someone change all appearances of ASSERTS to ASSERT? When discussed as an attribute statement I believe I should use REQUIRES and ENSURES, while when discussed as an executable statement I believe I should use REQUIRE and ENSURE. Can someone make that selected change?"
                },
                {
                    "user": "nncarlson",
                    "date": "2020-08-05 17:02:03+00:00",
                    "text": "@wclodius2  I'm not sure what errors you're seeing, but you should be able to make changes to your pull request.  Looks like Milan committed a couple changes to it. So perhaps you need to do a git pull on your assert branch to pull those changes into your working copy before you can commit your changes and push them back to the assert branch on your fork of the repo."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-14 00:02:15+00:00",
                    "text": "It has been a month and none of my three proposals (assertions/design by contract; optional dummy arguments, and module namespaces) have been merged into the repository. Did they \"fall off the radar\"? Did they need more work? Are they inappropriate for meeting 222, as they are explicitly F202y oriented and so low priority? Are there other reasons I am not thinking of?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 02:57:17+00:00",
                    "text": "@wclodius2 in the past we usually merged the pull requests before the meeting once we were happy with the wording and it was the version we wanted to present. I am happy to merge it sooner if you would prefer.\nIn the last meeting we presented such proposals at the plenary to get feedback from the whole committee. These proposals go into 202y, so the committee does not vote on them. The idea is to get them ready, so that when the committee starts considering proposals for 202y, they are ready.\nIn order to increase chances of the proposal getting accepted, it's good to involve as much of the wider community as possible. If there is wide support for some feature, it has a much higher chance of getting in."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-14 03:17:59+00:00",
                    "text": "In the past the nominal due date for proposals was two weeks before the meeting, with most proposals arriving a few days before the schedule. This means most proposals were read in a rush in the two week period before the meeting. I think where possible F202X proposals should be submitted a month in advance so there is a likelihood of feedback before the meeting. As these are F202Y proposals they don\u2019t need as prompt a feedback, but still I think they should get in before the two week deadline so there is a possibility of pre meeting commentary.\n\u2026\n On Sep 13, 2020, at 8:57 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> in the past we usually merged the pull requests before the meeting once we were happy with the wording and it was the version we wanted to present. I am happy to merge it sooner if you would prefer.\n\n In the last meeting we presented such proposals at the plenary to get feedback from the whole committee. These proposals go into 202y, so the committee does not vote on them. The idea is to get them ready, so that when the committee starts considering proposals for 202y, they are ready.\n\n In order to increase chances of the proposal getting accepted, it's good to involve as much of the wider community as possible. If there is wide support for some feature, it has a much higher chance of getting in.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#177 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOVH3FDE7H7KTV5IOMTSFWBBVANCNFSM4PUZU5SA>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 03:20:01+00:00",
                    "text": "Ok, let's merge it."
                }
            ]
        },
        {
            "number": 176,
            "user": "milancurcic",
            "date": "2020-07-20 22:38:14+00:00",
            "title": "Add namespace modules proposal revision by @wclodius2",
            "text": "Uploaded for @wclodius2. Related to issue #1.",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "wclodius2",
                    "date": "2020-07-31 18:53:34+00:00",
                    "text": "FWIW I don\u2019t have a significant  problem with disallowing it, but it requires more changes in the standard than simply allowing it,. In allowing the syntax you want to disallow you need only\n1. Add the new keyword, with;\n2. Add the module rename list; and\n3. Disallow the module rename list if with is omitted;\n\nTo disallow the syntax you want to disallow you need to add, probably as constraints:\n4. Disallow the only keyword if with is present; and\n5. Disallow the entity rename list if with is present.\n\nIt become a different negotiation i instead of use, with :: \u2026 you add a new with::... statement.  With a with statement you need:\n1. Add the new keyword with\n2. Add the with statement to the syntax\n3. Have the module rename list in the statement\n\nYou are in effect adding a simpler statement rather than complicating an existing statement\n\u2026\n On Jul 31, 2020, at 12:22 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @certik commented on this pull request.\n\n In proposals/namespace_modules/20-xxx.txt <#176 (comment)>:\n\n > +    use, with :: math, only: vector\n +    use, with:: strings, only: vector\n I believe this should be just:\n\n \u2b07\ufe0f Suggested change\n -    use, with :: math, only: vector\n -    use, with:: strings, only: vector\n +    use, with :: math\n +    use, with :: strings\n the code below would still run. I don't think we should allow user, with :: math, only: vector, what would it do? Allow math%vector, but not math%matrix? Python doesn't allow that, I wouldn't allow that either here.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOT43Y24H66BCKFWUYDR6MDWRANCNFSM4PC33DJQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 03:24:34+00:00",
                    "text": "I personally do not like allowing use, with :: math, only: vector. Also, if it is allowed, I think the proposal needs to explain more clearly what it would do. I personally would not allow it.\nBut I am happy to merge it if you just want to keep the proposal as is and discuss at the committee."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-14 03:54:43+00:00",
                    "text": "Then put it on the back burner. There is no rush for F202y. My attitude is that if there is a lot of activity on an F202Y issue on the GitHub forum, then it probably is not ready for J3. If there is not a lot of activity then we need to ask why. If that is because everyone is happy with the proposal then get it to J3 as soon as possible so non-participants in Git Hub can comment and some work can be done between meetings, even if it is not F202X work. If it is because people are tired of the issue or busy with other things then it may not be ready. As you are both the originator of the first namespace proposals, and the organizer of the Git Hub activities you have a big say as to whether it is ready.\n\nFor an F202X issue if there is a lot of activity on the GitHub forum then I would put off submitting it to J3 until about two weeks before the meeting. It means that progress is being made at the local level, and you want to make as much progress as possible before involving all of J3, but you cannot put off involving J3 until after the meeting. The face to face involvement at meetings can resolve issues faster than email exchanges.\n\u2026\n On Sep 13, 2020, at 9:24 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n I personally do not like allowing use, with :: math, only: vector. Also, if it is allowed, I think the proposal needs to explain more clearly what it would do. I personally would not allow it.\n\n But I am happy to merge it if you just want to keep the proposal as is and discuss at the committee.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOQDP7HTYGT6T53TIQ3SFWEH7ANCNFSM4PC33DJQ>."
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-14 22:21:14+00:00",
                    "text": "A very peripheral question, but for the J3 meeting, is it usual that participants are given only two weeks for reading proposals and making opinions about it? I am afraid that it is not a sufficiently long time to prepare opinions... (CC: @sblionel) ."
                },
                {
                    "user": "sblionel",
                    "date": "2020-09-14 22:41:01+00:00",
                    "text": "@septcolor The two-week limit is for new papers, though given that J3 meetings often generate dozens of new papers on the fly, it's not clear to me that this matters. Typically papers trickle in over the time between meetings so that two weeks in advance there are 20-30 papers to review (some of which have been there for months.)\nWe're at an odd stage in the development in that there are only seven work items for which work remains to be done. These all have topics in the j3-fortran.org discussion board (for J3 members only). So far, only a couple of minor papers have been submitted, none about the work items. I have been encouraging members to draft papers, but many are finding it difficult to devote time to this. If this in relation to 202Y proposals (as @wclodius2 suggests), then I suggest doing all discussion here as, at least for the October meeting, which is abbreviated, we may not have a chance to discuss future ideas."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-15 03:23:27+00:00",
                    "text": "@sblionel so standards development is at an odd state. Enough work has been done on the current draft that there would normally be enough time available to start preliminary work identifying features for the following draft, but because people are having trouble adjusting to COVID-19 telecommuting it is not clear how much progress will be made on the current draft. As a result it is unlikely that any work will be done this session on F202Y, with the possible exception of generics/templates. Understandable, but disappointing."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:08:42+00:00",
                    "text": "I've been thinking about this.\nI don't know if I like with more than namespace. For sure with is easier to type. @wclodius2 can you motivate how with describes that it imports the module as a namespace?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:10:13+00:00",
                    "text": "My other objection is that I don't understand what use, with :: math, only: vector means. As I suggested, I would not allow it. (I understand your argument about the simplest possible change, but I feel that's secondary.)"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-22 02:33:24+00:00",
                    "text": "There are several possible syntaxes for a namespace requiring statement. I will use with for the examples, as it is shorter, but replace it with namespace if you like.\n\nwhat we have been using for our examples is\n\nuse, with :: module-name\n\nbut that interacts oddly with module-nature\n\nuse, with, intrinsic:: iso_fortran_env\nuse, intrinsic, with :: iso_fortran_env\n\nand you have to explicitly forbid rename-list and only-list\n\nYou could also put the with after the module-name\nuse [, module-nature  :: ] module-name, with\n\nwhere with in effect replaces only making a third kind of use-stmt. This is easier to describe than the form we have been using for our examples.\n\nFinally you could have a namespace statement\n\nwith [, module-nature ::] module-name\n\nIt is what Ada uses, it is more succinct. It is also easier to  describe than the form we have been using for our examples.\n\u2026\n On Sep 21, 2020, at 8:10 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n My other objection is that I don't understand what use, with :: math, only: vector means. As I suggested, I would not allow it. (I understand your argument about the simplest possible change, but I feel that's secondary.)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOWKSMSFW4TSRK6KEXTSHABRHANCNFSM4PC33DJQ>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-22 02:36:16+00:00",
                    "text": "Using a module as a namespace you use the module entities always with the module-name.\n\u2026\n On Sep 21, 2020, at 8:08 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n I've been thinking about this.\n\n I don't know if I like with more than namespace. For sure with is easier to type. @wclodius2 <https://github.com/wclodius2> can you motivate how with describes that it imports the module as a namespace?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOQ6KGIHQGLKNJOHMTLSHABLPANCNFSM4PC33DJQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:40:14+00:00",
                    "text": "Using a module as a namespace you use the module entities always with the module-name.\n\nYes. I am just trying to understand how the term with describes this. You didn't use with in the above sentence, but you used the term namespace. Update: you did use with in with the module-name. Is that the idea? That with means that you always have to use the entities with the module-name in front?\n(I know this is just a term, but for this proposal, the \"marketing\" is very important, and I want to have a well rounded, well motivated proposal that will work and be intuitive to people.)\nP.S. Ada describes their use and with here: https://en.wikibooks.org/wiki/Ada_Programming/Packages#Using_packages"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-22 02:47:52+00:00",
                    "text": "I am having trouble understanding your point. I did use with in the sentence. I could have just as easily left namespace out.\n\nUsing a module with the with attribute requires that a module entity always be named with the module-name prepended.\n\u2026\n On Sep 21, 2020, at 8:40 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n Using a module as a namespace you use the module entities always with the module-name.\n\n Yes. I am just trying to understand how the term with describes this. You didn't use with in the above sentence, but you used the term namespace.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOUWDGNDMY7JSJX2T53SHAFBVANCNFSM4PC33DJQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:53:50+00:00",
                    "text": "My apologies, I amended my comment at #176 (comment), yes you did use with.\nWill you be able to join our Fortran call this Friday: https://fortran-lang.discourse.group/t/fortran-monthly-call-september-2020/298/8\nLet's discuss this there.\nLet me try to reformulate my question: I believe that language \"keywords\" should be natural and intuitive to describe what the feature is doing. So I want to have a motivation. Here is my best effort to motivate the two options:\n\nuse, namespace :: math The namespace keyword comes from: The math module will be imported as a namespace.\nuse, with :: math The with keyword comes from: The math module will be imported as a namespace where you use the module entities always with the module-name.\n\nBut I also have another alternative motivation:\n\n\n\nuse, with :: math The with keyword comes from: The code that contains this line will be used with the math module.\n\n\n\nWhich of these (if any) make sense to you?"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-22 03:02:21+00:00",
                    "text": "I will try to attend the the Fortran call on Friday. I currently have no conflicts with that time, but that of course can change.\n\u2026\n use, with :: math The with keyword comes from: The use of the module entities is always with the module-name.\n On Sep 21, 2020, at 8:54 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n My apologies, I amended my comment at #176 (comment) <#176 (comment)>, yes you did use with.\n\n Will you be able to join our Fortran call this Friday: https://fortran-lang.discourse.group/t/fortran-monthly-call-september-2020/298/8 <https://fortran-lang.discourse.group/t/fortran-monthly-call-september-2020/298/8>\n Let's discuss this there.\n\n Let me try to reformulate my question: I believe that language \"keywords\" should be natural and intuitive to describe what the feature is doing. So I want to have a motivation. Here is my best effort to motivate the two options:\n\n use, namespace :: math The namespace keyword comes from: The math module will be imported as a namespace.\n use, with :: math The with keyword comes from: The math module will be imported as a namespace where you use the module entities always with the module-name.\n But I also have another alternative motivation:\n\n use, with :: math The with keyword comes from: The code that contains this line will be used with the math module.\n Which of these (if any) make sense to you?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#176 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDORM5T2XO5VBF2JTHODSHAGUZANCNFSM4PC33DJQ>."
                }
            ]
        },
        {
            "number": 175,
            "user": "wclodius2",
            "date": "2020-07-12 04:31:06+00:00",
            "title": "Revised version of the default arguments proposal",
            "text": "I have written a revision of the paper by @milancurcic, @jvdp1, and @zjibben that attempts to address most of the issues raised at the Feb. 25 meeting, and a few other issues that have come to my mind. The paper differs from the original primarily by:\nRestricting optional arguments to arguments with the INTENT(IN), VALUE, or no intent attributes.\nRequiring arguments with a default assignment to be explicitly given the DEFAULT attribute.\nForbidding arguments from having both the DEFAULT and OPTIONAL attributes so that the PRESENT function retains its semantics.\nAllowing the expression on the right of the default assignment be a restricted expression and not just a constant expression.\nStrongly encouraging that the default assignment be in the FUNCTION or SUBROUTINE statement (and not the TYPE declaration statement) as probably being easier to parse.\nDiscussing the implications of the constraints on intrinsic assignment, 10.2.1.2, their interpretation, 10.2.1.3, and the constraints on defined assignment, 10.2.1.4, and their interpretation, 10.2.1.5 on default array assignments.\nBriefly discussing the implications of an argument with the DEFAULT attribute also having any one of the POINTER, VOLATILE, ASYNCHRONOUS, or TARGET attributes.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-12 04:58:56+00:00",
                    "text": "Thanks for submitting this!\n\nI like this. The only thing I am not sure is to specify the default expression in the subroutine statement. Indeed that is how other languages do that, but those languages also define the type there. In Fortran we define types separately from the subroutine line. So I think the default value should be initialized at the declaration also.\n\nNote also that in your proposal the default keyword is redundant. If you remove it, you arrive at the initial proposal from Milan. See the discussion at the original issue.\n\u2026\nOn Sat, Jul 11, 2020, at 10:31 PM, William B. Clodius wrote:\n I have written a revision of the paper by @milancurcic\n <https://github.com/milancurcic>, @jvdp1 <https://github.com/jvdp1>,\n and @zjibben <https://github.com/zjibben> that attempts to address most\n of the issues raised at the Feb. 25 meeting, and a few other issues\n that have come to my mind. The paper differs from the original\n primarily by:\n\n Restricting optional arguments to arguments with the INTENT(IN), VALUE,\n or no intent attributes.\n\n Requiring arguments with a default assignment to be explicitly given\n the DEFAULT attribute.\n\n Forbidding arguments from having both the DEFAULT and OPTIONAL\n attributes so that the PRESENT function retains its semantics.\n\n Allowing the expression on the right of the default assignment be a\n restricted expression and not just a constant expression.\n\n Strongly encouraging that the default assignment be in the FUNCTION or\n SUBROUTINE statement (and not the TYPE declaration statement) as\n probably being easier to parse.\n\n Discussing the implications of the constraints on intrinsic assignment,\n 10.2.1.2, their interpretation, 10.2.1.3, and the constraints on\n defined assignment, 10.2.1.4, and their interpretation, 10.2.1.5 on\n default array assignments.\n\n Briefly discussing the implications of an argument with the DEFAULT\n attribute also having any one of the POINTER, VOLATILE, ASYNCHRONOUS,\n or TARGET attributes.\n\n You can view, comment on, or merge this pull request online at:\n\n #175\n\n Commit Summary\n\n  * Revised version of the default arguments proposal\n File Changes\n\n  * *A* proposals/default_optional_arguments/revised_proposal.txt\n <https://github.com/j3-fortran/fortran_proposals/pull/175/files#diff-0f4b23a04e6db2e930f7b3c74a4ee745> (356)\n Patch Links:\n\n  * https://github.com/j3-fortran/fortran_proposals/pull/175.patch\n  * https://github.com/j3-fortran/fortran_proposals/pull/175.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#175>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWB4FNJQ3V2VYWYLKOTR3E4BNANCNFSM4OXT2LXA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 05:28:27+00:00",
                    "text": "OTOH I suspect that overriding the default assignment will normally be done by \u201cassignment\" to the named argument in the procedure call. The similarity to the usage I find attractive. I also find it very awkward attempting to distinguish between the constant assignment that gives the save attribute to local variables, and the proposed default assignment to arguments. The definition of an entity declaration in the TYPE declaration statement will become even more complex.\n\nThe DEFAULT keyword is redundant in the same sense that the OPTIONAL keyword is redundant. Fortran could have implicitly assigned the default attribute to any argument that is used with the PRESENT() function. I find the DEFAULT keyword very useful in distinguishing between arguments with the DEFAULT and OPTIONAL attributes. Redundancy isn\u2019t always bad. See what happened to the SAVE attribute.\n\u2026\n On Jul 11, 2020, at 10:59 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n Thanks for submitting this!\n\n I like this. The only thing I am not sure is to specify the default expression in the subroutine statement. Indeed that is how other languages do that, but those languages also define the type there. In Fortran we define types separately from the subroutine line. So I think the default value should be initialized at the declaration also.\n\n Note also that in your proposal the default keyword is redundant. If you remove it, you arrive at the initial proposal from Milan. See the discussion at the original issue.\n\n On Sat, Jul 11, 2020, at 10:31 PM, William B. Clodius wrote:\n > I have written a revision of the paper by @milancurcic\n > <https://github.com/milancurcic>, @jvdp1 <https://github.com/jvdp1>,\n > and @zjibben <https://github.com/zjibben> that attempts to address most\n > of the issues raised at the Feb. 25 meeting, and a few other issues\n > that have come to my mind. The paper differs from the original\n > primarily by:\n >\n > Restricting optional arguments to arguments with the INTENT(IN), VALUE,\n > or no intent attributes.\n >\n > Requiring arguments with a default assignment to be explicitly given\n > the DEFAULT attribute.\n >\n > Forbidding arguments from having both the DEFAULT and OPTIONAL\n > attributes so that the PRESENT function retains its semantics.\n >\n > Allowing the expression on the right of the default assignment be a\n > restricted expression and not just a constant expression.\n >\n > Strongly encouraging that the default assignment be in the FUNCTION or\n > SUBROUTINE statement (and not the TYPE declaration statement) as\n > probably being easier to parse.\n >\n > Discussing the implications of the constraints on intrinsic assignment,\n > 10.2.1.2, their interpretation, 10.2.1.3, and the constraints on\n > defined assignment, 10.2.1.4, and their interpretation, 10.2.1.5 on\n > default array assignments.\n >\n > Briefly discussing the implications of an argument with the DEFAULT\n > attribute also having any one of the POINTER, VOLATILE, ASYNCHRONOUS,\n > or TARGET attributes.\n >\n > You can view, comment on, or merge this pull request online at:\n >\n > #175\n >\n > Commit Summary\n >\n > * Revised version of the default arguments proposal\n > File Changes\n >\n > * *A* proposals/default_optional_arguments/revised_proposal.txt\n > <https://github.com/j3-fortran/fortran_proposals/pull/175/files#diff-0f4b23a04e6db2e930f7b3c74a4ee745> (356)\n > Patch Links:\n >\n > * https://github.com/j3-fortran/fortran_proposals/pull/175.patch\n > * https://github.com/j3-fortran/fortran_proposals/pull/175.diff\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#175>, or\n > unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWB4FNJQ3V2VYWYLKOTR3E4BNANCNFSM4OXT2LXA>.\n >\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub <#175 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOXGU3FXEWTOBNP6WS3R3E7JZANCNFSM4OXT2LXA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 13:27:09+00:00",
                    "text": "After checking my Ada textbook, I found that one thing I wrote about Ada is wrong so I am going to correct the proposal."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 13:36:44+00:00",
                    "text": "Removed the comment implying Ada was the exception in having a specification part."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-12 18:03:59+00:00",
                    "text": "Restricting optional arguments to arguments with the INTENT(IN), VALUE, or no intent attributes.\n\nThis would invalidate existing code, yes?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-12 18:26:56+00:00",
                    "text": "@klausler I'm pretty sure @wclodius2 meant \"Restricting default arguments...\". This proposal won't invalidate existing code. If it does, we will fix it."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-12 18:42:41+00:00",
                    "text": "This would invalidate existing code, yes?\n\nAfter having read the document, you should indeed read \"Restricting default arguments...\"."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 19:44:09+00:00",
                    "text": "A thinko. The proposal talks about restricting **default** arguments to arguments with the INTENT(IN), VALUE, or no intent attributes, which doesn\u2019t invalidate existing code.\n\u2026\n On Jul 12, 2020, at 12:04 PM, Peter Klausler ***@***.***> wrote:\n\n\n Restricting optional arguments to arguments with the INTENT(IN), VALUE, or no intent attributes.\n\n This would invalidate existing code, yes?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub <#175 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOX2O63XOWBLYBUV523R3H3JZANCNFSM4OXT2LXA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 19:53:13+00:00",
                    "text": "Unfortunately no intent is not equivalent to intent(inout), though I wouldn\u2019t object strongly if the revised proposal dropped allowing default assignment for no intent. INTENT(INOUT) means that the input value is always intended to be used and an output value is always expected. No INTENT could behave as an INTENT(IN), INTENT(OUT), or INTENT(INOUT), and its behavior could depend dynamically on the other arguments.\n\u2026\n On Jul 12, 2020, at 12:40 PM, Jeremie Vandenplas ***@***.***> wrote:\n\n\n @jvdp1 commented on this pull request.\n\n Thank you for this revision.\n I added minor comments around \"no intent\" and intent(inout). I am not sure what the issues are.\n\n In proposals/default_optional_arguments/revised_proposal.txt <#175 (comment)>:\n\n > +\n +1. Introduction\n +\n +This paper contains a proposal for Fortran 202y, to allow a programmer\n +to specify a default value for a subset of optional dummy\n +arguments. This would allow the programmer to then safely reference\n +such arguments in expressions regardless of whether the actual\n +argument is present or not.\n +\n +\n +2. Problem\n +\n +Fortran 2018 does not allow setting a default value for optional\n +arguments. A default value is the value that the dummy argument\n +would take if the corresponding actual argument is not present. If a\n +dummy argument of INTENT(IN) or VALUE, or no intent is declared as\n Is no intent equivalent to intent(inout)?\n\n In proposals/default_optional_arguments/revised_proposal.txt <#175 (comment)>:\n\n > +\n +This differs from the INTENT(IN), VALUE, and no intent case: first,\n +because one assigns the default value with INTENT(OUT) when the actual\n +argument is present, not when it is absent; and second, because the\n +assignment of a default involves only one statement rather than the\n +three statements for the helper variable of INTENT(IN), VALUE, and no\n +intent. For INTENT(INOUT), one typically makes the argument optional\n +to avoid the computational expense of calculating the out result, but\n +having a default value makes it awkward to determine the presence of\n +an optional argument, so the primary purpose of having it be optional\n +is defeated.\n +\n +This proposal addresses the issue for INTENT(IN), VALUE, and no intent\n +arguments that checking for the presence of the optional dummy\n +argument and using a helper variable is cumbersome and error-prone. We\n +will not address default values for INTENT(OUT) OR INTENT(INOUT)\n I am not sure to understand why intent(inout) is not considered.If no argument is passed, then intent(inout) would behave as intent(in)?\n\n In proposals/default_optional_arguments/revised_proposal.txt <#175 (comment)>:\n\n > +greatest in scenarios where the optional argument is used in many\n +places in the procedure, and a helper variable is used for its value\n +instead. Reduction in needed source code would result in more readable\n +and more correct programs.\n +\n +\n +3. Prior art\n +\n +We are not aware of any Fortran compiler that has implemented default\n +arguments. However it is a very common feature of other languages. Of\n +interpreted languages widely used in the scientific community:\n +Python, IDL, R, and Matlab all have default arguments. Of compiled\n +languages C++ and Ada may be the best known with default arguments. Of\n +these languages, Ada may be the most pertinent as it has INTENT\n +arguments similar to Fortran's. Ada has only defined default arguments\n +useful for INTENT(IN), and has not defined it for INTENT(OUT) or\n I don't know Ada. What does it implement for \"no intent\"?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#175 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOVNQNPJVPHR7QL5F5DR3H7SVANCNFSM4OXT2LXA>."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-12 20:06:53+00:00",
                    "text": "Unfortunately no intent is not equivalent to intent(inout), though I wouldn\u2019t object strongly if the revised proposal dropped allowing default assignment for no intent. INTENT(INOUT) means that the input value is always intended to be used and an output value is always expected. No INTENT could behave as an INTENT(IN), INTENT(OUT), or INTENT(INOUT), and its behavior could depend dynamically on the other arguments.\n\nThank you for the precisions. Therefore, because \"no intent\" could behave as an intent(out), wouldn't it make sense to not allowing default assignment for \"no intent\"? Otherwise, users could just drop \"intent(out)\" and add a default value for an argument actually behaving as intent(out)"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 20:19:04+00:00",
                    "text": "Like I said I have no strong feelings about no intent. The users can do a lot of things in almost any programming language that I would consider foolish. With no intent the user could also write the code in such a way that when he provides no argument so the default is used, the routine behaves like an INTENT(IN) and behaves like INTENT(INOUT) otherwise.. Whatever we decide we should discuss the implications for no intent, either requiring that an argument with the DEFAULT may not have the INTENT(INOUT) or INTENT(OUT) (implicitly allowing no intent), or require that arguments with the DEFAULT attribute must have  one of the attributes INTENT(IN) or VALUE (implicitly disallowing no intent).\n\u2026\n On Jul 12, 2020, at 2:07 PM, Jeremie Vandenplas ***@***.***> wrote:\n\n\n Unfortunately no intent is not equivalent to intent(inout), though I wouldn\u2019t object strongly if the revised proposal dropped allowing default assignment for no intent. INTENT(INOUT) means that the input value is always intended to be used and an output value is always expected. No INTENT could behave as an INTENT(IN), INTENT(OUT), or INTENT(INOUT), and its behavior could depend dynamically on the other arguments.\n\n Thank you for the precisions. Therefore, because \"no intent\" could behabe as an intent(out), wouldn't it make sense to not allowing default assignment for \"no intent\"? Otherwise, users could just drop \"intent(out)\" and add a default value for an argument actually behaving as intent(out)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#175 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDORHEY47PL72S6NERJLR3IJWTANCNFSM4OXT2LXA>."
                },
                {
                    "user": "certik",
                    "date": "2021-01-20 19:25:40+00:00",
                    "text": "I don't like specifying the default value in the argument list as in real function quadratic(x, a, b, c=0). I am ok with using default (and not mix this with optional).\nOne objection from the committee I believe is that the syntax integer, intent(in), default :: c = 0 implies the save attribute. So perhaps this syntax should be used instead: integer, intent(in), default(0) :: c."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-01-20 19:33:36+00:00",
                    "text": "One objection from the committee I believe is that the syntax integer, intent(in), default :: c = 0 implies the save attribute.\n\nI don't understand this objection because dummy arguments can't have a save attribute.\nI am also okay with not mixing default and optional. I slightly prefer the default :: c = 0 syntax, but default(0) :: c is fine too."
                },
                {
                    "user": "klausler",
                    "date": "2021-01-20 19:40:17+00:00",
                    "text": "You need to decide whether the default value of a dummy argument (or just that fact that it has one) is meant to be a characteristic of the procedure or not.  This matters in the implementation, because it determines whether an implementation has the freedom to implement the default value in the caller (as in C++) or in the called subprogram, or whether the language is forcing one or the other.\nWhy this matters: if the default value of a dummy argument is an expression involving other dummy arguments, host-associated variables, module or COMMON objects, &c., implementing the evaluation of the default value in the caller can be difficult or impossible.  But if default values are expressions to be evaluated if need be in the called subprogram, then the value need not be part of the characteristics or interface, and the implementation of the calling side is no different from an OPTIONAL argument; and one could argue that an explicit interface need not distinguish between OPTIONAL and having a default value for purposes of procedure pointer assignment and other interface compatibility checking."
                },
                {
                    "user": "certik",
                    "date": "2021-01-20 19:46:44+00:00",
                    "text": "Peter, when I discussed that at the last meeting (after the plenary), I think our idea was to implement the default value in the caller, which enables the compiler to compile the subroutine ahead of time without any if statements, and call it exactly the same way no matter if the user provides the default argument or not.\nYou have a good point about what if the default value is an expression involving other dummy arguments that it might be impossible. I don't know yet if it is impossible, and so a prior compiler implementation would be in order here. At least in gfortran it seems any of these expressions (such as a length of an array) is part of the function signature, so this would be also."
                },
                {
                    "user": "klausler",
                    "date": "2021-01-20 19:57:03+00:00",
                    "text": "Peter, when I discussed that at the last meeting (after the plenary), I think our idea was to implement the default value in the caller, which enables the compiler to compile the subroutine ahead of time without any if statements, and call it exactly the same way no matter if the user provides the default argument or not.\nYou have a good point about what if the default value is an expression involving other dummy arguments that it might be impossible. I don't know yet if it is impossible, and so a prior compiler implementation would be in order here. At least in gfortran it seems any of these expressions (such as a length of an array) is part of the function signature, so this would be also.\n\nsubroutine host(defaultY)\n  real, intent(in) :: defaultY\n  call solver(f)\n contains\n  real function f(x, y)\n    real, intent(in) :: x, y\n    default(defaultY) :: y\n    ...\n  end function\nend subroutine\n\nSeems like a compelling use case to me, but the default has to be implemented in the called subprogram to make it work.  So there's reasons why defaults should be implemented in callees, and the only argument for implementing them in callers (it might save a predictable branch) is weak and also has other obvious solutions."
                },
                {
                    "user": "certik",
                    "date": "2021-01-20 21:28:43+00:00",
                    "text": "I see. The nested subroutine f has access to the variables in the parent scope, such as defaultY, so this would work if the default is not part of the signature, using the current mechanism for nested subroutines. But if it is part of the signature of f, then one needs access to defaultY inside the function solver, which currently is not possible. Good point, thank you @klausler."
                },
                {
                    "user": "klausler",
                    "date": "2021-01-21 19:19:33+00:00",
                    "text": "I see. The nested subroutine f has access to the variables in the parent scope, such as defaultY, so this would work if the default is not part of the signature, using the current mechanism for nested subroutines. But if it is part of the signature of f, then one needs access to defaultY inside the function solver, which currently is not possible. Good point, thank you @klausler.\n\nHere's an idea: extend the VALUE attribute to accept an expression, and allow it to be applied to an OPTIONAL dummy argument as its default value.   (You could also accept VALUE with an expression to specify a per-invocation initializer for a local variable, too, I suppose.)"
                }
            ]
        },
        {
            "number": 174,
            "user": "certik",
            "date": "2020-07-03 21:40:31+00:00",
            "title": "Proposals from Amir Shahmoradi",
            "text": "@shahmoradi posted the following issues at #162, but I am moving them here. Let's create individual issues out of those, or add the comments there to already existing issues.\n\n@certik Ondrej, I am not sure where my requests for enhancements should go on the J3 repository. So I am going to list it here and hopefully you will know much better or help realize where I should submit them:\n\n\n\nCoarray slicing (equivalent of MPI_gather)\nreal :: co_Vector[*]\nreal, allocatable :: LocalVector(:)\n...\nLocalVector = co_Vector[ 1 : num_images() ]\n...\nAs far as I am aware, coarray slicing is currently not supported in Fortran 2018. This feature, however, is highly desired for writing a more concise code and potentially enabling more compiler optimization. The equivalent standard-conforming code would be:\ninteger :: i\nreal :: co_Vector[*]\nreal, allocatable :: LocalVector(:)\n...\nallocate( LocalVector(1 : num_images()) )\ndo i = 1, num_images()\n    LocalVector(i) = co_Vector[i]\nend do\n...\n\n\nthe ability to use dummy optional arguments when not present in a procedure:\nfunction runSampler(chainSize)\n    integer, intent(in), optional :: chainSize\n    if (.not.present(chainSize)) chainSize = 10000\n    ...\nThis is similar to the RFE by Curcic et al, so I won't explain it further here.\n\n\nstandardized support for a minimal healthy subset of the C/Fortran preprocessing features. preprocessors are essential for writing scalable code and many compilers are fully or partially support some level of preprocessing. C has this as part of the language. Adding preprocessors to Fortran would ensure that the community's use of preprocessors is more disciplined and supported by the language standard.\n\n\nfurther support for template metaprogramming. I know that this is already a highly popular RFE. So I just suffice to mention my strong support for it.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-03 21:45:09+00:00",
                    "text": "@shahmoradi, here are my comments:\n\n\nCan you create a new issue just for this? I don't think that's been proposed yet.\n\n\nI think that might be a duplicate of #22. If so, please make sure you voice your support there and add a thumbs up for it.\n\n\nI think that might be a duplicate of #65. If so, please make sure you voice your support there and add a thumbs up for it.\n\n\nThank you for our support. Some relevant issues are: #29, #4, #125 and many others. @tclune is officially leading an effort to make progress on this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-03 21:53:09+00:00",
                    "text": "I'd like to see item 1 as well and it could be a candidate for stdlib or standalone library. Why wait for it to be standardized? Let's make it."
                },
                {
                    "user": "certik",
                    "date": "2020-07-03 21:53:51+00:00",
                    "text": "Let's discuss item 1. in its dedicated issue."
                },
                {
                    "user": "shahmoradi",
                    "date": "2020-07-04 04:53:36+00:00",
                    "text": "@certik Thanks Ondrej. So should I create a new issue for coarray slicing then? (or is there already one?) I think the other items are well discussed in the issues you mentioned."
                },
                {
                    "user": "certik",
                    "date": "2020-07-04 04:58:25+00:00",
                    "text": "@shahmoradi yes, please create a new issue for coarray slicing."
                }
            ]
        },
        {
            "number": 173,
            "user": "Leonard-Reuter",
            "date": "2020-06-04 13:37:07+00:00",
            "title": "[Syntactic Sugar] chained comparisons",
            "text": "Allow for writing\nif (1 < 2 < 3)\ninstead of\nif (1 < 2 .and. 2 < 3)\nSimilar to python https://docs.python.org/3/reference/expressions.html#comparisons.\nI think, this is very much in the spirit of \"formula translation\" =)\n(Yup, this is nothing but syntactic sugar, but sugar is sweet)",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": []
        },
        {
            "number": 172,
            "user": "vansnyder",
            "date": "2020-05-09 20:23:56+00:00",
            "title": "Exceptions and Exception Handling",
            "text": "Block-structured exception handling has been provided in other languages for decades.  According to \"Programming Languages: Principles and Practice,\" 2nd edition, by Kenneth C. Louden (a notable textbook on programming languages), ``Exception handling was pioneered by the language PL/I in the 1960s and significantly advanced in CLU in the 1970s. However, it was only in the 1980s and early 1990s that design questions were largely resolved.'' Ada 83, for which development began in 1976, is probably the first language that provided block-structured exception handling in the modern form.  It is generally agreed that exception handling is commonplace in all modern languages.\nIt has been observed that the CHANGE TEAM construct described in the 6 November 2014 draft of TS 18508 (ISO/IEC JTC1/SC22/WG5 paper N2033) is, in effect, an exception block, but with an intrinsic (and invisible) exception handler that only manages necessary synchronization and\ndeallocations.\nIt's time for Fortran to have a complete block-structured exception handling mechanism.  Block-structured exception handling has been proposed for Fortran, but has never been implemented.\nObjections have been raised to block-structured exception handling, usually citing performance degradation.  While some implementations of block-structured exception handling impose expense even if an exception does not occur, block-structured exception handling does not inevitably\nimpose a significant execution-time penalty if an exception does not occur.  For example, the Janus and Verdix Ada compilers' block-structured exception handling mechanisms impose very low cost if an exception does not occur, and the exception handling mechanism provided by the GNU Ada Translator (GNAT) imposes zero cost if an exception does not occur.\nThe cost of exception handling should not be confused with the cost of exception detection. An exception cannot be handled unless it is detected. Most processors have methods to specify whether certain exceptions, such as subscripts out of bounds, are detected. The cost of an exception handler is the additional cost to provide for handling an exception, if one is detected. Providing a mechanism to handle an exception does not require or imply that the processor is instructed to detect it. If the processor does detect it, the additional overhead to handle it is very\nsmall, or nonexistent, until the exception is detected. If the processor does not detect it, the additional overhead to handle an exception that cannot occur is very small, or nonexistent.\nExceptions_3.pdf",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-05-12 15:59:15+00:00",
                    "text": "It's exceptionally important for Fortran to include support for exception handling as a modern language must.  Coders can then decide whether to make use of it and where and how in their codes just as it is with IEEE exception handling introduced in Fortran starting with the 2003 standard.\nOne of my biggest disappointments is with WG5 and how WG5 has reduced the work-list for Fortran 202X to drop items such as exception handling and generics.  Interested readers can see this link at comp,lang.fortran.  As seen in this link, many a Fortranner - with no real voice or representation due to their physical/virtual locale which is well outside the 2 to 5 country-based and rather institutionally controlled org structure - have been requesting support for exception handling but to no avail.\nThe way things function with an ISO-driven process and how arcane, archaic, and inefficient the process is when it comes to language advancement, it could very well be decades from now before the ducks get in a row for the standard process to finally work attentively toward exception handling in Fortran.  And even then there will always be the argument Fortran has survived that long without explicit exception handling support for coders, so why bother!?\nIn the meantime, there is another issue that too gets overlooked with this topic: in the industry where I work and the computing domains I am familiar with, code base after code base has moved away Fortran, a lack of support for exception handling and the demands that such a scenario places on the most important resource - developer time and productivity - is among the reasons for the flight away from Fortran.\nFor a simple example, there is a particular formula based on the pioneering scientific advancements by Gibbs and van der Waals which literally gets computed billions of times by engineers and scientists where I work.  This formula, y = f(x1, x2, .. , xN), can be written in a few lines of code and computed trivially.  Except when the values of the N independent variables x1 thru' xN are outside the physically acceptable range for practicable design and manufacturing.  The occurrence of this is truly an exceptional circumstance but which needs to be handled very carefully, for otherwise there are considerable consequences including that of safety.\nOwing to the lack of exception handling support in language, the Fortran codes were rendered exceptionally complex and verbose with developers having paid incalculable amount of attention to the handling of exceptional situations where the input values are outside the physically acceptable range.  This was so much so that a new engineer/scientist tasked to work on the code (and mostly with background in MATLAB, Python, C++, Java, .NET) would entirely fail to notice the important formula in the subprogram, it was a mind-blowing departure from the concept of Formula Translation and black-board abstraction.\nAs I mentioned earlier, the computations involving this formula are now performed in any number of compute environments where Fortran plays little to no role.  The code written in other languages is rather compact, readable and maintainable, albeit full of curly braces!!  For the purse-holders and budget managers though, the new code is overall better performant in spite of the use of structured exception handling.  So they can't be happier with their push away from Fortran.\nThis is an aspect where implementations such as LFortran, LLVM, etc. can be of great help with prototyping."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 16:23:11+00:00",
                    "text": "I think it is clear that many (if not the most) people in the wide Fortran community want some form of better exception handling.\nI also agree that the Committee in general is not handling these requests efficiently. As you know I am running for the WG5 Convenor position and in my platform I propose that we work on these proposals continuously and when they are ready, we will consider them for inclusion. However, no matter who gets selected in the end, let us work on these things, and when they are ready, I will bring them to the Committee to consider.\nSo let's get to work.\nThere are several approaches to exception handling. The above proposal is one. Here are other issues with other proposals: #6, #66. There are more.\nUltimately, this must be prototyped in a compiler to show that there is no performance overhead, and also to iron out corner cases, and to see how difficult it is to implement it. We will be able to do such prototypes very soon (if things go well, hopefully in a year or so). Until then, let's at least narrow down the options of what ideas should be prototyped.\nAlso, let's collect the most common objections and have solid answers to them. Here are some off top of my head:\n\nWhat are the performance implications?\nWhy are many C++ applications turning off exceptions for performance (in gaming industry for example)?\nThe C++ committee does not seem to be super happy with their traditional exceptions, and are proposing a different mechanism: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf; Wouldn't it be a mistake to do what C++ found is not such a great idea?\n\nAnd there is a lot more, see the thread at the J3 mailinglist starting with this email:\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-February/011256.html\nWe have to collect all the objections there and have a good answer, before we bring it back to the committee. Otherwise the same objections will be given and we will not move the discussion forward.\nThis is the real work that we have to do. I currently don't have time to drive this particular effort, but if somebody is interested in leading this, I will help as much as I can."
                },
                {
                    "user": "klausler",
                    "date": "2020-05-13 20:40:02+00:00",
                    "text": "Here is what I think Fortran can do.\n\nAdd a statement (say FAIL) that signifies failure with an error code.  As you will see, it can appear only within a dynamic context that can handle the error.  It causes transfer of control to the most deeply nested handler for its error code.  Memory allocations are automatically cleaned up between the FAIL and its handler.\nAdd a new specifier (say FAILING) to ALLOCATE statements, I/O statements, coarray references, &c. to give them permission to fail on error, END, and EOR conditions, thus allowing these conditions to be handled by the same handlers as if a FAIL statement had been executed.\nAdd a construct (say TRY <block> [ CATCH (error) <block> ]... [ CATCH DEFAULT <block> ] END TRY) that establishes an error handling context.  If a FAIL statement is executed, the appropriate handler block is executed.  A TRY construct with no CATCH DEFAULT, or with fallible code in its CATCH DEFAULT block, may appear only in a dynamic context that can handle the uncaught errors.\nAdd a attribute (I'll spell it FALLIBLE here) to procedures.  It signifies that the procedure may fail without catching all errors.  A reference to a FALLIBLE procedure may appear only where a FAIL statement could appear -- i.e., a hermetic TRY construct or in another FALLIBLE procedure.  The use of FALLIBLE implies an explicit interface.\n\nThe FAIL statement, and references to FALLIBLE procedures, may appear only within a hermetic TRY construct if they occur in a DO CONCURRENT loop or main program.\nWhy I favor this approach:\n\nIt has no effect on existing code.\nStatic checking can guarantee that all errors will be caught.\nRuntime overhead is cheap; no more expensive than alternate returns.\nImplementation would be straightforward; no magic in the linker or runtime library.\n\nTBD:\n\ninteraction with finalization\nwhether ALLOCATE statements, I/O statements, coarray references, &c. should automatically be fallible if they appear in a TRY construct.\nhow distinct user error codes would be defined"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:33:50+00:00",
                    "text": "@klausler thanks for this proposal. What I like about it is that it is essentially equivalent to manual alternate returns, and thus does not require any magic at runtime with stack frames or runtime library.\nAt the February 2019 meeting, we fleshed out two similar / alternative proposals:\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-February/011257.html\nSee the links at the bottom of the email:\n\nexample code in current Fortran: https://gist.github.com/certik/bd8235d2e1d049b22fcd1016f4914430\nmy original \"try\" proposal: https://gist.github.com/certik/d950b7468228ff6f7d8bbc680a0943a7\nnew \"status\" proposal: https://gist.github.com/certik/2293270ac39f2589ae702ed751f405f8\n\nit is also equivalent to manual alternate returns, no magic. I'll try to do this example using your proposal also, so that we can see how it would look like in a code."
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-13 22:57:01+00:00",
                    "text": "I uploaded a complete exception-handling proposal a few days ago. I\ndon't remember the number.\n   1. Exceptions are identified by enumerators of an extensible\nenumeration type.\n   2. Instead of a new construct, allow ENABLE ( <exception-list> )\nsuffix on BLOCK, CHANGE TEAM, DO CONCURENT, CRITICAL, SUBROUTINE and\nFUNCTION statements.\n   3. Allow any number of HANDLE ( <exception-list> ) ... <block> sub\nconstructs before the END of a construct that has an ENABLE suffix. The\n<exception-list> in the HANDLE should be required to be a subset of the\nlist in the ENABLE statement. The <exception-lists> in HANDLE blocks\nshall be disjoint.\n   4. The HANDLE block accesses its containing construct or program\nunit by host association, so the containing scope is NOT finalized\nbefore the exception handler starts.\n   5. When the exception handler finishes, its scope, and the\ncontaining scope, are finalized.\n   6. Users can define exceptions by extending the EXCEPTION type. Any\nexception, intrinsic or user-defined, can be explicitly raised by a\nRAISE statement.\n   7. If a scoping unit does not handle an exception, it is raised in\nthe enclosing scoping unit. If there is no enclosing scoping unit, it\nis raised in the invoking scoping unit, if any. If it is raised in the\nmain program, the rutime support handles it, probably by printing a\nmessage and ERROR STOPping with a non-zero status.\n   8. Interaction with interoperability TBD.\n   9. More details in the uploaded paper.\n\u2026\nOn Wed, 2020-05-13 at 13:40 -0700, Peter Klausler wrote:\n Here is what I think Fortran can do.\n\n\n Add a statement (say FAIL) that signifies failure with an error\n code.  As you will see, it can appear only within a dynamic context\n that can handle the error.  It causes transfer of control to the most\n deeply nested handler for its error code.  Memory allocations are\n automatically cleaned up between the FAIL and its handler.\n Add a new specifier (say FAILING) to ALLOCATE statements, I/O\n statements, coarray references, &c. to give them permission to fail\n on error, END, and EOR conditions, thus allowing these conditions to\n be handled by the same handlers as if a FAIL statement had been\n executed.\n Add a construct (say TRY <block> [ CATCH (error) <block> ]... [ CATCH\n DEFAULT <block> ] END TRY) that establishes an error handling\n context.  If a FAIL statement is executed, the appropriate handler\n block is executed.  A TRY construct with no CATCH DEFAULT, or with\n fallible code in its CATCH DEFAULT block, may appear only in a\n dynamic context that can handle the uncaught errors.\n Add a attribute (I'll spell it FALLIBLE here) to procedures.  It\n signifies that the procedure may fail without catching all errors.  A\n reference to a FALLIBLE procedure may appear only where a FAIL\n statement could appear -- i.e., a hermetic TRY construct or in\n another FALLIBLE procedure.  The use of FALLIBLE implies an explicit\n interface.\n\n The FAIL statement, and references to FALLIBLE procedures, may appear\n only within a hermetic TRY construct if they occur in a DO CONCURRENT\n loop or main program.\n\n Why I favor this approach:\n\n\n It has no effect on existing code.\n Static checking can guarantee that all errors will be caught.\n Runtime overhead is cheap; no more expensive than alternate returns.\n Implementation would be straightforward; no magic in the linker or\n runtime library.\n\n TBD:\n\n\n interaction with finalization\n whether ALLOCATE statements, I/O statements, coarray references, &c.\n should automatically be fallible if they appear in a TRY construct.\n how distinct user error codes would be defined\n\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\n [\n {\n ***@***.***\": \"http://schema.org\",\n ***@***.***\": \"EmailMessage\",\n \"potentialAction\": {\n ***@***.***\": \"ViewAction\",\n \"target\": \"\n #172 (comment)\n \",\n \"url\": \"\n #172 (comment)\n \",\n \"name\": \"View Issue\"\n },\n \"description\": \"View this Issue on GitHub\",\n \"publisher\": {\n ***@***.***\": \"Organization\",\n \"name\": \"GitHub\",\n \"url\": \"https://github.com\"\n }\n }\n ]"
                },
                {
                    "user": "klausler",
                    "date": "2020-05-14 00:17:21+00:00",
                    "text": "Looks a lot to me like the current C++ exception feature that many significant codebases specifically go out of their way to disable and that C++ is working hard to replace."
                },
                {
                    "user": "certik",
                    "date": "2020-05-14 02:16:59+00:00",
                    "text": "@klausler I implemented an example using your proposal, please let me know if I got it right:\n\nCurrent valid Fortran: https://gist.github.com/certik/bd8235d2e1d049b22fcd1016f4914430\nPeter's proposal: https://gist.github.com/certik/8dc9f960f7c58a2cc17f7f5b911eb4fa"
                },
                {
                    "user": "certik",
                    "date": "2020-05-14 03:28:06+00:00",
                    "text": "@vansnyder I have implemented an example using your proposal, please let me know if I got it right:\n\nCurrent valid Fortran: https://gist.github.com/certik/bd8235d2e1d049b22fcd1016f4914430\nVan's proposal: https://gist.github.com/certik/012ed004257e14fc2a7557c7943eeaf1"
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-14 04:29:59+00:00",
                    "text": "On Wed, 2020-05-13 at 17:17 -0700, Peter Klausler wrote:\n Looks a lot to me like the current C++ exception feature that many\n significant codebases specifically go out of their way to disable and\n that C++ is working hard to replace.\nIt's based on the Ada exception mechanism, and John Reid's proposal.\nOne important difference from John's proposal is that John's\nrepresented exceptions by integers.\n\u2026\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\n [\n {\n ***@***.***\": \"http://schema.org\",\n ***@***.***\": \"EmailMessage\",\n \"potentialAction\": {\n ***@***.***\": \"ViewAction\",\n \"target\": \"\n #172 (comment)\n \",\n \"url\": \"\n #172 (comment)\n \",\n \"name\": \"View Issue\"\n },\n \"description\": \"View this Issue on GitHub\",\n \"publisher\": {\n ***@***.***\": \"Organization\",\n \"name\": \"GitHub\",\n \"url\": \"https://github.com\"\n }\n }\n ]"
                },
                {
                    "user": "klausler",
                    "date": "2020-05-14 16:05:41+00:00",
                    "text": "@klausler I implemented an example using your proposal, please let me know if I got it right:\n\nCurrent valid Fortran: https://gist.github.com/certik/bd8235d2e1d049b22fcd1016f4914430\nPeter's proposal: https://gist.github.com/certik/8dc9f960f7c58a2cc17f7f5b911eb4fa\n\n\nThe fallible subroutine can't be called at line 15 from the main program outside an error handling context."
                },
                {
                    "user": "certik",
                    "date": "2020-05-14 16:26:27+00:00",
                    "text": "The fallible subroutine can't be called at line 15 from the main program outside an error handling context.\n\nI updated the gist (still the same link), you can see the changes in the \"Revisions\" tab.\nI was wondering about this --- I can see both ways here. Your proposal disallows calling the fallible subroutine outside of an error handling context, which is very explicit and will cause all errors to be explicitly handled, which I think is a nice feature.\nTwo questions:\n\n\nHow would this be implemented in the compiler? Would there be an implicit additional intent(out) argument __failed for every subroutine that is fallible? And then an implicit if statement right after calling any fallible subroutine that will check this __failed argument and if it is .true., it would immediately return and propagate __failed to the parent subroutine or main program?\n\n\nAssume you are in the main program or in some non-fallible subroutine. And you need to call a subroutine that is fallible, but you don't want to be handling errors, you just want the program to fail at runtime with a stacktrace, just like currently allocate will fail if you don't set the stat argument. In your proposal currently you have to do:\n\n\ntry\n    call mysum(5, s)\ncatch default\n    error stop\nend try\nWhich is quite verbose given that you don't want to handle the error. Would it make sense to create a shortcut for the above code as follows:\ntry mysum(5, s)\nWhich would be exactly equivalent to the above code. So in practice, if you have an existing code that has call mysum(5, s) and then later if the mysum subroutine becomes fallible, but you don't care about handling the error, all you have to do is to change call into try at each call site. Which is a simple change and the compiler would tell you which places need changing, and you can decide at each place if you want the default handling (error stop + stacktrace at runtime) or if you want to handle the error yourself. And also even later on, you will always see which places in your code can fail using the default error handling (error stop) and change them to handle the possible failure yourself. So that seems like a robust design."
                },
                {
                    "user": "klausler",
                    "date": "2020-05-14 16:55:43+00:00",
                    "text": "The implementation would be very much like that of alternate returns, except that it would also work for functions (not just subroutines).  The value returned has to be an error code, not just a simple flag.\nIf a call fails, the caller either handles the failure, or fails itself.  In the latter case, the caller's return is almost immediate -- it still deallocates its local state."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-14 21:15:29+00:00",
                    "text": "The implementation would be very much like that of alternate returns, except that it would also work for functions (not just subroutines). The value returned has to be an error code, not just a simple flag.\nIf a call fails, the caller either handles the failure, or fails itself. In the latter case, the caller's return is almost immediate -- it still deallocates its local state.\n\nI like the sound of this.  Plus @klausler point about \"The implementation would be very much like that of alternate returns,\" is really good to read.  For I've always had a simpleton's view the alternate return facility (given it's still part of the standard even if labeled obsolescent) in a given implementation for Fortran might be able to assist with illustration and prototyping.\nRe: @klausler other point, \"The value returned has to be an error code,\" it will be really beneficial and user friendly from a coder perspective if the return value is of an enumeration type as proposed by @vansnyder above."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-14 21:46:07+00:00",
                    "text": "@certik wrote on 12 May 2020:\n\nI think it is clear that many (if not the most) people in the wide Fortran community want some form of better exception handling.\nI also agree that the Committee in general is not handling these requests efficiently. As you know I am running for the WG5 Convenor position and in my platform I propose that we work on these proposals continuously and when they are ready, we will consider them for inclusion. However, no matter who gets selected in the end, let us work on these things, and when they are ready, I will bring them to the Committee to consider.\nSo let's get to work.\n..\n\nThe C++ committee does not seem to be super happy with their traditional exceptions, and are proposing a different mechanism: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf; Wouldn't it be a mistake to do what C++ found is not such a great idea?\n..\n\n\nThank you @certik , your feedback and suggestions are very inclusive of the broader needs of the community and as such, they are very helpful to achieve progress in the Fortran language with this important feature.\nAs I mentioned above, my experience in industry is along the same lines as the IEEE Spectrum ranking in terms of the popular languages employed for computing and where each and every one of the top languages offers support for exception handling.  In addition to C++, the languages used and all of whom support exception handling include C# and Java and Python and R and also some new languages such as Swift which has gained a lot of influence due to the influence of iOS ecosystem: https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html.  But not to be overlooked are other recent languages such as Julia which do compete with C++ and Fortran in the high-performance computing space also e.g., https://docs.julialang.org/en/v1/manual/control-flow/#Exception-Handling-1.  And as mentioned by @vansnyder, Ada with its focus on embedded devices and controls and task-based concurrent programming with highly demanding environments such as aircraft systems has also provided robust support for exception handling.\nThus it appears many paths are available beyond that taken by early C++and I hope Fortran can also quickly learn from other approaches such as Julia, Swift, C#, etc. and offer up some performant facility."
                },
                {
                    "user": "certik",
                    "date": "2020-05-14 21:54:46+00:00",
                    "text": "@FortranFan great links. The Swift link is I think very close if not exactly what we want. Very similar to Peter's proposal, although with different syntax."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-15 01:25:20+00:00",
                    "text": "@certik, the example you provided above can also be analyzed using alternate return facility in Fortran as follows:\nmodule exception_m\n\n   type :: exception_enum_t\n      integer :: e = 0\n   end type\n\n   type(exception_enum_t), parameter :: OBJECT_ALREADY_ALLOCATED = exception_enum_t( e=1 )\n   type(exception_enum_t), parameter :: INSUFFICIENT_MEMORY = exception_enum_t( e=2 )\n\nend module\n\nmodule mysum_m\n\n   use exception_m\n\n   interface mysum\n      module procedure mysum_with_noexception\n      module procedure mysum_with_exception\n   end interface\n\n   type(exception_enum_t) :: mysum_exception = exception_enum_t()\n\n   private :: mysum_with_noexception\n   private :: mysum_with_exception\n\ncontains\n\n   subroutine mysum_with_noexception(n, s)\n      integer, intent(in) :: n\n      real, intent(out)   :: s\n      real, allocatable :: a(:)\n      if ( n == 42 ) call foo( a )\n      allocate( a(n) )\n      call random_number( a )\n      s = sum(a)\n      return\n   end subroutine\n\n   subroutine mysum_with_exception(n, s, *)\n      integer, intent(in) :: n\n      real, intent(out)   :: s\n      real, allocatable :: a(:)\n      integer :: istat\n      if ( n == 42 ) call foo( a )\n      allocate( a(n), stat=istat )\n      if ( istat /= 0 ) then\n         select case ( istat )\n            case ( 151, 5014 )\n               call throw_exception( OBJECT_ALREADY_ALLOCATED )\n            case default\n               call throw_exception( INSUFFICIENT_MEMORY )\n         end select\n         return 1\n      end if\n      call random_number( a )\n      s = sum(a)\n      return\n   end subroutine\n\n   subroutine foo( a )\n      real, allocatable, intent(out) :: a(:)\n      a = [ real :: ]\n   end subroutine foo\n\n   subroutine throw_exception( ex )\n      type(exception_enum_t), intent(in) :: ex\n      mysum_exception = ex\n   end subroutine\n\nend module\n\nprogram p\n\n   use mysum_m\n\n   real :: s\n   integer :: i\n\n   do i = 41, 42\n\n      print *, \"i = \", i\n\n      try: block\n\n         use exception_m\n\n         call mysum(i, s, *99)\n         print *, \"call sum(i, s, *99): s = \", s\n         exit try\n\n      99 continue ! catch\n         print *, \"Program exception in sum\"\n         select case ( mysum_exception%e )\n            case ( OBJECT_ALREADY_ALLOCATED%e )\n               print *, \"Exception raised: allocatable object is already allocated.\"\n            case ( INSUFFICIENT_MEMORY%e )\n               print *, \"Exception raised: insufficient memory to allocate object.\"\n            case default\n               print *, \"Exception raised: unidentified error.\"\n         end select\n         print *, \"Resume execution\"\n\n      end block try\n\n      call mysum(i, s)\n      print *, \"call sum(i, s): s = \", s\n\n   end do\n\nend program p\nYou can try above code with either gfortran or Intel Fortran and you should get output as follows:\n\ni =           41\ncall sum(i, s, *99): s =    20.3514481\ncall sum(i, s): s =    18.7895145\ni =           42\nProgram exception in sum\nException raised: allocatable object is already allocated.\nResume execution\nAt line 33 of file C:\\dev\\Fortran\\temp\\sor\\p.f90\nFortran runtime error: Attempting to allocate already allocated variable 'a'\nError termination. Backtrace:\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\n#10  0xffffffff\nProcess returned 2 (0x2)   execution time : 0.043 s\n\nAs mimicked in this example with a 'throw' invocation, it will be nice if the return value of a raised exception is an enumeration type."
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-20 21:46:08+00:00",
                    "text": "On Thu, 2020-05-14 at 14:15 -0700, FortranFan wrote:\n         The implementation would be very much like that of alternate\n         returns, except that it would also work for functions (not\n         just subroutines). The value returned has to be an error code,\n         not just a simple flag.\n\n         If a call fails, the caller either handles the failure, or\n         fails itself. In the latter case, the caller's return is\n         almost immediate -- it still deallocates its local state.\n\n\n\n I like the sound of this. Plus @klausler other point about \"The\n implementation would be very much like that of alternate returns,\" is\n really good to read. For I've always had a simpleton's view the\n alternate return facility (given it's still part of the standard even\n if labeled obsolescent) in a given implementation for Fortran might be\n able to assist with illustration and prototyping.\nI haven't written a compiler for a \"real\" language such as Fortran (but\nI have written a bunch for \"little\" languages). I imagine that one way\nthat processors might propagate exceptions that aren't locally handled\nis equivalent to alternate returns.\n\nIt's important to be able to catch both system exceptions and exceptions\nraised explicitly by the program.\n Re: @klausler point, \"The value returned has to be an error code,\" it\n will be really beneficial and user friendly from a coder perspective\n if the return value is of an enumeration type as proposed by\n @vansnyder above.\nIn my complete exception-handler proposal, there is more to the\nrepresentation of an exception than a value of an enumeration type. The\nhandler can also receive an object of class EXCEPTION_DATA, which would\ninclude the STATUS (or IOSTAT) value, and the MESSAGE (or IOMSG) value.\n\u2026\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-24 00:57:19+00:00",
                    "text": "@certik wrote on May 14, 2020, 5:54 PM EDT:\n\n.. The Swift link is I think very close if not exactly what we want. Very similar to Peter's proposal, although with different syntax.\n\n@certik, @klausler, and to everyone with Fortran compiler developer experience:\nPrima facie, Swift language error handing facility does indeed appear close to what can benefit Fortran coders.  Swift also appears to be mindful of performance in terms of its semantics of a throw statement being made comparable to a return, consider\n\nNOTE\nError handling in Swift resembles exception handling in other languages, with the use of the try,\ncatch and throw keywords. Unlike exception handling in many languages\u2014including Objective-C\nerror handling in Swift does not involve unwinding the call stack, a process that can be\ncomputationally expensive. As such, the performance characteristics of a throw statement are\ncomparable to those of a return statement.\n\nGiven then, what would it take to get a project going to prototype a facility in one or more compiler implementations, perhaps building on @klausler's ideas?  What kind of support can non-compiler developers provide to compiler developers such as yourself to get such an effort rolling?\nAlso, any comments on the Swift approach to avoid unwinding of the stack vis-a-vis Fortran and its language semantics?  Is it a non-starter or a non-issue given current Fortran standard and its legacy, or can it be an option worth a consideration with Fortran?"
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-24 03:42:54+00:00",
                    "text": "Performance of exception handling shouldn't be an issue. Exceptions are\nsupposed to be exceptional. If you have performance problems because of\nthe expense of exception handling, you're abusing exception handling.\n\nMany processors have very low overhead due to the presence of the\nability to handle exceptions. Two processors for which I've had\ncorrespondence with the developers are Verdix Ada and GNU Ada. Verdix\nada has very low overhead unless an exception occurs. GNU Ada has zero\noverhead unless an exception occurs.\n\nI proposed that a BLOCK construct, CRITICAL construct, CHANGE TEAM\nconstruct, or procedure header could have an ENABLE suffix that\nspecifies which exceptions can be handled. This actually means which\nexceptions the construct or procedure will detect if the program is\ncompiled with checking for those exceptional conditions, such as\nsubscripts out of bounds, turned on. I think this is the same as \"try\"\nin other languages. Then a construct or subprogram can have any number\nof HANDLE blocks, each one indicating which exceptions it handles. Two\nhandlers in a particular construct or subprogram cannot handle the same\nexception. Users can raise an exception with a RAISE statement that\nspecifies an exception. A handler can pass an exception along to the\nenclosing or calling scope's handler using a RAISE statement that\ndoesn't specify an exception, meaning \"whatever exception got you to\nthis handler.\" I think that's the same as \"throw\" in other languages.\n\nIf an exception isn't handled in a block, it's raised in the enclosing\nblock,. If there's no enclosing block, it's raised in the calling scope.\n\nOne way that I can imagine to propagate exceptions to a calling scope is\nfor the processor to create the same sort of code as for an alternate\nreturn, except hidden, the way some F77 compilers passed character\nlengths. In the calling scope, the corresponding argument is the \"label\"\nof a dispatcher that looks at the exception and either gives it to a\nlocal handler or re-raises it.\n\u2026\nOn 5/23/20 5:57 PM, FortranFan wrote:\n\n @certik <https://github.com/certik> wrote on May 14, 2020, 5:54 PM EDT:\n\n     .. The Swift link is I think very close if not exactly what we\n     want. Very similar to Peter's proposal, although with different\n     syntax.\n\n @certik <https://github.com/certik>, @klausler\n <https://github.com/klausler>, and to everyone with Fortran compiler\n developer experience:\n\n Prima facie, Swift language error handing facility\n <https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html>\n does indeed appear close to what can benefit Fortran coders. Swift\n also appears to be mindful of performance in terms of its semantics of\n a *throw* statement being made comparable to a *return*, consider\n\n     NOTE\n\n     Error handling in Swift resembles exception handling in other\n     languages, with the use of the try,\n     catch and throw keywords. Unlike exception handling in many\n     languages\u2014including Objective-C\n     error handling in Swift does not involve unwinding the call stack,\n     a process that can be\n     computationally expensive. As such, the performance\n     characteristics of a throw statement are\n     comparable to those of a return statement.\n\n Given then, what would it take to get a project going to prototype a\n facility in one or more compiler implementations, perhaps building on\n @klausler <https://github.com/klausler>'s ideas? What kind of support\n can non-compiler developers provide to compiler developers such as\n yourself to get such an effort rolling?\n\n Also, any comments on the Swift approach to avoid unwinding of the\n stack vis-a-vis Fortran and its language semantics? Is it a\n non-starter or a non-issue given current Fortran standard and its\n legacy, or can it be an option worth a consideration with Fortran?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#172 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFMNQ63WYK33CS76DTPJKLDRTBWHVANCNFSM4M46DTBA>."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-24 19:16:19+00:00",
                    "text": "@vansnyder wrote May 23, 2020 11:42 PM EDT:\n\nPerformance of exception handling shouldn't be an issue. Exceptions are supposed to be exceptional. .. I proposed that a BLOCK construct, CRITICAL construct, CHANGE TEAM construct, or procedure header could have an ENABLE suffix that specifies which exceptions can be handled. .. One way that I can imagine to propagate exceptions to a calling scope is for the processor to create the same sort of code as for an alternate return, except hidden, ..\n\nAll this makes sense, the question really is how to gain traction and start to \"move the needle\" on this feature?\n\"Performance\" considerations keep coming up again and again in the context of this feature, either by vendors or by some who think it's been this way since FORTRAN I so why change.  Even though I personally think the concerns with performance are either overstated or an attempt at misdirection, it seems to hinder any progress on this work item with Fortran.  So then, how does one either put the \"performance\" issue to bed once and for all, or illustrate what can work with Fortran and what semantics to avoid?\nSeparately, I think syntax is the easier part though the debates might get \"passionate\" and agreement on the terms may prove elusive.  Does one go with verbs that are similar in sound and meaning as most other popular languages in scientific and technical programming and which will make it easier for younger Fortranners to relate to and employ the facility e.g., try, throw/throws, catch, defer, etc?  Or does Fortran end up with terms that are deliberately intended to make it stand apart and even sound archaic (\"classic\" in some minds) such as enable, raise, handle, fallible/fall and so forth.\nHowever there are a couple of big bridges to cross before Fortran can arrive at the \"world of fun\" with syntax.\nHow does one get started?\n@certik, with your vision toward WG5, would more liberal and robust use of the \"Technical Specification (TS)\" approach be worth a consideration to push progress on certain long-standing but dormant items such as exception handling?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:55:43+00:00",
                    "text": "@FortranFan I think we have identified 3 proposals worth prototyping above, and if people propose more proposals in the future, we can prototype those too.\nI think the next step is to prototype this in a compiler, preferably two compilers. That is the only way to settle the performance worries and to truly understand the complexity of this feature and to help nail down various design issues. I truly believe at least Flang and LFortran will be able to do this in a relatively near future (in a year or so).\nOnce we settle on the underlying mechanism / semantics and convince ourselves that this is doable and we understand the performance implications, then we have to agree on the final syntax and after that we should write a paper and propose this either directly to the standard, or using a TS. I am positive we can agree on the best way forward once we get to this point.\nI am now concentrating my efforts into LFortran to bring it to the state that people can start using it, and also so that we can prototype such features, and the Flang team is making good progress on their compiler, and I truly believe we can achieve the goal of having at least two independent prior implementations of such wide ranging features such as exceptions."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-05-27 01:22:14+00:00",
                    "text": "@certik wrote May 25, 2020 3:55 PM EDT:\n\n..\nI am now concentrating my efforts into LFortran to bring it to the state that people can start using it, and also so that we can prototype such features, and the Flang team is making good progress on their compiler, and I truly believe we can achieve the goal of having at least two independent prior implementations of such wide ranging features such as exceptions.\n\nThanks much for your feedback, that's really good.  It'll be really interesting to see how things work out.\nFyi here's a paper by @sblionel at a J3 meeting last year on user and library exceptions: https://j3-fortran.org/doc/year/19/19-207.txt"
                }
            ]
        },
        {
            "number": 171,
            "user": "vansnyder",
            "date": "2020-05-09 20:13:06+00:00",
            "title": "Support for Containers",
            "text": "I proposed a system to support development of containers at meeting 219 in Tokyo. It was ruled \"out of order,\" even though at meeting 216 in Berkeley WG5 had agreed to develop support for development of containers rather than to provide specific containers. The paper was 19-168, attached herewith.\n19-168.pdf",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 20:14:36+00:00",
                    "text": "Opened twice by mistake"
                }
            ]
        },
        {
            "number": 170,
            "user": "vansnyder",
            "date": "2020-05-09 20:12:52+00:00",
            "title": "Support for containers",
            "text": "I proposed a system to support development of containers at meeting 219 in Tokyo. It was ruled \"out of order,\" even though at meeting 216 in Berkeley WG5 had agreed to develop support for development of containers rather than to provide specific containers. The paper was 19-168, attached herewith.\n19-168.pdf",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-05-23 19:15:44+00:00",
                    "text": "@vansnyder wrote on May 9, 2020, 4:12 PM EDT:\n\nI proposed a system to support development of containers at meeting 219 in Tokyo. It was ruled \"out of order,\" even though at meeting 216 in Berkeley WG5 had agreed to develop support for development of containers rather than to provide specific containers. The paper was 19-168, attached herewith.\n19-168.pdf\n\n@vansnyder,\nI've read your proposal and even though I can't claim to understand most of it and thus am unclear on many of the items therein, I agree with the concept of language support for the development of containers which would be a natural extension of the concept of derived types (and procedures that operate on derived types including the type-binding facility).\nCan you post here the smallest list of additional items (iterators?) that can be added to the base Fortran language standard that you think will make development of containers easier?  By development, I mean by other library writers who want to roll out their own containers for others to use e.g., FOSS minded, commercial entities, etc."
                },
                {
                    "user": "vansnyder",
                    "date": "2022-04-23 21:00:24+00:00",
                    "text": "\"Can you post here the smallest list of additional items (iterators?) that can be added to the base Fortran language standard that you think will make development of containers easier?\"\nUpdaters (some call them setters) would be one of them. The proposal in 19-168 was an attempt for an unified structure providing a data declaration for a container, together with procedures to operate on it, along with uniform syntax so that if one chose to change the representation of the data, the syntax to reference it would not change."
                }
            ]
        },
        {
            "number": 169,
            "user": "ghost",
            "date": "2020-04-03 08:18:10+00:00",
            "title": "\"select rank()\" should be more permissive.",
            "text": "One of the new features in F2018 is assumed-rank arrays and \"select rank()\" construct.\nthe \"select rank()\" construct should be allowed to accept one or more scalar integer, like \"select case()\"\nexample:\nsubroutine sub(a)\n  integer :: a(..)\n  select rank(a)\n    rank(0)\n      ...\n    rank(1:3)\n      ...\n    rank(4:)\n      ...\n  end select\nend subroutine sub\nthis will allow for more generic programming.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2020-04-03 16:35:40+00:00",
                    "text": "What would you do in the rank(1:3) block that would be correct and useful, yet couldn't be done with if (rank(a)>=1.and.rank(a)<=3) then ... end if?"
                },
                {
                    "user": "ghost",
                    "date": "2020-04-03 16:53:13+00:00",
                    "text": "An assumed-rank variable name must not appear in a designator or expression except as one of the following:\n\nAn actual argument corresponding to a dummy argument that is assumed-rank\nThe argument of the C_LOC function in the ISO_C_BINDING intrinsic module\nThe first argument in a reference to an intrinsic inquiry function\nThe selector of a SELECT RANK construct\n\nAs you can see there are few operations that you can do with an assumed-rank array unless it is  inside a \"select rank()\" construct.\nfor example:\nsubroutine sub(a,b)\n  integer :: a(..)\n  ....\n  a = 0.\n  ...\nend subroutine"
                },
                {
                    "user": "klausler",
                    "date": "2020-04-03 16:56:41+00:00",
                    "text": "Your if (a/=b)  isn't going to do what you think it will, SELECT RANK or not."
                },
                {
                    "user": "ghost",
                    "date": "2020-04-03 16:57:42+00:00",
                    "text": "Your if (a/=b) isn't going to do what you think it will, SELECT RANK or not.\n\nI corrected the example."
                },
                {
                    "user": "klausler",
                    "date": "2020-04-03 17:12:33+00:00",
                    "text": "Ok.  But that kind of rank-independent programming would be just as useful outside a multiple-rank case of a SELECT RANK, if that feature were to exist."
                },
                {
                    "user": "ghost",
                    "date": "2020-04-03 17:16:46+00:00",
                    "text": "It would be better if they remove those restrictions on assumed-rank arrays outside of select rank."
                },
                {
                    "user": "klausler",
                    "date": "2020-04-03 17:29:14+00:00",
                    "text": "That's basically my point (or rather, absent more rank-independent features, the multi-rank RANK case doesn't do much good; and given more rank-independent features, the multi-rank RANK case isn't as valuable).\nI can see a multi-rank RANK case being more useful today (absent more rank-independent features) if SELECT RANK could accept multiple assumed-rank arrays."
                }
            ]
        },
        {
            "number": 168,
            "user": "certik",
            "date": "2020-03-23 22:11:42+00:00",
            "title": "Using mixedCase",
            "text": "@everythingfunctional wrote in #56 (comment) and I am moving it to a separate issue here:\n\nAs a side note, what's the community consensus on mixed case? I've been working for the past few years under the assumption that it was ok to use mixed case as an aid to the reader, even if the compiler didn't care.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-23 22:16:52+00:00",
                    "text": "The Fortran community has historically been agnostic if you use mixed case or upper case or lower case, so from this perspective, you can use whatever you prefer.\nHowever, instead of each of us using incompatible naming conventions, I would like if we can come together as a community, and agree on a more unified style that we all follow. And then provide tooling (compilers) that can enforce it. Similar to Python's PEP8.\nI like the Python's approach: https://www.python.org/dev/peps/pep-0008/#function-and-variable-names:\n\nmixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility.\n\nand I suggest we follow the same.\nSee also the discussion at:\nfortran-lang/stdlib#3\nwhich lead to:\nhttps://github.com/fortran-lang/stdlib/blob/5d1e09131cad56467549ecd9d6b977cec19b2f35/STYLE_GUIDE.md\nAlso https://www.fortran90.org/src/best-practices.html#naming-convention. One can browse current open source Fortran codes here: https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects. Some codes use mixedCase, but most codes seem to use lower_case_with_underscores."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2020-06-04 13:48:27+00:00",
                    "text": "This is a related to #118\nI also like Pythons approach, and my Fortran programming is atm close to pythons PEP8:\n\nvariables in lower_case_with_underscores\ntypes in CapWords convention\nparameters in SCREAMCASE\n\nAdditionally, I follow two advises from the book 'Modern Fortran: Style and Usage':\n\nroutines in Upper_case_with_underscores. This is helpful to distinguish arrays from functions (which is not needed in python, because array access is with [ ]). In Fortran, for a = electrons(3), electrons could be both, an array and a function (although one with a stupid name).\nIf the type has only one word (i.e. Circle), I add an _t (i.e. Circle_t) this way, I can still use circle for an instance of Circle_t. Again in python due to case sensitivity, this is not needed. This way, I can also distinguish a type constructor from one-word functions."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 05:03:31+00:00",
                    "text": "I think what we need here is an automatic formatter that can enforce these things. For things where there are multiple opinions, we can allow it to be configurable, so that each project can set it up the way they like, similar to clang-format.\nI like all your suggestions, except the subroutines where I personally prefer all lowercase (but I understand your argument about arrays). But this can be configurable in the formatter."
                },
                {
                    "user": "HaoZeke",
                    "date": "2021-06-24 20:37:37+00:00",
                    "text": "For what its worth, I prefer camelCase myself. The snake_case variables to me seem longer somehow. Enforcing project level specifications feel out of scope for the J3 committee. Anything like PEP8 would be something for the standards committee but I would definitely strongly be against (completely ruins backward compatibility for one thing)."
                }
            ]
        },
        {
            "number": 167,
            "user": "certik",
            "date": "2020-03-09 15:26:36+00:00",
            "title": "Pros and Cons of making keywords reserved",
            "text": "Currently Fortran has non-reserved keywords: words like begin, end, subroutine, result can be freely used as variable names, but they also have semantic meaning in the right context.\nHere is a full list of the non-reserved keywords:\nabstract, all, allocatable, allocate, assignment, associate, asynchronous,\nbackspace, bind, block, call, case, character, class, close, codimension, \ncommon, complex, concurrent, contains, contiguous, continue, critical, cycle,\ndata, deallocate, default, deferred, dimension, do, dowhile, double, elemental,\nelse, end, endif, end, enddo, end, endwhere, entry, enum, enumerator,\nequivalence, errmsg, error, exit, extends, external, file, final, flush, \nforall, format, formatted, function, generic, go, if, implicit, import, impure,\nin, include, inout, inquire, integer, intent, interface, intrinsic, is, kind,\nlen, local, local_init, logical, module, mold, name, namelist, nopass,\nnon_intrinsic, non_overridable, non_recursive, none, nullify, only, open,\noperator, optional, out, parameter, pass, pointer, precision, print, private,\nprocedure, program, protected, public, pure, quiet, rank, read, real, \nrecursive, result, return, rewind, save, select, sequence, shared, source,     \nstat, stop, submodule, subroutine, target, team, team_number, then, to, type,\nunformatted, use, value, volatile, where, while, write\n\nThe advantage of these being non-reserved keywords is that the standard can add new keywords in the future and they will not invalidate current code, because users can still use them as variable (or function, module, etc.) names.\nThe disadvantages are:\n\nit makes the parsing much harder (and slower)\nthe automatic highlighting in editors, GitHub (see the example below) and elsewhere will incorrectly highlight variables such as result as if they were keywords, even though they are not in that context (that is because the syntax highlighters are based on regex expressions, as opposed to using a full Fortran parser that could disambiguate semi-reserved keywords)\nit prevents potential new features such as #130\n\nFurthermore, in my own codes and other codes, I recommend not to use these non-reserved keywords as variable names anyway. For example, one should not write code like this, even though it's strictly speaking valid:\ninteger function end(return,&\ninteger)result(function);;;;&\ninteger integer,return;;;;;;&\n;;function=return;if(return>&\ninteger)return;;;;;function=&\ninteger;;end function end;;;;\nI opened this issue so that we can brainstorm what can be done about this. Here is an idea:\n\nStandard will remain with non-reserved keywords (no change)\nCompilers can provide warnings when a code uses a non-reserved keyword for variable / function / etc. names\nAs a community we will provide recommendation to enable the compiler warnings and ensure code is free of such warnings\nIf a compiler knows the code is not using non-reserved keywords for anything else than the actual keyword, then one can write much easier parsers for Fortran to enable better tooling (the tooling would only work for code that is warning free --- such as all my codes for example, so this would be very useful)",
            "is_open": true,
            "labels": [
                "Clause 6"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-09 16:07:57+00:00",
                    "text": "(I failed to find the definition now of \"semi-reserved keywords\".  When I researched this about a year ago, I thought that's exactly what Fortran does. But perhaps the term means something else. Either way, that does not change the details of the above issue.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-03-09 21:04:26+00:00",
                    "text": "@certik wrote:\n\n..\nI opened this issue so that we can brainstorm what can be done about this. Here is an idea: ..\n\nI've wondered about this as well.  Keeping in mind Fortran does not have a concept of NAMESPACEs but the language standard does have a concept of a scoping unit, a thought I have had for a while is whether a prefix-spec (a la PURE for procedures) can be introduced into the language  which signals to the processor a scoping unit will not use any of the language keyword as a name for any of the entities (derived type names, named constants, variables, dummy arguments, etc.) in that scoping unit and also in any nested scoping units in that scope!\nPossible names for this new prefix-spec are PURE, or SIMPLE, or CLEAN, or NEAT, etc.\nFor example, MODULEs and SUBMODULEs are scoping units as is a main program, or an external subprogram, or an interface body, a derived type definition, a BLOCK construct, etc.\nSay the language allowed\nPURE module foo_m  !<-- Suggested new prefix-spec\n   use ..\n   ..\n   <some_type>, parameter :: ..\n   type :: t\n     ..\n   end type\n   interface ..\n     ..\n   end interface\n   ..\ncontains\n   subroutine ..\n      ..\n   end subroutine ..\n   ..\n   function ..\n      ..\n   end function ..\n   ..\nend module ..\nAnd this were to inform the processor the above scoping unit cannot have a name clash in any entity in that scope with any of the keywords in the language, as listed by @certik above, then I think it provides a way to enforce a good coding practice (GCP) while also enabling better/faster tooling with such \"clean\" codes in Fortran.\nJust a thought,"
                },
                {
                    "user": "certik",
                    "date": "2020-03-09 21:57:30+00:00",
                    "text": "@FortranFan good point, I haven't thought of that.\nI really like the #83 approach, so there would simply be edition 202Y, which would enforce that keywords are not clashing. Existing code would stay with edition 202X, which allows keywords to clash, so existing code would continue to run unmodified forever. But if you want to upgrade to 202Y, one might need to ensure that keywords are not clashing."
                },
                {
                    "user": "sblionel",
                    "date": "2020-03-11 21:46:12+00:00",
                    "text": "I disagree that there are ANY reserved or \"semi-reserved\" words in Fortran. At most there are syntax rules prohibiting statements that look like END but aren't. I've worked on Fortran parsers, so I think I would know if any kind of reserved words existed. A Fortran parser doesn't know about any reserved words.\n@certik , please indicate why you think some words are \"semi-reserved\". Examples would be helpful.\n[Edited to be more constructive.]"
                },
                {
                    "user": "zjibben",
                    "date": "2020-03-11 22:28:23+00:00",
                    "text": "@sblionel this comment comes off a tad aggressive. Please keep in mind our Code of Conduct, in particular we would like to create a welcoming environment for everyone here. Respectful disagreement is always encouraged!"
                },
                {
                    "user": "sblionel",
                    "date": "2020-03-11 23:03:33+00:00",
                    "text": "I thought I was respectfully disagreeing. If you think otherwise, please shoot me an email and explain."
                },
                {
                    "user": "certik",
                    "date": "2020-03-17 21:13:24+00:00",
                    "text": "I edited the issue description and changed \"semi-reserved\" to \"non-reserved\". As I mentioned above, I was not sure about the terminology.\nSince Steve asked, here is an example that Intel Fortran rejects, because it uses a keyword:\n      parameterx = parameterx\n      end\nYou have to compile in fixed-form mode (ifort -c a.f -o a.o). If one changes parameterx to parametex, then it compiles. One can probably find other such examples.\nFinally, I should mention that people have asked me why we cannot make keywords reserved in Fortran that it would simplify a lot of things. So this is not some academic exercise. The community asked us, and I see it as our job to have a good answer plus associated discussion why this cannot be done (if that is the case)."
                },
                {
                    "user": "sblionel",
                    "date": "2020-03-17 21:21:45+00:00",
                    "text": "That example fails because, in fixed form, it uses a non-standard feature, the \"typeless PARAMETER\" statement. This had been part of FORTRAN 77 right up until the final version, where it was changed to the form in the standard today with parentheses and a typed value.\nD:\\Projects>type t.f\n      parameterx = parameterx\n      end\nD:\\Projects>ifort /stand t.f\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.1.0.166 Build 20191121\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\n\nt.f(1): warning #7373: Fixed form source is an obsolescent feature in Fortran 2008.\n      parameterx = parameterx\n^\nt.f(1): warning #6474: Fortran 2008 does not allow this form of the PARAMETER statement.\n      parameterx = parameterx\n^\nt.f(1): error #6592: This symbol must be a defined parameter, an enumerator, or an argument of an inquiry function that evaluates to a compile-time constant.   [PARAMETERX]\n      parameterx = parameterx\n-------------------^\n\nDEC Fortran went ahead and implemented the typeless form because they thought it would become standard. Then they had to support both. This experience resulted in the DEC team (now Intel) refusing to implement features before they become published (either in a standard or a TS.)\nA compiler without this extension would not have this problem. The example you presented does not reflect the standard."
                },
                {
                    "user": "certik",
                    "date": "2020-03-17 21:23:40+00:00",
                    "text": "Indeed, I verified that gfortran compiles this without a problem."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-08 15:20:49+00:00",
                    "text": "Coming across this thread from a different context, but I do sometimes allow myself to use some of the words in the words in the Ondrej's list.    In particular, to emulate STL containers, I allow myself to have type-bound procedures named begin and end.    (And it was not that many years ago that gFortran would break when doing this sort of thing.)    Other than highlighting, I don't find such limited usage confusing.     But I agree with the general rule to avoid such things."
                }
            ]
        },
        {
            "number": 166,
            "user": "srinathv",
            "date": "2020-03-09 15:21:33+00:00",
            "title": "bfloat16 in anticipation for hardware implementation.",
            "text": "In light of possible hardware coming to the market with bfloat16 implemented what is the desire for the fortran community to support bfloat16? If not in the standard, is there a preferred way to approximate (or downcast)?",
            "is_open": true,
            "labels": [
                "duplicate"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-09 15:36:52+00:00",
                    "text": "@srinathv thanks a lot for the proposal. Note that it's a duplicate of #3."
                }
            ]
        },
        {
            "number": 165,
            "user": "thenlich",
            "date": "2020-03-03 08:35:05+00:00",
            "title": "IEEE pi trigonometric functions",
            "text": "To: J3                                                     J3/18-276r1\nFrom: Lorri Menard\nSubject: IEEE pi trigonometric functions\nDate: 2018-October-18\nI  Introduction\nAt m217 J3 agreed to consider adding degree-argument versions of\nsome of the trigonometric intrinsic functions.\nAs part of the discussion it was suggested that we also add the\nIEEE pi versions of the these same trigonometric intrinsic functions.\nII  Use cases\nThis provides a portable mechanism for programs that need to use\nthe standard IEEE \"pi\" functions.   It will\nIII What I have in mind\nOnly generic functions are to be added for these names, with\nbehavior to match that listed in IEEE 754 latest.\n\n(*) ACOSPI\nACOSPI(x) returns acos(x)/pi in the domain of [-1,+1]\n(*) ASINPI\nASINPI(x) returns asin(x)/pi in the domain of [-1,+1]\nATANPI\nATANPI(x)  returns atan(x)/pi in the domain of (-inf,+inf)\nCOSPI\nCOSPI(x) returns cos(pi * x) in the domain of (-inf, +inf)\nSINPI\nSINPI(x) returns sin(pi * x) in the domain of (-inf, +inf)\n(*) TANPI\nTANPI(x) returns tan(pi * x) in the domain of (-inf, +inf)\nATAN2PI\nATAN2PI(y,x) has a number of special rules, which should\nbe handled as described in IEEE 754-201x\n\nThe intrinsics marked with \"(*)\" weren't found in the IEEE 754-2008\nversion of the document, but we are assured that these are being\nadded to the next release of IEEE 754.\nAddendum:  Confirmed that these were found in the IEEE 754-201x\ndraft document.",
            "is_open": true,
            "labels": [
                "Fortran 2023",
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "thenlich",
                    "date": "2020-03-03 08:50:41+00:00",
                    "text": "To: J3                                                     J3/19-204r1\nFrom: Tom Knox\nSubject: IEEE Circular trigonometric functions (US05)\nDate: 2019-August-07\nReference:  19-157r1, 18-007r1\n1 Introduction\nAddition of the circular trigonometric functions was given specifications\nin m218, during which 19-157r1 was passed.  This paper makes minor\ncorrections and proposes edits.\n2 Specifications\nThese elemental intrinsics are generic and not specific.\nAll would be similar to their radian counterparts except that the\nargument(s) or return values would be half-revolutions.\n3 Syntax\nACOSPI (X)\nDescription: Inverse circular cosine function.\nClass: Elemental function.\nArgument: X shall be of type real with a value that satisfies the \n          inequality |X| <= 1.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to arccos(X)/pi. It is expressed in\nhalf-revolutions and lies in the range of 0 to 1 (inclusive).\n\nASINPI (X)\nDescription: Inverse circular sine function.\nClass: Elemental function.\nArgument: X shall be of type real with a value that satisfies the \n          inequality |X| <= 1.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to arcsin(X)/pi. It is expressed in half-revolutions \nand lies in the range of -1/2 to 1/2 (inclusive).  \n\nATANPI (X) or ATANPI (Y, X) \nDescription: Inverse circular tangent function.\nClass: Elemental function.\nArguments: \n Y     shall be of type real.\n X     If Y appears, X shall be of type real with the same kind type\n       parameter as Y. If Y has the value zero, X shall not have the\n       value zero. If Y does not appear, X shall be of type real.\nResult Characteristics: Same as X.\nResult Value: If Y appears, the result is the same as the result of\nATAN2PI (Y, X). If Y does not appear, the result is expressed in\nhalf-revolutions, with a value equal to a processor-dependent\napproximation to arctan(X)/pi, and lies in the range\n-1/2 to 1/2 (inclusive).\n\nATAN2PI (Y, X) \nDescription: Inverse circular tangent function.\nClass: Elemental function.\nArguments: \n Y     shall be of type real.\n X     X shall be of the same type and kind type\n       parameter as Y. If Y has the value zero, X shall not have the\n       value zero. \nResult Characteristics: Same as X\nResult Value: The result is expressed in half-revolutions and has a\nvalue equal to a processor-dependent approximation to arctan(Y/X)/pi\nif X /= 0; it lies in the range -1 to 1 (inclusive). If Y > zero,\nthe result is positive. If Y < zero, the result is negative. If\nY = zero, the result is Y (if X > zero), approximately 1 (if X < zero\nand Y is positive real zero or the processor does not distinguish\nbetween positive and negative real zero) or approximately -1 (if\nY is negative real zero). If X = zero, the absolute value of the\nresult is approximately 1/2.\n\nCOSPI (X)\nDescription: Circular cosine function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in\nhalf-revolutions.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to cos(X * pi). \n\nSINPI (X)\nDescription: Circular sine function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in\nhalf-revolutions.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to sin(X * pi). \n\nTANPI (X)\nDescription: Circular tangent function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in\nhalf-revolutions.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to tan(X * pi).  \n\n4 Edits to 18-007r1\n[...]\nExample. ACOSPI (-1.0) has the value 1.0 (approximately).\n[...]\nExample. ASINPI (1.0) has the value 0.5 (approximately).\n[...]\nExample. ATANPI (1.0) has the value 0.25 (approximately).\n[...]\nExample. ATAN2PI (1.0, 1.0) has the value 0.25 (approximately).  If Y has the value [1 1; -1 -1] and X has the value [-1 1; -1 1], the value of ATAN2PI (Y, X) is approximately [0.75 0.25; -0.75 -0.25].\n[...]\nExample. COSPI (1.0) has the value -1.0 (approximately).\n[...]\nExample. SINPI (1.0) has the value 0.0 (approximately).\n[...]\nExample. TANPI (1.0) has the value 0.0 (approximately)."
                }
            ]
        },
        {
            "number": 164,
            "user": "thenlich",
            "date": "2020-03-02 18:35:53+00:00",
            "title": "Degree trigonometric functions",
            "text": "To: J3                                                     J3/18-139r1\nFrom: Steve Lionel @sblionel\nSubject: Degree trigonometric functions\nDate: 2018-February-16\nMany if not most Fortran implementations support, as extensions,\ndegree-argument (or return value) versions of some of the trigonometric\nintrinsic functions, and these are widely used. In the spirit of\nstandardizing existing practice, we should add the following generic\nintrinsic functions to the standard:\n\nACOSD\nASIND\nATAN2D\nATAND\nCOSD\nSIND\nTAND\n\nAll of these would be similar to their radian counterparts\nexcept that the argument(s) or return values would be in degrees.\nDuring J3 discussion it was noted:\n\nThe hyperbolic functions (COSH, SINH, etc.) do not use radians and\ntherefore need no degree equivalents.\nWhile ATAN2 is effectively replaced by the two-argument form of\nATAN, it was felt appropriate to include ATAN2D in support of\nexisting practice.",
            "is_open": true,
            "labels": [
                "Fortran 2023",
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "thenlich",
                    "date": "2020-03-03 08:01:40+00:00",
                    "text": "To: J3                                                     J3/18-272r1\nFrom: Lorri Menard\nSubject: Degree trigonometric functions\nDate: 2018-October-17\nReference:  m215/18-139r1\nI  Introduction\n[...]\nII  Use cases\nThis provides a portable mechanism for programs that have\nmathematical formulas that need the actual degrees.\nIII What I have in mind\nFirst, the prevailing principle is that only generic functions\nare to be added, even if some vendors (ahem) may have provided\nspecific versions.\n[...]\nFinally, add the generic intrinsics listed above."
                },
                {
                    "user": "thenlich",
                    "date": "2020-03-03 08:22:58+00:00",
                    "text": "To: J3                                                     J3/19-203r1\nFrom: Tom Knox\nSubject: Degree trigonometric functions (US04)\nDate: 2019-August-07\nReference:  19-145r2, 18-007r1\n1 Introduction\nAddition of the degree trigonometric functions was given specifications\nin m218, during which 19-145r2 was passed.  This paper makes minor\ncorrections and proposes edits.\n2 Specifications\nThese elemental intrinsics are generic and not specific.\nAll would be similar to their radian counterparts except that the\nargument(s) or return values would be in degrees.\n3 Syntax\nACOSD (X)\nDescription: Arccosine (inverse cosine) function in degrees.\nClass: Elemental function.\nArgument: X shall be of type real with a value that satisfies the \n          inequality |X| <= 1.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to arccos(X). The result is expressed in degrees\nand lies in the range of 0 to 180 (inclusive).\n\nASIND (X)\nDescription: Arcsine (inverse sine) function in degrees.\nClass: Elemental function.\nArgument: X shall be of type real with a value that satisfies the \n          inequality |X| <= 1.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to arcsin(X). The result is expressed in degrees\nand lies in the range -90 to 90 (inclusive).  \n\n\nATAND (X) or ATAND (Y,X) \nDescription: Arctangent (inverse tangent) function in degrees.\nClass: Elemental function.\nArguments: \n Y     shall be of type real.\n X     If Y appears, X shall be of type real with the same kind type\n       parameter as Y. If Y has the value zero, X shall not have the\n       value zero. If Y does not appear, X shall be of type real.\nResult Characteristics: Same as X\nResult Value: If Y appears, the result is the same as the result of\nATAN2D (Y, X). If Y does not appear, the result is expressed in\ndegrees, with a value equal to a processor-dependent approximation\nto arctan(X), and lies in the range -90 to 90 (inclusive).\n\nATAN2D (Y,X) \nDescription: Arctangent (inverse tangent) function in degrees.\nClass: Elemental function.\nArguments: \n Y     shall be of type real.\n X     X shall be of the same type and kind type\n       parameter as Y. If Y has the value zero, X shall not have the\n       value zero. \nResult Characteristics: Same as X\nResult Value: The result is expressed in degrees and has a value\nequal to a processor-dependent approximation to arctan(Y/X) if\nX /= 0; it lies in the range -180 to 180 (inclusive). If Y >\nzero, the result is positive. If Y < zero, the result is negative.\nIf Y = zero, the result is Y (if X > zero), approximately 180 (if\nX < zero and Y is positive real zero or the processor does not\ndistinguish between positive and negative real zero) or approximately\n-180 (if Y is negative real zero). If X = zero, the absolute value of\nthe result is approximately 90.\n\nCOSD (X)\nDescription: Degree cosine function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in degrees.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to cos(X), where X is expressed in degrees.\n\nSIND (X)\nDescription: Degree sine function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in degrees.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to sin(X), where X is expressed in degrees.\n\nTAND (X)\nDescription: Degree tangent function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in degrees.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to tan(X), where X is expressed in degrees.\n\n4 Edits to 18-007r1\n[...]\nExample. ACOSD (-1.0) has the value 180.0 (approximately).\n[...]\nExample. ASIND (1.0) has the value 90.0 (approximately).\n[...]\nExample. ATAND (1.0) has the value 45.0 (approximately).\n[...]\nExample. ATAN2D (1.0, 1.0) has the value 45.0 (approximately).  If Y has the value [1  1; -1 -1] and X has the value [-1 1; -1 1], the value of ATAN2D (Y, X) is approximately [135.0 45.0; -135.0 -45.0].\n[...]\nExample. COSD (180.0) has the value -1.0 (approximately).\n[...]\nExample. SIND (180.0) has the value 0.0 (approximately).\n[...]\nExample. TAND (180.0) has the value 0.0 (approximately)."
                },
                {
                    "user": "thenlich",
                    "date": "2020-03-04 13:41:00+00:00",
                    "text": "A logical next step would be to add conversion functions between degrees and radians to the standard. Usual function names are: rad2deg, deg, degrees; deg2rad, rad, radians.\nUse case: Often it is necessary to use angles in radians in calculation, e.g. to calculate arc length of a unit circle. Example: the involute function inv(x) = tan(x) - x.\nCorrectly rounded multiplication by arbitrary precision constants (\u03c0/180) or (180/\u03c0) is non-trivial.\nDEGREES (X)\nDescription: Radians to degrees conversion function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in radians.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to X, where X is expressed in degrees.\n\nRADIANS (X)\nDescription: Degrees to radians conversion function.\nClass: Elemental function.\nArgument: X shall be of type real, regarded as a value in degrees.\nResult Characteristics: Same as X.\nResult Value: The result has a value equal to a processor-dependent\napproximation to X, where X is expressed in radians.\n\n4 Edits\n[...]\nExample. DEGREES (3.141593) has the value 180.0 (approximately).\n[...]\nExample. RADIANS (-360.0) has the value -6.283185 (approximately).\nTODO\nRADIANS(): define additional (optional) parameters\n\n(intent: in) to control range reduction to -360\u00b0...360\u00b0; 0\u00b0...360\u00b0; -180\u00b0...180\u00b0; 0\u00b0...45\u00b0 etc.\n(intent: out) to inform about in which 90\u00b0 or 45\u00b0 sector the angle lies."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 13:55:05+00:00",
                    "text": "Alternatively these conversion functions can go into stdlib.\n\u2026\nOn Wed, Mar 4, 2020, at 6:41 AM, Thomas Henlich wrote:\n A logical next step would be to add conversion functions between\n degrees and radians to the standard. Usual function names are: deg2rad,\n deg, degrees; rad2deg, rad, radians.\n\n Use case: Often it is necessary to use angles in radians in\n calculation, e.g. to calculate arc length of a unit circle. Example:\n the involute function inv(x) = tan(x) - x.\n\n Correctly rounded multiplication by arbitrary precision constants\n <http://perso.ens-lyon.fr/jean-michel.muller/MultConstant.html> (\u03c0/180)\n or (180/\u03c0) is non-trivial.\n\n `DEGREES (X)\n Description: Radians to degrees conversion function.\n Class: Elemental function.\n Argument: X shall be of type real, regarded as a value in radians.\n Result Characteristics: Same as X.\n Result Value: The result has a value equal to a processor-dependent\n approximation to X, where X is expressed in degrees.\n\n RADIANS (X)\n Description: Degrees to radians conversion function.\n Class: Elemental function.\n Argument: X shall be of type real, regarded as a value in degrees.\n Result Characteristics: Same as X.\n Result Value: The result has a value equal to a processor-dependent\n approximation to X, where X is expressed in radians.\n `\n 4 Edits\n  [...]\n  Example. DEGREES (3.141593) has the value 180.0 (approximately).\n  [...]\n  Example. RADIANS (-360.0) has the value -6.283185 (approximately).\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#164?email_source=notifications&email_token=AAAFAWAUW2GOL5JSWPL4DNDRFZK6ZA5CNFSM4K72DTD2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENX4ULI#issuecomment-594528813>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEAWF2PSLZRLI5RV6LRFZK6ZANCNFSM4K72DTDQ>."
                },
                {
                    "user": "klausler",
                    "date": "2020-03-04 17:13:32+00:00",
                    "text": "As another alternative: intrinsic functions that provide multiplication and division by a constant of a distinct (more precise) kind of REAL, returning a result of the kind of the not-necessarily-constant argument.  Then DEGREES(x) = DIVBY(180 * x, 3.141592653589793238462643383279503E0_16)."
                },
                {
                    "user": "thenlich",
                    "date": "2020-03-04 17:59:01+00:00",
                    "text": "The Fortran standard is not concerned where or how these functions would be implemented (the word \"processor-dependent\" is used a lot there), just with what they should do, and how they would be used in a standard-conforming program."
                }
            ]
        },
        {
            "number": 163,
            "user": "certik",
            "date": "2020-03-02 16:00:46+00:00",
            "title": "Meta: how proposals are developed",
            "text": "@zjibben and I would like to summarize this in the README, so that we are all on the same page what the process is.\nIn fact, there seems to be a little disagreement how new features should be developed at the Committee. Some members of the Committee prefer to start with writing down requirements, pass it. Then develop specification (specs) based on the requirements. Pass it. Then develop syntax, pass it. And finally edits to the standard and pass it. 4 papers.\n@zjibben and I think we should instead use the following approach, which is similar, but different:\n\n\nProposal: Develop a proposal that discusses use cases both before and after the feature. It discusses syntax and how the new feature should be used. The proposal does not have to have all the details fleshed out, but it needs to be clear to the reader what the feature should be and it concentrates on syntax and properties of the new feature.\n\n\nRequirements: From the Proposal, extract Requirements.\n\n\nSpecification: From the Requirements only, logically derive Specification.\n\n\nSyntax: From the Specification, logically derive and propose Syntax.\n\n\nIterate: Does 3. and 4. agree with the Proposal at 1. ? If it does not, then we need to iterate the process 1. - 4. until it agrees and is self consistent.\n\n\nEdits: Write Edits to the standard.\n\n\nThe advantage of this approach 1. - 6. is that it ensures both:\na) The feature is what the community wants (this is ensured by 1.)\nb) The feature is the best way to achieve something, i.e., there is not an alternate way to develop a feature (this is ensured by extracting the abstract requirements in 2. and then ensuring that the feature in 3. and 4. logically follows from it, and that it agrees with 1., as ensured in 5.)\nOn the other hand, by starting with Requirements right away, we ensure consistent feature, but we cannot ensure we end up with a feature that the community wants. In fact, by observing how features get developed at the Committee, very often we see features that are not what the community wants, because 1. was skipped, and we went straight to 2.\nExample:\nAn example proposal that got recently passed by the Committee that follows this process is #161, where:\n1: https://j3-fortran.org/doc/year/18/18-273r1.txt\n2, 3, 4: https://j3-fortran.org/doc/year/19/19-201r1.txt\n5: In this case 3. and 4. agree with 1.\n6: https://j3-fortran.org/doc/year/20/20-116.txt\ncc @FortranFan.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-03-02 23:29:20+00:00",
                    "text": "Please see this: https://mailman.j3-fortran.org/pipermail/j3/2018-July/010806.html\nMy understanding is the J3 approach has a subtle but important attribute in that items 2 and 3 are \"Formal Requirements\" and \"Formal Specifications\" i.e., the term \"Formal\" brings these 2 aspects closer to the \"standardese\" used in the IEC ISO document.\nBut for proposals developed on a forum such as this one, I suggest focusing on simple language during the initial steps and inserting a step after 1 in the list above which is Needs where the proposer can explain in simple terms what the proposal should achieve i.e., add to or extend or not be affected in the language due to proposal e.g., with #156, the Needs section might clearly state \"it must be possible to define a variable of a derived type with a protected component in an intrinsic assignment."
                }
            ]
        },
        {
            "number": 162,
            "user": "certik",
            "date": "2020-02-29 18:32:31+00:00",
            "title": "Proposal List for 202X",
            "text": "Here is the list of issues approved by WG5 to go into 202X:\n\nUK01 - Extend procedure C_F_POINTER to allow a Fortran array pointer to have lower bounds other than 1.\nUS01 - Allow much longer statement lines and overall statement length.\nUS02 - Require the processor to report cases where over-long lines or statements result in lost information.\n#187 US03 - SPLIT string intrinsic (original proposal was to keep all module intrinsics from the withdrawn Part 2 (ISO_VARYING_STRINGS).\n#164 US04 - Trig functions with arguments in degrees and arc versions with results in degrees.\nUS05 - Trig functions with arguments implicitly scaled by PI.\nUS06 - SELECTED_LOGICAL_KIND to return a KIND of logical based on its minimum storage size.\nUS07 - Additional named constants, LOGICAL8, LOGICAL16, LOGICAL32, LOGICAL64, in ISO_FORTRAN_ENV to specify KINDS supported for type LOGICAL.\n#13 US08 - Additional named constant, REAL16, in ISO_FORTRAN_ENV to specify whether the processor supports a 16-bit REAL KIND.\nUS09 - Intrinsics for converting between C strings and Fortran strings.\nUS10 - AT format editing specifier. Has the effect of TRIM on the corresponding character list item before output.\nUS11 - Control over leading zeros in output of REAL values.\nUS12 - Allow an array of a type that has an allocatable coarray component.\n#20 US13 - Syntax and semantics for a \"Put with Notify\" operation.\n#160 US14 - Allow deferred-length character variables in more locations, including as actual arguments corresponding to IOMSG and ERRMSG arguments for similar variables in specifiers.  Also allow for internal I/O.\n#161 US15 - SIMPLE procedures. A form of Super-Pure that disallows references to global data.\n#158 US16 - TYPEOF and CLASSOF type declarations to indicate the object being declared has the same type/class as another object. Useful to ensure a local variable in a procedure has the same type as a dummy argument, or that two dummy arguments have the same type.\n#157 US17 - Syntax to specify an element or section of an array with arbitrary rank.\n#157 US18 - Syntax for generic specification of rank and bounds of an object.\n#156 #16 US19 - Protected components.\n#17 US20 - Reduction specifier for DO CONCURRENT.\n#11 US21 - Typed enumerators.\n#183 US22 - Conditional expressions. (alternatively: #19 US26 - Short-circuit logical operators.)\n#18 US23 - Enhancements to BOZ constants.\n#5 US27 - Syntax to specify that the target of a dummy argument pointer is not to be changed (INTENT applies to the pointer, not its target)\n\nThe list is described in the document N2165 US Feature list proposals for F202X (PL22.3) as available from https://wg5-fortran.org/documents.html, but unfortunately the link is dead. We also found the list in the minutes N2169 Minutes of the August 2019 Meeting in Tokyo available from https://wg5-fortran.org/f202x.html. Just in case, I am attaching the N2169 document to this issue, so that it does not get lost.\nOnce all such ideas are fully developed and passed by the J3 and WG5 Committees, then the 202X standard will get out, and we will work on 202Y.\nIn order to speed up the 202X release as well as to ensure that the community agrees with the proposals that the committee passes, I encourage wide community participation in the proposals for these features.\nISO-IECJTC1-SC22-WG5_N2169_Minutes_of_the_August_2019_Meeting_in_Tokyo.txt",
            "is_open": true,
            "labels": [
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-29 18:37:17+00:00",
                    "text": "As a community, I suggest we provide use cases (code) and syntax that we like. I can then ensure that the Committee's final proposals will work with the use cases that the community wants."
                },
                {
                    "user": "zjibben",
                    "date": "2020-03-02 22:54:14+00:00",
                    "text": "I found a copy of N2165 on my hard drive:\nISO-IECJTC1-SC22-WG5_N2165_US_Feature_list_proposals_for_F202X.txt\nThere are a few extra details that aren't in the minutes."
                },
                {
                    "user": "zjibben",
                    "date": "2020-03-02 23:12:33+00:00",
                    "text": "Here is the list of items, with added issue numbers where I found them. Some work needs to be done yet to add issues or find ones I missed, then making sure the background papers are listed in the related issues. We might also update the issue names to include the USxx item number. Feel free to edit this comment to add new info.\nUpdate (Ondrej): I moved the list to the issue description above to make it more easier to see."
                },
                {
                    "user": "shahmoradi",
                    "date": "2020-07-03 20:58:43+00:00",
                    "text": "@certik Ondrej, I am not sure where my requests for enhancements should go on the J3 repository. So I am going to list it here and hopefully you will know much better or help realize where I should submit them:\n\n\nCoarray slicing (equivalent of MPI_gather)\nreal :: co_Vector[*]\nreal, allocatable :: LocalVector(:)\n...\nLocalVector = co_Vector[ 1 : num_images() ]\n...\nAs far as I am aware, coarray slicing is currently not supported in Fortran 2018. This feature, however, is highly desired for writing a more concise code and potentially enabling more compiler optimization. The equivalent standard-conforming code would be:\ninteger :: i\nreal :: co_Vector[*]\nreal, allocatable :: LocalVector(:)\n...\nallocate( LocalVector(1 : num_images()) )\ndo i = 1, num_images()\n    LocalVector(i) = co_Vector[i]\nend do\n...\n\n\nthe ability to use dummy optional arguments when not present in a procedure:\nfunction runSampler(chainSize)\n    integer, intent(in), optional :: chainSize\n    if (.not.present(chainSize)) chainSize = 10000\n    ...\nThis is similar to the RFE by Curcic et al, so I won't explain it further here.\n\n\nstandardized support for a minimal healthy subset of the C/Fortran preprocessing features. preprocessors are essential for writing scalable code and many compilers are fully or partially support some level of preprocessing. C has this as part of the language. Adding preprocessors to Fortran would ensure that the community's use of preprocessors is more disciplined and supported by the language standard.\n\n\nfurther support for template metaprogramming. I know that this is already a highly popular RFE. So I just suffice to mention my strong support for it."
                },
                {
                    "user": "certik",
                    "date": "2020-07-03 21:41:11+00:00",
                    "text": "@shahmoradi I moved your comment to #174, let's discuss there. This issue #162 is for proposals that are already approved for 202X."
                },
                {
                    "user": "h-vetinari",
                    "date": "2022-03-23 01:16:59+00:00",
                    "text": "Is there a good place to track the status/timeline of 202x? The WG5 page says:\n\nDevelopment Schedule\nThis is the current development schedule (see N2135) for Fortran 202x. See the Glossary for definitions of terms.\n\nStarted planning further revision 2017-06\nChoose issues that need attention 2018-06\nPreliminary choice of technical content 2019-08\nFinal choice of technical content 2020-06\nCD constructed 2021-06\nCD ballot initiated 2021-07\n\n\nthough the document from which this originates seems to be from 2017. I also looked at https://fortran-lang.org/ and https://fortran-lang.discourse.group/."
                }
            ]
        },
        {
            "number": 161,
            "user": "zjibben",
            "date": "2020-02-28 23:12:40+00:00",
            "title": "US15 Simple procedures",
            "text": "A procedure that does not reference outside variables is easier to offload to a device, or other off-chip processor.\n\n\nPURE procedures operate without writing to global variables beyond their arguments, SIMPLE procedures would be further restricted from referencing global variables beyond their arguments.\n\n\nhttps://j3-fortran.org/doc/year/18/18-273r1.txt (initial proposal)\nhttps://j3-fortran.org/doc/year/19/19-201r1.txt (requirements, specifications, and syntax)\nhttps://j3-fortran.org/doc/year/20/20-116.txt (edits)",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2020-03-02 17:39:00+00:00",
                    "text": "Another subtle benefit from using SIMPLE procedures is that SIMPLE procedure pointers don't need to waste space for a \"static link\" to potential host-associated objects; mere code address(es) suffice."
                }
            ]
        },
        {
            "number": 160,
            "user": "zjibben",
            "date": "2020-02-28 23:06:30+00:00",
            "title": "Auto-allocating processor messages",
            "text": "This feature is to address certain cases which require programmers to provide already-allocated strings of sufficient length, but the standard provides no mechanism to determine that length.\n\nhttps://j3-fortran.org/doc/year/19/19-252r2.txt\nhttps://j3-fortran.org/doc/year/20/20-122.txt",
            "is_open": true,
            "labels": [
                "Clause 12"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2020-03-02 22:12:49+00:00",
                    "text": "Uncharacteristically for Fortran, this proposal would change the behavior of some current conforming programs.  I suggested at the J3 meeting that the change be restricted to only automatically allocate deferred-length CHARACTER allocatable variables that are in a deallocated state, since that case is currently an error, but to no avail.\nThe case that worries me the most is that of internal writes to allocatable CHARACTER.  When the internal unit is a deferred-length allocatable CHARACTER scalar data object that is already allocated, this feature would change the current behavior of the internal write from blank-padding into reallocation.  (I'm not saying that reallocation is a bad idea or not useful; I'm saying that silently changing the semantics of working programs is a bad idea.)\nEDIT: sample program whose behavior will change:\ncharacter(len=:), allocatable :: x\nallocate(character(len=10) :: x)\nwrite(x,\"('hi')\")\nprint *, len(x) ! was 10, now 2"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-03-02 23:03:16+00:00",
                    "text": "@klausler wrote:\n\nUncharacteristically for Fortran, this proposal would change the behavior of some current conforming programs. I suggested at the J3 meeting that the change be restricted to only automatically allocate deferred-length CHARACTER allocatable variables that are in a deallocated state, since that case is currently an error, but to no avail.\nThe case that worries me the most is that of internal writes to allocatable CHARACTER. When the internal unit is a deferred-length allocatable CHARACTER scalar data object that is already allocated, this feature would change the current behavior of the internal write from blank-padding into reallocation. (I'm not saying that reallocation is a bad idea or not useful; I'm saying that silently changing the semantics of working programs is a bad idea.)\n..\n\nCan you please cross-check again with the relevant committee folks about this?\nMy understanding is different from yours, that the internal write to an already allocated allocatable character scalar will retain its length when the number of transferred characters during said write is less than the allocated length of the scalar variable.  So I expect the output of your sample program to remain as 10.\nPlease note the following, especially the bullet starting with 'otherwise', from paper https://j3-fortran.org/doc/year/20/20-122r1.txt:\n\nThis bullet item is replaced with the following text that now contains\ntwo sub-bullets:\n\"A record of the internal file becomes defined by writing the record.\n\nIf the internal file is an allocatable, deferred-length character\nscalar variable, it becomes defined as if by intrinsic assignment of\nthe record.\nOtherwise, if the number of characters written in a record is less\nthan the length of the record, the remaining portion of the record is\nfilled with blanks; the number of characters to be written shall not\nexceed the length of the record.\"\n\n{ writing an internal file to a scalar allocates as needed }\n{Note to the Editor: the last sentence in the original bullet has been\nchanged to a clause separated by a semicolon. The intent is that this\nsentence is attached to the \"otherwise\". The editor is free to rework\nthis as he feels appropriate.}"
                },
                {
                    "user": "klausler",
                    "date": "2020-03-02 23:06:07+00:00",
                    "text": "It's the first bullet point that's relevant."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-03-02 23:14:48+00:00",
                    "text": "It's the first bullet point that's relevant.\n\nI think the authors in paper 20-122r1 meant to state in the first bullet, \"If the internal file is an unallocated allocatable, deferred-length character scalar variable, it becomes defined as if by intrinsic assignment of the record.\"\nThis aspect was discussed in the previous paper they referenced, https://j3-fortran.org/doc/year/18/18-279r1.txt:\n\n3c. Internal WRITE\n..\nJOR recommends that if the io-unit in an internal WRITE is an\nunallocated deferred-length character allocatable scalar variable,\nthe WRITE behaves as if the record were assigned as if by intrinsic\nassignment. The requirement that the variable be unallocated is\nto provide consistency with the array case described in the next\nparagraph. If the variable is allocated it behaves as it does in\nF2008, using the current length."
                },
                {
                    "user": "klausler",
                    "date": "2020-03-02 23:21:23+00:00",
                    "text": "It's the first bullet point that's relevant.\n\nI think the authors in paper 20-122r1 meant to state in the first bullet, \"If the internal file is an unallocated allocatable, deferred-length character scalar variable, it becomes defined as if by intrinsic assignment of the record.\"\n\nThat would be better, but I asked specifically in the plenary meeting on Friday whether the proposal that was passed from JOR would invalidate current Fortran programs in the case of allocated deferred-length allocatable CHARACTER scalar variables, and was told explicitly that (1) yes, it would, and (2) that was intentional."
                },
                {
                    "user": "zjibben",
                    "date": "2020-03-02 23:29:59+00:00",
                    "text": "@klausler this is what I recall from plenary as well. Personally I'm ok with this behavior, as it's what happens with intrinsic assignment already, but I'd be curious to hear from the community if they consider it undesirable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-02 23:32:47+00:00",
                    "text": "The \"as if by intrinsic assignment\" means that yes, the variable would be reallocated. And as @klausler says, the committee said that it was intended for that to be the case. Their contention was that in the majority of cases, it probably wouldn't outwardly change behavior because the use cases probably are already reallocating it immediately afterward as workaround to the fact that it isn't done automatically already.\nIf you know of any cases where the intended behavior is to allocate a character and use internal IO to write into it without it being reallocated, now is the time to speak up, because this will cause a change in behavior.\nPersonally, I agree with the committee, that the new behavior is probably always what was desired anyway."
                },
                {
                    "user": "klausler",
                    "date": "2020-03-02 23:41:19+00:00",
                    "text": "I'm really uncomfortable with changing this behavior for internal writes because it breaks a long-standing correspondence between internal writes and fixed-length I/O.  Internal writes to CHARACTER arrays treat each element of the array just like a fixed-sized record (RECL=) in an external file.  Now, with this change, internal writes to CHARACTER scalars may no longer work in the same way as an internal write to a single-element CHARACTER array would, if the scalar is deferred-length and already allocated."
                },
                {
                    "user": "sblionel",
                    "date": "2020-03-07 01:28:34+00:00",
                    "text": "My view on this is that it is very unusual for current programs to use deferred-length allocatable character variables for this. Most will use fixed-length character and those will not change. We had many, many requests for this feature in the 202X survey.\nPlease also note that for the internal WRITE case, the new behavior applies to scalars only, since Fortran doesn't have \"ragged arrays\"."
                },
                {
                    "user": "klausler",
                    "date": "2020-03-09 15:39:37+00:00",
                    "text": "The feature should be limited for internal WRITEs to the (current) error case of an unallocated deferred-length allocatable character scalar."
                }
            ]
        },
        {
            "number": 159,
            "user": "marshallward",
            "date": "2020-02-28 02:15:29+00:00",
            "title": "Namelist delimiter proposal update",
            "text": "This patch contains two main modifications to the namelist delimiter\nproposal:\n\n\nThe introduction has been modified for clarity and to include the\nproposed change, rather than simply a discussion of the problem.\n\n\nThe introduction and proposal sections have been modified to clarify\nthat list-directed output would be unaffected by the change.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "marshallward",
                    "date": "2021-01-02 13:25:24+00:00",
                    "text": "I am not sure how to submit this, and other feedback suggests that I am the only person on the planet who is concerned about this, so I am going to close this."
                }
            ]
        },
        {
            "number": 158,
            "user": "certik",
            "date": "2020-02-26 16:57:08+00:00",
            "title": "US16 TYPEOF and CLASSOF",
            "text": "The Committee is discussing a proposal for TYPEOF and CLASSOF.\nProposals:\nhttps://j3-fortran.org/doc/year/19/19-142r1.txt\nhttps://j3-fortran.org/doc/year/20/20-114.txt",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023"
            ],
            "comments": []
        },
        {
            "number": 157,
            "user": "certik",
            "date": "2020-02-26 16:42:37+00:00",
            "title": "Rank-agnostic array element and section denotation",
            "text": "The Committee is debating how to do \"Rank-agnostic array element and section denotation\".\nThere is disagreement on how to approach this, particularly between rank-1 integers vs a type. Many think the alternatives need to be explored more.\nPapers:\nhttps://j3-fortran.org/doc/year/19/19-150.txt\nhttps://j3-fortran.org/doc/year/19/19-173r1.txt\nhttps://j3-fortran.org/doc/year/19/19-202r2.txt\nhttps://j3-fortran.org/doc/year/20/20-113.txt (passed 10 v 5)\nhttps://j3-fortran.org/doc/year/20/20-115.txt\nhttps://j3-fortran.org/doc/year/20/20-120.txt\nhttps://j3-fortran.org/doc/year/20/20-124.txt\nhttps://j3-fortran.org/doc/year/20/20-125.txt Failed (5 v 7). Missing edits, and disagreement on types vs rank-1 integers, the options need to be explored more.\nhttps://j3-fortran.org/doc/year/20/20-126.txt\nhttps://j3-fortran.org/doc/year/19/19-253r1.txt (type-based array descriptors)\nBasic Summary\n\n\n\nA(@V)\n\nis equivalent to\nA(V(1), V(2), ..., V(size(V)))\n\n\n\n\n  A(@V1, :, @V2)\n\nis equivalent to\nA ( V1(1), V1(2) , ..., V1(size(V1)) , :, &\n    & V2(1), V2(2) , ..., V2(size(V2)) )",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-26 16:45:26+00:00",
                    "text": "One of the main questions is whether to use a rank 1 integer, or a derived type for doing the indexing.\nThe other question is whether to design this now, or wait until Fortran has a plan for more generic programming, to ensure that this feature is consistent with it."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-26 16:50:04+00:00",
                    "text": "I would very much prefer a more generalized function-like solution in which one could apply an array to an array of indices, whose first dimension would have to match the rank of the array.\nThat said, I think it's putting the cart before the horse to design features meant mostly for generic programming before Fortran's generic programming capabilities have been defined; how can we be confident that we understand the requirements?"
                },
                {
                    "user": "certik",
                    "date": "2020-02-26 16:53:41+00:00",
                    "text": "My own opinion: We do not understand the requirements, and we do not understand the space of possible solutions. Consequently, we cannot guarantee this will end up consistent with future generic features. In addition, we have not explored all ideas how to achieve rank agnostic access, such as the function idea that @klausler mentioned above."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-26 17:20:25+00:00",
                    "text": "This syntax suggests itself for function calls, f(@g(x)). I'm not sure whether that would be useful or not, but I think the syntax is practically begging for it. Maybe an alternative would be more distinct, if that's not what we want. I agree we need to understand the requirements better to make useful decisions."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-26 19:15:13+00:00",
                    "text": "I think, we would need an infrastructure which enables us to address slices in arbitrary dimensions. The language should ,for example, allow us to write a generic sum functions working for arbitrary ranks (e.g. as  shown in #153) without having to use a pre-processor. The solution above does not seem to make that possible, and I don't see, how it could be extended into that direction."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 00:08:11+00:00",
                    "text": "I'm not sure that this is the best issue for posting this message (it's not bad, it's just that there are several other options).      The examples here are intended to give some sense of how the recently proposed F202x rank-agnostic features complement assumed-rank (F2018) and potential F202y templating capabilities.\nThe following subroutine finds the index at which the 3D array x achieves its maximum value, and then determines the corresponding values in arrays q1, q2, q3.  The results are returns in the 1D array vec.\nsubroutine max_at(x, q1, q2, q3, vec)\n   real, intent(in) :: x(:,:,:)\n   real, intent(in) :: q1(:,:,:)\n   real, intent(in) :: q2(:,:,:)\n   real, intent(in) :: q3(:,:,:)\n   real, intent(out) :: vec(3)\n\n   integer :: idx(3)\n\n   idx = maxloc(x)\n\n   vec(1) = q1(idx(1),idx(2),idx(3))\n   vec(2) = q2(idx(1),idx(2),idx(3))\n   vec(3) = q3(idx(1),idx(2),idx(3))\n\nend subroutine max_at\nWith F2018 we can try to generalize this for say ranks 2-4 in a single interface using SELECT RANK:\nsubroutine max_at(x, q1, q2, q3, vec)\n   real, intent(in) :: x(..)\n   real, intent(in) :: q1(..)\n   real, intent(in) :: q2(..)\n   real, intent(in) :: q3(..)\n   real, intent(out) :: vec(3)\n\n   integer, allocatable :: idx(:)\n\n\n   select rank (x)\n   rank(2)\n      ! Maybe the standard can be amended such that MAXLOC() works\n      ! with assumed rank, but for now it does not.  Thus the\n      ! following line must be repeated inside each case.\n      idx = maxloc(x)\n      vec(1) = q1(idx(1),idx(2))\n      vec(2) = q2(idx(1),idx(2))\n      vec(3) = q3(idx(1),idx(2))\n   rank(3)\n      idx = maxloc(x)\n      vec(1) = q1(idx(1),idx(2),idx(3))\n      vec(2) = q2(idx(1),idx(2),idx(3))\n      vec(3) = q3(idx(1),idx(2),idx(3))\n   rank(4)\n      idx = maxloc(x)\n      vec(1) = q1(idx(1),idx(2),idx(3),idx(4))\n      vec(2) = q2(idx(1),idx(2),idx(3),idx(4))\n      vec(3) = q3(idx(1),idx(2),idx(3),idx(4))\n   end select\n\nend subroutine max_at\nWith Proposed F202x rank agnostic features this gets a bit cleaner, but, annoyingly still has some duplicated bits of code.  The duplication could be avoided with an include file, but that would be a bit heavy-handed for this example.\nsubroutine max_at(x, q1, q2, q3, vec)\n   real, intent(in) :: x(..)\n   real, intent(in) :: q1(..)\n   real, intent(in) :: q2(..)\n   real, intent(in) :: q3(..)\n   real, intent(out) :: vec(3)\n\n   integer, allocatable :: idx(:)\n\n   select rank (x)\n   rank(2)\n      idx = maxloc(x)\n      vec = [q1(@idx),q2(@idx),q3(@idx)]\n   rank(3)\n      idx = maxloc(x)\n      vec = [q1(@idx),q2(@idx),q3(@idx)]\n   rank(4)\n      idx = maxloc(x)\n      vec = [q1(@idx),q2(@idx),q3(@idx)]\n   end select\n\nend subroutine max_at\nWith some sort of templating capability in F202Y I imagine something similar to the following should be possible.  Here\n is suggestive of an integer template parameter that specifies the ranks.\nsubroutine max_at<n>(x, q1, q2, q3, vec)\n   real, rank(n), intent(in) :: x\n   real, rank(n), intent(in) :: q1\n   real, rank(n), intent(in) :: q2\n   real, rank(n), intent(in) :: q3\n   real, intent(out) :: vec(3)\n\n   integer, allocatable :: idx(:)\n\n   idx = maxloc(x)\n   vec = [q1(@idx),q2(@idx),q3(@idx)]\n\nend subroutine max_at\nNow consider a more complex example where multiple rank-related factors come into play.\nRequirement: a software layer that supports performing a GATHER operation (originally MPI, but using co-arrays here) for an array that has one dimension distributed over multiple images.  The supported ranks are 2-5, but the distributed dimension might be any of the 2nd, 3rd, or 4th dimension.  This is a real use case from a\nmajor climate model, GISS ModelE.\nIn the real code the extent of the local array in each dimension can vary due to divisibility of the global domain size vs number of images, but for simplicity, assume that the local array on each image has an extent of 2 in the distributed dimension.  We will also allow the allocation of the output array to be performed on the\nclient side.\nThis is only one of several algorithms that require somewhat similar implementations in the model.\nF2008 approach.\ninterface\n   module procedure gather_2d  ! not shown here\n   module procedure gather_3d\n   module procedure gather_4d\n   module procedure gather_5d  ! not shown here\nend interface\n\ncontains\n   \nsubroutine gather_3d(local_arr, dim, global_arr)\n   real, intent(in) :: local_arr(:,:,:)\n   integer, intent(in) :: dim\n   real, intent(out) :: global_arr(:,:,:)\n\n   integer :: p\n   integer :: k0, k1\n\n   sync_all\n   if (this_image() == 1) then\n\n      do p = 1, num_images()\n         k0 = 1 + (p-1)*2\n         k1 = p*2\n         select case (dim)\n         case (2)\n            global_arr(:,k0:k1,:) = local_array[p]\n         case (3)\n            global_arr(:,:,k0:k1) = local_array[p]\n         end select\n      end select\n   end if\n   sync_all\n   \nend subroutine gather_3d\n\nsubroutine gather_4d(local_arr, dim, global_arr)\n   real, intent(in) :: local_arr(:,:,:,:)\n   integer, intent(in) :: dim\n   real, intent(out) :: global_arr(:,:,:,:)\n\n   integer :: p\n   integer :: k0, k1\n\n   sync_all\n   if (this_image() == 1) then\n\n      do p = 1, num_images()\n         k0 = 1 + (p-1)*2\n         k1 = p*2\n         select case (dim)\n         case (2)\n            global_arr(:,k0:k1,:,:) = local_array[p]\n         case (3)\n            global_arr(:,:,k0:k1,:) = local_array[p]\n         case (4)\n            global_arr(:,:,:,k0:k1) = local_array[p]\n         end select\n      end select\n   end if\n   sync_all\n   \nend subroutine gather_3d\n...\nWith F2018 we might try to use select rank, but we end up with nested constructs:\nsubroutine gather(local_arr, dim, global_arr)\n   real, intent(in) :: local_arr(..)[*]\n   integer, intent(in) :: dim\n   real, intent(out) :: global_arr(..)\n\n   integer :: p\n   integer :: k0, k1\n\n   sync_all\n   if (this_image() == 1) then\n\n      do p = 1, num_images()\n         k0 = 1 + (p-1)*2\n         k1 = p*2\n         select rank(local_arr)\n         rank (2)\n            ! dim must be 2\n            global_arr(:,k0:k1) = local_array[p]\n         rank (3)\n            select case (dim)\n            case (2)\n               global_arr(:,k0:k1,:) = local_array[p]\n            case (3)\n               global_arr(:,:,k0:k1) = local_array[p]\n            end select\n         rank (4)\n            select case (dim)\n            case (2)\n               global_arr(:,k0:k1,:,:) = local_array[p]\n            case (3)\n               global_arr(:,:,k0:k1,:) = local_array[p]\n            case (4)\n               global_arr(:,:,:,k0:k1) = local_array[p]\n            end select\n         rank (5)\n            select case (dim)\n            case (2)\n               global_arr(:,k0:k1,:,:,:) = local_array[p]\n            case (3)\n               global_arr(:,:,k0:k1,:,:) = local_array[p]\n            case (4)\n               global_arr(:,:,:,k0:k1,:) = local_array[p]\n            end select\n         end select\n   end if\n   sync_all\nend subroutine gather\nWith F202x rank-agnostic capabilities, we can avoid the nesting:\nsubroutine gather(local_arr, dim, global_arr)\n   real, intent(in) :: local_arr(..)[*]\n   integer, intent(in) :: dim\n   real, intent(out) :: global_arr(..)\n\n   integer :: p\n   integer :: k0, k1\n   integer, allocatable :: shp(:)\n\n   shp = shape(local_array)\n   sync_all\n   if (this_image() == 1) then\n      do p = 1, num_images()\n         k0 = 1 + (p-1)*2\n         k1 = p*2\n         select rank(local_arr)\n         rank (2)\n            ! dim must be 2\n            global_arr(:,k0:k1) = local_array[p]\n         rank (3)\n            global_arr(@:shp(1:dim-1),k0:k1,@:shp(dim+1:)) = local[p]\n         rank (4)\n            global_arr(@:shp(1:dim-1),k0:k1,@:shp(dim+1:)) = local[p]\n         rank (5)\n            global_arr(@:shp(1:dim-1),k0:k1,@:shp(dim+1:)) = local[p]\n         end select\n   end if\n   sync_all\nend subroutine gather\nWith F202y some templating mechanism might allow the following:\nsubroutine gather<n>(local_arr, dim, global_arr)\n   real, rank(n) intent(in) :: local_arr[*]\n   integer, intent(in) :: dim\n   real, rank(n), intent(out) :: global_arr[*]\n\n   integer :: p\n   integer :: k0, k1\n   integer, allocatable :: shp(:)\n\n   sync_all\n   if (this_image() == 1) then\n      do p = 1, num_images()\n         k0 = 1 + (p-1)*2\n         k1 = p*2\n\n         shp = shape(local_array)\n         global_arr(@:shp(1:dim-1),k0:k1,@:shp(dim+1:)) = local[p]\n      end do\n   end if\n   sync_all\nend subroutine gather\nSummary\nAssumed-rank is good for reducing the near-duplication of interfaces for different ranks, but is almost useless for reducing\nnear-duplication of the logic that must go inside SELECT RANK constructs.  Indeed many of my other uses of SELECT RANK have identical code inside each RANK clause, except for the DEFAULT clause.\nF202x rank-agnostic features are good for reducing near-duplication, within a given RANK clause\nF202y generic features are expected to eliminate the need for SELECT RANK entirely for many use cases, and in conjunction with the rank-agnostic features almost completely eliminate near duplication of code for this class of problem."
                },
                {
                    "user": "tclune",
                    "date": "2020-10-16 00:12:12+00:00",
                    "text": "I would hope that any serious proposal to replace the F202x \"@\" syntax would work well in the previous examples.   I'm not particularly opposed to the function-based approach that was suggested earlier in this thread, but I think doing anything like that on the LHS of the assignment will meet some resistance.   When various use cases were discussed in planning F202x there was significantly less backing for accessors than there were for most of the other use cases."
                },
                {
                    "user": "certik",
                    "date": "2021-06-10 19:43:28+00:00",
                    "text": "Regarding the first example, we can rewrite it like this:\nsubroutine max_at(x, q1, q2, q3, vec)\nreal, intent(in) :: x(..)\nreal, intent(in) :: q1(..)\nreal, intent(in) :: q2(..)\nreal, intent(in) :: q3(..)\nreal, intent(out) :: vec(3)\ninteger, allocatable :: idx(:)\nselect rank(x) \nrank(2)\n    idx = maxloc(x)\n    vec = [q1(idx(1),idx(2)), q2(idx(1),idx(2)), q3(idx(1),idx(2))]\nrank(3)\n    idx = maxloc(x)\n    vec = [q1(idx(1),idx(2),idx(3)), q2(idx(1),idx(2),idx(3)), q3(idx(1),idx(2),idx(3))]\nrank(4)\n    idx = maxloc(x)\n    vec = [q1(idx(1),idx(2),idx(3),idx(4)), q2(idx(1),idx(2),idx(3),idx(4)), q3(idx(1),idx(2),idx(3),idx(4))]\nend select\nend subroutine\nto be more consistent with the simpler version using the @ notation:\nsubroutine max_at(x, q1, q2, q3, vec)\nreal, intent(in) :: x(..)\nreal, intent(in) :: q1(..)\nreal, intent(in) :: q2(..)\nreal, intent(in) :: q3(..)\nreal, intent(out) :: vec(3)\ninteger, allocatable :: idx(:)\nselect rank(x)\nrank(2)\n    idx = maxloc(x)\n    vec = [q1(@idx), q2(@idx), q3(@idx)]                             \nrank(3)\n    idx = maxloc(x)\n    vec = [q1(@idx), q2(@idx), q3(@idx)]\nrank(4)\n    idx = maxloc(x)\n    vec = [q1(@idx), q2(@idx), q3(@idx)]\nend select\nend subroutine\nCan Fortran be extended in this direction for this particular case:\nsubroutine max_at(x, q1, q2, q3, vec)\nreal, intent(in) :: x(..)\nreal, intent(in) :: q1(..)\nreal, intent(in) :: q2(..)\nreal, intent(in) :: q3(..)\nreal, intent(out) :: vec(3)\ninteger :: idx(rank(x))\nidx = maxloc(x)\nvec = [q1(@idx), q2(@idx), q3(@idx)]                             \nend subroutine\nWhich eliminates the need for allocating idx (slow) using the rank(x) construct, and it extends maxloc and @idx to not require to be inside the select rank construct.\nI also asked here to get more feedback: https://fortran-lang.discourse.group/t/examples-for-the-new-rank-agnostic-array-notation/1376"
                }
            ]
        },
        {
            "number": 156,
            "user": "certik",
            "date": "2020-02-25 23:27:38+00:00",
            "title": "Protected Components",
            "text": "As part of #155, the committee is looking at protected components as part of\nUS 19 Protected Components\nhttps://j3-fortran.org/doc/year/18/18-265.txt\nhttps://j3-fortran.org/doc/year/19/19-135r1.txt\nhttps://j3-fortran.org/doc/year/19/19-161.txt\nhttps://j3-fortran.org/doc/year/19/19-214r1.txt\nhttps://j3-fortran.org/doc/year/20/20-106.txt\nhttps://j3-fortran.org/doc/year/20/20-121.txt",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 23:42:55+00:00",
                    "text": "@zjibben can fill in the details.\nIt looks like the latest version so far has a requirement that a protected component (meaning one cannot write into it from outside the class) will require that one cannot assign the class variable to another (a = b), or allocate it or deallocate it, unless one writes lots of boilerplate code (custom initializer? and finalizer and custom = operator and the user must import it).\nI am personally against that, I don't think that's a good approach. If using the equivalence of = being \"copy constructor in C++\", allocate being \"constructor\" and \"deallocate\" being \"destructor\", those in C++ can be implicitly generated by the compiler, or written explicitly by the user, in either case they are methods of the object itself, and thus if C++ had protected components, it seems that one could call = and create and destruct the object. I would do the same in Fortran."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-25 23:46:12+00:00",
                    "text": "C++ does have const data members that can be assigned only during construction."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-26 06:03:39+00:00",
                    "text": "As @certik said, there is something in the works related to #16, but the existing version has many more restrictions than we expected. In particular, if you have a type with a protected component (or some subobject which ultimately has a protected component), there are many things you wouldn't be able to do outside the module where it is defined. The restrictions which raised concern were, outside the module where the type containing a protected component defined, you could not allocate or deallocate a variable of the type, nor use intrinsic assignment to the object as a whole if it contains a protected data member (a = b is disallowed if b%c is protected). It also restricted type extension, so one could never have an extension type with a protected component if the parent didn't also have a protected component (this restriction would prevent a loophole to get around the no-intrinsic-assignment rule above).\nSome committee members were concerned this would make protected components too unwieldy to use in practice, that they shouldn't add more write-restrictions than private components, and protected components shouldn't have so strong an affect on how the object itself is used. They would force a lot of boiler plate to use defined assignment or type extension or allocatables if all a programmer wanted was automatic and free getter methods. On the other hand, the counter-argument is that without these restrictions you aren't really protecting the data all that much. Anyone outside the module could blow it away with a reallocation or intrinsic assignment to the variable which ultimately contains protected data.\nWe agreed the restriction on type extension was too far, so that is going away. The rest is up for debate. At the moment things are leaning toward reworking the requirements entirely, that the original version may be too heavy a hammer, but I think nothing is really settled one way or another."
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-02-26 07:28:37+00:00",
                    "text": "If memory serves, you can use intrinsic assignment on derived types with private components, so I don't see why anything should be different for types with protected ones."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-26 09:10:14+00:00",
                    "text": "@zjibben , @certik: Similar to @cmacmackin, I also think, that members with protected attribute should behave the same way as private members do, with the only notable difference, that reading them shall be also allowed in routines outside of the module with the type declaration."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-26 09:51:27+00:00",
                    "text": "Reading through the attached documents I got the impression, that the protected attribute should receive even more \"protection\" as private components (e.g. protected components can never change, unless a routine in the module defining the type is invoked). I think, this is unnecessarily strict, as not even private members have that protection:\nmodule testmod\n  implicit none\n\n  type :: mytype_t\n    private\n    integer :: val = 0\n  contains\n    procedure :: setval => mytype_setval\n    procedure :: getval => mytype_getval\n  end type mytype_t\n\ncontains\n\n  subroutine mytype_setval(this, newval)\n    class(mytype_t), intent(inout) :: this\n    integer, intent(in) :: newval\n\n    this%val = newval\n\n  end subroutine mytype_setval\n\n\n  function mytype_getval(this) result(val)\n    class(mytype_t), intent(in) :: this\n    integer :: val\n\n    val = this%val\n\n  end function mytype_getval\n\n\nend module testmod\n\n\nprogram testprog\n  use testmod\n\n  type(mytype_t) :: a, b\n\n  call a%setval(42)\n  ! print *, a%val, b%val\n  print *, a%getval(), b%getval()  ! 42 0\n  b = a\n  ! print *, a%val, b%val\n  print *, a%getval(), b%getval()  ! 42 42\n\nend program testprog\n\nAs explained above, I'd suggest to treat protected data componenets on a similar foot as private ones, with the exception of allowing protected data components to appear as rvalue in expressions outside of the defining module. The protectedness of a data member should not cause any more restriction for the given type, as a private data member does."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-26 10:08:23+00:00",
                    "text": "As for type extension: The extended type should inherit the protected data component of the base type. (In contrast to private components, which are \"invisible\" in extending types). If the extending type is defined in a different module as the base type, though, it would only be able to manipulate the protected data component via routines defined in the module of the base type. (Similarly, how an extending type needs the setter routines of the base type in order to manipulate its private components.)\nI may have, of course, overseen something trivial, and I am definitely lacking the experience and far-sigthedness of the committee members. But I think, that by interpreting the protected data members as just a kind of light version of private components, we could add the desired functionality (reading out values directly, without the need of getter routines) with minimal side effects."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-26 23:13:19+00:00",
                    "text": "Thank you all for the feedback, these are exactly the points I've brought up with the committee. I sat down with them to write up a toy example to depict what I (and I think others here) would like, which includes intrinsic assignment for one. This was the example:\nmodule foo_type\n\n  implicit none\n\n  type :: foo\n    real, protected :: a\n    real, private :: b\n  contains\n    procedure :: init\n  end type foo\n\ncontains\n\n  subroutine init(this, x)\n\n    class(foo), intent(out) :: this\n    real, intent(in) :: x\n\n    a = x\n    b = -x\n\n  end subroutine init\n\nend module foo_type\n\n\nprogram main\n\n  use foo_type\n  implicit none\n\n  type(foo) :: f, g\n  real :: x\n\n  x = 1\n  call g%init(x)\n\n  f = g ! We want to be able to do this.\n\n  ! Now it is not possible to insert garbage in f%a,\n  ! without changing f%b\n\nend program main\nThe counter-example which shows the danger they're concerned about is here, using a linked list:\n! Linked list mock-up\nmodule bar_type\n\n  implicit none\n\n  type :: bar\n    type(bar), pointer, protected :: prev => null()\n    type(bar), pointer, protected :: next => null()\n  contains\n    procedure :: init\n  end type bar\n\ncontains\n\n  subroutine init(this)\n\n    class(bar), intent(out) :: this\n\n    this%prev => this\n    this%next => this\n\n  end subroutine init\n\nend module bar_type\n\n\nprogram main\n\n  use bar_type\n  implicit none\n\n  type(bar) :: f, g\n\n  call g%init()\n\n  f = g\n  ! Now f has pointers to g instead of itself, so is a\n  ! linked list that can't get back to itself.\n  ! Committee solution is forbid intrinsic assignment.\n\nend program main\nThe argument coming from some in the committee is that intrinsic assignment can produce things you don't want, so why do it? If you want assignment, make a defined assignment within the module where the type is defined. I might argue that this danger seems limited to linked-list type situations and not particularly damaging (existing data is intact, new object is undesired). So, we might instead have a programmer write defined assignment to override (=) when they want to prevent intrinsic assignment rather than make it impossible for all the objects where it's actually preferred. But at this point I believe we are at an impasse of conflicting interests, and most likely the \"forbid intrinsic assignment, allocation, and deallocation\" version will go through."
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-02-26 23:26:55+00:00",
                    "text": "Exactly the same thing could happen if you used private components for next and prev though, and intrinsic assignment is allowed for that. I do not understand where this argument is coming from and what possible justification there could be for treating private and protected components differently."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 00:22:20+00:00",
                    "text": "It seems that the proposal attempts to take \"protected\" absolutely literally.  I'll just echo what everyone else is saying, that we want something just a bit less restrictive than private, namely it is readable outside the module where the type is declared. What is being proposed is pretty useless in my view."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 01:58:28+00:00",
                    "text": "It seems that the proposal attempts to take \"protected\" absolutely literally.\n\nThis is exactly the problem as I see it, and as a result it looks like we're getting something that protects data so tightly that it can't be used for much. There are workarounds, like having defined-assignment which just turns around and does the intrinsic assignment within the module where the type is defined. But at that point, it's a lot of boiler plate for what it's giving you.\nAs a consequence of this protection, it was realized that protected is really an entirely different kind of thing than private and public. So the proposal is allowing for a private, protected component. If a type has a length-0 array component which is private, protected, you effectively just disable intrinsic assignment for that object without expanding the visible API or memory footprint. I struggle to imagine the applicability, but I'm told there have been requests for such a feature.\nAt any rate, my reading of the committee is this will go a very different direction than what most developers (including myself) are interested in."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 06:45:06+00:00",
                    "text": "My understanding is that the Data subcommittee couldn't agree on the way forward, so decided not to put the proposal for a vote tomorrow."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-27 10:25:41+00:00",
                    "text": "Oh, that's quite sad news! Anyway, if some more arguments are needed: I think, the case of the linked list structure, which was used to justify the complicated behavior, is not a very good one. Usually, if one implements a container, one wants to hide the implementation details (whether it is a linked list or not) completely and provides iterators instead. So trying to make a linked list safe from unnoticed changes should not the object to aim for. What we should aim at instead is to protect consistency of data within one derive type instance without any kind of warranty for the \"ethernal\" existence of the derived type instance. (Exactly as the language already does it for private components...)\nAs a compromise, why not splitting the efforts into two parts?\n\nFirst, introducing the lightweight protected attribute. As already discussed, it should behave like private apart of the readability from outside, and would have basically no side-effects. It would be symmetric to how protected already works for module, where it exactly behaves as private with the additional readability from outside. This could be basically introduced immediately into the language.\nInterested people could work on the introduction of a more protective keyword (e.g. immutable), which could do all the hard protection with all the horrible side effects, and see, whether they come up with something which still can be used.\n\nAnd one last note, as pointers were mentioned: A pointer having the protected attribute should be protected the same way, as a pointer dummy argument with the intent(in) attribute would be protected in a subroutine: That means, only the pointer instance would be protected, but not necessarily the content it points to. Again, this maybe unsatisfactory, but would be IMHO much more consistent with the current language, as the one suggested by the committee members.\nAnyway @certik @zjibben thanks a lot for all your efforts, and let's see, whether we still  have to provide getters in twenty years...."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 18:45:55+00:00",
                    "text": "Ok, so after a long discussion in the Data subcommittee, the current proposal would require the developer of the class A with protected components to provide the type bound assignment operator, but if they do, then as the user, you can assign a = b (both of type A) and it will just work. You do not need to import the = operator manually, it will automatically come with the class A.\nSo I think, at least from a user perspective, you can use = naturally, this will not be a problem. As a developer, you have to write extra boilerplate code unfortunately."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 18:48:51+00:00",
                    "text": "Finally, as @zjibben mentioned, the automatic deallocation would still work intuitively. Just explicit deallocation would not work.\nAllocation would need to be done with a subroutine that the module developer provides (actually by overloading the constructor, so this would also work intuitively). (Explicit allocation from outside the module would not work.)"
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-02-27 19:04:46+00:00",
                    "text": "I still don't understand what the reason is for treating protected\ncomponents more strictly than private ones.\n\u2026\nOn Thu, 27 Feb 2020, 18:48 Ond\u0159ej \u010cert\u00edk, ***@***.***> wrote:\n Finally, as @zjibben <https://github.com/zjibben> mentioned, the\n automatic deallocation would still work intuitively. Just explicit\n deallocation would not work.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#156?email_source=notifications&email_token=AB6ESPKNMCUULCU6EQQYTZ3RFADJJA5CNFSM4K3WKLZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENFP4BQ#issuecomment-592117254>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPNXWOR2KS72IHSTI5DRFADJJANCNFSM4K3WKLZA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 19:08:23+00:00",
                    "text": "I still don't understand what the reason is for treating protected components more strictly than private ones.\n\nUnfortunately I don't understand why either... @zjibben, @klausler, @FortranFan, @everythingfunctional are sitting in the same room --- is any of you able to answer @cmacmackin's question?"
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 19:16:32+00:00",
                    "text": "This has to do with the example above protecting pointers, and existing expectations from the term protected, I think. Though @cmacmackin had some counter-points to the pointer protection, so I can't say I fully understand either."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 19:34:08+00:00",
                    "text": "Visibility of components and definability of components are being treated as independent concepts, which (IMO) they are."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 19:52:35+00:00",
                    "text": "The conclusion reached in the Data subcommittee so far is that we have to bring lots of use cases. That is, code that we would like to work with \"protected\". Then at our next meeting, we will sit down and see how to make them work with the proposal."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-27 19:57:45+00:00",
                    "text": "I think the initial idea expressed here was meant to be, relax the restrictions of private, without allowing for direct assignment/change of the component.\nInstead the committee is defining protected as \"disallow all ways of modifying the value of this component, except from procedures within the defining module\"."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 23:37:16+00:00",
                    "text": "I just learned there is an older proposal which describes a version of protected which is much closer to what we expected here:\nhttps://j3-fortran.org/doc/year/18/18-265.txt\nThere, intrinsic assignment is allowed, and allocation and deallocation aren't called out at all. I think this is the paper to reference in future use cases, along with @aradi's paper."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-28 00:54:40+00:00",
                    "text": "@cmacmackin wrote:\n\nI still don't understand what the reason is for treating protected components more strictly than private ones. ..\n\nI'm still struggling to understand the underlying technical reasons, but my understanding is this paper - https://j3-fortran.org/doc/year/19/19-135r1.txt - forms the basis for much of the rationale.\nAs stated in some of the recent posts above, my understanding is the \"protected\" attribute of derived type components as being currently for Fortran 202X refers to what can appear in a \"variable definition context\".  It is the not accessibility relative to module scope as it is applied to PUBLIC/PRIVATE attributes."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-28 07:43:15+00:00",
                    "text": "I think, I know where some of the confusions comes from (at least mine). I have always interpreted the protected attribute in modules as a visibility between private and protected and wished to transfer it to derived type components as well. But reading Modern Fortran Explained (and probably the standard says the same) about the protected attribute:\n\nThis attribute does not affect the visibility of the variable, which must must still be public to be visible, but confers the same protection aginst modification that intent \u0131n does for dummy arguments.\n\nSo, as @klausler pointed out, the visibility and definability are indeed independent from the view point of the current standard. And this is probably, what the committee tries to apply to the derived type components as well. (Which means, the protected attribute would be an additional one on top of the public attribute of a component)."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 07:52:55+00:00",
                    "text": "I think that's precisely it!\n\nHowever, I think what most people want instead is something like private, but read only and visible.\n\u2026\nOn Thu, Feb 27, 2020, at 11:43 PM, B\u00e1lint Aradi wrote:\n I think, I know where some of the confusions comes from (at least\n mine). I have always interpreted the `protected` attribute in modules\n as a visibility between `private` and `protected` and wished to\n transfer it to derived type components as well. But reading Modern\n Fortran Explained (and probably the standard says the same) about the\n `protected` attribute:\n\n > This attribute does not affect the visibility of the variable, which must must still be public to be visible, but confers the same protection aginst modification that intent `\u0131n` does for dummy arguments.\n\n So, as @klausler <https://github.com/klausler> pointed out, the\n visibility and definability are indeed independent from the view point\n of the current standard. And this is probably, what the committee tries\n to apply to the derived type components as well. (Which means, the\n `protected` attribute would be an additional one on top of the `public`\n attribute of a component).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#156?email_source=notifications&email_token=AAAFAWBSX6GOYTOQCNMLZWDRFC6BHA5CNFSM4K3WKLZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENHSVWY#issuecomment-592390875>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGR2YS3HANOO4R3PFLRFC6BHANCNFSM4K3WKLZA>."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-28 07:58:45+00:00",
                    "text": "In order to be in accordance with the spirit of the current standard, we just have to make sure, that protected, public components behave the same way as if they were intent(in) dummy arguments in a subroutine. However, IMO the intent(in)-ness should only apply to the component, not to the entire derived type. Therefore, direct allocation/deallocation of the protected component should be forbidden, but not the allocation/deallocation of the containing derived type instance as one unit:\nmodule testmod\n  implicit none\n\n  type :: mytype\n    public\n    integer, allocatable, protected :: array(:)\n  end type mytype\n\nend module testmod\n\n\nprogram testprog\n  use testmod\n  implicit none\n\n  type(mytype), allocatable :: inst1, inst2\n\n  ! Should be possibe since the inst1 as whole is not protected\n  allocate(inst1)\n\n  ! Should be NOT possible as it tries to manipulated directly a protected component\n  allocate(inst1%array)\n\n  ! This should be possible since assignment acts on the entire instance\n  inst2 = inst1\n\n  ! Should be NOT possible as it acts directly on a protected component\n  inst2%array(1) = 9\n\n  ! Should be possible as well\n  deallocate(inst1, inst2)\n\nend program testprog\n\nThis would probably give exactly the expected user experience and would be still in accordance with the spirit of the standard."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 16:54:02+00:00",
                    "text": "The paper https://j3-fortran.org/doc/year/20/20-121.txt was withdrawn after a discussion and general opposition to it. A way out that was suggested is to implement protected components along the lines of the paper https://j3-fortran.org/doc/year/18/18-265.txt, which would satisfy what people in this thread expect. Then in addition, there could be a protected class, which would restrict even the assignment and other things. The protected component and protected class would be two different features."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-28 17:51:26+00:00",
                    "text": "The committee overall seemed to understand the concerns expressed over the usability of the feature as proposed, and was very agreeable to withdrawal."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-28 21:21:19+00:00",
                    "text": "That's quite good news. I was not aware of https://j3-fortran.org/doc/year/18/18-265.txt, but it seems to formulate exactly the same idea as suggested above and would be in accordance with the original proposal on GitHub! So, there is still hope! \ud83d\ude09"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-02 21:04:03+00:00",
                    "text": "Because the semantics of PROTECTED entities is not quite what is commonly thought, and the problems with PROTECTED components are because they are trying to match the semantics of PROTECTED entities, perhaps what is needed is a new keyword, e.g., VISIBLE, to indicate entities an components whose value can be seen, but cannot be directly modified."
                },
                {
                    "user": "zjibben",
                    "date": "2020-09-21 23:25:06+00:00",
                    "text": "Everyone, I have a new specs & syntax paper over at #182 planned for the next meeting (Oct 12). Please take a look & comment your suggestions."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-27 15:24:31+00:00",
                    "text": "@zjibben, @certik, and everyone contributing here,\nKudos on great effort and collaboration.\nWith the protected components section of the paper, the revised paper looks good, and the comments posted here thus far appear to me to have captured all the use cases and needs and feature aspects I have come across.  Nothing useful I can add at this stage.\nHowever I am simply unable to understand the protected type, the rationale for it, its use cases, and the accompanying requirements and the specifications.\nThus an immediate question and a suggestion: will it be possible to break up the protected components and protected types into two separate work items with the committee and which can then have separate papers to develop the features?  This way, if one aspect, say protected components, looks mature, it can advance without being held back by the other,"
                }
            ]
        },
        {
            "number": 155,
            "user": "certik",
            "date": "2020-02-24 23:22:55+00:00",
            "title": "February 2020 Fortran Meeting",
            "text": "Fortran Committee Meeting February 24 - 28, 2020, Las Vegas, NV, USA\nPeople\n\nDan Nagle (NCAR)\nSteven Lionel (WG5) @sblionel\nJon Steidel (Intel) @JonSteidel\nBill Long (Cray / HPE) @longb\nPeter Klausler (Nvidia) @klausler\nReuben Budiardja (ORNL) @reubendb\nDaniel Chen (IBM) @DanielCChen\nBrad Richardson (Structural Integrity) @everythingfunctional\nBrian Friesen (LBNL) @bcfriesen\nErhard Ploedereder (WG23)\nSrinath Vadlamani (ARM) @srinathv\nTom Clune (NASA) @tclune\nGary Klimowicz (Nvidia) @gklimowicz\nRich Bleikamp (AMD) @rbleikamp\nVan Sneider (JPL)\nZach Jibben (LANL) @zjibben\nMalcolm Cohen (NAG)\nStephen Michell (WG23)\nOnd\u0159ej \u010cert\u00edk (LANL) @certik\nBob Corbett\nVipul Parekh\nDamian Rouson (Sourcery, Inc.) @rouson\nMagne Haveraaen (University of Bergen)\n\nProposals Discussed at Plenary\nTuesday 2/25\n\n#22: Default values of optional arguments (https://j3-fortran.org/doc/year/20/20-107.txt)\n\nWednesday 2/26\n\n#157: Rank-agnostic array element and section denotation (https://j3-fortran.org/doc/year/20/20-113.txt, https://j3-fortran.org/doc/year/20/20-115.txt)\n#158: TYPEOF and CLASSOF (https://j3-fortran.org/doc/year/20/20-114.txt)\n#1: Namespace for modules (https://j3-fortran.org/doc/year/20/20-108.txt)\nInterpretation: FORM TEAM and failed images (https://j3-fortran.org/doc/year/20/20-102r1.txt)\nInterpretation: Collective subroutines and STAT= (https://j3-fortran.org/doc/year/20/20-104r1.txt)\n\nThursday 2/27\n\nInterpretation: events that cause variables to become undefined (https://j3-fortran.org/doc/year/20/20-119.txt)\nEdits for SIMPLE procedures (https://j3-fortran.org/doc/year/20/20-116.txt)\nBFLOAT16 (https://j3-fortran.org/doc/year/20/20-118.txt)\n#146: Interpretation: allocatable component finalization (https://j3-fortran.org/doc/year/20/20-117.txt)\n\nFriday 2/28\n\n#157: Rank-agnostic syntax (https://j3-fortran.org/doc/year/20/20-120.txt). Passed unanimously with minor changes.\n#156: Protected components (https://j3-fortran.org/doc/year/20/20-121.txt). Withdrawn to address conflicting interests.\n#160: Edits for auto-allocate characters (https://j3-fortran.org/doc/year/20/20-122.txt). Passed unanimously with minor changes.\nEdits for procedure pointer association (https://j3-fortran.org/doc/year/20/20-123.txt). Passed unanimously.\n#157: Edits for rank-agnostic bounds (https://j3-fortran.org/doc/year/20/20-124.txt). Withdrawn because some edits were missing and need to be added. There were concerns about fitting into the framework of generics later on.\n#157: Edits for rank-agnostic array element and section denotation (https://j3-fortran.org/doc/year/20/20-125.txt). Failed (5 v 7). Missing edits, and disagreement on types vs rank-1 integers, the options need to be explored more.\n#157: Edits for rank-agnostic allocation and pointer assignment (https://j3-fortran.org/doc/year/20/20-126.txt). Passed unanimously with minor changes.\nInterpretation: Public namelist and private variable (https://j3-fortran.org/doc/year/20/20-127.txt). Straw vote (0 yes, 8 no, 9 undecided). Passed unanimously with \"no\" alternative.\nInterpretation F18/015 (https://j3-fortran.org/doc/year/20/20-105.txt). Passed unanimously.\n\nFuture Plan\nThis was on the plan but we didn't get to it:\n\n#5: US 27 POINTER dummy arguments, INTENT, and target modification (https://j3-fortran.org/doc/year/18/18-144r1.txt)\n#19: Short-circuiting",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "marshallward",
                    "date": "2020-02-29 19:06:02+00:00",
                    "text": "Big thanks to @certik and @zjibben for preparing this report and keeping us connected with the subcommittee discussions.\nThis greater transparency gives us more confidence to commit to the language in our own work, and is a great continuation of the work done by @sblionel and others in J3.\nI hope that the other committee members will also contribute to the discussions here and help all of us better understand the contours of the language and its evolution."
                }
            ]
        },
        {
            "number": 154,
            "user": "marshallward",
            "date": "2020-02-24 20:12:39+00:00",
            "title": "Examples added to namelist delim + reformat",
            "text": "An example section was added to the Namelist delimiter proposal in order\nto highlight the problem of non-delimited character array namelist\noutput.\nThe text was also reformatted to 72 columns, since this seems to be the\nstandard used by other proposals.\nOther aberrant use of reST syntax was also removed.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:38:18+00:00",
                    "text": "@zjibben would you be willing to sponsor this proposal and upload it?"
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 19:07:37+00:00",
                    "text": "Thank you @marshallward ! I gave the JOR subgroup in J3 a copy of your paper."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-27 20:15:33+00:00",
                    "text": "Great!  Thanks very much for handling this for me.\n\u2026\nOn Thu, Feb 27, 2020 at 2:07 PM Zach Jibben ***@***.***> wrote:\n Thank you @marshallward <https://github.com/marshallward> ! I gave the\n JOR subgroup in J3 a copy of your paper.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#154?email_source=notifications&email_token=AADQ325YNEHQGY6KE6BGXEDRFAFPVA5CNFSM4K2Q7YW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENFR7TY#issuecomment-592125903>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AADQ32ZDRJNCP77D2HNLDPLRFAFPVANCNFSM4K2Q7YWQ>\n ."
                }
            ]
        },
        {
            "number": 153,
            "user": "aradi",
            "date": "2020-02-24 10:58:17+00:00",
            "title": "General array indexing infrastructure",
            "text": "The implementation of first the generic statistical functions in stdlib exposed the lack of a general array indexing infrastructure of Fortran. For example, in the experimental implementation of a generic mean() function one has to generate a separate function for each possible rank. It would be nice, if Fortran offered an infrastructure which makes the generation of this vast amount of routines unnecessary. Let's collect in this issue, what we would need for that:\nI my opinion, we lack following features for the moment:\n\nPossibility for a function to return an array with a rank unknown at compile time (the array should not be necessary an allocatable one!)\nGeneral indexing scheme, which allows accessing arrays / strides / slices in an array without the usual comma-separated index notation. (Funny enough, the Fortran 2018 C-interoperability makes that possible, but only in C! It would be nice, if he had similar tools in Fortran!)\n\nAs a proof of concept, let's require functionality which enables to write a function, which just wraps the sum() intrinsic (taken from #144).\nmodule test\n  implicit none\n\ncontains\n\n  function sum_wrapper(array, dim) result(redarray)\n    real, dimension(..), intent(in) :: array\n    integer, intent(in) :: dim\n    ! Dimension would be an array of \"slice-types\" allowing dynamic\n    ! determination of the shape of the returned array\n    real, dimension(get_redarray_shape(array, dim)) :: redarray\n\n    redarray(get_redarray_shape(array, dim)) = sum(array, dim=dim)\n\n  end function sum_wrapper\n\n\n  pure function get_redarray_shape(array, dim) result(redshape)\n    real, dimension(..), intent(in) :: array\n    integer, intent(in) :: dim\n    type(slice), dimension(rank(array) - 1) :: redshape\n    integer :: ii\n\n    do ii = 1, dim - 1\n      ! With the intrinsic function get_slices, we should get access to the\n      ! slicing parameters of the array (similar, how you can do it in C since\n      ! Fortran 2018)\n      redshape(ii) = get_slices(array, dim=ii)\n    end do\n    do ii = dim + 1, rank(array)\n      redshape(ii - 1) = get_slices(array, dim=ii)\n    end do\n\n  end function get_redarray_shape\n\nend module test\n\nHaving functionality along those lines (eventually combined with the one described in #144) would enable to write rank-agnostic general functions, on par with the intrinsic sum() and product() functions.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2020-02-27 19:09:27+00:00",
                    "text": "See https://j3-fortran.org/doc/year/20/20-115r1.txt and https://j3-fortran.org/doc/year/20/20-113r1.txt which were passed for 202X."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 19:39:27+00:00",
                    "text": "See #157. @aradi in there you commented that this might not be enough."
                }
            ]
        },
        {
            "number": 152,
            "user": "zjibben",
            "date": "2020-02-24 01:43:07+00:00",
            "title": "Add proposal guidance",
            "text": "",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 151,
            "user": "zjibben",
            "date": "2020-02-24 00:08:18+00:00",
            "title": "Reformat namelist delimiter proposal",
            "text": "75 character line length\ntext file rather than restructured text (only changed the header)",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 150,
            "user": "certik",
            "date": "2020-02-23 23:49:54+00:00",
            "title": "Use 75 characters",
            "text": "",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 149,
            "user": "certik",
            "date": "2020-02-23 18:44:01+00:00",
            "title": "Namespaces",
            "text": "Resubmitting the namespaces proposal",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:48:39+00:00",
                    "text": "Uploaded at https://j3-fortran.org/doc/year/20/20-108.txt."
                }
            ]
        },
        {
            "number": 148,
            "user": "zjibben",
            "date": "2020-02-23 18:02:07+00:00",
            "title": "Fix proposal formatting",
            "text": "J3 papers have a 75 character line limit.\nSome characters aren't allowed.\n\nShould we mention this in the README?\nUnrelated, I also added a reference to this github page for one of the proposals.",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 147,
            "user": "zjibben",
            "date": "2020-02-22 22:37:33+00:00",
            "title": "Add sections on intent(inout) and arrays to optional-default proposal",
            "text": "More on the proposal for #22. @jvdp1 @certik @milancurcic.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "zjibben",
                    "date": "2020-02-23 17:34:58+00:00",
                    "text": "Thank you all! I will submit this for our meeting."
                }
            ]
        },
        {
            "number": 146,
            "user": "nncarlson",
            "date": "2020-02-21 21:21:54+00:00",
            "title": "Finalization order for complex objects: official interpretation needed?",
            "text": "@certik asked that I share this here.\nI've encountered an issue with finalization that is illustrated by the example that follows. There is a parent type and child type that extends the parent, each with a final subroutine. The child type has two derived type components, one allocatable, the other not. The component types also have final subroutines.  The point of the example is to reveal the order in which the final subroutines are called.\nTwo compilers produce the results I expected, namely the string \"CABP\" for Child, component A, component B, and Parent.  \"CBAP\" would have been equally acceptable.  A third compiler produces the string \"CBPA\".  The preliminary response from the vendor of the latter compiler is that the standard is ambiguous with conflicting requirements and that choice of behavior is arguably valid. They did go into some explanation, but I haven't yet understood their argument. I'll be following up with them, and as I understand more I'll comment here with it. Section 7.5.6.2 (2018) seems pretty clear to me (arguing for \"CABP\") but there may well be other parts of the standard that are inconsistent with it -- I have a lot of respect for this vendor. If an official interpretation and standard clarification is required I would strongly urge for \"CABP\".\n[Edit] The core question here is why does the third compiler vendor believe the allocatable component A have to be finalized last after the parent, whereas the non-allocatable component B should be finalized before the parent.\nHere is the example\nmodule child_type\n\n  implicit none\n  private\n\n  type :: objectA\n  contains\n    final :: finalize_objectA\n  end type\n\n  type :: objectB\n  contains\n    final :: finalize_objectB\n  end type\n\n  type :: parent\n  contains\n    final :: finalize_parent\n  end type\n\n  type, extends(parent), public :: child\n    type(objectA), allocatable :: A\n    type(objectB) :: B\n  contains\n    procedure :: init\n    final :: finalize_child\n  end type\n\ncontains\n\n  subroutine finalize_objectA(this)\n    type(objectA), intent(inout) :: this\n    write(*,'(\"A\")',advance='no')\n  end subroutine\n\n  subroutine finalize_objectB(this)\n    type(objectB), intent(inout) :: this\n    write(*,'(\"B\")',advance='no')\n  end subroutine\n\n  subroutine finalize_parent(this)\n    type(parent), intent(inout) :: this\n    write(*,'(\"P\")',advance='no')\n  end subroutine\n\n  subroutine finalize_child(this)\n    type(child), intent(inout) :: this\n    write(*,'(\"C\")',advance='no')\n  end subroutine\n\n  subroutine init(this)\n    class(child), intent(inout) :: this\n    allocate(this%A)\n  end subroutine\n\nend module\n\nprogram main\n  use child_type\n  call run\ncontains\n  subroutine run\n    type(child) :: c\n    call c%init\n  end subroutine\nend program",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "nncarlson",
                    "date": "2020-02-21 22:08:38+00:00",
                    "text": "A bit of background for those who might be wondering. In the actual use case, the child type is a \"solver\". The solver makes use of a third party framework library AMReX that the solver starts up as part of its initialization and then shuts down when the solver is deallocated or goes out of scope. The solver also has components that have framework objects as subobjects.  These must be finalized before the framework is shutdown. In order to ensure that things happen in the right order, the solver extends a dummy parent type whose main purpose is to shut down the framework as part of the parent's final subroutine. Unfortunately this doesn't work with the way the third compiler behaves.\nIn the actual use case the allocatable component is polymorphic (hence making it non-allocatable isn't an option), but that is an extraneous feature to the core question. Interestingly, one of the compilers that gets the example \"right\" totally blows it for the allocatable polymorphic component case -- it never bothers to call its finalizer at all."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-21 23:09:32+00:00",
                    "text": "Apart from the lack of specification on the order of finalization of components, F'2018 is very clear to me on this point.  \"CABP\" and \"CBAP\" are the only valid outputs.  In particular, the parent component absolutely may not be finalized in step (3) until after the non-parent components have been finalized in step (2) (see 7.5.6.2).\nThe child's final procedure can effectively force the order \"ACBP\" if necessary by deallocating A in finalize_child before doing anything else."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 23:12:42+00:00",
                    "text": "I agree with @nncarlson and @klausler that \"CABP\" and \"CBAP\" should be the only two valid outputs in this case."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-25 23:58:20+00:00",
                    "text": "To me, this looks worthy of an interpretation request."
                },
                {
                    "user": "certik",
                    "date": "2020-02-26 05:06:27+00:00",
                    "text": "How do we submit one?\n\u2026\nOn Tue, Feb 25, 2020, at 3:58 PM, FortranFan wrote:\n To me, this looks worthy of an interpretation request.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146?email_source=notifications&email_token=AAAFAWBXEE7GS2YSDDAAM33REWWBZA5CNFSM4KZKUGP2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEM6DOHI#issuecomment-591148829>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBZWO2TYYCZA2RRLFDREWWBZANCNFSM4KZKUGPQ>."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-26 06:15:00+00:00",
                    "text": "@certik wrote:\n\nHow do we submit one?\n..\n\nStart with an email to the J3 mailing list.  Then as needed based on clarity and/or suitability of the response(s), draft a paper like this: https://j3-fortran.org/doc/year/20/20-102.txt"
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 00:46:44+00:00",
                    "text": "There is an interp paper on this for discussion tomorrow: https://j3-fortran.org/doc/year/20/20-117.txt."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 02:39:33+00:00",
                    "text": "Actually I think this paper is a little bit different if you look at the example carefully. But maybe it exposes the same issue.\n\u2026\nOn Wed, Feb 26, 2020, at 4:46 PM, Zach Jibben wrote:\n There is an interp paper on this for discussion tomorrow:\n https://j3-fortran.org/doc/year/20/20-117.txt.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146?email_source=notifications&email_token=AAAFAWGWNROTW7LYMV6ADETRE4EPJA5CNFSM4KZKUGP2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENCOUMY#issuecomment-591718963>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGKUOQX3DUG7BV5HS3RE4EPJANCNFSM4KZKUGPQ>."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 02:47:33+00:00",
                    "text": "I'm not sure of what to make of the document. Rather opaque on my first reading. I hope the outcome, whatever the means, is that the required behavior is what we seem to agree is wanted. Please push for that tomorrow."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 03:02:40+00:00",
                    "text": "@certik the example from the document is precisely the same as the one gave in here."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-27 04:48:52+00:00",
                    "text": "@certik the example from the document is precisely the same as the one gave in here.\n\nThere is a difference in that the example in the interpretation document at the J3 website does NOT have the equivalent of 'objectB' as a component in the child derived type:\n\nPlus there is the aspect where discussion in the interp doc addresses quite a bit the concern about an object ('OtherF') being finalized twice.\nThat doesn't appear in the original post here since that would  have led to comments about 'A' appearing twice in the output of the program in the original post."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 06:41:58+00:00",
                    "text": "Indeed, it seems different. For that reason I submitted a new one:\nhttps://mailman.j3-fortran.org/pipermail/j3/2020-February/011838.html\nFor now just as an email. Based on the response and discussion tomorrow, we can submit a full request."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 13:57:52+00:00",
                    "text": "As @FortranFan pointed out the only difference was the addition of an objectB component. I added that simply to highlight how finalization of non-allocatable component is done differently from that for an allocatable for the one problem compiler.  I should probably say \"cleanup\" instead of \"finalization\", because I sense from the interp doc, that finalization is being used in a very strict technical sense that isn't completely synonymous with what I think of naively as cleanup.\nI know of no compiler that does the finalization twice like the interp doc discusses. In fact, the problem compiler of the OP is the NAG compiler, and its odd behavior is precisely to avoid finalizing twice per an explanation passed on to me from Malcolm. I still don't understand why he believes one possible interp requires finalizing twice -- I'm missing something, hopefully @certik and @zjibben will be able to explain what the problem is after today's deliberation."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 17:01:41+00:00",
                    "text": "So after the discussion at plenary the paper https://j3-fortran.org/doc/year/20/20-117.txt got passed.\nWith the standard, as amended by 20-117, the CBPA output is allowed and ok, per standard."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 17:07:23+00:00",
                    "text": "Argh... Was there much disagreement? apparently there weren't enough people who saw (or cared) how stupid (imo) that is."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 17:08:46+00:00",
                    "text": "I've been studying the edits in that paper, and (discussion in the room notwithstanding) I don't see anything that changes the organization of the section in the standard (7.5.6.2) that puts finalization of the parent component in step (3), after the finalization of the extended type's instance and its components.\nEDIT: This is wrong; these edits do break the order of finalization of a parent component w/r/t allocatable components in instances of its extended derived types."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 17:10:23+00:00",
                    "text": "I also think that there was a lot of ambiguous usage of the word \"parent\" in the meeting, and at least two people were using the word to mean \"the object being finalized, as opposed to its 'child' components\", and not \"the parent component of the extended derived type\"."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 17:11:00+00:00",
                    "text": "@klausler per your understanding, is the CBPA output allowed by the standard (for the code above)?"
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 17:15:55+00:00",
                    "text": "Parent components are finalized in step (3) in the standard.  I don't see anything in the edits in the actual paper (https://j3-fortran.org/doc/year/20/20-117.txt) that changes that.  But the discussion was highly confused (or at least confusing).\nEDIT: Now I see them; never mind."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-02-27 17:24:42+00:00",
                    "text": "@klausler, what about\n\n[80:9] 7.5.6.2 The finalization process, p1, item (2),\n\"All finalizable\" -> \"All nonallocatable finalizable\".\n\nWith that change, 7.5.6.2 does't appear to have anything to say about what happens to allocatable finalizable components."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 17:30:24+00:00",
                    "text": "I've come to the same conclusion here, Neil.  And that seems broken to me."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 17:35:07+00:00",
                    "text": "The issue was that the standard said to finalize the allocatable components twice. So we had to remove it from one place ---- unfortunately we removed it from the wrong place. So this edit 20-117 breaks the standard in our opinion. We need to reverse it."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-27 19:53:04+00:00",
                    "text": "If I understood the discussion at the meeting correctly, the Fortran standard will try its damndest to leave the order of finalization of components in a finalizable type up to the compiler - \"processor-dependent\" per standardese.  That is, the finalization of an object in a standard-conforming program can occur in different order as long the possibilities cover the sequence as indicated in section 7.5.6.2 which includes\n\n\nthe parent type, if finalizable, will be finalized after the final subroutine for child is invoked,\n\n\nthe allocatable components of the object being finalized get addressed separately via the existing semantics in section 9.7.3.2 on \"Deallocation of allocatable variables\".  In connection with this, please note the sentence in the 20-117 interp document, \"The design where allocatable entities are finalized at the time of deallocation would seem to be simpler, easier to understand, and less buggy.\""
                },
                {
                    "user": "reubendb",
                    "date": "2020-02-28 13:27:49+00:00",
                    "text": "My reading of the standard as it is, is that only both of the following output are allowed: \"CBAP\" and \"CABP\". The standard is currently under-specified such that \"CBAPA\" is also a legal, that is, A is doubly-finalized. I don't think \"CBPA\" is a valid output with the current standard (and could be a compiler bug).\nOut of the four compilers I tried, three produces \"CABP\" (correctly), and one produces \"CBPA\", which in my opinion is a bug.\nPaper 20-117 actually attempts to fix the double finalization issue mentioned above. Unfortunately, I think the (unintended?) consequence is that all three output---\"CBAP\", \"CABP\", and \"CBPA\"--- would be legal and is processor dependent.\nI think \"CBPA\" is, at least, very counter-intuitive to users and should not be allowed, although at the moment I can't come up with a good technical reason for why it should not be allowed. But it does seem that it would defy user's expectation. There were some further discussions on coming up with a better fix that would address all of these issues at once."
                },
                {
                    "user": "klausler",
                    "date": "2020-04-06 23:45:25+00:00",
                    "text": "Here's another test for your enjoyment.  Of the compilers that I have on site, only ifort and xlf seem to finalize in a non-surprising order (1-10, or 6-10/1-5).  I will ensure that f18 is also non-surprising.\nmodule m\n  type :: t1\n    integer :: n1\n   contains\n    final :: finalt1Elem, finalt1Vec\n  end type\n  type :: t2\n    integer :: n2\n    type(t1), allocatable :: a2(:)\n   contains\n    final :: finalt2Elem, finalt2Vec\n  end type\n  type, extends(t2) :: t3\n    integer :: n3\n    type(t2), allocatable :: a3(:)\n   contains\n    final :: finalt3Elem, finalt3Vec\n  end type\n contains\n  impure elemental subroutine finalt1Elem(x)\n    type(t1), intent(inout) :: x\n    print *, \"finalt1Elem\", x%n1\n  end subroutine\n  subroutine finalt1Vec(x)\n    type(t1), intent(inout) :: x(:)\n    print *, \"finalt1Vec\", x(:)%n1\n  end subroutine\n  impure elemental subroutine finalt2Elem(x)\n    type(t2), intent(inout) :: x\n    print *, \"finalt2Elem\", x%n2\n  end subroutine\n  subroutine finalt2Vec(x)\n    type(t2), intent(inout) :: x(:)\n    print *, \"finalt2Vec\", x(:)%n2\n  end subroutine\n  impure elemental subroutine finalt3Elem(x)\n    type(t3), intent(inout) :: x\n    print *, \"finalt3Elem\", x%n3\n  end subroutine\n  subroutine finalt3Vec(x)\n    type(t3), intent(inout) :: x(:)\n    print *, \"finalt3Vec\", x(:)%n3\n  end subroutine\nend module\n\nsubroutine test\n  use m\n  type(t3) :: x0, x1(1)\n  integer :: n\n  n = 1\n  call populatet3(x0)\n  call populatet3(x1(1))\n  print *, 'expect ', n-1, ' finalizations'\n contains\n  integer function next()\n    next = n\n    n = n + 1\n  end function\n  subroutine populatet1(x)\n    type(t1), intent(inout) :: x\n    x%n1 = next()\n  end subroutine\n  subroutine populatet2(x)\n    class(t2), intent(inout) :: x\n    x%n2 = next()\n    allocate(x%a2(1))\n    call populatet1(x%a2(1))\n  end subroutine\n  subroutine populatet3(x)\n    type(t3), intent(inout) :: x\n    x%n3 = next()\n    allocate(x%a3(1))\n    call populatet2(x%a3(1))\n    call populatet2(x)\n  end subroutine\nend subroutine\n\nprogram main\n  call test\nend program"
                },
                {
                    "user": "klausler",
                    "date": "2020-06-04 18:37:12+00:00",
                    "text": "Does anybody understand the change that's out for letter ballot at the moment for this problem?\nI think it precludes multiple finalization of A, which is good, but would allow a compiler to implement any of CABP, CBAP, and CBPA call orders (in terms of the original example), if I understand it accurately.\nA program could force CABP by explicitly deallocating the allocatable component in the final procedure for the containing object, yes?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 18:38:27+00:00",
                    "text": "@klausler that is my understanding, but I am going to ask at the J3 mailinglist to clarify this. Update: submitted here: https://mailman.j3-fortran.org/pipermail/j3/2020-June/012101.html"
                },
                {
                    "user": "reubendb",
                    "date": "2020-06-04 18:42:56+00:00",
                    "text": "@klausler Those are my understanding as well (see my comments above). Some of us worked this out in our subgroup and I believe came out with the same conclusion."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-04 18:48:50+00:00",
                    "text": "Ok, thanks.  I want f18 to do CBAP to be least surprising to those familiar with C++ destructors; does that sound okay?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 18:51:02+00:00",
                    "text": "@klausler that sounds like what all compilers should do, as that is what users expect."
                },
                {
                    "user": "certik",
                    "date": "2020-06-06 20:32:48+00:00",
                    "text": "Malcolm just posted a partial and a full analysis of @nncarlson's code above. The answer is as @klausler wrote, i.e., if the interp is accepted, all three of the answers are valid: CABP or CBAP or CBPA. And yes, one can force CABP by explicitly deallocating the allocatable component in the final procedure for the containing object."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-06-06 23:16:26+00:00",
                    "text": "As someone who uses Fortran, I find the behaviour CBPA to be bizarre and unacceptable. Has anyone stepped forward (Malcolm?) to defend that behavior as sensible? Sure I can live with it by writing a final procedure that I otherwise would not have had to do, but if this goes through it's going to be another black mark on the language compared to other alternative languages."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 00:05:06+00:00",
                    "text": "I think there is a wide agreement that CBPA is not wanted, and so I am going to vote NO for LANL on this interp.\n\u2026\nOn Sat, Jun 6, 2020, at 5:16 PM, Neil Carlson wrote:\n\n\n As someone who uses Fortran, I find the behaviour CBPA to be bizarre\n and unacceptable. Has anyone stepped forward (Malcolm?) to defend that\n behavior as sensible? Sure I can live with it by writing a final\n procedure that I otherwise would not have had to do, but if this goes\n through it's going to be another black mark on the language compared to\n other alternative languages.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWCPTFBQAXQ6FE4QTZLRVLE5NANCNFSM4KZKUGPQ>."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-06-07 13:19:00+00:00",
                    "text": "@nncarlson wrote June 6, 2020 7:16 PM PDT:\n\nAs someone who uses Fortran, I find the behaviour CBPA to be bizarre and unacceptable. Has anyone stepped forward (Malcolm?) to defend that behavior as sensible? Sure I can live with it by writing a final procedure that I otherwise would not have had to do, but if this goes through it's going to be another black mark on the language compared to other alternative languages.\n\nThe \"full' analysis mentioned by @certik above attempts to explain how the standard permits 'CBPA'.  The rationale appears to again come back to the major role played by backwards compatibility (#79) in Fortran, this time with the semantics of auto-deallocation of ALLOCATABLEs whose introduction preceded by well over a decade that of the finalization facility.  To allow 'CBPA' appears to have consequences with ALLOCATABLEs.\nALLOCATABLEs is among the most valuable features in the language and Fortran is rather unique in providing such support intrinsically..  This allows programmers to get closer to formula translation rather than deal with memory management, GC (garbage collection), etc. in the codes toward scientific and technical computing.\nGiven the use case provided by OP in #146 (comment) with AMReX, implementing a finalizer for the case at hand appears a safe approach regardless of the language standard.  And which then would avoid the concerns with this particular situation."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-06-07 13:24:50+00:00",
                    "text": "@certik wrote June 6, 2020 8:05 PM PDT:\n\nI think there is a wide agreement that CBPA is not wanted, and so I am going to vote NO for LANL on this interp.\n\n@certik ,  as I mentioned in #146 (comment), please review the full analysis on the J3 mailing list with your colleagues at LANL wrt the history and semantics of ALLOCATABLEs in Fortran.  Perhaps that might change your vote?"
                },
                {
                    "user": "nncarlson",
                    "date": "2020-06-07 15:59:49+00:00",
                    "text": "@FortranFan, yes I have studied Malcolm's analysis. He does a nice job of explaining how allocatables and finalization evolved separately and how we arrived at the state things are today. It also explains how some compilers have arrived at implementing Strategy One, including presumably NAG's, and that the goal of his proposed interp is to preserve such implementations. However as a user looking from the outside, that internal implementation detail carries little weight with me.  To me the fundamental question is does it make sense for A to be finalized after P, and in particular does it make sense for A to be finalized after P when its sibling component B is finalized before merely because one is allocatable and one is not.  I find that behavior to be very surprising and at odds with C++, for example, and I would imagine other OO languages.\nYou specifically called out allocatable.  I wholeheartedly agree about their value, but I don't see that an alternative interp that would reject the CBPA order (implemented using Malcolm's Strategy Two perhaps) would need to do anything whatsoever to damage them or change their semantics. Am I mistaken there? Nor would it break code that used to be unambiguously valid; this is not a backwards compatibility question that I can see.\nPerhaps I overlooked something in Malcolm's analysis that you think should sway my opinion; if so, please point it out to me."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 16:17:37+00:00",
                    "text": "@FortranFan from a user perspective it does not seem to break backwards compatibility to exclude CBPA, because users couldn't have relied on that anyway, given that CABP has always been allowed.\nThe main argument here is that Fortran does something unexpected, forcing users to force de-allocation order, that in other languages such as C++ works out of the box. We don't want users to move to C++, we want to keep them in Fortran. Allowing CBPA would hurt the cause here. I am sure @nncarlson is not the only one that got surprised by it."
                },
                {
                    "user": "pbrady",
                    "date": "2020-06-08 15:13:54+00:00",
                    "text": "Anything that makes c++ more intuitive than Fortran is very, very bad"
                },
                {
                    "user": "klausler",
                    "date": "2020-06-08 16:01:50+00:00",
                    "text": "Is there any existing Fortran compiler or runtime that implements the CBPA order?  Is there any current application that relies on the CBPA order?  I'm struggling to understand why the language standard would need to preserve that option."
                },
                {
                    "user": "zjibben",
                    "date": "2020-06-08 16:03:48+00:00",
                    "text": "NAG implements CBPA."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-08 16:11:20+00:00",
                    "text": "NAG implements CBPA.\n\nWell, a lot of pieces just fell into place with my understanding of this problem."
                },
                {
                    "user": "certik",
                    "date": "2020-06-08 16:33:13+00:00",
                    "text": "I just asked at the J3 mailinglist if there are other arguments to allow the CBPA order. (The last line in my email starting with >From the user perspective has a quote > at front that was added by Mailman, the online email archive. It is not there in my original email...)"
                },
                {
                    "user": "nSircombe",
                    "date": "2020-06-09 06:30:50+00:00",
                    "text": "Ok, thanks. I want f18 to do CBAP to be least surprising to those familiar with C++ destructors; does that sound okay?\n\n@klausler - just to check (since much of the discussion in the tread appears to favour CABP) did you mean CBAP, or CABP?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-09 15:30:38+00:00",
                    "text": "did you mean CBAP, or CABP?\n\nHi @nSircombe nice to see you here. My understanding is that both CBAP and CABP are acceptable from the user perspective, I don't think there is any ordering between A and B based on the semantics. The key is that P is at the end. Maybe @klausler can correct me."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-09 15:33:18+00:00",
                    "text": "C++ destructors are invoked in the opposite order of constructors.  If the component order is AB, then it makes sense to me to deallocate &/or finalize B before A for least surprise."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-06-09 23:17:36+00:00",
                    "text": "In 7.5.6.1 p2 it says: \"A derived type is finalizable if and only if it has a final subroutine or a nonpointer, nonallocatable component of finalizable type.\"\nDoes any one understand why allocatable components were excluded in the definition of \"finalizable\"?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-06-13 00:18:03+00:00",
                    "text": "Malcolm replied today on the J3 list:\n\nHi folks,\nSome probably-final comments from me on this topic\nThere is no doubt in my mind that finalization was not intended to, and does not cause deallocation (evidence: the standard does not say that it does).\nThere is equally no doubt in my mind that deallocation of allocatable and pointer entities was intended to, and does cause finalization (evidence: the standard says that).\nThere is similarly no doubt in my mind that allocatable components were not intended to be finalized as part of the containing object finalization, but as part of the automatic deallocation process (evidence: the definition of finalizable in the standard ignores allocatable components).\nThus I think the interp should remain as it is now.\nInterestingly, of the four compilers that I have access to and which support FINAL, two out of the four produce CBPA for Ondrej\u2019s example, and two produce CABP. Changing the A component to \u201cCLASS(*)\u201d and the allocation to allocate it as type OBJECTA, the two CBPA-producing compilers remain producing CBPA (as one might expect if they\u2019re following the deallocation-causes-finalization model), but one of the other two now produces CBP which is clearly erroneous.\nI am not necessarily opposed in principle to the idea of changing finalization to cause deallocation of allocatable components, though it seems to me that the user already has the tools available to force an ordering when he wants to, so I am yet to be convinced of its usefulness. I do however, think this would be a significant change to the design (virtually a new feature), and so should be considered (should we decide that it is in fact desirable) in a future revision."
                },
                {
                    "user": "sblionel",
                    "date": "2020-06-13 00:23:19+00:00",
                    "text": "FWIW, it's ifort that gives CBP in the revision Malcolm mentions. I will let them know."
                }
            ]
        },
        {
            "number": 145,
            "user": "zjibben",
            "date": "2020-02-21 00:32:44+00:00",
            "title": "Prepare default value for optional arguments proposal for submission.",
            "text": "This continues the default-value saga from #22 #137 and #140.\nI made a few formatting changes, added an introduction, and tried to capture some of the discussion in #140 about intent(out) arguments. My goal is to make sure our interests and the possible different behaviors are expressed, so the Committee has some ideas to consider. I'd like to get it in shape to submit before the meeting next week, and hope to discuss it there.\n@jvdp1, I added your name to the proposal if you don't mind. Please let me know if you would like this changed and if spelling is correct.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-21 23:10:06+00:00",
                    "text": "It seems there is general agreement on these changes. Further discussion might be needed on top, so let's open issues or further PRs as needed. I merged this, so that we have something in the repository that we can at least roughly agree on, and we can now work on polishing it up so that @zjibben can submit it as an official proposal.\nIn general, if we can't reach agreement, I think it is perfectly ok to simply propose the alternatives (with pros and cons) in the proposal, and let the committee discuss it and provide feedback."
                }
            ]
        },
        {
            "number": 144,
            "user": "reinh-bader",
            "date": "2020-02-14 10:42:03+00:00",
            "title": "Generic processing of assumed rank objects",
            "text": "The concept of assumed rank permits definition of interfaces that are rank-agnostic.\nThe addition of the SELECT RANK block construct permits definitions and references to the object by resolving at run time to whatever rank the actual argument has. This is fine in case the array rank e.g. reflects different problem dimensions, requiring different algorithms for its solution. However, there are also cases in which uniform treatment of the argument's data irrespective of its rank is required. This is currently cumbersome to do.\nThis proposal suggests supporting this at least for the case of a CONTIGUOUS argument by remapping to a suitable rank-1 entity.\nVariant 1: Permit pointer assignment\nAssuming declarations\nREAL, CONTIGUOUS, TARGET :: X(..)\nREAL, POINTER :: XP(:)\nit should be permissible to write\nXP(1:SIZE(X)) => X\nNote that for X assumed shape and any rank, this is already permitted. Some words would be needed to treat the rank 0 and rank \"*\" cases. The data in X could then be processed via XP.\nVariant 2: Extend ASSOCIATE semantics\nAssuming a declaration\nREAL, CONTIGUOUS :: X(..)\nit should be permissible to write\nASSOCIATE(XA(1:SIZE(X)) => X)\n... ! definitions and references to XA\nEND ASSOCIATE\nThis variant would not require the TARGET attribute on X. Inside the ASSOCIATE block, the data could be processed via XA.\nRequiring the CONTIGUOUS attribute imposes no limitation on functionality. Users need to be made aware of the potential performance impact for copy-in/out.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-02-14 11:55:57+00:00",
                    "text": "Having read your proposal, I am inclined towards the ASSOCIATE alternative - it feels more inline with the newer constructs. I guess it also be possible to do:\nM = 10 N = SIZE(X)/M ASSOCIATE( XA(1:N,1:M) => X)\nirrespective of the rank of X.\nOtherwise, if the ASSOCIATE is limited to one-dimensional \"mappings\", the \"(1:SIZE(X)\" could be replaced by \"(:)\" to indicate that a one-dimensional mapping is required. (I am sure I do not oversee all ramifications)"
                },
                {
                    "user": "reinh-bader",
                    "date": "2020-02-14 12:13:26+00:00",
                    "text": "While permission of multi-rank mappings could certainly be allowed, it is not really germane to the use-case at hand. I also prefer the ASSOCIATE, but the rank-remapped pointer conveys the idea, since it is already in the language. The bounds specs, I think, are necessary. Especially for the rank \"*\" case."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-24 06:25:05+00:00",
                    "text": "I think, this possibility could/should be combined with the possibility of returning an array of arbitrary rank in a function, and a generic way to access the indexing of the arrays, similar how it can be already in C since Fortran 2018.\nmodule test\n  implicit none\n\ncontains\n\n  function sum_wrapper(array, dim) result(redarray)\n    real, dimension(..), intent(in) :: array\n    integer, intent(in) :: dim\n    ! Dimension would be an array of \"slice-types\" allowing dynamic\n    ! determination of the shape of the returned array\n    real, dimension(get_redarray_shape(array, dim)) :: redarray\n\n    redarray(get_redarray_shape(array, dim)) = sum(array, dim=dim)\n\n  end function sum_wrapper\n\n\n  pure function get_redarray_shape(array, dim) result(redshape)\n    real, dimension(..), intent(in) :: array\n    integer, intent(in) :: dim\n    type(slice), dimension(rank(array) - 1) :: redshape\n    integer :: ii\n\n    do ii = 1, dim - 1\n      ! With the intrinsic function get_slices, we should get access to the\n      ! slicing parameters of the array (similar, how you can do it in C since\n      ! Fortran 2018)\n      redshape(ii) = get_slices(array, dim=ii)\n    end do\n    do ii = dim + 1, rank(array)\n      redshape(ii - 1) = get_slices(array, dim=ii)\n    end do\n\n  end function get_redarray_shape\n\nend module test\n\nThis possibility, combined with the multi-rank mapping as suggested by @arjenmarkus would eliminate a lot of the Fypp-magic in the stdlib-statistical functions."
                },
                {
                    "user": "reinh-bader",
                    "date": "2020-02-24 10:20:58+00:00",
                    "text": "Has the concept of type(slice) already been submitted as an issue?\nFurther, how do you invoke sum_wrapper? Fortran currently defines no semantics for array expressions whose rank is not determined at compile time."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-24 10:59:21+00:00",
                    "text": "I've now created issue #153 for that in order not to pollute this issue."
                }
            ]
        },
        {
            "number": 143,
            "user": "difference-scheme",
            "date": "2020-02-05 17:42:09+00:00",
            "title": "First draft of run-time polymorphism proposal",
            "text": "This proposal resulted from the discussion in Issue #125. It accounts for some of the suggestions made there, but includes also some (minor) new twists. It motivates why Fortran's run-time polymorphism needs to be strengthened, and includes a use case to demonstrate the advantages of the proposed features.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-05 21:33:55+00:00",
                    "text": "This is great. Thanks. I do have few questions, to which I hadn't devised good answers myself yet.\n\nShould it be possible to give multiple interfaces in a declaration? I.e.\n\ntrait(ISolver, IPrinter) :: client\n\nor would one need to \"compose\" a new interface from the two and provide that name as done in the examples you give?\n\nWhat would the interface look like for procedures that are pass? I.e.\n\nabstract interface :: IShowable\n    function show(self) result(string)\n        trait(IShowable), intent(in) :: self ! Is this right?\n        character(len=:), allocatable :: string\n    end function show\nend interface IShowable\n\ntype, implements(IShowable) :: my_type\n...\ncontains\n    procedure :: show => my_type_show\nend type my_type\n\nfunction my_type_show(self) result(string)\n    class(my_type), intent(in) :: self\n    character(len=:), allocatable :: string\n\n    string = \"My Type\"\nend function my_type_show\n\n\nWhat if you wanted an interface with a procedure that took two arguments of the same type? I.e.\n\nabstract interface :: IAddable\n    function add(self, other) result(combined)\n        trait(IAddable), intent(in) :: self\n        trait(IAddable), intent(in) :: other\n        trait(IAddable) :: combined ! Is this possible?\n    end function add\nend interface IAddable\n\ntype, implements(IAddable) :: my_type\n...\ncontains\n    procedure :: add => my_type_add\nend type my_type\n\n! Does this conform to the interface now?\nfunction my_type_add(self, other) result(combined)\n    class(my_type), intent(in) :: self\n    type(my_type), intent(in) :: other\n    type(my_type) :: combined\n\n    combined = ! some expression with self and other\nend function my_type_add\n\nI feel like this might only possible with compile time stuff like templates, but wondered if you had any ideas."
                },
                {
                    "user": "certik",
                    "date": "2020-02-05 21:45:27+00:00",
                    "text": "Thank you for submitting this! @tclune what is your opinion on this?"
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-06 13:03:34+00:00",
                    "text": "@everythingfunctional So far I have thoughts on your first two points, so let's focus\non those.\n\n\nYes, one would have to compose a new interface and use it as in the examples. The reason\nis that a named abstract interface would be viewed as a type in its own right, and the meaning\nof say the declaration\ntrait(ISolver), allocatable :: solver\nis that solver is to be treated like a (polymorphic) variable of type ISolver. Fortran is needlessly verbose here. In Java the above would simply be written as follows:\nISolver solver;\nSo, in this notation, your above example would be\nISolver, IPrinter client;\nwhich I am pretty sure Java doesn't allow because it views it as a self-contradiction (as the variable can only have one declared type).\n\n\nConcerning the declaration of the variable self within the IShowable interface of your second example: I think this variable must be declared as being an instance of the derived type my_type, rather than being of type IShowable. The reasoning being that the function show is a procedure that is bound to my_type, and would thus need to have, in general, access to my_type's data fields, in order to do some useful work. But data fields are forbidden for interfaces.\n\n\nSo, your example of IShowable's declaration would have to read something like this\nabstract interface :: IShowable\n    import :: my_type\n    function show(self) result(string)\n        type(my_type), intent(in) :: self\n        character(len=:), allocatable :: string\n    end function show\nend interface IShowable\n\ntype, implements(IShowable) :: my_type\n...\ncontains\n    procedure :: show => my_type_show\nend type my_type\n\n\nwhich brings us to the next point: this is a nasty circular reference (IShowable depends on my_type, while my_type depends on IShowable) that would need to be dealt with somehow.\nI personally believe that it will be essentially impossible, in any OO application code of some complexity, to entirely avoid circular references. But we want their occurrence to be among interfaces only. We don't want them to occur among concrete implementation types, and we sure don't want them to occur between interfaces and types that depend on them.\nUnless I am missing something, I believe we need to check in detail how this has been dealt with in Rust."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-06 15:51:59+00:00",
                    "text": "Rust has a way of referring to the \"Implementation\" type inside a trait block. The keyword Self. See this. We could do something similar by simply stating that within an abstract interface block, referring to the interface (trait) as class(ITrait) or type(ITrait) means replace it with the actual type implementing the trait, whereas trait(ITrait) does not.\nI think with that additional specification you could solve both my situations like\nabstract interface :: IShowable\n    function show(self) result(string)\n        class(IShowable), intent(in) :: self\n        character(len=:), allocatable :: string\n    end function show\nend interface IShowable\n\ntype, implements(IShowable) :: my_type\n...\ncontains\n    procedure :: show => my_type_show\nend type my_type\n\nfunction my_type_show(self) result(string)\n    class(my_type), intent(in) :: self\n    character(len=:), allocatable :: string\n\n    string = \"My Type\"\nend function my_type_show\n\nand\nabstract interface :: IAddable\n    function add(self, other) result(combined)\n        class(IAddable), intent(in) :: self\n        type(IAddable), intent(in) :: other\n        type(IAddable) :: combined\n    end function add\nend interface IAddable\n\ntype, implements(IAddable) :: my_type\n...\ncontains\n    procedure :: add => my_type_add\nend type my_type\n\nfunction my_type_add(self, other) result(combined)\n    class(my_type), intent(in) :: self\n    type(my_type), intent(in) :: other\n    type(my_type) :: combined\n\n    combined = ! some expression with self and other\nend function my_type_add\n\nWe may need to think through all the implications that will have on inheritance though. For example, inside an interface block that inherits from another, does that mean referring to any of those traits that way means the actual type implementing that trait? Probably.\nBut what about abstract and extended types? If I create an abstract type that \"implements\" a trait, but defers implementation of some of the procedures, in the extended type, when implementing the necessary procedures, do arguments of type(ITrait) refer to the parent type or the child type? Probably the child type.\nI think we can probably define the spec well enough to handle this, just trying to make sure we think through all the edge cases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-06 16:14:19+00:00",
                    "text": "My next question is then about \"generics\", and brings up the question about which argument is pass.\nSay I want to implement a something like\nabstract interface :: IScalable\n    function multiplyLeft(multiplier, self) result(scaled)\n        double precision, intent(in) :: multiplier\n        class(IScalable), intent(in) :: self\n        type(IScalable) :: scaled\n    end function multiplyLeft\n\n    function multiplyRight(self, multiplier) result(scaled)\n        class(IScalable), intent(in) :: self\n        double precision, intent(in) :: multiplier\n        type(IScalable) :: scaled\n    end function multiplyRight\n\n    function divide(self, divisor) result(scaled)\n        class(IScalable), intent(in) :: self\n        double precision, intent(in) :: divisor\n        type(IScalable) :: scaled\n    end function divide\n\n    interface operator(*)\n        module procedure multiplyLeft\n        module procedure multiplyRight\n    end interface operator(*)\n\n    interface operator(/)\n        module procedure divide\n    end interface operator(/)\nend interface IScalable"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-06 16:34:15+00:00",
                    "text": "I have another thought related to this, but that should probably be a follow up proposal. What about a library that defines a trait, and another library that defines a type, but I'd like to be able to use them together?\nIn Rust this is possible because the implementation of a trait is separate from the definition of the type, and can be done in multiple places. Would it be possible in Fortran to allow types to be \"re-opened\" so as to add procedures in a different place? Maybe not, and we'll just have to stick with wrapper types for that use case, but it may be worth considering."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-06 16:54:01+00:00",
                    "text": "@everythingfunctional Ok, I believe I got your point. I think you mean that we need to have a pair of names: \"trait\"/\"class\" for abstract interfaces in the same way as we have \"type\"/\"class\" for derived types (unfortunately the most logical pair: \"abstract interface\"/\"trait\" is out of the question due to its verbosity). Hence the confusion with the names.\nYes, I agree. The whole thing needs to be modelled with respect to inheritance essentially in the same way as type/class is for derived types. I need to check in detail the Rust link that you provided to understand how they did it, and to see whether we should add some example along these lines to the proposal."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-08 17:40:29+00:00",
                    "text": "@everythingfunctional To comment on your last question first. I believe it should be possible to do in Fortran what is done in Rust. Fortran and Rust are very similar in that they do not have classes in the sense of Java or C++. They only have \"structures\" (structs in Rust, types in Fortran) to which procedures are bound.\nTherefore, I believe it should be possible, in principle, to make the proposed feature a complete equivalent to Rust's impl. But then one might be forced to give up interoperability with what is already included in the language (i.e. type extension). This is why I leaned more towards the Java way, rather than the Rust way, of doing this. But I'd love to hear the opinions of compiler writers on this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-09 03:36:58+00:00",
                    "text": "But I'd love to hear the opinions of compiler writers on this.\n\n@certik , is there anybody on any of the major compiler teams active on here that may be able to speak to this?\n@difference-scheme , there was a suggestion not to require types to specify which traits they implement, just have the compiler verify it at each use. I think that would probably slow down compile times. But it probably would enable more flexibility."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-09 13:57:15+00:00",
                    "text": "I have revised the proposal to account for @everythingfunctional's feedback.\nI have opted to admit only one way for declaring polymorphic variables, namely Fortran's standard way, using the class specifier (which would therefore need to be extended). I believe anything else will lead to confusion.\nI have also added a Java and a Rust version of the (Fortran) example code given in Appendix B of the proposal. You can find them in the separate Examples directory, in case you'd like to see how the proposed features work in these languages."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-21 10:42:41+00:00",
                    "text": "@certik Unfortunately, I couldn't find the time before the committee's upcoming meeting next week to make the present proposal as complete as I'd like it to be.\nWhat is presently missing is a facility like Kotlin's by operator for automatic delegation of functionality to composed objects, that would spare the programmer the (present) need to write large amounts of boilerplate (function call indirection) code with object composition. I'd also like to account for those comments of @everythingfunctional that haven't been satisfactorily addressed yet.\nWill the present version of this proposal, along with #142, be nevertheless discussed in the upcoming committee meeting?"
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 18:40:12+00:00",
                    "text": "@difference-scheme I think it is good enough to be discussed. I think in general the committee prefers a simple text file, instead of a pdf, but I could be wrong on that. Either way, since this will not go into 202X, I think we do not perhaps need to submit this formally, but simply discuss it as an option for generic programming in the Data subcommittee.\n(I personally think we should do it more like Rust does it, and do most of generic programming at compile time, not runtime. If I find time, I'll try to submit a separate proposal along those lines. But it's good that your idea got written down, so that we can discuss it and move the discussion forward.)"
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-21 19:01:16+00:00",
                    "text": "@certik Thanks for your reply. Could you elaborate briefly on what features you think should be taken from Rust?\nTo my knowledge, Rust offers both compile-time generics, and run-time polymorphism (the latter by using \"trait-objects\"), so I would think that these two do not conflict with each other. Of course, anything that can be done at compile time should be done right then and there (at zero run-time cost)."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 21:34:14+00:00",
                    "text": "I think you are right --- I am still learning Rust and I am currently not 100% sure what happens at runtime and what happens at compile time, but it seems Rust has both compile-time generics, and run-time polymorphism, and the traits seem to be actually used for both (https://blog.rust-lang.org/2015/05/11/traits.html).\nAnyway, your proposal moves the conversation forward and may end up as part of the big proposal for generics.\nI am very happy that we are moving forward on these things."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-02-21 23:38:35+00:00",
                    "text": "Yes, in Rust the traits are used for both the bounding of compile-time generics, and for enabling subtyping run-time polymorphism.\nThis is why having named abstract interfaces in Fortran would be so important; it would serve both these purposes. We really need to have both these capabilities in the language, because they are complementary: some things that can be done with run-time polymorphism cannot be done with compile-time generics, and vice versa.\nIt would be a terrible blow to Fortran if we couldn't get both these capabilities into the language (and we need them rather sooner than later). So, I hope you will find the opportunity to work on the generics proposal, and I'd be willing to help out with this."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 23:54:02+00:00",
                    "text": "I agree that we need both. I also agree we should design both at the same time.\n\nI'll keep you updated.\n\u2026\nOn Fri, Feb 21, 2020, at 4:38 PM, difference-scheme wrote:\n Yes, in Rust the traits are used for both the bounding of compile-time\n generics, and for enabling subtyping run-time polymorphism.\n\n This is why having named abstract interfaces in Fortran would be so\n important; it would serve *both* these purposes. We really need to have\n *both* these capabilities in the language, because they are\n complementary: some things that can be done with run-time polymorphism\n cannot be done with compile-time generics, and vice versa.\n\n It would be a terrible blow to Fortran if we couldn't get both these\n capabilities into the language (and we need them rather sooner than\n later). So, I hope you will find the opportunity to work on the\n generics proposal, and I'd be willing to help out with this.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#143?email_source=notifications&email_token=AAAFAWH5S4XLTFBCTDOCJTLREBQXXA5CNFSM4KQPILZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEMUOETA#issuecomment-589881932>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWH7MTDAMB44GLIBIPDREBQXXANCNFSM4KQPILZA>."
                },
                {
                    "user": "certik",
                    "date": "2020-02-23 23:42:18+00:00",
                    "text": "This PR would be a great reference for a proposal. A good proposal should be 75 characters per line and between 50 - 400 lines. Also, it should be written as a regular text file, not latex or pdf.\nAs I said, I'll discuss this with the Data subcommittee and update this issue with the results."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-03-02 10:57:11+00:00",
                    "text": "@certik: Any news on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 15:47:40+00:00",
                    "text": "@difference-scheme yes, we discussed your proposal together with #125\nat the subset of the Data subcommittee, if I remember well, the people present were: @tclune, @everythingfunctional, @FortranFan, Magne Haveraaen, @zjibben  and myself. (See #155 for a summary of the whole meeting and attendance.)\nThe consensus so far seems to be that we want both runtime polymorphism (both #143 and #125 seem quite similar in this respect, obviously we would need to unify the syntax) as well as compile time polymorphism (the proposal #125 actually covers that too). It seems the way Rust handles Traits is something to consider, it might be exactly what we need. We discussed that the Rust syntax seems identical for compile time as well as runtime generics, and we were a bit unsure how Rust determines which one will happen. We should do more examples and analyze on case by case basis.\nMore importantly, when considering features such as #157, a common objection at the plenary was that we really need to have a plan for generics (even if they would go into 202Y) so that we can ensure that such features such as #157 are designed to be consistent with generics, so that we do not end up with a not well thought out system.\nAs such, I would like to push forward and hopefully get a community agreement how the generics should be done for 202Y, and then design features such as #157 for 202X to be consistent with them."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-03-02 16:41:36+00:00",
                    "text": "@certik Thanks for the update! I agree that Rust handles traits in a very elegant and general way and that we should consider taking their approach as a baseline for both compile-time and run-time polymorphism.\nWe shouldn't forget Swift, though, which does things in a manner that is very similar to Rust, and which has, moreover, succeeded in making all of this even interoperable with (classical) implementation inheritance.\nPersonally, I wouldn't even mind declaring Fortran's implementation inheritance, introduced in the 2003 standard, an obsolescent feature, if we would have a Rust-equivalent of run-time/compile-time polymorphism as an alternative. So, I believe we should be bold/progressive. Do you think that there might be opposition in the committee to such a progressive design, by people that would prefer a more conservative path?\nConcerning Rust's run-time vs. compile-time generics see also the following overview:\nhttps://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/\nBasically, the dynamic part (trait-objects) is indicated by the dyn keyword."
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 17:10:26+00:00",
                    "text": "@difference-scheme great link, thanks for sharing it. I personally wouldn't mind at all to make inheritance obsolete, and to recommend Rust style composition using Traits instead, as long as there is a clear path how to upgrade. But even if it is not officially obsolete, we can still, as a community, simply recommend to use traits over inheritance.\nMagne stressed a lot to try to implement Traits with similar syntax as what is already in Fortran, to make it more familiar to users as well as perhaps easier to implement for compilers."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-03-02 17:33:23+00:00",
                    "text": "@certik I fully agree (also with Magne's point).\nRust-style composition combined with automatic (implicit) delegation (as in Kotlin) is a way better programming model than inheritance. Also, implicit delegation will be absolutely crucial for easing the programmers' transition from the use of inheritance towards the use of the new features, so it is something we will absolutely need to have.\nRust doesn't have it yet, because they couldn't agree so far on a sufficiently simple implementation: rust-lang/rfcs#2393\nIt would be nice to see Fortran being quicker in this respect!"
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 20:28:55+00:00",
                    "text": "@difference-scheme good point about delegation. If you have some ideas how to design it for Fortran, please open an issue / PR."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-03-02 21:06:20+00:00",
                    "text": "@certik I have some first ideas on how delegation could be done in Fortran, in order to make it an almost drop-in replacement for implementation inheritance.\nI had started to work on an update of the present proposal along these lines, because I thought implicit delegation would be best explained in this same context (to demonstrate its use on the same examples so that one may clearly judge its benefits).\nBut since the present proposal appears to have been merged some moments ago, would you like me to keep updating this one, or should I open a new PR (along with an accompanying issue) that deals exclusively with delegation?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-03 01:12:12+00:00",
                    "text": "@difference-scheme go ahead and open a new PR that deals with delegation.\n@tclune thanks for the input. Note that I assigned it before the meeting, in the hopes that we can merge and discuss more ahead of time before we meet in person. In the same spirit, I would encourage that if you come up with requirements, that you share it with us well ahead of the meeting, so that we can discuss and think about it, in order to be more efficient in person.\nSee also #163. I believe that in order to come up with good requirements, we need to have an initial informal proposal in hand first."
                }
            ]
        },
        {
            "number": 142,
            "user": "everythingfunctional",
            "date": "2020-01-28 04:23:55+00:00",
            "title": "Traits Proposal",
            "text": "Proposal for traits as a method of enabling more generic programming capabilities.\nSee #125",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-28 04:25:56+00:00",
                    "text": "This is just a rough draft. It needs somebody with more experience writing these to help me use the write terms and verbiage, and to make sure we cover all the necessary points."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:05:31+00:00",
                    "text": "@everythingfunctional thanks for starting this!\nWe discussed all kinds of aspects at the original issue. Let's start with this:\n\nis this compile time or runtime polymorphism?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-28 14:56:41+00:00",
                    "text": "So far I haven't specified anything that would force an implementation to use one or the other. I was leaning towards runtime polymorphism though, as it aligns with the current runtime polymorphism already available through inheritance.\nI know you were hoping for compile time, but I really think that is better done with templates than traits. I could be persuaded to change it if there is a significant consensus otherwise."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 16:06:46+00:00",
                    "text": "So traits and templates interact. I've been learning Rust recently, and I like so far how they did it. Although I am still confused what exactly is compile time and runtime --- I'll write up C++ / Rust rosetta stone to clarify that soon. And I think it will be helpful for our discussions here too. So far it seems to me what Rust did is exactly what we should do in Fortran also, but I still need more time to learn.\nIn order to move things forward --- I think you can do your best clarifying things the way you see fit in the meantime. That will be helpful either way. I will let you know once I made some progress."
                },
                {
                    "user": "certik",
                    "date": "2020-02-23 23:47:28+00:00",
                    "text": "Thanks! I am going to merge it now and upload."
                },
                {
                    "user": "certik",
                    "date": "2020-02-23 23:53:22+00:00",
                    "text": "I uploaded it here:\nhttps://j3-fortran.org/doc/year/20/20-109.txt\n(I had to fix up a few things #150.)"
                }
            ]
        },
        {
            "number": 141,
            "user": "arjenmarkus",
            "date": "2020-01-15 14:43:07+00:00",
            "title": "Treat tab characters in list-directed input as a separator like a comma",
            "text": "Currently, tab characters read via list-directed input are not considered special in contrast to commas (or semicolons, if the file that is being read is opened with DECIMAL='COMMA'). Tab characters are very commonly used, however, to separate fields - for instance in CSV files. It would be nice if a tab character would be treated in the same way as a comma/semicolon.\nMore specifically: a single tab separates two fields (numerical or character or ..), two consecutive tabs separate an empty position and the corresponding variable in the READ statement would not be changed, just as with two consecutive commas. In fact, the treatment of a tab should be exactly the same as a comma (or semicolon).\nThis will introduce a backward incompatibility., To avoid that, the OPEN statement could be used in the same way as the keyword DECIMAL changes the meaning of a comma to attach this meaning to the tab character. Something along the lines of:\nOPEN( NEWUNIT=lun, FILE='input.csv', TAB='SEPARATOR' )\nAlternatively: TAB='CHARACTER' to indicate no special treatment of tab characters should be applied. This would be the default.",
            "is_open": true,
            "labels": [
                "Clause 12"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2020-01-15 16:34:54+00:00",
                    "text": "I assume you know that tab isn't even in the Fortran character set at present. I think most implementations allow tab in list-directed input as equivalent to spaces, so this generally works (and indeed I use it in my own programs) with the exception of the omitted value. That seems like a very strange corner-case that could end up causing more confusion than help since, outside of CSV files, multiple tabs just appear as whitespace.\nIn all of the requests I've seen asking for language help with CSV files, I never ran into this. How common is it to have a CSV file with an omitted value?\nIf we were to do this at all, I would restrict it to an I/O control list specifier on a list-directed (or NAMELIST?) READ only."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-15 18:56:03+00:00",
                    "text": "@sblionel , missing data in CSV files is very common in data science/big data applications. Whether the language should be changed to accommodate edge cases in specific data formats for specific applications is a different question."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-16 08:52:28+00:00",
                    "text": "@sblionel, yes, I know tabs are not part of the character set ;). Yet they are ubiquitous.\nFiles with missing values I have to deal with regularly have. for instance, a column indicating that a measured concentration value is below the detection limit. In that case the field contains a \"<\". If the value is well above it, the field is simply empty, so exporting the data to a CSV file results in two consecutive commas or tabs.\nPerhaps my request that they be treated in this way is a bit overzealous as @everythingfunctional points out. At least a guaranteed treatment - in whatever way - of tabs seems useful enough."
                },
                {
                    "user": "richardbleikamp",
                    "date": "2020-01-22 22:28:12+00:00",
                    "text": "I agree with Steve that limiting this to an I/O list control specifier makes sense.\nPerhaps a more general capability, to allow the user to specify multiple separator values, possibly even changing \",\" (or \";\") to NOT be considered a separator (what about blanks???), would make more sense.  A possible problem with this is accommodating different character KINDs, so this might be limited to  input records that only contain default kind characters.\nREAD(..., SEPARATORS=\", ;\\t\"), where \"\\t\" is not what the user would type, a real TAB character (of default kind) would be what the user would type.  Only affects list directed input of records containing solely default kind characters.\n\n\nif a blank is included in the SEPARATORS value, what do consecutive blanks do?  Perhaps blanks should always be a separator?\n\n\ndoes a SEPARATORS character in a delimited (or non-delimited) character input value affect anything?  Probably not, that is, its not a separator if in a delimited character string in an input record.\n\n\nperhaps this capability should only add new separators, not affect blank, comma, semicolon, and possibly be limited to control characters (not a well defined thing in the standard), or non-alphanumeric, not .+='\"()*&%$#@! etc??? (exclude every character in the Fortran char. set?), this would still allow horizontal and vertical tabs, BELL, etc.\n\n\n\nThe user can do this themselves now (in F2018?), if we assume a list directed READ only reads ONE record from the input file (true for .csv files I think).  Something like:\nREAD(unit, *,TAB=\"separator\") x,y,z\n\ncould be written as\nBLOCK\n    CHARACTER (:), ALLOCATABLE :: newrec; INTEGER p\n    READ (unit, FMT=\"(A999999)\") newrec   ! replace 999999 with reasonable max line length\n    p = scan(newrec, \"\\t\")              ! replace \\t with actual TAB character\n    do while(p>0)\n        newrec(p:p) = \",\";    p = scan(newrec, \"\\t\")\n    end do\n    READ(newrec, *) x,y,z;  deallocate (newrec)\nEND BLOCK\n\nSo, I think a quick straw vote on: (where \"we\" is J3)\n\nshould we support TAB=\"separator\" in a READ  stmt, OR\nshould we support SEPARATOR=\"xxx\", OR\nshould we do nothing\nis appropriate for meeting 221 or later, if Dan allows discussion\n\nComments?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-22 23:09:55+00:00",
                    "text": "My suggestion for now is to not over-specify it. It is sufficient to provide a general description of the problem and use cases.   A normal process would have each request written up as a separate J3 paper, but I think what would work here is a single document with links to each of the threads and let J3 (and WG5!) members review the whole of the discussions. This would also provide some record that could live on the J3 site - the paper could be amended to include results of any discussions.\nDo keep in mind that, ultimately, it is WG5 that decides whether or not to include a feature, though a favorable recommendation from J3 goes a long way."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-23 08:54:40+00:00",
                    "text": "@richardbleikamp in the \"tokenizer\" modules in my Flibs project I explicitly consider delimiters and separators - two consecutive delimiters mean there is an empty string in between and separators work just as spaces."
                }
            ]
        },
        {
            "number": 140,
            "user": "jvdp1",
            "date": "2020-01-13 21:52:53+00:00",
            "title": "addition of present()",
            "text": "I just added an example on how I think present may behave when an initializer is mentioned or not.\nI am just wondering what would happen in such a case:\nmodule ...\n ....\ncontains\nsubroutine foo(i_,value)\n integer, intent(in) :: i_\n integer, optional, intent(out) :: value = 0\n integer :: value_\n !some computations with value_\n if (present(value)) value = value_\nend subroutine foo\n\nend module\n\nprogram test\n use ...\n implicit none\n call foo(10) !what happens with value in foo if present() always return .true.?\nend program\nWhat will happen with foo when it is called without providing an actual argument, since present() always returns .true. . Probably it should not be a problem since value is already used.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-13 22:30:55+00:00",
                    "text": "The changes in the PR are fine. Regarding the question in the description, the argument is intent(out). One option is to not allow default values for intent(out) arguments. The other option is to make present(value) to return .true. or .false. depending on if the value is actually present. So it would work differently than intent(in) arguments. Good question --- we need to clarify that in the proposal."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-13 22:52:44+00:00",
                    "text": "The other option is to make present(value) to return .true. or .false. depending on if the value is actually present. So it would work differently than intent(in) arguments.\n\nI think it should work in  the same way for both intent(in) and intent(out). Otherwise, what would be its behaviour for intent(inout)?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-13 23:35:34+00:00",
                    "text": "@sblionel also supported this interpretation of present in an earlier comment (#137 (comment)).\nI'd argue for the opposite:\n\nThe other option is to make present(value) to return .true. or .false. depending on if the value is actually present.\n\nThis makes more sense to me. I always thought of present() as a test for \"was the actual argument passed by the caller?\"\nThere's also a technical argument:\n\nIf present() always returns .true. for an optional argument with a default value, then the function is useless for such optional arguments;\nIf present() returns .false. for an optional argument with a default value doesn't have a corresponding actual argument, it's still useful. For example, you may want to check if the argument was passed by the caller so you can validate or sanitize the input:\n\nsubroutine simulate(a, b)\n  real, intent(in) :: a\n  real, intent(in), optional :: b = 1.234\n  if (present(b)) then\n    ... ! expensive input validation here\n  end if\n  ...\nend subroutine simulate\nIn this example, expensive input validation code would execute only if argument passed by the caller, which is otherwise not needed.\nIn summary, present() should return .false. if there's no corresponding actual argument, regardless of whether the optional argument has a default value."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-13 23:39:11+00:00",
                    "text": "From #137:\n\n\nI will also need help suggest a specific and formal addition/change to the standard.\n\n\n\nI am not sure what you mean.\n\nI mean, let's also include the text to be included in the standard, should this proposal be accepted. Which section of the standard should be edited and how? Should any text be removed? What should be added?\nAlthough this may be in the scope of the Committee, the more we can help the easier will a proposal be accepted and implemented. Let's help as much as we can and know."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-14 03:23:32+00:00",
                    "text": "I don't think a default value for an optional, intent(out) argument makes any sense. intent(out) arguments are undefined until they become defined within the body of the procedure. So what code would you write that assumed the argument had a value before you assigned one to it? I think the only use case for such a thing to be allowed would be poor code design.\nBut this does bring up the question of optional, intent(inout). Can you assign to it if no actual argument is not present? What about optional with no intent specified?\nIt would be my opinion that default values for optional arguments should only be allowed for intent(in) arguments unless and until somebody can come up with both a coherent use case and implementation strategy for the other possibilities. This would allow the possibility of the naive but simple implementation strategy of just treating default values as syntactic sugar like the following:\nfunction something(arg)\n    integer, intent(in), optional :: arg = 1\n    integer :: something\n\n    ! function body\nend function something\n\nwould be equivalent to\nfunction something(arg)\n    integer, intent(in), optional :: arg\n    integer :: something\n\n    integer :: arg_\n\n    if (present(arg)) then\n        arg_ = arg\n    else\n        arg_ = 1\n    end if\n\n    ! replace all occurrences of arg with arg_ in the body\nend function something\n\nThat simple transformation doesn't make any sense, and in fact causes a run time error for any other intent.\nI would be in favor of still allowing present to return .false. for default values, as has already been explained to have a use case. I personally probably wouldn't use it that way, but it's not unreasonable to want to."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-14 07:55:48+00:00",
                    "text": "I would be in favor of still allowing present to return .false. for default values, as has already been explained to have a use case. I personally probably wouldn't use it that way, but it's not unreasonable to want to.\n\nI was in favor of such a behaviour of present too, but I tried to integrate @sblionel 's comment (see #137). Such a behavior (.false. or .true. independently of the initializer) would be also in agreement with the function optval implemented in stdlib.\nIt seems that most people would be in favor of present returning .false./.true. indepentely of the initializer. @milancurcic: I can modify my PR in that sense, and add your use case for present as an example.\n@sblionel what would be the issue of such a behavior (in addition to its implementation in a compiler)?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 08:10:15+00:00",
                    "text": "Let's discuss pros and cons of both alternatives in the proposal. This will surely come up during a discussion at the committee, no matter which alternative we choose as the better one.\n\u2026\nOn Tue, Jan 14, 2020, at 12:55 AM, Jeremie Vandenplas wrote:\n >\n > I would be in favor of still allowing `present` to return `.false.` for default values, as has already been explained to have a use case. I personally probably wouldn't use it that way, but it's not unreasonable to want to.\n\n I was in favor of such a behaviour of `present` too, but I tried to\n integrate @sblionel <https://github.com/sblionel> 's comment (see #137\n <#137>). Such a\n behavior (.false. or .true. independently of the initializer) would be\n also in agreement with the function `optval`\n <https://github.com/fortran-lang/stdlib/blob/f300f4a609ab02620b82ee2c79566361d84505c4/src/stdlib_experimental_optval.f90#L37> implemented in `stdlib`.\n\n It seems that most people would be in favor of `present` returning\n .false./.true. indepentely of the initializer. @milancurcic\n <https://github.com/milancurcic>: I can modify my PR in that sense, and\n add your use case as an example.\n @sblionel <https://github.com/sblionel> what would be the issue of such\n a behavior (in addition to its implementation in a compiler)?\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#140?email_source=notifications&email_token=AAAFAWA4HS3BDT4YWB7FJZTQ5VVYLA5CNFSM4KGJMFM2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEI3U76I#issuecomment-574050297>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGRUZMM2BQIM4ZC3GTQ5VVYLANCNFSM4KGJMFMQ>."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-14 08:11:53+00:00",
                    "text": "I don't think a default value for an optional, intent(out) argument makes any sense. intent(out) arguments are undefined until they become defined within the body of the procedure. So what code would you write that assumed the argument had a value before you assigned one to it? I think the only use case for such a thing to be allowed would be poor code design.\n\nFor intent(out), I agree my first example might be useless. However, what about the following use case (from stdlib open):\ninteger function open(filename, mode, iostat) result(u)\ncharacter(*), intent(in) :: filename\ncharacter(*), intent(in), optional :: mode\ninteger, intent(out), optional :: iostat\n\ncharacter(3) :: mode_\ncharacter(:),allocatable :: action_, position_, status_, access_, form_\n\n!some code\n!....\n\nif (present(iostat)) then\n    open(newunit=u, file=filename, &\n         action = action_, position = position_, status = status_, &\n         access = access_, form = form_, &\n         iostat = iostat)\nelse\n    open(newunit=u, file=filename, &\n         action = action_, position = position_, status = status_, &\n         access = access_, form = form_)\nend if\n\nend function\nwhich would become:\ninteger function open(filename, mode, iostat) result(u)\ncharacter(*), intent(in) :: filename\ncharacter(*), intent(in), optional :: mode\ninteger, intent(out), optional :: iostat = 0\n\ncharacter(3) :: mode_\ncharacter(:),allocatable :: action_, position_, status_, access_, form_\n\n!some code\n!....\n\nopen(newunit=u, file=filename, &\n         action = action_, position = position_, status = status_, &\n         access = access_, form = form_, &\n         iostat = iostat)\n\nend function\nIn this use case, the function present is not used, but the initializer allows to avoid a if statement, which simplifies the code.\nFor intent(inout), a use case similar to the one of @milancurcic  could be:\nsubroutine simulate(a, b)\n  real, intent(in) :: a\n  real, intent(inout), optional :: b = 1.234\n  if (present(b)) then\n    ... ! expensive input validation here\n  end if\n  \n  !some computations with b\n  \n  if (present(b)) then\n   !some expensive computations that modify  b and return the newly computed b\n  end if\nend subroutine simulate\nWhile this would probably be a poor design, it would be possible if default values are allowed for intent(in), intent(out), and intent(inout)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-14 08:13:55+00:00",
                    "text": "Let's discuss pros and cons of both alternatives in the proposal. This will surely come up during a discussion at the committee, no matter which alternative we choose as the better one.\n\n@certik I will push another version of a description of present."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-14 16:14:40+00:00",
                    "text": "This is very interesting development. At first I wasn't considering intent(out) or intent(in out) scenarios at all because I don't use them much (but they must be considered, of course). After reading Brad's comment here, I also struggled thinking of a good use case for a default value of an intent(out) until I saw Jeremie's example with the open() function. A more general form of this example could be the use case of return codes for exception handling (many many projects use this style of exception handling):\nsubroutine simulate(a, rc)\n  real, intent(in) :: a\n  integer, intent(out), optional :: rc = 0 ! assume success\n  ... ! simulation code\n  if (present(rc)) then\n    ! test for simulation state\n    if (some_erroneous_condition) then\n      rc = 173 ! meaningful error code\n      return\n    end if\n  end if\n  ... ! more simulation code\nend subroutine simulate\nThe only aspect that the default initializer helps here with is that we don't have to have a separate line at the top: rc = 0 ! assume success. So it seems to me that in the case of intent(out), setting default value really only acts as an initializer (which doesn't imply save!), which is minor, but can still be useful.\nAnother technical argument for allowing default value for any intent is that the rule is easier to explain, write, and implement (no special cases)."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 16:36:17+00:00",
                    "text": "Thanks everybody for brainstorming this. This is exactly the kind of work that needs to happen between Committee meetings that we can all do very efficiently at GitHub. So that by the time the Committee meets, the proposal is truly ready with all these \"details\" figured out."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-01-14 16:41:02+00:00",
                    "text": "If there's not a technical reason for disallowing a default value for optional intent(out) arguments then I say it should be allowed. I can't think of a really compelling use case that needs it either, but we shouldn't be trying to anticipate what someone might find useful in this context. And I agree with @milancurcic it will be easier to write the specification if we don't add unnecessary constraints."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-14 16:59:48+00:00",
                    "text": "@milancurcic , just for clarity, your suggestion is that a default value for intent(out) would imply something like the following, but you would still need to check if present before any assignment statements?\nsubroutine foo(stat)\n    integer, intent(out), optional :: stat = 0\n\n    ! do stuff\n    if (some_error) then\n        if (present(stat)) stat = some_error_code\n        return\n    end if\nend subroutine foo\n\nwould be equivalent to\nsubroutine foo(stat)\n    integer, intent(out), optional :: stat\n\n    if (present(stat)) stat = 0\n    ! do stuff\n    if (some_error) then\n        if (present(stat)) stat = some_error_code\n        return\n    end if\nend subroutine foo\n\nI would actually suggest something a bit different, which would then be coherent when combined for intent(inout), and preclude the necessity of checking for present everywhere.\nsubroutine foo(stat)\n    integer, intent(out), optional :: stat = 0\n\n    ! do stuff\n    if (some_error) then\n        stat = some_error_code\n        return\n    end if\nend subroutine foo\n\nwould be equivalent to\nsubroutine foo(stat)\n    integer, intent(out), optional :: stat\n\n    integer :: stat_\n    stat_ = 0\n\n    ! do stuff\n    if (some_error) then\n        stat_ = some_error_code\n        if (present(stat)) stat = stat_\n        return\n    end if\n    if (present(stat)) stat = stat_\nend subroutine foo\n\nOf course the actual implementation of a compiler would be smarter than having to insert that extra line before every return statement (one would hope).\nBut this makes the following work as well.\nsubroutine foo(x)\n    integer, intent(inout), optional :: x = 0\n\n    ! do stuff that could use or assign to x\nend subroutine foo\n\nwould be equivalent to\nsubroutine foo(x)\n    integer, intent(inout), optional :: x\n\n    integer :: x_\n\n    if (present(x)) then\n        x_ = x\n    else\n        x_ = 0\n    end if\n\n    ! do stuff that could use or assign to x\n\n    if (present(x)) x = x_\nend subroutine foo\n\nAnd it would be exactly the same transformation if no intent is specified. This at least gives the feature a coherent idea that if you have a default value for an optional argument, you no longer need to check if it's present, no matter what it's intent is. But as has been mentioned, you might still want the ability to check if it's present, which my simple transformation would preclude."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-14 18:54:27+00:00",
                    "text": "And it would be exactly the same transformation if no intent is specified. This at least gives the feature a coherent idea that if you have a default value for an optional argument, you no longer need to check if it's present, no matter what it's intent is. But as has been mentioned, you might still want the ability to check if it's present, which my simple transformation would preclude.\n\nDid I understand you correctly, @everythingfunctional:\nThe optional argument with an initializer will behave as a declared variable, with an initial value equal to the default value (initializer) (so, no need of present() to use the dummy argument). Also,\n\nIf it is inten(in) and the caller provides an actual argument, it wil get the value of the actual argument; (Use case: see proposal)\nIf it is intent(out) and the caller provides an actual argument, the returned value is the default value if the optional argument is not modified, or the assigned value otherwise; (Use case: see @jvdp1 'open' scenario; @everythingfunctional 's example)\nIf it is intent(inout) and the caller provides an actual argument, it wil get the value of the actual argument, AND the returned value is equal to the actual value if it is not modified, or the assigned value otherwise. (Use case: @everythingfunctional 's example).\n\npresent() can still be used in all cases (assuming it has the same behaviour as in the current standard; see the differen comments). (Weak?) use cases for the three scenarios are provided in this PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-14 19:17:45+00:00",
                    "text": "@jvdp1 , yes, those statements are true as I envisioned it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-14 20:34:06+00:00",
                    "text": "This at least gives the feature a coherent idea that if you have a default value for an optional argument, you no longer need to check if it's present, no matter what it's intent is.\n\nExactly! While this was implied in the proposal, we didn't state it explicitly and we should: Using default value for an optional argument allows the programmer to safely reference it in expressions regardless of intent and whether the actual argument is present or not."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 00:08:12+00:00",
                    "text": "Looks like there is agreement on this, so I am going to merge it."
                },
                {
                    "user": "sblionel",
                    "date": "2020-02-21 00:28:00+00:00",
                    "text": "@sblionel what would be the issue of such a behavior (in addition to its implementation in a compiler)?\n\nI missed seeing this earlier.\nIf one was to allow present() to be useful for a default argument, then the called routine would need to add prologue code to:\n\nTest to see if the argument was supplied\nMap the name of the dummy to a local temp\nCopy either the default or the actual into the temp\nMake sure that present() tested the passed argument and not the temp\n\nIf you also allowed this for other than intent(in), then there would need to be epilogue code to copy the temp back to the dummy, if supplied.\nThis interpretation would also complicate passing the argument to another routine. At present (!), \"presentness\" is passed on to other routines where the dummy is optional.\nTo me, this is awfully complicated and performance-inhibiting. I foresee a lot of opposition to such a thing. I still favor default values being supplied by the caller, in which case everything falls out without adding a layer of complexity. It is also far easier to explain (and implement.)\nIn my experience, I have not seen default values combined with \"did the caller really pass something?\" This is not to say that there couldn't be a case for that, but it isn't compelling to me."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 00:31:00+00:00",
                    "text": "@jvdp1 if you have time, would you mind capturing the rest of the discussion here, such a Steve's comment above, and send a new PR?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-21 16:21:31+00:00",
                    "text": "@sblionel Thanks! Indeed, I didn't consider implementation it all, nor do I have experience with it. Your argument makes sense to me."
                }
            ]
        },
        {
            "number": 139,
            "user": "rjfarmer",
            "date": "2020-01-11 17:23:18+00:00",
            "title": "Arrays of procedure pointers",
            "text": "I propose adding the ability for procedure pointers to be arrays, thus making something like this valid:\nprocedure(afunc), pointer, dimension(:) :: funcptr\n\nThis would allow building up \"lists\" of functions to be created that can be passed to a function to \"process\", or to make it easier to call different functions based on some index value. This would also make procedure pointers similar to other objects (and pointers) like ints, floats, derived types etc which can be arrays.\nUse cases:\nallocate(funcptr(3))\nnull(funcptr)\nfuncptr(1) => function1\nfuncptr(2) => null()\nfuncptr(3) =>  function3\n\ncall some_routine(funcptr)\ndeallocate(funcptr)\n\nsubroutine some_routine(funcptr)\n    do i=1,size(funcptr)\n          if(associated(funcptr(i))) call funcptr(i)\n    end do\n\nDifferent use case (which i have in my code)\nSELECT CASE (id)\ncase(1)\n    ptr => func1\ncase(2)\n    ptr => func2\n.....\n\ncall ptr()\n\nWhich could be made cleaner with:\n ! Inside an init function\n funcptr(1) => function1\n funcptr(2) => function2   \n\n ! Calling code\n call funcptr(id)\n\nCurrently you can do something similar if you do\ntype mytype\n     procedure(afunc), pointer :: ptr\nend type mytype\n\ntype(mytype), allocatable, dimension(:) :: funcptr\n\nBut this just hides whats going on and is no-obvious to a user/(me) why the pointer needs to be put inside a derived type (when you can have real, pointer, dimension(:) ).",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2020-01-11 20:35:06+00:00",
                    "text": "This would be awkward, since one can't have arrays of data pointers. This suggestion just carves out a special case and doesn't add anything you can't do in a reasonable fashion today. Yes, using a derived type is a bit weird, but I wouldn't be in favor of special-casing procedure pointers for this."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-20 19:46:01+00:00",
                    "text": "Please consider also the following. In a polymorphic language (which Fortran now is) users do not actually need to be able to directly access raw procedure pointers at all (see Java as a case in point, which does not expose procedure pointers to the user).\nPolymorphism provides a much safer alternative path to the same functionality (as it relies on procedure pointers being used under the hood). The fact that Fortran follows the C++ example to also make procedure pointers directly accessible to the user might arguably be seen as a weak point of both these languages in terms of safety."
                },
                {
                    "user": "ghwilliams",
                    "date": "2020-05-18 13:22:36+00:00",
                    "text": "What about arrays of pointers for derived types. For example:\ntype, abstract :: base_class\nend type base_class\ntype, extends (base_class) :: class_a\nend type class_a\ntype, extends (base_class) :: class_b\nend type class_b\n... later\n! currently allocatable conflicts with pointer. In a new standard it would be understood as an array of pointers.\nclass (base_class),  allocatable, pointer :: obj_list(:)\nallocate(obj_list(2))\nallocate(obj_list(1), source = class_a)\nallocate(obj_list(2), source = class_b)\nthis is the basic idea."
                },
                {
                    "user": "thoth291",
                    "date": "2020-06-25 00:19:31+00:00",
                    "text": "@rjfarmer for functions it could be done like this:\n      interface\n         function proc_int()\n            real :: proc_int\n         end function proc_int\n      end interface\n\n      type proc_pointer\n         sequence\n         procedure(proc_int),pointer, nopass :: ptr\n      end type\n\n      type(proc_pointer),dimension(1:NFUNKS) :: procs\n      \n      real function custom_func(n)\n         integer :: n\n         double precision :: tsum\n         custom_func = 0.0D0\n         tsum = 0.0D0\n         do k = 1,n\n            tsum = tsum + k\n         enddo\n         custom_func = tsum\n         return\n      end function custom_func\n      \n      i=0 !for example\n      procs(i)%ptr=>custom_func\nHaven't tried it for subroutines, though..."
                }
            ]
        },
        {
            "number": 138,
            "user": "urbanjost",
            "date": "2020-01-11 03:25:46+00:00",
            "title": "CHARACTER arguments on MERGE() should b",
            "text": "The requirement that the CHARACTER arguments to MERGE() must be of the\nsame length prevents it from being used in a straight-forward manner.\nIn normal assignments the RHS would be padded or truncated to the size\nof the LHS, or the LHS would be allocated to the size of the RHS.\nThis is also true if testing strings for equality.\nThe following code will fail on the third call to SHOW() in a\nstandard-compliant programming environment.\nprogram main\n   call show('1234567')\n   call show('12345678') ! unequal lengths\n   call show()           ! unequal lengths\n   call show('123456')   ! unequal lengths\ncontains\n\n   subroutine show(a)\n      character(len=*),optional :: a\n      character(len=:),allocatable :: a_local\n      a_local=merge(a,'DEFAULT',present(a))\n      write(*,'(a)')'value=['//a//']'\n   end subroutine show\n\n   end program main\nThe compilers I tried detect this even at run-time and throw a descriptive\nmessage. They should correct for the difference in length there, and the\ndocumentation can describe that if the lengths are not the same that the\nfunction may run less efficiently instead of not allowing for the difference.\nI do not have a strong opinion on whether the returned value should be the length of the longer argument or the same as the original that was selected.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-11 04:04:35+00:00",
                    "text": "I had no idea merge can work on scalar character strings. Cool!\nHowever, is a_local=merge(a,'DEFAULT',present(a)) valid when a is missing? I thought a here can be referenced only if passed as argument to present() or as an actual argument to another procedure with a corresponding optional dummy argument. I get [] on call show() with gfortran-9.2.0, but I expected a run-time error."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-11 14:46:01+00:00",
                    "text": "@milancurcic 's question about the use of present(a) is on point. It;s ok to use present() in a merge  (see interp F08/0095) but it's not ok to reference a not-present optional dummy as one of the sources.\nI have a memory of discussing this general issue at a J3 meeting but can't find a paper on it, nor a mention in my notes. The question is whether the mask is evaluated first and only the true sources referenced, or if a conforming implementation can evaluate both sources and then select the \"true\" elements.  You can't depend on this."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-12 16:42:59+00:00",
                    "text": "On January 11, 2020 at 9:46 AM Steve Lionel ***@***.***> wrote:\n\n\n     @milancurcic https://github.com/milancurcic 's question about the use of present(a) is on point. It;s ok to use present() in a merge (see interp F08/0095 https://j3-fortran.org/doc/year/13/13-278r1.txt ) but it's not ok to reference a not-present optional dummy as one of the sources.\n\n     I have a memory of discussing this general issue at a J3 meeting but can't find a paper on it, nor a mention in my notes. The question is whether the mask is evaluated first and only the true sources referenced, or if a conforming implementation can evaluate both sources and then select the \"true\" elements. You can't depend on this.\n\n     \u2014\n     You are receiving this because you authored the thread.\n     Reply to this email directly, view it on GitHub #138?email_source=notifications&email_token=AHDWN3IYH4ZIH3IUCRV7RPTQ5HLSTA5CNFSM4KFPZPE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIWDNNY#issuecomment-573322935 , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3NY3GK2UTJ2Y5FQKDDQ5HLSTANCNFSM4KFPZPEQ .\n\nAs the example raises more questions by using the optional argument in the merge()  I can change the example to a less-contentious case; but I had that discussion on the Fortran newsgroup and came away with the impression that as long as I did not use \"a\" in an expression but just passed it that it would be no different than passing an undefined"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-12 19:21:48+00:00",
                    "text": "Well, I once thought it was illegal but after discussing it on the Fortran newsgroup I was\nconvinced it was OK as long as the optional parameter was passed directly and not used\nin an expression. Since this was what I thought was a very good use case for the feature I used that, but I do not want to have this perhaps badly selected example detract from the\ninitial request.  MERGE is a good substitute for other types for the C \": ?\"  syntax with the\nadditional power that array syntax provides too boot; but is hindered by CHARACTER values having to be the same length, which is rarely the case in other parts of Fortran, I will\nconcede my favorite use case is not the best example, but contend the feature is still useful. If merge would short-cut it's parameters and only evaluate the true condition that would be useful in MERGE as well as IF statements, but that is a whole other (bigger) enhancement I would like.\n\u2026\n On January 11, 2020 at 9:46 AM Steve Lionel ***@***.***> wrote:\n\n\n     @milancurcic https://github.com/milancurcic 's question about the use of present(a) is on point. It;s ok to use present() in a merge (see interp F08/0095 https://j3-fortran.org/doc/year/13/13-278r1.txt ) but it's not ok to reference a not-present optional dummy as one of the sources.\n\n     I have a memory of discussing this general issue at a J3 meeting but can't find a paper on it, nor a mention in my notes. The question is whether the mask is evaluated first and only the true sources referenced, or if a conforming implementation can evaluate both sources and then select the \"true\" elements. You can't depend on this.\n\n     \u2014\n     You are receiving this because you authored the thread.\n     Reply to this email directly, view it on GitHub #138?email_source=notifications&email_token=AHDWN3IYH4ZIH3IUCRV7RPTQ5HLSTA5CNFSM4KFPZPE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIWDNNY#issuecomment-573322935 , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3NY3GK2UTJ2Y5FQKDDQ5HLSTANCNFSM4KFPZPEQ ."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-12 19:34:18+00:00",
                    "text": "I was trying to think if making MERGE have the TRUE and FALSE return values optional so the parameter could be passed by the standard would be a solution, but it would make MERGE pretty funky. I had a discussion about this and there was a pretty convincing argument made that passing the value directly was no different than passing an undefined value or unassigned pointer, in that it would not cause a problem unless used in an expression by the called procedure, but you are right that the standard states explicit restrictions on optional arguments, which was missed in my earlier discussion. I started off\nwanting backed up that it could not be passed and was convinced otherwise. It really would be a nice use of MERGE. If you have a lot of optional parameters the code can get messy.  I guess another approach I have seen suggested is to allow a default value to be specified on the declaration of the optional value; but that would maybe be confusing because you would be implying it gets set on each call?  That is, would\n\ncharacter(len=*),optional :: string='default value'\n\nbe a better way to do what I wanted with MERGE in that particular case? But that is a whole other line of thought, even if worth pursuing.\n\u2026\n On January 10, 2020 at 11:04 PM Milan Curcic ***@***.***> wrote:\n\n\n     I had no idea merge can work on scalar character strings. Cool!\n\n     However, is a_local=merge(a,'DEFAULT',present(a)) valid when a is missing? I thought a here can be referenced only if passed as argument to present() or as an actual argument to another procedure with a corresponding optional dummy argument. I get [] on call show() with gfortran-9.2.0, but I expected a run-time error.\n\n     \u2014\n     You are receiving this because you authored the thread.\n     Reply to this email directly, view it on GitHub #138?email_source=notifications&email_token=AHDWN3KMTF2QJMTYNQVJGNDQ5FANHA5CNFSM4KFPZPE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIVYTXY#issuecomment-573278687 , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3IWQ4ZGLZFD37L5XGTQ5FANHANCNFSM4KFPZPEQ ."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-14 18:13:57+00:00",
                    "text": "@urbanjost, so is your interest really the idea behind  #22 with default value of optional arguments?  And not MERGE?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-16 02:19:51+00:00",
                    "text": "For the use case I originally specified that would be better and I definitely support that change. I mad my own function for scalars that is just like merge except the return values are optional just so it does not break the rules over passing optional arguments with a metamorphic class(*) variable and looking at all the places I use it all but two are for what #22 does.  I also tried doing it with pointers to eliminate some of the problems with having to declare a local variable, which #22 would eliminate.\nSo I would say #22 would work great; there are still a few places not concerned with optional arguments where it is a pain to deal with the lengths being equal, but essentially you are right - I would prefer \"22\" to be implemented instead of this if the choice were between the two. And I have not seen nearly the activity for this as for \"22\"; so if I am the only one that wants this it can be dropped (as I have a work-around)."
                }
            ]
        },
        {
            "number": 137,
            "user": "milancurcic",
            "date": "2020-01-10 23:20:22+00:00",
            "title": "proposal for setting default values of optional arguments",
            "text": "First draft of the proposal to set default value for optional arguments (#22).",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-10 23:24:59+00:00",
                    "text": "I will need some help linking to the user survey that @sblionel mentioned (I participated in it, and I read the results back then, but now I can't find it anywhere).\nI will also need help suggest a specific and formal addition/change to the standard."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-10 23:33:18+00:00",
                    "text": "https://isotc.iso.org/livelink/livelink?func=ll&objId=19530634&objAction=Open&viewType=1"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-11 07:49:29+00:00",
                    "text": "@milancurcic thank you for the proposal. The first draft looks good to me.\n\nI will also need help suggest a specific and formal addition/change to the standard.\n\nI am not sure what you mean.\nShould the following cases be discussed in the draft:\n\nWhat is the behavior of present?\n\nsubroutine foo(dummy)\n     integer, intent(in), optional :: dummy = 0\n     print*, present(dummy) ! = .true. if dummy provided, .false. otherwise\nend subroutine\n\nHow does dummy behave when it is optional and allocatable?\n\nsubroutine foo(dummy)\n     integer, allocatable, intent(in), optional :: dummy(:) = [ 0, 0] \n    if ( .not. present(dummy)) then\n     allocate(dummy(5))   !I intentionaly used a dim of 5, instead of 2\n     dummy = 1\n   end if\nend subroutine\nI think your proposal has no problem when intent(inout || out), optional is used since the argument is not provided"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-11 14:29:07+00:00",
                    "text": "@jvdp1 Anything and everything we can think of that seems relevant should be discussed - both of those questions are worthy of mention.\nMy opinions would be:\n\npresent() would always return true for an argument with a default.\nThat combination is not valid. If the dummy is allocatable, the actual must also be.\n\nMy position is that a default value has exactly the same meaning as if the caller passed that value as the corresponding actual argument, with all the existing rules applied. Indeed, I would expect a compiler to implement it this way, doing the substitution at the call and not inside the procedure being called."
                }
            ]
        },
        {
            "number": 136,
            "user": "urbanjost",
            "date": "2020-01-10 18:29:33+00:00",
            "title": "Allow stream I/O on pre-attached stdin and stdout",
            "text": "The ability to read a stream from stdin, and to write a stream to stdout would be very useful to make filter programs especially so programs can be used in pipes with binary data.\nA primary use of stream I/O is for creating programs that can\nbe used in pipes on systems that support it.  There is no standard way to reopen the preattached files connected to stdin and stdout as streams to support generating such applications.  Non-advancing I/O does not solve the problem primarily because of there being a limit on line length and for other well-documented reasons.\nCalling the C routines via the ISO_C_BINDING interface is the work-around I have  seen used the most.  If possible, an OPEN on the pre-attached files that allowed changing them to STREAM I/O and optionally binary seems like it would be the nicest syntax.  Although far less preferred by  myself even new  intrinsics like GETC() and PUTC() that mirrored the C functions of the same name\nwould be better than the current state.  Note that in some programming environments you can do an INQUIRE() on the units and close and reopen them, but not on others.  And there is the complication that you can usually only do that for the units defined by\nuse, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit\nand not necessarily the ones representing by \"*\".   Not having this as a standard capability greatly limits the construction of filters using Fortran.",
            "is_open": true,
            "labels": [
                "Clause 12"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2020-01-11 15:02:37+00:00",
                    "text": "Quoting 12.5.1p4 (emphasis mine)\n\nIn a READ statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential formatted input on image 1 in the initial team only (12.6.4.3). This unit is also identified by the value of the named constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). In a WRITE statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential formatted output. This unit is also identified by the value of the named constant OUTPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.22).\n\nThat said, I agree it would be useful to be able to use the preconnected units for unformatted stream I/O. I think the simplest approach would be to require that INQUIRE() return a filespec that can be used in an OPEN for the preconnected units."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-12 16:52:36+00:00",
                    "text": "That would be great; especially since some programming environments do already return a usable name from an INQUIRE that can be used that way; but others return a string like \"stdin\" and \"stdout\" that does not work as a name on OPEN() or a blank name. So I have seen that model be workable in some current environments.\n\u2026\n On January 11, 2020 at 10:02 AM Steve Lionel ***@***.***> wrote:\n\n\n     Quoting 12.5.1p4 (emphasis mine)\n\n         > >\n >         In a READ statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential formatted input on image 1 in the initial team only (12.6.4.3). This unit is also identified by the value of the named constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). In a WRITE statement, an io-unit that is an asterisk identifies an external unit that is preconnected for sequential formatted output. This unit is also identified by the value of the named constant OUTPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.22).\n >\n >     >\n     That said, I agree it would be useful to be able to use the preconnected units for unformatted stream I/O. I think the simplest approach would be to require that INQUIRE() return a filespec that can be used in an OPEN for the preconnected units.\n\n     \u2014\n     You are receiving this because you authored the thread.\n     Reply to this email directly, view it on GitHub #136?email_source=notifications&email_token=AHDWN3NNSK2VNN7F5XGK763Q5HNQ3A5CNFSM4KFLUBR2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIWDX3Y#issuecomment-573324271 , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3JSBLZSKMUTIYAPJH3Q5HNQ3ANCNFSM4KFLUBRQ ."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-12 19:46:08+00:00",
                    "text": "I would argue that implementations that do not return a usable name for INQUIRE(NAME=) are not following the standard, which says: \"The value assigned shall be suitable for use as the value of the file-name-expr in the FILE= specifier in an OPEN statement.\"\nBut there is an escape that if it is deemed that the file doesn't have a name, then the value of NAME= becomes undefined (and presumably NAMED= would return .FALSE.)\nIt may be that reopening the file wouldn't work anyway...\nI'm struggling to come up with a \"Fortranic\" (love that term) way of expressing the notion here. Fortran does have \"changeable modes\", but ACCESS and FORM aren't among them."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-12 21:32:45+00:00",
                    "text": "Even the syntax is hard to make \"Fortranic\" (I like that). Even something like a specifier on the READ or WRITE (which is allowed for other properties) or ** instead of * for a unit specifier might be good syntactically, but I wonder about implementing something that way,\nas it would imply that a single file could be written to with different attributes in the same program (that is, if the program had both  WRITE(*,...) and WRITE(**,...) statements would that be feasible?).  Even deciding if ** meant UNFORMATTED STREAM or FORMATTED STREAM takes thought. And yet this is a common and useful feature of other languages. It is very limiting to not be able to create Fortran filter programs that reliably can read a binary stream, as just one example. I find myself precariously using non-advancing I/O or calls to C getc(c) and putc(); which is very limiting compared to a fully supported Fortran I/O interface.\n\u2026\n On January 12, 2020 at 2:46 PM Steve Lionel ***@***.***> wrote:\n\n\n     I would argue that implementations that do not return a usable name for INQUIRE(NAME=) are not following the standard, which says: \"The value assigned shall be suitable for use as the value of the file-name-expr in the FILE= specifier in an OPEN statement.\"\n\n     But there is an escape that if it is deemed that the file doesn't have a name, then the value of NAME= becomes undefined (and presumably NAMED= would return .FALSE.)\n\n     It may be that reopening the file wouldn't work anyway...\n\n     I'm struggling to come up with a \"Fortranic\" (love that term) way of expressing the notion here. Fortran does have \"changeable modes\", but ACCESS and FORM aren't among them.\n\n     \u2014\n     You are receiving this because you authored the thread.\n     Reply to this email directly, view it on GitHub #136?email_source=notifications&email_token=AHDWN3NRPPTOXPJNE3LHU2DQ5NXQDA5CNFSM4KFLUBR2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIXCO6Q#issuecomment-573450106 , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3O6DLLHACLP5APWAYDQ5NXQDANCNFSM4KFLUBRQ ."
                }
            ]
        },
        {
            "number": 135,
            "user": "marshallward",
            "date": "2020-01-10 15:55:57+00:00",
            "title": "Namelist object designators may have blanks following commas",
            "text": "Currently, the following namelist is invalid:\nidx_nml\n   v(1, 1) = 5\n   v(2, 1) = 5\n/\n\nThe reason is because the object designator (e.g. v(1, 1)) of a namelist may not contain any blanks (13.11.2p2, last sentence):\n\nEach designator may be preceded and followed by one or more optional blanks but shall not contain embedded blanks.\n\nThere is no such restriction AFAIK in Fortran itself.\nDespite this restriction, such spaces are permitted in every compiler that I have tested (gfortran, ifort, Cray, PGI).  The exception is NAG Fortran, which is correctly adhering to the standard.\nSome discussion here, for the interested.\nI would suggest that the final sentence be removed from this paragraph of the standard, if only because it is inconsistent with Fortran source code, and because hardly anyone appears to be following this rule anyway without any apparent side-effects.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-10 18:27:44+00:00",
                    "text": "@marshallward the link in your post is invalid."
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-10 18:31:13+00:00",
                    "text": "Weird, issues became issue.  Anyway it is fixed now, thanks."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-10 23:34:29+00:00",
                    "text": "Another one for #106, a no-brainer in terms of a change which should get absorbed into the Fortran standard at fairly short notice rather than the 8+ years it's going to take in the current scheme of things."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-11 15:15:28+00:00",
                    "text": "@FortranFan , your continued harping on past implementation delays is not helpful. It is also not accurate for today's compiler landscape, where the leading compilers are quickly catching up to the current standard, and standard development is moving faster.\nI suspect that this restriction is in place to disallow something like a%b %c, but I agree that embedded blanks that would be allowed in free-form source should also be allowed here."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-11 22:36:50+00:00",
                    "text": "@sblionel wrote:\n\n@FortranFan , your continued harping on past implementation delays is not helpful. It is also not accurate for today's compiler landscape, where the leading compilers are quickly catching up to the current standard, and standard development is moving faster.\n..\n\n@sblionel, what is \"not helpful\" and is entirely uncalled for here is a personal, singling out attempt at a censure of my impersonal sentence upthread  with mischaracterization such as  \"harping\".\nInstead, what will be helpful here is to note the non-Fortrannic phrase in the standard for NAMELIST formatting i.e., Section 13.11 Name-value subsequences, paragraph 2, lines 35 and 36, \"Each designator may be preceded and followed by one or more optional blanks but shall not contain embedded blanks\"\nThat perhaps this phrase might be an oversight but yet no speedy review of it, let alone any redressal, appears feasible.  Fortran 202X is \"closed\" for instance.\nMy first thought when I read the original post is the phrase, \"but shall not contain embedded blanks,\" appears entirely questionable for a language that not only allows blanks in many contexts (e.g., x % n = 42 but which requires any and all including new processors to continue to support fixed-form source with its \"semantics\" toward \"embedded blanks\".  That the standard will permit something like the following:\n      P R    O   G   R    A   M   B          L          A     N     K  S\n      T   Y      P        E     F        O                             O\n      I N T   E  G   E                                   R   X   Y     Z\n      E      N          D         T             Y           P          E\n      T           Y           P          E     B     A                 R\n      T       Y        P         E    (    F      O        O )  A  B   C\n      E          N        D          T       Y       P                 E\n      T    Y        P    E    (   B      A  R     )                    A \n      A            %   A       B       C        %     X   Y   Z   = 4  2\n      PRINT *, \"A%ABC%XYZ = \", A%ABC%XYZ, \"; Expected is 42\"\n      S           T    O                                               P\n      END PROGRAM BLANKS\nbut yet strive to maintain as non-conforming a simple NAMELIST input of &dat a % b % c = 42/.  That is inconsistent and it is doing disservice to a Fortran practitioner.\n\nC:\\Temp>type p.for\n\n       P R    O   G   R    A   M   B          L          A     N     K  S\n       T   Y      P        E     F        O                             O\n       I N T   E  G   E                                   R   X   Y     Z\n       E      N          D         T             Y           P          E\n       T           Y           P          E     B     A                 R\n       T       Y        P         E    (    F      O        O )  A  B   C\n       E          N        D          T       Y       P                 E\n       T    Y        P    E    (   B      A  R     )                    A\n       A            %   A       B       C        %     X   Y   Z   = 4  2\n       PRINT *, \"A%ABC%XYZ = \", A%ABC%XYZ, \"; Expected is 42\"\n       S           T    O                                               P\n       END PROGRAM BLANKS\n\nC:\\Temp>ifort p.for\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.5.281 Build 20190815\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.24.28314.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:p.exe\n-subsystem:console\np.obj\nC:\\Temp>p.exe\nA%ABC%XYZ =           42 ; Expected is 42\nC:\\Temp>gfortran p.for -o p-gnu.exe\nC:\\Temp>p-gnu.exe\nA%ABC%XYZ =           42 ; Expected is 42\nC:\\Temp>"
                },
                {
                    "user": "certik",
                    "date": "2020-01-12 00:32:57+00:00",
                    "text": "@FortranFan please do not bring up the speed of adoption in technical issues. Your first comment:\n\nAnother one for #106, a no-brainer in terms of a change which should get absorbed into the Fortran standard at fairly short notice rather than the 8+ years it's going to take in the current scheme of things.\n\nCould have been instead written as:\n\nAnother one for #106, a no-brainer in terms of a change which should get absorbed into the Fortran standard at fairly short notice.\n\nIf you have comments regarding Fortran standard adoption, please discuss this in separate issues, such as #106, #36 or create a new one, and just link them here. (Btw, I agree with you and I am as unhappy as you are regarding #106, #36, in fact I created those issues --- but we have to focus and not pollute every issue like this #135 with our unhappiness, because that will only get people annoyed, and not get us what we want.)"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-14 16:46:10+00:00",
                    "text": "I observe that this restriction has been there since Fortran 90."
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-15 18:30:39+00:00",
                    "text": "The example alluded to by @sblionel and expanded on by @FortranFan does fail on gfortran, e.g.:\n&test\n    x % a = 1\n    x % b = 2\n/\n\nIn this case, it aborts because it wants to see a = after the space-delimited variable, x.  But I believe that x % a = 1 would be a valid Fortran statement.  Other spacings like x %a = 1 fail because it rejects %a as a valid variable, again due to space-delimiters.\nMy guess is that v(1, 1) = 5 only works because the (, ) are acting as delimiters of a subsection of the designator.  Something like x % a has no delimiters, and I can see how it may be a challenge (maybe impossible?) to parse correctly.\nI now see some purpose in the current wording, and I no longer think it's just a simple matter of relaxing the zero-blanks requirement of the designators."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-15 22:57:09+00:00",
                    "text": "@marshallward wrote:\n\n..\nI now see some purpose in the current wording, and I no longer think it's just a simple matter of relaxing the zero-blanks requirement of the designators.\n\nWhy is the percent sign not a good delimiter when equals sign is in NAMELIST formatting and so is exclamation mark for comments and beginning and ending ampersands for complex objects?\n      p  r  o  g   r  a   m  b   l  a  n   k   s   g  a    l  o  r     e\n      c h a r a c t e r(len=1), parameter :: N L = n e w _ l i n e( \"\" )\n      c   o    m    p    l     e            x                          z\n      c h a r a c t e r ( l e n = : ), a l l o c a t a b l e : : i n p\n      n    a      m     e    l     i   s     t  /   d   a     t   /    z\n      i   n   p    =   \"  &dat   \" // NL // \"!       blanks galore \" / /\n     &  N  L / / \"  z   =  (    1.0   ,    0.0      )  \" // NL // \" /  \"\n      p    r       i      n      t *  ,      i             n           p\n      r  e   a   d   (  i   n    p  ,   n  m   l   =    d    a  t      )\n      print *, \"z = \", z, \"; expected is (1.0,0.0)\"\n      e   n    d p  r  o  g   r  a   m  b  l a n  k  s  g  a  l  o  r  e\n\nC:\\Temp>type p.for\n\n       p  r  o  g   r  a   m  b   l  a  n   k   s   g  a    l  o  r     e\n       c h a r a c t e r(len=1), parameter :: N L = n e w _ l i n e( \"\" )\n       c   o    m    p    l     e            x                          z\n       c h a r a c t e r ( l e n = : ), a l l o c a t a b l e : : i n p\n       n    a      m     e    l     i   s     t  /   d   a     t   /    z\n       i   n   p    =   \"  &dat   \" // NL // \"!       blanks galore \" / /\n      &  N  L / / \"  z   =  (    1.0   ,    0.0      )  \" // NL // \" /  \"\n       p    r       i      n      t *  ,      i             n           p\n       r  e   a   d   (  i   n    p  ,   n  m   l   =    d    a  t      )\n       print *, \"z = \", z, \"; expected is (1.0,0.0)\"\n       e   n    d p  r  o  g   r  a   m  b  l a n  k  s  g  a  l  o  r  e\n\nC:\\Temp>gfortran -std=f2018 p.for -o p-gnu.exe\nC:\\Temp>p-gnu.exe\n&dat\n!       blanks galore\nz   =  (    1.0   ,    0.0      )\n/\nz =              (1.00000000,0.00000000) ; expected is (1.0,0.0)\nC:\\Temp>"
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-15 23:23:44+00:00",
                    "text": "@FortranFan You may be right, I also suspect that this ought to be unambiguously parseable.  I'm only suggesting that the problem is more complicated than my original example suggests and probably needs more discussion.\nAnd there's the problem that it is not parseable by a greater number of compilers, so I can't simply say \"nearly everyone supports this already\".  My x % a = 1 example above fails on GCC, for example.\nFortran source has the luxury of having \\n as a delimiter between statements and can usually treat spaces as null characters, whereas namelists must treat both as potential delimiters.  So at the least one cannot expect all of the Fortran rules to carry over on default.\nFor example, these are valid namelists which would not be valid Fortran statements:\n&test1\n    x\n    =\n    1\n/\n\n&test2 x=1 y=2 /"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-15 23:58:29+00:00",
                    "text": "As someone who has actually implemented NAMELIST in a compiler's  (VAX FORTRAN) I/O library, the newlines aren't a real problem. Unlike source, list-directed and NAMELIST reads are perfectly capable of spanning record boundaries, as long as the input item is requesting more data.\nThe standard says, for free-form source, that a \"token\" cannot have embedded blanks. In the case of x%a, each of x, % and a are tokens, and the input processor is perfectly capable of handling this in an unambiguous fashion, if so implemented, even split across record boundaries. Once an identifier is seen (x here), it has to keep looking until it sees a =.\nAs I noted earlier, I think it would be adequate to say that tokens in the designator may not have embedded blanks, adopting the language the standard has for free-form source:\n\nIn free source form blank characters shall not appear within lexical tokens other than in a character context or in a format specification. Blanks may be inserted freely between tokens to improve readability; for example, blanks may occur between the tokens that form a complex literal constant. A sequence of blank characters outside of a character context is equivalent to a single blank character."
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-16 01:12:49+00:00",
                    "text": "For what it's worth, my own parser also seems to have no trouble with interior whitespace:\n>>> import f90nml\n>>> print(f90nml.reads(\"&test x % a = 1 x % b = 2 /\"))\n&test\n    x%a = 1\n    x%b = 2\n/\n\nso I am also inclined to agree that whitespace between any tokens should be permitted."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-16 16:04:24+00:00",
                    "text": "Why not ignore whitespace entirely outside character literals?  Whitespace doesn't seem necessary for disambiguating tokens."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-17 20:04:59+00:00",
                    "text": "Why not ignore whitespace entirely outside character literals? Whitespace doesn't seem necessary for disambiguating tokens.\n\nIt'll be very useful, along the lines of the need expressed in the per original post here, if the Fortran standard can extend better support for blanks in NAMELIST formatting, at least as per how the standard treats them in free-form source c.f. 6.3.2.2 Blank characters in free form, paragraph 1, lines 17 and 18, \"In free source form blank characters shall not appear within lexical tokens other than in a character context or in a format specification. Blanks may be inserted freely between tokens to improve readability.\"  I've a really hard time believing how such an improved facility can be any difficult for a present-day parser or a processor.\nTaking it to the level of \"whitespace\", a term currently unknown to the Fortran standard and which some may understand as implying more than blanks, perhaps tab characters, newline, carriage return, form feed, etc. may be \"nice to have\" - I don't know yet and which I'll defer.\nBut I'll be happy if last sentence in paragraph 2 of 13.11.2 Name-value subsequences under 13.11 Namelist formatting were to read:\n\n\"Each designator may be preceded and followed by one or more optional blanks but any lexical token within a designator shall not contain embedded blanks\"."
                }
            ]
        },
        {
            "number": 134,
            "user": "urbanjost",
            "date": "2020-01-09 23:34:35+00:00",
            "title": "Ability to write part of a NAMELIST using NAMELIST group I/O",
            "text": "A useful extension to NAMELIST group I/O would be able to just print part of a NAMELIST, perhaps by giving the WRITE statement a string with a list of variables in a somewhat NAMELIST like format. Assuming\na namelist like\nnamelist /big/a,b,c,d,e,f,g\nexisted with some of the elements of the group being large arrays, to just print a subset of the NAMELIST maybe something like\nwrite(,nml=big) 'a(30:40),c'\nor with less flexibilty (the list of names could not be changed at run-time) even\nwrite(,nml=big)a(i:j)\nwould be useful, eIspecially if the output showed the subset being printed, as in\n&BIG A(10:20)=1,2,3,4,5,6,7,8,9....\nwhich could still be read back in with existing NAMELIST groups and would let you selectively examine or extract small parts of a large array, for example.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-01-10 13:57:45+00:00",
                    "text": "This is a tough one!\nThe standard appears to have focused more on facilities on NAMELIST input but not as much with NAMELIST output.  With what the standard calls null values, comments, etc., what can be done in NAMELIST output is somewhat limited relative to input.  It may prove rather difficult to get much excitement and support to make NAMELIST output more functional.\nSince the use case suggests the need with \"large arrays\", an alternative for coders might be to consider an OO approach and design 'classes' aka derived types to encapsulate such large arrays e.g., a roll-your-own derived type in Fortran to model something like 'vector' class from C++ STL as a container for the 'large' array.  Users can then implement derived-type IO (DTIO) that includes NAMELIST support to output (and input) process the array section data in a variety of flexible ways.  This might even be an option for the standard library effort."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-11 15:22:19+00:00",
                    "text": "NAMELIST was largely dropped into F90 from IBM FORTRAN (and those who copied it) and hasn't been meaningfully extended since then.  What is the real-world use case for such a feature, specifically in relation to NAMELIST? It seems like a \"can of worms\" for little payback.\nI agree with @FortranFan that this seems more amenable to a \"roll your own\" approach. You can even mimic NAMELIST output without too much effort if the format is important."
                }
            ]
        },
        {
            "number": 133,
            "user": "arjenmarkus",
            "date": "2020-01-09 15:36:27+00:00",
            "title": "Allow the source lines to be of arbitrary length",
            "text": "It is a minor issue, but sometimes the restriction of at most 132 characters hinders the programmer - or some program generating source code from specifications (I am specifically thinking here of my \"flemon\"' parser generator).\nWould it not be nice to not have to worry too much about the line length? Note that I do not intend to write code with lines of more than 100 characters or whatever fits nicely on the screen (or the printout). It is just that in particular situations - generated code or deeply nested code - you run into the right-hand margin.",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-09 16:33:56+00:00",
                    "text": "I am pretty sure we discussed this at the last October Committee meeting and I thought this was generally approved, but I can't find the proposal right now. (Starting this February meeting, I plan to rigorously track every proposal and the associated discussion at GitHub issues here.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-09 16:47:52+00:00",
                    "text": "I am pretty sure we discussed this at the last October Committee meeting and I thought this was generally approved, but I can't find the proposal right now. (Starting this February meeting, I plan to rigorously track every proposal and the associated discussion at GitHub issues here.)\n\nSee https://j3-fortran.org/doc/year/19/19-138r1.txt.  The summary is\n\n3 Specifications\nA source line contains at most ten thousand characters.\nA source statement contains at most one million characters.\nProcessors are required to be able to report too-long lines.\nContinuation is unchanged, except that the limit of 255 is removed.\n\nWG5 approved this for Fortran 202X at the Tokyo meeting August 2019.."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-10 09:12:40+00:00",
                    "text": "Perfect :)"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-10 13:59:56+00:00",
                    "text": "@arjenmarkus wrote:\n\nPerfect :)\n\nCan this issue be marked as \"Completed\" (or some such)?!"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-10 14:13:05+00:00",
                    "text": "As this topic has already been discussed in the WG5 group, it can be closed."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-10 14:13:35+00:00",
                    "text": "Just done so.\n\nOp vr 10 jan. 2020 om 14:59 schreef FortranFan <notifications@github.com>:\n\u2026\n @arjenmarkus <https://github.com/arjenmarkus> wrote:\n\n Perfect :)\n\n Can this issue be marked as \"Completed\" (or some such)?!\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#133?email_source=notifications&email_token=AAN6YR2UXHZTJFYWNJ3FOUTQ5B5N3A5CNFSM4KE2IJ62YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIT73SQ#issuecomment-573046218>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3ZUKB66VQY34DEB33Q5B5N3ANCNFSM4KE2IJ6Q>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-10 14:56:04+00:00",
                    "text": "I recommend keeping this issue open, despite there being an existing proposal and discussion at meeting. The rationale for it is that the issue doesn't get buried and people from the community can more easily discover it, support it, and give their two cents. By closing the issue, we're shutting down this side of the conversation.\nLet's keep any issue open until it officially enters the language standard. If there is an existing proposal and discussion already, we can use a tag to mark this \"in progress\" or similar. @certik what do you think?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-10 18:25:46+00:00",
                    "text": "Yes, let's definitely keep the issue open until it becomes part of the standard. I added the appropriate labels for now."
                }
            ]
        },
        {
            "number": 132,
            "user": "urbanjost",
            "date": "2020-01-09 07:02:59+00:00",
            "title": "NAMELIsT should be allowed in BLOCK constructs",
            "text": "This should be allowed:\nBLOCK\nNAMELIST /PRINT/ A,B,C\nWRITE(*,PRINT)\nENDBLOCK\nOne use of this could be  for constructing debugging sections, as in\nif(debug)then\nblock\nnamelist /print/a,b,c\nwrite(,print)\nwrite(,)' change values'\nread(,print)\nendif\nendblock\nwere you can create a local namelist to just print a subset of values in a self-describing format that can easily be read into other ad-hoc programs to analyze, for example.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2020-01-09 19:50:14+00:00",
                    "text": "@urbanjost,\nThe title here refers to NAMELIST facility in a BLOCK construct but the original post includes a second aspect (Another useful extension would be able to just print part of a NAMELIST ..) also which is unrelated to BLOCK constructs.\nCan you cut out the 2nd aspect and start a separate issue for it?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-09 23:44:08+00:00",
                    "text": "Thanks. Getting my feet wet in how best to do this. The NAMELIST request(s) seemed like an easy one to start with. It was not clear to me whether to group a number of related requests into a single page, whether there was a formal template to use or whether the intent was to start with a simple suggestion and let the dialog develop organically (which is preferable I think, to nip some things in the bud before putting to much time into them if they are not viable, etc ... versus putting in a high enough bar to keep the volume of requests to a mininum, etc). Saw examples of different approaches in the existing requests but not much mention if one approach was preferred over another  or whether all approaches were welcome."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-10 02:13:36+00:00",
                    "text": "Per my comments at comp.lang.fortran thread  where this was posed as a question earlier, I support this.\nMy view is the semantics of the BLOCK construct is not all that much different from a CONTAINed subprogram and if the following is permitted, then NAMELISTs can be allowed in BLOCK also and that will be a useful facility for many a practitioner of Fortran."
                },
                {
                    "user": "certik",
                    "date": "2021-06-21 23:44:58+00:00",
                    "text": "A paper has been submitted to the June 2021 J3 meeting:\n\nhttps://j3-fortran.org/doc/year/21/21-136.txt\n\nUnless I am mistaken, it is the same feature. The committee did not allow discussion on the paper at the meeting itself, because it is for 202Y, not 202X; but it invited committee members to provide feedback here on GitHub."
                }
            ]
        },
        {
            "number": 131,
            "user": "urbanjost",
            "date": "2020-01-09 06:18:09+00:00",
            "title": "Extend NAMELIST to support command line parsing per standard syntaxes",
            "text": "The desired extension would allow for a NAMELIST to be flagged as an argument list and a new procedure called GET_ARGUMENTS([standard_name]). The expected behavior would look like\n     integer, a=1, b=2\n     logical :: h=.false., v=.false.\n     namelist,arguments /args/a,b,h,v\n     call get_arguments()   # read command line as a NAMELIST input line\n     call get_arguments('POSIX'|'getopts'|....\nat a minimum only the NAMELIST and Sun CLIP standards would need supported, with developers free to support other command line styles.\nThe NAMELIST option can be simulated except for the ability to make the NAMELIST visible in a different scope (ie that the compiler can see the NAMELIST names).\nprogram testit\nimplicit none\n! declare and initialize a namelist\ninteger    :: i=1, j=2, k=3\nreal       :: s=111.1, t=222.2, r=333.3\ncharacter(len=255) :: c=' '\nnamelist /cmd/ i,j,k,s,t,r,c            ! just add a variable here and it is a new parameter !!\ninteger :: err\n   err=get_arguments()  ! return command line arguments as NAMELIST input\n   ! all done cracking the command line.  use the values in your program.\n   write(*,nml=cmd)\n   ! THE FOLLOWING WOULD NOT BE REQUIRED IF THE EXTENSION EXISTED\ncontains\nfunction get_arguments()\ncharacter(len=255)           :: message ! use for I/O error messages\ncharacter(len=:),allocatable :: string  ! stores command line argument\ninteger                      :: get_arguments\ninteger :: command_line_length\n   call get_command(length=command_line_length)   ! get length needed to hold command\n   allocate(character(len=command_line_length) :: string)\n   call get_command(string)\n   ! trim off command name and get command line arguments\n   string=adjustl(string)//' '                    ! assuming command verb does not have spaces in it\n   string=string(index(string,' '):)\n   string=\"&cmd \"//string//\" /\"                   ! add namelist prefix and terminator\n   read(string,nml=cmd,iostat=get_arguments,iomsg=message) ! internal read of namelist\n   if(get_arguments.ne.0)then\n      write(*,'(\"ERROR:\",i0,1x,a)')get_arguments, trim(message)\n      write(*,*)'COMMAND OPTIONS ARE'\n      write(*,nml=cmd)\n      !!stop 1\n   endif\nend function get_arguments\nend program testit\nThe program can now be called using syntax like\n   /testit  A=10 B=20\n\nThe syntax for parsing the argument values would remain the same as for NAMELIST. That is, if\nreading an array or user-defined type  you could use ARR=10,20.3,40 and so on, per NAMELIST\nrules, no matter what the syntax.\nOther than arguing what formats would be standard and how (if at all) case is handled; the advantages would be\nFortran would have a standard command-line argument parsing interface.\nExtremely easy to use using existing NAMELIST definition; and requiring no additional code to convert arguments to correct types by user.\nLeveraging existing NAMELIST features non-existent options would be detected, variable names could be equivalenced, ...\nThe https://github.com/urbanjost/M_commandline site  is as close as I could get to what I would like to because of the limitation on the scope of the NAMELIST group.  It looks at ways long and short names and case could be handled and shows that existing Fortran features can almost be used to provide the feature, indicating this should be a relatively if somewhat system-dependent feature.\nConsidering the number of  requests for a command-line interface I have seen I believe this is very commonly desired feature and using NAMELIST in this way would provide an easy-to-use interface.\nFar easier than any I have seen, including the C getopts(3c) routine.\nIn addition, since the arguments are in a NAMELIST format it would be trivial for the user to add config files to set defaults for their applications or to record and/or display the command line selections.\nThis specifically suggests changing NAMELIST groups, but has a lot in common with #25.\nThe closest I got to what I wanted that is also useful as a production version is the module\nM_CLI; but I only have tried it in one programming environment. If anyone tries it, I would appreciate hearing what compilers were used and any errors as I think it could be useful in the interim.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-01-09 06:35:05+00:00",
                    "text": "PS; There is a more extensive M_args.f90 included in the  \"General Purpose Fortran\" repository that explores other alternatives like using a prototype like\ncall get_arguments('-i 10 --help .false. --version .false. -A \"a string\"')\nI picture implementing it would be like adding the contained routine into a main program at compilation time. A more general solution would be that any procedure that can convert the command line into a table of keywords and values could be passed to the routine, which could convert that to the NAMELIST group values. This would allow users to customize the parser."
                },
                {
                    "user": "certik",
                    "date": "2020-01-09 16:36:50+00:00",
                    "text": "@urbanjost you can use ``` to format your blocks of code and use other Markdown features to better format your post. See https://guides.github.com/features/mastering-markdown/ for how to do that."
                }
            ]
        },
        {
            "number": 130,
            "user": "marshallward",
            "date": "2020-01-08 16:26:07+00:00",
            "title": "Implicit line continuation",
            "text": "I don't know if this is possible within the context of the compiler, or if it could potentially break huge amounts of existing code, but it would be nice to introduce some kind of implicit line continuation.\nFor example, the function declaration below has a &, but the parser ought to be able to infer from the open ( to keep looking for ) on the next line.\nsubroutine parse_segment_data_str(segment_str, var, value, filenam, &\n                                  fieldnam, fields, num_fields, debug)\n\nArrays could also be implicit\nx = [\n    1.1,\n    2.2,\n    3.3\n]\n\nHas this been proposed in the past?  Are there any inherent reasons why a Fortran parser cannot detect these cases?",
            "is_open": true,
            "labels": [
                "Clause 6"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-08 17:05:00+00:00",
                    "text": "From a user perspective, I would like this a lot. It's quite annoying always having to put & at the end. I like the way Python does it --- almost always the parser can infer this automatically, only when it can't, you have to use \\ as the line continuation character."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-08 17:11:44+00:00",
                    "text": "BEGIN =\n  END"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-03-08 01:35:43+00:00",
                    "text": "I would add to the list of implied continuation line indicators (in addition to array constructors and unmatched parenthesis) a line ending in a comma. Looking at a sample of 140 000, lines of free-format Fortran\ncode 88% of the continuation lines were eliminated (there were 6 868 continuation lines).  As an alternative, lines beginning with an open parenthesis would be continued till a matching close parenthesis.\nThe code looks cleaner and is easier to reformat with an editor. That is, instead of\nwrite(,) left, &\nright, &\ntop, &\ndown\narray=[ 10, 20, 30, &\n40, 50, 60, &\n70, 80, 90 ]\ncall sub(one+two+ &\nthree)\nwrite(,)'VALUES ARE NOW ', &\n&'x        ',x,&\n&'y        ',y,&\n&'z        ',z,&\n&'point    ',point,&\n&'title    ',title,&\n&'help     ',help,'h ',h,&\n&'version  ',version,'v ',v,&\n&'l        ',l,&\n&'l_       ',l_\nDATA (C(I),I=1,19)/              -0.73804295108687506715D-01,            &\n& 0.11366785079620443739D+02, -0.65838973034256501712D+02,            &\n& 0.14119145750221817396D+03, -0.15929975325701922684D+03,            &\n& 0.11122328958866232246D+03, -0.52866443153661476803D+02,            &\n& 0.18223597971689250243D+02, -0.47661469297599122637D+01,            &\n& 0.97840283604837466112D+00, -0.16191400580768858112D+00,            &\n& 0.2212712874183229440D-01,  -0.2606907391286968320D-02,             &\n& 0.316831265267384320D-03,   -0.6102072906743808D-04,                &\n& 0.1658373309202432D-04,     -0.3439710458347520D-05,                &\n& 0.338099825541120D-06,      -0.343597383680D-09/\nOne could write\nwrite(,) left,\nright,\ntop,\ndown\narray=[ 10, 20, 30,\n40, 50, 60,\n70, 80, 90 ]\ncall sub(one+two+\nthree)\n   write(*,*)'VALUES ARE NOW ', \n    'x        ',x,              \n    'y        ',y,              \n    'z        ',z,              \n    'point    ',point,          \n    'title    ',title,          \n    'help     ',help,'h ',h,    \n    'version  ',version,'v ',v, \n    'l        ',l,              \n    'l_       ',l_\n\n\nDATA (C(I),I=1,19)/              -0.73804295108687506715D-01,         \n     0.11366785079620443739D+02, -0.65838973034256501712D+02,    \n     0.14119145750221817396D+03, -0.15929975325701922684D+03,   \n     0.11122328958866232246D+03, -0.52866443153661476803D+02,  \n     0.18223597971689250243D+02, -0.47661469297599122637D+01, \n     0.97840283604837466112D+00, -0.16191400580768858112D+00,\n     0.2212712874183229440D-01,  -0.2606907391286968320D-02,       \n     0.316831265267384320D-03,   -0.6102072906743808D-04,         \n     0.1658373309202432D-04,     -0.3439710458347520D-05,        \n     0.338099825541120D-06,      -0.343597383680D-09/"
                },
                {
                    "user": "marshallward",
                    "date": "2020-03-09 14:25:06+00:00",
                    "text": "I would guess that cases like this would be difficult to parse\nwrite(,) left,\nright,\ntop,\ndown\n\nsince end-of-line is still an important token in Fortran parsing.  The comma may not be sufficient to infer line continuation, I am not sure.  (That would not have worked in Python, due to how it handles tuples, but Fortran has no such burden.)\nAlso, I think I finally understand @klausler's comment (thanks @septcolor for clarifying).  I agree that there are many such statements would be unparseable without line continuation tokens.\nTo clarify, I am only thinking of cases where there is an explicit subtoken like (...) or [...] providing a nested statement."
                },
                {
                    "user": "certik",
                    "date": "2020-03-09 15:32:05+00:00",
                    "text": "I can see how this might be hard (impossible?) to do with the current semi-reserved keywords in Fortran. I opened an issue #167 to discuss that. Unfortunately for the above proposal, it's probably best if the standard itself keeps the semi-reserved keywords, so the above proposal probably cannot be standardized."
                },
                {
                    "user": "klausler",
                    "date": "2020-03-09 16:01:41+00:00",
                    "text": "Fortran doesn't have reserved keywords, semi- or otherwise.  But it does have special rules for things that look like END statements.\nActual implementations of Fortran need to be able to have some separation of concerns for all of the tasks that have to occur during and before parsing.  Some compilers (esp. ones built with parser generators) need to have a tokenization module acquiring tokens from the source and passing them on to the parser proper, and the state of the parse needs to affect the tokenization rules so that things like MODULEPROCEDUREFOO get dealt with correctly.  Other compilers (recursive descent with backtracking) normalize the source, dealing with line continuation and INCLUDE and preprocessing along the way, without knowledge of the partial parse.\nThese proposals that mess with line continuation rules would be hard to implement in both of these kinds of compilers -- those with tokenization steps that handle line continuation will need more state from the parser to handle the implicit continuation, and those that normalize the source stream before beginning any parsing will have to track things like parenthesis/bracket nesting and dangling = signs while making line continuation decisions.  All of this would make error recovery harder, too, and that's the last thing you want with Fortran."
                },
                {
                    "user": "marshallward",
                    "date": "2020-03-09 17:19:00+00:00",
                    "text": "Thanks @klausler, I figured there would be restrictions on what might be possible.  I can appreciate that it may be extremely problematic to implement.  Do you see any particular challenges with, say, implicit line continuation for arrays?\nAlso I'd be keen to know if there are any other examples where line continuation would be either impossible to resolve, or even just too problematic or computationally expensive.\nBTW I do not plan or ever expect to see this proposed, I am more interested in whether it's possible or what could be done here.  If you are busy, then don't let this take up any more time!"
                },
                {
                    "user": "certik",
                    "date": "2021-10-27 14:17:22+00:00",
                    "text": "Also proposed at https://fortran-lang.discourse.group/t/make-line-continuation-operator-optional/2176."
                }
            ]
        },
        {
            "number": 129,
            "user": "certik",
            "date": "2020-01-07 18:08:39+00:00",
            "title": "Introduce \"auto\"",
            "text": "Introduced by @pklausler at #40 (comment):\nGolang has var := expr; which declares var to have the type of the value of expr, which is also assigned to it.  The fact that an initializing declaration must necessarily have an expr does make the explicit type somewhat redundant on the statement.  So I suggest AUTO :: a = expr, b = expr, ... and AUTO, POINTER :: p => target, ....\nFurther examples:\nAUTO :: a = expr, b = expr, ...\nauto :: x = 3.14159\nauto, pointer :: p => t",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-07 18:17:26+00:00",
                    "text": "@pklausler, mentioned that auto would not preclude an explicit type (or shape).\nHow would the syntax work? Maybe like this:\nauto, integer :: a = expr, b = expr, ...\nauto, real :: x = 3.14159\nperhaps also like this:\ninteger, auto :: a = expr, b = expr, ...\nreal, auto :: x = 3.14159\nSo it would act like the init proposal at #40, except that in addition to init, it would also allow to omit the type, and it would get inferred."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 08:28:07+00:00",
                    "text": "I think, having auto at a later stage in Fortran will become important. It is not clear to me, though, how it would handle arrays. Would\n auto, allocatable :: a(:) = some_big_array\n\nwork?\nAs for the second comment, I don't see the use case for specifying the type together with the auto keyword. If it is just in order to avoid explicit saving, then I find it counter intuitive (what is \"automatic\" in integer, auto :: a = expr?)."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-08 16:12:23+00:00",
                    "text": "Features like this really get back to the question: For whom Fortran?\nShould the consensus be Fortran is for certain (a limited set?) practitioners doing their computing in a manner (say individual development and/or small/isolated teams and/or much longer timescales than viewed by managers wanting \"agile development\") such that forcing certain verbosity and redundancy in coding instructions are to be always considered a desired \"feature\" of the language, then there can be a fair argument to ignore type inference facilities such as with auto.\nHowever if Fortran is to be viewed more broadly as being suitable for large new applications also, even in the scientific and technical computing domains, and where the development may span many large teams with huge number of coders and pressing schedules and so forth, then the language development needs to keep an open mind and consider a 'bigger tent' approach.  That is, support those wanting explicit typed declarations (as is the case now) but also allow type inferencing.\nConsider for example, the development of a 'modern' process simulator of chemical manufacturing facilities costing $$ billions with extensive handling of massive amounts of data in addition to intensive numerical computations: languages supporting features such as the ones introduced in C++ starting their C++11 revision thru' C++14, C++17, and soon C++20 (including with type inference and auto are going to preferred by majority of the developers because these developers then find it easier to rapidly put together functional codes for a lot of the component and libraries which are both critical and reused extensively across the application.  Fortran will suffer in such situations if it remains too rigid and inconsistent (seeks explicit type safety in principle but refuses to let go of implicit typing in practice)."
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 16:21:44+00:00",
                    "text": "@FortranFan I can see both sides and I don't currently know if we should have it or not.\nAs I posted in #40, I use C++ often, and I do not like the auto keyword for simple types such as integer or float. I use auto for complicated iterators, as that simplifies the code a lot (e.g., in \"for auto\"). But otherwise whenever I can, I try to list the type explicitly, because it makes the code a lot more readable --- the reader can immediately see the types of everything. With auto everywhere, the code starts looking like Python. And Python, while I like it and have been using for 20 years, I find it much less readable than C++ or Fortran, precisely for the lack of visible types. But Python is the best for quickly prototyping an application. Much better than C++.\nMore generally, I think auto makes it easier to quickly prototype. For example it would be ideal for LFortran in the Jupyter notebook setting. In production code, on the other hand, I think it makes things harder to read and maintain. So I don't know what the best approach is."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2020-06-04 14:54:33+00:00",
                    "text": "But otherwise whenever I can, I try to list the type explicitly, because it makes the code a lot more readable --- the reader can immediately see the types of everything.\n\nI think I would disagree, that no explicit listing of the type makes the code necessarily much less readable for two reasons:\n\nWith good naming of variables, the type should be obvious from the variable name. i.e. variables ending with _count or _index are integers. Having the type written explicitly is then just redundant information\nMost of the C++ code is nowadays written with powerful IDEs, where you can just hover over a variable to see the type. So if you are not able to deduce the type from the name, there is a fast way to look it up (other than going to some functions definition)\n\nHowever, there are no powerful native Fortran IDEs out there. I for instance use Clion with the Fortran plugin, which works okayish, but not as good as for C++ (especially the refactoring)"
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 15:38:58+00:00",
                    "text": "@Libavius I think you would agree that with no explicit typing, you need an IDE to help you. We should (and we will) have an IDE for Fortran, for example Flang or LFortran will in the future provide the language server for VSCode.\nBut there is a beauty of not needing an IDE to write and to read code. That's what I mean by simple."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2020-06-04 17:05:28+00:00",
                    "text": "@certik the prospect of a Fortran IDE sounds really promising =).\nI agree, that in many cases, explicit typing improves readability. In addition to the IDE stuff, I wanted to point out, that this is not necessarily always the case and that good naming can (sometimes) make explicit typing redundant.\nThe option of having an auto keyword would give programmers the freedom to avoid this redundancy, while still using explicit types where they improve the readability."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-04 17:14:29+00:00",
                    "text": "@Libavius I think you would agree that with no explicit typing, you need an IDE to help you. We should (and we will) have an IDE for Fortran, for example Flang or LFortran will in the future provide the language server for VSCode.\nBut there is a beauty of not needing an IDE to write and to read code. That's what I mean by simple.\n\nIt's not all-or-nothing, IDE or not (I do all my programming with a simple editory).  Haskell programmers know the power of type inference and are accustomed to adding explicit type signatures where they improve readability, and avoiding them when they don't, for example.  And C++ programmers learn where auto does and does not make sense.  The circumstances matter."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 17:57:59+00:00",
                    "text": "@klausler I think you are right. As long as we provide guidelines how to use auto, I think it would be very useful."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 20:24:09+00:00",
                    "text": "My understanding is that one of the biggest powers of auto in C++ is that you get proper static typing of local variables in template instantiation. I think the biggest driver for auto in Fortran will come from the generics efforts. Although typeof and classof may diminish that need."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-04 20:36:16+00:00",
                    "text": "auto is extremely useful in templatized C++ code to avoid having to explicitly write out complicated type expressions (or to avoid using type aliases), yes.  And auto is absolutely essential when declaring things whose types are hidden in the compiler (e.g., lambda as local variables for use as internal functions) or polymorphic (e.g., a lambda like [](const auto &x){...} with a hidden template implementation).\nBut sometimes it's great to have around just to save some completely redundant verbiage in C++.  const auto *p{std::get_if<VerboseButInformativeTypeName>(&u)}; isn't made any more readable if the auto is replaced with the long type name, I think.  And that's why I think it would be useful in Fortran today -- when there's an initializer with an obvious type."
                },
                {
                    "user": "fazedo",
                    "date": "2020-11-04 15:48:19+00:00",
                    "text": "auto is very useful in C++, but I see few situations where it will be well employed in Fortran. Let's see some examples in C++:\n\nfor (auto x: some_list) do_stuff(); // Fortran does not have range-based loops.\nauto it = something.begin();         // Fortran does not have support for iterators in a generic programming fashion.\nauto t0 = get_time();                    // auto is cool because I don't care about t0 class.\n... some code..\nauto t1 = get_time();\nauto elapsed_time = t1 - t0;          // Again I don't care about which class is that.\n// But Fortran does not allow declarations in the middle of the code.\nauto f = [] (double x, int n) -> double {some code}; // Again Fortran...\nint i = 2;\nauto j = i;                                      // Not good practice. \"Explicit is better than implicit.\" - Tim Peters\nauto x = 2.3;                                 // Idem.\nauto x = f();                                   // Not common to declare variables and define them on the same line.\n\nauto was introduced in C++11 when generic programming was already well settled down, so it found a plethora of good places to be used, while, in Fortran, I don't see it will be really useful.\nI do believe Fortran needs support for generic programming as a scientific computing language, which is supposed to translate algorithms, not just formulas, but for the moment that is not the case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-11-04 16:09:27+00:00",
                    "text": "In a sense, Fortran already does have something roughly equivalent to auto.\nassociate(x => some_function()) ! x takes on the type and value of the return from some_function\n  ! some code\nend associate"
                },
                {
                    "user": "fazedo",
                    "date": "2020-11-15 18:23:40+00:00",
                    "text": "Just in case it helps the discussion, there is an excelent talk by Herb Sutter on CppCon 2014 where he discuss several situations where it is a good practice to employ auto: https://youtu.be/xnqTKD8uD64?t=1703 ."
                }
            ]
        },
        {
            "number": 128,
            "user": "certik",
            "date": "2020-01-03 22:15:23+00:00",
            "title": "Allow an intent(out) argument to adopt the same kind as an input(in) argument",
            "text": "Use case: when one wants to write a function that operates on all kinds, the only way currently is:\nuse kinds, only: sp, dp, qp\n...\ninterface log10\n    module subroutine log10_sp\n    module subroutine log10_dp\n    module subroutine log10_qp\nend interface\n...\nreal(sp) function log10_sp(x) result(r)\nreal(sp), intent(in) :: x\nr = log(x) / log(10._sp)\nend function\n\nreal(dp) function log10_dp(x) result(r)\nreal(dp), intent(in) :: x\nr = log(x) / log(10._dp)\nend function\n\nreal(qp) function log10_qp(x) result(r)\nreal(qp), intent(in) :: x\nr = log(x) / log(10._qp)\nend function\nOne can generate these in various ways (see fortran-lang/stdlib#35 where we discuss various approaches).\nInstead, it would be nice if one could write the above as follows:\nreal(wp) function log10(x) result(r)\ninteger, parameter :: wp = kind(x)\nreal(wp), intent(in) :: x\nr = log(x) / log(10._wp)\nend function\nWhere one defines the local variable wp with the \"working precision\" of x. This would be a generic function (templated on the \"kind\"), that is instantiated when used to the actual kind of the input argument x at the call site.\nThis would work for subroutines also, e.g.:\nsubroutine log10(x, r)\ninteger, parameter :: wp = kind(x)\nreal(wp), intent(in) :: x\nreal(wp), intent(out) :: r\nr = log(x) / log(10._wp)\nend function\nThe way compilers would implement that is not by \"templates\" and \"instantiation\" but by simply immediately generating different versions of the log10 function for all the precisions that the compiler supports, typically three for reals (sp, dp and qp). So it should be about as fast to compile as the hand written first version above which does this explicitly. And once it is compiled, user code should be as fast to compile as today.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2020-01-03 22:25:17+00:00",
                    "text": "You probably don't want to use both real(wp) and result(r) on the same function statement.\nLet me suggest this revision:\nfunction log10(x) result(r)\n  real(kind=*), intent(in) :: x ! <- note the \"assumed kind\" type parameter\n  integer, parameter :: wp = kind(x) ! no longer a forward reference to x\n  real(kind=wp) :: r\n  r = log(x) / log(10._wp)\nend"
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 22:27:13+00:00",
                    "text": "@klausler that's better. Thanks!"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-04 22:40:58+00:00",
                    "text": "@klausler wrote:\n\nYou probably don't want to use both real(wp) and result(r) on the same function statement.\nLet me suggest this revision:\nfunction log10(x) result(r)\n  real(kind=*), intent(in) :: x ! <- note the \"assumed kind\" type parameter\n  ..\n\n\nThough I don't have ready references at the moment, indications are the Fortran standard committee has disfavored the \"assumed kind\" option, that they have insisted the kind type parameter to be either defaulted or be given by a constant expression.  One can see evidence of this with parameterized derived type (PDT) facility starting Fortran 2003 that introduced assumed length parameter option with derived types but no assumed kind; and with assumed type ( TYPE(*) ) and assumed rank ( DIMENSION(..) ) options starting Fortran 2018.  It's unclear whether such a position against assumed kind can change in the future.\nNote the original post here is but one use case for proper GENERICS in Fortran.  Toward generics, it appears the committee is open to the notion of certain UTILITIES e.g., TYPEOF/CLASSOF intrinsic inquiry functions that can employed in dummy argument declarations.  In the same vein, I wonder if might be feasible to consider another utility, say ALL_OF, that can be allowed in constant expressions.\nConsidering the standard states in the context of standard intrinsic modules, \"The processor shall provide the named constants, derived types, and procedures described in 16.10.2\" and among the constants listed include the KINDs of intrinsinc types such as REAL_KINDS, INTEGER_KINDS, CHARACTER_KINDS, etc., a utility such as ALL_OF can make feasible the following which might make it easier for processors to do the needful, meaning put together all the necessary wiring toward the generic interface needed by a coder, as illustrated in the original post.\nfunction log10(x) result(r)\n   use, intrinsic :: iso_fortran_env, only : REAL_KINDS\n   real(kind=ALL_OF(REAL_KINDS)), intent(in) :: x \n   integer, parameter :: wp = kind(x) ! no longer a forward reference to x\n   real(kind=wp) :: r\n   r = log(x) / log(10._wp)\nend"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-06-30 19:40:56+00:00",
                    "text": "The TYPE_OF facility plans for 202X would simplify this usage."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-07-01 13:41:15+00:00",
                    "text": "@wclodius2 wrote June 30, 2020 3;40 PM EDT:\n\nThe TYPE_OF facility plans for 202X would simplify this usage.\n\nNo, it won't - see my earlier reply."
                }
            ]
        },
        {
            "number": 127,
            "user": "nncarlson",
            "date": "2020-01-03 20:09:06+00:00",
            "title": "Improved control of type bound procedure accessibility",
            "text": "Here is a problem I regularly encounter: I have a class with a type bound procedure that (a) should not be publicly accessible (for invoking); but (b) I want to allow an extension of the class to override the procedure. In many cases the class is an abstract type and the procedure is deferred. This appears in the non-virtual interface (NVI) pattern, for example. Because of (a) I want to declare the procedure private, but due to (b) I have to let it be public (the two type declarations are in separate modules).\nI wish there was another type bound procedure accessibility attribute between public and private with the effect that the procedure would not be accessible for invoking, but would be accessible when declaring an extension of the type.",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-03 20:44:40+00:00",
                    "text": "@nncarlson is it the same thing as protected members in C++?"
                },
                {
                    "user": "nncarlson",
                    "date": "2020-01-03 21:29:16+00:00",
                    "text": "@certik After visiting SO (my C++ is weak) I think it is the same in spirit but there are some differences due to Fortran's additional module scope. As it pertains to type bound procedures:\n\nFortran public == C++ public\nFortran private => inaccessible outside module, but still accessible and overridable within the module.\n\nSo perhaps what I'd propose is a new attribute protected for type bound procedure declarations with this effect:\n\nWithin the module scope: protected functionally the same as private (or public)\nOutside of module scope: protected parent procedure would be accessible (and overloadable) within code defining/implementing a child type, but otherwise as private\nprotected is incompatible either non_overridable or private\n\nPerhaps a protected attribute makes sense for data components of a derived type too."
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-01-03 21:39:05+00:00",
                    "text": "Correct me if I'm wrong but I'm pretty sure it's possible to override a\nprivate type-bound procedure even from another module (although not to call\nit). Pretty sure this is done in the Abstract Calculus pattern.\n\u2026\nOn Fri, 3 Jan 2020, 21:29 Neil Carlson, ***@***.***> wrote:\n @certik <https://github.com/certik> After visiting SO (my C++ is weak) I\n think it is the same in spirit but there are some differences due to\n Fortran's additional module scope. As it pertains to type bound procedures:\n\n    - Fortran public == C++ public\n    - Fortran private => inaccessible outside module, but still accessible\n    and overridable within the module.\n\n So perhaps what I'd propose is a new attribute protected for type bound\n procedure declarations with this effect:\n\n    - Within the module scope: protected functionally the same as private\n    (or public)\n    - Outside of module scope: protected parent procedure would be\n    accessible (and overloadable) within code defining/implementing a child\n    type, but otherwise as private\n    - protected is incompatible either non_overridable or private\n\n Perhaps a protected attribute makes sense for data components of a\n derived type too.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#127?email_source=notifications&email_token=AB6ESPJSCZGUJ4KBKVR2M7LQ36U23A5CNFSM4KCRNFVKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEICD7FI#issuecomment-570703765>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPNCUSWOXJORJ37MWXLQ36U23ANCNFSM4KCRNFVA>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-03 21:40:32+00:00",
                    "text": "Be advised: the keyword PROTECTED is already used for something else (8.5.15).\nMaybe it would suffice to define an exception to PRIVATE checking in this specific case of overriding a parent procedure in an extended derived type."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-01-03 22:08:22+00:00",
                    "text": "@cmacmackin, interestingly enough in fact you can (I was surprised), but it's not exactly overriding the procedure. The parent class doesn't see it as being overridden as the following example shows (but this behavior could be exactly what one wants -- just not in the NVI-type use cases I'm usually encountering).\nBut the one case this definitely doesn't work at all is with an abstract base class and deferred procedure, because deferred and private are incompatible attributes.\nHere's the example:\nmodule parent_type\n  private\n  type, public :: parent\n  contains\n    procedure, private :: private_sub\n    procedure :: public_sub\n  end type\ncontains\n  subroutine private_sub(this)\n    class(parent) :: this\n    print *, 'parent:private_sub'\n  end subroutine\n  subroutine public_sub(this)\n    class(parent) :: this\n    call this%private_sub\n  end subroutine\nend module\n\nmodule child_type\n  use parent_type\n  private\n  type, extends(parent), public :: child\n  contains\n    procedure :: private_sub\n  end type\ncontains\n  subroutine private_sub(this)\n    class(child) :: this\n    print *, 'child:private_sub'\n  end subroutine\nend module\n\nuse parent_type\nuse child_type\ntype(parent) :: p\ntype(child) :: c\ncall p%public_sub  ! prints parent:private_sub\ncall c%public_sub  ! prints parent:private_sub\nend"
                },
                {
                    "user": "nncarlson",
                    "date": "2020-01-03 22:14:37+00:00",
                    "text": "@klausler I forgot that protected was already in use.  But would that prevent it from being used in another context where it can't be currently used at all? That said, I don't find \"protected\" to be all that descriptive of what it implies for C++, I'm just using it as proxy by analogy with C++."
                },
                {
                    "user": "nncarlson",
                    "date": "2020-01-03 22:25:23+00:00",
                    "text": "@klausler\n\nMaybe it would suffice to define an exception to PRIVATE checking in this specific case of overriding a parent procedure in an extended derived type.\n\nYes, that would too. And if one didn't want that exception the procedure could bePRIVATE, NON_OVERRIDABLE. That would recover the existing behavior outside of the module scope, though change things for the module scope."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-04 17:53:52+00:00",
                    "text": "@nncarlson wrote:\n\nHere is a problem I regularly encounter: I have a class with a type bound procedure that (a) should not be publicly accessible (for invoking); but (b) I want to allow an extension of the class to override the procedure. In many cases the class is an abstract type and the procedure is deferred. This appears in the non-virtual interface (NVI) pattern, for example. Because of (a) I want to declare the procedure private, but due to (b) I have to let it be public (the two type declarations are in separate modules).\nI wish there was another type bound procedure accessibility attribute between public and private with the effect that the procedure would not be accessible for invoking, but would be accessible when declaring an extension of the type.\n\n@nncarlson and all interested,\nPlease take a look at this discussion thread on essentially the same user need as here from Intel Fortran Forum several years ago: https://software.intel.com/en-us/forums/intel-fortran-compiler/topic/681705.\nIn this Intel Fortran forum thread, please look at the comments by IanH, a brilliant mind when it comes to programming languages as well as the Fortran standard: IanH makes some excellent points e.g., \"The result of the interp results in a capability gap for authors when they want a binding that can be overriden but not invoked - which is what I guess was the intent of the code in Fortran Fan's example.  It would be nice to see the language address this in the future.\" and who provides other use cases later in the thread involving designing of libraries using Fortran.\nI'll check but my recollection is a similar need has been expressed on other forums (comp-fortran-90 mailing list or even J3 itself) re: derived type (or \"classes\") and type-bound procedures vis-a-vis the current accessibility statements with PUBLIC/PRIVATE that work at the MODULE level in Fortran.\nSo my thought was to consider the concept of EXTENSIBLE MODULEs as I had mentioned in the Intel forum link above which, if combined suitably with the concept of PACKAGEs and/or NAMESPACEs, can prove quite handy, I believe.\n\nextend (!) the EXTENDS facility in the language to MODULEs as well and to introduce OVERRIDABLE keyword and see if this can address the \"capability gap\" mentioned by IanH above.  For example, say the language allowed the following:\n\nmodule, overridable :: b_m\n   ! NOTICE the keyword above implying this module is EXTENSIBLE\n   ! By default, modules are to be NON_OVERRIDABLE\n\n   implicit none\n\n   private\n\n   type, abstract, public :: b_t\n   contains\n      private\n      procedure(Ip), pass(this), deferred :: p\n   end type b_t\n\n   abstract interface\n      subroutine Ip( this)\n         import :: b_t\n         class(b_t), intent(inout) :: this\n      end subroutine Ip\n   end interface\n\nend module b_m\nmodule, extends(b_m) e_m\n   ! NOTICE extends keyword above\n\n   implicit none\n\n   private\n\n   type, extends(b_t), public :: e_t\n   contains\n      procedure, pass(this) :: p => e_p\n   end type e_t\n\ncontains\n\n   subroutine e_p( this)\n      class(e_t), intent(inout) :: this\n   end subroutine e_p\n\nend module e_m\n\nThen can one effectively view a new module (e_m) as belonging to the same scope as base module (b_m) and thereby what's private to b_m can become accessible to the extended module.  Developers of base module can mark it as either OVERRIDABLE (or a keyword of another name , say EXTENSIBLE) or NON_OVERRIDABLE (a keyword which already exists in the context of TBPs or a new one, say NON_EXTENSIBLE).  The default will be such as to be consistent with existing code.  I wonder if this can give flexibility to coders when it comes to extending derived types.  My thought is to introduce functionality somewhat similar to \"internal\" (or protected or even friend) inheritance in other OO languages where \"children\" can access certain information from \"parents\" that others consumers cannot."
                },
                {
                    "user": "zjibben",
                    "date": "2020-01-08 22:56:39+00:00",
                    "text": "Is this the same as #16, and the proposal @aradi started in #31?"
                },
                {
                    "user": "aradi",
                    "date": "2020-01-09 09:13:04+00:00",
                    "text": "No, it is not. Issue #16 and PR #31 aim for allowing read-only access to variables in derived types (similarly, how you can do it for module variables with the protected attribute already). This issue here, as far as I understand, tries to fix the problem that a type-bound procedure is either public or private, but there is no way to allow special access for extending derived types. It aims to introduce something like the protected methods in C++. (Which would be also definitely a very desirable goal.)"
                }
            ]
        },
        {
            "number": 126,
            "user": "jacobwilliams",
            "date": "2019-12-30 19:23:33+00:00",
            "title": "Dynamic Eval for Fortran",
            "text": "So, here's a thought. This would be amazing:\ninteger :: i,j\ni = 1\ncall eval('j = i + 1')  ! some sort of new intrinsic\nwrite(*,*) j  ! writes 2\nSo, something akin to Python's eval.\nNow, we can already write function parsers (see here and here, and we outlined a more modern approach here). But, these are limited and require you to manually pass in the variables you want your function to have access to (there is no access to the current Fortran scope). An intrinsic eval could:\n\nHave full access to everything in the current scope\nBe able to execute arbitrary Fortran code\n\nMoving Fortran more into the realm of dynamic languages would be game-changing I think.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 21:27:48+00:00",
                    "text": "I don't believe this is feasible for a compiled language. It would effectively require the fortran run time to carry around a copy of its own compiler, that understands how to interface with the code it generated. Additionally, the mechanics of making it work, and fail properly, are incredibly complex. What happens if you put invalid code in there? You can't check that at compile time, because the string could be generated at run time. What if the code includes something that fails? I.e. call eval('read('Hi', '(I0)') var'). What if the code includes variables that aren't in scope? Can you put variable definitions in there? I'ts just too complex."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 21:41:11+00:00",
                    "text": "I didn't say it would be easy. \ud83d\ude04 Just trying to get us to think big, and not just about minor updates.\nA vendor could choose to only allow this feature if the compiler was installed on the machine maybe? Same way you have to have Python installed to run Python (or Julia installed to run Julia). Others could include it in the runtime. The standard could be silent on this (as it is silent on so many other things).\nErrors would be run time errors. It would probably need to return some kind of status code or message (or raise an exception if we ever actually get that)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 22:04:35+00:00",
                    "text": "@jacobwilliams , do you know of any compiled language which has this capability? Python and Julia are interpreted languages, so when eval is invoked, the interpreter is already running and has full access to the current environment. It would be a pretty incredible feature, but I don't think it fits in with Fortran's goals."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 22:11:31+00:00",
                    "text": "This could be done in the future with LFortran. It can already just in time compile, so it is effectively interpreted, just like Julia works. But whether it should be done is another question --- I really like that Fortran can be fully and statically compiled. The idea behind LFortran is to keep this feature, but allow Julia/Python like interactive development. I wanted to implement something like eval that you described, because it would make it feel more like Python, which could be useful for interactive development, the main target of LFortran. But for production use, I would prefer if Fortran didn't have this feature. So how to reconcile this?\n@jacobwilliams what are some use cases where you would like to use this feature?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 22:18:39+00:00",
                    "text": "@everythingfunctional No, I don't know of a compiled language that has this. But wouldn't it be amazing if Fortran had it!\n@certik Personally, I would use this like crazy, even in production. I've spent countless hours and written tens of thousands of lines of code to give my users the ability to dynamically add computations to a compiled Fortran application (this includes a DLL plugin architecture, hand-written embedded parsers, callbacks to Python, etc). I could probably replace all that with this. It would be glorious.\nAnother trivial (but important) use case would be config file input to programs. If they could contain actual Fortran code, that would be amazing (e.g., the way some people use Lua for this right now).\nVery excited to know that maybe it's at least a possibility for LFortran."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 23:10:38+00:00",
                    "text": "@jacobwilliams ok, interesting. I created an issue for this: https://gitlab.com/lfortran/lfortran/issues/149.\n(The eval functionality is mostly already implemented in LFortran, it's just not exposed from Fortran itself, only from Python and now C++, as that is how the read eval loop is implemented.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-31 01:17:28+00:00",
                    "text": "This could be done in the future with LFortran. It can already just in time compile, so it is effectively interpreted, just like Julia works. But whether it should be done is another question --- I really like that Fortran can be fully and statically compiled. The idea behind LFortran is to keep this feature, but allow Julia/Python like interactive development.  ..\n\nBy the way, does the Fortran standard require a processor to statically compile programs?  My understanding is no; that, as written, it doesn't care whether a processor is a Python/Julia type of interpreting one or a static compiler."
                },
                {
                    "user": "marshallward",
                    "date": "2019-12-31 01:26:33+00:00",
                    "text": "FWIW, eval type functions can be considered unsafe, since they can be a way to inject code into an executable.  I'd probably prefer that something like this not exist if it's not necessary."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-31 02:05:05+00:00",
                    "text": "From the top of my head, Rust, Go, C#, Lisp are examples of compiled languages that can eval. I bet there are many more. Compiled binary needs to have a runtime included to be able to eval() as it runs. LFortran seems like a good candidate for such a thing."
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 02:08:19+00:00",
                    "text": "Indeed. The advantage of not including eval is that you can ahead of time compile everything. By including it, the Fortran runtime library has to include the full Fortran compiler (with LLVM etc.) and indeed any code can then be compiled and executed at runtime.\n\nFor HPC usage, I think I'd like to know, as a user, that there will be no runtime compilation going on.\n\nBut the advantage of having eval is that you can then configure your app using Fortran itself and provide all kinds of nice Python like behavior at runtime.\n\u2026\nOn Mon, Dec 30, 2019, at 6:26 PM, Marshall Ward wrote:\n FWIW, `eval` type functions can be considered unsafe, since they can be\n a way to inject code into an executable. I'd probably prefer that\n something like this not exist if it's not actually necessary.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#126?email_source=notifications&email_token=AAAFAWCVZQ5BIKB5SG7SFWLQ3KNUVA5CNFSM4KBPNV42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH3SBIA#issuecomment-569843872>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBWRFLWBSDJXDOO5N3Q3KNUVANCNFSM4KBPNV4Q>."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-31 17:29:16+00:00",
                    "text": "Yep, HPC applications may not need this... although I could see using a Fortran config file input as being useful. Think about namelists as being a very very restricted kind of Fortran code, and then allow any arbitrary Fortran code to be in there. Think of the possibilities. :)\nYes, it could be considered unsafe... but so are a lot of things. execute_command_line could also be considered unsafe, since it can basically do anything. People just have to be aware of what there are doing. I think this eval idea is safer than loading a DLL, since at least you have access to the code you are running.\nAnd certainly, those of us building interactive applications would benefit tremendously from this. It also has the potential to expand the use cases of Fortran, which is what we need to be thinking about.\nI could definitely see some of the Big Corp compilers not implementing this, but that's OK (intel hasn't implemented unicode, but the standard allows that option). The interface could be similar to execute_command_line (which I think also has the option of returning a -1 exit code for the alleged \"processors\" that don't have the concept of a command line)."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-31 17:41:20+00:00",
                    "text": "The concept of eval is considered bad and security risk in almost all\ncases. I do not think it would be worth the effort. It would also probably\nonly work for very simple expressions (so that no arbitrary code can be\nexecuted). So I think it's a strong no in this case.\n\nwt., 31 gru 2019, 18:29 u\u017cytkownik Jacob Williams <notifications@github.com>\nnapisa\u0142:\n\u2026\n Yep, HPC applications may not need this... although I could see using a\n Fortran config file input as being useful. Think about namelists as being a\n very very restricted kind of Fortran code, and then allow any arbitrary\n Fortran code to be in there. Think of the possibilities. :)\n\n Yes, it could be considered unsafe... but so are a lot of things.\n execute_command_line could also be considered unsafe, since it can\n basically do anything. People just have to be aware of what there are\n doing. I think this eval idea is safer than loading a DLL, since at least\n you have access to the code you are running.\n\n And certainly, those of us building interactive applications would benefit\n tremendously from this. It also has the potential to expand the use cases\n of Fortran, which is what we need to be thinking about.\n\n I could definitely see some of the Big Corp compilers not implementing\n this, but that's OK (intel hasn't implemented unicode, but the standard\n allows that option). The interface could be similar to\n execute_command_line (which I think also has the option of returning a -1\n exit code for the alleged \"processors\" that don't have the concept of a\n command line).\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#126?email_source=notifications&email_token=AC4NA3N6JHMQKI6TYBURXGDQ3N6O5A5CNFSM4KBPNV42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH4PDWQ#issuecomment-569962970>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KFR6FBN7ESD7OZUALQ3N6O5ANCNFSM4KBPNV4Q>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-31 17:44:57+00:00",
                    "text": "Indeed. The advantage of not including eval is that you can ahead of time compile everything. By including it, the Fortran runtime library has to include the full Fortran compiler (with LLVM etc.) and indeed any code can then be compiled and executed at runtime.\n\nIt also needs to have (a representation of) the original program's scopes and symbols and types and IMPLICIT rules and generic interfaces, so that the names in the evaluated statement can be resolved at runtime.  This would be a big deal.\nIt also needs to generate code in such a way that any symbol that might appear in an eval is available at runtime (essentially -g0 mode), so performance of the compiled code around the eval will suffer."
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 17:51:00+00:00",
                    "text": "Yes, agreed. I still like the idea. But perhaps not for the main standard, but just a compiler extension.\n\u2026\nOn Tue, Dec 31, 2019, at 10:44 AM, Peter Klausler wrote:\n >\n > Indeed. The advantage of not including eval is that you can ahead of time compile everything. By including it, the Fortran runtime library has to include the full Fortran compiler (with LLVM etc.) and indeed any code can then be compiled and executed at runtime.\n\n It also needs to have (a representation of) the original program's\n scopes and symbols and types and `IMPLICIT` rules and generic\n interfaces, so that the names in the evaluated statement can be\n resolved at runtime. This would be a big deal.\n\n It also needs to generate code in such a way that any symbol that might\n appear in an `eval` is available at runtime (essentially `-g0` mode),\n so performance of the compiled code around the `eval` will suffer.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#126?email_source=notifications&email_token=AAAFAWGNMVGHLEOO6WYTTTLQ3OAJTA5CNFSM4KBPNV42YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH4PT3A#issuecomment-569965036>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWAVI33GQWHDJCXHIQDQ3OAJTANCNFSM4KBPNV4Q>."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-02 00:17:38+00:00",
                    "text": "I often see requests for an expression evaluator, and if one limits it to that, it's at least feasible. To make this work at all you would need to identify the variables you wanted to use in advance so that the compiler could pass information about them to the evaluator. NAMELIST already has to do this sort of thing.\nThat said, I don't see this as an idea that would gain much traction for the standard. It's something that could be done as a library, with calls to \"register\" variables. If you wanted it to be magic and see all the host-scope variables, the idea would be DOA in my opinion."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-07 19:40:52+00:00",
                    "text": "Actually, my contribution in #32 is quite akin to that: lambda expressions. Also see the \"experiments\" directory in my Flibs project enumerating (integer) sets and the like - enum_set.f90 for instance. Not entirely an \"eval()\" function, but still."
                },
                {
                    "user": "gklimowicz",
                    "date": "2021-07-30 02:43:25+00:00",
                    "text": "@jacobwilliams , do you know of any compiled language which has this capability?\n\nCommon Lisp compilers have this capability (and they are not interpreters). You're right, @everythingfunctional, though, it does require all the compilation machinery at runtime. And I believe the evaluated code runs in a separate \"environment\" that doesn't have access to the lexical environment.\nGreenspun's Tenth Rule: \"Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.\""
                }
            ]
        },
        {
            "number": 125,
            "user": "everythingfunctional",
            "date": "2019-12-29 03:58:07+00:00",
            "title": "Traits For Types",
            "text": "Java calls them interfaces, Haskell calls them type classes, and Rust calls them traits. But the basic gist is that you can define the procedures that a type must have in order to implement a trait. A type can then be marked as implementing that trait, and procedures and types can specify traits instead of just types or classes.\nThe additional syntax would be as follows.\nA new block structure, similar to interface, that defines a trait. I.e.\ntrait some_trait\n    function someFunc(self, other)\n        trait(some_trait), intent(in) :: self\n        integer, intent(in) :: other\n        real :: someFunc\n    end function someFunc\n\n    subroutine someRoutine(input, output)\n        integer, intent(in) :: input\n        integer, intent(out) :: output\n    end subroutine someRoutine\nend trait some_trait\n\nA new statement only valid in a type definition. I.e.\ntype, public :: someType\n    implements some_trait\ncontains\n    procedure :: someFunc => someTypeSomeFunc\n    procedure, nopass :: someRoutine => someTypeSomeRoutine\nend type someType\n\nAnd a new keyword for variable declarations. I.e. the following would all be valid\nsubroutine doSomething(some_input)\n    trait(some_trait), intent(in) :: some_input\n    ...\nend subroutine doSomething\n\ntype, public :: someOtherType\n    trait(some_trait), allocatable :: something\nend type someOtherType\n\nprogram hello\n    ...\n    trait(some_trait), allocatable :: something\n   ...\n    allocate(someType :: something)\n   ...\nend program hello\n\nThe compiler must simply confirm that a type implements the procedures in the trait with the correct interfaces, and any type used where trait(some_trait) is specified must simply be checked to have implemented that trait. The run time implications are basically just an extension of the dynamic capabilities that class(someClass) already offers.\nI think that this would enable techniques and patterns that would otherwise require parameterized types, multiple inheritance, or templates, or all 3, without requiring a hugely significant change to the inner workings of the language or the syntax.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-29 15:36:11+00:00",
                    "text": "Yes!\n\nThis is precisely how we concluded templates should be implemented at the last J3 meeting. I think it's also called strong concepts in C++.\n\nThe advantage of the approach you described is that the compiler can provide good error messages and relatively quick compile times compared to the traditional C++ templates.\n\nSo I think this proposal should be pursued.\n\u2026\nOn Sat, Dec 28, 2019, at 8:58 PM, Brad Richardson wrote:\n Java calls them interfaces, Haskell calls them type classes, and Rust\n calls them traits. But the basic gist is that you can define the\n procedures that a type must have in order to implement a trait. A type\n can then be marked as implementing that trait, and procedures and types\n can specify traits instead of just types or classes.\n\n The additional syntax would be as follows.\n\n A new block structure, similar to interface, that defines a trait. I.e.\n\n `trait some_trait\n     function someFunc(self, other)\n         trait(some_trait), intent(in) :: self\n         integer, intent(in) :: other\n         real :: someFunc\n     end function someFunc\n\n     subroutine someRoutine(input, output)\n         integer, intent(in) :: input\n         integer, intent(out) :: output\n     end subroutine someRoutine\n end trait some_trait\n `\n A new statement only valid in a type definition. I.e.\n\n `type, public :: someType\n     implements some_trait\n contains\n     procedure :: someFunc => someTypeSomeFunc\n     procedure, nopass :: someRoutine => someTypeSomeRoutine\n end type someType\n `\n And a new keyword for variable declarations. I.e. the following would\n all be valid\n\n `subroutine doSomething(some_input)\n     trait(some_trait), intent(in) :: some_input\n     ...\n end subroutine doSomething\n ` `type, public :: someOtherType\n     trait(some_trait), allocatable :: something\n end type someOtherType\n ` `program hello\n     ...\n     trait(some_trait), allocatable :: something\n    ...\n     allocate(someType :: something)\n    ...\n end program hello\n `\n The compiler must simply confirm that a type implements the procedures\n in the trait with the correct interfaces, and any type used where\n `trait(some_trait)` is specified must simply be checked to have\n implemented that trait. The run time implications are basically just an\n extension of the dynamic capabilities that `class(someClass)` already\n offers.\n\n I think that this would enable techniques and patterns that would\n otherwise require parameterized types, multiple inheritance, or\n templates, or all 3, without requiring a hugely significant change to\n the inner workings of the language or the syntax.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#125?email_source=notifications&email_token=AAAFAWHOCMNP5YU57XM3TNLQ3AN47A5CNFSM4KAWLA7KYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IDCJZEQ>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE6RSGUVWH33HLIUSDQ3AN47ANCNFSM4KAWLA7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 03:49:24+00:00",
                    "text": "Actually, I think implements should not be a statement, but an attribute of the type. Similar to extends. I.e.\ntype, public, implements(some_trait) :: someType\ncontains\n    procedure :: someFunc => someTypeSomeFunc\n    procedure, nopass :: someRoutine => someTypeSomeRoutine\nend type someType"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 03:49:36+00:00",
                    "text": "It would also be desirable if more than one trait could be specified. I.e. a type could implement multiple traits, and an argument or variable could be required to implement multiple traits."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-30 04:09:51+00:00",
                    "text": "While I agree that this would be a useful feature, I'd question whether it should be taken as the sole means by which to implement generic programming (as @certik seems to suggest). This issue is that it does not allow generic code to be written for the intrinsic types (e.g., an algorithm which could work with both reals and integers). While this could be overcome by wrapping the intrinsic types, that would be a rather tedious and inelegant workaround.\nFurthermore, how would one declare derived-type components by a trait. Would they be treated in much the same way as polymorphic variables? The downside of this as a way to create generic containers is that it would not allow for compile-type type-checking.\nWhere these traits could be useful, however, would be as a means of constraining type-parameters such as those discussed in #4."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 05:34:06+00:00",
                    "text": "It does allow to write generic code that works for both reals and integers. One specifies a trait (we called it an interface) that requires the arithmetic operations that you need, and if both real and integers satisfy it, then you can use both.\n\u2026\nOn Sun, Dec 29, 2019, at 9:09 PM, Chris MacMackin wrote:\n While I agree that this would be a useful feature, I'd question whether\n it should be taken as the sole means by which to implement generic\n programming (as @certik <https://github.com/certik> seems to suggest).\n This issue is that it does not allow generic code to be written for the\n intrinsic types (e.g., an algorithm which could work with both reals\n and integers). While this could be overcome by wrapping the intrinsic\n types, that would be a rather tedious and inelegant workaround.\n\n Furthermore, how would one declare derived-type components by a trait.\n Would they be treated in much the same way as polymorphic variables?\n The downside of this as a way to create generic containers is that it\n would not allow for compile-type type-checking.\n\n Where these traits could be useful, however, would be as a means of\n constraining type-parameters such as those discussed in #4\n <#4>.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#125?email_source=notifications&email_token=AAAFAWGTGACHZXH57LN52ZTQ3FYA7A5CNFSM4KAWLA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEHZQ53Y#issuecomment-569577199>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHYZDXRR4UY37T6KWLQ3FYA7ANCNFSM4KAWLA7A>."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-30 11:14:54+00:00",
                    "text": "It does allow to write generic code that works for both reals and integers. One specifies a trait (we called it an interface) that requires the arithmetic operations that you need, and if both real and integers satisfy it, then you can use both.\n\nGiven that the proposal required derived types to have an implements statement or attribute for them to match a trait, it's not clear to me that this is the case."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 14:46:01+00:00",
                    "text": "Well, the details have to be figured out, but that should be the goal.\n\u2026\nOn Mon, Dec 30, 2019, at 4:14 AM, Chris MacMackin wrote:\n >\n > It does allow to write generic code that works for both reals and integers. One specifies a trait (we called it an interface) that requires the arithmetic operations that you need, and if both real and integers satisfy it, then you can use both.\n\n Given that the proposal required derived types to have an `implements`\n statement or attribute for them to match a trait, it's not clear to me\n that this is the case.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#125?email_source=notifications&email_token=AAAFAWAUYLMUOWNME5HYO63Q3HJ27A5CNFSM4KAWLA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH2CU5I#issuecomment-569649781>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWCK3YPTQW2QB26VY5DQ3HJ27ANCNFSM4KAWLA7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 15:45:51+00:00",
                    "text": "@cmacmackin , if there are some built-in traits that real, integer, etc. do implement, then you could write generic code that works for both reals and integers. While I agree that traits do not enable every kind of generic programming, I think it does take you farther than any other single feature would.\nAs for derived-type components, yes, they would be treated like polymorphic variables. Correct, you wouldn't get as much compile-time type-checking, but you won't be able to get full compile-time type-checking without a full unification and constraint solver like you would find in Haskell."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 15:47:43+00:00",
                    "text": "@certik Is there any write up of what was decided about this at the J3 meeting?\nI also like the type, public, implements(some_trait) :: someType syntax. Multiple traits would also be key in order to be really useful (e.g., you've got some object you want to use with two different libraries, each of which require some different traits)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 17:38:10+00:00",
                    "text": "What distinguishes a \"trait\" from an ABSTRACT derived type (7.5.2) plus multiple inheritance?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 17:50:16+00:00",
                    "text": "@klausler With inheritance, you also get other components and type bound procedures that you might not want. You could in theory use multiple inheritance like traits, but multiple inheritance involves dealing with a lot more problems."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 17:58:22+00:00",
                    "text": "@klausler With inheritance, you also get other components and type bound procedures that you might not want. You could in theory use multiple inheritance like traits, but multiple inheritance involves dealing with a lot more problems.\n\nWell, thanks for the reply, but I'm still not seeing what a \"trait\" does that an ABSTRACT type can't do."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 18:11:39+00:00",
                    "text": "That's actually kind of the point. It doesn't do everything that abstract types can do. Which makes it easier to implement, and easier to understand how it's supposed to be used.\nSometimes a feature with the right constraints is actually better than a feature that can do everything."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 18:20:23+00:00",
                    "text": "That's actually kind of the point. It doesn't do everything that abstract types can do. Which makes it easier to implement, and easier to understand how it's supposed to be used.\nSometimes a feature with the right constraints is actually better than a feature that can do everything.\n\nThanks for the confirmation."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 18:55:22+00:00",
                    "text": "Also, abstract types can't handle the intrinsic types. If you require a user to extend an abstract type to use a sorting library, then they aren't going to be able to use real, integer, variables. We don't want to have to wrap these into a custom type just to use a library, and then have to add all the operators that are already present for intrinsic types. That's one of the major problems we have now that this would solve if implemented well."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 19:04:06+00:00",
                    "text": "Also, abstract types can't handle the intrinsic types. If you require a user to extend an abstract type to use a sorting library, then they aren't going to be able to use real, integer, variables. We don't want to have to wrap these into a custom type just to use a library, and then have to add all the operators that are already present for intrinsic types. That's one of the major problems we have now that this would solve if implemented well.\n\nBut the intrinsic types could be predefined to have procedures, such as the OPERATOR(<=) needed by a sorting routine, yes?"
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 19:46:05+00:00",
                    "text": "The abstract type approach requires a type A to subclass it in order for the user to use A in the generic subroutine, correct?\n\nThe advantage of the \"interface\" approach as we discussed at J3 meeting (I'll try to write up what we discussed soon) is that user types, such as A above, do not need to subclass anything. Thus the approach works like one would expect from templates.\n\u2026\nOn Mon, Dec 30, 2019, at 12:04 PM, Peter Klausler wrote:\n >\n > Also, abstract types can't handle the intrinsic types. If you require a user to extend an abstract type to use a sorting library, then they aren't going to be able to use `real`, `integer`, variables. We don't want to have to wrap these into a custom type just to use a library, and then have to add all the operators that are already present for intrinsic types. That's one of the major problems we have now that this would solve if implemented well.\n\n But the intrinsic types could be predefined to have procedures, such as\n the `OPERATOR(<=)` needed by a sorting routine, yes?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#125?email_source=notifications&email_token=AAAFAWEQBOXDYZNOXZTQP5DQ3JA2PA5CNFSM4KAWLA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH267UY#issuecomment-569765843>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEMANENJ2VM7EZ5FP3Q3JA2PANCNFSM4KAWLA7A>."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 19:54:35+00:00",
                    "text": "The abstract type approach requires a type A to subclass it in order for the user to use A in the generic subroutine, correct? The advantage of the \"interface\" approach as we discussed at J3 meeting (I'll try to write up what we discussed soon) is that user types, such as A above, do not need to subclass anything. Thus the approach works like one would expect from templates.\n\u2026\nOn Mon, Dec 30, 2019, at 12:04 PM, Peter Klausler wrote: > > Also, abstract types can't handle the intrinsic types. If you require a user to extend an abstract type to use a sorting library, then they aren't going to be able to use real, integer, variables. We don't want to have to wrap these into a custom type just to use a library, and then have to add all the operators that are already present for intrinsic types. That's one of the major problems we have now that this would solve if implemented well. But the intrinsic types could be predefined to have procedures, such as the OPERATOR(<=) needed by a sorting routine, yes? \u2014 You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <#125?email_source=notifications&email_token=AAAFAWEQBOXDYZNOXZTQP5DQ3JA2PA5CNFSM4KAWLA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEH267UY#issuecomment-569765843>, or unsubscribe https://github.com/notifications/unsubscribe-auth/AAAFAWEMANENJ2VM7EZ5FP3Q3JA2PANCNFSM4KAWLA7A.\n\nABSTRACT types today must contain only procedures that are DEFERRED, and those cannot be referenced until they are overridden in an extended type. yes."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 20:15:31+00:00",
                    "text": "Let's discuss the various approaches on a simple example from #46. The syntax is just preliminary (I don't even like it myself, but that's not the point here):\n    <T> function f(x)\n    <T>, intent(in) :: x\n    f = x + 1\n    end function\nThis is just the old fashioned C++ style templates. What we discussed at the J3 meeting is that this causes slow compile times and very long unreadable error messages. The solution to both is to provide some kind of an interface (I just wrote this up, there might be some slight mistakes):\n  type, requirements :: T\n  contains\n    generic :: operator(+) => plus\n  end type\n\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs, rhs\n      type(T) :: plus\n    end function\n  end interface\n\n    type(T) function f(x)\n    type(T), intent(in) :: x\n    f = x + 1\n    end function\nThen when you use this, you can just call it with any type that satisfies the type, requirements :: T above, and you do not subclass it. As an example both of these should just work:\ninteger :: a, b\nb = 1\na = f(b) # a will be equal to 2\nand\nreal :: a, b\nb = 1\na = f(b) # a will be equal to 2\nas well as any user defined type that defines operator(+) with the above signature:\ntype(user_type) :: a, b\nb = ...\na = f(b) # \"a\" will be equal to \"b\" + 1\nThe way this would work is that the compiler would check that user_type or integer or real (from the above three examples) satisfies the type, requirements :: T \"interface\". If it does, then it compiles and works. If it does not, then it emits a nice error message why the user type does not satisfy the interface. Finally, while compiling the generic function \"f(x)\" above (typically in some library), the compiler will check that the body of the function only uses operations are declared in the \"interface requirements\" T. If the function \"f\" uses an operation that was not defined, the compiler will emit an error right away (as opposed to at instantiation time, as in current C++). The compile times will be shorter also, because the compiler only needs to compile \"f\" once (and check that it conforms to the type \"T\"). After that, at instantiation time, the compiler only has to check the user type against the interface \"T\", it does not have to go through the whole subroutine ensuring that everything is used correctly for the given case. This roughly corresponds to \"strong concepts\" from C++ (proposed for C++11, but did not get in).\nThe current C++ has so called \"weak concepts\", where the compiler checks user code at instantiation time against the interface. But it does not check the code of \"f\" against T. So there can still be long error messages.\nSo this is roughly what we discussed at the last J3 meeting. See here for more info: #4 (comment)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 20:22:03+00:00",
                    "text": "This idea defers type resolution to runtime for the function f, rather than instantiating f at compilation time separately for each necessary combination of argument types, correct?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 21:39:37+00:00",
                    "text": "@klausler , you could probably do both. In some instances it would be possible to specialize and inline a generic function, in others it might not be possible, (i.e. you're variable is class(something) and so you still need the vtable lookup at run time), or you might be concerned about bloating the size of your binary.\nBy specifying the trait on both the type definition and the variable declarations, you don't actually have to recheck whether the type satisfies the trait at every use."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 23:57:57+00:00",
                    "text": "@klausler the idea is fully compile time, there is no runtime resolution. To be specific and clear, let's have a module A.f90:\nmodule A\nimplicit none\nprivate\npublic :: T, f\n\n  type, requirements :: T\n  contains\n    generic :: operator(+) => plus\n  end type\n\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs, rhs\n      type(T) :: plus\n    end function\n  end interface\n\ncontains\n\n    type(T) function f(x)\n    type(T), intent(in) :: x\n    f = x + 1\n    end function\n\nend module\nWhen you compile it, the compiler will check that f conforms to the interface T and report any errors. Internally it will store the generic (un-instantiated) version of f in the A.mod file. Then let's have a B.f90 file with:\nprogram B\nuse A, only: f\nimplicit none\ninteger :: a, b\nb = 1\na = f(b) # a will be equal to 2\nend\nWhen compiling B.f90, the compiler will check that the type of b (which is integer) conforms with the interface T in the module A. If it conforms, then we know that f can be instantiated, without checking f again (thus this check is quick). So it will instantiate f at the compile time of B."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-31 00:02:24+00:00",
                    "text": "Thanks for the clarification.\nCan f be defined as a separate module procedure?\n(Additional question) And how is the availability of a conversion from default INTEGER (for 1) to T indicated?"
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 00:17:09+00:00",
                    "text": "Can f be defined as a separate module procedure?\n\nLike this?\nmodule A\nimplicit none\nprivate\npublic :: T\n\n  type, requirements :: T\n  contains\n    generic :: operator(+) => plus\n  end type\n\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs, rhs\n      type(T) :: plus\n    end function\n  end interface\n\nend module A\n\nmodule A2\nuse A, only: T\nimplicit none\nprivate\npublic :: f\n\ncontains\n\n    type(T) function f(x)\n    type(T), intent(in) :: x\n    f = x + 1\n    end function\n\nend module A2\nI think so.\n\n(Additional question) And how is the availability of a conversion from default INTEGER (for 1) to T indicated?\n\nThis is something we discussed at the J3 meeting, and there are several ideas, but I don't think we figured out how to best do this yet. @tclune do you remember about this particular point?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-31 01:28:00+00:00",
                    "text": "@certik wrote:\n\n..\n\n(Additional question) And how is the availability of a conversion from default INTEGER (for 1) to T indicated?\n\nThis is something we discussed at the J3 meeting, and there are several ideas, but I don't think we figured out how to best do this yet. ..\n\nWhy won't this be per the usual language rules?  That, when the processor \"will instantiate f at the compile time of B\" for type REAL say, will it not simply create an instantiated f like so\n   real function instantiated_f(x)\n      real, intent(in) :: x\n      instantiated_f = x + 1\n   end function\nand in which case, the standard stipulations toward the above mixed-mode arithmetic will apply?"
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 01:58:03+00:00",
                    "text": "Why won't this be per the usual language rules? That, when the processor \"will instantiate f at the compile time of B\" for type REAL say, will it not simply create an instantiated f like so\n   real function instantiated_f(x)\n      real, intent(in) :: x\n      instantiated_f = x + 1\n   end function\nand in which case, the standard stipulations toward the above mixed-mode arithmetic will apply?\n\nThis is the natural thing to do. But the problem is that if this approach can cause the code to be in error at instantiation? If so, then this is not going to work, as that would be equivalent to the \"weak concepts\" from C++. Instead, we want the \"strong concepts\", because we want to catch all errors in f at the compile time of the module A, not B. So the T declaration must possibly be extended with the exact operations that are needed, such as implicit conversions.\nThese are the details that we have to iron out."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-31 03:36:13+00:00",
                    "text": "I have an example which would demonstrate why a function may not be able to be fully \"instantiated\" at compile time. It's a bit convoluted though. Have a trait T defined, and an abstract type A that implements T. Then have a type B that extends from A. Now, have a procedure that takes as input something that implements trait T. Declare an allocatable variable of class(A), and pass that as input to the procedure. At this point, you can't actually fully instantiate the procedure with a concrete type, because you don't know which concrete type will actually be used. And especially if that procedure calls another procedure that takes a trait, it definitely won't know at compile time what actual type will be passed. You have to use the same method that class variables use (vtables) to look up the actual procedure at run time.\nmodule traitT\n\n    trait T\n        function traitFunction(input)\n            trait(T), intent(in) :: input\n            integer :: traitFunction\n        end function\n    end trait\nend module traitT\n\nmodule abstractA\n    use traitT, only: T\n\n    type, abstract, implements(T) :: A\n    contains\n        procedure :: traitFunction => ATraitFunction\n    end type A\ncontains\n    function ATraitFunction(input)\n        class(A), intent(in) :: input\n        integer :: ATraitFunction\n\n       ATraitFunction = 1\n    end function ATraitFunction\nend module abstractA\n\nmodule typeB\n    use abstractA, only: A\n\n    type, extends(A) :: B\n    contains\n        procedure :: traitFunction => overideTraitFunction\n    end type B\ncontains\n    function overideTraitFunction(input)\n        class(B), intent(in) :: input\n        integer :: overideTraitFunction\n\n        overideTraitFunction = 2\n    end function overideTraitFunction\nend module typeB\n\nmodule routines\n    use traitT, only: T\ncontains\n    subroutine f(input)\n        trait(T), intent(in) :: input\n\n        call g(input)\n    end subroutine f\n\n    subroutine g(input)\n        trait(T), intent(in) :: input\n\n        print *, input%traitFunction()\n    end subroutine g\nend module routines\n\nprogram orchestrate\n    use traitT, only: T\n    use abstractA, only: A\n    use typeB, only: B\n    use routines, only: f\n\n    class(A), allocatable :: x\n\n    allocate(B :: x)\n    call f(x)\nend program orchestrate\n\nI'm pretty sure the above is perfectly valid except for the trait part, but you could substitute that with another abstract type that A extends from instead and it would actually be valid. This is a contrived example, but you can kind of see my point. You would expect this program to print 2, but if it tried to actually \"instantiate\" at compile time, it'd probably end up printing 1 because it would instantiate the routines as taking type A and end up calling ATraitFunction instead of overideTraitFunction."
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 15:19:39+00:00",
                    "text": "@everythingfunctional seems the only difference between your proposal and what I described above is that in your proposal, user types such as A in your previous comment has to specify which trait it implements (type, abstract, implements(T) :: A). Is that necessary? That would prevent intrinsic types like integer / real to be used, and also it prevents the type A to be used with other traits. What is your opinion on that? Are there any other differences between what you proposed and what I tried to describe above about what we discussed at the last J3 committee meeting? If they are the same, then we can use this issue. If they are different, then I am going to create a separate issue for the J3 proposal. I initially thought they are the same, but after seeing more examples and carefully reading what you wrote, it seems maybe they are not the same. If you could help clarify that, I would really appreciate it.\nRegarding your last comment about runtime instantiation: I think that is no different to using templates in C++ with virtual functions ---- they will resolve to the base class function, known at compile time, not the overloaded function known at runtime. So the above example in C++ would return 1.\nIf you want it to resolve to the \"overloaded\" function (and return 2), you have to use the CRTP pattern where you explicitly type the base class to a subclass at compile time, and then the template resolves to the overloaded function, at compile time.\nI would think the above design (everything at compile time) would make the most sense, as there will be no runtime overhead."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-31 15:41:28+00:00",
                    "text": "Syntactically, I think that is the only difference. But, my proposal would be that you could provide a list of traits that are satisfied there. Also, I would propose you be able to specify a list of traits for procedure arguments and allocatable variables. That way you could say this procedure needs something that is Addable and Showable (i.e. has operator(+) and procedure toString defined).\nRust has some traits that are built in to the language. I would propose some be added to the Fortran standard as well. That way intrinsic types could be used for at least some traits. It would also beneficial if there was some way to add traits, or even type bound procedures, to intrinsic types. I don't know if that's too much to ask, but Rust has it. Or perhaps your idea of not specifying which traits a type implements would be sufficient.\nI was unclear on that behavior of C++. What does Fortran currently do in this situation? I haven't tested it. I like the idea of no runtime overhead, but sometimes you can't get away from it. In my example, of f calling g, would the whole call chain have to be instantiated at call f(x)? Seems like that would add a lot of overhead to compilation times."
                },
                {
                    "user": "certik",
                    "date": "2019-12-31 15:47:53+00:00",
                    "text": "Ok, let's keep just this issue for now to discuss the details, it seems it's quite similar, and we have not moved beyond what I described above either at the J3 committee.\nRegarding your last paragraph, indeed, the whole chain f and g are \"templated\" / \"generic\", and so the whole chain has to be instantiated (at compile time)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-31 16:43:18+00:00",
                    "text": "Can f be defined as a separate module procedure?\n\nLike this?\n\nNo.  Separate module procedures (15.6.2.5) are defined with MODULE PROCEDURE, possibly in a submodule."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-31 16:56:19+00:00",
                    "text": "I was thinking... would it be useful if some traits were optional, and a procedure could query if an input had a certain trait and then do something with that information?\nI was thinking of the automatic differentiation application (see #95). You could write a function that had an optional derivative calculation, but only if you gave it a class where you needed that (if you passed in a real, it wouldn't do that part)."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-01 00:53:30+00:00",
                    "text": "@certik wrote:\n\nFortranFan wrote:\nWhy won't this be per the usual language rules? That, when the processor \"will instantiate f at the compile time of B\" for type REAL say, will it not simply create an instantiated f like so\n\n   real function instantiated_f(x)\n      real, intent(in) :: x\n      instantiated_f = x + 1\n   end function\nand in which case, the standard stipulations toward the above mixed-mode arithmetic will apply?\n\n.. Instead, we want the \"strong concepts\", because we want to catch all errors in f at the compile time of the module A, not B. So the T declaration must possibly be extended with the exact operations that are needed, such as implicit conversions.\n..\n\nWith respect to your comment in #125 (comment)  , I assume you meant to catch errors at compile-time of module A2?\nAssuming yes and keeping in mind the J3 discussion on \"requirements\" was in the context of generics toward a possible Fortran 202Y design, can the \"strong concept\" mean a \"strong\" requirement is enforced on all instructions?\nMeaning, in your generic procedure f that employs the requirements of the abstract interface given with plus, an instruction such as z = x + y where x, y, and z are all type(T) can be permitted because it can be seen by a processor as clearly matching up with the interface in plus?\nWhereas an instruction such as x = x + 1 can be considered a weak match with possible mixed-mode arithmetic and thus be disallowed?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-01 03:23:09+00:00",
                    "text": "With respect to your comment in #125 (comment) , I assume you meant to catch errors at compile-time of module A2?\n\nYes.\nMy understanding of the strong concept is that A2 is fully checked at its compile time, and it will not fail at instantiation.  While weak concept is that user type is still checked against the \"requirement\", but the function f can fail to instantiate if is uses features that are not part of the \"requirement\".  If my understanding is incorrect, let me know."
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 20:35:53+00:00",
                    "text": "@tclune I tried to summarize our latest status on templates from the last J3 meeting in this issue. Would you have time to make some progress on this before our next meeting? It would be nice to have some draft of a proposal, even if very preliminary. If we wait until we meet at the J3 meeting, it will be too late."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-22 18:12:12+00:00",
                    "text": "Yes, this is absolutely essential, and it is incomprehensible why this is still not part of the language!\nI was about to open an Issue for this myself, but I will simply comment here, instead, on what I believe would be the best way to proceed.\nI think that in order to get this feature rapidly into the language it is essential to focus on run-time polymorphism (i.e. OOP) first. One should leave a potential use of some similar feature for compile-time polymorphism (i.e. generics) to some later revision, that will deal with such complications separately.\nA 'trait' as it was called above is, in Fortran speak, nothing but an abstract type, with the important restriction that it is prohibited to contain any fields (i.e. variables) or non-deferred methods, i.e. any implementation code. Like an abstract type it may contain deferred procedures, and like an abstract type it cannot be instantiated.\nI prefer the name 'interface type' instead of 'trait' because the syntax for the aforementioned semantics most compatible with present-day Fortran is something like the following\ntype, abstract, interface :: InterfaceType1\ncontains\n  procedure(proc), deferred :: method1\nend type InterfaceType1\n\nabstract interface\n  subroutine proc()\n  end subroutine proc\nend interface\n\n(notice the nice double occurrence of \"abstract\" and \"interface\" for consistency). So the only new thing required above is the new type-qualifier \"interface\" in the type declaration. Thus the compiler will know that the insertion of anything above the contains statement is forbidden, and that any procedure declared below the contains statement must be deferred.\nTo use the feature one will simply code the following\ntype, implements(InterfaceType1) :: ConcreteType\ncontains\n  procedure :: method1\nend type ConcreteType\n\n\nand provide an implementation of method1. Notice that it is this mechanism (i.e. \"implements\" inheritance) which will allow polymorphism, e.g. if InterfaceType1 is used in another type, like so\ntype :: SomeOtherType\n  class(InterfaceType1), allocatable :: obj\nend type SomeOtherType\n\n\nI think that no completely new syntax should be necessary here. We should still be able to use the \"class\" statement, since InterfaceType1 is nothing but a (special) form of an abstract type, and \"implements\" inheritance is a (special) form of inheritance. But I'd like to hear other views on this.\nIf we need to conform to two InterfaceTypes we would have, e.g., something like the following:\ntype, implements(InterfaceType1,InterfaceType2) :: ConcreteType\ncontains\n  procedure :: method1\n  procedure :: method2\nend type ConcreteType\n\n\nThis could then be combined also with implementation inheritance to, e.g., inherit variables and concrete versions of method1/method2 from some ConcreteBaseType\ntype, extends(ConcreteBaseType), implements(InterfaceType1,InterfaceType2) :: ConcreteType\ncontains\n  procedure :: method1\n  procedure :: method2\nend type ConcreteType\n\n\nSo, one would obtain a two-tiered inheritance capability, one to enable polymorphism, and one to inherit implementations (if one so desires), the same way it works in Java. It is the lack of such a feature which is responsible for most of the \"select type\" downcasting non-sense that we currently have to contend with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-22 19:17:20+00:00",
                    "text": "@difference-scheme thanks for the feedback. We need your help:\n\nit is incomprehensible why this is still not part of the language!\n\nThe reason it's not part of the language already is that nobody has put enough work to get it in. In order to get this done, we need to brainstorm and figure out a way to do this that will work and that we can agree upon, then write proposals for it, then discuss at the Committee and convince everybody, and several times (at several meetings) etc. Would you be interested in helping us with this?\nThe hardest part right now is to collect all the various proposals above, and figure out a proposal that we would all agree upon, and to drive the discussion and try to reach an agreement. To that aim, I think we have to have document where we discuss the pros and cons of all the proposals above, so that we can move the discussion forward. Your particular proposal in your comment seems to be a variation of several of the above proposals. So I think it's time we start to work on just one document and keep improving the various aspects of it."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-22 19:52:52+00:00",
                    "text": "@certik Yes, I am willing to help with this, though I am only just a user and not an expert on languages. In case you've already started to write up some draft for a proposal, feel free to use anything that I've written up in my comment. I could then try to come up with some examples on how typical tasks have to be coded now, vs. how they would be coded with the feature in place, to illustrate the advantages.\nI believe the main point to agree on first is whether we want such a feature to cover only run-time polymorphism for now, or both run-time and compile-time polymorphism. The former would make adoption much quicker and simpler, as there is very little risk involved, given that the same feature already works in other languages (Java, C#, etc.)."
                },
                {
                    "user": "certik",
                    "date": "2020-01-22 21:01:57+00:00",
                    "text": "Thanks. @tclune is leading the effort here, he might have some document already. Otherwise maybe somebody will find time to write it up. I want to write proposals for some other features first, before I get to this.\n\nI believe the main point to agree on first is whether we want such a feature to cover only run-time polymorphism for now, or both run-time and compile-time polymorphism.\n\nThe proposal I had above would be only compile time polymorphism -- although as we discussed above, maybe it's both. Doing only runtime polymorphism with interfaces would be new, but one can \"sort of\" do it already with abstract classes, so there is a workaround. But Fortran currently does not have a compile time template / polymorphism."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-28 16:34:54+00:00",
                    "text": "I finally got around to testing it, and Fortran does do run time look up of functions for polymorphic variables. A procedure which accepts a class(Parent) and calls one of its procedures will call the child types procedure if it is passed as the actual argument. Even if it is passed as an allocatable variable of the parent type. So long as the actual value is of the child type, any calls to it's procedures will be to the child types procedures, even if they are made through a variable of the parent class.\nI.e. given\nmodule Poly_m\n    use iso_varying_string, only: VARYING_STRING, assignment(=)\n\n    implicit none\n    private\n\n    type, public :: Base_t\n    contains\n        private\n        procedure, public, nopass :: greet => baseGreet\n    end type Base_t\n\n    type, public, extends(Base_t) :: Extended_t\n    contains\n        private\n        procedure, public, nopass :: greet => extendedGreet\n    end type Extended_t\n\n    public :: fromGreeter\ncontains\n    pure function baseGreet() result(greeting)\n        type(VARYING_STRING) :: greeting\n\n        greeting = \"Hello\"\n    end function baseGreet\n\n    pure function extendedGreet() result(greeting)\n        type(VARYING_STRING) :: greeting\n\n        greeting = \"Howdy\"\n    end function extendedGreet\n\n    pure function fromGreeter(greeter) result(greeting)\n        class(Base_t), intent(in) :: greeter\n        type(VARYING_STRING) :: greeting\n\n        greeting = greeter%greet()\n    end function fromGreeter\nend module Poly_m\n\nThe following will print \"Howdy\"\nclass(Base_t), allocatable :: greeter\nallocate(Extended_t :: greeter)\ncall put_line(fromGreeter(greeter))\n\nThis is why I think traits should be implemented as run time polymorphism. It doesn't stray far from the already existing concepts and underlying machinery of abstract and extends for inheritance, making it easier to implement, and easier for users to understand."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 16:38:07+00:00",
                    "text": "@everythingfunctional ok, in that case I think this proposal is different to what we discussed at the Committee so far, as my understanding was that we were discussing compile time polymorphism / templates. I will try to create a separate issue for that, and we can use this issue for your original proposal, which is runtime polymorphism with traits."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-28 17:22:21+00:00",
                    "text": "@everythingfunctional, @certik Great! I have started to write up a draft for a proposal along these lines (the preliminary title is: \"Improved run-time polymorphism for Fortran\").\nEDIT: @certik Sorry, I think I misunderstood you. I presume now that you want to move your own (compile-time polymorphism) proposal into another Issue. So where can I put my proposal draft in case you want to contribute to the write-up or give feedback?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 20:19:12+00:00",
                    "text": "@difference-scheme just create a PR with the proposal. Once we have the proposals written and we can see the differences between them, if two of them should be merged, then we can do it. Otherwise we'll have several different proposals and we can then discuss the pros and cons of each approach, which will move the discussion forward."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-11-13 00:09:39+00:00",
                    "text": "FWIW in the example\nmodule A\nimplicit none\nprivate\npublic :: T\n\n  type, requirements :: T\n  contains\n    generic :: operator(+) => plus\n  end type\n\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs, rhs\n      type(T) :: plus\n    end function\n  end interface\n\nend module A\n\nmodule A2\nuse A, only: T\nimplicit none\nprivate\npublic :: f\n\ncontains\n\n    type(T) function f(x)\n    type(T), intent(in) :: x\n    f = x + 1\n    end function\n\nend module A2\nThe interface should be:\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs\n      integer, intent(in) :: rhs\n      type(T) :: plus\n    end function\n  end interface\nThe type probably also needs an assignment interface for the \"strong concepts\" to be enforced, and would benefit from having an example instantiation, so a full example should probably be\nmodule A\nimplicit none\nprivate\npublic :: T\n\n  type, requirements :: T\n  contains\n    generic :: operator(+) => plus\n    generic :: assignment(=) => assign\n  end type\n\n  abstract interface\n    function plus(lhs,rhs)\n      type(T), intent(in) :: lhs\n      integer, intent(in) :: rhs\n      type(T) :: plus\n    end function plus\n  end interface\n\n  abstract interface\n    function assgn(lhs,rhs)\n      type(T), intent(out) :: lhs\n      type(T), intent(in) :: rhs\n    end function assign\n  end interface\n\nend module A\n\nmodule A2\nuse A, only: T\nimplicit none\nprivate\npublic :: f\n\ncontains\n\n    type(T) function f(x)\n    type(T), intent(in) :: x\n    f = x + 1\n    end function\n\nend module A2\n\nprogram example\nuse A2\nimplicit none\nreal :: two\ntwo = f(1.0)\nend program example"
                },
                {
                    "user": "brandongc",
                    "date": "2021-08-25 17:46:56+00:00",
                    "text": "(Let me know if you think should be a different linked issue vs a comment on this one)\nIt would be great if the intrinsics such as matmul and dot_product would also take advantage of this and work with types provided the appropriate operators (*,+,=) and traits (e.g. \"associative\") are defined.\nThis would be particularly useful for working with a broad range of algebraic structures."
                }
            ]
        },
        {
            "number": 124,
            "user": "qolin1",
            "date": "2019-12-23 23:01:22+00:00",
            "title": "Allow PRIVATE and PUBLIC in SUBROUTINE & FUNCTION statements",
            "text": "The need to specify the private or public attribute of a procedure in separate statements is awkward.\nIn a module with lots of public and private procedures, the need to collect this status somewhere near the top (before the CONTAINS statement) is a pain. When looking at the declaration of a procedure, its public/private status ought IMO to be specifiable along with the rest of its definition. Eg:\nRECURSIVE PRIVATE SUBROUTINE Fred(...)\nPUBLIC PURE FUNCTION rose(...)",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-23 23:41:57+00:00",
                    "text": "(Slightly off topic, but since you mentioned it: I actually like to have a single line of public at the top of a module and specify the public API of a module that way --- easy for people to quickly see what the public API is, as opposed to going through the whole module and trying to figure out which symbols are defined as public and which as private.)"
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 09:14:03+00:00",
                    "text": "Yes this can be useful. But, as with most useful things, being forced to do it can also be a pain. I have one large module with over a hundred public methods, plus a couple of dozen private ones. I need to maintain & extend it every few months. Being forced to separate the PUBLICs and PRIVATEs from the routines themselves is far from ideal. I would like everyone to be able to choose the existing way, or this way."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-27 01:36:38+00:00",
                    "text": "@qolin1 wrote:\n\n.. I would like everyone to be able to choose the existing way, or this way.\n\nFirst, I agree with this sentiment wholeheartedly: there are quite a few aspects including the one in the original post where Fortran can do much better to allow syntax that supports multiple coding styles and arrangements.\nSecondly, I'm yet unable to come up with any objection of my own with the basic idea which is the collocation of the accessibility attribute with the procedure interface/implementation itself.\nNote the standard has already set a precedent with other module entities such as derived type declarations, generic interfaces, and module variables:\nmodule foo_m\n   ..\n   private\n   ..\n   type, public :: foo_t\n      ..\n   end type\n   ..\n   type(foo_t), parameter, public :: BAR = foo_t(..)\n   ..\n   generic, public :: Fred => Fred1, Fred2, ..\nThus extending the concept to procedure interfaces or implementations seems to me a natural extension.\nKudos to OP for bringing this up."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 18:10:49+00:00",
                    "text": "...Fortran can do much better to allow syntax that supports multiple coding styles and arrangements.\n\nI actually disagree with this sentiment. Seeing different styles from one code base to another can be bad enough. But allowing even for different syntaxes actually makes this problem even worse. And in this instance I agree @certik , that I like having the public API be explicit at the top of a module, so user's don't really need to scroll down and see the rest of the code."
                }
            ]
        },
        {
            "number": 123,
            "user": "certik",
            "date": "2019-12-23 18:11:11+00:00",
            "title": "Triage proposals into three tiers",
            "text": "@klausler suggested in #122 (comment):\nI suggest that the proposals can be triaged into three tiers: (1) fixes to actual bugs in the language, (2) features that enable new usages that are impossible or impractical today, and (3) conveniences.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-23 18:12:30+00:00",
                    "text": "I think this is a good idea. We can use labels for that. What labels should we use?\n\nbug\nnew feature\nconvenience\n\nThere might be some overlap between \"new feature\" and \"convenience\". I think there could be other categories:\n\nmeta (we already have and use this label)\nworkflow (perhaps #36 could fit)\ncommunity (something that is not directly related to a standard as a work item for the J3 or WG5 committees, but we still want to see happen in the Fortran community; #104, #57 could fit)"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-23 18:19:58+00:00",
                    "text": "I didn't use the term \"new feature\".  Most of these items are new features.  The distinction between tier (2) and tier (3) is that tier (2) items are \"must haves\" that enable capabilities that are not possible today, while tier (3) items are \"nice to haves\"."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:33:16+00:00",
                    "text": "@klausler can you propose names for labels you would like to use? Perhaps bug, must have, nice to have. I don't know."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-23 18:45:07+00:00",
                    "text": "Bug, essential, nonessential."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-24 00:34:33+00:00",
                    "text": "Example: I consider some kind of parametric polymorphism to be essential, not a convenience -- the alternatives are too painful, and it is a scandal that one cannot quickly instantiate a linked list for a new derived type.  But I admit that's a subjective judgement.\nFrom the perspective of this implementer, the distinction seems to be how I would react if a feature showed up on an RFP (tier (1) is \"obviously we have to do that\",tier  (2) is \"I can see why you need that\", and tier (3) is \"let's ask whether this is a deal-killer\").\nI guess that I'm just asking for some kind of prioritization that isn't obviously too far out of whack with reality."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-28 04:44:40+00:00",
                    "text": "@klausler suggested in #122 (comment):\nI suggest that the proposals can be triaged into three tiers: (1) fixes to actual bugs in the language, (2) features that enable new usages that are impossible or impractical today, and (3) conveniences.\n\nWG5 Fortran committee in collaboration with the national bodies (particularly J3) already does all that with a lot of regimen and with extensive focus on prioritization as dictated by their schedule, especially with point (1) re: fixes to bugs in the language standard.\nJ3 and WG5 effectively do their own \"triaging\" with the proposals presented to them and they have a methodology as well as extensive experience in doing so.  Not only I see little value in replicating such \"triaging\" here, I find little of the collaborative skills and organization structure here yet which are needed toward such attempts.\nAny further reclassification of issues posted here and reduction of ideas and suggestions (such as what might be one coder's enabling facility getting needlessly labeled by an implementor as mere \"convenience\") will be a disincentive \"to collaborate on ideas and proposals with the Fortran community.\"\nTowards the \"idea for this repository is to act as a public facing discussion tool to collaborate with the user community to gather proposals for the Fortran language,\" there is already the \"workflow\" of \"negative feedback\" that envisages a closure to a discussion and \"positive feedback\" which promises a \"drafting a formal proposal to be submitted into Documents for the US committee\".\nI suggest continuing with this workflow and refining it as needed e.g., get the OP's who posted issues that received positive feedback to work with those who provided the \"thumbs up\" (as well as anyone else who has the time and inclination to assist) to develop their issues into proposals, so their ideas can be forwarded for consideration by the standard committee.  #67 with proposal in https://github.com/marshallward/fortran_proposals/blob/namelist_delim/proposals/namelist_delimiters/namelist_proposal.rst is a good example to follow."
                }
            ]
        },
        {
            "number": 122,
            "user": "certik",
            "date": "2019-12-23 17:46:15+00:00",
            "title": "Proposals for February 24 - 28, 2020 J3 committee meeting",
            "text": "Here are the submitted documents: https://j3-fortran.org/doc/meeting/221.\nLet's use this issue to help coordinate and prioritize proposals for the next J3 meeting 221 in February 24-28, 2020.\nEverybody, can you please ensure you put thumbs up on issues that you find high priority, and then help us create high quality proposals for this meeting by submitting PRs against this repository. Once a proposal is ready in this repository, I am happy to submit it officially so that it appears at https://j3-fortran.org/doc/meeting/221.\nWhat do you think should be the top 3 to 5 issues that we should concentrate on? Go ahead and comment below with your personal top 3 to 5 issues. Let's see if we can agree on some of those as a community. Then let's ensure we have good proposals for those. Beyond those, if you feel strongly about some feature, go ahead and start drafting a proposal and motivate in there why it is a good feature.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-23 17:53:20+00:00",
                    "text": "Here is the current list of issues sorted by the number of thumbs up, which we can use as an (imperfect) hint of which issues might be popular."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-23 17:59:29+00:00",
                    "text": "I suggest that the proposals can be triaged into three tiers: (1) fixes to actual bugs in the language, (2) features that enable new usages that are impossible or impractical today, and (3) conveniences."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:08:29+00:00",
                    "text": "I'll go first. Here is my list (I will update it and/or re-order if I get convinced based on a discussion):\n\n\n#104\n\n\n#36\n\n\n#86\n\n\n#1\n\n\n#102\n\n\nComments: Number 1. might not need a formal proposal, but it's something I want to informally discuss with every committee member and try to get their support. For me this is the highest priority, and actually something we can achieve as a community today, with today's compilers. This would be a huge quality of life improvement and big productivity boost for any Fortran developer. The number 2. also is more of an issue to get support at the committee for. The numbers 3., 4. and 5. would require proposals.\nI will also try to write proposals for #81, and #40. Especially #40 would be a nice quality of life improvement."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:13:04+00:00",
                    "text": "@klausler great idea, I made this a new issue #123, so that we can discuss the details and make that happen."
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 04:59:22+00:00",
                    "text": "@FortranFan, @milancurcic, @jacobwilliams, @jvdp1, @zjibben, @marshallward, @zbeekman, @everythingfunctional, @qolin1, @rweed, @gronki, @ivan-pi, @aradi, @arjenmarkus, @cmacmackin, @Beliavsky, @pbrady\nThe next J3 meeting is less than 2 months away. We brainstormed a lot of ideas, but now it's time to turn some of the ideas into action and create a few high quality proposals. Please comment here with your top five priorities for this next meeting. Hopefully there will be some overlap, and then let's work on the issues/proposals of common interest.\n(I tried to tag everybody who created issues here, feel free to forward this issue to others.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-03 05:51:29+00:00",
                    "text": "@certik wrote:\n\n..\nThe next J3 meeting is less than 2 months away. We brainstormed a lot of ideas, but now it's time to turn some of the ideas into action and create a few high quality proposals. Please comment here with your top five priorities for this next meeting. Hopefully there will be some overlap, and then let's work on the issues/proposals of common interest.\n..\n\n@certik , thank you very much for your initiative.\nMy concern is the posted agenda for the meeting (https://j3-fortran.org/doc/year/20/agenda221.txt) that appears essentially a carbon copy of the last N number of meetings and which effectively only allocates time (\"officially at least\") for Fortran 202X items.\nBut now, not only is the work-list for Fortran 202X fixed to that set by the Tokyo meeting last summer as noted at this link https://isotc.iso.org/livelink/livelink?func=ll&objId=20646091&objAction=Open, but even the feature specifications also appear locked in place based on discussion and votes at the Tokyo meeting.\nThere seems to be no room to maneuver on any 202X items even e.g., with US-21 on \"typed enums\" vis-a-vis #46 (comment) and #46 (comment) other than to wait for years when the next window of opportunity opens up for any improvements to features implemented in an earlier revision.\nHow do you see any proposal fit into this scheme?  Thanks,"
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 06:02:12+00:00",
                    "text": "@FortranFan thanks for sharing the concerns. As @sblionel mentioned in #98 (comment), the committee will consider every proposal submitted to it. His word is good enough for me. As you know, it will take some time and iterations and several committee reviews for every new proposal / idea that we submit in order to get in. So let's get started. Once we have proposals that have been positively reviewed by the committee, and are rock solid, and backed by the community, then let's convince the committee to put it into the standard sooner than in 10 years (i.e., to fix #36). But we need those proposals first, so let's work on that, and once they are ready or near ready, let's have a discussion at the committee how to fix #36."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-03 12:58:51+00:00",
                    "text": "Here is my list:\n\n#4\n#16\n#36\n#1\n#102\n\nI could also add #22 and #104"
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-01-03 13:24:47+00:00",
                    "text": "My votes:\n\n#4 (or one of the other similar issues)\n#27 (although this was recently rejected by the committee, without good reason in my view)\n#1\n#28\n#119\n\nPersonally I'd like to see #30 taken forward, but not too many people agreed with me that this was important. Obviously #36 would also be very helpful."
                },
                {
                    "user": "rweed",
                    "date": "2020-01-03 14:25:08+00:00",
                    "text": "My list would be:\n#1 - recently encountered a case where this would  be useful\n#4/29 - anything that gets us closer to better generics even if its not what everyone wants\n#61 - my proposal so I have to support it. I think its of immediate use and would be trivial for the developers to implement so it might have a chance of gaining traction with the committee\n#65 - if we can't have intrinsic generics/templates a standardized pre-processor that makes generating different versions of the same code easier is the next best thing\n#70 - a standard assert routine would be very useful as a first step to better error handleing. Also something that looks like it would be straight forward to implement.\n#40/90 - I would at least like some language in the standard that encourages developers to make explicit typeing the default mode and force people who want to stick with implicit typing use a compiler flag (opposite to the current mode in many compilers) to make it the default. Again, I see this as more of a policy problem than a technical one. It just takes a vendor/developer to summon the courage to change the default mode.\nI also support the items currently on the J3 F202y list (ie coroutines etc.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-03 15:41:37+00:00",
                    "text": "#4\n#125\n#27 - Combined with #4 and #125, this would make Fortran's capabilities on par with practically every other language. Even if some techniques or patterns would be cumbersome without some additional work, they would at least be possible.\n#16 - I would use this tomorrow. I've exposed some attributes as public explicitly for performance reasons, and this would make that safer.\n#36 - 5 years is absolutely too long to wait between releases"
                },
                {
                    "user": "klausler",
                    "date": "2020-01-03 17:16:53+00:00",
                    "text": "If we had some form of parameterized modules, plus modules-as-namespaces, we could have something as powerful as subprogram templates but more general and flexible.  E.g., CALL SORTING_MODULE(MY_TYPE)%SORT_LIST(MY_LIST).  I encourage you to seek the most general and powerful features, and to do so in combination.  Also, please don't forget about fixing bugs."
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-03 18:51:40+00:00",
                    "text": "#36 - 3 years, even if only temporarily, will help Fortran catch up to community concerns\n#4 - Templating, or some alternative, is needed to eliminate a lot of boilerplate code around types\n#1 / #87 - More namespace controls would eliminate the \"flat\" namespace\n#104 - As mentioned, perhaps this need not be a proposal, but some recognition of a stdlib would at least allow for a safe deferral of features\n#94 - My \"pet\" issue.  But since it addresses an error that the standard itself acknowledges, it is a good test to see if the committee is serious about resolving simple problems.\n\n#36 and #104 are meta-proposals, which will help future development.   #4 and #1 feel like very fundamental concepts needed for Fortran to evolve to modern expectations.\nI'd also like for #22, #30, #40, #90 to be considered if possible, but not if they will cause friction."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-03 19:41:01+00:00",
                    "text": "Ondrej, thanks for leading this effort. My votes are:\n\n#4 (templates)\n#1 (namespaces)\n#13 (real16)\n#22 (default value for optional)\n#104 (stdlib)"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-04 00:08:19+00:00",
                    "text": "My top picks at the moment are:\n\n#119 overloading ()\n#16 protected attribute\n#1 namespace for modules\n#76 variadic functions\n#95 automatic differentiation\n\nI have included number 5 because I created the issue and I think it has some of the most far reaching consequences with respect to the application of Fortran in the scientific and engineering domains, while the previous issues are mostly just programmer convenience. I also don't want Fortran to stay far behind Julia in this respect."
                },
                {
                    "user": "epagone",
                    "date": "2020-01-04 18:26:47+00:00",
                    "text": "Given my limited programming proficiency, I'm not participating much but I'm following with great interest. FWIW, my preferences are:\n\n#24 string intrinsic type\n#4 templates\n#22 default value for optional dummy args\n#61 deallocate/reallocate option for allocate\n#40 deprecate and remove implicit save\n\n#50 (engineering units of measure) and #95 (automatic differentiation) did not make it in the top-5 but are very close.\nFurthermore, I think #104 (standard library), #36 (release standard every 3 years), #56 (use lower case in the standard), #99 (extension to EXECUTE_COMMAND_LINE) and #106 (pathway to introduce straightforward features) are all non-technical proposals or (apparently) minor technical changes worth pursuing in my opinion."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-04 19:23:29+00:00",
                    "text": "My priorities:\n\n#1 and #87: Namespaces and nested namespaces\n#16: Protected variables in derived types\n#61: Reallocation\n#76: Variadic functions.\n#40: Remove implicit save\n\nI would love to see the generic programming being driven forward. A lot of ideas had been presented here, but I think, it needs more discussions, before any of them can be formulated as a formal proposal. But, if there were any to pick, I would go with the traits as in #125.\nFinally as meta-proposal: #36 (3 years standard release cycle)"
                },
                {
                    "user": "zjibben",
                    "date": "2020-01-04 22:23:28+00:00",
                    "text": "Here are my priorities:\n\n#4 templates\n#36 shorter release cycles\n#104 standard library\n#22 default for optional values\n#1 / #87 namespacing and nesting\n\nI also like #19, #40, and #113, which along with #22 I think make up a set of micro-scale issues which contribute to Fortran clunkiness. I\u2019d also like to see #5 and #16 to help with data safety."
                },
                {
                    "user": "qolin1",
                    "date": "2020-01-05 09:31:44+00:00",
                    "text": "Here are mine:\n\n#22  default for optional values\n#40  implicit save\n#90  implicit typing\n#1 / #87, namespace for modules\n#4 Templating\n\nPlus of course  #124, #121 & #120, because none of them are at all difficult, and because I suggested them."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-07 19:47:47+00:00",
                    "text": "This was a tough one. I thought I might try to group the issues that seem to revolve around the same theme. Ordering rather arbitrary. Here is my list:\n\nTemplates/generic features: #4, #29, #74 for instance, but also #125\nExceptions: #6, #66\nCoroutines and iterators: #60, #116 (and perhaps #53)\nFile system access: #100\nWorking with units: #50\n\nMind you: a large number of the issues may simply be implementable as a library (or libraries), so they contribute to the standard library proposal."
                },
                {
                    "user": "pbrady",
                    "date": "2020-01-07 20:46:24+00:00",
                    "text": "Short circuiting: #19\nEliminating the need for septuply nested loops in 3D cartesian mesh codes: #85."
                },
                {
                    "user": "reinh-bader",
                    "date": "2020-02-14 10:59:57+00:00",
                    "text": "Given recent (personally communicated) comments from one of the https://github.com/fortran-lang/stdlib developers, I've added #144\nAt least, technical feedback on this would be valuable. If positive, I would hand in an official German proposal on the WG5 level."
                },
                {
                    "user": "certik",
                    "date": "2020-02-23 23:58:02+00:00",
                    "text": "Please keep sending Pull Requests (PRs) against this repository with your proposals based on the above priorities. I'll be happy to merge them and upload them to the J3 website. Here is the current list of uploaded proposals that the committee will consider: https://j3-fortran.org/doc/meeting/221\nI will soon start a separate issue to track all those."
                },
                {
                    "user": "certik",
                    "date": "2020-04-02 21:41:33+00:00",
                    "text": "The summary of the February meeting is available at #155."
                }
            ]
        },
        {
            "number": 121,
            "user": "qolin1",
            "date": "2019-12-23 10:33:35+00:00",
            "title": "Allow a submodule to be USEd by another submodule",
            "text": "I have 3 submodules, called\u00a0 AA, BB, and CC, and an ancestor module KK. I also have 2 vanilla modules XX and YY that hold data (no procedures). I would like to restrict access to XX and YY so they can only be used by descendants of KK. At present the only way to do this is to move the code defining that data from XX and YY so it appears in module KK. This works.\nSuppose now that I would like to restrict access to this data within the submodules. Suppose I want AA and BB to have access to the data originally in XX, but disallow CC from such access. This can be achieved, but it requires an additional submodule to be created: let's call it sXX. sXX must be a direct descendant of KK; and AA and BB must be made descendants of sXX. The data that was in XX must appear in sXX. Again, this works.\nSuppose now that I realize that AA should NOT have access to the data originally in module YY, but it must remain available to BB and CC. ...AFAICS, there is no way to arrange the tree of the submodules to achieve this. I can, of course, go back to the original setup, where XX and YY are vanilla modules, but this means they would be \"public\", available to all other code in the program.\nWhat I propose, therefore, is to allow a submodule like sXX to be named on a USE statement in another submodule, providing they both have the same ancestor. AFAIK one cannot specify a submodule name on a USE statement, so relaxing this rule within a submodule set seems appropriate to me. This would allow data to be shared in a flexable way, while keeping it private inside the submodule set.\nI guess there would need to be some rule requiring sXX to contain only data... or maybe not? Would it be useful to restrict access to procedures as well? Not sure of this...",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-23 18:28:25+00:00",
                    "text": "@qolin1 Would the proposal #86, if implemented, allow you to arrange the (sub)modules AA, BB and CC the way you want?"
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-23 23:09:36+00:00",
                    "text": "...Er, I'm not really sure, but I think the answer is no.\nMy understanding of #86 is that it allows additional functionality to be expressed via USE statements, in a situation where USE is already allowed.\nBut this proposal (#121) requests that USE statements be allowed in a situation where they are currently prohibited.\n...Assuming I get the right end of the #86 stick..."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 23:45:49+00:00",
                    "text": "I am not sure I follow your reasoning. The #86 is to allow modules to be nested, and used, so it seems it would cover your use case also. To clarify this, would you mind posting an example code of the modules AA, BB, CC, XX, YY to show exactly what you are trying to achieve, and then let's discuss it."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 10:31:54+00:00",
                    "text": "Nesting is allowed in submodules already, but as I explained originally, it does not fix my case. #86 proposes the nesting of modules, but AFAICS that would not render them private to any other module: all public modules would remain public.\nThe submodule approach allows the data to be shared among submodule routines, while preserving its privacy.\nAttached is example code demonstrating what I would like. Note that it doesn't compile.\ntest_121_desired.f90.txt"
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 10:38:37+00:00",
                    "text": "Closed in error, so repoened."
                },
                {
                    "user": "certik",
                    "date": "2019-12-24 18:59:56+00:00",
                    "text": "Thanks for the code. Here is how you would do this if #86 is implemented:\nmodule kk\n   implicit none\n   use kk%aa, only: aa_sub\n   use kk%bb, only: bb_sub\n   use kk%cc, only: cc_sub\nend module kk\n\n!------------------------------------------------------------------\n\nmodule (kk) sXX\n   implicit none\n   real(8) :: xxa(100) = 99d0\nend module\n\n!------------------------------------------------------------------\n\nmodule (kk) sYY\n   implicit none\n   real(8) :: yya(100) = 88d0\nend module\n\n!------------------------------------------------------------------\n\nmodule (kk) aa\n   contains\n      module subroutine aa_sub\n      use kk%sXX\n      ! this routine should have access to XXA, but not YYA\n      xxa(1) = 66.\n  !!  yya(2) = 77.  ! ... should not be able to access YYA\n      end subroutine\nend module\n\n!------------------------------------------------------------------\n\nmodule (kk) bb\n   contains\n      module subroutine bb_sub\n      use kk%sXX\n      use kk%sYY\n      ! this routine should have access to XXA and YYA\n      xxa(2) = 77.\n      yya(2) = 77.\n      end subroutine\nend module\n\n!------------------------------------------------------------------\n\nmodule (kk) cc\n   contains\n      module subroutine cc_sub \n      use kk%sYY\n      ! this routine should have access to YYA, but not XXA\n !!   xxa(2) = 88. !  ... should not be able to access XXA\n      yya(3) = 88.\n      end subroutine\nend module"
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 21:22:57+00:00",
                    "text": "OK, Looks good ... does this module nesting then achieve everything that submodules currently offer? Is it in fact a superset of submodules,  aka \"submodules done better\" ?"
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 21:27:45+00:00",
                    "text": "Ah, and I forgot to ask: is any other code in the app allowed to USE kk%sYY ? Or is access to it restricted to modules within the KK nest?"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-24 21:27:59+00:00",
                    "text": "OK, Looks good ... does this module nesting then achieve everything that submodules currently offer? Is it in fact a superset of submodules, aka \"submodules done better\" ?\n\nNo, they're quite distinct concepts.  Submodules implement things declared by their ancestors, whose definitions are implicitly USE'd in the submodule.  Nested modules declare things to be used by their containers, which would not be automatically USE'd."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-24 21:42:25+00:00",
                    "text": "OK so the killer feature of submodules is the separation of interface from implementation, and thus breaking the compilation cascade. It appears that nested modules does not allow this. Hence my original request to enhance submodules stands."
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 19:44:58+00:00",
                    "text": "Submodules can have submodules. Would this solve the original problem?"
                },
                {
                    "user": "qolin1",
                    "date": "2020-05-09 22:44:54+00:00",
                    "text": "No. Any given Submodule is only allowed to have exactly one parent (sub) module. The whole point of my proposal is to allow a (sub-)submodule to access entities outside of the direct line of submodule ancestry, while restricting those entities from being public to the rest of the program.\nGreat to make your acquaintance BTW, I love the stuff you have written on nuclear power."
                }
            ]
        },
        {
            "number": 120,
            "user": "qolin1",
            "date": "2019-12-21 14:49:41+00:00",
            "title": "Allow ABSTRACT INTERFACE to define submodule procedure interfaces ",
            "text": "Consider a series of procedures in a number of SUBMODULEs. Each procedure requires its interface to be defined in the ancestor module.\nThe following refers to code in the ancestor module only, It does not refer to any changes in the submodules.\nIf many of these procedures have an identical interface (apart from the procedure name), it would be useful if the interfaces could be defined in a single ABSTRACT INTERFACE, and the resulting named interface used in subsequent PROCEDURE statements.\nI asked in the Intel Fortran Forum if this were possible, but it appears it is not: see https://software.intel.com/en-us/forums/intel-fortran-compiler/topic/842383\nI have attached the example file showing my existing code.\ntest.f90.txt",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2019-12-21 15:36:01+00:00",
                    "text": "This really isn't related to submodules - what you'd like to do is use PROCEDURE(abstract_interface) instead of SUBROUTINE/FUNCTION in an interface block or a procedure definition.  I can think of uses for this without submodules. (Note that in a submodule, you can simply say MODULE PROCEDURE xxx with the interface having been defined in the parent module.)\nGiven that compilers already have to support MODULE PROCEDURE, I don't see this as a difficult thing. The downside is that a reader has to go looking elsewhere for the declarations of the dummy arguments, something I find annoying."
                },
                {
                    "user": "Jellby",
                    "date": "2020-09-25 17:37:39+00:00",
                    "text": "The downside is that a reader has to go looking elsewhere for the declarations of the dummy arguments, something I find annoying.\n\nNot more annoying than having to repeat and modify the same dummy argument declaration tens of times. Without this feature, the developer will use preprocessor include files... which doesn't make it less annoying for the reader."
                }
            ]
        },
        {
            "number": 119,
            "user": "jacobwilliams",
            "date": "2019-12-20 05:39:33+00:00",
            "title": "Overloading ()",
            "text": "I haven't fully thought this through yet, but what if we had the ability to overload () for a derived type in various contexts? That could be used for some interesting things.\nSuch as dictionaries:\ntype(dict) :: d\nd('key') = 1\nd(1995) = 'string'\nor a string class:\ntype(string) :: s\ns = 'hello world'\nwrite(*,*) s(1:5)   ! this writes 'hello'",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "nncarlson",
                    "date": "2019-12-20 15:30:21+00:00",
                    "text": "I'm not so sure about such expressions as the lhs of an assignment (and actually I'm not sure what \"1:5\" would mean as an argument), but I've often wished for this to improve readability/expressiveness.  For example, I currently have stuff similar to this\ntype, abstract :: func\ncontains\n  procedure(eval) , deferred :: eval\nend type\nabstract interface\n  real function eval(this, x)\n    import func\n    real, intent(in) :: x\n  end function\nend interface\nclass(func) :: f\na =  f%eval(0.0)\nIt would be much clearer imo to be able to write f(0.0). This just syntactic sugar I think, so I wouldn't expect it to be difficult to implement."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-20 15:45:23+00:00",
                    "text": "Unless a strong use case is presented, I would personally oppose. Fortran\nis not C++. It already has arrays. If someone wants to build an object\nwrapper around an array, or implement string as a derived type (as opposed\nto intrinsic implementation) I suggest using C++ as a better suited\nlanguage.\n\nDictionaries, strings and arrays should be built into language.\n\npt., 20 gru 2019 o 16:30 Neil Carlson <notifications@github.com> napisa\u0142(a):\n\u2026\n I'm not so sure about such expressions as the lhs of an assignment (and\n actually I'm not sure what \"1:5\" would mean as an argument), but I've often\n wished for this to improve readability/expressiveness. For example, I\n currently have stuff similar to this\n\n type, abstract :: funccontains\n   procedure(eval) , deferred :: eval\n end type\n abstract interface\n   real function eval(this, x)\n     import func\n     real, intent(in) :: x\n   end function\n end interface\n class(func) :: f\n a =  f%eval(0.0)\n\n It would be much clearer imo to be able to write f(0.0). This just\n syntactic sugar I think, so I wouldn't expect it to be difficult to\n implement.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#119?email_source=notifications&email_token=AC4NA3I5DFQSTWWBXYILQK3QZTQI5A5CNFSM4J5X4262YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEHNHFFA#issuecomment-567964308>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3MP2DRZ245AULZYMW3QZTQI5ANCNFSM4J5X426Q>\n ."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-20 15:50:22+00:00",
                    "text": "I think this could be useful, but we would need to separate function calls from indexing. Function calls would be trivial enough to define. Something like the following:\nmodule example\ntype :: callable\ncontains\n    procedure :: called_proc\n    generic :: operator(()) => called_proc\nend type callable\n\ncontains\n\nreal function called_proc(self, arg1, arg2, arg3)\n    class(callable), intent(in) :: self\n    integer, intent(in) :: arg1, arg2\n    real, intent(in) :: arg3\n    called_proc = arg3 ** (arg1 + arg2)\nend function called_proc\n\nend module example\nThe procedure that is called could be any function or subroutine which is valid as a type-bound procedure.\nIndexing could be implemented in a similar manner, but would need some way to distinguish itself. Leaving that issue aside for the moment, we could do the following:\nmodule example2\ntype :: indexed\ncontains\n    procedure :: index_proc\n    generic :: operator(()) => index_proc\nend type indexed\n\ncontains\n\nreal function index_proc(self, arg1, arg2, arg3)\n    class(indexed), intent(in) :: self\n    integer, intent(in) :: arg1, arg2, arg3\n    called_proc = arg3 ** (arg1 + arg2)\nend function index_proc\n\nend module example2\nThe functionn called for indexing would need to accept scalar integer arguments of intent(in) and return a scalar result. The compiler could then handle \"array-slicing\" as though the function were elemental (perhaps require it to be declared as such?) and were passed an array of integers corresponding to the slices.\nThe issue becomes how to distinguish between these two distinct use cases. Some different approaches:\n\nelide this and specify that the compiler will only allow slices as arguments when the bound-procedure meets the requirements set out in the previous paragraph\nintroduce attributes callable and indexable for derived types, indicating how operator(()) should be interpreted\nspecify these attributes at the generic declaration within the derived type\nintroduce some sort of different operator type for each of these cases\n\nPersonally, I think the first of these makes the most sense."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-20 15:55:13+00:00",
                    "text": "Unless a strong use case is presented, I would personally oppose. Fortran is not C++. It already has arrays. If someone wants to build an object wrapper around an array, or implement string as a derived type (as opposed to intrinsic implementation) I suggest using C++ as a better suited language. Dictionaries, strings and arrays should be built into language.\n\nWell, the fact of the matter is that these aren't built in and I can see this operator being accepted more quickly than such a standard template library being approved and implemented.\nA use-case I could potentially see for overloaded indexing would be for handling non-rectangular or periodic grids. Potentially unstructured meshes too, maybe?\nA use case for overloading procedure-calling would be to allow functors and something closer to closures or lambda functions (although I'd also be quite happy to see the latter properly implemented within the language)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-20 17:47:50+00:00",
                    "text": "This is just syntactic sugar for a type-bound function that could return a pointer, yes?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-20 18:54:55+00:00",
                    "text": "@klausler For the LHS case, maybe ... or maybe some additional kind of assignment operator?\n@gronki @cmacmackin Right, we don't have strings, and I'm not that optimistic that we will ever have them. So, give us this, and we can write our own string class in the proposed standard library. No matter how amazing a string class we can write now, it will always be clunky since to use the slice notation, we have to expose the underling character string:\nThis would be amazing:\ntype(string) :: s1, s2, s3\n...\ns3 = s1(1:2) // s(10:20)\nThis is not amazing:\ntype(string) :: s1, s2, s3\n...\ns3 = s1%str(1:2) // s%str(10:20)"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-20 20:42:40+00:00",
                    "text": "@klausler the issue with returning pointers is it requires that whatever is being pointed to is a valid target. Currently derived type components can not have the target attribute, meaning they'd have to be pointers with all the associated hassle of memory management. Hopefully that restriction can be removed (see #28 )."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-12-21 14:34:14+00:00",
                    "text": "I have wished to have this several times. An equivalent feature of Python is the ability to overload the  __call__ method.\nI like the idea of @cmacmackin to have attributes for callable and indexable. A quadratic function could be built then as:\nmodule quadratic_mod\ntype, public :: quadratic\n   real :: a, b, c \ncontains\n    procedure, callable :: eval\n    generic :: operator(()) => eval\nend type \ncontains\nreal function eval(this,x)\nclass(quadratic),intent(in) :: this\nreal,intent(in) :: x\neval = this%a+x*(this%b+x*this%c)\nend function\nend module\n\nprogram main\nuse quadratic_mod\ntype(quadratic) :: f = quadratic(1.0,2.0,3.0) ! 1 + 2*x + 3*x**2\nreal :: y\ny = f(x)\nend program\nWhat I wonder is, whether such a functors could then be passed on to some other routine, e.g. a numerical integration routine with a fixed interface such as:\nabstract interface\n   real function f(x)\n       real, intent(in) :: x\n   end function\nend interface\nfunction integrate(a,b,f)\nreal, intent(in) :: a, b\nprocedure(func) :: f\n...\nend funcion\nwithout having to rely upon an adaptor class/module."
                },
                {
                    "user": "pbrady",
                    "date": "2019-12-23 18:02:37+00:00",
                    "text": "I believe this is the same as #44 (and maybe #45).  I'll close those since there's no discussion there"
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:35:12+00:00",
                    "text": "Thanks @pbrady I thought you already opened some issues for this, but I couldn't find it."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-24 01:03:12+00:00",
                    "text": "@nncarlson It's interesting that I use the same pattern for creating potential energy functions, i.e. a function object (derived from an abstract one) that is given system-specific data + potential routines. An appealing point of this approach (to me) is that each function object has its own data internally.\nOne use case might be to pass such a function object (with an overloaded ()) to generics that can accept both procedures and functors. For example, \"callablle(func) :: f\" instead of \"procedure(func) :: f\"...?\n(But I also feel that this kind of thing could make the learning cost of Fortran higher, so care may be necessary to keep the syntax relatively straightforward...)"
                },
                {
                    "user": "veryreverie",
                    "date": "2021-05-31 08:53:16+00:00",
                    "text": "I think that there are two independent proposals here, which I would separate as:\n\nFunction objects, i.e. types which overload the () operator, probably using operator(()) syntax. Ideally these objects would also be useable in procedure(func) contexts.\nOverloadable array slice syntax. i.e. allowing user-defined procedures to take a:b:c slices as arguments. This could possibly be done by definining an intrinsic type slice with components %first, %last and %stride\n\nI think both proposals would make the language more intuitive, but I think the two should be evaluated separately, on their own merits. If both were implemented, I see no reason to limit the slice syntax to only be useable with the function object syntax."
                }
            ]
        },
        {
            "number": 118,
            "user": "Leonard-Reuter",
            "date": "2019-12-17 15:49:25+00:00",
            "title": "[META] Writing a code style standard like PEP8 for Fortran",
            "text": "Should we have a unified recommended code style standard like PEP8 for Fortran?\nIf there is constent, that this'd be helpful, I can open a repo for it.\nI found the following repo browsing the internet:\nRules in 'Modern Fortran: Style and Usage' (Book)\nhttp://fortranwiki.org/fortran/show/Source+conventions\nhttps://www.fortran90.org/src/best-practices.html\nhttps://github.com/kramer314/fortran-style-guide\nhttps://github.com/compas/grasp/wiki/WIP:-Code-style-conventions",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-12-17 16:30:56+00:00",
                    "text": "This is interesting. Could you elaborate more on this? What is this, who\npublishes it etc? I wonder if that would let off some pressure for\n\"discouraging users from writing bad code\" from the standarization entity.\n\nwt., 17 gru 2019 o 16:49 Libavius <notifications@github.com> napisa\u0142(a):\n\u2026\n Should we have a unified recommended code style standard like PEP8 for\n Fortran?\n The best there is atm are the Rules in 'Modern Fortran: Style and Usage'.\n However, this is not open-source...\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#118?email_source=notifications&email_token=AC4NA3PT54ORTUO24WKA24DQZDYIPA5CNFSM4J35RUQKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IBCZQLQ>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3K5F3W2DQ6HW46VI7DQZDYIPANCNFSM4J35RUQA>\n ."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-17 16:35:30+00:00",
                    "text": "This is interesting. Could you elaborate more on this? What is this, who publishes it etc? I wonder if that would let off some pressure for \"discouraging users from writing bad code\" from the standarization entity. wt., 17 gru 2019 o 16:49 Libavius notifications@github.com napisa\u0142(a):\n\nI just updated the original post with a link to pythons PEP8 and a few Fortran style guides I found in the internet.\nMost Fortran projects have their own style guide (which may be useful, since requirements can differ). However it would be good to have a unified way of writing code and then making exceptions and breaking the rules.\nThis is especially helpful for beginners who then don't have to find rules themselves.\nIn a repo, everybody could discuss/share his*her ideas and contribute to a summary of rules."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 18:38:11+00:00",
                    "text": "I would whole heartedly be in favor of this. In fact, I've put together style guides based on documents from NASA, JPL, Google, and PEP8, ProgrammingStandards.pdf. I've got several open source libraries out there in this style."
                },
                {
                    "user": "nncarlson",
                    "date": "2019-12-28 03:43:02+00:00",
                    "text": "The guidelines in all style guides I've seen, including a couple linked here that I skimmed, fall mostly into two categories. One is \"best practices\", things like always use implicit none that have weighty rationale behind them. For these things I think it is possible to come to a broad community consensus, and believe a best practices guide would be extremely useful.\nThe other category is simple style, things like don't use CamelCase for names. Everyone has some rationale for what they choose, but in the end it really boils down to personal preference. Style guides seem to consist mostly of this stuff. It is important for individual projects, but trying for broad community consensus on these types of things would be a fools errand."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-28 13:49:19+00:00",
                    "text": "Isn't the \"coding style\" discussion more suited to, for example, stdlib rather than a proposal for the standard...? Because they include actual working codes, beginners can learn much from their coding style.\nhttps://github.com/fortran-lang/stdlib/issues"
                }
            ]
        },
        {
            "number": 117,
            "user": "Leonard-Reuter",
            "date": "2019-12-16 14:12:14+00:00",
            "title": "switch off backwards compatibility with compiler arguments",
            "text": "It would be great to be able to switch off backwards compatibility 'features' with compiler arguments:\neg.:\n-implicit=none\n-case_sensitive=true\nto enforce good code for new projects.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2019-12-16 14:27:27+00:00",
                    "text": "Most compilers implement non-standard features like this. This repo is for proposals to the Fortran Standard Committee."
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 20:07:07+00:00",
                    "text": "Most compilers implement non-standard features like this. This repo is for proposals to the Fortran Standard Committee.\n\nI think we allow to discuss issues more broadly here, and I think all these overlap:\n\nThe standard itself\nWhat compilers do\nWhat the community does\n\nThis issue is related to the discussions at #40, #83."
                }
            ]
        },
        {
            "number": 116,
            "user": "Leonard-Reuter",
            "date": "2019-12-16 12:58:27+00:00",
            "title": "foreach loop",
            "text": "Allow for foreach loops:\neg.\ndo element in array\n    write(*,*) element\nend do\ninstead of\ndo i=1, SIZE(array)\n    write(*,*) array(i)\nend do",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-12-16 14:38:23+00:00",
                    "text": "It is not even Fortran???\n\npon., 16 gru 2019, 13:58 u\u017cytkownik Libavius <notifications@github.com>\nnapisa\u0142:\n\u2026\n Allow for foreach loops:\n eg.\n\n for element in array:\n     write(*,*) element\n\n instead of\n\n for i in SIZE(array):\n     write(*,*) array(i)\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#116?email_source=notifications&email_token=AC4NA3LCABQCS7HGQ4E4B33QY53PLA5CNFSM4J3JQTG2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IAXI7SA>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3OFU6MV7ACITOFIL3TQY53PLANCNFSM4J3JQTGQ>\n ."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 14:43:30+00:00",
                    "text": "It is not even Fortran???\n\nI was a bit distracted when I wrote it. However, I edited it after max. 5 mins, which is 2 hours before you commented =/."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-16 15:00:39+00:00",
                    "text": "PSA: edits are not reflected in the email notifications. If someone is only viewing these via email, they never see any edits. :)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 20:04:35+00:00",
                    "text": "That is an interesting idea (probably the final : is not needed in the syntax?). Because Fortran's syntax for iterating over arrays is so simple, I usually like to have an index i, rather than the element itself, because typically (but not always) I want to do more with the matrix than just access the element. Also it generalizes nicely to multidimensional arrays, which the above syntax does not (I think)."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 20:14:19+00:00",
                    "text": "That is an interesting idea (probably the final : is not needed in the syntax?). Because Fortran's syntax for iterating over arrays is so simple, I usually like to have an index i, rather than the element itself, because typically (but not always) I want to do more with the matrix than just access the element. Also it generalizes nicely to multidimensional arrays, which the above syntax does not (I think).\n\nJup, I deleted the :.\nI sometimes prefer the foreach loop, if I have some kind of nested object oriented code: ie:\ntype :: Molecule_t\n    type(Atom_t), allocatable :: atoms(:)\nend type Molecule_t\nAnd later:\nsubroutine Foo(molecules)\n    type(Molecule_t), intent(inout) :: molecules(:)\n    integer :: i, j\n\n    do i=1, SIZE(molecules)\n        do j=1, SIZE(molecules(i)%atoms)\n            call molecules(i)%atoms(j)%Do_something()\n        end do\n    end do\nend subroutine Foo\nWould reduce to (probably the variables molecule and atom are best off as pointers?):\nsubroutine Foo(molecules)\n    type(Molecule_t), intent(inout) :: molecules(:)\n    type(Molecule_t), pointer :: molecule\n    type(Atom_t), pointer :: atom\n\n    do molecule in molecules\n        do atom in molecule%atoms\n            call atom%Do_something()\n        end do\n    end do\nend subroutine Foo"
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 20:18:52+00:00",
                    "text": "@Libavius thanks for the use case."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 20:31:44+00:00",
                    "text": "@Libavius thanks for the use case.\n\nIt could analogoulsy work for multidimensional arrays: (Note that the slicing of an array is determined by the way it is written in the memory.)\nsubroutine Foo(tensor)\n    real(real64), intent(inout) :: tensor(:,:,:)\n    real(real64), pointer :: matrix(:,:), vector(:), scalar\n\n    do matrix in tensor\n        do vector in matrix\n            do scalar in vector\n                call Do_something(scalar)\n            end do\n        end do\n    end do\nend subroutine Foo\nHowever, this is not really advantageous compared to the obvious way to do it."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-17 16:49:22+00:00",
                    "text": "This could also enable some pythonic 'list' (here: array) comprehension:\ntype(Atom_t) :: atoms(n)\ninteger :: charges(n)\n\ncharges = [(atom%Get_charge(), atom in atoms)]\ninstead of:\ninteger :: i\ntype(Atom_t) :: atoms(n)\ninteger :: charges(n)\n\ncharges = [(atoms(i)%Get_charge(), i=1, n)]\nEDIT: it is actually easier, if Get_charge ist elemental:\ntype(Atom_t) :: atoms(n)\ninteger :: charges(n)\n\ncharges = atoms%Get_charge()"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-17 18:39:12+00:00",
                    "text": "Also, how about adding Python iterator like capability to a derived type? That would be very interesting."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-01-06 13:22:26+00:00",
                    "text": "There is the proposal on coroutines and iterators - [https://j3-fortran.org/doc/year/19/19-169.pdf] (see #60). That would definitely cover the kind of loop that is being discussed here."
                }
            ]
        },
        {
            "number": 115,
            "user": "Leonard-Reuter",
            "date": "2019-12-16 12:53:07+00:00",
            "title": "string functions in standard",
            "text": "Add functions like Pythons split to the standard.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 13:54:34+00:00",
                    "text": "sorry, this is a duplication of #96 (which i missed)"
                }
            ]
        },
        {
            "number": 114,
            "user": "Leonard-Reuter",
            "date": "2019-12-16 12:50:35+00:00",
            "title": "Alternative array access with [ ]",
            "text": "Allow for alternative array acess:\nmy_array[3]\n\ninstead of\nmy_array(3)\n\nin order to distinguish between array access and function call.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "cmacmackin",
                    "date": "2019-12-16 13:26:57+00:00",
                    "text": "This would conflict with coarray indexing. Also, frankly, the last thing Fortran needs is more ways to do the same thing. It is already full of those and it makes the source a devil to parse and analyse."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 13:29:05+00:00",
                    "text": "This would conflict with coarray indexing. Also, frankly, the last thing Fortran needs is more ways to do the same thing. It is already full of those and it makes the source a devil to parse and analyse.\n\nI never worked with coarrays, so I did not know this. Thanks for the clarification =)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 20:08:50+00:00",
                    "text": "Yes, the a[3] syntax is already taken, so this would be very hard to do."
                }
            ]
        },
        {
            "number": 113,
            "user": "Leonard-Reuter",
            "date": "2019-12-16 12:49:09+00:00",
            "title": "Augmented assignment (+=)",
            "text": "allow writing\na += b\ninstead of\na = a + b\nand\na *= b\ninstead of\na = a * b\nI think this feature is quite important, since the lack of it misleads programmers towards the use of (too) short variable names:\nI would write like to write this:\nelectrons_number += charge\nBut maybe prefer this\nen = en + charge\nover this abomination of a line =)\nelectrons_number = electrons_number + charge\nThis should not end in a discussion whether to use long variable names or not, let's just agree, that they are better sometimes.\nThis is a second use case\nThis is a third (and fourth) use case",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-16 20:11:39+00:00",
                    "text": "This is a very common request, so we should have an issue for it and document why such ideas were not implemented yet.\nThe last time I have seen this discussed is with this proposal: https://j3-fortran.org/doc/year/19/19-111r1.txt. It actually has reason why it was rejected.\n(The += and *= would also imply to have /=, but that is already taken for .ne.. The 19-111r1 paper thus introduces a new operator that could do the same.)"
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 20:53:05+00:00",
                    "text": "This is a very common request, so we should have an issue for it and document why such ideas were not implemented yet.\nThe last time I have seen this discussed is with this proposal: https://j3-fortran.org/doc/year/19/19-111r1.txt. It actually has reason why it was rejected.\n(The += and *= would also imply to have /=, but that is already taken for .ne.. The 19-111r1 paper thus introduces a new operator that could do the same.)\n\nI think, just doing the two 'positive' operators would already help a lot. '-=' and '/=' are much less needed and can be circumvented like this:\nThe hypothetical code:\na = 1.0_real64\ndo i=1, 10\n    a -= vector(i)\nend do\nCan be written as:\na = 1.0_real64\na *= -1\ndo i=1, 10\n    a += vector(i)\nend do\na *= -1\nAnd analogous for division (maybe in line with the loop statements, to make the purpose clearer?):\na = 1.0_real64\na = 1/a; do i=1, 10\n    a *= vector(i)\nend do; a = 1/a\nWhile this seems messy, it prevents the 'space ship operator' from being valid:\na -=- 1  ! this gives the same as 'a += 1'\nThe main point however should be, that '-=' and '/=' are much less needed. I would really advise against another operator for '/='. That would be quite counter-intuitive.\nPS: since the referred paper was in parts rejected due to a missing use case, I will add one to the original post =)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 21:17:29+00:00",
                    "text": "Good point: the proposal would be to only add += and *=. I would say the += is probably the most common in practice. I grepped one of my codes for i = i + 1 and I use just this particular string 7 times. I use j = j + 1 8 times, k = k + 1 3 times, etc., and that's just a small subset of all usages for +=. So having += would simplify dozens of places in my own code for sure."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-16 22:17:36+00:00",
                    "text": "The important aspect of BCPL's assignment operator(s) is that the left-hand side of the assignment is evaluated only once; e.g., if Fortran were to acquire such a feature, in A(F()) += X, there would only be one call made to F."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 22:28:09+00:00",
                    "text": "The important aspect of BCPL's assignment operator(s) is that the left-hand side of the assignment is evaluated only once; e.g., if Fortran were to acquire such a feature, in A(F()) += X, there would only be one call made to F.\n\nI referenced your point in the original post."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-16 22:35:50+00:00",
                    "text": "Additionally, this feature should specifically state whether the augmented assignment is atomic or reducing or disallowed in some circumstances (shared variable in DO CONCURRENT, &/or coindexed references)."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-17 08:20:26+00:00",
                    "text": "I'd suggest also adding **= to have the 'positive' augmented assignment operators complete."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-17 18:23:12+00:00",
                    "text": "For once I agree with the committee for not adding something. \ud83d\ude03 I think these variants are best left to C-based languages. I don't think they are very \"Fortranic\". Aesthetically I've always thought they were weird, and I don't think we really gain much by having them (except new confusion about /=)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-17 21:08:45+00:00",
                    "text": "@Libavius wrote:\n\n..\nThe hypothetical code:\na = 1.0_real64\ndo i=1, 10\n    a -= vector(i)\nend do\nCan be written as:\na = 1.0_real64\na *= -1\ndo i=1, 10\n    a += vector(i)\nend do\na *= -1\n\nThe above \"hypothetical code\" can be written using current Fortran standard as:\na = 1.0_real64 - sum(vector)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-17 21:25:09+00:00",
                    "text": "In fact you can write it as\na = 1 - sum(vector)\nBut I think @Libavius's point was to show how it can be used. A typical loop where I use i = i + 1 is:\ni = 1\nj = 1\ndo j = 1, size(nl)\n    n = nl(j)\n    zeta = zl(j)\n    l = ll(j)\n    do m = -l, l\n        nlist(i) = n\n        zetalist(i) = zeta\n        llist(i) = l\n        mlist(i) = m\n        i = i + 1\n    end do\nend do\nWhere it is kept as a running index.\nI am leaning towards @jacobwilliams's comment above (#113 (comment)) that i = i + 1 looks great and even though i += 1 is shorter, it is a new syntax, and so it might not be worth it in this case."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-18 12:31:53+00:00",
                    "text": "@FortranFan I know, thanks anyway for the hint.\n@certik that was my point indeed. I also agree, that i = i + 1 looks good, however this is not always the case.\nA more elaborate use case:\ntype Molecule_t\n    type(Atom_t), allocatable :: atoms(:)\ncontains\n    procedure, pass :: Get_electrons_number => Molecule_t_get_electrons_number\nend type Molecule_t\n\ncontains\n\nfunction Molecule_t_get_electrons_number(this) result(electrons_number)\n    class(Molecule_t), intent(in) :: this\n    integer :: electrons_number\n\n    integer :: i\n\n    electrons_number = 0\n\n    if (ALLOCATED(this%atoms) then\n        do i=1, SIZE(this%atoms)\n            electrons_number = electrons_number + this%atoms(i)%get_electrons_number()\n        end do\n    end if\nend subroutine Molecule_t_get_electrons_number\nThe loop would\u2013in my opinion\u2013be easier readable like this:\ndo i=1, SIZE(this%atoms)\n    electrons_number += this%atoms(i)%get_electrons_number()\nend do\n@FortranFan I could write this with the SUM intrinsic (but this would be slower, since an array would need to be allocated):\nelectrons_number = SUM([( this%atoms(i)%get_electrons_number(), i=1, SIZE(this%atoms) )])\nEDIT: (or easier, but still with allocation, if Get_electrons_number is elemental\nelectrons_number = SUM(this%atoms%get_electrons_number() )\nThis is in addition to the possible reduction of function calls that @klausler mentioned.\n@jacobwilliams jup, the confusion with /= ist quite painful and probably the strongest counter-argument..."
                },
                {
                    "user": "certik",
                    "date": "2019-12-18 15:42:21+00:00",
                    "text": "@Libavius for your latest use case, I would recommend to change get_electrons_number() to not be a function, but just a member variable. In fact I would recommend to change Molecule_t to:\ntype Molecule_t\n    real(dp), allocatable :: electrons_number(:)\n    ...\ncontains\n    procedure, pass :: Get_electrons_number => Molecule_t_get_electrons_number\nend type Molecule_t\nAnd then change the loop to just:\nelectrons_number = sum(this%electrons_number)"
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-18 15:52:51+00:00",
                    "text": "@certik\nBut then, if I change my atoms array I always have to be careful and update electrons_number as well.\nThe idea in this case would be, that a molecule has atoms but an atom can also exist without a molecule. To avoid code duplication I don't want the molecule to have a member 'electrons_number' or implement atom-related functions again but rather iterate over its atoms."
                },
                {
                    "user": "certik",
                    "date": "2019-12-18 17:23:36+00:00",
                    "text": "The way I do this in my electronic structure codes is that I do not have an Atom type at all. So if your molecule has only one atom, then the length of all the arrays will be just 1. There is no code duplication and in fact things run much faster."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-18 18:39:05+00:00",
                    "text": "@septcolor\nI've also suggested something like these be included in Fortran (#30 ). I feel they are useful because they allow you to expose derived type components, safe in the knowledge that if you need to refactor the data storage layout you can always add a getter in future. They are thus extermely useful for encapsulation, which @certik's approach breaks."
                },
                {
                    "user": "certik",
                    "date": "2019-12-18 19:10:31+00:00",
                    "text": "@cmacmackin indeed, the approach I suggested is flat and exposed. It's not encapsulated. It has the huge advantage that it works well with current Fortran, and typically optimizes really well and runs fast, and it's actually typically simpler in terms of lines of code (as demonstrated above). The disadvantage is that if you change the underlying representation, you need to rework your whole code. So with my approach, one has to design things well, but one can use the current Fortran language. For the encapsulated approach, Fortran does not have the best tools currently."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-18 21:32:10+00:00",
                    "text": "As for the syntax, what about Espen Myklebusts proposal in #80, using the @ operator representing the LHS of an assignment? So @septcolor s example could be writen as\nmy_data(idat) % its_sub_obj(iobj) % another_sub_obj(isubobj) = @ + 1\n\nIt would not cause any conflicts with current operators, so it could be also used for division (I would find it really strange, if *= were introduced but in place division won't work...). And it had the benefit, that the @ operator (representing the LHS) could appear even more than once on the RHS, as in\narray(i,j)%comp1(k,l)%value1 = abs(@ - sqrt(@))\n\n(example by Espen Myklebust)."
                },
                {
                    "user": "certik",
                    "date": "2019-12-18 21:54:29+00:00",
                    "text": "@aradi is your idea different to the proposal I linked at #113 (comment), which was rejected?"
                },
                {
                    "user": "aradi",
                    "date": "2019-12-18 22:04:48+00:00",
                    "text": "@certik Yes, Espen Myklebusts proposal has in my opinion a considerably lower complexity, as the one you have linked in. The @ operator would always represent the entire LHS, while in your proposal it can also represent a part of it (as in a ( s @ (3*i+1) ) = b(s)). It does not involve naming, so no conflicts with eventual implicit statements must be feared and there is no need to introduce a new (statement level) scope."
                },
                {
                    "user": "certik",
                    "date": "2019-12-18 22:25:12+00:00",
                    "text": "@aradi thanks for the clarification. (For the record the 19-111r1 proposal is not my proposal, I just linked to it.)"
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-27 10:56:20+00:00",
                    "text": "As for the syntax, what about Espen Myklebusts proposal in #80, using the @ operator representing the LHS of an assignment? So @septcolor s example could be writen as\nmy_data(idat) % its_sub_obj(iobj) % another_sub_obj(isubobj) = @ + 1\n\nIt would not cause any conflicts with current operators, so it could be also used for division (I would find it really strange, if *= were introduced but in place division won't work...). And it had the benefit, that the @ operator (representing the LHS) could appear even more than once on the RHS, as in\narray(i,j)%comp1(k,l)%value1 = abs(@ - sqrt(@))\n\n(example by Espen Myklebust).\n\nI think this'd be superb elegant =)\nEDIT: After some time, I'm not so sure anymore. It is also a bit of syntactic overload..."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-27 17:41:26+00:00",
                    "text": "I like the idea of using a symbol in the right-hand side to denote the current value of the left-hand side, but @ is accepted as a legal character in identifiers as an extension in many compilers (as is $ as well).  # would conflict with preprocessing directives if it were used and it appeared at the beginning of a continuation line.  '*' would be very Fortran-like but would lead to ambiguity (X=Y*****Z), as would /.  So that leaves us % and ?, I think."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 18:25:58+00:00",
                    "text": "I think the reasons outlined why augmented assignment probably won't work out are true. But I would be in favor of the \"pronoun\" proposal that @certik mentioned. There are a variety of languages starting to support this kind of feature (most commonly in languages that have a pattern matching feature). One might think of this as basically syntactic sugar for an associate block with only a single line in it.\nFor example:\nv @ x(3*i+1) = v * 42 + b(i)\n\nwould be directly equivalent to:\nassociate(v => x(3*i+1))\n    v = v * 42 + b(i)\nend associate\n\nSo this could basically be treated as syntactic sugar, not really a new functionality."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 22:13:21+00:00",
                    "text": "I think the reasons outlined why augmented assignment probably won't work out are true. But I would be in favor of the \"pronoun\" proposal that @certik mentioned. There are a variety of languages starting to support this kind of feature (most commonly in languages that have a pattern matching feature). One might think of this as basically syntactic sugar for an associate block with only a single line in it.\n\nASSOCIATE() could be extended slightly to accommodate a single statement as well as a block."
                },
                {
                    "user": "opeil",
                    "date": "2020-04-14 19:00:13+00:00",
                    "text": "Perhaps, it is too late to discuss this but somehow I have not seen anyone mentioning another important aspect of the compound/augmented assignment: It allows to perform more efficient in-place operations, such as big_array(:, :, :) += big_array2(:, :, :), without the risk of creating temporaries. This makes it more than just a syntactic sugar.\nAnother similar example is that if we have a type like this\ntype :: BigObject\n   real(dp) :: values(10000, 10000)\nend type\n\ntype(BigObject) :: a, b\n\nand there is a frequent need to do operations like this -- a % values = a % values + b % values, then a naive overloading of operator (+) would result in an extremely inefficient code. It would be great if one has a possibility to overload something like (+=) [with obvious call semantics] to implement heavy in-place operations."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 18:07:13+00:00",
                    "text": "There is a renewed discussion at the J3 mailinglist about this feature.\nI created a prototype implementation in a compiler: https://gitlab.com/lfortran/lfortran/-/merge_requests/1286"
                },
                {
                    "user": "klausler",
                    "date": "2021-08-27 16:29:46+00:00",
                    "text": "ASSOCIATE can't be used to form a mutable association with every variable.  Variables with vector-valued subscripts, and coindexed references, become immutable copies of expressions if they appear as \"right-hand\" sides of selectors in ASSOCIATE & al.  If you want to use ASSOCIATE to get a mutable abbreviation of the variable of an assignment-stmt, it won't always work.\nI prefer the idea of using a symbol in the expr of assignment-stmt to denote (a copy of) the variable, e.g. \"var = @ + expr\".  It would work with any operation (including those spelled like .AND.) and it allows repetition, use of the functions (e.g., var=transpose(@)), and the syntax doesn't look like it implies atomicity.  (If @ can't be used, there's other symbols that would work syntactically.)"
                },
                {
                    "user": "mjklemm",
                    "date": "2021-08-27 17:01:18+00:00",
                    "text": "Ada extends the notion of '@' so that you can do things like this:\n\nc(i,j) = cmplx(real(@) + 1.0d0, aimag(@) * 3.0d0, real64)\n\nThe '@' can stand-in for the entity on LHS as many times as needed and as a sub-expression on the RHS.\n\nSo, this generalizes what you could achieve with operator assignments like +=."
                },
                {
                    "user": "mjklemm",
                    "date": "2021-08-27 17:03:06+00:00",
                    "text": "PS: It's required that the expression that is bound via '@' is evaluated only once, so that it's clear how many times functions and the likes are evaluated then they occur multiple times as part of a '@'."
                },
                {
                    "user": "certik",
                    "date": "2021-08-27 17:06:01+00:00",
                    "text": "Thanks @klausler and @mjklemm for the comments!"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-27 17:19:45+00:00",
                    "text": "I do quite like the idea of a symbol for a shorthand for the lhs. I feel almost certain that using @ for that would conflict somehow with its use as the rank-agnostic subscript feature, but I can't quite put my finger on exactly how. Hopefully we can come up with some other agreeable symbol. $ perhaps? I don't believe it's been used other than in format specifications, but I could be mistaken."
                },
                {
                    "user": "klausler",
                    "date": "2021-09-02 21:56:41+00:00",
                    "text": "Some further thought about the use of a special symbol (say .. here) to represent the entire previous value of the left-hand side of an assignment-stmt is leading me to think that it would be a worthwhile feature to consider.\n\nIt handles the original important use case of +=, as x = .. + y.\nIt works for any operator, including division, concatenation, logicals, and user-defined dyadics, without ambiguity.\nIt allows reversed operations (subtract from, divide into, prepend).\nIt works as well for operations that are not operators, including subscripts (ints(:) = permute(..)), function reference actual arguments, and even designators.\nIt allows for multiple occurrences of the left-hand side variable on the right-hand side.\nIt could/should be defined to work for left-hand side variables that ASSOCIATE can't handle (viz., vector-valued subscripts & coindexed variables).\nIt looks (to me) less likely than += to imply atomicity to the naive reader.\nIt would allow for the use of parentheses to control rounding and perhaps prevent the use of FMA (x = (.. * y) + z)."
                },
                {
                    "user": "certik",
                    "date": "2021-10-21 01:35:49+00:00",
                    "text": "Another discussion of this proposal: https://fortran-lang.discourse.group/t/updating-assignment-operators/2129"
                },
                {
                    "user": "opeil",
                    "date": "2021-10-26 09:28:58+00:00",
                    "text": "First of all, I think that the idea (originally by Espen Myklebusts, I suppose) with a LHS designator instead of dozens new operators is great and offers a syntactically simple and flexible way of enhancing assignments. I could only suggest to use an existing Fortran association syntax to avoid introducing additional symbols. This way, the combined assignment-operation would look like:\n(lhs => container % array(:, :, i)) = lhs + fun(lhs)\n(c => complex_array(i, j)) = cmplx(real(c) + 1.0_real64, aimag(c) * 3, kind=real64)\netc. This is essentially a more \"fortranic\"  development of the idea by @everythingfunctional .\nSuch a construction can be considered as a one-line ASSOCIATE block, but, as @klausler has remarked, the restrictions inherent to the ASSOCIATE statement can be considerably relaxed in the new construction. Typical restrictions of the assignment statement should rather be applied.\nThe advantage of such a syntax is that it does not introduce any new lexer elements and does not seem to create a clash with existing constructions."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-26 20:28:40+00:00",
                    "text": "To me, the precise goal of the augmented assignment, as discussed here, is still unclear. Should it be simple syntactic sugar to abbreviate code (which would be for sure useful), or should it represent new operators, which one can also extend for user defined types (useful when designing efficient OOP-based abstract calculus concepts)?"
                },
                {
                    "user": "certik",
                    "date": "2021-10-26 22:30:20+00:00",
                    "text": "To me just += and *= would be the most useful. The extra operators seem quite complicated to see what is going on."
                },
                {
                    "user": "opeil",
                    "date": "2021-10-28 08:35:47+00:00",
                    "text": "A couple of points (from someone interested in having either += style operators or any kind of shorthand notation for assignments of the form lhs = lhs .op. foo):\n1. All constructs considered here can be considered as syntactic sugar.\n2. That said, they also change the semantics of the operation, sending a clear message to the compiler that  the operation should be done in-place if possible. The usual semantics of Fortran implies that the RHS is first  evaluated and then assigned, which by default requires a temporary storage.\n3. Inasmuch as I myself like to use augmented operators +=, *=, etc. in other languages, there is an obvious issue with /= in Fortran that does not seem to be resolvable in an elegant way (introducing another symbol for division or skipping it entirely cannot be considered as elegant). This leads to a well-motivated opposition from the Committee to such operators, qualifying them as \"non-fortranic\" (Steve Lionel expressed this explicitly on several occasions). Furthermore, introducing new operators is not encouraged because technically Fortran already allows a user to define infinitely many custom operators by means of the dot notation.\n4. If one at all wants to have a more concise notation and more computationally efficient assignment semantics in the standard, one would need to come up with a solution that is aligned with the Fortran style (i.e., sufficiently \"fortranic\") and that does not introduce new entities, if possible."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2021-10-28 14:00:08+00:00",
                    "text": "@opeil @certik\nIn order to resolve the issue with \\= how about adding a dot in between the operator and \"=\":\nThis would give:\n+.=, -.=, *.=, /.=, **.=\nFurthermore it can be applied to any custom operator .op. as .op.= (dropping one dot)\nI don't know, if this is 'fortranic' enough, but it would resolve the issue with /= and the dot would be borrowing the operator dot notation. On the other hand, it would still be very much intelligible for any reader."
                },
                {
                    "user": "klausler",
                    "date": "2021-10-28 16:22:27+00:00",
                    "text": "All constructs considered here can be considered as syntactic sugar.\n\n\nThat is not the case with C's augmented assignment operators, not is it true with the proposals above.\n\n2.. That said, they also change the semantics of the operation, sending a clear message to the compiler that the operation should be done in-place if possible. The usual semantics of Fortran implies that the RHS is first evaluated and then assigned, which by default requires a temporary storage.\n\nThis is also not the case.  Instances where an augmented assignment statement might require use of a temporary would also be in need of a temporary if written without the augmentation.\n\n\nInasmuch as I myself like to use augmented operators +=, *=, etc. in other languages, there is an obvious issue with /= in Fortran that does not seem to be resolvable in an elegant way (introducing another symbol for division or skipping it entirely cannot be considered as elegant). This leads to a well-motivated opposition from the Committee to such operators, qualifying them as \"non-fortranic\" (Steve Lionel expressed this explicitly on several occasions). Furthermore, introducing new operators is not encouraged because technically Fortran already allows a user to define infinitely many custom operators by means of the dot notation.\n\n\nFortran allows new user-defined operators but not new assignment statement symbols.\nThe most general proposal for augmented assignments -- namely, the introduction of a symbol to represent the previous value of the left-hand side of the assignment -- avoids the problems with /=."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-28 20:28:26+00:00",
                    "text": "The most general proposal for augmented assignments -- namely, the introduction of a symbol to represent the previous value of the left-hand side of the assignment -- avoids the problems with /=.\n\nI like a lot the idea of having a placeholder for the lhs, as this would abbreviate long expressions in many cases. But then, it would be still syntactic sugar only, as programmers won't be able to extend it for their own types in order to provide efficient in-place implementations for them. (As one would be able to do by overriding the += operator in C++ or the __iadd__ method in Python...)"
                },
                {
                    "user": "klausler",
                    "date": "2021-10-28 20:51:53+00:00",
                    "text": "The most general proposal for augmented assignments -- namely, the introduction of a symbol to represent the previous value of the left-hand side of the assignment -- avoids the problems with /=.\n\nI like a lot the idea of having a placeholder for the lhs, as this would abbreviate long expressions in many cases. But then, it would be still syntactic sugar only, as programmers won't be able to extend it for their own types in order to provide efficient in-place implementations for them. (As one would be able to do by overriding the += operator in C++ or the __iadd__ method in Python...)\n\nNeither an augmented variant of assignment (+=) nor a symbol that refers to the previous value of the left-hand side of an assignment are just \"syntactic sugar\".  They must have semantic guarantees that the expressions on the left-hand side of the assignment are not evaluated more than once, and this property is not one that can be preserved with simple rewriting transformations.  For example, rewriting A(IFUNC()) += 1 to A(IFUNC()) = A(IFUNC()) + 1 would probably be a bad idea.\nOne of the reasons the alterative approach of using a symbol that designates the previous value of the left-hand side is more natural than augmenting variants of assignment(s) is that you can use your user-defined OPERATOR(+) in place, as it were, without having to also define an ASSIGNMENT(+=), if such a thing were possible.  This might not be what you'd want if your += had semantics that were not the same as your + in the context of assignment (e.g., += is somehow atomic), but for many use cases the \"left-hand side symbol\" approach will save boilerplate."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2021-10-29 08:31:09+00:00",
                    "text": "Maybe there should be an independent issue proposing the LHS symbol? While its usage has some overlaps with augmented assignment, it is really a different thing as it extends way beyond what augmented assignment can do, but is less intuitive to use and read (especially for people who switch from other languages)."
                },
                {
                    "user": "aradi",
                    "date": "2021-10-29 09:20:59+00:00",
                    "text": "@klausler OK, I see your point. But, then, similar to what have been proposed above, an extension of the current associate construct may already be enough to enable it?  Actually, I think,  by introducing the statement form of associate  one could already have it (or do I miss something obvious?)\nassociate(lhs => A(IFUNC())) lhs = lhs + 1\n\nassociate(c => complex_array(i, j)) &\n    & cmplx(real(c) + 1.0_real64, aimag(c) * 3, kind=real64)\n\nIt won't be as compact as other forms proposed, but it would be for sure a very natural extension of the current language.\nActually, augmented assignment operators (+=, *=, etc.) only make sense to me, if\n\nthey were available for most built-in binary arithmetic operators (I would hate the asymmetry, that + and * have augmented assignment equivalents, but - and / not) AND\nthey would define new in-place operators (and not being just kind of automatic combinations of existing ones), so that they can be extended in order to manually/algorithmically optimize in-place arithmetic operators for user defined derived types.\n\nIf any of the two is not given, I'd rather go with the LHS-association. That seems to fit more to the current language and would allow for a much more flexible usage."
                },
                {
                    "user": "klausler",
                    "date": "2021-10-29 16:23:09+00:00",
                    "text": "ASSOCIATE doesn't create a modifiable association for designators containing vector-valued subscripts or coindexes today.  If your left-hand side \"associate\" syntax doesn't support those, it's too limited, and if it does, it shouldn't use the same keyword.  We also don't need an name for the left-hand side; there's can't be another assignment statement in its scope, so a single left-hand side symbol suffices."
                }
            ]
        },
        {
            "number": 112,
            "user": "rweed",
            "date": "2019-12-14 20:01:21+00:00",
            "title": "Fortran versions of some Matlab functions",
            "text": "Recently, I needed to translate some Matlab code to Fortran. To get things to work the same as Matlab I had to create my own versions of the following functions.\n\nunique - find unique values in an array\nmean and standard deviations (mean, std)\nismember\n\nAlthough the code to implement these in Fortran is not complicated for rank 1 and rank 2 arrays it gets complicated for anything greater so it would be nice if there where intrinsic Fortran equivalents\nI'm guessing others might have additional functions they would add to this list. When it comes to intrinsics for manipulating and creating arrays along with some other functions, I would be happy if Fortran became Matlabs older but still faster and smarter brother.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2019-12-14 23:46:33+00:00",
                    "text": "These look like good candidates for https://github.com/fortran-lang/stdlib."
                },
                {
                    "user": "certik",
                    "date": "2019-12-19 16:46:41+00:00",
                    "text": "@rweed can you create issues at the stdlib repo please? These would fit well. See e.g.: fortran-lang/stdlib#16, fortran-lang/stdlib#17, fortran-lang/stdlib#18 for similar ideas."
                }
            ]
        },
        {
            "number": 111,
            "user": "milancurcic",
            "date": "2019-12-14 18:10:12+00:00",
            "title": "Allow higher integer kinds for event count inside event_type",
            "text": "Problem\nCurrently the standard defines the event_type to have an internal event count that is an integer with atomic_int_kind. When you make event post(), the event count is incremented by 1. If you do event wait() on the event, the count is decremented by 1, or until_count if provided. However event wait() is a blocking statement. To do non-blocking polling of events, Fortran 2018 provides the intrinsic subroutine event_query().\nAs far as I can tell, the standard doesn't dictate the size of atomic_int_kind. On my platform (gcc-9.2.0, OpenCoarrays-2.8.0), atomic_int_kind is the same as int32, which has the maximum value of 2147483647. You can see where this is going: If you post events from one or more images, and poll them using event_query(), the event count may go out of range in long-running programs.\nWhat happens if the event count range is exceeded? I don't think the standard specifies.\nExample\nCompile, then run this program on two or more images:\nprogram event_count_limit\n\n  use iso_fortran_env, only: event_type, int64\n  implicit none\n  type(event_type) :: event[*]\n  integer(int64) :: n = 0\n\n  if (this_image() == 1) then\n    do\n      call event_query(event, n)\n      print *, n, '/', huge(n)\n      call execute_command_line('sleep 1')\n    end do\n  else\n    do\n      event post(event[1])\n    end do\n  end if\n\nend program event_count_limit\n(I use int64 for n intentionally to demonstrate that the limit is in the internal count representation)\nYou should get the output like this:\n                   13 /  9223372036854775807\n              5878597 /  9223372036854775807\n             11904877 /  9223372036854775807\n...\n           2120568619 /  9223372036854775807\n           2126577421 /  9223372036854775807\n           2132538217 /  9223372036854775807\n           2138522898 /  9223372036854775807\n           2144551285 /  9223372036854775807\n          -2144391377 /  9223372036854775807\n          -2138394635 /  9223372036854775807\n          -2132374894 /  9223372036854775807\n...\n\nIf I post continuously from 5 images, my event count overflows in ~10 minutes. If the event count were a higher integer kind, e.g. int64, it would overflow in > ~70000 years.\nSolution\nIntroduce higher atomic kinds to iso_fortran_env, e.g. atomic_int64_kind, and:\n\nuse the highest available in event_type; OR\nallow user to set the kind when invoking the event_type constructor, for example:\n\nuse iso_fortran_env, only: atomic_int64_kind, event_type\ntype(event_type) :: notification[*]\nnotification = event_type(count_kind=atomic_int64_kind)\nNote\nThis issue was raised by my technical editor while reviewing my chapter draft on teams, events, and collectives, paraphrasing: \"What happens if the maximum event count is exceeded in long-running programs?\". I didn't think of this until he asked.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": []
        },
        {
            "number": 110,
            "user": "MichaelSiehl",
            "date": "2019-12-12 21:27:37+00:00",
            "title": "Implementing Integer-based Enumerations with an Inheritance Hierarchy ",
            "text": "Implementing Integer-based Enumerations with an Inheritance Hierarchy\nFortran (2018) does allow to implement kind of integer-based enumerations, something like this (code snippets):\nmodule xx\n..\ntype, private :: SyncStatus_EnumDef\n  integer :: Enum_StepWidth ! = 1\n  integer :: WaitingForEventPost ! = 2\n  integer :: DoSynchronizationAbort ! = 3\nend type SyncStatus_EnumDef\n!\ntype (SyncStatus_EnumDef), public, parameter :: Enum_SyncStatus &\n     = SyncStatus_EnumDef (1,2,3)\n..\nend module xx\nWe can easily access the enumeration outside our module xx by USE association.\nFortran (gfortran) does also allow to declare our enum type as a component within an abstract type and to use it with an inheritance hierarchy. \nmodule xx\n..\ntype, abstract, public :: EventScalarSync\n  private\n  ! enumeration type:\n  type (SyncStatus_EnumDef), public :: Enum_SyncStatus &\n     = SyncStatus_EnumDef (1,2,3)\n..\nend type EventScalarSync\nThe advantage of this usage of our enum type is a clean OOP interface and no need for USE association (USE statement) to access the enum type at higher levels of our inheritance hierarchy.\nThis works already very well with today's Fortran 2018. (I did testing with gfortran).\nSuggestion for Improvement\nWithin an (abstract) type we can't declare the enum type component as PARAMETER (constant). (I did my testing with recent gfortran, which issues a compile time error message).\nThus, it is still possible to do silly changes of the values of our enum type component later in our codes and raise unwanted runtime behavior.\nThus, my question: Are there any reason too not allow to declare components as PARAMETER types (constants) with (abstract) types in future Fortran? (Or is this already allowed and I did just overlook it?) \n\nRegards",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-12-12 21:38:00+00:00",
                    "text": "You could use defaulted KIND type parameters instead of components.\nmodule m\ntype, private :: SyncStatusEnumDef(Enum_StepWidth, WaitingForEventPost, DoSynchronizationAbort)\n  integer, kind :: Enum_StepWidth = 1, WaitingForEventPost = 2, DoSynchronizationAbort = 3\nend type\ntype(SyncStatusEnumDef), parameter :: Enum_SyncStatus\n\nand then access the values of the \"enumerators\" via type parameter inquiries e.g. Enum_SyncStatus%WaitingForEventPost."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 22:44:24+00:00",
                    "text": "Note: other enumeration proposals are at #11."
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2019-12-13 20:44:43+00:00",
                    "text": "Thanks for your comments.\n@klausler I did just check your suggestion with my \"production\" code (experimental PGAS programming) but it gives an ICE with recent gfortran (without the PARAMETER statement). Anyway, it would only be a slightly different syntax for the same thing. The problem with the PARAMETER statement remains: compile time error \"parameter statement is not allowed in TYPE definition\". \nMaybe my above second code snippet was somewhat incomplete thus, this may help for better understanding:\nmodule xx\n...\ntype, private :: SyncStatus_EnumDef\n  integer :: Enum_StepWidth ! = 1\n  integer :: WaitingForEventPost ! = 2\n  integer :: DoSynchronizationAbort ! = 3\nend type SyncStatus_EnumDef\n...\ntype, abstract, public :: EventScalarSync\n  private\n  ! enumeration type:\n  type (SyncStatus_EnumDef), public :: Enum_SyncStatus &  ! we can't use PARAMETER here\n     = SyncStatus_EnumDef (1,2,3)\n...\nend type EventScalarSync\n...\nend module xx\nPersonally, I don't need the parameter statement necessarily within a TYPE definition for my programming, and I can't tell if this would break with some other rules of OOP. But in case it does not break with the rules, it could make (experimental) parallel programming more safe (in the future)."
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2019-12-13 21:03:53+00:00",
                    "text": "@certik Thanks for that hint. I was aware that there is a proposal that seeks to implement enumerations as 'true type' but did not see it was already here. I am not against such and don't want to argue against such.\nNevertheless, the language and compilers do already support a sort of integer-based enums (since F9x). The importance of integer-based enums remains for (experimental) PGAS programming because of atomics supporting this data type: integer-based enums can be used with atomics."
                },
                {
                    "user": "certik",
                    "date": "2019-12-13 21:16:54+00:00",
                    "text": "@MichaelSiehl yes, I only posted it so that you and others can easily find it, I didn't mean to suggest that your proposal is not worth it. Thanks for getting involved here and feel free to engage in other discussions here also."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-14 14:09:28+00:00",
                    "text": "..\nSuggestion for Improvement\nWithin an (abstract) type we can't declare the enum type component as PARAMETER (constant). ..\nThus, my question: Are there any reason too not allow to declare components as PARAMETER types (constants) with (abstract) types in future Fortran? (Or is this already allowed and I did just overlook it?)\n..\n\nRe: \"is this already allowed?\" - my read of the current Fortran standard suggests the answer is no.\nSee issue #16 which can satisfy the use case mentioned here to some extent."
                }
            ]
        },
        {
            "number": 109,
            "user": "certik",
            "date": "2019-12-12 16:18:08+00:00",
            "title": "How to communicate off-topic ideas",
            "text": "@FortranFan asked in #108 (comment):\n\nMay I please see some consistent adherence and application of this?\n\nSee also @milancurcic's reply in #108 (comment).\nThe consistent suggestion that I have is to simply look at all members who participate here and react to our posts, and if we see that some are getting discouraged to participate here, then please step back and try to find a way to communicate our ideas without people getting annoyed. I provided some suggestions how to do that, the main one being to simply create a new issue for the off topic idea and just link it. That way the main technical thread does not get derailed. When I say \"we\", I mean everybody including myself.\n@FortranFan, we can discuss this in detail here in this issue. And people who are not interested can ignore it.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-12-12 17:29:34+00:00",
                    "text": "@certik, can this forum please use 'we/us' instead of \"you\" the next time something refers to \"everybody including\" the author?"
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 17:33:25+00:00",
                    "text": "@FortranFan yes, I modified the post. I couldn't figure out how to best formulate it. Thanks for the suggestion, I agree."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-28 02:17:49+00:00",
                    "text": "#92 (comment) is off-topic as far as I'm concerned (I explain briefly in #108 (comment)).  I only see it try to \"derail the discussion\" in that thread or get some \"discouraged to participate here\"."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-28 02:54:05+00:00",
                    "text": "In #92 (comment), @gronki wrote:\n\nThis last proposal looks as if Fortran 77 nightmare was trying to creep back in. In my opinion function attributes are most intuitive before the function name as it is currently.\n\nThe first sentence in this comment can only try to \"derail the discussion\" and get \"some discouraged from participating here\".\nAs to the overall comment, it ignores RESULT and BIND came after FORTRAN 77.  Besides, a phrase such as \"Fortran 77 nightmare was trying to creep back in\" by @gronki is needless hyperbole (#108 (comment)) and is entirely objectionable.\nAlso, that \"last proposal\" mentioned therein was only trying to suggest an alternative which expands on the approach already adopted by standard committee with RESULT, BIND to see if some solution can be arrived at to help OP of that thread with the suggested idea."
                }
            ]
        },
        {
            "number": 108,
            "user": "jacobwilliams",
            "date": "2019-12-10 05:22:30+00:00",
            "title": "Delete Fixed-Form source format",
            "text": "It's long past time. Like implicit typing, fixed-form source is a massive embarrassment to modern Fortran that needs to go.\nProvide a canonical fixed to free conversion script (see also Python's 2to3).",
            "is_open": true,
            "labels": [
                "Clause 6"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-12-10 05:32:47+00:00",
                    "text": "I agree. It might be that compilers will support it for a long time for practical reasons, but the standard should simply say that fixed-form is deprecated and provide a canonical conversion tool that works with any code. That way the community will simply move code over (automatically).\nHowever I would not use Python 2 to 3 as an example, as that script didn't actually work properly, due to the dynamic nature of Python and caused projects to invest insane amount of efforts to do the port. See my blog post with details: https://ondrejcertik.blogspot.com/2013/08/how-to-support-both-python-2-and-3.html. On the other hand, for the fixed-form, I think there might be a way to do this fully automatically and robustly --- but we need to do try this and ensure it works with any code out there, before deprecating fixed-form."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-10 15:33:05+00:00",
                    "text": "@certik wrote:\n\n.. the standard should simply say that fixed-form is deprecated ..\n\nThe standard currently marks fixed-form source as obscolescent.  There is a section in the standard for deleted, but there is no deprecated.  Don't know if any ISO or INCITS considerations come into play here when it comes to these kinds of classification.\nThere appears an extremely strong resistance to mark features as deleted.\nBut the advantages of deletions are obvious: once something is deleted, the standard text (e.g., section 6 in current standard) no longer needs to cover that feature plus a compiler implementation, especially a new one, can decide not to support those deleted features.  This might free up development resources to focus on new features while attracting certain customers (I know of some) who want nothing whatsoever to do with legacy aspects and want their code as well as compiler tool chains to focus exclusively on modern coding practices."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-10 16:08:11+00:00",
                    "text": "Delete it! :)"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-10 18:37:13+00:00",
                    "text": "Production Fortran compilers don't have the luxury to delete features that paying customers are using, standard or not.  Fixed form isn't hard to implement, it's still in use, and it's not going to leave the actual Fortran language, so removing it from the standard document just makes its specification harder to find in the future."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-10 19:03:18+00:00",
                    "text": "@jacobwilliams Proposals like this must have technical arguments. What's the problem with fixed form and what would be the benefits of removing it from the language? What would be the costs?"
                },
                {
                    "user": "gronki",
                    "date": "2019-12-10 19:17:38+00:00",
                    "text": "Well I think stupid line restrictions that make free form not actually free\nare more of a concern.\n\nDominik\n\nwt., 10 gru 2019, 20:03 u\u017cytkownik Milan Curcic <notifications@github.com>\nnapisa\u0142:\n\u2026\n @jacobwilliams <https://github.com/jacobwilliams> Proposals like this\n must have technical arguments. What's the problem with fixed form and what\n would be the benefits of removing it from the language? What would be the\n costs?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#108?email_source=notifications&email_token=AC4NA3OLFLMXH65IZJJ5CDDQX7RXRA5CNFSM4JYYZB4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGQL7KI#issuecomment-564182953>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NPLO7O3CJJEISKNLTQX7RXRANCNFSM4JYYZB4A>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-10 19:48:36+00:00",
                    "text": "@gronki  wrote:\n\nWell I think stupid line restrictions that make free form not actually free are more of a concern. ..\n\nNot sure what the above statement refers to.\nWith respect to Fortran 202X the next standard revision, WG5 has thankfully approved at the Tokyo meeting the following specifications for free-form source:\n3 Specifications\n\nA source line contains at most ten thousand characters.\n\nA source statement contains at most one million characters.\n\nProcessors are required to be able to report too-long lines.\n\nContinuation is unchanged, except that the limit of 255 is removed.\n\nBarring any surprises during any further development of Fortran 202X work-list by J3 or reconsideration during subsequent WG5 meetings which, I think, would be unlikely, Fortran 202X should considerably \"free up\" the source form.\nI believe Fortran 202X development with US01 worklist item on \"Allow much longer statement lines and overall statement length\" is a real quick grab of a low-hanging fruit with a language development that should alleviate any pending concerns with free-form source by actual coders as well as any that might arise with machine-generated code.\nReaders can thus view free-form source as a mostly (if they aren't inclined to accept as fully) solved problem) and focus back on the original post with fixed-form source"
                },
                {
                    "user": "rweed",
                    "date": "2019-12-10 21:00:25+00:00",
                    "text": "Doing the most basic conversions required to transform a fixed source file to a free format one (ie changing comment cards to ! and continuations) is actually fairly trivial. I wrote my own code (in Fortran) to do that 20 years ago. Most current Fortran books suggest a strategy for continuations of placing an ampersand in column 73 on the continued line and ampersands in column 6 for the continuation. Detecting continuations is also trivial (just look for characters in column 6). The hard part of conversion though is dealing with what I call Stupid Programmer Tricks (ala Lettermans Stupid Human Tricks) where folks insisted on inserting white spaces between characters in reserved words etc. My \"favorite\" one was in a very large DoE program where one of the programmers (I think a grad student or a post-doc who didn't know better) thought it was jolly fun to  put spaces between the letters of subroutine and the subroutine name ie\nS U B R O U T I N E   M A T M O D. The real complexity comes when you want to shift things over to column one and then refactor the code to some indentation pattern that suits your programming style. Also if you want to lower case on all or some of the text to get away from the ALL UPPER CASE shouting, you have to deal with detecting and handleing character strings where you might not want the case to change.  Still all of this can be handled by a competent Python/C++/Java (and even Fortran) programmer or any one (on Linux) with sed/awk and bash scripting skills. Going up to the next level and generating a tool to do a complete \"makeover\" that will convert DO loops to block constructs, change GOTOs to If/Then/Else is a much harder task and probably requires using the current compiler front ends and the ASTs etc generated as the first pass. Maybe some tools to do this can be written for LFortran and flang/f18 using LLVM but I know very little about LLVM so I'll let the experts comment on that."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-12-11 04:04:51+00:00",
                    "text": "Don't any of you have those days where you feel like taking an old 1966 dusty deck in fixed-form source format out of the closet and having it compile smoothly with the current Fortran compilers? ;) It is what I do occasionally on weekends (like for example here: https://github.com/ivan-pi/stroud_quad).\nI agree with @milancurcic that we need some technical arguments. I don't see fixed-form as an embarrassment and most people learning Fortran start using free-form directly (or at least I hope so!).\nI can perhaps see a technical argument, that currently compilers assume .f files are in fixed-form, leading to the problem that @sblionel blogged about: https://software.intel.com/en-us/blogs/2013/01/11/doctor-fortran-in-source-form-just-wants-to-be-free. Maybe this discussion should be about standardizing the file extension instead, like @jacobwilliams has written about previously (see here http://degenerateconic.com/fortran-file-extensions/ ).\nIf fixed-form was removed/deprecated then we, modern free-form Fortran people, could again use the .f file ending, instead of defaulting to .f90 (which we use just out of convenience since it directly works on both the Intel and gfortran compiler, without the need for extra compiler flags)."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-11 12:27:02+00:00",
                    "text": "When we use the term \u201cdeprecated\u201d, this is what the standard calls \u201cobsolescent\u201d, marking it as a candidate for deletion. Deleting a feature doesn\u2019t magically free up something for redefinition, and NO compiler is going to remove support for fixed-form even if it gets deleted.\nI would be delighted to find a way out of the mess we got ourselves into in 1991, but easy compatibility with decades-old sources is a major strength of the language, and I would not support anything that hurt that."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-11 19:10:00+00:00",
                    "text": "The reason is not entirely technical (although there are some technical reasons). Sure, for some people it's great that they can still compile their 50 year old code without modifications, but I think in the long run, it's very bad for the future of the language.\nPeople are not choosing Fortran anymore. Young people are not learning it. Most people still equate Fortran with FORTRAN 77. One of the reasons for this is the vast amount of FORTRAN 77 code out there in the wild. Look at all the old FORTRAN 77 code that has been wrapped via SciPy. People see this stuff and think that's what Fortran is (and they know that they want nothing to do with it). It would be better if this old stuff just wasn't compilable anymore. Then people would either just abandon it (which is going to happen anyway at some point), or modernize it.\nBackwards compatibility is great, but at some point it's time to move on. The time has long passed. People complain about the Python 2-3 transition, but in the end everyone is going to just deal with it. Python 3 probably has more users than all of Fortran, and conversion from fixed to free form is not nearly as difficult as converting from Python 2 to 3 (not even close). That's why an official conversion routine would be vital.\nI know the committee doesn't agree, but getting new people onboard should be more important than backward compatibility. I see fixed-form source (along with implicit typing and other atavistic nonsense) as a gangrenous limb that needs to be removed before it kills the patient. :)"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-11 19:26:45+00:00",
                    "text": "The reason is not entirely technical (although there are some technical reasons).\n\nWhat are these technical reasons?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-11 19:39:50+00:00",
                    "text": "It seems like I've seen some discussions here about new features and worrying that some things aren't possible because of some limitation of fixed-form source? Somebody correct me if I'm wrong."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-11 19:53:22+00:00",
                    "text": "Yes I definely remember such arguments too although I can't bring up\nparticular features or links. But it was mostly regarding syntax\nsimplification related topics (along the lines of proposal X can't be done\nbecause fixed form does not see spaces blah blah blah). Maybe someone can\nhelp out here.\n\n\u015br., 11 gru 2019, 20:39 u\u017cytkownik Jacob Williams <notifications@github.com>\nnapisa\u0142:\n\u2026\n It seems like I've seen some discussions here about new features and\n worrying that some things aren't possible because of some limitation of\n fixed-form source?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#108?email_source=notifications&email_token=AC4NA3JKRXH7RU3JUG7KXG3QYE6YNA5CNFSM4JYYZB4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGUKKEI#issuecomment-564700433>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3OOUF7TNZLVRF3WGBDQYE6YNANCNFSM4JYYZB4A>\n ."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-11 19:54:25+00:00",
                    "text": "I'm all for killing old code. If Fortran might die too its a risk worth\ntaking. It is dead anyway and we are just trying to revive it.\n\n\u015br., 11 gru 2019, 20:53 u\u017cytkownik Dominik Gronkiewicz <gronki@gmail.com>\nnapisa\u0142:\n\u2026\n Yes I definely remember such arguments too although I can't bring up\n particular features or links. But it was mostly regarding syntax\n simplification related topics (along the lines of proposal X can't be done\n because fixed form does not see spaces blah blah blah). Maybe someone can\n help out here.\n\n \u015br., 11 gru 2019, 20:39 u\u017cytkownik Jacob Williams <\n ***@***.***> napisa\u0142:\n\n> It seems like I've seen some discussions here about new features and\n> worrying that some things aren't possible because of some limitation of\n> fixed-form source?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#108?email_source=notifications&email_token=AC4NA3JKRXH7RU3JUG7KXG3QYE6YNA5CNFSM4JYYZB4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGUKKEI#issuecomment-564700433>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AC4NA3OOUF7TNZLVRF3WGBDQYE6YNANCNFSM4JYYZB4A>\n> .\n>"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-11 20:14:08+00:00",
                    "text": "@jacobwilliams wrote:\n\nIt seems like I've seen some discussions here about new features and worrying that some things aren't possible because of some limitation of fixed-form source? Somebody correct me if I'm wrong.\n\nGlad this point has finally surfaced and it's OP who has brought it up!  I was waiting for it and I had deliberately kept quiet on this front in my first response upthread since I expected that to  bring out all the usual non-technical counterarguments to pop up as they have.  Which itself is most ironic given the premise of wanting technical arguments for a request to move forward.\nFrom what I see given how the Fortran standard and its bearers understand matters (perhaps using ISO/INCITS considerations, as to whether that is pursued rightly or wrongly is a separate but legitimate debate), one is left with a binary proposition: no deletion of fixed-form source essentially implies continued support of it.  And effectively then, every decision of all new features in the language while fixed-form source continues to be NOT DELETED, particularly at the customer-facing level meaning the syntax which is what the persevering practitioners of Fortran dabble with, is impacted and even held hostage by the peculiarities of that fixed source form.\nConsider the current work by J3 on enumerations and see this paper: https://j3-fortran.org/doc/year/19/19-249.txt:\n\nNow, there were some good suggestions during the last meeting in Las Vegas on the requirements and specifications of this new feature and how to also allow compact declarations of an enumeration type along with its enumerator members e.g., for simple cases, something supported by many popular languages in scientific and technical domains such as Java, etc..\nUnfortunately such suggestions could not be considered and among the reasons for that was the language rules of fixed-form source.\nIt appears highly likely what J3 will develop and what WG5 will approve for Fortran 202X toward enumerations is a most limited Pascal v1980 style facility (e.g., no ability to specify the value of enumerators UNLIKE all the top languages per 2019 IEEE survey) BUT with considerable VERBOSITY to boot - I'll be laughed off my domain if I show the ensuing enumeration facility in Fortran around year 2030 or whenever the compiler support for it finally arrives.\nThe pernicious impact of fixed-form source would have played no small role in this abomination.\n\nI think OP has legitimate merit with the request here."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-11 20:54:42+00:00",
                    "text": "@jacobwilliams wrote:\n\nIt seems like I've seen some discussions here about new features and worrying that some things aren't possible because of some limitation of fixed-form source? Somebody correct me if I'm wrong.\n\nGlad this point has finally surfaced and it's OP who has brought it up! I was waiting for it and I had deliberately kept quiet on this front in my first response upthread since I expected that to bring out all the usual non-technical counterarguments to pop up as they have. Which itself is most ironic given the premise of wanting technical arguments for a request to move forward.\nFrom what I see given how the Fortran standard and its bearers understand matters (perhaps using ISO/INCITS considerations, as to whether that is pursued rightly or wrongly is a separate but legitimate debate), one is left with a binary proposition: no deletion of fixed-form source essentially implies continued support of it. And effectively then, every decision of all new features in the language while fixed-form source continues to be NOT DELETED, particularly at the customer-facing level meaning the syntax which is what the persevering practitioners of Fortran dabble with, is impacted and even held hostage by the peculiarities of that fixed source form.\nConsider the current work by J3 on enumerations and see this paper: https://j3-fortran.org/doc/year/19/19-249.txt:\n\nNow, there were some good suggestions during the last meeting in Las Vegas on the requirements and specifications of this new feature and how to also allow compact declarations of an enumeration type along with its enumerator members e.g., for simple cases, something supported by many popular languages in scientific and technical domains such as Java, etc..\nUnfortunately such suggestions could not be considered and among the reasons for that was the language rules of fixed-form source.\nIt appears highly likely what J3 will develop and what WG5 will approve for Fortran 202X toward enumerations is a most limited Pascal v1980 style facility (e.g., no ability to specify the value of enumerators UNLIKE all the top languages per 2019 IEEE survey) BUT with considerable VERBOSITY to boot - I'll be laughed off my domain if I show the ensuing enumeration facility in Fortran around year 2030 or whenever the compiler support for it finally arrives.\nThe pernicious impact of fixed-form source would have played no small role in this abomination.\n\nI think OP has legitimate merit with the request here.\n\nIf one actually goes and reads the linked paper, one will see that fixed-form is used as a reason for requiring the keyword ENUMERATOR to appear before a list of enumerator names; in the absence of the keyword, a sole enumerator name might be misinterpreted as another keyword statement.  Retaining the keyword seems like a good idea for free-form source too for error recovery reasons, so I don't think that fixed-form is exactly constituting a major barrier to technical progress in this case.\nAnd you need to dramatically reduce the hyperbolic gibbering if you want this Fortran implementer to spend more time perusing this site.  The good ideas are getting buried."
                },
                {
                    "user": "certik",
                    "date": "2019-12-11 21:09:09+00:00",
                    "text": "@FortranFan's main point is valid, that fixed form was used as an argument why something cannot be done in 19/19-249.txt. If fixed form didn't have to be considered, perhaps the ENUMERATOR keyword would still be necessary for other reasons, as @klausler indicated, but perhaps not. However let's discuss that at #11.\n@FortranFan please try hard to stick on topic and just discuss technical arguments in issues, otherwise every issue becomes buried and people stop participating here. If you want to discuss your wider points, just open a new issue and link it. But for already open issues that somebody opened to discuss a particular topic, please try not to derail the discussion."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-11 21:57:34+00:00",
                    "text": "Some real-world data on the cost of supporting fixed-form source in a compiler:\nThe parsing phase of the f18 compiler comprises 21373 lines of C++ code today; this phase recognizes Fortran programs and represents them in a parse tree data structure, which is constructed in memory prior to the following phase of semantic analysis.  Fixed-form source affects only the part of the parsing code that preprocesses and normalizes the source in memory (stripping comments, joining continued lines, &c.) prior to running the recursive descent backtracking parser proper.\nI searched through this code to count the lines that I could delete if fixed form source did not exist, and came up with a total of 250 lines, many of which were comments or just }.  In the parser proper, fixed form affects two lines of source (they suppress a warning about missing white space where free form requires it).  And there's roughly 20 lines of code elsewhere that manages the setting and clearing of the flags that indicate fixed-form source.\nSo that adds up to about 1.3% of the parser, which itself constitutes about 1/3rd of the f18 front-end."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-11 22:13:34+00:00",
                    "text": "I cannot think of any features proposed that were rejected because of fixed-form's existence. (I don't count syntax that was revised for fixed-form compatibility.)  Keep in mind that every compiler implementor I have spoken with on the topic of deleted features has said that they must continue to support deleted features. Deleting features provides no benefits and actually adds complexity for implementations which have to figure out how those features continue to work with the rest of the standard.\nI do not agree that fixed-form source is why (allegedly) young programmers are not learning Fortran. I also disagree with that basic premise. While Fortran is not often taught in the US, in favor of sparkly languages not common in production environments, it is widely taught in Europe and Asia. This isn't the standard's fault.\nMy recommendation would be to \"save your strength\" and advocate for new features that will support the programming paradigms you'd like to use."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-11 22:55:12+00:00",
                    "text": "@certik wrote:\n\n..\n@FortranFan please try hard to stick on topic and just discuss technical arguments in issues, ..\n\nMay I please see some consistent adherence and application of this?  The issue I notice across many threads here and it's one of non-technical counter-arguments to original posts.  A basic fact with Fortran, nearly 3 decades after Fortran 90 revision, is that when it comes to certain legacy aspects such as implicit typing, fixed-form source, etc., the requests and suggestions to move forward as in the original post here and which allow the language to progress more freely are overarching considerations and can scarcely be put forth using any technical points given how the support toward the legacy aspects permeates across the standard, its development, and implementations in many subtle, hidden, and now 41 years after ANSI document on FORTRAN 77 in overwhelmingly harmful ways.\nUnder the circumstances, it's those making counterarguments who should have to strive to be technical, particularly from any of the points listed toward \"creating a positive environment\" under https://github.com/j3-fortran/fortran_proposals/blob/master/CODE_OF_CONDUCT.md.  Otherwise,\nI fail to see anything technical in the arguments posted counter to the original post here: #108 (comment), especially #108 (comment). #108 (comment)\nSo if the matter of some guidelines for counterarguments can be addressed better under CoC of this site and if some consideration can be extended to what I suggest here, it will help."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-11 23:58:32+00:00",
                    "text": "Non-technical arguments are OK, and I don't think they should be dismissed or discouraged (or dictated by the CoC). However, technical arguments go a long way to help a proposal. This isn't a competition in which the strongest technical argument wins and gets adopted in the standard. This is about trying to persuade the rest of the community (and hopefully committee members) that a change is needed. The original post was a one-liner with almost nothing to give, this is why I asked for some technical arguments so we can have a real discussion and weigh the pros and cons.\nWhen each of us propose a change to the language, we need to do the homework and show (or convincingly speculate) that the benefits will outweigh the cost, not the other way around."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-12 01:00:05+00:00",
                    "text": "I fail to see anything technical in the arguments posted counter to the original post here: #108 (comment), especially #108 (comment).\n\nStatements of fact qualify as technical points, whether they're required to be so to constitute counterarguments to non-technical complaints or not.  Specifically, from my comment to which you linked above: fixed-form source is still in use and is easy to support.  The first claim is obviously true, and I've documented why the second claim holds with data."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-12 10:53:38+00:00",
                    "text": "I'd like to note that a language version keyword as discussed in #83 could also allow for giving up compatibility with fixed-form source. Whenever the programmer specifies a language version newer than a given date (e.g. 202Y), the processor could refuse to compile the module, if it is in fixed-form. Nevertheless, people could still compile and develop their legacy codes, they just would not be allowed to use any new constructs (and default behaviors) introduced in Fortran 202Y or later without converting to free-form."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-12 13:58:34+00:00",
                    "text": "The typical way of handling this is a directive that looks like a whole-line comment. You're already familiar with these (!DIR$, !$OMP, etc.), as well as shell scripts. Many compilers already support !DIR$ FREEFORM or similar.\nI don't recall if J3 has ever taken up the idea of directives in Fortran source, rather than preprocessing."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 15:43:08+00:00",
                    "text": "@sblionel when it comes to adding new features to Fortran, do we still need to consider how they will work with fixed-form? Is it acceptable to simply say that for new features, such as #11, we do not need to consider fixed-form? I see lots of positives of that, but I don't know if there is any downside."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-12 15:44:25+00:00",
                    "text": "Yes, we still need to consider fixed-form. It is still part of the language. And despite my entreaties to the contrary, people still write new code in fixed-form."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 15:48:47+00:00",
                    "text": "Yes, we still need to consider fixed-form. It is still part of the language. And despite my entreaties to the contrary, people still write new code in fixed-form.\n\nWhat would be the reasons why people have to write fixed-form? Is it just a lack of a tool that would reliably do the conversion, or is there another reason?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-12 15:51:26+00:00",
                    "text": "\"have to\"? No. But it's what they're used to and that's what they do."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-12 15:57:38+00:00",
                    "text": "That's what I mentioned in some other posts. We all know they do. But they\nshouldn't. How do we force them to stop? I think not having nice features\nwould be a good motivation.\n\nIn Linux world, people are unhappy with changes all the time, but then the\nnew solution is forced upon users and everyone just adjusts. I think\nstandard is not enforcing enough to discourage bad coding such as fixed\nform.\n\nczw., 12 gru 2019, 16:51 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n \"have to\"? No. But it's what they're used to and that's what they do.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#108?email_source=notifications&email_token=AC4NA3IWDKISK7ELR5MJS4LQYJMX7A5CNFSM4JYYZB4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGXDKSY#issuecomment-565065035>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LALQRY42Y2LZSOM4LQYJMX7ANCNFSM4JYYZB4A>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 16:01:21+00:00",
                    "text": "When I discussed this with quite a few people, it seems that a reasonable compromise is to support fixed-form for current codes, but not adding new features to it, e.g., if you want to use enumerators, you would first need to convert your fixed-form to free form. So that we do not need to discuss fixed-form restrictions when designing a new feature."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 16:20:43+00:00",
                    "text": "@FortranFan wrote:\n\nMay I please see some consistent adherence and application of this?\n\nI just created a separate issue #109 to discuss how to communicate, please let's move that discussion there, and only discuss fixed-form here in this issue."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-12 16:47:55+00:00",
                    "text": "@certik wrote:\n\nWhen I discussed this with quite a few people, it seems that a reasonable compromise is to support fixed-form for current codes, but not adding new features to it, e.g., if you want to use enumerators, you would first need to convert your fixed-form to free form. So that we do not need to discuss fixed-form restrictions when designing a new feature.\n\nErgo the proposal in the original post.\nWithin the parameters of the current system toward the Fortran standard, the compromise of \"support fixed-form for current codes, but not adding new features to it\" only appears feasible if fixed-form is marked as DELETED in the official standard.\nDeleting fixed-form from the standard will not preclude any existing or new compiler from supporting fixed-form: one can look at the support of already deleted features in most of the current compilers.  But the further development of the standard is freed up from the confines of fixed-form.\nAs indicated in #108 (comment) with the committee approach of which I've been acutely aware, my worry all along has been even the features toward Fortran 202Y - say GENERICS and perhaps exception handling or one or two others if they get considered - would all need to be compatible in their design with fixed-form source.  My experience remains the need to remain compatible with fixed-form has adversely impacts VERBOSITY in Fortran.\nUnless the compromise indicated by @certik can be pursued with some urgency, there remains the risk of suboptimal designs of new features in Fortran due to support for fixed-form source and that is not at all a healthy and encouraging prospect for developers like @jacobwilliams who are among the few persevering with Fortran."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-12 17:08:48+00:00",
                    "text": "That's what I mentioned in some other posts. We all know they do. But they shouldn't. How do we force them to stop? I think not having nice features would be a good motivation. In Linux world, people are unhappy with changes all the time, but then the new solution is forced upon users and everyone just adjusts. I think standard is not enforcing enough to discourage bad coding such as fixed form.\n\nWhy in the world would anybody want to force fixed-form users to stop using fixed-form?"
                },
                {
                    "user": "gronki",
                    "date": "2019-12-12 17:18:48+00:00",
                    "text": "For the reasons clearly listed above that I am not going to repeat. :)\n\nczw., 12 gru 2019 o 18:08 Peter Klausler <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n That's what I mentioned in some other posts. We all know they do. But they\n shouldn't. How do we force them to stop? I think not having nice features\n would be a good motivation. In Linux world, people are unhappy with changes\n all the time, but then the new solution is forced upon users and everyone\n just adjusts. I think standard is not enforcing enough to discourage bad\n coding such as fixed form.\n\n Why in the world would anybody want to *force* fixed-form users to stop\n using fixed-form?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#108?email_source=notifications&email_token=AC4NA3LXI562YJXSIZ4QZPLQYJV2DA5CNFSM4JYYZB4KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGXLG7Q#issuecomment-565097342>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3JJWJQOQO4WPKUMDODQYJV2DANCNFSM4JYYZB4A>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-12 17:34:50+00:00",
                    "text": "For the reasons clearly listed above that I am not going to repeat. :)\n\nThe only serious point that was raised was that fixed-form makes it harder to add a feature to the language that would change parsing of keyword statements like END to be context-dependent.  Such bad ideas should be hard to add to the language, so that's a reason to retain fixed-form."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 17:46:15+00:00",
                    "text": "@klausler let's discuss the actual argument in #11 more with regards to fixed-form. One proposed syntax is:\nenum some_type\n    enumerator a, b, c, d, end, e, endenum, f\nend enum\nand the reason why we cannot just have\nenum some_type\n    a, b, c, d, end, e, endenum, f\nend enum\nis that end and endenum can be confused with end enum when parsing (especially if the optional space is omitted). I think that's probably true, but I think the modern standard could be modified to require end if, end function, end enum to be always written with a space in between. And in that case, I don't know if there is still an ambiguity in free-form (more ambiguity than there already is with regards to end -- it is already context dependent)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-12 17:55:14+00:00",
                    "text": "ENUM SOME_TYPE\n  CONTINUE\n  STOP\n  END\n  CONTAINS\n  PRIVATE\n  SAVE\nEND ENUM\n\nStatement classification is already difficult and bug-prone in Fortran.  This feature makes it worse -- a bare END statement may no longer be an END statement, &c."
                },
                {
                    "user": "certik",
                    "date": "2019-12-12 17:58:55+00:00",
                    "text": "@klausler I think you are right. This is the main argument, and that has nothing to do with fixed-form.\nI propose that fixed-form arguments should not even enter the discussion, and should not be mentioned in the proposal for #11. Rather, the argument that you just made about the end ambiguity is the main argument."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-28 02:08:50+00:00",
                    "text": "@certik wrote:\n\n@FortranFan's main point is valid, that fixed form was used as an argument why something cannot be done in 19/19-249.txt. If fixed form didn't have to be considered, perhaps the ENUMERATOR keyword would still be necessary for other reasons, as @klausler indicated, but perhaps not. However let's discuss that at #11.\n@FortranFan please try hard to stick on topic and just discuss technical arguments in issues, otherwise every issue becomes buried and people stop participating here. If you want to discuss your wider points, just open a new issue and link it. But for already open issues that somebody opened to discuss a particular topic, please try not to derail the discussion.\n\nIn #92 (comment), @klausler wrote:\n\nAttributes before the FUNCTION and SUBROUTINE keyword are how things are done today, like it or not. It was a bad design and it restricted at least one syntactic possibility (one can write CHARACTER*7 or CHARACTER(LEN=NAMEDCONSTANT) but not CHARACTER*NAMEDCONSTANT, and that's due at least in part to the ambiguity that would introduce in CHARACTER*IMPUREFUNCTIONFOO()). But that ship has sailed; adding a redundant ATTRIBUTES(...) syntax would not enable any new capability.\n\nCHARACTER*NAMEDCONSTANT does not conform to the standard but CHARACTER(NAMEDCONSTANT) does.\nAnd a function declaration such as CHARACTER(NAMEDCONSTANT)IMPUREELEMENTALFUNCTIONFOO() is standard-conforming in fixed-form source (assuming other requirements are satisfied) but obviously not in free-form source.  Regardless I find it irrelevant to the discussion in #92 on FUNCTION or SUBROUTINE declarations.\nPer section B.3.7 in 18-007r1 document toward Fortran 2018, fixed-form is obsolescent.\nBringing up a fixed-form code snippet to influence direction in any manner in a discussion to a new proposal (whatever \"tier\" it may be in, a convenience to a few mere mortal but persevering Fortranners or otherwise) which then also presents a risk to \"derail the discussion\" is exactly what I was trying to warn in my above #108 (comment).  It happens often enough, it's really harmful in that it too stops people from \"participating\" in Fortran.  OP's proposal in this thread to \"Delete fixed-form source format\" remains a good suggestion for Fortran."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-29 16:19:06+00:00",
                    "text": "The existence of fixed form can affect syntax chosen, but it has never, to my knowledge, actually blocked a feature from being developed. (19-249 is not an example of such.)\nI'll also mention: \"The program unit END statement shall not be continued. A statement whose initial line appears to be a program unit END statement shall not be continued.\" (6.3.3.5)\nFixed form isn't why the ENUMERATOR keyword exists, as @klausler points out. Fortran doesn't have reserved words and isn't going to start adding them.\nI would be cautiously agreeable to the notion that new features be available in free-form only, where it made sense to do so. As I've mentioned before, there's a significant cost to deleting features from the language."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 21:57:13+00:00",
                    "text": "I would think the easiest way to ensure that new features only apply to free-form is to just delete fixed-form from the standard. Then you never have to worry about it again (let the vendors who want to worry about maintaining it for people who need to run unmodified 50 year old code...but the standard would be free to move forward unencumbered)."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 22:52:43+00:00",
                    "text": "I would think the easiest way to ensure that new features only apply to free-form is to just delete fixed-form from the standard. Then you never have to worry about it again (let the vendors who want to worry about maintaining it for people who need to run unmodified 50 year old code...but the standard would be free to move forward unencumbered).\n\nSuppose for the sake of discussion that fixed source form were to be removed from the standard.  Which Fortran compilers do you think would remove support for fixed source form?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-31 04:04:58+00:00",
                    "text": "I would think the easiest way to ensure that new features only apply to free-form is to just delete fixed-form from the standard. Then you never have to worry about it again (let the vendors who want to worry about maintaining it for people who need to run unmodified 50 year old code...but the standard would be free to move forward unencumbered).\n\nSuppose for the sake of discussion that fixed source form were to be removed from the standard. Which Fortran compilers do you think would remove support for fixed source form?\n\nMy guess is the same number that have removed support for non-standards extensions (effectively zero?). But a guy can hope."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-02 22:27:19+00:00",
                    "text": "@sblionel wrote:\n\n.. there's a significant cost to deleting features from the language.\n\nI request any argument in terms of \"cost\" be treated as firmly off-topic in this repository.\nNo reliable and accurate data are available on any matter related to costs in Fortran.  No honest or trustworthy discussion is then possible.\nMoreover, any discussion regarding \"cost\" is meaningless without a full and fair consideration of the benefits.\nWhen it comes to benefits though, I find the feedback on the value proposition and the benefit statements offered by many a persevering, \"mere mortal\" Fortranner either gets ignored or is rejected outright.\nUnder the circumstances, no \"good faith\" discussion can take place once cost and only cost makes it way into the discussion.\nYet if the cost argument is allowed to persist, then a honest position will be to note:\n\n\nfeatures delayed are features denied, period.  The resultant \"opportunity costs\" to Fortran and its well-being are then immeasurably high.  Entire code-bases move permanently away from Fortran as a result\n\n\nfeatures HALF-BAKED (e.g., several aspects introduced in Fortran 2003) are features ignored or misused.  The resultant \"opportunity costs\" to Fortran and its well-being are again immeasurably high.\n\n\nfeatures too VERBOSE are features abhorred by a large section of the computing community.  The costs to Fortran's well-being again are immense.\n\n\nWith Fortran, all 3 of these points - delays, half-baked aspects, and verbosity - have been impacted to some extent or other by vendors' notions of backward compatibility, the continuing support of fixed-form source very much falls under this.\nThere is considerable evidence an inherently dishonest and unequal treatment of backward compatibility remains in Fortran, one just has to look at Annex B of the Fortran standard.\nThe aspect of the obsolescent-since-1997 fixed-form source facility is part and parcel of this biased treatment of backward compatibility in the language.\nThe cost argument is simply untenable, more than anything else it's one that always threatens to \"derail a discussion\"."
                },
                {
                    "user": "certik",
                    "date": "2020-01-02 22:57:41+00:00",
                    "text": "@FortranFan I agree with you that we should evaluate both the \"cost\" as well as the \"opportunity cost\". (Although I think it's very much on-topic here to discuss these costs.)\nSo I think @sblionel is correct that \"there's a significant cost to deleting features from the language\". But I also believe there is a significant opportunity cost of not deleting features from the language, and we have to weigh both."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-03 23:21:09+00:00",
                    "text": "At what point on a language change's path from concept to formal description to standardization to implementation should cost become relevant?\n\n@sblionel wrote:\n\n.. there's a significant cost to deleting features from the language.\n\nI request any argument in terms of \"cost\" be treated as firmly off-topic in this repository.\nNo reliable and accurate data are available on any matter related to costs in Fortran. No honest or trustworthy discussion is then possible.\nMoreover, any discussion regarding \"cost\" is meaningless without a full and fair consideration of the benefits.\nWhen it comes to benefits though, I find the feedback on the value proposition and the benefit statements offered by many a persevering, \"mere mortal\" Fortranner either gets ignored or is rejected outright.\nUnder the circumstances, no \"good faith\" discussion can take place once cost and only cost makes it way into the discussion.\nYet if the cost argument is allowed to persist, then a honest position will be to note:\n\nfeatures delayed are features denied, period.  The resultant \"opportunity costs\" to Fortran and its well-being are then immeasurably high.  Entire code-bases move permanently away from Fortran as a result\nfeatures HALF-BAKED (e.g., several aspects introduced in Fortran 2003) are features ignored or misused.  The resultant \"opportunity costs\" to Fortran and its well-being are again immeasurably high.\nfeatures too VERBOSE are features abhorred by a large section of the computing community.  The costs to Fortran's well-being again are immense.\n\nWith Fortran, all 3 of these points - delays, half-baked aspects, and verbosity - have been impacted to some extent or other by vendors' notions of backward compatibility, the continuing support of fixed-form source very much falls under this.\nThere is considerable evidence an inherently dishonest and unequal treatment of backward compatibility remains in Fortran, one just has to look at Annex B of the Fortran standard.\nThe aspect of the obsolescent-since-1997 fixed-form source facility is part and parcel of this biased treatment of backward compatibility in the language.\nThe cost argument is simply untenable, more than anything else it's one that always threatens to \"derail a discussion\"."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-25 22:58:53+00:00",
                    "text": "See this comment in #221.\nIn reply, @everythingfunctional writes\n\n.. fixed-form is obsolescent (IMO) it would be reasonable for that feature not to be available in fixed form\n\nMy view is as follows:\nObsolescent is simply a label per the standard, it has no teeth.  A feature marked obsolescent remains effectively \"first class,\" meaning all new features need to integrate with it.  As long as a feature is NOT deleted from the standard, its semantic and syntactical implications need to be fully taken into account.\nFixed-form has been obsolescent since Fortran 95, published nearly 25 years ago.  It will continue to hinder options for newer revisions as long as it is not deleted.  As recently as the last standard meeting, the selection for conditional expressions was predicated on support for fixed-form source; the final form that was chosen was low in popularity at the online forum."
                },
                {
                    "user": "certik",
                    "date": "2021-08-25 23:01:56+00:00",
                    "text": "It should be deleted from the standard.\nBut what should compilers do? They have to support it. I think the natural way is to not support some newer features that will be available in free form only."
                },
                {
                    "user": "sblionel",
                    "date": "2021-08-25 23:03:39+00:00",
                    "text": "I disagree with @FortranFan - obsolescent features are NOT \"first-class\", they generate diagnostics when standards checking is enabled (some compilers by default), they are in small type in the standard and tend to not be taught in textbooks.\nIn practical terms, deleting fixed-form source would have no effect beyond declaring it obsolescent. Compilers will continue to support it. If deleted, compiler developers will lose guidance for how to process fixed-form source."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-25 23:12:06+00:00",
                    "text": "I disagree with @FortranFan - obsolescent features are NOT \"first-class\",\n\nWhat part of \"effectively\" and the quote around the \"first class\" and the following description of mine do you not understand?"
                },
                {
                    "user": "sblionel",
                    "date": "2021-08-25 23:21:48+00:00",
                    "text": "My response stands."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-08-25 23:40:31+00:00",
                    "text": "If deleted, compiler developers will lose guidance for how to process fixed-form source.\n\nIMO, that's ok, because it's not part of the standard. That said, I do understand the predicament it would put a lot of people in. This whole limbo state is occasionally obnoxious though. Is fixed-form Fortran or not?"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-26 03:53:31+00:00",
                    "text": "It should be deleted from the standard.\nBut what should compilers do? They have to support it. I think the natural way is to not support some newer features that will be available in free form only.\n\nPlease see #225.\nRe: \"what should compilers do?\", in the context of this thread, well I think they should unburden themselves from having to implement any new feature in fixed-form source once this outmoded source form can be marked as retired officially in the standard."
                },
                {
                    "user": "certik",
                    "date": "2021-08-26 04:29:03+00:00",
                    "text": "Re: \"what should compilers do?\", in the context of this thread, well I think they should unburden themselves from having to implement any new feature in fixed-form source once this outmoded source form can be marked as retired officially in the standard.\n\nThe biggest issue with fixed-form is that white space is irrelevant. For LFortran I tried to see how far you can get with parsing fixed-form as if it was free-form, so you just fix the columns and some other slight differences in a prescanner, and then use the same tokenizer and parser. And it turns out most of SciPy seems to parse just fine. There are some slight issues, but I am hoping to implement few more heuristics to make it useful for people. The SciPy developers would be ok with changing their fixed-form a bit so that it can parse. If there is demand for a better fixed-form parser, then we'll have to implement the full fixed-form parser, as a separate parser."
                },
                {
                    "user": "Meriipu",
                    "date": "2022-03-22 08:18:26+00:00",
                    "text": "(...)\nand the reason why we cannot just have\nenum some_type\n    a, b, c, d, end, e, endenum, f\nend enum\nis that end and endenum can be confused with end enum when parsing (especially if the optional space is omitted). I think that's probably true, but I think the modern standard could be modified to require end if, end function, end enum to be always written with a space in between.\n\nunless I misunderstand, this would break even more code (including conforming free-form code) than some of the more conservative suggestions? And perhaps be excessively normative about code style."
                },
                {
                    "user": "sblionel",
                    "date": "2022-03-22 12:28:10+00:00",
                    "text": "@Meriipu, no, that's not correct. The only restriction is that a source line cannot look like an END statement (see @klausler 's post above). The syntax you show would be acceptable in fixed and free form (though not otherwise currently valid syntax.)"
                },
                {
                    "user": "Meriipu",
                    "date": "2022-03-22 13:01:57+00:00",
                    "text": "I was referring to the suggestion at the end of the quoted text (emphasized in bold) from the comment #108 (comment) which I took to mean to enforce the optional space (in e.g. endif vs end if) as mandatory."
                },
                {
                    "user": "sblionel",
                    "date": "2022-03-22 13:08:51+00:00",
                    "text": "Oops - failed to read carefully. Sorry.\nI'm still of the opinion that there's no good reason to delete fixed form, nor introduce new features valid only in free form. Yes, one can construct syntax that doesn't work, but so what? Other syntax, consistent with the language, is possible, as repeatedly demonstrated over the years."
                }
            ]
        },
        {
            "number": 107,
            "user": "jacobwilliams",
            "date": "2019-12-09 18:35:21+00:00",
            "title": "Reduced verbosity for allocate/select type",
            "text": "I seem to encounter this sort of thing a lot:\nclass(abs_class),allocatable :: my_class\n\nallocate( specific :: my_class )\nselect type (my_class)\nclass is (specific)\n  !... now can access specific my_class members...\nend select \nIt would be nice to combine the allocate/select type/class is into one line. If you're going to allocate a class, and then immediately do something with it, the amount of code here seems excessive.\nI'm not sure what the syntax would look like.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "nncarlson",
                    "date": "2019-12-09 18:59:18+00:00",
                    "text": "I find this to be a nuisance too. I have no suggestions to offer on a new combined syntax, but have found the following strategy to be less obnoxious:\nclass(abs_class),allocatable :: my_class\ntype(specific),allocatable :: my_specific\n\nallocate( my_specific)\n  !... do what you want with specific type members...\ncall move_alloc(my_specific, my_class)"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-09 21:47:52+00:00",
                    "text": "@nncarlson Nice! From 5 lines to 4.\nI was thinking something like this (3 lines):\nclass(abs_class),allocatable :: my_class\n\nsomething allocate( specific :: my_class )\n  !... now can access specific my_class members...\nend something"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-09 21:49:06+00:00",
                    "text": "@jacobwilliams wrote:\n\n..\nIt would be nice to combine the allocate/select type/class is into one line. If you're going to allocate a class, and then immediately do something with it, the amount of code here seems excessive.\nI'm not sure what the syntax would look like.\n\n@jacobwilliams , you may note inquiries such as yours have appeared on many a forum and the 'canonical' feedback to all those hapless Fortranners, often newbies dabbling with OO in Fortran, is their choices per the language standard are mostly verbose, particularly when it comes to employing polymorphism in their actual code.  That to eschew polymorphism via better OO design and analysis (OOA and OOD) of one's code is what they should pursue if they seek reduced verbosity.  Such feedback has always bothered me quite a bit even though I have on occasions suggested that to forum readers for lack of anything else.\nI personally think coder productivity is of paramount importance and convenient syntax (which many dismiss as 'syntactic sugar' to my great dismay) is a critical part of this.  I'm inclined to place high priority on enhancements involving better syntax that can improve Fortran on the verbosity ranking.  Where I work in industry there just ain't no way a team of 2 or more developers can be tasked to work using Fortran on a new project which will inevitably involve extensive utilization of object-oriented paradigm given the kind of verbose syntax on offer, especially with the managers having to keep in mind all the other limitations in Fortran when it comes to data processing.\nSo, with that preamble, a thought which I have always had (and toward which I was working to propose a paper for Fortran 202X until I got totally deflated after learning this past June the work-list for 202X was pretty much frozen with items that were decided several meetings earlier in Feb 2018) was to consider using angle brackets <..> (or another convenient notation) to signal 'dynamic' downcasting.  Say if you could do something along the following lines:\n   ...\n   class(abs_class), allocatable :: my_class\n   ...\n   allocate ( specific :: my_class )\n   ...\n   ! now access specific my_class members via dynamic cast.\n   call <specific>my_class%foo( .. )\n   <specific>my_class%bar = ..\n   ...\nThe basic idea of the above construct is to simply introduce a short-hand notation (and thus achieve your stated objective which is reduced verbosity) for each instance toward downcasting which a coder might do using the current standard with basic error handling such as with\n   ...\n   class(abs_class), allocatable :: my_class\n   ...\n   allocate( specific :: my_class )\n   ...\n   select type ( my_class )\n      type is ( specific ) ! or 'class is ( specific )\n          ! access specific member 'foo'\n          call my_class%foo( .. )\n      class default\n           error stop 'No match in type-guard statement'\n   end select\n   select type ( my_class )\n      type is ( specific ) ! or 'class is ( specific )\n          ! access specific member 'bar'\n          my_class%bar = ..\n      class default\n           error stop 'No match in type-guard statement'\n   end select\n   ...\nThe coder with <specific> downcasting option shown above achieves compactness in their code while also being forced to enter into an exception handing scenario - something  per the current standard, they then tend to overlook with missing or empty class default statements anyway and not realize no block is executed and thus experience what can be considered 'silent errors' in their code.\nMy hope was the work toward exception handling will go on in parallel as part of Fortran 202X  and a use case to handle type-guard mismatch during dynamic downcasting can get added to that work.  Alas!\nA forward-looking processor such as LFortran might even be able to try out the above with just their parser and provide feedback on the pros and cons?"
                },
                {
                    "user": "aradi",
                    "date": "2019-12-12 10:35:54+00:00",
                    "text": "I think, there are two aspects there. The first one is the access of specialized fields without having to specify select type. I usually also use the pattern as suggested @nncarlson and I don't think, that sparing just one line would be justified to introduce a new syntax. The second one, is the safety of the select type construct as brought up by @FortranFan, and that I find much more sever. Forgetting to specify a class default block can make up for hard to spot bugs.\nBut probably, this could be solved by a simple intrinsic subroutine as well, instead of a new syntax. This subroutine would associate a specific pointer with an abstract base class if possible, and either return an error code (as an optional argument) or stop the execution if the association was not possible.\nclass(abs_class), allocatable, target :: myclass\nclass(specific), pointer :: specificptr\ninteger :: error\n\nallocate(specific :: myclass)\n! Would stop the code if failing\ncall associate_specialization(myclass, specificptr)   \n! It would be the programmers responsibility to check the content of error afterwards\ncall associate_specialization(myclass, specificptr, assocerror=error)"
                }
            ]
        },
        {
            "number": 106,
            "user": "certik",
            "date": "2019-11-30 14:10:04+00:00",
            "title": "Pathway to introduce straightforward features",
            "text": "@FortranFan submitted this at #105, I moved it to a separate issue here, so that we do not derail a discussion at #105.\n\nSorry for going off-topic but to me this proposal looks rather straightforward and without serious side effects and any concerns or issues raised with something like this are going to be an overreach and can be heavily debated whether they're technical at all.\nSo the question is why does this have to Fortran 202Y whose timeline is likely in the year 2028 at the earliest?\nThat is, other than perhaps a project management type of decision by WG5 on the work-list toward Fortran 202X?  But who should WG5 represent other than the \"many users\" who \"have asked for a way to\" need this?  And since many other features of interest to said users have been deferred or rejected by WG5 for Fortran 202X anyway, why not carve out an avenue to add many other smallish features to Fortran 202X which will at least add some heft to what appears otherwise a rather dull revision considering the five years devoted to its development?\nSuggestions such as these appear to me to be in the Just do it! category and the standards revision process must have a pathway to introduce any number of them into the language as soon as the work is completed like in an online development platform.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-30 14:18:44+00:00",
                    "text": "This is related to #36. I agree. Currently we are in a mode \"we select features and work hard on those few selected features until they are ready, delaying the release of the standard\". Rather, we should move to a mode \"we work on all features that the community wants, and when a feature is ready, it goes into the very next standard, which is released every 3 years no matter what\"."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 15:32:04+00:00",
                    "text": "I very much understand the sentiment here. But this approach has been the ruin of us before, making continuous additions right up to nearly the end. The problems with this are 1) stretching out the schedule because NO feature, no matter how simple, has zero cost, and 2) it encourages others to keep up a steady of stream of \"if you let X in, why not my Y?\" This includes things I'd like to see added, and I've had to bite my tongue several times to avoid reopening the floodgates.\nThis is my first go at \"running\" a standard development process, and I've chosen to take a hard line on when we stop accepting new feature requests. Nearly all of WG5 supports this and we have made much more progress in meetings than before, where we kept taking time away from development and integration with discussions of 1+ items. For better or for worse, that's how we're doing it for 202X. (FWIW, John Reid, the previous convenor, has said to me more than once that he wished he had said \"No\" more often.)\nMight it be different for 202Y? Probably - especially if this Github list is successful at accelerating development of features. I would want to see participation of more of the J3 folks who have long experience with the standard and who develop the bulk of the proposals to date. I'm uncomfortable that so far I seem to be the only one such here. It's definitely something I will bring up in February.\nWhat I do very much want to avoid is Fortran becoming a \"kitchen sink\" language, full of everyone's pet features from other languages (or new).  I think the current process is working well so far, and we've made a lot of progress, and I don't want to spoil that by changing the strategy mid-stream."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-30 16:17:08+00:00",
                    "text": "Sorry to break it but no. The current process is not good and Fortran needs\nto catch up urgently. The truth is that many of these \"pet features\" are\nmore polished that these who made it into standard and are made fun of till\nthese day.\n\nIf we have to wait for 10 years until 202y for simple features needed in\nthe language urgently then we see the problem that is explained in the\noriginal post. I would see them published no later than 2 years. And if the\ncurrent committee cannot do this then probably this is why it meets so much\ncriticism from people who actually use the language.\n\nsob., 30 lis 2019, 16:32 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n I very much understand the sentiment here. But this approach has been the\n ruin of us before, making continuous additions right up to nearly the end.\n The problems with this are 1) stretching out the schedule because NO\n feature, no matter how simple, has zero cost, and 2) it encourages others\n to keep up a steady of stream of \"if you let X in, why not my Y?\" This\n includes things I'd like to see added, and I've had to bite my tongue\n several times to avoid reopening the floodgates.\n\n This is my first go at \"running\" a standard development process, and I've\n chosen to take a hard line on when we stop accepting new feature requests.\n Nearly all of WG5 supports this and we have made much more progress in\n meetings than before, where we kept taking time away from development and\n integration with discussions of 1+ items. For better or for worse, that's\n how we're doing it for 202X. (FWIW, John Reid, the previous convenor, has\n said to me more than once that he wished he had said \"No\" more often.)\n\n Might it be different for 202Y? Probably - especially if this Github list\n is successful at accelerating development of features. I would want to see\n participation of more of the J3 folks who have long experience with the\n standard and who develop the bulk of the proposals to date. I'm\n uncomfortable that so far I seem to be the only one such here. It's\n definitely something I will bring up in February.\n\n What I do very much want to avoid is Fortran becoming a \"kitchen sink\"\n language, full of everyone's pet features from other languages (or new). I\n think the current process is working well so far, and we've made a lot of\n progress, and I don't want to spoil that by changing the strategy\n mid-stream.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#106?email_source=notifications&email_token=AC4NA3OWPVG3N4T6VXYYBLTQWKBPNA5CNFSM4JTGYOVKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFQKX6Y#issuecomment-559983611>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KCLASV2EFBCJYUHDTQWKBPNANCNFSM4JTGYOVA>\n ."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 16:27:45+00:00",
                    "text": "I have said before, the majority membership of J3 and WG5 are users, not vendors. (And most of the vendor members are down in the weeds with their users on a daily basis.) It really doesn't matter what we do, someone will be critical. The 202X process was more open to users' wants and needs than any in the past.\nA significant part of the delay in issuing new standards is the process required by ISO, which calls for multi-month letter ballots of a draft and what is supposed to be final. There's absolutely no way that a 2-year cadence could be followed unless the only things changed were fixing typos. Consider that the coarray enhancements in F2018 took at least four years to develop, changing significantly over that time. A lot of the work was done asynchronously to meetings."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-30 16:38:57+00:00",
                    "text": "I understand. Thank you for explanation of these limitations. Still I think\nmaybe some features could get a fast track process. Can I ask how is the\ndivision of workload? Say we need feature X which is a simple function to\ndo something. Does everyone discuss it at once? Maybe one person who is\nqualified could take this only one function as their main focus and prepare\nanalysis and ready to vote project that does not need to wait years. Would\nthat work?\n\nsob., 30 lis 2019, 17:27 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n I have said before, the majority membership of J3 and WG5 are users, not\n vendors. (And most of the vendor members are down in the weeds with their\n users on a daily basis.) It really doesn't matter what we do, someone will\n be critical. The 202X process was more open to users' wants and needs than\n any in the past.\n\n A significant part of the delay in issuing new standards is the process\n required by ISO, which calls for multi-month letter ballots of a draft and\n what is supposed to be final. There's absolutely no way that a 2-year\n cadence could be followed unless the only things changed were fixing typos.\n Consider that the coarray enhancements in F2018 took at least four years to\n develop, changing significantly over that time. A lot of the work was done\n asynchronously to meetings.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#106?email_source=notifications&email_token=AC4NA3KHMPVGCDUBIP6I2YLQWKIADA5CNFSM4JTGYOVKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFQMUWQ#issuecomment-559991386>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KA7ZCXNBOWXIWRNPTQWKIADANCNFSM4JTGYOVA>\n ."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 17:07:13+00:00",
                    "text": "Each meeting, attendees are split into \"subgroups\". A first pass at this is usually done by Bill Long, but at the meeting anyone can ask or offer to join a different subgroup. The subgroups are (if I have this right, even now I sometimes get confused):\n\nData - deals with declarations, expressions\nHPC - coarrays and C interoperability\nJoR - I/O, intrinsics, execution control (The term JoR is historical, doesn't really mean anything now.)\nInterp - Interpretations\nEdit - Non-technical changes\n\nBill does preliminary assignments of all submitted papers to the various subgroups. Sometimes these assignments get changed as the paper is better understood.  Each subgroup has a head. Different people have different areas of expertise; Bill usually heads HPC, Malcolm heads Data (and Edit and Interp nowadays). Dan Nagle usually heads JoR but I have sometimes, and I am usually there as that's the part of the language I know best. If the distribution of papers among subgroups is uneven (often), more people will be switched to the one with more papers.\nEach day, after the initial plenary meeting, the subgroups separate to work on papers. Features generally need specifications and syntax, and subgroup members work on those. They will also discuss proposals and decide whether or not the subgroup recommends the proposal or not.  Often new papers will be written as results of considering earlier papers, or issues that have arisen.\nEach afternoon, the subgroup head reads off a list of papers that all are to read for the next day. Some are for vote, some have \"straw votes\" used to establish a direction, some are informational and some are flagged as \"no action\". At the next morning's plenary session each paper is discussed in turn and, if needed, votes taken. Often some minor detail will arise that requires a small edit, and the paper is passed \"as amended\" where that edit is agreed upon and then a final revision is made and posted.\nWhen I built the current J3 web site, I added the ability to mark each paper with its status, and you can sort on status, making it easy to see if anything was missed. It used to be that Dan kept a spreadsheet that he updated twice daily, but this was a manual process.\nMany members read papers as they are posted to the J3 site between meetings and may engage in discussion with the author.\nIt's very unusual for any proposal to come to J3 fully-baked, no matter how qualified the author. Most smaller items can get done in one or two meetings, but larger ones take more time. A major source of issues is often how the proposal works with the rest of the language, and it is here that the more experienced members have valuable insight.\nFor 202Y, I'd love to see us begin the process with developed proposals and not just one-liners. This github could be a way to do that."
                },
                {
                    "user": "tskeith",
                    "date": "2019-11-30 17:30:59+00:00",
                    "text": "This is related to #36. I agree. Currently we are in a mode \"we select features and work hard on those few selected features until they are ready, delaying the release of the standard\". Rather, we should move to a mode \"we work on all features that the community wants, and when a feature is ready, it goes into the very next standard, which is released every 3 years no matter what\".\n\nThis seems to imply that implementors have unlimited capacity for new features so there is no need to prioritize them. (Or else it's fine to have lots of features in the language that aren't implemented yet.). I don't believe that is the case.\nI think an important contribution of this project can be to decide which features are most important to get in (at least to this community)."
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 17:47:28+00:00",
                    "text": "@gronki is 100% correct, that if we, as a committee, are unable or unwilling to get simple features like #105 (if there is an agreement in the wide community for it) in sooner than in 10 years, then we are not doing our job. It's that simple.\n@sblionel has done a tremendous job making the committee's work more transparent, creating a website, thinking hard how the process can be improved, engaging here, etc. That is not a criticism of you.\n@tskeith's point is also valid, that's why we have an issue #59 and indeed, we absolutely should not put every conceivable feature into Fortran. Only those that bring Fortran closer to its vision (as agreed by the wide community on the most popular issues)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-30 23:00:34+00:00",
                    "text": "@certik wrote:\n\n..\n@sblionel has done a tremendous job making the committee's work more transparent, creating a website, thinking hard how the process can be improved, engaging here, etc. That is not a criticism of you.\n..\n\nI absolutely second the above statement.  My comments and questions in the original post are not meant as any personal criticism.\nRather my assessments are based solely on \"the writing on the wall\" appearing in clearer, bolder, and darker letters every day the Fortran standard is on the verge of becoming totally irrelevant (or it always was) in so many domains.  So many code-bases get refactored away from Fortran altogether and a few that remain are left untouched in legacy FORTRAN which, in every instance I have reviewed, employs so many non-standard extensions.\nSo another question to ask after \"For whom Fortran?\" is \"Of what use is the standard?\"  Especially if the supposed INCITS standards process - as understood by the current members - comes in the way of the Fortran language?  And when so many of the widely used computing languages and paradigms - Python, Java, C#, R, MATLAB, Swift, and even C++ in its real usage  - in the scientific and technical domains are unencumbered by INCITS in any way.\nThe situation is dire.\nI find no manager financing a large, new project will now even consider 'modern' Fortran given its interminable feature-deficiencies.  Imagine letting loose a team to work on a specific engineering or technology task using Fortran with a challenging but firm deadline where the coder backgrounds right from their high school days overwhelmingly given the education system (how many engineering schools or high schools teach Fortran?) tend to be in coding in non-standard C++, Python, MATLAB, C#, Java, Swift, R, Visual Basic for Applications (VBA), etc.  (and especially when they are engineers and scientists who have to apply and advance their domain-specific knowledge the foremost during the execution of the task) and where they can't locate ready and easy ways to work with the diagonal of a matrix or split a 'string' into words or apply a type-safe and secure way to handle a myriad of computation specifications, the very basic aspects which have been resolved in other languages for decades.\nPrecisely when there is a particular urgency for Fortran to catch up, the WG5 decision with Fortran 202X is severely curtailing the much-needed growth of the language.  In fact it now threatens regression among its monolingual practitioners professionally and computationally considering the general state of computing, say with the top 10 languages surveyed by IEEE (the largest body of engineers globally) that includes, as stated above, Python, C++, Java, C#, R, Swift, etc. and whose ecosystems advance at the proverbial \"speed of light\"."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-01 02:12:19+00:00",
                    "text": "I want to point out one important thing... Many, many customers have told me that they are not allowed to use a new feature unless said feature is supported in at least three (usually) mainstream compilers. What happens if you start cramming features into the standard is that implementors set their own priorities on which to do first, and it delays eventual support of the entire standard. This in turn means it can be many, many years before you're allowed to use feature X, even if it has been in the standard for a while.\nI respectfully disagree with @FortranFan 's calling the situation \"dire\". Maybe this reflects his own circumstances and experiences, but it doesn't jibe with what I have seen in recent years among Fortran's wide customer base. Indeed, what I heard from customers was to keep the next revision small so that vendors had a chance to catch up, thus allowing them to make use of the new features sooner. The last thing I think any of us want to see is another Fortran 2008 situation, where even 10 years after publication there are only two full implementations (one of which is for a platform most don't have access to), and some of the most commonly used compilers don't even support all of Fortran 2003."
                },
                {
                    "user": "certik",
                    "date": "2019-12-01 05:20:43+00:00",
                    "text": "I must agree with @FortranFan that the situation is indeed dire and I have seen a lot of the user base. The only reason Fortran is still being used is that so much is already written in it. But managers take every opportunity to move away from Fortran. And the sad part is that if I was in their shoes, I would probably do the same. I would suggest not to look the other way and rather try to understand the situation, otherwise we can't fix it if we do not even understand the problem."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-01 19:31:03+00:00",
                    "text": "@sblionel wrote:\n\n..\nFor 202Y, I'd love to see us begin the process with developed proposals and not just one-liners. This github could be a way to do that.\n\nCan some readers please look at items #37 and #46 and review the originals posts and the links therein to proposal papers and provide feedback as to whether they are \"one-liners\"?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-04 23:03:15+00:00",
                    "text": "Add me to the \"situation is dire\" group. In the NASA/astrodynamics/optimization world, Fortran is dying. Many of the classic Fortran programs and libraries with decades of heritage have been or are currently being replaced. Just a few major examples off the top of my head:\n\nJSC : FDS/FAS & SORT. Replaced with Matlab, Java, Julia, and some commercial tools\nJPL: DPTRAJ/ODP (replaced with C++ and Python), SPICELIB (currently being rewritten in C++).\nLaRC: POST (rewritten in C)\nMSFC: GRAM atmosphere model (rewritten in C++)\nGCFC: GTDS (I believe replaced with some C++ tools...but not quite sure about this one.)\n\nI don't see any new modern optimization software being produced in Fortran anymore. (The classic SNOPT is an exception, it's still around but Fortran 77, and they have been working on a Fortran 2003 update for some time I believe). IPOPT was originally Fortran but was rewritten in C++. Amazing new libraries are being written in C++ (e.g., HIOP from LLNL, NLPAROPT from GSFC). There's also some excitement about Julia in this field.\nThere are a few holdouts. I'm holding down with fort with my Copernicus software (which is used by hundreds of people...most of whom probably don't know it's written in Fortran), as well as my opensource projects. But, the trend here is pretty clear. It's only going to get worse if another decade goes by with no significant improvements to the language or ecosystem."
                },
                {
                    "user": "certik",
                    "date": "2019-12-04 23:27:06+00:00",
                    "text": "@jacobwilliams 100% agree, exactly the same experience at National Labs."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-04 23:37:48+00:00",
                    "text": "I also agree that the situation is dire. I'm working as a research software engineer at the UK Atomic Energy Authority and new code is all written in Python or C++ (very occasionally Julia). While I have provided resources showing best-practice for those wishing to start a new project in Fortran, I know of no one who plans to do so. Codes currently written in Fortran are tending to be converted to Python for all except the most numerically-intensive parts (which get wrapped using f2py). Frankly, I would find it difficult to recommend anyone writes new software in Fortran, given the its verbosity, the poor compiler support for recent more powerful features, and the massive amount of time required to reimplement features which are built into most other languages.\nIt must be said that not all of this is due to the standards committee; the compiler vendors must take a great deal of the blame. They have failed to keep up with what new features are introduced. Gfortran at least has the excuse that it is primarily worked on by volunteers with limited time (although frankly, industry should start donating money and/or developers to overcome that). The commercial compilers really must do better, however.\nWithout meaning any animosity towards those on the committee or those working for the vendors, I fear that the current path will lead to the demise of the language in all but legacy code. The problem, I think, is this: at present the main customers for Fortran compilers are those with large legacy code-bases. Therefore, the vendors are compelled to cater towards those needs and will prioritise that over implementing new features or pursuing new, experimental, and/or innovative developments to the language. However, in doing so they are making it less and less likely that new projects/customers will use Fortran, given that there are other more powerful or productive languages they could work in. Ultimately I think this will spell the death of the language. Unfortunately, given the economic incentives, I also don't see an easy way out.\nWhat we desperately need (as others have said) is an open source Fortran compiler which offers faster development of new features, including experimental ones. Not being dependent on legacy clients, it would be less constrained by the past and could even blaze a trail for the standards committee to some extent. It would be nice if gfortran could provide this, but given its massive and intimidating nature (not to mention that it is written in C) I think this seems unlikely enough people would have the skills to get involved. Perhaps Flang or LFortran will be able to fill this role, although we would still have the issue of resources; such a project is likely to struggle if it is done purely on a voluntary basis. However, something along these lines is surely necessary if we are to modernise the language."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-06 00:10:21+00:00",
                    "text": "My personal opinion...  I think waiting for three compilers to support something before you use it is an extreme requirement, and Fortran shouldn't be held up by people that have a requirement like that. No one has a requirement like that for Python (the very idea would be absurd). Unfortunately, I guess the reason some people have this requirement is because the Fortran compilers I'm familiar with are usually riddled with bugs when a new feature is added (yes gfortran is done by volunteers so I don't complain about that. Intel is another story). If there existed a free and canonical Fortran compiler that was released along with the standard and was very high quality and guaranteed to work, then this wouldn't be an issue... but that doesn't currently exist."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-06 05:06:44+00:00",
                    "text": "Edit 12/6/2019: my earlier comments withdrawn.\n@septcolor wrote:\n\n.. Here again, do we users need to wait for the NAG compiler to implement it (with the implementation schedule unknown?) ...\n\nI honestly believe waiting for certain compilers to catch up has dictated the technical content of Fortran 202X to that of a very minor revision.  I have tremendous concern such a consideration will continue to adversely impact future development of the language."
                },
                {
                    "user": "certik",
                    "date": "2019-12-06 17:57:09+00:00",
                    "text": "Thank you @jacobwilliams, @cmacmackin and @septcolor for your feedback. I agree, I have a very similar or identical experience as you have. I have no doubts it is like that at any major corporation and company, so the situation is dire. Most influential members on the committee currently unfortunately do not agree with us. The committee seems fine with the current trajectory.\nI am not. I want to say very clearly, that I am not at all interested in the current trajectory of \"managing Fortran's slow but steady disappearance\". If that is the goal of the Fortran committee, then we need to change the goal. The goal should be to get Fortran used for new projects again, and to create a healthy ecosystem again.\nAnd I also believe the tide could be turned (that's why I started LFortran, joined the committee, started this GitHub repo, etc.). I also agree that what is needed is to have a modern compiler, maintained by the community, and add all the new features in there, just like Python or Julia does it, and not need to wait until all other compilers catch up.\nThe wider community seems to agree this is the right vision. And so it would be very helpful if the Fortran committee could help us make the vision succeed.\nP.S. To that end, @FortranFan please tone the rhetoric down a little bit. Let's try to be critical without being personal. We are all on the same team."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-07 00:17:58+00:00",
                    "text": "@certik wrote:\n\n.. @FortranFan please tone the rhetoric down a little bit. Let's try to be critical without being personal. We are all on the same team.\n\nPoint accepted."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-17 08:39:03+00:00",
                    "text": "Just to add my experience even though it simply mirrors all the others:\nIn theoretical chemistry community (and also theoretical phyics afaik), no new program is written in Fortran. People use Python and/or C++ instead.\nI really agree with @certik : We have to improve and adapt the language at a pace faster than now. Otherwise, Fortrans disappearance might actually come faster than you'd think. (Trying not to sound apocalyptic).\nI think, LFortran and especially this repo are really giving us a chance."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-01-03 08:54:17+00:00",
                    "text": "Extra anecdote. Background: statistical physics, chemical physics, nonlinear dynamics, work at universities.\nWhen I mention Fortran to colleagues, most of them wonder at the mere existence of the language. It is regarded as a relica, most people having only caught seen a glimpse of F77 if any. CPUs have become fast enough that one can prototype small simulations in Python or Matlab. It is annoying of course, because small scale computations implemented as Python loops take forever to run. There is no easy \"start with Python then speed up\" (PS: I know the libraries to accelerate Python code, my colleagues/students not) so that we are in a worse situation than the default Fortran + gnuplot/xmgrace of 20 years ago. Courses are now C++ or Python.\nI'd like to mention a huge bonus of Fortran here: one can develop codes spanning several years of work, whereas in some other languages you'd be hit by a new incompatible version, a small numerical regression, a tool becoming unsupported, or whatever change of fashion. I know that code I write in Fortran is an investment. Scientists unfortunately can only acquire this point of view after many years of practice.\nI think that the current Fortran has already gone a long way (mostly thanks to modules, defined types, and C interop). We should look, as others mention, at the idea that Fortran should remain a good option for new codes.\nBesides the language itself, the stdlib initiative is excellent. We also need teaching resources that show how to use Fortran in a modern way (@milancurcic 's book, @certik fortran90.org , maybe extra \"Fortran for starters\" tutorials)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-01-07 15:24:33+00:00",
                    "text": "When I mention Fortran to colleagues, most of them wonder at the mere existence of the language. It is regarded as a relica, most people having only caught seen a glimpse of F77 if any. CPUs have become fast enough that one can prototype small simulations in Python or Matlab. It is annoying of course, because small scale computations implemented as Python loops take forever to run. There is no easy \"start with Python then speed up\" (PS: I know the libraries to accelerate Python code, my colleagues/students not) so that we are in a worse situation than the default Fortran + gnuplot/xmgrace of 20 years ago. Courses are now C++ or Python.\n\nSame experience for me :("
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-13 01:44:13+00:00",
                    "text": "#135 appears a \"classic\" use case for this issue.\nMy #135 (comment) in that thread got mischaracterized, however it's the truth in the current scheme of things no pathway to introduce straightforward features exists with Fortran 202X being \"closed\" and the subsequent revision, where some pathways might open up for straightforward features, is indeed 8+ years away from the present.\n#135 appears to be a simple Yes/No question.\n\n\nIs Fortran willing to reconsider the NAMELIST formatting aspect of embedded blanks in designators?\n\n\nIf yes, is Fortran willing to \"standardize\" what is already supported by several of the processors tested by OP (Intel, Cray, PGI, gfortran) and which is very Fortrannic in that FORTRAN has supported embedded blanks in designators and more since its very inception.\n\n\nWhat would be the technical reasons one would need anything more than a limited amount of time, say one WG5 meeting (that usually takes place over 5 working days) to answer the first question?  Then if the answer is No, no further action on #135 would be necessary.  But if it is Yes, why should it then take more than one or two J3 meetings, which too are usually 5 working days long, and one other WG5 meeting to answer the second question?\nOne would think a \"straightforward\" feature is one that does not appear to present any concern involving backward incompatibility, adverse impact, etc.  Can #135 be a case study case in terms of how the readers can think through such matters?  According to readers then, what are the potential reasons to view #135 as not a \"straightforward\" feature?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-13 02:02:04+00:00",
                    "text": "I agree. Thanks for continuing the discussion here. We need to be able to bring such improvements in. Let's prepare a proposal for it, and get it approved by the Committee. Then let's convince the committee to include it in the next standard.\n\u2026\nOn Sun, Jan 12, 2020, at 6:44 PM, FortranFan wrote:\n #135 <#135>\n appears a \"classic\" use case for this issue.\n\n My #135 (comment)\n <#135 (comment)> in that thread got mischaracterized, however it's the truth in the current scheme of things no pathway to introduce straightforward features exists with Fortran 202X being \"closed\" and the subsequent revision, where some pathways might open up for straightforward features, is indeed 8+ years away from the present.\n\n #135 <#135>\n appears to be a simple **Yes/No** question.\n\n  * Is Fortran willing to reconsider the NAMELIST formatting aspect of\n embedded blanks in designators?\n\n  * If yes, is Fortran willing to \"standardize\" what is already\n supported by several of the processors tested by OP (Intel, Cray, PGI,\n gfortran) and which is very Fortrannic in that FORTRAN has supported\n embedded blanks in designators and more since its very inception.\n\n What would be the technical reasons one would need anything more than a\n limited amount of time, say one WG5 meeting (that usually takes place\n over 5 working days) to answer the first question? Then if the answer\n is No, no further action on #135\n <#135> would be\n necessary. But if it is Yes, why should it then take more than one or\n two J3 meetings, which too are usually 5 working days long, and one\n other WG5 meeting to answer the second question?\n\n One would think a \"straightforward\" feature is one that does not appear\n to present any concern involving backward incompatibility, adverse\n impact, etc. Can #135\n <#135> be a case\n study case in terms of how the readers can think through such matters?\n According to readers then, what are the potential reasons to view #135\n <#135> as not a\n \"straightforward\" feature?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106?email_source=notifications&email_token=AAAFAWDQO7VG7BIXGKLSZ4DQ5PBO5A5CNFSM4JTGYOVKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIXKTOI#issuecomment-573483449>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWERQ4SHK52S3D6SF7DQ5PBO5ANCNFSM4JTGYOVA>."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-14 15:48:23+00:00",
                    "text": "In my position as WG5 Convenor, I am against reopening the work list for 202X. It is not clear to me if that is what is being suggested here, but if it is, there will be a strong pushback. One of the major criticisms raised in this \"forum\" is the length of time it took to ratify F2018 after F2010 - I presume this is the source of the \"8 years\" comment that has been made.\nIt is my firm belief, having been on the committee during that entire development time, that a major factor was continuing to \"`1+\" the feature list well into what should have been the final draft phase. When I was made Convenor, I decided that we were going to do it differently this time and set a firm cutoff for features, in the hope of getting the standard out in 3-4 years instead of 8. I got the approval of pretty much everyone on WG5 for this. The previous Convenor, John Reid, admitted to me that he wished he had said \"No\" more often.\nYes, I know that this means good ideas won't \"make this train\" and will have to wait for the next one. But the alternative, in my view, is worse, as there will be a steady stream of \"just one more!\" that takes away our limited resources to define and integrate, and risks making mistakes due to rushed development of what we might think is straightforward.\nThis forum is doing what I hoped for - collecting and vetting ideas for future revisions, kickstarting that process and allowing us to do more in less time."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 16:30:25+00:00",
                    "text": "@sblionel thank you for participating here and trying to make it work. I agree with your concerns. I have a pretty pragmatic comment to this which I think will get all of us what we want.\n\nI am against reopening the work list for 202X. It is not clear to me if that is what is being suggested here, but if it is, there will be a strong pushback.\n\nYes, that's what is being suggested --- however, not right now. The first step is to write a strong proposal for #135, get an agreement here at GitHub and submit to the Committee and get an agreement at the Committee. Then the next step (I think) is to also prepare the exact edits to the standard and again get everybody to agree to them. Even for a \"simple\" proposal like #135 this is actually a lot of work, that all has to happen first. Only then, if it is truly ready, I would consider that we have a frank talk about putting this into 202X. And yes, the answer at the Committee could be that we will only be able to put this into 202Y. But I am actually quite optimistic that people at the Committee might change their mind regarding this, if the feature is truly ready, meaning it does not require any more work from any Committee member.\nUntil then it's obviously not ready and I am not suggesting we open any kind of a work list and risk delaying 202X. We all want 202X to be out as soon as possible.\nAnd we are all learning how to do this the most efficiently, we are just starting with this repository and we are just starting to build a community. All I am asking is that we trust each other that we are all putting our best faith effort to make this all work. And I think we are all doing exactly that, so let's keep working."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-14 16:44:27+00:00",
                    "text": "Just to make it clear -  WG5 could vote to allow new features in. I am just one vote on that. This isn't something J3 gets to decide on its own, though it can make a recommendation. If a change seems really important to get in now, I expect most WG5 members could be convinced to do so. #135 doesn't rise to that level, in my opinion.\nI would be favorable to J3 discussion of any of these proposals, if it doesn't take away time from developing 202X. On #135 I'd be interested in opinions from people who have been on the committee longer than I on why that restriction was put in."
                }
            ]
        },
        {
            "number": 105,
            "user": "sblionel",
            "date": "2019-11-30 01:04:35+00:00",
            "title": "Allow COMPILER_VERSION, COMPILER_OPTIONS in constant expressions",
            "text": "Fortran 2008 added COMPILER_VERSION and COMPILER_OPTIONS functions to intrinsic module ISO_FORTRAN_ENV, These are nice, but they can't be used in constant expressions, despite their being compile-time constant.\n10.1.2 has a carve-out for transformational intrinsics from IEEE_ARITHMETIC and IEEE_EXCEPTIONS when all arguments are constant expressions. I would like to see this extended to ISO_FORTRAN_ENV\nIn addition, many users have asked for a way to save the compile date/time in the code. One can sometimes do this with a preprocessor, but a COMPILE_DATE_TIME or such function in ISO_FORTRAN_ENV would round out the existing support.",
            "is_open": true,
            "labels": [
                "Fortran 202y",
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-30 02:35:25+00:00",
                    "text": "This issue is a candidate for #106."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-01 04:27:04+00:00",
                    "text": "I love the COMPILE_DATE_TIME idea!"
                }
            ]
        },
        {
            "number": 104,
            "user": "milancurcic",
            "date": "2019-11-29 01:48:58+00:00",
            "title": "Standard library proposals",
            "text": "Edit: Moved to https://github.com/fortran-lang/stdlib\n\nI'm opening this meta issue with the goal of a broad and open-ended discussion around specific proposals that aim to add intrinsic procedures to the standard. Recent examples of such proposals are: #96, #100, #101, #103.\nWhile I'm personally in support of most such proposals, I often see them as putting the cart before the horse. Why so? A common argument for such additions is that they are commonly used and often re-implemented over and over again because they're not available as intrinsics. I get this. However, if such intrinsics are really needed, I imagine there'd be an obvious choice of a 3rd party library available. Reusable and open libraries emerge when the pain is high enough in the community. That's how datetime-fortran came about. Lack of open source libraries may be a signal that there just isn't great need for such procedures.\nShould we, as the Fortran community, consider working on a non-standard library that would include such procedures that we aim to the propose to the committee for inclusion in the standard? This library, or a subset of it, could over time become a candidate for the Fortran standard library, in addition to built-in intrinsics.\nI foresee multiple benefits:\n\nNear-immediate quality of life improvement for many application developers like myself.\nIn the process we'd flesh out what's really useful and what's not so important; we could troubleshoot caveats in the implementations before they're committed in writing in the standard.\nWe'd have concrete examples to show to the committee, which would make it easier to argue for their inclusion in the language;\nA maintained general purpose library could ease and increase adoption of Fortran by newcomers to the language.\nImplementations of new procedures could be used to solicit use cases.\n\nThere are quite a few projects in this spirit, such as Arjen's flibs and Ondrej's fortran-utils. Such libraries could serve as design examples, and perhaps even contribute implementations toward a dedicated non-stdlib.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-29 03:20:44+00:00",
                    "text": "I think this is a great idea. The fortran-utils project began as a necessity, where I collaborated with as many people as I could, but that was about 10 years ago, and we now have a much better community and a will to collaborate on a \"standard library\", with the idea that that what is in there are strong candidates for inclusion into the standard. (Sort of like Boost in C++.) I am imagining that we would carefully discuss a design of each function in there. With many eyes and experiences that we have, I think it can be really well designed.\nIndeed, currently the committee always puts the carriage in front of the horse. The fix for language features is to first implement them in a compiler. That will come in a few years, hopefully even sooner. But for library additions (this feature), the fix is to first implement them in the \"standard library\", get it used in projects, gain some experience, and then write up a proposal and get it into the standard.\nWhat should we call this library?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-29 03:41:27+00:00",
                    "text": "FYI: @apthorpe had some good thoughts about this a couple years ago:\n\nhttp://www.acorvid.com/2017/12/13/what-i-miss-when-writing-fortran/\nhttp://www.acorvid.com/2017/12/11/what-should-a-fortran-standard-library-contain-part-1/\nhttp://www.acorvid.com/2017/12/12/what-should-a-fortran-standard-library-contain-part-2/"
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-29 04:41:44+00:00",
                    "text": "An ancillary issue is how much of such a library should be written in Fortran itself.  Most libc implementations that I've seen are predominantly written in C, with occasional assembly code (most notably crt0.s).  The CPython Standard Library, on the other hand, seems to be a blend of Python and C.\nAt the risk of repeating myself, I think the answer to this question would help to more strongly define what can and cannot (or ought and ought not) be done within the constraints of the language itself, and perhaps reveal more precisely when an extension of the core language is required.\nAnother issue is whether particular intrinsics ought to be part of such a library, rather than part of the language itself.  I know that my own group would like more control over the behavior of many transcendental functions like exp() for the sake of bit reproducibility, for example.\nOverall, I am very supportive of something like this and would love to contribute to its development."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-29 15:29:30+00:00",
                    "text": "@certik I don't know about the name, for the time being we can refer to it as just standard library, and see if it meets adversity. My guess is that it'd be welcome and embraced by most of the community. If a better name candidate comes up, we'll know. More important are the processes that we adopt to elect candidates for stdlib, and how to implement them. Your strong experience with SymPy will come in useful here as well.\nI think a good model in the beginning would be for stdlib candidates to evolve from certain proposals in this repo. If it's a request for adding an intrinsic procedure or module to the language, we tag is as stdlib-candidate, and issues that gather strong support by the community can \"level up\" to experimental implementation in the stdlib. The stdlib could be another repo under github.com/j3-fortran. This repo would also be a place to include unit and regression tests, benchmarks, and of course the stdlib docs.\n@marshallward Good points, and I don't see a good reason to limit this to pure Fortran implementation. For example, sorting can be done with pure Fortran, but file system procedures would need quite a bit of C. I think this is OK.\nWhether some intrinsics should be part of a 3rd party library or part of the language, we'll learn that along the way. If we find that a procedure or module should be standardized, we'd use this as a stepping stone in that process."
                },
                {
                    "user": "certik",
                    "date": "2019-11-29 15:54:19+00:00",
                    "text": "@milancurcic I agree. Let's call it the \"Fortran Standard Library\", or stdlib in short. I would like to try get (informal) support / blessing from the committee for this effort. In SymPy or fortran-utils the bar to get a new feature in is lower --- one just has to send a PR and convince the core developers to merge it. In this stdlib the bar to get a feature in should be much higher --- there needs to be a proposal in this repository, it needs to have support from the wider community, and then also ideally several members of the committee would \"approve\" it. And the goal of stdlib would be that if the Fortran Standard Committee decides that Fortran should have a standard library specified in the Fortran Standard itself, this stdlib will be it. In particular, we want to prevent a situation that in the future the committee decides to have a standard library, and they would not like some API of stdlib and decide to change it in backwards incompatible way. So for that reason I want to have a buy in of the committee from the very beginning.\n@sblionel what do you think?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-30 00:34:50+00:00",
                    "text": "@certik wrote:\n\n.. Let's call it the \"Fortran Standard Library\", or stdlib in short. ..\n\n@milancurcic , @certik, @marshallward ,\nIt's great to see your enthusiasm toward this effort, the value of this to the Fortran community is immeasurable and priceless.  I really hope the ISO IEC working group WG5 will wholeheartedly support and cooperate with such an initiative.\nIt will be truly remarkable if stdlib can cover the 4 broad categories noticed with 'standard libraries' of other languages:\n\n\nContainers\na. string type\nb. bitsets\nc. Enhanced 'array' types such as vectors, singly-linked and doubly-linked lists, etc,\nd. Adapters such as stacks, queues, etc.\ne Associative ones such as dictionaries (maps), hash_sets, etc.\n\n\nAlgorithms\na. Generic methods for sort, findloc, etc. that can work with any type, intrinsic and derived,\nb. Operations and permutations on a range of elements such as merge/union, difference,\netc.\n\n\nUtilities\na. Iterator-like facilities which make it easy to work with Containers,\nb. Operator (<, >, ==, etc. ) and assignment(=) overload abstracttions that perhaps make\nthe use of standard algorithms more efficient?\nc. Miscellaneous other functions, subroutines (like generic swap), datetime, named\nconstants, etc,\n\n\nSpecial aspects: a placeholder for any fundamental needs that get identified as this initiative progresses:\na. Any basic facilities (extensions perhaps to ABSTRACT INTERFACE block?) needed toward\n\"special\" functions such as Variadic ones in the language e.g., MAX, MIN\nb. Ability to \"overload\" array subsection notation facility with Containers that standard Fortran\nprovides with its 2 built-in containers: arrays and CHARACTER intrinsic type.\nc. Any special mechanisms that can help aid with improved constructors of arrays/containers\nand derived types ('classes').  I envision certain fundamental 'computer engineering' aspects\nbeing pursued here that can enable, say, efficient operation on the diagonal of a matrix or\ninitialization to an identity matrix; or efficient 'dynamic' construction of 'classes' in Fortran similar\nto that is achieved near universally using new keyword in other languages."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-30 00:47:16+00:00",
                    "text": "@jacobwilliams wrote:\n\nFYI: @apthorpe had some good thoughts about this a couple years ago:\n\nhttp://www.acorvid.com/2017/12/13/what-i-miss-when-writing-fortran/\nhttp://www.acorvid.com/2017/12/11/what-should-a-fortran-standard-library-contain-part-1/\nhttp://www.acorvid.com/2017/12/12/what-should-a-fortran-standard-library-contain-part-2/\n\n\nAgree.\nThoughts by @apthorpe under the \"Release and Distribution Model\" e.g.\nI have a background in nuclear safety and writing code to the ASME NQA-1 standard for\nsafety-related quality assurance where strict configuration management is the norm.\nHaving worked in both fast-paced startups and in the glacially-paced nuclear industry,\nI have to say I prefer the more thoughtful release model. I feel it\u2019s a better fit for Fortran\nculture and it offers a more consistent, predictable, and reliable experience for end users\n\nare particularly important for all the users I work with."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-12-01 12:22:03+00:00",
                    "text": "For the past five years I've been programming in Fortran, I have always felt there is a lack of a central library for common things such containers, string handling, IO, etc., but also general numerical routines for interpolation, LAPACK interfaces, ODE solvers, evaluating polynomials and more. It seems like each of us has (re-)implemented these tools at some point in time, wasting lots of human hours. Ironically, many wrapped Fortran libraries are much easier to use from Python (via SciPy) than from Fortran itself.\nWould a Fortran stdlib also cover such routines for numerical work or should there be a second library for scientific Fortran routines? I imagine the scientific library would more or less reimplement what the NAG library and the former IMSL library (now RogueWave) already have. I wonder if perhaps these two libraries might be the reason why we have no open-source scientific Fortran library, as many Fortran users (or there employers) in the past simply bought a license.\nFinally, I wanted to mention the Flibcpp project which provides Fortran bindings to the C++ standard library using auto-generated code from SWIG-Fortran. Would we allow the Fortran standard library to have different backends (e.g. via submodules)? For example one with \"hand-written\" Fortran/C routines, and another one which is just a thin wrapper of the C++ one. It would be interesting to see if this library effort gained momentum, would the compiler vendors slowly shift to this standard library interface and provide there own specialized implementations (kind of like the Intel distribution of Python which has linked up Numpy/SciPy with the Intel Math Kernel Library)."
                },
                {
                    "user": "apthorpe",
                    "date": "2019-12-02 03:27:33+00:00",
                    "text": "I'm very heartened to see this pick up again, especially with people I've\nmet since I originally posted my thoughts on the matter. I've been working\nwith C++ and the Boost library for about a year and I like their approach.\nA number of Boost proposals and libraries have made it into the C++\nstandard library with minor modifications. This allows early adopters to\nexercise the code, find limitations, etc., prior to making a proposal to\nthe standards committee. Much of the developmental 'churn' takes place long\nbefore standards proposals are made. When Boost libraries are accepted to\nthe standard library, it's usually very easy for end-developers to migrate\nfrom Boost to stdlib routines.\n\nMy preference is to concentrate on areas where traditionally there hasn't\nbeen much emphasis, especially data import/export, string processing,\ncontainers, and search/sort. Numerical code is covered well (for example,\nIntel Fortran ships with optimized versions of BLAS/LAPACK). Regular\nexpressions, hashes (dict/map/associative array), and data validation and\nimport utilities would substantially reduce the burden of parsing,\nprocessing, and validating input. I've seen a surprisingly large fraction\nof application code devoted to input processing, much of which could be\nimproved or eliminated with regexes or hashes.\n\nAs for implementation language, I wouldn't limit it to just Fortran. While\none can write a regular expression library in Fortran, one probably\nshouldn't, especially when C++11 already has a perfectly usable regular\nexpression implementation. My inclination is to stay with mature\nstandardized languages such as C++, C, etc. If Fortran is workable, great;\nin many cases it isn't. To simplify adoption, it may be wise to restrict\nimplementation languages to C, C++, and Fortran, at least initially.\n\u2026\nOn Sun, Dec 1, 2019 at 6:22 AM Ivan ***@***.***> wrote:\n For the past five years I've been programming in Fortran, I have always\n felt there is a lack of a central library for common things such\n containers, string handling, IO, etc., but also general numerical routines\n for interpolation, LAPACK interfaces, ODE solvers, evaluating polynomials\n and more. It seems like each of us has (re-)implemented these tools at some\n point in time, wasting lots of human hours. Ironically, many wrapped\n Fortran libraries are much easier to use from Python (via SciPy) than from\n Fortran itself.\n\n Would a Fortran stdlib also cover such routines for numerical work or\n should there be a second library for scientific Fortran routines? I imagine\n the scientific library would more or less reimplement what the NAG\n <https://www.nag.com/numeric/fl/nagdoc_latest/html/frontmatter/manconts.html>\n library and the former IMSL\n <https://www.roguewave.com/products-services/imsl-numerical-libraries/fortran-libraries>\n library (now RogueWave) already have. I wonder if perhaps these two\n libraries might be the reason why we have no open-source scientific Fortran\n library, as many Fortran users would simply buy a license.\n\n Finally, I wanted to mention the Flibcpp\n <https://github.com/swig-fortran/flibcpp> project which provides Fortran\n bindings to the C++ standard library using auto-generated code from\n SWIG-Fortran. Would we allow the Fortran standard library to have different\n backends (e.g. via submodules)? For example one with \"hand-written\"\n Fortran/C routines, and another one which is just a thin wrapper of the C++\n one.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AAIPODKKOFJOIL2PXZBD72LQWOT6ZA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFRHOEQ#issuecomment-560101138>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAIPODPAE55AXSTR5R3MJCLQWOT6ZANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "rweed",
                    "date": "2019-12-07 17:01:00+00:00",
                    "text": "As a first step towards a standard library, i think it would be useful if we had a complete list  (as possible) of currently available open source projects/libraries that address the things that most people would agree are of immediate need (for me thats enhanced string handling, sorting, and ADT containers and algorithms (lists, dictionaries/unordered maps, stacks, queues, etc.). If the authors of the projects are ameanable, their code could be forked into a standard repostitory that aggregates the code into one place. Then we could begin a community effort to evaluate the various ways people implemented the needed functionality we envision for a standard fortran library and write reveiws on what we liked about their approach, what we didnt' like and how appropriate the code would be as a candidate for inclusion into the standard library. I think this would also benefit the original authors because it would provide useful feedback for their individual projects. We could also encourage people to consider placing their code on the repository first prior to standing up their own github site."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-07 19:44:52+00:00",
                    "text": "This is just a small contribution, but I did come up with a way of storing arbitrary data, with run-time type-checking: https://github.com/cmacmackin/PolyCon. At one point I'd planned to use this to build a bunch of ADT containers, but I never got around to it. The code is currently GPL licensed, but I'd be willing to release it under something more permissive if people could find a use for it."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-08 19:32:29+00:00",
                    "text": "I'm all for this!\nI would prefer this activity to be 100% community led. It would be great to have some support or blessing from the Fortran committee. But, I don't wish to have a situation where we have to wait for approval from the committee or some number of members to get code merged in. That would be fatal mistake, I think."
                },
                {
                    "user": "certik",
                    "date": "2019-12-08 23:51:15+00:00",
                    "text": "@sblionel what do you think of this effort? What would be the best way to get an approval / blessing by the committee for this, per the discussion above?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-09 00:02:00+00:00",
                    "text": "@certik I don't see that any committee approval or blessing is needed for this. The 202X work list includes some features that such a library might find useful, though that of course means one can't implement things until compilers have those features. Early implementations might get revised once the features become available.\nThe idea of a \"stdlib for Fortran\" has a lot of appeal, and what I have suggested before is that proponents put together a list of what they think such a library should contain. This might influence future standardization direction, especially if prototype implementations highlight a need for certain features.\nIt would be great if some version of this library were used in a production application, with observations of how it helped and how general its application was.  The standard has many features that were first implemented outside the standard."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-09 00:29:09+00:00",
                    "text": "@sblionel I think this is exactly the kind of \"blessing\" we were looking for, at least IMO. Fortran stdlib can (and should) exist in parallel to the language standard, and shouldn't be confused for it. Parts of it may eventually become part of the language."
                },
                {
                    "user": "apthorpe",
                    "date": "2019-12-10 05:09:08+00:00",
                    "text": "FWIW, I found a few simple and promising projects for testing and regular\nexpressions (PCRE) - see https://github.com/pdebuyl/fortran_tester and\nhttps://github.com/ZedThree/fortran_pcre. I agree that surveying existing\nprojects and approaching the authors would help, both to recognize work\nthat has already been done and to show there's community interest and\nsupport. I contributed back documentation, test, and build infrastructure\n(Doxygen, CTest, CMake); my preferred environment is linux/unix, but I've\nworked in mainly in Windows shops so I try to keep code and builds\nplatform-neutral (hence CMake). Regardless, I'd like to follow a Boost\nmodel where we can deliver a consistently documented and tested suite of\ncross-platform routines, relatively low impact on developers (i.e. does not\nrequire bleeding-edge tools or complex dependencies or weird manual\nconfiguration to build). I'm thinking Principle of Least Work - make this\neasy for developers to standardize on, a solid 80% solution\n\u2026\nOn Sun, Dec 8, 2019 at 6:29 PM Milan Curcic ***@***.***> wrote:\n @sblionel <https://github.com/sblionel> I think this is exactly the kind\n of \"blessing\" we were looking for, at least IMO. Fortran stdlib can (and\n should) exist in parallel to the language standard, and shouldn't be\n confused for it. Parts of it may eventually become part of the language.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AAIPODK4BJDSYIZJ7ENMQC3QXWGNNA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGHPHGQ#issuecomment-563016602>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAIPODOHNR3HXRSHHXORAELQXWGNNANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-12-10 05:25:07+00:00",
                    "text": "Thank you @sblionel for the blessing.\n@milancurcic do you want to take the lead on this effort? We can call it stdlib, and create some GitHub organization to host it under, and I think a key to its success is to get all the people who have created similar \"utility\" libraries in the past on the same page (I think we mostly already are) and then ensure that the API of the stdlib is \"approved\" by those people as well as the wider community.\nFor example, speaking for myself, if the API is good enough, and if the library can be both installed on all platforms using cmake, as well as if it works if I simply copy relevant modules to larger production codes (I think this is aligned with @apthorpe's recommendations), I'll be happy to use it instead of https://github.com/certik/fortran-utils/. If authors of similar projects will do the same, then I think this will be successful."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-10 05:49:45+00:00",
                    "text": "Today I was having a look at a few Fortran libraries (some of them very\nsmall) and was extremely taken aback by inability to compile them without\nusing CMake. Please keep in mind that CMake is extremely bloated and I find\nusing it to compile it 3 files a bit ridiculous and an overkill. For 90% of\nthe projects that people use cmake for, a simple well-written makefile is\nmore than enough. So in my opinion, requiring this one particular build\ntool for project to be acceptable as stdlib candidate is a mistake and\ncompletely against the goal. It is enough requirement that the makefiles\nfollow all the basic conventions (such as target and variable names).\n\nwt., 10 gru 2019 o 06:25 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n Thank you @sblionel <https://github.com/sblionel> for the blessing.\n\n @milancurcic <https://github.com/milancurcic> do you want to take the\n lead on this effort? We can call it stdlib, and create some GitHub\n organization to host it under, and I think a key to its success is to get\n all the people who have created similar \"utility\" libraries in the past on\n the same page (I think we mostly already are) and then ensure that the API\n of the stdlib is \"approved\" by those people as well as the wider community.\n\n For example, speaking for myself, if the API is good enough, and if the\n library can be both installed on all platforms using cmake, as well as if\n it works if I simply copy relevant modules to larger production codes, I'll\n be happy to use it instead of https://github.com/certik/fortran-utils/.\n If authors of similar projects will do the same, then I think this will be\n successful.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AC4NA3OOAOETTGEXCWICS5LQX4R3LA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGNYNDQ#issuecomment-563840654>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3J4YD6FFB4OHEEKHILQX4R3LANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-12-10 06:08:22+00:00",
                    "text": "I think we all agree on this one, see my last comment where I stressed that it must be possible to simply copy the relevant modules to your project and things should just work. We should also maintain regular simple Makefiles for the same reason. CMake should only be optional.\n\u2026\nOn Mon, Dec 9, 2019, at 10:49 PM, Dominik Gronkiewicz wrote:\n Today I was having a look at a few Fortran libraries (some of them very\n  small) and was extremely taken aback by inability to compile them without\n  using CMake. Please keep in mind that CMake is extremely bloated and I find\n  using it to compile it 3 files a bit ridiculous and an overkill. For 90% of\n  the projects that people use cmake for, a simple well-written makefile is\n  more than enough. So in my opinion, requiring this one particular build\n  tool for project to be acceptable as stdlib candidate is a mistake and\n  completely against the goal. It is enough requirement that the makefiles\n  follow all the basic conventions (such as target and variable names).\n\n  wt., 10 gru 2019 o 06:25 Ond\u0159ej \u010cert\u00edk ***@***.***>\n  napisa\u0142(a):\n\n  > Thank you @sblionel <https://github.com/sblionel> for the blessing.\n  >\n  > @milancurcic <https://github.com/milancurcic> do you want to take the\n  > lead on this effort? We can call it stdlib, and create some GitHub\n  > organization to host it under, and I think a key to its success is\n to get\n  > all the people who have created similar \"utility\" libraries in the\n past on\n  > the same page (I think we mostly already are) and then ensure that\n the API\n  > of the stdlib is \"approved\" by those people as well as the wider\n community.\n  >\n  > For example, speaking for myself, if the API is good enough, and if\n the\n  > library can be both installed on all platforms using cmake, as well\n as if\n  > it works if I simply copy relevant modules to larger production\n codes, I'll\n  > be happy to use it instead of\n https://github.com/certik/fortran-utils/.\n  > If authors of similar projects will do the same, then I think this\n will be\n  > successful.\n  >\n  > \u2014\n  > You are receiving this because you are subscribed to this thread.\n  > Reply to this email directly, view it on GitHub\n  >\n <#104?email_source=notifications&email_token=AC4NA3OOAOETTGEXCWICS5LQX4R3LA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGNYNDQ#issuecomment-563840654>,\n  > or unsubscribe\n  >\n <https://github.com/notifications/unsubscribe-auth/AC4NA3J4YD6FFB4OHEEKHILQX4R3LANCNFSM4JSZ6FOQ>\n  > .\n  >\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AAAFAWATE3XOUV6UW332KIDQX4UXVA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGOAQAY#issuecomment-563873795>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWA3OJHKS7HEMBQKIE3QX4UXVANCNFSM4JSZ6FOQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-10 14:45:46+00:00",
                    "text": "@milancurcic do you want to take the lead on this effort? We can call it stdlib, and create some GitHub organization to host it under, and I think a key to its success is to get all the people who have created similar \"utility\" libraries in the past on the same page (I think we mostly already are) and then ensure that the API of the stdlib is \"approved\" by those people as well as the wider community.\n\nHappy to! Will follow up with everybody later this week."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-10 16:05:58+00:00",
                    "text": "On CMake: keep in mind that, depending on what goes into this standard library, it could be hundreds of modules with complex interdependencies. It might not be so easy to just pick and choose what you want to pull out. So, a good and modern build system will be critical. Like it or not, CMake is an option that a lot of people use. Once you get somebody that knows what they are doing to set it up, it is quite easy to use and add new stuff to."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-10 16:11:40+00:00",
                    "text": "Yes but not all projects require that. Make is a standard solution and we\nshould minimize the amount of effort to set up a small project.\n\nwt., 10 gru 2019, 17:05 u\u017cytkownik Jacob Williams <notifications@github.com>\nnapisa\u0142:\n\u2026\n On CMake: keep in mind that, depending on what goes into this standard\n library, it could be hundreds of modules with complex interdependencies. It\n might not be so easy to just pick and choose what you want to pull out. So,\n a good and modern build system will be critical. Like it or not, CMake is\n an option that a lot of people use. Once you get somebody that knows what\n they are doing to set it up, it is quite easy to use and add new stuff to.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AC4NA3N4E4XR7ENPPXRBEL3QX646PA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGPY2VY#issuecomment-564104535>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KOIW6UPRIMDTSE6KDQX646PANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-10 16:57:32+00:00",
                    "text": "I don't like CMake either, but it will be important for cross-platform builds, especially as the project grows. Local CMake experts (ahem @jacobwilliams, @zbeekman?) will need to step up to the task to develop and maintain it. Another likely candidate is autotools. Many projects have 2 or more build systems in parallel.\nI agree overall that we should only add build capabilities as needed, rather than \"maybe we'll need this someday\"."
                },
                {
                    "user": "apthorpe",
                    "date": "2019-12-10 17:53:01+00:00",
                    "text": "I see CMake as the best of a number of unpleasant alternatives. I use it because it allows me to support multiple platforms (Linux, Windows, OSX) with a single system, handle documentation generation, dependency management, testing, and packaging. Those may not be important in everyone's environment but they are in mine. CMake doesn't force me to alter my source code nor have I found it to affect resource consumption of the compiled artifacts (speed, size, memory consumption).\nI understand CMake is polarizing; maybe someone with experience with other systems can explain how one can repeatably and automatically build and test arbitrary code including dependency detection (and potentially retrieval and build) across multiple platforms without using a system like CMake. CMake is widely used, actively maintained, and has good support for Fortran. The syntax is weird and there's a learning curve, but I've found that to be true of every build system.\nFinally, as a community effort I'd hope that those of us with experience configuring build, documentation, and test infrastructure (I include myself in this) could assist in setting up these facilities for projects. I understand people not wanting to be bothered with CMake but I don't understand the resistance to having it available for those of us who need it."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-10 18:24:27+00:00",
                    "text": "I never said it should not be available. What I say it that it should not\nbe required. Makefile is usually enough.\n\nwt., 10 gru 2019, 18:53 u\u017cytkownik Bob Apthorpe <notifications@github.com>\nnapisa\u0142:\n\u2026\n I see CMake as the best of a number of unpleasant alternatives. I use it\n because it allows me to support multiple platforms (Linux, Windows, OSX)\n with a single system, handle documentation generation, dependency\n management, testing, and packaging. Those may not be important in\n everyone's environment but they are in mine. CMake doesn't force me to\n alter my source code nor have I found it to affect resource consumption of\n the compiled artifacts (speed, size, memory consumption).\n\n I understand CMake is polarizing; maybe someone with experience with other\n systems can explain how one can repeatably and automatically build and test\n arbitrary code including dependency detection (and potentially retrieval\n and build) across multiple platforms without using a system like CMake.\n CMake is widely used, actively maintained, and has good support for\n Fortran. The syntax is weird and there's a learning curve, but I've found\n that to be true of every build system.\n\n Finally, as a community effort I'd hope that those of us with experience\n configuring build, documentation, and test infrastructure (I include myself\n in this) could assist in setting up these facilities for projects. I\n understand people not wanting to be bothered with CMake but I don't\n understand the resistance to having it available for those of us who need\n it.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AC4NA3N5QIJQOIJLNZW2FHTQX7JP5A5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGQEXII#issuecomment-564153249>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NTG6DR3RVMMF5T7GLQX7JP5ANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-10 18:44:39+00:00",
                    "text": "@gronki Yes, I believe that is true of any CMake project."
                },
                {
                    "user": "zbeekman",
                    "date": "2019-12-10 19:19:36+00:00",
                    "text": "I don't like CMake either, but it will be important for cross-platform builds, especially as the project grows. Local CMake experts (ahem @jacobwilliams, @zbeekman?) will need to step up to the task to develop and maintain it. Another likely candidate is autotools. Many projects have 2 or more build systems in parallel.\n\nIf the goals are to support all major OSes, then I would recommend CMake. Meson is coming along, but doesn't have as much buy in, and I don't know much about it. Also, CMake has pretty first class modern fortran support with automatic dependency resolution, and the ability to create robust install and export logic for package maintainers (i.e., debian, fedora, Homebrew, etc.) and can even output package-config pc files so that auto-tools packages can find it.\nA lot of the pain and hate with CMake stems from \"bad\" old-school CMake doing things in a weird/bad way, and just the fact that build systems & meta build systems are always a PITA. (I don't like CMake either, but I like it more than anything else I've tried to use in its place.)\nI have experience using CMake for Fortran mixed language (C and C++ too) projects that are required to build and run on all 3 major OSes, and use Microsoft Visual Studio for the main Fortran source on Windows.\nIn addition, CMake has buy in at DOE, and many/most other national labs.\nI'd be happy to help out with CMake stuff.\n\nI agree overall that we should only add build capabilities as needed, rather than \"maybe we'll need this someday\".\n\nYes, don't build it before you need it is an important mantra to follow.\nOff topic \u26a0\ufe0f\nFYI, I haven't had time to go through this thread in any detail, but wanted to mention that I've been particularly frustrated by repeated implementing stuff in 3 main areas, and as a result, I've started working on my own \"missing\" standard library: https://github.com/zbeekman/ZstdFortranLib\nThe best place with somewhat coherent explanation of the rationale and how to build it is the README.md on the develop branch and the ReadTheDocs documentation.\nI am going to pull in community libraries where they have compatible licenses (.e.g., functional-fortran) and focus on the following main areas (for now):\n\nStrings\n\nConversion to/from integer/real/logical (all kinds of each)\nConversion on string concatenation\nraw string processing functions inspired by Ruby & Python\nstring class to make using all the machinery easier via TBPs\n\n\nFiles\n\nFor now just name manipulations like dirname, basename, etc.\n\n\nOS/Environment integration\n\nis_a_tty(), OS%env(\"HOME\"), .envExists. \"USER\", etc.\n\n\nUnit testing & assertions stuff\n\nSubtest summaries w/ color\nFile and line number triggering failures\n\n\nError Stack class/object\n\nMaintain a call-stack\nRaise errors, but optionally trap them later with good call stack\nincluding line number and file"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-10 19:36:20+00:00",
                    "text": "I found the following thread to be apropos of discussions here: https://twitter.com/MichaelCaisse/status/1204207152237367297?s=20"
                },
                {
                    "user": "gronki",
                    "date": "2019-12-10 19:46:24+00:00",
                    "text": "But Fortran is not C++. C++ was designed to be flexible and able to\naccommodate any possible design structure in the code. Fortran is a rigid\nand limited numerical computing language which is its advantage and cripple\nat the same time. Look at all failed attempts to create any sensible\ncontainers in Fortran as it is. They are ugly and unusable. You cannot do\nit. Fortran needs standard library in 2 years or less. Generic will come in\nno less in 10 years. In 15 years nobody will be left to write or use that\nlibrary. This is exactly the attitude that says \"let this language die in\npeace\". It has to change.\n\nwt., 10 gru 2019, 20:36 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n I found the following thread to be apropos of discussions here:\n https://twitter.com/MichaelCaisse/status/1204207152237367297?s=20\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#104?email_source=notifications&email_token=AC4NA3KRJP36SWWJAPUSYZDQX7VTLA5CNFSM4JSZ6FO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGQSOHQ#issuecomment-564209438>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3N7P7BYJVW6PX2PGXLQX7VTLANCNFSM4JSZ6FOQ>\n ."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-12-10 20:23:56+00:00",
                    "text": "The real advantage of CMake is its ability to automatically resolve dependencies in modern Fortran. If we are going to have an even remotely complicated interdependencies within this library then I think CMake is a necessity and raw make files simply are not a viable option.\nAs others have said, once someone has set up the CMake files, it is really not difficult to use. At work I was tasked with writing a sort of template/skeleton for new Fortran projects to use, part of which included a CMake build system. I think that would provide a more than adequate starting point and it would then be very easy to adapt for the needs of this project."
                },
                {
                    "user": "certik",
                    "date": "2019-12-10 20:32:11+00:00",
                    "text": "I suggest let @milancurcic take the lead, setup a repository and we can discuss CMake and Makefiles in there. Let's use this issue to discuss what should actually be in the library."
                },
                {
                    "user": "apthorpe",
                    "date": "2019-12-10 20:40:11+00:00",
                    "text": "@zbeekman noted:\n\n... (I don't like CMake either, but I like it more than anything else I've tried to use in its place.)\n\nThis is my feeling as well.\n\nFYI, I haven't had time to go through this thread in any detail, but wanted to mention that I've been particularly frustrated by repeated implementing stuff in 3 main areas, and as a result, I've started working on my own \"missing\" standard library: https://github.com/zbeekman/ZstdFortranLib ...\n\nI'd add logging to that; I extended FLIBS' m_logger module with syslog-like priority but the stock module is quite usable as it is. There's a trend towards 'observability' vs unstructured logs in some sectors which might be interesting to look into, but simple logging is better than WRITE() scattered through the code. syslog and Windows Event Log support would be nice but it's probably better to achieve something simple like m_logger first."
                },
                {
                    "user": "zbeekman",
                    "date": "2019-12-11 01:30:23+00:00",
                    "text": "@apthorpe Thanks for the feedback. Yeah, logging is kind of the next feature on the list. I\u2019m just so tired of reading variables and messing around with strings.\nFYI, the way I get overloading for all kinds of each intrinsic type is through the very awesome Jin2For package. A thin extension of Jinja2 that interrogates the compiler and provides nice convenience. Templating has its advantages for generic programming when used wisely and in moderation until there is something better in the standard."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-14 23:39:37+00:00",
                    "text": "I created a repo here:\nhttps://github.com/fortran-lang/stdlib\nand bootstrapped some documents and issues.\nI will reach out directly to many of you over the next few days with some ideas and questions about getting more closely involved."
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 19:03:54+00:00",
                    "text": "Thanks @milancurcic for taking the lead on this.\nLet's start with something simple that we can all agree on, to learn and figure out how the process should work, and then we can try to tackle some of the more difficult proposals.\nIt seems the least controversial will be a subset of NumPy and Matlab (both of which use very similar API):\n\n\neig, eigh, inv, solve, det, svd, ... . A possible implementation is here: https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/linalg.f90\n\n\nsavetxt, loadtxt (NumPy: https://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html, Fortran: https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/utils.f90#L176)\n\n\nlinspace, logspace, meshgrid\n\n\nString utilities: upper case, lower case, ...\n\n\nAnd we just need to discuss the API (name, arguments, return value) and ensure it is familiar (identical or close to NumPy / Matlab / Julia, ...) and consistent with Fortran."
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 19:31:02+00:00",
                    "text": "I created fortran-lang/stdlib#10 for stdlib_linalg and eig in particular. We should be able to converge to an agreement on the API pretty quickly for eig."
                },
                {
                    "user": "aamaricci",
                    "date": "2019-12-21 10:40:04+00:00",
                    "text": "Sorry guys I lost this precious discussion and I read it only by now.\nLet me say that I find the proposal of building a standard library wonderful and I thank you all and Milan in particular for taking the lead.\nI am willing to contribute to standard library.\nFirst of all, as some of you may know, I devoted quite some effort to develop SciFortran. A project which aims to \"port\" what SciPy is for python into Fortran. The motivation is similar to what has been discussed here, although with a more scientific/math oriented goal.\nEssentially: to provide the average fortran user a \"simple\" interface to the most common task that might be required when developing on scientific project. With \"simple\" I mean something that does not make explicit use of derived data type as much as possible so that the user keep using implicit data types and arrays.  In some cases this is unavoidable of course but in most cases it can be avoided.\nThe project is open source and heavily influenced by my research activity, by older version of SciPy and by other similar projects (for which I got \"inspired\", e.g. some LAPACK interface from Certik's project :-))\nPlease feel free to use, copy, change, update, modify and whatever other action you may have in mind Scifor for the development of standard library. Scifor compiles with Cmake and try to make use of available lapack/blas/scalapack libraries present in the system (e.g. veclib, mkl, etc.): this is very important for optimisation and it is currently done also in the installation of scipy.\n[to make concrete example scipy eigh take 0.9s to work on a 1000x1000 matrix on OSX using veclib blas. Scifor used local installation of blas/lapack and took up to 5 times more for the same task. compiling against veclib blas we reached the same or better performance as python].\nUnfortunately there is essentially no documentation. (I am lazy I know).\nScifor contains already:\n\nCommon variables and physical units, colors, fonts to modify standard output\nLinear algebra: a big part of LAPACK interface, many of the utilities used in python (diag, eye, diagonal, trace, etc...). This part should also contains BLAS interface, for now it is only limited to Xgemm (as function and as operator .x.). It also includes interface to Scalapack for few methods (eigh, matrix-matrix multiplication, matrix inversion, ...). It contains also kronecker products.\nRandom number generators,  (KISS, Mersenne-Twister, etc..)\nOptimization and Root finding (interface to MinPack plus other procedures such as broyden, fzero, and other few algorithms)\nSparse Linear algebra (very basic): simple interface to P/Arpack and some Lanczos methods\nIntegration (generic interface to QUADPACK into quad, simpson, trapezoidal rule, etc..)\nInterpolation (PPPACK, CUBSPL, plus other including Numerical Recipes) 1d and 2d, linear, cubic, polynomial\nSpecial functions\nDerivatives (evaluates derivatives using increasing order finite difference methods, jacobian ,hessian, etc.)\nFast Fourier Transforms (interface to FFTPACK)\nInput/Output tools (simple save,read procedures for arrays up to 7dimensions). This is not very general indeed at least not at the level of savetxt, loadtxt. It contains some additional procedure that come useful as str which converts any standard data type into a character(len=*) of proper length. This I use a lot and is very similar to str in python.\nInput Parser: an internal data structure which parse input variables from a file or command line. all standard data type are supported.\n\nI do have some additional comments, mostly based on my experience:\n. It is important and useful to keep a modular structure so that a single part can be loaded independently of the rest.\n. There is a non-trivial issue with the automatic inclusion of the .mod files. While in c/c++ the header can be placed in suitable path of the OS, in fortran the situation is more complicated.\nI solved this by generating in Cmake a script very similar to what is used to load Ifort/MKL. Alternatively it generates an environment module file.  I did not find any better way to have automatic use of the library.\n. I think it is important to distinguish between development of intrinsic type and methods, which can import some functional programming in fortran, from the algorithms (used in different contexts). Having all in the same place is ok but in my mind these are two different problems.\nFrom my point of view, I would inspire more to Python than C/C++ in this respect.\nI am convinced that Fortran can easily reach the simplicity of python while keeping its lower level qualities.  Perhaps I can elaborate more on this.\nSorry for the very long message.\nAgain: thanks a lot for proposing this. I really really appreciate it."
                },
                {
                    "user": "certik",
                    "date": "2019-12-21 14:19:14+00:00",
                    "text": "@aamaricci thanks for the input! Let's keep the discussion going.\nI discovered your code and linked it at fortran-lang/stdlib#1 yesterday.\nI am I think in the same camp as you are --- for example with the modern Fortran Python like interface to Lapack implemented in fortran-utils, that you ended up using. I am glad you liked it! And I would like the whole of SciPy ported to Fortran, in a natural, non OO way. I have no doubts it would go a long way towards much wider adoption of Fortran. Furthermore, I want to ship this stdlib with LFortran, that would allow interactive usage in Jupyter, thus providing almost equivalent experience as SciPy (in fact I hope much better experience!).\nOthers like @cmacmackin like OO interfaces, and I think we can have them too, in addition to non OO interfaces.\nThe other aspect is that we pretty much know how to implement all of the above --- either we have already done that, or know how to do it quickly. The biggest contribution of stdlib is to agree on an interface that we all like and approve as a community and commit to support for the long run. For example, the linalg routines, that you also ended up using or got inspired by, I designed them with a few other Fortran users about 10 years ago; but that is different and not enough --- what we are doing now is to have a much wider discussion about the API, and I would love if you could also be part of this discussion, you can start here:\nfortran-lang/stdlib#23\nfortran-lang/stdlib#10\nthen, once we mostly agree on the API, we merge into our \"experimental\" modules in master. You can see the PR 23 above for an example. Then much later, once we gain experience with the API, we will propose to move from experimental to main. The bar for that will be much higher. We are still figuring out all this workflow. But I am positive we can figure out a high quality process that would allow us to deliver on a Fortran Standard Library that we all eventually agree upon."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-23 19:05:12+00:00",
                    "text": "As a counter argument to \"make everything stdlib rather than part of the standard\", here's an article: https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/\nI think there's important quality in standarizing the behavior of the most essential utilities (such as string split) over leaving them to the community."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 19:33:34+00:00",
                    "text": "@gronki the goal of stdlib is to make it the standard. What does that mean? Here are a few minimal requirements that we are striving for stdlib to satisfy (in the future):\n\nAll API must be agreed upon by the wide community\nMust be widely used in Fortran projects\nThe stdlib github repository itself must end up a successful open source project (lots of contributors, lots of stars at GitHub, ...)\nMost community will agree that stdlib is the de-facto standard including most J3 and WG5 committee members\n\nWe are obviously not there yet, as we have just started. These goals will take years to achieve. But if we achieve these (and probably there are more goals that we need to achieve beyond these) we might start calling stdlib the standard.\nThe example you posted with leftpad in Javascript did not satisfy any of the above goals: it was quite widely used, but it had little github stars, one (?) contributor, the community did not seem to agree this is the Javascript standard library, etc. So I want to make it clear, we are not trying to achieve what leftpad did. We have much bigger goals as outlined above. In fact I would argue leftpad is an example what happens if you do not have a standard library --- people start re-implementing such basic features themselves, in an unorganized fashion and then codes start depending on such not well supported libraries and it causes all kinds of problems at outlined in the blog post you linked. If Javascript included leftpad either directly in the language, or in the standard library, there wouldn't be such a problem.\nAssuming we do achieve the above goals in the future, then it will be a good time to see if some of the stdlib's more basic functionality (such as string manipulation) could be included in the standard itself, or if the Fortran standard could standardize the API of stdlib as the Fortran Standard Library. (In fact, we do not need to wait until stdlib becomes popular, we should push good ideas in this fortran_proposal repository in parallel with stdlib.) Also hopefully, stdlib will spur discussions about Fortran language improvements that would make some usage simpler."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-23 20:04:12+00:00",
                    "text": "@certik ok that made me a bit calmer. I posted a thread in the other repo to address the possible solution for packages that are too big/specific for an stdlib. I am curious what you think."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-12-23 21:14:54+00:00",
                    "text": "I can't think of any procedure that should be considered for the standard and that shouldn't be staged and implemented in stdlib first."
                },
                {
                    "user": "leonfoks",
                    "date": "2020-01-07 19:28:01+00:00",
                    "text": "Just to add my two cents, my package Coretran contains some of the things discussed at the beginning of this issue. Its interfaced, object oriented, and uses submodules.\nThere are things outside of scope of a standard library like KdTree and Shewchuks arbitrary precision geometry stuff (are these outside scope though?), but I do have a relatively fast introspection sort and dynamic arrays.\nI do use Cmake, but as @cmacmackin mentioned, I like how it handles the modern dependencies.\nI called my package Coretran because I did not want to suggest I was good enough to create a standard library! But that was the original intention I guess.\nI think contributing to a centralized 'approved' standard library is great!  Im not saying use Coretran, im willing to migrate anything over if it makes sense."
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 22:48:09+00:00",
                    "text": "@leonfoks thank you for finding this project and getting in touch with us. I put a link to it into fortran-lang/stdlib#1, where we keep a list of similar and related projects.\nIndeed, many of us (myself included) have written similar libraries that were intended as a \"standard library\", see the full list at fortran-lang/stdlib#1. And none of us are good enough to create a standard library on our own. But the difference how stdlib is developed is that we managed to create an initial community that is large enough and representative enough that we can refine the API as a community so that we are all ok with it to use it in all of our projects and with a high chance that people who were not part of the approval process for a particular feature will still like the result. We just merged in an initial workflow how new features should get into stdlib: https://github.com/fortran-lang/stdlib/blob/006bedafc0d40ff381da2bd4455f61b5e11fc2ee/WORKFLOW.md.\n(Update: we added the motivation into README: https://github.com/fortran-lang/stdlib#goals-and-motivation)\nThank you for offering to migrate over things from Coretran. Would you mind following the workflow and get your things discussed and eventually implemented in stdlib? I am looking forward to collaborating with you."
                },
                {
                    "user": "leonfoks",
                    "date": "2020-01-08 01:52:57+00:00",
                    "text": "Thanks @certik Looking forward to this project! I saw the update to fortran-lang/stdlib#1 . Its cool to see a list of the other projects too.\nI took a look at the workflow, I will start adding things and seeing what gets traction!"
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 20:18:54+00:00",
                    "text": "@leonfoks do you want to start an issue for Coretran like I just did for my old library (fortran-lang/stdlib#103)? I think there are lots of open issues that parts of Coretran would fit into, and then you can open new issues for the rest. And let's get it discussed."
                }
            ]
        },
        {
            "number": 103,
            "user": "jacobwilliams",
            "date": "2019-11-28 18:20:37+00:00",
            "title": "Identity matrix intrinsic",
            "text": "An intrinsic to define an identity matrix would be nice. For example, Matlab has this.\nSay:\nreal(wp),dimension(4,4),parameter :: I = eye(4)\nFor example, currently, to do this we have to have to do something like this:\nreal(wp),dimension(4,4),parameter :: I = reshape([1.0_wp,0.0_wp,0.0_wp,0.0_wp,&\n                                                  0.0_wp,1.0_wp,0.0_wp,0.0_wp,&\n                                                  0.0_wp,0.0_wp,1.0_wp,0.0_wp,&\n                                                  0.0_wp,0.0_wp,0.0_wp,1.0_wp],[4,4])\nRelated maybe to #102.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-28 18:59:06+00:00",
                    "text": "See also #14."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 21:37:44+00:00",
                    "text": "I agree. But well, then there is this solution: =)\ninteger :: i\ninteger, parameter :: n = 4  ! dimension of the identity matrix\nreal(wp), parameter :: I(n,n) = RESHAPE([ (MERGE(1._wp, 0._wp, i/n==MOD(i,n)), i=0, n**2-1) ], [n,n])"
                }
            ]
        },
        {
            "number": 102,
            "user": "FortranFan",
            "date": "2019-11-28 02:51:21+00:00",
            "title": "Matrix literals",
            "text": "As proposed by a reader at comp.lang.fortran: https://groups.google.com/d/msg/comp.lang.fortran/m6qz7hC4a7M/78maOb9uEgAJ\n(see the thread for further comments and discussion)\nAdding matrix literals\nThis is mostly a quality of life thing, but something like\n\n\nINTEGER, DIMENSION(2, 2) :: A = [1, 2; 3, 4]\nrepresenting the matrix\n/ 1 2 \\\n\\ 3 4 /\n\nis, to me, a lot more readable than\n\nINTEGER, DIMENSION(2, 2) :: A = TRANSPOSE(RESHAPE([1, 2, 3, 4], [2, 2]))\nThis could even be extended to more complex arrays by, for instance, repeating\nsemicolons, eg.\n\nINTEGER, DIMENSION(2, 2, 2) :: B = [1, 2; 3, 4;; 5, 6; 7, 8]\nOne issue with this syntax is of course that the values are given row major,\nwhich is different from the memory layout of Fortran an thus also the way\nRESHAPE works.\n\nAlternatively [1, 2; 3, 4] could represent\n/ 1 3 \\\n\\ 2 4 /",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-28 04:07:11+00:00",
                    "text": "Yes! I've been wishing something like this for years."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-28 15:40:20+00:00",
                    "text": "Agreed. The reshape thing is not ideal. I wish there was some way to declare a matrix that didn't require you to know that the compiler was using column major order. That always seemed to me a low-level detail that a user shouldn't have to know about."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-28 15:49:51+00:00",
                    "text": "Agreed. The reshape thing is not ideal. I wish there was some way to declare a matrix that didn't require you to know that the compiler was using column major order. That always seemed to me a low-level detail that a user shouldn't have to know about.\n\nNot sure about this.\nI wouldn't use a language if I couldn't be sure about the storage layout of higher dimension arrays.\nIt's absolutely necessary to know storage layout a priori in order to ensure memory access is contiguous and therefore efficient.\nPerformance difference between strided access and contiguous access is very significant.\nOtherwise I agree with the usefulness of matrix literals."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-28 15:57:48+00:00",
                    "text": "Sure, for performance you need to know that. But for showing a beginner how to declare a 3x3 matrix parameter it's not really that great."
                },
                {
                    "user": "certik",
                    "date": "2019-11-28 16:03:37+00:00",
                    "text": "Indeed. You need to know the memory layout to write performant code, but it should not be necessary to know the layout just to write correct code (even if slow).\n\u2026\nOn Thu, Nov 28, 2019, at 8:57 AM, Jacob Williams wrote:\n Sure, for performance you need to know that. But for showing a beginner\n how to declare a 3x3 matrix parameter it's not really that great.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#102?email_source=notifications&email_token=AAAFAWGUE4ITA6HAVQQQ4VLQV7S7ZA5CNFSM4JSOR54KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFM7NNA#issuecomment-559543988>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBGWAJ7YPPOS3JGPDLQV7S7ZANCNFSM4JSOR54A>."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-28 16:14:26+00:00",
                    "text": "Sure, for performance you need to know that. But for showing a beginner how to declare a 3x3 matrix parameter it's not really that great.\n\nAgreed, I'd interpreted your sentiment as a more general desire to completely abstract away storage order to compiler implementation."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-28 16:17:33+00:00",
                    "text": "I understand that matrix literals are for defining small matrices anyway. I\nagree that better syntax is needed.\n\nczw., 28 lis 2019, 17:14 u\u017cytkownik LKedward <notifications@github.com>\nnapisa\u0142:\n\u2026\n Sure, for performance you need to know that. But for showing a beginner\n how to declare a 3x3 matrix parameter it's not really that great.\n\n Agreed, I'd interpreted your sentiment as a more general desire to\n completely abstract away storage order to compiler implementation.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#102?email_source=notifications&email_token=AC4NA3MT33YGMME4BXXBX63QV7U6JA5CNFSM4JSOR54KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFNAVJY#issuecomment-559549095>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3PLH3FJE5AIC7H7K3DQV7U6JANCNFSM4JSOR54A>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-28 17:21:43+00:00",
                    "text": "I wish there was some way to declare a matrix that didn't require you to know that the compiler was using column major order.\n\n\nBut for showing a beginner how to declare a 3x3 matrix parameter it's not really that great.\n\nWith these things being said, and returning to the last point in the original post, there is an argument for using row-major in the literal syntax in that it is the same as MATLAB and therefore will be familiar to beginners coming from MATLAB.\nIndeed, I understand that MATLAB uses row-major syntax despite being column major storage."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-28 18:04:29+00:00",
                    "text": "MATLAB also accepts commas as column delimiters instead of spaces and this is generally recommended for readability.\ni.e. The following are equivalent in MATLAB\na = [1 2 3; 4 5 6; 7 8 9];\na = [1, 2, 3; 4, 5, 6; 7, 8, 9];\nIt is the same comma/semicolon syntax as suggested in the original post.\nAn alternative syntax not using the semicolon could be nested array literals:\ninteger :: a(3,3)\na = [[1,2,3],[4,5,6],[7,8,9]]\nbut this again raises the row-major/column-major syntax question."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-28 18:24:25+00:00",
                    "text": "I certainly think that the limitations of fixed-form source should not enter the deliberations. It's long past time for that to be eliminated (#108)."
                },
                {
                    "user": "rweed",
                    "date": "2019-12-07 16:24:46+00:00",
                    "text": "After spending several days recently typing in data to create equation of state tables, I can say from experience that anything like the MATLAB way of defining multi-dimensional arrays would be a big improvement over RESHAPE. I've never understood why you need RESHAPE if you are entering data in column major order in the first place."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-09 00:05:48+00:00",
                    "text": "I could certainly see relaxing the shape matching rules if the right side was a rank-1 array with the same SIZE as the left. I do wonder how these proposals would extend to rank 3 and greater arrays."
                },
                {
                    "user": "zjibben",
                    "date": "2020-01-04 21:09:34+00:00",
                    "text": "An existing alternative I haven\u2019t seen mentioned here is using a data statement:\ninteger :: A(2,2)\ndata A /1,2,  3,4/\nThis isn\u2019t as nice as the proposed syntax, and there\u2019s still the row/column ordering issue, but I tend to find it slightly more readable than reshape. Having everything on one line would be even better."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-04 23:21:24+00:00",
                    "text": "@zjibben wrote:\n\nAn existing alternative I haven\u2019t seen mentioned here is using a data statement:\ninteger :: A(2,2)\ndata A /1,2,  3,4/\n\nI've avoided DATA statements in any code I wrote and I've shied away from ever recommending DATA statements because it attaches the perilous \"implied SAVE\" attribute to objects in Fortran:\nFrom the standard:\n\n8.6.7 DATA statement\n..\n.. a named variable has the SAVE attribute if any part of it is initialized in a DATA statement .."
                },
                {
                    "user": "zjibben",
                    "date": "2020-01-05 19:52:50+00:00",
                    "text": "@FortranFan That is a very good point, and probably why I\u2019ve only seen it used for constant module-level data.."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-08 05:12:14+00:00",
                    "text": "Some initial thoughts. If:\ninteger,save :: xx(3,5)= reshape([&\n1, 2, 3, 4, 5, &\n10,20,30,40,50, &\n11,22,33,44,55  &\n],shape(xx),order=[2,1])\nwhere equivalent to the simpler (order= on LHS implies :\nthe type of RESHAPE above):\n\n  integer(order=[2,1]),save :: xx(3,5)= [&\n   1, 2, 3, 4, 5, &\n  10,20,30,40,50, &\n  11,22,33,44,55  &\n  ]\n\nI would be happy, although I am not sure it\nwould be what I would call intuitive to a new\nuser. Would be nice to not need the & too, but that would break a lot of other rules.\n\nALTERNATIVE 1\nNesting or grouping with brackets would look\nthe nicest, but not as explicit past three\ndegrees. for 2-D maybe something like:\n\n  integer,save :: xx(3,5)= &\n  [ 1, 2, 3, 4, 5], &\n  [10,20,30,40,50], &\n  [11,22,33,44,55],\n\nwould be nice. That would still work for\nspace dimensions and still look clean.\n\n  integer,save :: xx(3,5,2)= &\n  [ 1, 2, 3, 4, 5], &\n  [10,20,30,40,50], &\n  [11,22,33,44,55], &\n\n  [ 1, 2, 3, 4, 5], &\n  [10,20,30,40,50], &\n  [21,22,33,44,55]  &\n\nALTERNATIVE 2\nTaking some of the syntax from DATA statements could be a\ngeneral solution. Maybe instead of\n\n! fill rows using DATA statements\ninteger,save,dimension(3,5) :: gg\ndata gg(1,:)/  1,  2,  3,  4,  5 /\ndata gg(2,:)/ 10, 20, 30, 40, 50 /\ndata gg(3,:)/ 11, 22, 33, 44, 55 /\n\ncould become:\n\ninteger,save,dimension(3,5) :: gg=[[ (1,:)/  1,  2,  3,  4,  5 / &\n                                    (2,:)/ 10, 20, 30, 40, 50  / &\n                                    (3,:)/ 11, 22, 33, 44, 55 / ]]\nwhere the redundant brackets flags to use \"DATA\" format?\n\nDATA statements are so flexible and do not have problems like a limit\non the number of continuation lines and so on. The implied SAVE never\ncaused me any issues, it was the \"feature\" that you do not to have to\ninitialize all the values that made me careful with DATA statements.\n\nDIdn't do a proof on whether the synax would work generically with \ndimensions higher than space dimensions, but I will work it out if anyone \nthinks those syntax's are appealing.\n\n\nAn option to print small arrays in the same format would be nice\ntoo, like dispmodule(3f), \"A Fortran 95 module for pretty-printing\nmatrices\". (jonasson@hi.is)."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 08:49:07+00:00",
                    "text": "I could certainly see relaxing the shape matching rules if the right side was a rank-1 array with the same SIZE as the left. I do wonder how these proposals would extend to rank 3 and greater arrays.\n\nThat sounds to me like a very pragmatic solution! Since we can let multi-rank pointers point to rank-1 targets, one could similarly allow the assignment of a rank-1 array to a multidimensional array, provided, the shape of the LHS is known (so not automatic reallocation occurs).\nWe could then write:\ninteger :: array2(2, 2) = &\n  & [ 1, 2, &\n  &   3, 4 ]\n\ninteger, array3(2, 2, 2) = &\n  & [ 1, 2, &\n  &   3, 4, &\n  &&\n  &  5, 6, &\n  &  7, 8 ]\n\nI dont't think, that the other proposed forms (introducing new symbols) are much more readable than those examples. Actually, using Fortran's array-merging strategy one could even write:\n  integer :: array(2, 2, 2) = &\n      & [[[ 1, 2 ], &\n      &   [ 3, 4 ]], &\n      &  [[ 5, 6 ], &\n      &   [ 7, 8 ]]]\n\nwhich is on par with any other notations suggested so far. You would still have to remember, that Fortran has column-major ordering (so lines in the literal correspond to 'columns' in the actual array), but that is IMO acceptable."
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 15:20:12+00:00",
                    "text": "I like this syntax the most:\ninteger :: a(3,3)\na = [[1,2,3], [4,5,6], [7,8,9]]\nprint *, a\nThat's how Python does it. As @septcolor mentioned in #102 (comment), currently Fortran flattens such arrays. What is the motivation for this \"flattening\"?\nI think rethinking this and allowing the natural a = [[1,2,3], [4,5,6], [7,8,9]] syntax would be the best."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 15:34:38+00:00",
                    "text": "@certik If the assignment of rank-1 arrays to rank-N arrays were allowed, your example would  work immediately without the need for any backwards incompatible changes. As long as the shape of the LHS is unambigous, the flattening of the literal of the RHS won't be an issue.\nWe would only have troubles with automatic reallocation, such as\ninteger, allocatable :: a(:,:)\na = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nas here it is impossible to find out, how RHS should be reshaped to match LHS. For those cases, the compiler would have to emit an error and stop."
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 15:39:06+00:00",
                    "text": "I see. I still think removing this automatic \"flattening\" would help. What is the motivation for it? We can introduce a function flatten, that can do this flattening if you really want it:\na = flatten([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nBut otherwise it should not flatten by default in my opinion."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 15:51:22+00:00",
                    "text": "Well, removing the flattening would be backwards incompatible, as the following code snippet won't work any more:\nprogram test\n  implicit none\n\n  integer, allocatable :: a(:), b(:)\n\n  a = [1, 2]\n  b = [a, a]\n  print *, b\n\nend program test"
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 16:07:15+00:00",
                    "text": "True. But this would work:\nprogram test\n  implicit none\n\n  integer, allocatable :: a(:), b(:)\n\n  a = [1, 2]\n  b = flatten([a, a])\n  print *, b\n\nend program test\nI agree since this is backwards incompatible, we might not want to do that. But if the only motivation for automatic flattening is backwards compatibility, then it would seem this was a bad design decision long time ago."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 16:23:42+00:00",
                    "text": "Unfortunately, it is not just flattening, but also automatic merging.  The assignment\nb = [[-3, 2, 9], [1, 2]]\n\ncurrently works (provided b is a rank-1 array), but it would became a syntactical non-sence if the braces would open/close ranks as they do in Python.\nI agree, that the current syntax is weird and I have no clue, why it was introduced. But I don't think we have any chance to delete it from the language. So, the best compromise IMO is still the assignment of rank-1 arrays to rank-N ones without the need for a reshape, as suggested by @sblionel ."
                },
                {
                    "user": "elecprog",
                    "date": "2020-11-02 18:04:03+00:00",
                    "text": "But I don't think we have any chance to delete it from the language.\n\nGiven that I used this rather recently, that chance is indeed rather slim. It's convenient to concatenate arrays, although an intrinsic function would have been the better choice back when that syntax was introduced.\nI'm still keen on doing something similar to Matlab or Julia as in my initial proposal (I'm the original comp.lang.fortran poster), but I haven't yet found a better alternative.\nI'd be weary of introducing anything that doesn't also scale to rank 3 (or higher) arrays, though."
                },
                {
                    "user": "certik",
                    "date": "2020-11-02 18:36:38+00:00",
                    "text": "@elecprog thanks for the feedback and for the proposal. I think there is still an opportunity here to do something, but we have to figure out how to do it to satisfy all the requirements/issues stated in this thread."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-11-03 01:45:11+00:00",
                    "text": "When I think of all the capabilities available in READ() including list-directed and implied DO constructs if there were some equivalent of a \"here\" document in Fortran it woud allow for inputting small arrays but also text blocks without having to use continuation characters and quotes as well.\ninteger :: a(3,4) <<< read(*,*)(a(i,j),i=1,3,j=1,4)\n   1  2   3   4\n   5  6   7   8\n   9  10  11  12\n>>>\n\ncharacter(len=:),allocatable :: text(:) <<< read(*,'(a)')text\n   This is the help text\n   for my\n   program\n>>>\n\nAlmost no new syntax, useful for small arrays but maybe more so for text; would be really nice to have some kind of block comment too, maybe just\n<<<\n   a block of\n   text\n>>>"
                },
                {
                    "user": "elecprog",
                    "date": "2021-09-13 07:10:39+00:00",
                    "text": "Maybe we could take some inspiration from the syntax introduced in Julia v1.7 (see NEWS.md).\nA first thing to note in Julia's case, [1, 2, 3] is a (column) vector (in Fortran terms dimension(3)) and [1 2 3] is a row vector (in Fortran terms dimension(1, 3)).\nA ; concatenates in the column direction, i.e. [1; 2; 3] == [1, 2, 3]. Since v1.7 this idea is extended to repeated semicolons concatenating in the next dimension, thus [1;; 2;; 3] == [1 2 3] (the row is the second dimension), etc.\nJulia does not allow mixing of commas and semicolons, but it does allow spaces and semicolons, giving for example: [1 2 3; 4 5 6] == [[1 2 3]; [4 5 6]] thus the matrix shorthand is nothing but the concatenation of two row vectors along the column (= first) direction. Another way to write the exact same matrix would be [1; 4;; 2; 5;; 3; 6] == [[1, 4] [2, 5] [3, 6]] where we write the matrix as the horizontal concatenation of three column vectors (which evidently is also how the memory layout of Fortran thinks about matrices).\nWhich is also another motivation of the automatic flattening as this is also how it's written in mathematics (using newlines for concatenation in the column direction instead of semicolons \ud83d\ude09)\nFortran already has a concatenation operator // which could extend to /// etc. But I do not yet know how if feel about [1 2 // 3 4] == [1 // 3 /// 2 // 4]."
                }
            ]
        },
        {
            "number": 101,
            "user": "jacobwilliams",
            "date": "2019-11-27 23:00:27+00:00",
            "title": "Sorting",
            "text": "I wonder if sorting should be built into the language? This is such a fundamental thing that currently take a staggering amount of code to make it work with all intrinsic types and user-defined types (see for example here). I think C++ has sorting built in to its standard library.\nFeatures:\n\nsort ascending or descending\nit works for all intrinsic numeric types (integer(kind=*) and real(kind=*))\nhow about also a \"sort x, while carrying y along\"? That's always nice to have. See, for example, isort from SLATEC. Or even a variadic \"sort x while carrying any number of other arrays along\". And any of them can be any combination of types.\nmaybe also indexing?\nhow about lexical sorting? Including \"[natural sorting]?(https://en.wikipedia.org/wiki/Natural_sort_order)\".\n\nI think it goes without saying that any well-designed future generic/templating feature should also allow one to apply a sorting algorithm (either one from a third-party library or maybe even the hypothetical intrinsic one) to a user-defined type with a minimum of code.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-28 04:05:43+00:00",
                    "text": "@jacobwilliams indeed. We had to implement our own (https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/sorting.f90) and it's not very efficient. This would be a great addition."
                },
                {
                    "user": "rweed",
                    "date": "2019-12-07 16:07:41+00:00",
                    "text": "agree 100% about the need for sorting routines. Since there are numerous examples of quicksort etc. in the literature, implementing this in a standard library should be a no-brainer. I would point to the code in Robin Vowels excellent book \"Algorithms and Data Structures in F and Fortran\", Dick Hanson and Tim Hopkins book \"Numerical Computing with Modern Fortran\", and Ajen Markus's FLIBS implementation of quicksort. Also, if Robin Vowels is following this and the other issues on this site, I would love an updated version of your book focused on Modern Fortran implementations of the algorithms and data  structures with additional coverage of things like octrees etc. I would buy it yesterday."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:02:28+00:00",
                    "text": "Let's implement good sorting routines in stdlib (#104). If we make stdlib successful, that would get us 90% there. There might be some language features that would be helpful, but we can have that discussion later."
                },
                {
                    "user": "leonfoks",
                    "date": "2020-01-07 19:53:16+00:00",
                    "text": "I have a decent introspection sort in Coretran.\nRight now it's interfaced and operates on contiguous memory primitive arrays,  real32, real64, int32, int64. I have argsort too.  I went further than a quicksort to add robustness for edge cases.\nHere's the description from my module.\n!! Uses an introspective sort on a set of numbers. See this \"http://www.geeksforgeeks.org/know-\nyour-sorting-algorithm-set-2-introsort-cs-sorting-weapon/\" for more information\n!!\n!! To begin, a quicksort with a median of three pivot is used until the size of the array is less than 16.  At this point, an insertion sort is used to reduce cache overhead and tail recursion.\n!! Unfortunately, a quicksort is not ideal for sorted/almost sorted arrays or arrays with duplicate values.  Therefore if the number of iterations exceededs a threshold, a heapsort is used instead.\n!! This provides a robust sorting algorithm that is still very fast for almost sorted arrays.\n!!\n!! In this implementation, the quicksort and heapsort are unstable sorts. A stable merge sort is therefore provided as an alternative but it has an order(N) memory overhead.\n!!\n!! Often, the numbers wish to be maintained in their given order, so with an O(N) memory overhead we can sort an integer array instead by calling argsort()\nThe stable merge sort doesn't really matter for numbers, will be important if used for arbitrary types though."
                },
                {
                    "user": "leonfoks",
                    "date": "2020-01-07 20:02:12+00:00",
                    "text": "Also related, maybe it should be a separate issue.\nShould searching algorithms be part of the stdlib?  Binary search or interval search?\nI use a binary search for a lot of functions in Coretran (again interfaced for the different primitives), including KdTree, the dynamic arrays, inserting into a sorted list etc."
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 20:22:38+00:00",
                    "text": "I think searching algorithm would also fit into stdlib."
                }
            ]
        },
        {
            "number": 100,
            "user": "jacobwilliams",
            "date": "2019-11-24 17:06:28+00:00",
            "title": "File system and directory access",
            "text": "I've always considered it a major defect of Fortran that it doesn't seem to know anything about directories or the file system. I think some people consider this a feature of sorts, but it's hard to imagine nowadays any complicated program that doesn't need to know about these things. So we all resort to compiler extensions (e.g. Intel's portability library is great) or hand-rolled hacks or platform-specific system calls. It would be nice if a lot of this was standardized. Just of few of the things we need:\n\ndoes a directory exist? (I think Intel has an extension for this).\ndelete a file or directory (I know for files we can open and then close(..status='delete') but that is just so non-modern).\ncreate a directory\nlist all the files in a directory\nget/set the current working directory\nrename a file or directory\n... others?\n\nHaving these standardized so they will work on all platforms and with all compilers would be a big improvement over the current situation.",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-07 22:56:35+00:00",
                    "text": "This should all become part of stdlib."
                }
            ]
        },
        {
            "number": 99,
            "user": "jacobwilliams",
            "date": "2019-11-24 14:21:52+00:00",
            "title": "Extension to EXECUTE_COMMAND_LINE",
            "text": "It would be nice for some use cases if EXECUTE_COMMAND_LINE intrinsic had some kind of process ID optional output that could be used to check the status (and maybe also kill) a process executed asynchronously via wait=.false.\nSo something like this:\ncall execute_command_line('my_long_process.exe',wait=.false.,pid=pid)\ndo\n  call cpu_time(t1)\n  call do_some_stuff()\n  if (process_still_running(pid)) then    ! a new intrinsic\n    call cpu_time(t2)\n    if (t2 - t1 >= max_time_to_wait) then\n      call kill_process(pid)    ! a new intrinsic\n      exit\n    else\n      t1 = t2\n    end if\n  else\n    exit\n  end if\nend do",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "marshallward",
                    "date": "2019-11-24 16:52:05+00:00",
                    "text": "It's been a long wish of mine to have some sort of standardized POSIX support within Fortran, either natively or through a public library.  Something like that would go a long towards supporting native process control, along with a wide range of other resources."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 00:52:23+00:00",
                    "text": "POSIX is dead. Intel Fortran supports a lot of POSIX routines, but it;'s hardly worth using them.\nThe problem I see with the proposal here is that it assumes host system support for this sort of concept. I implemented EXECUTE_COMMAND_LINE for Intel Fortran and it was complex enough across the various platforms to do the waiting properly. The Fortran standard tries not to tie itself down to implementation details. I might be able to see some sort of ID-based thing like asynchronous I/O, but requiring the ability to kill an asynchronous task seems a stretch."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-30 16:07:41+00:00",
                    "text": "I'm not sure what you mean when you say that POSIX is dead, and perhaps it's not what I'm actually suggesting.  All I meant was that I would like access to the lower level OS operations and resources like file handlers, process IDs, and system calls.\nGreater access to these resources would enable development of things like greater subprocess control without requiring extensions of the language."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 16:19:13+00:00",
                    "text": "The Fortran interfaces to POSIX were abandoned by the POSIX committee years ago, and are at the F77 level.\nThe Fortran language tries very hard to avoid baking in host environment aspects. Things such as \"subprocess\" are platform-specific. I know there is a general tendency to think that UNIX and Windows are the entire world, but they are not.\nYou already have access to lower-level APIs in most compilers, and you would probably end up spurning any standard interface for the more fine-grained access the OS offers in most cases."
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 18:09:20+00:00",
                    "text": "@sblionel I had exactly this discussion with a few colleagues recently. Besides HPC (mostly some flavor of Linux/UNIX), Linux, Windows, macOS and then platforms like Android, iOS --- all of which have a file system and processes (as far as I know) --- what are some other common platforms that Fortran users are running on? Is there a Fortran platform that does not have a filesystem, or does not have processes?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 20:19:07+00:00",
                    "text": "It's not lack of a file system that's the issue - Fortran pretty much assumes there is one in how it defines OPEN/CLOSE/INQUIRE, though it avoids being specific. Process control varies a lot. In addition to Windows, MacOS and UNIX/Linux systems, Fortran is also used on CrayOS and OpenVMS. There may be other platforms that don't spring immediately to mind.\nBut the fundamental issue is that there is a strong desire to keep the standard away from specifying such low-level details as the language (and programs) have a long life and technologies change. For example, a few years ago we rejected a proposal to add a way to specify allocation from \"fast memory\", since we knew this was a short-term thing.\nMy personal opinion is that building low-level stuff into the language is a waste of effort better placed elsewhere. It's not as if you can't do all these things already with interfaces to system APIs, and my experience is that most applications want to go beyond what things built-in to the language could offer."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-01 04:15:20+00:00",
                    "text": "I don't see this as a low-level thing as far as a user of the language is concerned. We have the ability to start a process. It is logical that we should have to ability to check it and end it. Sure the internal details will vary for different platforms. Python certainly has the ability to kill processes, and I'm pretty sure that Python runs on as many or more platforms as Fortran (certainly more than Intel Fortran) so this is pretty much a solved problem as far as I'm concerned.\nFrom my point of view, the current asynchronous option for execute_command_line is basically useless. I can't imagine a situation where I would want to start a process, and then just hope for the best that it finishes.\nWe can, of course, do it with interfaces to system APIs (this is what I do), but then we have to write a massive amount of code that is different for different platforms. I think it's better to make the compiler writers do that than the users. :)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-01 20:42:00+00:00",
                    "text": "This seems like a perfect candidate for inclusion in #104."
                }
            ]
        },
        {
            "number": 98,
            "user": "certik",
            "date": "2019-11-23 19:07:01+00:00",
            "title": "Proposal For J3 Committee Rules",
            "text": "Problem\nThe J3 committee currently does not seem to have written down rules how it operates, how a proposal can be submitted (and what requirements it needs to satisfy), how and when it will be considered, and the committee currently does not provide official feedback why a proposal got rejected. Goals:\n\n\nNot waste precious committee time and not delay 202X standardization\n\n\nRespond to every proposal (currently the committee sometimes ignores a proposal)\n\n\nGet a wider community discussion around every proposal (currently the committee sometimes advances a proposal without proper discussion with the wider community or even the committee itself)\n\n\nProposal\nI am attaching a proposal to improve how the J3 committee operates in order to make it a lot more efficient and achieve the above goals. At the same time the proposal is not radical and only requires a few small changes to how the committee operates and thus might have a good chance of actually being adopted.\ncommittee_workflow.txt\nI already discussed this proposal with about 7 people on the committee, and the feedback I am getting is either supportive, or a request for a wide discussion about this to see if we can arrive at a consensus.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2019-11-25 16:15:03+00:00",
                    "text": "Thanks Ondrej, I support this proposal. At this time I don't have anything to add to it, but I'd like to express a few observations and open-ended questions.\n\nAs a Fortran application developer of 13 years, I found the committee quite removed and opaque, something between a benevolent mythical creature and an urban legend. Over the past few years, I've learned a lot from you, Steve, and few other members about how it works. Only recently I discovered that anybody can join the J3 mailing list, and I did. My point being, even though the J3 mailing list was publicly open, it wasn't obvious to me. It's possible that so many other people that would otherwise want to participate or just read aren't aware of it.\nNow that I understand better how it works, it makes sense why it's opaque and why the progress is so slow:\n\nIt's quite difficult to join -- be an alternate to an existing member, or pay membership to join as self.\nIt's also difficult to remain a member -- don't miss more than one meeting in a row. For many of us with busy schedules and/or lack of budget, it just doesn't work even if the good will is there.\nDiscussions via mailing lists and voting in meetings. This worked well a few decades ago, there are much better development models nowadays. This repo is a great example of one aspect of such development.\n\n\nI understand that the ultimate bottleneck is the number of compiler developers to implement features, however if the committee worked more openly and closer to the community, the community could grow and more compiler developers could join or come about by learning how to do it.\nLike @FortranFan likes to ask \"for whom Fortran?\", I think we should also ask \"for whom the Fortran Standards Committee?\". At a time when various flavors of FORTRAN were rampant in the wild, standardization made sense. I also understand that large enterprises put a lot of trust to something with an ISO stamp on it. However, does this model best serve the community, and even large enterprises nowadays? Should we look at some examples of productive language development teams like Python, Go, or Rust? Yes, they're backed by large corporations, but so is Fortran (Intel, Cray, IBM, NVIDIA etc.).\n\nAnyhow, I ramble and don't mean to hi-jack the topic further. I didn't say anything that wasn't said before, but I think they're conversations we need to have. I'm beyond grateful for the committee's and compiler developers' hard work and the way Modern Fortran has evolved. Both my research and business are in large part thanks to it, and I'm sure I'll be a happy Fortranner for years to come. However, let's keep bringing up the conversation and reassessing the best way going forward.\nIf I'd pull out anything specific to this proposal, my recommendation for the committee would be to make it easier for people to participate, specifically:\n\nLower the requirements for becoming a member and remove the requirement for physical attendance of meetings.\nAdopt a publicly open and online venue for language development. This repo is an essential step toward such venue."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-27 22:18:41+00:00",
                    "text": "A J3-hosted instance of Discourse (https://discourse.org) might be one option for an online venue for general discussion."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 22:38:46+00:00",
                    "text": "@jacobwilliams Yes, that might also work: we could use Discourse for a general discussion, and this GitHub repository to keep track of technical issues for each proposal and to collaborate (using PRs) on new proposals (that was my original intention). In terms of priorities, this GitHub repository, while not perfect, does give us enough organization for now, and I think the highest priority is to set the J3 committee rules how it will consider the proposals that we can then start submitting."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 01:14:01+00:00",
                    "text": "Many of the more annoying rules are forced on J3 by INCITS. (By the way, one can miss two meetings in a row before your membership is in jeopardy - you have to miss three in a row to lose membership, and attendance by any of your alternates counts.)\nThe J3 email list doesn't tend to get a lot of use between meetings, other than questions about what the standard says about some particular usage.\nINCITS/ANSI/ISO have a lot of rules for how standards committees operate. J3 actually flouts some of them (for example, the J3 web site is technically not allowed) and we try to make things as easy as we can.\nAs for considering proposals, that's simple. Write and submit a paper, and you just need  the template and get a J3 member to upload it when you have it done. All papers submitted are at least looked at at the next meeting (unless we overlook something, which happens but is rare.)"
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 14:49:54+00:00",
                    "text": "All papers submitted are at least looked at at the next meeting (unless we overlook something, which happens but is rare.)\n\nFrom my very short experience at the committee this is unfortunately not true. However, your word is enough for me and if you say that this is honestly just an oversight, then I believe it.\nThe confusion is out there unfortunately about this. See this recent question and the follow up discussion:\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-November/011732.html\n\nAs I said, your word is enough for me, that all we have to do is submit proposals. And so we will do that for the next meeting. We plan to submit 3 to 5 proposals for some of the highly requested features in this GitHub repository.\n\nThe main issue is however not resolved. We need to have written down rules how the committee operates. Does anyone have a link for the INCITS/ANSI/ISO rules for the J3 committee? I searched for them and couldn't find it."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 16:31:12+00:00",
                    "text": "The rules are for all committees under INCITS (J3) and ISO (WG5).\nhttp://www.incits.org/standards-information/policies\nhttps://isotc.iso.org/livelink/livelink?func=ll&objId=4230450&objAction=browse&viewType=1\nHappy reading!"
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 18:11:14+00:00",
                    "text": "@sblionel thanks a lot! I am going to study this thoroughly before proposing how to move forward."
                }
            ]
        },
        {
            "number": 97,
            "user": "certik",
            "date": "2019-11-23 18:56:30+00:00",
            "title": "Standardize common tasks even if they are simple to implement",
            "text": "A common sentiment against standardizing relatively simple routines for common tasks such as diag (#14), string manipulation such as split (#96) and other similar proposals is that such features are simple for users to implement themselves and as such are not worth putting into the standard.\nThe counter argument is that if simple things are not standardized, then every user reimplements them in slightly incompatible ways over and over again, and it slows down productivity. As an extreme example, C++ follows this approach also, and did not standardize the syntax for multidimensional arrays (the language itself provides enough primitives for users to implement their own) and as a result C++ has dozens and dozens of incompatible array implementations.\nFortran, unlike C++, has standardized such \"simple\" things as multidimensional arrays, special functions, and everything else that is needed in practice for numerical computing.\nIt would be nice to develop general guidelines of what features are worth standardizing and which not, so that we do not need to repeat such arguments in every issue.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "marshallward",
                    "date": "2019-11-23 22:58:53+00:00",
                    "text": "I think my comment in #96 about consideration of a standard library might be more appropriate to raise here.\nI know that the C standard library developed more historically than by design, but I think that C's approach has allowed its language to stay compact, while letting libc deal with implementation of tasks such as the ones you describe.  I'm not familiar with C++, but it seems like they've also gone in a similar direction.\nI could see a standard library also offloading many of these discussions out of the Fortran discussion and into, say, a group devoted to such a library.  I could also imagine a standards-defining implementation (glibfort?) alongside vendor implementations, who could focus on optimizations suited for their target platforms.\nIt could also clarify exactly what can and cannot be done with Fortran itself.  If a particular intrinsic cannot be written in Fortran, then it's likely that the language either needs an extension, or is a task that one probably ought not be doing in Fortran.\nTo address your points, a standard library would help to achieve your goals:\n\n\nThey would not appear in the standard, nor would the committee need to deliberate over them\n\n\nImplementations would vary, but interfaces would not.  And in all likelihood there would not be many more implementations than there are compilers.\n\n\nA standard library could afford to be more nimble, as one could trial new libraries alongside existing compilers.  As it is, there's a big learning curve to add anything to any Fortran compiler.\n\n\nIt would help to delineate the guidelines that we seek on what ought to be a language feature, an intrinsic, or what should sit in an external library.\n\n\nI could list the various things that I would like to see in such a library, but I'll hold my tongue for now \ud83d\ude1d."
                }
            ]
        },
        {
            "number": 96,
            "user": "gronki",
            "date": "2019-11-22 13:23:34+00:00",
            "title": "list of needed string utilities",
            "text": "Many will disagree, but I think Fortran strings (character(len = :), allocatable) are pretty dope for a low-level language. However, lack of standard utilities to handle them is pain. Adding a few utilities would be an extremely easy way to highly increase the value of the language.\nI suggest the following format for proposals:\n\nname of the utility\nshort description\ndoes it exist in other languages\nproposed example of usage",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-11-22 13:28:33+00:00",
                    "text": "split\nGiven a separator, splits the string into some form of array.\nMost languages have some form of that utility. Example in Python:\n\nIn [1]: \"i am a sheep\".split()                                                                  \nOut[1]: ['i', 'am', 'a', 'sheep']\n\nIn [2]: \"i am a big sheep\".split('big')                                                         \nOut[2]: ['i am a ', ' sheep']\n\n\nThere are other possible ways for it to work, just showing one:\n\ncharacter(len = 16) :: arr(10)\ncall split(\"i am a sheep\", arr)\ncall split(\"i am a big sheep\", arr, delim = \"big\")"
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-22 14:14:15+00:00",
                    "text": "Being a Fortran programmer, I like my programs to parse user config files as case-insensitive where possible. So most of my programs have an upperStr routine included.\n\nupperStr(...)/lowerStr(...)\nConvert a character string all to upper/lower case\nyes\n\n\ncharacter(len = 11) :: myString, myStringUpper\nmyString = \"Hello World\"\nmyStringUpper = upperStr(myString)"
                },
                {
                    "user": "rweed",
                    "date": "2019-11-22 14:16:49+00:00",
                    "text": "I think a new intrinsic module (ISO_FORTRAN_STRINGS) was proposed for F202x that included split along with some other new string routines (extract, insert, replace etc.)\nLast time I looked on the J3 site it appears thought that only split has survived.  I think this was proposed to bring some of the functionality in the old VARYING_STRINGS module into the mainline standard. I would be interested in hearing from the committee menbers on the status of this since its one of the few things I see proposed for F202x I would use immediately if available."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-22 14:21:44+00:00",
                    "text": "A broader question may be whether Fortran should consider including a standard library.  String manipulation would be a natural component of such a library."
                },
                {
                    "user": "rweed",
                    "date": "2019-11-22 14:29:17+00:00",
                    "text": "See https://j3-fortran/org/doc/year/18/18-259r2.txt for the original proposal."
                },
                {
                    "user": "rweed",
                    "date": "2019-11-22 14:31:00+00:00",
                    "text": "Oops. j3-fortran.org not j3-fortran/org"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-22 14:51:26+00:00",
                    "text": "split\n\n\nReaders may note Part 2 of the Fortran standard, \"Varying length character strings\" which is slated for deletion.\nIn response, there was a proposal by J3 to include certain intrinsic procedures to Part 1 of the Fortran standard: see US03 in that link.\nHowever WG5 decided at the Tokyo meeting earlier this year to only consider SPLIT for Fortran 202X, here's where it stands at present: https://j3-fortran.org/doc/year/19/19-254r2.txt"
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-22 14:51:52+00:00",
                    "text": "A broader question may be whether Fortran should consider including a standard library. String manipulation would be a natural component of such a library.\n\nSorry, off-topic, but how is the current set of intrinsic procedures not a standard library? Sure, it's not called standard library in the standard, and it's available by default in the global namespace, but otherwise I can't tell the difference.\nI use the term standard library throughout my book to refer to the set of intrinsic procedures and modules. This term is easier to understand to the broader audience."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-22 14:57:57+00:00",
                    "text": "I would have said that a standard library could, for example, define a function that does not require an extension of the language itself, and could (in principle) be something that could be implemented in Fortran.  In the case of string manipulations, it could help to delineate operations which are currently tedious vs impossible to implement.\nBut I definitely agree that this is potentially off-topic and I somewhat regret the comment.  Apologies for the distraction."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-23 00:35:59+00:00",
                    "text": "https://j3-fortran.org/doc/year/19/19-196r3.txt is the latest paper on this. There was some opposition to doing even this much. My own preference would have been to do more. The prevailing notion was that procedures that are straightforward to implement by users don't need to be intrinsics. I would like to see this revisited for 202Y.\nOn a semi-related note, see https://j3-fortran.org/doc/year/19/19-197r3.txt , which I worked on."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-23 02:53:19+00:00",
                    "text": "Thanks for the answer. It would be awesome if this could be revisited. The\nattitude that functions easy to implement should not be standardized is in\nmy opinion absolutely detached from reality and outrageous. Keeping my\nfingers crossed for your (and others) efforts to push though improvements\nin Fortran string handling!\n\nsob., 23 lis 2019, 01:36 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n https://j3-fortran.org/doc/year/19/19-196r3.txt is the latest paper on\n this. There was some opposition to doing even this much. My own preference\n would have been to do more. The prevailing notion was that procedures that\n are straightforward to implement by users don't need to be intrinsics. I\n would like to see this revisited for 202Y.\n\n On a semi-related note, see\n https://j3-fortran.org/doc/year/19/19-197r3.txt , which I worked on.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#96?email_source=notifications&email_token=AC4NA3MNNH6C3AXEI3OYPWLQVB3G7A5CNFSM4JQQTFP2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEE7IBHA#issuecomment-557744284>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KLHCPZ5ESQIH4LO3TQVB3G7ANCNFSM4JQQTFPQ>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-23 03:59:38+00:00",
                    "text": "@sblionel wrote:\n\nhttps://j3-fortran.org/doc/year/19/19-196r3.txt is the latest paper on this. ..\n\nAs I commented in #96 (comment),  the current state of development of a new SPLIT intrinsic appears instead to be this."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-23 04:33:40+00:00",
                    "text": "@sblionel wrote:\n\n.. There was some opposition to doing even this much. My own preference would have been to do more. The prevailing notion was that procedures that are straightforward to implement by users don't need to be intrinsics. I would like to see this revisited for 202Y.\n..\n\nCan't help but go OT: the basic need for a standard is for the widest group of practitioners to have\n\n\na standard name e.g., is a procedure to be named REMOVE or ERASE;  SPLIT or STRTOK or TOKENIZE, etc.!?\n\n\na standard interface e.g., subroutine or a function; what is the list, order, naming, and type, kind, rank of method parameters?\n\n\nstandard documentation and dissemination of method characteristics.\n\n\nfor the most commonly needed instructions.\nConsidering so much of information to be processed in the arena of scientific and technical computing is also in the form of strings, the utilities for string manipulation are of foremost importance.\nThat such an elementary consideration got voted over yet again at Fortran meeting #219 places Fortran at such a disadvantage.  The question remains: For Whom Fortran?"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-23 15:18:14+00:00",
                    "text": "Wow, these SPLIT proposals are really... um... requiring of more time in the oven... So, it's going to return the tokens with a bunch of extra padding spaces? All because we can't have a decent string class? That is just terrible. And to get even this is requiring years of debate? Is this really the best we can hope for?\nHow can we liberate Fortran from the Fortran committee?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-23 15:24:38+00:00",
                    "text": "You could join the committee, or at least submit some proposals that flesh out your ideas.\nThat SPLIT proposal was the work of a day or two, and went through some rather major changes, A big part of the problem is the inability to have an array of different-length strings, but one can deal with that by trimming. To do more would require a major feature we're not going to do this time around."
                },
                {
                    "user": "certik",
                    "date": "2019-11-23 18:48:48+00:00",
                    "text": "And to get even this is requiring years of debate? Is this really the best we can hope for?\nHow can we liberate Fortran from the Fortran committee?\n\n@jacobwilliams When you write criticism, please follow the Code of Conduct. Trust me, everybody on the committee and especially @sblionel has heard such sentiment before and you will not achieve any change just be repeating it, the only outcome will be that the committee members will not want to participate here.\nThat being said, I agree with what you are (I think) trying to say. But the only way to improve things is to join the committee --- I asked you a few times and my invitation stands: please consider joining the committee, we need help. If you cannot join the committee, then the best way you can help is to constructively discuss things here and help draft proposals.\nFor this process to work, the committee must eventually do a few changes how it operates. One is to open up the discussion process and I think we have been very successful with this GitHub repository and the committee, as far as I can tell, is supportive of this effort. That's just the technical part, but it's a huge improvement. I know that you want a lot more changes and I do too, but again, we can sit and complain, or we can get to work on improving this process.\nThe next step is to make the committee's work transparent in how it decides which proposals get considered and to give feedback why a proposal was not accepted. I am working on this too, see #98.\nSee #97 for a discussion about standardizing \"simple\" things."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-24 14:09:11+00:00",
                    "text": "@certik Sorry, no offense was intended. My somewhat tongue-in-cheek comment wasn't intended to be a personal attack on anybody. I was only referring to the ISO process. I agree 100% with what you are saying, and applaud your efforts here."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-24 14:57:02+00:00",
                    "text": "Back to original topic. Here's one I use all the time:\n\nstring_replace\nReplace all occurrences of one string with another\nYes, Python has this:\n\n>>> 'aaaa'.replace('a','bb')\n'bbbbbbbb'\n\nSomething along these lines:\n\ncharacter(len=:),allocatable :: str\nstr = 'aaaa'\ncall string_replace(str,'a','bb')\nwrite(*,*) str ! writes bbbbbbbb"
                },
                {
                    "user": "certik",
                    "date": "2019-11-24 20:11:05+00:00",
                    "text": "@jacobwilliams no worries, thank you for contributing here!"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-27 18:28:17+00:00",
                    "text": "@certik wrote:\n\n..\nThat being said, I agree with what you are (I think) trying to say. But the only way to improve things is to join the committee --- I asked you a few times and my invitation stands: please consider joining the committee, we need help. If you cannot join the committee, then the best way you can help is to constructively discuss things here and help draft proposals.\n..\n\n@certik and everyone interested in advancing Fortran:\nPlease see a similar discussion thread on the unmoderated platform of comp.lang.fortran via this link  and this one.\nWith respect to the point about joining the committee, please first consider the following:\n\n\nWhat appears is a crucial difference between joining a working committee of a national body like the so-called \"J3 committee\" for US versus the international one of WG5 with respect to all the decision-making control and influence that is effectively held by WG5 with respect to the Fortran standard.\n\n\nReaders need to keep in mind the J3 committee as a US national body can have >7 billion members from all over the world, practically all of humanity, and develop fully worked out proposals for all the features that one can ever contemplate for a programming language (Namespaces; Generics; Exception Handling; Standard Containers for strings, dictionaries, trees, etc.; Object-Oriented enhancements, Type-safe enums, and on and on) .\n\n\nJ3 can then present all those proposals at a WG5 meeting which presently comprises 3 national bodies of US, UK, and Japan only.  But if the other two national bodies - usually one representative each - happen to think all these features are not of any interest to them for whatever reason (their focus on strict numerical performance only, compiler vendor reluctance, bad mood, luddite, etc.) , each and every one of those proposals can get rejected (or deferred to an unspecified future Fortran revision in year 20YZ) by a vote of 2-1.  And which can effectively mean the vote of 2 people against the rest of humanity.\n\n\nThe bulk of feature developments occurs at physical 5-day meetings held by the J3 committee typically in Las Vegas NV on working days a few times a year (usually two).  Re: this arrangement, consider the constraints expressed by @rweed in that comp.lang.fortran thread, \"having to use our own personal time/money or beg our employers to support a trip to Las Vegas or elsewhere. If I told my boss I wanted him to pay for a trip to Las Vegas to participate in a Fortran standard committee meeting he would kick me out of his office.\"\n\n\nThus when readers such as @jacobwilliams are invited to join the committee and they accept the invitation, that can be remarkably beneficial to the quality and quantity of proposals by J3 but that might come about at possibly great personal cost (time and/or finances and/or relationships given the Vegas location) to these new members.\nBut all that effort can yet FAIL ENTIRELY to bear any fruit and can potentially make NO difference to the state of the Fortran language as constrained it is by the ISO IEC standard and whose content as well as the pace of change is completely controlled by WG5, as explained in point 3 above.\nIt can literally take DECADES and DECADES for the Fortran standard to have the simplest of features such as a string utility like SPLIT or a type-safe ENUM, facilities that pop up cleanly and efficiently in other languages such as Python (look at all their enhancement proposals), C++, C#, Julia, etc. in a matter of months or a year.\nSo how much time and effort can Fortranners afford to spend on developing this language?  How long can the practitioners wait for the language to get the features they need in their coding?\nIn effect, the arrangement with Fortran and WG5 is not all that different - philosophically speaking - from trying to join UN to achieve world peace.\nConsidering all this, the statement \"How can we liberate Fortran from the Fortran committee?\" by @jacobwilliams in #96 (comment) should really resonate with every persevering practitioner of Fortran."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 18:45:21+00:00",
                    "text": "@FortranFan what you and @jacobwilliams said resonates strongly with me also. All I am saying is that we need to work as a team, and together with the Fortran committee (both J3 and WG5). We need to discuss these things without alienating anyone and then come up with a constructive solution. As I said, there are many many steps towards fixing these. First is to even have a discussion (fixed by this GitHub repo). Second is to have rules and a streamlined process in the J3 committee (proposed fix in #98). Third is to have a discussion in WG5 --- I haven't been to any meeting yet, so I don't know yet what (if anything) needs to be improved there. Then the whole process must be streamlined, hopefully sped up (#36), etc. I don't have any silver bullet, I don't think there is one."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-27 18:56:07+00:00",
                    "text": "Wow - where to begin. There is quite a bit of @FortranFan 's post that is incorrect.\nJ3's membership is open to anyone, but when J3 votes, only the \"principal member\", or a single alternate if the principal is not present, can vote in plenary session. That said, most of the direction is taken from \"straw votes\" where anyone present can participate.\nWG5 has many member countries, though it is true that only a few tend to be represented at the annual meeting. In addition to those mentioned, Germany and Canada are usually represented. It is NOT true that votes to accept or deny features is done by single individuals.  Country votes happen only on letter ballots, which happen towards the end of the process. Otherwise, all organizations represented at WG5 meetings have an equal vote, and by far the most of these are US-based.\nIt does not take \"DECADES and DECADES\" to add features, but neither does this happen overnight. My main goal as WG5 Convenor (think of it as a chairperson role) is to get the next revision out within five years, and hopefully less than that, with another revision five years after that. There has been tremendous pressure on the committee to slow down adding features so that compilers can catch up.\nI'm all in favor of anything that will let us develop the language faster, but this doesn't mean rushing into designs that may not work well with the rest of the language."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 19:48:32+00:00",
                    "text": "but this doesn't mean rushing into designs that may not work well with the rest of the language.\n\nI just want to point out that I think we all agree on that. It's about figuring out how to achieve a design that works well with the rest of the language (in a timely manner)."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-27 19:48:47+00:00",
                    "text": "I understand your point and as a chair of the organization you know many\nthings that we are not aware of from community perspective. To me, however,\nthis dynamics of compiler vendors vs committee is extremely weird. It's\nalmost as if Fortran caters to their needs more than actual development of\nthe language. And because their needs are \"our customers want to run\noutdated f77 codes so god forbid we remove any obsolete features!!!\" which\nis the cause of the stall, lack of any progress and invalid \"backwards\ncompatibility\" arguments. On the other hand, free compilers (which are the\nonly ones that matter) like gfortran or lfortran thrive which makes me\nthink that maybe the lobby of non-free compiler vendors is not the best\nvoice to listen to in the decision making.\n\nPlease keep in mind that I am not involved in Commitee's work so this is\nonly my biased perspective as an outside observer. Please feel free to\ncorrect me if I am wrong.\n\nDominik\n\n\u015br., 27 lis 2019 o 19:56 Steve Lionel <notifications@github.com> napisa\u0142(a):\n\u2026\n Wow - where to begin. There is quite a bit of @FortranFan\n <https://github.com/FortranFan> 's post that is incorrect.\n\n J3's membership is open to anyone, but when J3 votes, only the \"principal\n member\", or a single alternate if the principal is not present, can vote in\n plenary session. That said, most of the direction is taken from \"straw\n votes\" where anyone present can participate.\n\n WG5 has many member countries, though it is true that only a few tend to\n be represented at the annual meeting. In addition to those mentioned,\n Germany and Canada are usually represented. It is NOT true that votes to\n accept or deny features is done by single individuals. Country votes happen\n only on letter ballots, which happen towards the end of the process.\n Otherwise, all organizations represented at WG5 meetings have an equal\n vote, and by far the most of these are US-based.\n\n It does not take \"DECADES and DECADES\" to add features, but neither does\n this happen overnight. My main goal as WG5 Convenor (think of it as a\n chairperson role) is to get the next revision out within five years, and\n hopefully less than that, with another revision five years after that.\n There has been tremendous pressure on the committee to slow down adding\n features so that compilers can catch up.\n\n I'm all in favor of anything that will let us develop the language faster,\n but this doesn't mean rushing into designs that may not work well with the\n rest of the language.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#96?email_source=notifications&email_token=AC4NA3LORJTMDSWDBWQH44DQV27ERA5CNFSM4JQQTFP2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFKOK3Y#issuecomment-559211887>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NYKZXQ5DIRWQXPW73QV27ERANCNFSM4JQQTFPQ>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-27 21:00:16+00:00",
                    "text": "@sblionel wrote:\n\nWow - where to begin. There is quite a bit of @FortranFan 's post that is incorrect.\n..\n\nI'm yet to notice in any inaccuracy in my post, and when I do, I shall be the first to admit it.\nJust as \"shall\" carries particular meaning in the Fortran standard, my post relies on the verb \"can\" which is \"used to indicate possibility\" and the possibility is something which is more than backed up by considerable evidence given how features keep getting dropped time and again from Fortran revisions, such as BITS data type from the Fortran 2008 draft and repeatedly with the topic of this thread, string utilities .\n\n..\nIt does not take \"DECADES and DECADES\" to add features, ..\n\nNo, there is considerable evidence many features do take that long, or that matters can be worse, in that the standard may never see some features e.g., an intrinsic string type.\n,\nConsider this paper by \"ISO Meeting of Fortran Experts,\" all the way back from 1982: https://wg5-fortran.org/N001-N1100/N052.txt.  Now, consider a couple of sections from this:\n8.  Bit Data Type\n    -------------\n    This is very important for certain types of application. There has\n    been inconclusive debate over whether it should be in the core\n    language.\n\nNo amount of input from the practitioners of Fortran appears to \"settle\" this debate, why is that?  Why are there continued arguments against adding a feature and why is the rationale against doing something circular or non-technical (e.g., wait for compilers to catch up) so often?  It took 10 years - a DECADE for Fortran 2018 to be published, a minor revision to boot, and there is still a call for wait for compilers to catch up with 2008.\n12. Character Data Type Extensions\n    ------------------------------\n    Academic computer scientists have poked fun at Fortran for many\n    years and it is feared that having two such closely parallel but\n    different facilities as STRING and CHARACTER will give renewed\n    cause for mirth. More importantly, it will cause confusion to\n    users of the language, and judging by Fortran 77, possibly also to\n    implementors. Since STRING is more powerful and more general it\n    alone should be in the core and CHARACTER should be relegated to\n    the compatibility module.\n\nThe above two paragraphs are proof-positive of the wait for decades by the practitioners of Fortran in spite of them having conveyed their needs and which had the recognition by the so-called \"experts\".  These couple of basic features were up for discussion at this year WG5 meeting, what a coincidence!\nAnd what happened exactly?\n\nBITS data type got deferred,\nThere is still no STRING intrinsic type,\nEven as the CHARACTER type remains an intrinsic type with limitations such as with arrays of varying lengths and Fortran continues to mocked at and remains laughable, all but one of the utilities - the topic of this thread - gets dropped from the list.\n\nSo it was back in 1982 with BITS type, it was recognized, \"This is very important for certain types of application\"  36 years later i.e., last year we had a project (where I work) that could really have used this data type in the code design.  That's well over 3 decades later and the feature is still missing.\nThe same with string utilities.\n\n.. There has been tremendous pressure on the committee to slow down adding features so that compilers can catch up.\n..\n\nBy whom, 1 or perhaps 2 national bodies?  As evidenced in https://isotc.iso.org/livelink/livelink?func=ll&objId=20648817&objAction=Open and https://isotc.iso.org/livelink/livelink?func=ll&objId=20632887&objAction=Open?  Or due to one specific compiler vendor exerting outsized influence on these national bodies?   Regardless, this goes back to my earlier comment about how proposals can peter out at the WG5 level.\nThe users of Fortran the world over with forums online, their input to WG5 survey itself are feeding back the exact opposite: see comments such as this:\n\n\n\"Is it too late now to start this project? ..The list of new features to be added in Fortran 202X has been finalized in last August at the Tokyo WG5 meeting. More specifically, exception handling has been unfortunately rejected \" https://groups.google.com/d/msg/comp.lang.fortran/dFenjU25o9k/Z5MMiXyRAAAJ\n\n\n\"Personally, it's very sad that various features are postponed or even rejected for this round of revision (which may be reasonable for the committee for various reasons), and I'm (very personally) sad that a builtin \"string\" type seems not considered even as a revision candidate\" https://groups.google.com/d/msg/comp.lang.fortran/dFenjU25o9k/-t-OEW2aAAAJ\n\n\n\".. in 2019, people will use C++ instead ..\" https://groups.google.com/d/msg/comp.lang.fortran/dFenjU25o9k/srcYqhXYAAAJ\n\n\n\".. I am afraid that \"waiting for most compilers to catch up\" could mean \"forever\" in practice...\" https://groups.google.com/d/msg/comp.lang.fortran/dFenjU25o9k/UVwbjkraAAAJ"
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-27 21:36:43+00:00",
                    "text": "@gronki I get it and I don't think you're wrong, and yes, you're biased just like me and everybody else here with specific perspective and needs. Here's my biased perspective.\nTo me it makes perfect sense that compiler vendors follow their bottom-line (needs of customers who pay the most), and the committee is in big part made of representatives from vendors. I don't find it weird at all, and I'd find it weird if it were any other way.\nI also understand your and some other people's disregard for backward compatibility, but this is subjective. For instance, I'm an application developer and member of the community, and I care about backward compatibility and consider it one of Fortran's great strengths. I also think backward compatibility is a red herring being considered an obstacle to progress. It's quite possible to advance the language while preserving backward compatibility. What I see as real obstacles are the disconnect from the community and outdated, slow processes.\nI also think it's subjective to consider only free compilers to matter. For me, both free and commercial compilers are essential. The former mostly for development, the latter for production.\nSo what do we do? Can we try to work with the committee and help them make adjustments? If you care about sticking with and advancing Fortran, commercial vendors, committees and backward compatibility are part of the course. I will keep asking \"for whom the Fortran Standard Committee?\", but at some point you got to ask where do you want to go and how can you best get there."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 21:43:27+00:00",
                    "text": "@FortranFan I think the only reason I would like features to be rejected is if they are not ready, or they really should not belong into Fortran (see #59). I am happy the exceptions got rejected, because the feature is simply not ready (too easy to make things worse by putting a half-thought out feature in). Regarding the string type on the other hand, that seems like a good example of what you are talking about that it seems to take decades to get it in."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 21:49:51+00:00",
                    "text": "@milancurcic I agree. We have to try our best to work with the committee. But it goes both ways, the committee must try its best to work with the wider Fortran community. What I have seen so far (and this GitHub repository is a proof of that) is that the wider community is eager to work with the committee, if the committee is willing to reach out."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-27 21:50:30+00:00",
                    "text": "By the numbers - J3 currently has 15 members; only four are from vendors (Cray, IBM, Intel and Nvidia - Malcolm Cohen works for NAG but NAG dropped their membership; Malcolm is one of my alternates now). Most vendor reps are from the support teams (as I was), not development, and are close to what their customers are looking for."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-27 21:54:31+00:00",
                    "text": "@milancurcic I agree. We have to try our best to work with the committee. But it goes both ways, the committee must try its best to work with the wider Fortran community. What I have seen so far (and this GitHub repository is a proof of that) is that the wider community is eager to work with the committee, if the committee is willing to reach out.\n\nAnd we have been doing exactly that - witness the survey we ran for more than half a year, with more than 130 detailed responses from the user community, that fed directly into the planning for Fortran 202X. This github forum is fine, but so far it's mainly a lot of arguing. If I wanted that, I'd go to a J3 meeting.... Oh, wait..."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 22:09:39+00:00",
                    "text": "@sblionel I must react to this:\n\nThis github forum is fine, but so far it's mainly a lot of arguing.\n\nI don't think that's accurate. If you browse the issues:\nhttps://github.com/j3-fortran/fortran_proposals/issues\nThe vast majority are constructive issues (including this one at the top) of what people are requesting.\nThere are only a very few issues where we have off-topic discussions (like this one). The reason for that is that the community feels the committee does not have a real discussion with the wider community about features, and there is a frustration in the community about how to even submit a proposal that will be considered (see #98).\nThe survey you did was great, thank you for doing it, and it should be part (although not the only thing) of what the committee is doing in order to engage the wider community."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-27 22:26:14+00:00",
                    "text": "yeah my thread for string function proposals burned :(\n\n\u015br., 27 lis 2019 o 23:09 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n @sblionel <https://github.com/sblionel> I must react to this:\n\n This github forum is fine, but so far it's mainly a lot of arguing.\n\n I don't think that's accurate. If you browse the issues:\n\n https://github.com/j3-fortran/fortran_proposals/issues\n\n The vast majority are constructive issues (including this one at the top)\n of what people are requesting.\n\n There are only a very few issues where we have off-topic discussions (like\n this one). The reason for that is that the community feels the committee\n does not have a real discussion with the wider community about features,\n and there is a frustration in the community about how to even submit a\n proposal that will be considered (see #98\n <#98>).\n\n The survey you did was great, thank you for doing it, and it should be\n part (although not the only thing) of what the committee is doing in order\n to engage the wider community.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#96?email_source=notifications&email_token=AC4NA3IY6X6SUFYA2YACH6TQV3V2JA5CNFSM4JQQTFP2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFK33UY#issuecomment-559267283>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3OYQ3A4APMWS7UDPFLQV3V2JANCNFSM4JQQTFPQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-27 22:34:02+00:00",
                    "text": "yeah my thread for string function proposals burned :(\n\nYeah, I am sorry. I do believe this is only temporary, as we build trust and fix the committee processes (#98), and once people can see how the process works, there won't be a need to argue about the process."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-27 23:40:57+00:00",
                    "text": "@gronki wrote:\n\nyeah my thread for string function proposals burned ..\n\nThis can be a recurring issue with such proposals because the barriers of them into the language are mostly non-technical and these barriers have been around for a long time.  The programming needs have long been recognized e.g., that paper I linked above with STRING type being mentioned back in 1982!"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-28 00:17:05+00:00",
                    "text": "@certik wrote:\n\n\nyeah my thread for string function proposals burned :(\n\nYeah, I am sorry. I do believe this is only temporary, as we build trust and fix the committee processes (#98), and once people can see how the process works, there won't be a need to argue about the process.\n\nAs I've mentioned before, kudos to you on a great initiative here.\nFor the sake of Fortran, I really do hope the rules and work process fall into place nicely allowing everyone to \"build trust\" which is so critical.  Once you achieve that, perhaps this community can progress to a state where such an online collaboration forum can become a productive development platform also. To paraphrase from my comment in that thread  at comp.lang.fortran:\nadopt *more* of the modern options involving online collaboration toward at\nleast the aspects in language development which fall mostly in the category\nof that mentioned in \"What is New in Fortran 2018\" document at the WG5\nwebsite i.e., \"Features that address deficiencies and discrepancies\".  In my\nmind, what is suggested in the original post here with string utilities\nfalls under this bracket.\n\nA large fraction of the scope and effort toward feature enhancements such as\nthese, the \"minor\" ones per Modern Fortran Explained, is decidedly limited.\nBut such a worklist can be very tedious and quite burdensome if it is\napproached in the traditional manner of serialized processing by a small\nsubcommitee of a burgeoning number of such requests from the users.\n\nHowever, offloading a lot of such feature develoment effort, especially the\ngrunt work that is otherwise constant with each Fortran standard revision,\nto a more modern development model which also involves crowd-sourcing from keen\nFortranners globally via online collaboration platforms and which often garners\n24x7x365 engagement from the enthusiastic Fortran community, can really help\nFortran with parallelized and semi-automated advancement.\n\nWhat is mostly required is enumeration and enunciation by Fortran (sub)\ncommittees of a basic set of language semantics (rules) and (other) requirements\nand constraints which need to be kept in mind while developing features.  The\n\"crowd\" can then iron out a lot of wrinkles in its own ideas, and even reject\na bunch of them.\n\nThe standard (sub)committee(s) would then review, refine, and redirect\ndevelopment and hopefully reduce its own burden along the way.\n\nMy bottom-line message: at least with \"Features that address deficiencies and\ndiscrepancies\" in Fortran, the standard body would do well to consider alternate\noptions to develop proposals which then allow the introduction of MORE as well\nas SPEEDIER refinements in the language.  The traditional approach of having to\njoin committees and attend physical meetings is only possible for a select few.\n\nThere is a need to continuously improve the work processes for faster development."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 18:23:41+00:00",
                    "text": "Let's fix 90% of this issue by implementing the string utilities into stdlib (#104) and by making stdlib a success."
                },
                {
                    "user": "zbeekman",
                    "date": "2020-01-03 21:39:17+00:00",
                    "text": "To get back on topic:\nIMO, the hardest part of writing decent string functions are:\n\nThe awkwardness of character arrays\nUnknown string kinds that must queried at configure time. (e.g., Is \"DEFAULT\" \"ASCII\"? Do we have \"ISO_10646\"? Does the processor provide additional kinds for, e.g. Kanji?)\n\nSo as far as things that the standard could do to help with this are in two main areas in my opinion, and at least partially orthogonal from whether this should be in the standard or in a library:\n\nBetter generic handling of intrinsic types with different kind parameters. Maybe this is via templating (#125). Maybe this is via standardized pre-processors (#65). Maybe this is by intent(out) and function return variables being allowed to adopt the same kind as an intent(in) variable (#128). Maybe this is something different that I can't think of right now.\nBetter handling of character arrays. Maybe this means optional reallocation of an array of strings on assignment (yuck! I hope not.) Maybe this means a new intrinsic string type or class.\n\nThere are admittedly more work arounds for variable length string arrays, but these are at times still hampered by bugs in compiler implementations of allocatable, scalar characters in UDTs.\nSPLIT() is a good case study, as it demonstrates the awkwardness of both of the issues I highlighted above."
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 22:19:50+00:00",
                    "text": "(@zbeekman I created a new issue #128 for your \"infer precision\" idea, and linked existing issues for your other ideas by editing your comment.)"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-30 17:30:14+00:00",
                    "text": "A basic string request I see all the time, as mentioned in several topics here is converting strings to numeric values and vice-versa. Many of us have such functions, often just based on a simple internal read and right. But if you extend a few intrinsics with those routines (which I have done if anyone is interested) you end up with very \"Fortranic\" functions that would fulfill a common need.  How about\nif int(), real(), dble() take CHARACTER as well as numeric types? CHAR() does not quite extend naturally to something that goes the other way (maybe) but an additional function to convert numeric values to strings will fill out the set.  Also, allowing CLASS(*) numerics where the TYPE matches one of the currently supported values (ie. numeric types) and CHARACTER would be very useful for writing functions that take many types without a template or repeated generic implementations for various types.  So you could write something like\nelemental function something(value)\nclass(*),intent(in) :: value\nreal :: val\n    val=real(value)\n ..\n ..\nend function something\nwould allow you to write a function that promotes(demotes) any scalar intrinsic of numeric type or string to\na REAL, for example.  You could call this routine with\n   a=something('100.345e2')\n   a=something(10)\n   a=something(300.d0)'\nI think this stays within and natually extends the Fortran syntax and solves the need for a commonly needed functionality  (It's \"Fortranic\"!). A check on range (so \"something(huge(0.0d0)\" gets caught)\nwould be a nice touch.\nIn addition\n  character(len=:),allocatable :: string\n  real :: value\n   string='my answer is '//value\nshould \"just work\" as well.  Assuming the new function STR() existed that converted anything intrinsic type to a string, this would be equivalent to  \"string='my answer is'//str(value).\nI see no need for STR() to be limited to a single parameter. If it allowed for (say 9) metamorphic values something like  call proc(str(\"my message is \",.true.,\" and the value is \",100.3)...) would allow strings to be easily generated and passed as input without having to do an internal WRITE first, for example.\nAs an example, extending the DBLE(3f) intrinsic using f2008-compliant code:\n!-----------------------------------------------------------------------------------------------------------------------------------\nmodule M_extend\n   use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\n   use, intrinsic :: iso_fortran_env, only : real32, real64, real128\n   implicit none\n   private\n   public dble                      ! extend intrinsics to accept CHARACTER values and LOGICALS\n   interface dble\n      module procedure anyscalar_to_double\n   end interface\ncontains\n!-----------------------------------------------------------------------------------------------------------------------------------\n   pure elemental function anyscalar_to_double(valuein) result(d_out)\n      use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit\n      implicit none\n\n!$@(#) M_anything::anyscalar_to_double(3f): convert integer or real parameter of any kind to doubleprecision\n\n      class(*),intent(in)       :: valuein\n      doubleprecision           :: d_out\n      doubleprecision,parameter :: big=huge(0.0d0)\n      character(len=3)          :: nanstring\n      select type(valuein)\n       type is (integer(kind=int8));   d_out=real(valuein,kind=real64)\n       type is (integer(kind=int16));  d_out=real(valuein,kind=real64)\n       type is (integer(kind=int32));  d_out=real(valuein,kind=real64)\n       type is (integer(kind=int64));  d_out=real(valuein,kind=real64)\n       type is (real(kind=real32));    d_out=real(valuein,kind=real64)\n       type is (real(kind=real64));    d_out=real(valuein,kind=real64)\n       Type is (real(kind=real128))\n         if(valuein.gt.big)then\n            !!write(error_unit,*)'*anyscalar_to_double* value too large ',valuein\n            nanstring='NaN'\n            read(nanstring,*) d_out\n         else\n            d_out=real(valuein,kind=real64)\n         endif\n       type is (logical);              d_out=merge(0.0d0,1.0d0,valuein)\n       type is (character(len=*));     read(valuein,*) d_out\n       class default\n         !!stop '*M_anything::anyscalar_to_double: unknown type'\n         nanstring='NaN'\n         read(nanstring,*) d_out\n      end select\n   end function anyscalar_to_double\n!-----------------------------------------------------------------------------------------------------------------------------------\nend module M_extend\n!-----------------------------------------------------------------------------------------------------------------------------------\nprogram testit\n   use M_extend\n   implicit none\n   ! make sure normal stuff still works\n   write(*,*)'##CONVENTIONAL'\n   write(*,*)'INTEGER         ', dble(10)\n   write(*,*)'INTEGER ARRAY   ', dble([10,20])\n   write(*,*)'REAL            ', dble(10.20)\n   write(*,*)'DOUBLEPRECISION ', dble(100.20d0)\n   ! extensions\n   write(*,*)'##EXTENSIONS'\n   write(*,*)'CHARACTER       ', dble('100.30')\n   write(*,*)'CHARACTER ARRAY ', dble([character(len=10) :: '100.30','400.500'])\n   ! call a function with a metamorphic argument\n   write(*,*)'METAMORPHIC     ', promote(111)\n   ! settle this once and for all\n   write(*,*)'LOGICAL TRUE    ', dble(.true.)\n   write(*,*)'LOGICAL FALSE   ', dble(.false.)\n   write(*,*)'LOGICAL ARRAY   ', dble([.false., .true., .false., .true.])\ncontains\n   function promote(value)\n      class(*),intent(in) :: value\n      doubleprecision     :: promote\n      promote=dble(value)**2\n   end function promote\nend program testit\n!-----------------------------------------------------------------------------------------------------------------------------------\nHandles CHARACTER strings easily:\n##CONVENTIONAL\nINTEGER            10.000000000000000     \nINTEGER ARRAY      10.000000000000000        20.000000000000000     \nREAL               10.199999809265137     \nDOUBLEPRECISION    100.20000000000000     \n##EXTENSIONS\nCHARACTER          100.30000000000000     \nCHARACTER ARRAY    100.30000000000000        400.50000000000000     \nMETAMORPHIC        12321.000000000000     \nLOGICAL TRUE       0.0000000000000000     \nLOGICAL FALSE      1.0000000000000000     \nLOGICAL ARRAY      1.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-02 17:31:05+00:00",
                    "text": "@urbanjost wrote:\n\nA basic string request I see all the time, as mentioned in several topics here is converting strings to numeric values and vice-versa. ..\n\n@urbanjost, are you active on https://github.com/fortran-lang/stdlib work?  Is something like \"to_string\" (perhaps, along the lines of C++ stdlib, or something better!) in the works there?  If not, you may want to collaborate to get that added."
                },
                {
                    "user": "sblionel",
                    "date": "2020-02-02 17:58:10+00:00",
                    "text": "A basic string request I see all the time, as mentioned in several topics here is converting strings to numeric values and vice-versa.\n\nI always assumed that people who ask this do so because of their familiarity with such functions in other languages. Fortran's approach is quite different, though if you step back a bit it's a lot like sprintf in C. The advantage of a function is that it's easier to reference in an expression.\nI could see putting a simple version in a library, though I expect it would instantly get requests for additional formatting flexibility. I suppose one could pass a FORMAT string as an optional argument."
                },
                {
                    "user": "septcolor",
                    "date": "2020-02-02 18:25:35+00:00",
                    "text": "I always have a question that \"Why doesn't Fortran introduce a decent string type?\" It fails even for a simple case likemerge( \"true\", \"false\", flag ). It even cannot read input from stdin while determining its length automatically (which is a piece of cake in C++ and D...). I think \"character(:), allocatable\" is not a solution for future because ALLOCATABLE is not part of a type."
                }
            ]
        },
        {
            "number": 95,
            "user": "ivan-pi",
            "date": "2019-11-20 17:25:55+00:00",
            "title": "Automatic differentiation in Fortran",
            "text": "Recently, there has been a growth of interest in automatic differentiation tools used in adjoint modelling. Some popular projects in the Python and Julia worlds are JAX and\nJuliaDiff, respectively.\nOf course, plenty of such tools exist for other languages including (older) Fortran ones such as adjac, OpenAD, Tapenade, AUTO_DERIV, and ADIFOR just to name a few. At NAG they also support some algorithmic differentiation tools in the form of overloaded C++ classes.\nThe growth of interest in algorithmic differentiation appears to be fueled by the needs of the machine learning community. The Julia language developers are trying to push it so far to even have a differentiable programming language. A recent blog post touches on this topic from the perspective of a Fortran programmer (the idea for submitting opening this issue/proposal comes from reading this blog post).\nI have no experience in this area (just plans to have a closer look in the future), but I am wondering whether some of the older tools (for example ADIFOR dates back to 1992) have achieved a level of maturity, where they might be implemented directly into the language. I am guessing the compiler developers already employ some experts in this field. It would be interesting to see whether an experimental branch of the LFortran compiler could make this idea take off. I can imagine that making these tools easy to use (while keeping the performance) would generate some new interest in Fortran and also send the message that Fortran is a living language (otherwise, we might end up in the situation where those rare Fortran programmers still left start calling ODE solvers through the Julia C API or simply abandoning ship).\nGiven that Fortran was named and developed for the purpose of \"formula translation\", one could imagine that in the current decade (or perhaps century) we also continue down this path of adding further mathematical abstractions such as differentiation. A related idea would be to introduce a new type for dual numbers, which can also be used for the purpose of automatic differentiation (see here and here).\nI look forward to reading the comments from those of you who have used/authored such automatic differentiation tools in the past.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-20 17:39:39+00:00",
                    "text": "1000 thumbs up for this!\nI see this as a major use case for some kind of generic programming/template feature. But it has to be well-designed. There are things we just cannot do right now.\nFor example: say we have a function that depends on an intrinsic real variable. This function could be using hundreds of modules, third-party codes, etc. I want to be able to call this function to get the result, but I also want to call the function and get the derivative, by replacing this real variable with some kind of autodiff class. I want both of these calls to be as efficient as they can be. Maybe this class is not even known about by some of the third-party code. I think the Julia multiple dispatch thing is the closest thing I've seen that can do something like this, but I've not actually used it before. Fortran needs that desperately. I don't want to have to clutter potentially hundreds of thousands of routines to put select type everywhere, or put all the logic in include files and duplicate all the interfaces. That's just not practical for anything complex."
                },
                {
                    "user": "certik",
                    "date": "2019-11-20 19:19:56+00:00",
                    "text": "I have an issue open for this at LFortran: https://gitlab.com/lfortran/lfortran/issues/97. In the coming months I'll write a prototype, so that people can play with it, then we can go from there."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-20 22:09:50+00:00",
                    "text": "This would be amazing!\nIf Fortran became a language with AD built in, it would be a game changer for scientific and numerical computing where derivatives are so important.\nAs you point out there are tools for performing AD in Fortran, however they are all old (don't support modern Fortran) and/or not open source.\nAs far as language modifications go, it's very complex, though there is a lot of research in the field.\nI believe it can already be implemented simply (and inefficiently) in Fortran using operator overloading, but it really needs a source-code-transformation approach or equivalent if you want an efficient derivative code.\nI don't know how this can be achieved at a language level, but it would set Fortran far apart if implemented."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-21 03:08:09+00:00",
                    "text": "I dare not dream that we'll ever get anything like this out of the Fortran committee. Which is why I think the best we could hope for is a really good generic programming capability so users could implement this themselves with (hopefully) a minimum of verbosity.\nHaving this baked into LFortran would also be amazing! That would really be a game changer."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-20 20:11:35+00:00",
                    "text": "Yes, this can already be done today (to some extent) with the features already present in the language, by declaring a type for dual numbers and using operator overloading to declare arithmetic operations on these numbers (akin to how one would implement complex numbers if the language didn't provide them). The problem is it will be slow, not least due to the arithmetic overhead inherent in, e.g., dual number division (six times more expensive than division of reals)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-01-20 20:40:11+00:00",
                    "text": "@difference-scheme The main reason this is unworkable for anything complex is that you can't use any third-party library for any calculation unless it is also using your dual number class. There are a dozen different sort of classes you might devise to get derivatives besides dual numbers. All third party libs (say, an ODE solver or whatever) can't be expected to support all of them. The only way to make this workable is:\n\nAutodifferentiation is somehow baked into the language, so we don't have to worry about writing any custom classes.\nThe language provides some amazing way to implement generics so that all third-party libs will be able to be written in such a way that they can be used for auto-differentiation without having to know about the particular implementation a user might use.\n\nThe Fortran committee needs to be looking at what Swift and Julia are doing. In this field, as in many other ways, Fortran is falling behind..."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-04-30 18:41:02+00:00",
                    "text": "Perhaps of interest: Algorithm 1005: Fortran Subroutines for Reverse Mode Algorithmic Differentiation of BLAS Matrix Operations. I could not find the actual Fortran routines. But it shows at least there is still large interest in having the possibility to automatically differentiate Fortran programs that rely on BLAS. Hopefully, LAPACK follows (in the paper they already show discuss algorithmic differentiation of the Cholesky decomposition).\nThis blog post by Christopher Rackauckas, The Essential Tools of Scientific Machine Learning (Scientific ML), also offers a summary of the automatic differentiation field with a focus on bringing together machine learning and ODE/PDE solvers."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-28 11:52:27+00:00",
                    "text": "The ISO C++ committee is looking at differentiable programming in one of their study groups: https://docs.google.com/document/d/1_5TJCBvI6fZSdyuK7_Cpo5XwdoIS24DDbEPh2JjqQsg/edit?ts=5cf823e2#heading=h.t1fxx74w88nq\nIt seems as if the Fortran community is starting to fall behind on this issue compared to Julia and C++."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-10-15 13:46:50+00:00",
                    "text": "Perhaps of interest: Algorithm 1005: Fortran Subroutines for Reverse Mode Algorithmic Differentiation of BLAS Matrix Operations. I could not find the actual Fortran routines. But it shows at least there is still large interest in having the possibility to automatically differentiate Fortran programs that rely on BLAS. Hopefully, LAPACK follows (in the paper they already show discuss algorithmic differentiation of the Cholesky decomposition).\n\nThe routines are now available on the ACM page: https://dl.acm.org/doi/10.1145/3382191"
                },
                {
                    "user": "dalon-work",
                    "date": "2021-12-20 19:31:40+00:00",
                    "text": "CppCon 2021 recently posted a talk about implementing AD in LLVM as a plugin, using the compiler directly, instead of any language-level constructs. I assume this would affect Flang as well.\nhttps://youtu.be/1QQj1mAV-eY?t=2240\nAt the end he describes an effort to make this part of the C++ standard somehow."
                }
            ]
        },
        {
            "number": 94,
            "user": "marshallward",
            "date": "2019-11-19 15:06:54+00:00",
            "title": "Namelist delimiter proposal",
            "text": "This patch includes a proposal to require delimiters for characters\narrays in namelist output.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-03 05:05:27+00:00",
                    "text": "@marshallward thanks for the PR. Can you comment on #122 and (hopefully) list it among your top 5?"
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-24 00:00:37+00:00",
                    "text": "This is a very nice proposal, thanks! I think one thing to improve it more would be a code example showing the problem."
                },
                {
                    "user": "certik",
                    "date": "2020-02-24 00:18:42+00:00",
                    "text": "@marshallward can you send us an example how this would be used? Ideally as a PR to the already merged file. This would greatly help us when advocating for the proposal. It's a little bit unclear without an example.\nAfter you send it, we will upload it and discuss it at the committee.\nThanks!"
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-24 03:05:43+00:00",
                    "text": "Sure, I will send a change in tomorrow morning.  Thanks very much for the corrections and reformatting!"
                },
                {
                    "user": "certik",
                    "date": "2020-02-24 18:32:27+00:00",
                    "text": "@marshallward thanks! Please ping me when you do so."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-24 20:13:45+00:00",
                    "text": "@certik @zjibben I've submitted an update here:  #154\nThis includes an example section describing how to reproduce the current issue."
                }
            ]
        },
        {
            "number": 93,
            "user": "aradi",
            "date": "2019-11-18 20:53:51+00:00",
            "title": "Issue lifetime",
            "text": "Question about the general workflow: Should issues be closed at some point? Or should they stay opened, unless they result in a PR? What if the discussion/conversation stopped for a while? Or if it arrived at a dead end? Or in case the discussion raised severe concerns killing its chances of becoming a strong proposal and being discussed by the committee?\nI think, closing issues could help to concentrate efforts on the more promising candidates.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-18 21:18:04+00:00",
                    "text": "Right now let's keep all issues open. Only close the ones for which there is a new issue the  supersedes them.\nI will be discussing with the committee at the February 2020 meeting how to improve our workflow, and once the committee settles on some plan how to handle new proposals, my idea is to close an issue that was essentially rejected by the committee in the current form. One can then open a new issue that fixes some of the objections with a new proposal.\nI expect that there will be thousands of issues eventually, so the way I expect us to prioritize them is to use GitHub features like \"sort by number of comments\", or \"number of reactions\". We will also create meta issues for things like \"issues to create proposals for February 2020 meeting\", etc."
                }
            ]
        },
        {
            "number": 92,
            "user": "jacobwilliams",
            "date": "2019-11-18 16:44:43+00:00",
            "title": "Function/subroutine declarations",
            "text": "I always thought that function/subroutine declarations should be done in a similar way as variables. So instead of:\npure elemental function f(x) bind(c,'whatever') result(s)\nwhich to me looks like a haphazard pile of things separated by spaces, you could do this:\nfunction,pure,elemental,bind(c,'whatever'),result(s) :: f(x)\nor taking it to the extreme, something like:\nfunction,pure,elemental,bind(c,'whatever'),arguments(x),result(s) :: f\nJust a thought.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-19 05:18:06+00:00",
                    "text": "Thanks for submitting the idea, I haven't heard of this one before."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-21 16:47:28+00:00",
                    "text": "I agree, would be useful. In addition I would like the PRIVATE and PUBLIC attributes to be available on the declaration."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-27 01:48:30+00:00",
                    "text": "@jacobwilliams, @certik, @qolin1,\nI agree there is the risk Fortran language is reaching a point where attributes of procedures can get rather long and unwieldy:\n   non_recursive module impure elemental subroutine Fred( .. )\n   ! And public/private possibly\nThe idea of using prefixes to specify procedure attributes may have run its course.\nTo borrow @jacobwilliams' term, a more Fortrannic approach to deal with this issue might be to introduce a new clause, say ATTRIBUTES, a la RESULT(..) and BIND(..).  From what I recall, compiler implementors (and thus the standard committee) appear open to the idea of more clauses to address certain language improvements, especially when it comes to FUNCTIONS.  So with a clause, a declaration may look as follows:\n   subroutine Fred( .. )\n       attributes( public, non_recursive, module, impure, elemental )\n   ..\nCan you provide your feedback as to whether this alternative involving a subprogram clause is worth a separate issue?"
                },
                {
                    "user": "gronki",
                    "date": "2019-12-27 16:38:58+00:00",
                    "text": "This last proposal looks as if Fortran 77 nightmare was trying to creep\nback in. In my opinion function attributes are most intuitive before the\nfunction name as it is currently.\n\npt., 27 gru 2019, 02:48 u\u017cytkownik FortranFan <notifications@github.com>\nnapisa\u0142:\n\u2026\n @jacobwilliams <https://github.com/jacobwilliams>, @certik\n <https://github.com/certik>, @qolin1 <https://github.com/qolin1>,\n\n I agree there is the risk Fortran language is reaching a point where\n attributes of procedures can get rather long and unwieldy:\n\n    non_recursive module impure elemental subroutine Fred( .. )\n    ! And public/private possibly\n\n The idea of using prefixes to specify procedure attributes may have run\n its course.\n\n To borrow @jacobwilliams <https://github.com/jacobwilliams>' term, a more\n Fortrannic approach to deal with this issue might be to introduce a new\n clause, say ATTRIBUTES, a la RESULT(..) and BIND(..). From what I recall,\n compiler implementors (and thus the standard committee) appear open to the\n idea of more clauses to address certain language improvements, especially\n when it comes to FUNCTIONS. So with a clause, a declaration may look as\n follows:\n\n    subroutine Fred( .. )\n        attributes( public, non_recursive, module, impure, elemental )\n    ..\n\n Can you provide your feedback as to whether this alternative involving a\n subprogram clause is worth a separate issue?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#92?email_source=notifications&email_token=AC4NA3MPZDDLQPZ67QKLA4DQ2VNHBA5CNFSM4JOWJVI2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEHWMEAA#issuecomment-569164288>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3IKXXRHLDLONML4UHTQ2VNHBANCNFSM4JOWJVIQ>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-27 17:50:47+00:00",
                    "text": "Attributes before the FUNCTION and SUBROUTINE keyword are how things are done today, like it or not.  It was a bad design and it restricted at least one syntactic possibility (one can write CHARACTER*7 or CHARACTER(LEN=NAMEDCONSTANT) but not CHARACTER*NAMEDCONSTANT, and that's due at least in part to the ambiguity that would introduce in CHARACTER*IMPUREFUNCTIONFOO()).  But that ship has sailed; adding a redundant ATTRIBUTES(...) syntax would not enable any new capability."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 18:03:15+00:00",
                    "text": "True, the current syntax is far from perfect and leaves much to be desired. But, adding yet another option for syntax is probably not a good solution. There is already a large variation in code style out there, which can make switching between code bases unpleasant. This would simply make that problem even worse.\nMy vote is that a bad but consistent style is better than a variety of inconsistent styles. Maybe if there was going to be a push to start deprecating old syntaxes and settle on a single style going forward now would be the time to make this change, but I don't really see that as a possibility."
                }
            ]
        },
        {
            "number": 91,
            "user": "jacobwilliams",
            "date": "2019-11-18 16:37:52+00:00",
            "title": "Function kind specified by optional input",
            "text": "I want to be able to define a function that behaves like, for example, the intrinsic SIZE function, where the kind of the output is specified by an optional input. Am I correct that this currently isn't possible?\nMaybe using something similar to @cmacmackin's parameterized function syntax from #4, combined with a better way to specify the default value of optional arguments (see also #22):\nfunction my_class_size(me, kind=INT32) result(s)\nclass(my_class) :: me\ninteger,intent(in),optional,kind :: kind  \ninteger(kind) :: s \n...\nend function my_class_size\nSee also #78, and also the various issues about generic programming and templates.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-18 17:47:02+00:00",
                    "text": "@jacobwilliams wrote:\n\nI want to be able to define a function that behaves like, for example, the intrinsic SIZE function, where the kind of the output is specified by an optional input. Am I correct that this currently isn't possible? ..\n\nThe specific example with 'my_class_size' function above is not feasible since KINDs need to be known at compile time.  However, based on further description of the need, it may be possible to workaround it by designing the 'my_class' as a parameterized derived type.\nAnyways, the need \"I want to be able to define a function that behaves like, for example, the intrinsic SIZE function\" is yet another instance where the Fortran standard makes certain allowances for intrinsic procedures (generic like ABS, FINDLOC, etc; variadic like MAX, MIN) and intrinsic types that are inextensible, single-component like C_PTR, etc. but does not extend the same courtesy for user procedures and types\nThis really comes to 'bite' because the committee refuses to include certain intrinsic 'classes' (a la what other languages now already have e.g., C++ in STL with std::string, std::vector, std::variant) that are so badly needed in the language but then there is extreme recalcitrance to offer to coders all the tools and mechanisms they need to build their own such 'classes'."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-05 11:49:14+00:00",
                    "text": "I have stumbled into this a few times already. The last time was in a discussion of extending the intrinsic character functions like verify and scan to a custom string type (see fortran-lang/stdlib#321).\nAllowing a mechanism to allow a kind attribute in functions would make it much more convenient to use custom derived types (floats, strings) or types supporting automatic differentation (see #95), by allowing to overload all the intrinsic functions which have such an optional kind argument.\nFor a specific example say I want to use a derived type designed to emulate quadruple precision (106 bits of significand) using two doubles (also known as double-double arithmetic) or potentially the more ambitious quad-double (unevaluated sum of 4 doubles):\n  type :: dd_real\n    real(dp) :: x, y = 0.0d0\n  end type\n\nTo allow easily porting code from double to double-double, I would like to overload the real(a [,kind]) function, to cast down to a standard real value (say for output):\npure function real(a,kind) result(y)\n  type(dd_real), intent(in) :: a\n  integer, kind, optional :: kind\n  real(kind=kind) :: y\n  block\n    intrinsic :: real\n    y = real(a%x,kind=kind)\n  end block\nend function\n\nIf no optional argument is present, then kind should resolve to the default type (and not a null pointer). Maybe this is something which could be pursued in connection to issue #22 (default value for optional arguments) and the related proposal #175. In that case, the default real kind could be set using\ninteger, kind, default(kind(1.0)) :: kind\n\nIs there any way to find out if any related proposals have been discussed previously, and if yes, why were they  rejected?\ncc @certik @milancurcic @wclodius2 @sblionel"
                },
                {
                    "user": "sblionel",
                    "date": "2021-04-06 14:03:23+00:00",
                    "text": "@ivan-pi , I don't recall ever seeing a proposal along these lines. It's an interesting idea."
                },
                {
                    "user": "certik",
                    "date": "2021-08-18 15:12:49+00:00",
                    "text": "I think this proposal is very similar to #128."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-10-03 13:51:22+00:00",
                    "text": "Similar, but not the same. size returns an integer, but can be passed in any type. So there isn't an integer input to get the kind from. That's the kind of function I want to be able to write. There are couple other intrinsic functions that are not possible for a user to write (max is another example)...see my other proposal at #76."
                }
            ]
        },
        {
            "number": 90,
            "user": "jacobwilliams",
            "date": "2019-11-16 16:50:03+00:00",
            "title": "Eliminate implicit typing",
            "text": "In a similar spirit as #40.\nI think most everybody agrees that implicit typing is a terrible \"feature\" that should never be used. Keeping it as the default behavior is a constant source of annoyance and errors. It's also just an embarrassment at this point. Why not get rid of it?\nRemoving it would require that people running obsolete codes put implicit double precision (a-h...) or whatever that is in all their codes, right? To me that's preferable to making everybody else suffer until the end of time.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-16 17:41:09+00:00",
                    "text": "@jacobwilliams , see also a couple of other recent threads: #79 and #83.\nSee also these 2 comments where I make similar points, even an entirely painful compromise (in my mind at least) to make the (NOT!) breaking change in free-form source since every free-form source out there already has (or intends to have) \"IMPLICIT NONE\" to signal implicit typing is not desired :\n#83 (comment)\n#83 (comment)\nI entirely concur with your assertion, \"It's also just an embarrassment at this point.\"  As I write in one of the above comments, \"Trying to get new coders to work on Fortran codes, particularly in industry, is a huge challenge. Few join with any background in Fortran, few schools teach Fortran. Then one loses them at 'hello' itself, meaning at the very beginning stage when one stresses to them the need to type 'implicit none' in every scope.\"\nAs I show with this link  and with even another ISO IEC working group (WG23) document on vulnerabilities with Fortran, countless amount of time and effort is expended to ensure \"implicit data declarations (are) banned, by inserting \"IMPLICIT NONE' in all program units\".\nThere is no reason any longer to leave such an important aspect to all the other coders and to anything else (e.g., processor options -fimplicit-none) but the goddamn standard itself.\nInterestingly, one arm of ISO/IEC JTC 1/SC 22 in WG23 itself states the following which is unfortunately not paid heed to by the other in WG5:\n\n7 Language specific vulnerabilities for Fortran\n\n8 Implications for standardization \n  Future standardization efforts should consider:\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of integer overflows during program execution.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of out-of-bounds subscripts and array-shape mismatches in\n    assignment statements during program execution.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of invalid pointer references during program execution.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of an invalid use of character constants as format specifiers.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of tests for equality between two objects of type real or complex.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of pointer assignment of a pointer whose lifetime is known to be\n    longer than the lifetime of the target or the target attribute of the target.\n  \u2022 Requiring that processors have the ability to detect and report the occurrence within a\n    submitted program unit of the reuse of a name within a nested scope.\n  \u2022 Providing a means to specify explicitly a limited set of entities to be accessed by host\n    association.\n  \u2022 Identifying, deprecating, and replacing features whose use is problematic where there is\n    a safer and clearer alternative in the modern revisions of the language or in current\n    practice in other languages.\n\n\n\nConsidering the last bullet, nothing stands out as much as implicit typing and implied SAVE requiring immediate deletion from the Fortran standard."
                },
                {
                    "user": "rweed",
                    "date": "2019-11-17 02:57:17+00:00",
                    "text": "@jacobwiliiams and @FortranFan, I think anyone who like me started with Fortran IV/Fortan 66 and then F77 (what I like to call Jurasic Fortran) and then moved to F90 and its decendents knows that implicit typing should have been removed from the language around the time of F90 (or before). Unfortunately, this is another one of those obsolete features that somehow take precedent over more modern and more useful coding constructs because of the \"we can't break code\" mantra. Every time I see this I immediately interpret it as \"we can't break code by adding features or deleting obsolete ones that people are paying us money to help maintain\". I'm becoming more convinced that the only way to save Fortran is to first declare that what is currently called Fortran has reached its \"end of life\" and is entering maintenance mode. Then maybe some enterprising young person will \"fork\" the language and produce a compiler that ONLY supports the things in the current standard that haven't been declared obsolete and strips out all the other cruft (DEC extensions etc.) vendors insist on adding and then give it a new name and market it is as a new language. I've alway wondered what price we are paying in the way of increased compiler bugs etc. because developers have to keep dragging the weight of all the obsolete stuff around just to satisfy a few hid bound organizations that are too cheap to make the effort to update their codes. I put the following question to the F18/LLVM/Flang developers and others. How much time and code are you wasteing trying to support features that have been declared obsolete by the standard and other things like DEC extensions. I guess what I'm saying is isn't it time we had a new vision of Fortran that doesn't include or support fixed source, implicit typing, all obsolete features and existing features we can all (mostly) agree were either a mistake to add to the language or are in their current form poorly implemented. I want a new standard that officially bans them and compilers that refuse to compile if it sees any of those features. Again, the only way I see that happening is to just fork what we can all agree are the best parts of \"modern Fortran\", come to a consensus on what new features we think would add value to that core capability and if necessary\nwrite an new standard, call it a new name, and market it to the world as a new language.\nAs to @jacobwilliams proposal, I still see this as a procedural issue with the vendors more than a technical one. The path of least resistance is to make explicit typing the default and have compiler switches that people who insist on still doing implicit typing must turn on to get the old default. To me this is the logical approach since no mods would have to be made to old code and the only impact I can see is on build options\njust my 2 cents"
                },
                {
                    "user": "certik",
                    "date": "2019-11-17 04:13:06+00:00",
                    "text": "@rweed Thanks for the feedback. I just created an issue for this in LFortran (a compiler that we are developing): https://gitlab.com/lfortran/lfortran/issues/148. I thought very hard about whether we should simply create a new language, and came to the conclusion that it's better not to: by sticking to Fortran's syntax and staying compatible, it means we can leverage the excellent Fortran compilers out there, that generate highly optimized code (historically better than LLVM, although the gap has been shrinking). If we create an incompatible language, then we are starting from scratch. And we can't use it with so many Fortran codes out there.\nThe other aspect is that if somehow Fortran compilers stop compiling our codes (and we have millions of lines) because Fortran becomes incompatible, it will only accelerate the exodus from Fortran in my opinion.\nNote also that there have been such efforts to remove old stuff and only stick to modern Fortran, I believe https://en.wikipedia.org/wiki/F_%28programming_language%29 was one such attempt. I don't think it was ultimately successful.\nI think there is a way to modernize the language, while staying compatible (for example with a compiler option). We just have to try."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-17 04:49:50+00:00",
                    "text": "@certik wrote:\n\n@rweed Thanks for the feedback. I just created an issue for this in LFortran (a compiler that we are developing): https://gitlab.com/lfortran/lfortran/issues/148.\n\nThat's most commendable, thank you for pursuing such an approach with LFortran.\n\n.. Note also that there have been such efforts to remove old stuff and only stick to modern Fortran, I believe https://en.wikipedia.org/wiki/F_%28programming_language%29 was one such attempt. I don't think it was ultimately successful.\n..\n\nThe name matters a lot, if they had been strongly irredentist to call their effort Fortran also, the outcome could have been different!"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-17 06:20:56+00:00",
                    "text": "@rweed wrote:\n\n.. I guess what I'm saying is isn't it time we had a new vision of Fortran that doesn't include or support fixed source, implicit typing, all obsolete features and existing features we can all (mostly) agree were either a mistake to add to the language or are in their current form poorly implemented. I want a new standard that officially bans them and compilers that refuse to compile if it sees any of those features.  ..\n\n@rweed, I'm completely sympathetic to and understanding of your sentiments.\nSooner or later, the question \"For whom Fortran?\" will need to get addressed earnestly.\nAnd I can only hope that will result in the realization Fortran needs to transcend and rise above the confines of ISO IEC standards body bureaucracy.  That it's the latter who will have to follow the language where it freely needs to go.  One can notice that clearly with C++ and the rapid pace and expansive scope and brave conviction of each ISO revision.  Whereas many others on the IEEE Spectrum of most popular languages in the technical arena such as Python, Java, C#, R, MATLAB, Swift, Go, and even other HPC ones such as Julia, Haskell, etc. don't even bother with such standards bureaucracy but with no less success, that's for sure.\nThere is a lesson to be learned here: at some point, the 'bureaucracy' will need to adopt the US Marines ethos: lead, follow, or get out of the way.\nThe current snail's pace of incremental abominations of the likes of implicit none (type, external) is like adding insult to injury."
                },
                {
                    "user": "certik",
                    "date": "2019-11-18 21:12:46+00:00",
                    "text": "By the way, is it possible to separate this kind of \"meta\" discussion to dedicated threads?\n\nYes, I encourage everyone to do so please. When you see a related but ultimately separate discussion, feel free to open a new issue and move it there. Sometimes it's hard to do, as we are discovering the \"space\" of arguments and we end up discussing these meta questions as we encounter them. But as we get better at this, we will eventually have dedicated issues with these meta questions so that we do not need to repeat the arguments."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 04:04:18+00:00",
                    "text": "Back to implicit typing: can anyone point to any code-base which explicitly (!) relies on this feature as part of their code design?\nOver the last 6 years or so, I've reviewed lots and lots of code in legacy FORTRAN (66/IV/77 + non-standard extensions) spread over 75 programs and libraries and over a couple of million lines of instruction developed using dozens of person-years of effort spanning decades of contributions by many different engineers and scientists.  All of these codes - without fail - either had\nIMPLICIT INTEGER(I-N), DOUBLE PRECISION (A-H,O-Z)\nor\nIMPLICIT NONE\nFor codes like these with explicit IMPLICIT statements, a future revision of the standard that removes implicit typing as the default should cause no harm!\nSo it'll be really useful to know what other codes are out there which are of concern that Fortran cannot remove implicit typing as the default.  And how relevant will these codes be in year 2035 or later when sufficient number of processors providing support for a revision with such a change start to appear?  Note the earliest possible revision is Fortran 202Y.\nI contend the risk of breaking old code is too low or nonexistent and that's not even taking into account the surefire possibility of vendors providing options to retain implicit typing as the default.  It'll be an opportunity of some commercial potential at least for the vendors, something that should not be discounted completely.\nSo, \"Why not get rid of it\" as @jacobwilliams asked regarding implicit typing as the default in Fortran?"
                },
                {
                    "user": "rweed",
                    "date": "2019-11-20 14:52:04+00:00",
                    "text": "I've always assumed most (all) compilers supported something like gfortran's -fimplicit-none compiler option. If that were the case then making implicit none the default would be a procedural or policy decision and not a technical one. You just change the default polarity of that option. Unfortunately, a quick review of compiler documentation of the compiler's I use or have used in the pass shows that (as far as I can tell) only Cray and gfortran support an implicit-none option. I can't find any reference to an equivalent option for Intel, PGI, or IBM. They may exist but I didn't see any reference to one."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-20 14:56:27+00:00",
                    "text": "I can't find any reference to an equivalent option for Intel, PGI, or IBM. They may exist but I didn't see any reference to one.\n\nIt's -implicitnone for ifort if I recall correctly."
                },
                {
                    "user": "rweed",
                    "date": "2019-11-20 15:05:28+00:00",
                    "text": "@milancurcic, I think that only turns on warnings about implicit typing. It doesn't enforce explicit typing by default. The only reference in the man pages to -implicitnone for Intel 19.0.5 is in relation to -warn options"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 18:27:17+00:00",
                    "text": "@rweed wrote:\n\n.. I think that only turns on warnings about implicit typing. It doesn't enforce explicit typing by default. The only reference in the man pages to -implicitnone for Intel 19.0.5 is in relation to -warn options\n\nThey don't make it easy, Intel Fortran customers have to write -warn declarations, errors (or /warn:declarations,errors on Windows):\nC:\\Temp>type p.for\n      I = 42\n      END\n\nC:\\Temp>ifort /c /warn:declarations,errors p.for\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.5.281 Build 20190815\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\n\np.for(1): error #6717: This name has not been given an explicit type.   [I]\n      I = 42\n------^\ncompilation aborted for p.for (code 1)\n\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 18:42:25+00:00",
                    "text": "@rweed  wrote:\n\n,, Unfortunately, a quick review of compiler documentation of the compiler's I use or have used in the pass shows that (as far as I can tell) only Cray and gfortran support an implicit-none option. I can't find any reference to an equivalent option for Intel, PGI, or IBM. They may exist but I didn't see any reference to one.\n\nNAG Fortran documentation  states:\n-u\n    Specify that IMPLICIT NONE is in effect by default, unless overridden by explicit IMPLICIT\n    statements.\n\nAnd the same with IBM XL Fortran"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 22:54:46+00:00",
                    "text": "But doesn't the standard only have the concept of \"Fortran processor\" and formally ignore the existence of any specific devices/software (including compilers and options)? If compiler options are a valid approach (for the standard) ..\n\nAs stated, the desired goal of this thread \"Eliminate implicit typing\" has an overwhelming non-technical component i.e., beyond the boundaries of syntax and semantics of the language.  The risk of breaking old code is among them.  The long history of compilers and options come into play only as much to show the risk is rather low or non-existent to be used as a crutch to further kick this can down the road.\nIMPLICIT NONE was among the most widely adopted non-standard extensions to FORTRAN 77 in processors starting in the 1980s.  And there are countless coding guidelines and rulesets out there that required its use which clearly shows the practitioners of the language have overwhelmingly desired to move away from implicit typing.  But that the very same processors will adopt options to support the miniscule minority (it it at all exists) who may want to continue employing implicit typing.  That there is no reason to force the majority to suffer from the tyranny of such a minority."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 23:08:14+00:00",
                    "text": "@septcolor wrote:\n\n.. For example...\nAMOS (A Portable Package for Bessel Functions of a Complex Argument\nand Nonnegative Order) ..\n\n@septcolor , thank you very, very much for bringing attention to codes such as AMOS from NetLib collection.\nHowever I do not think these legacy sources are good examples of code-bases where implicit typing is part and parcel of code design.  These sources as-is have portability issues across current processors, see the comment on that GitHub repo.  Then the good news is 33 out of 39 source files do not have implicit typing.  Among the remaining 6 sources which do some problems with implicit declarations,\n\n\none source zbesy.f has a bug in that the variable R1M5 is clearly meant to be an object of double precision type but is instead implicitly typed as default real,\n\n\nanother source zunk1.f obviously has missed out on declaring a local variable M after having done so for all the other variables including the typical ones of I, J, etc.\n\n\nConsidering everything, I would not include codes likes these in any serious attempt toward assessing the risk of deleting implicit typing as the default in Fortran."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-23 00:47:16+00:00",
                    "text": "In ifort, -warn declarations is all you need. This is equivalent to saying IMPLICIT NONE in every program unit. Don't get hung up on the use of \"warn\" - ifort is already inconsistent about which of these checks are warnings and which are errors (this goes back decades to the DEC implementations.)"
                },
                {
                    "user": "ThemosTsikas",
                    "date": "2020-01-29 14:50:03+00:00",
                    "text": "Briefly: It seems to me that the first step is to declare the following feature obsolescent (using J3/18-007r1, page 114, pg 130/646 of PDF, 8.7 line 9).\nR863 implicit-stmt is IMPLICIT implicit-spec-list\nAlso delete:\nFirst sentence of line 5\n\"In a scoping unit, an IMPLICIT statement specifies a type, and possibly type parameters, for all implicitly typed data entities whose names begin with one of the letters specified in the statement. \"\nLine 11\n\"R864 implicit-spec is declaration-type-spec ( letter-spec-list )\"\nLine 12\n\"R865 letter-spec is letter [ \u2013 letter ]\"\nLine 21\n\"C894 (R865) If the minus and second letter appear, the second letter shall follow the fi rst letter alphabetically.\"\nPara 2\n\"A letter-spec consisting of two letters separated by a minus is equivalent to writing a list containing all of the letters in alphabetical order in the alphabetic sequence from the fi rst letter through the second letter. For example, A\u2013C is equivalent to A, B, C. The same letter shall not appear as a single letter, or be included in a range of letters, more than once in all of the IMPLICIT statements in a scoping unit.\"\nSecond sentence of Para 3\n\"An IMPLICIT statement specifies the mapping for the letters in its letter-spec- list. \"\nReplace line 32, para 3\n\"mapping for all the letters. If a mapping is not specified for a letter, the default for a program unit or an interface\"\nwith\n\"mapping for all the letters. The default mapping for a program unit or an interface\"\nReplace lines 37 -38, para 4\n\"type parameters) mapped from the first letter of its name, provided the mapping is not null. The mapping for the first letter of the data entity shall either have been established by a prior IMPLICIT statement or be the\"\nwith\n\"type parameters) mapped from the first letter of its name, provided the mapping is not null. The mapping for the first letter of the data entity shall be the\"\nDelete last sentence of para 4\n\"An explicit type specification in a FUNCTION statement overrides an IMPLICIT statement for the result of that function.\"\nNOTE 1 on page 115 needs to be rewriten\nNOTE 2 on page 115 needs to be rewritten to show how to deal with the case where a variable is  synonymous with a derived type, making it difficult to declare such a derived type. Perhaps the introduction of namespaces (#1) will make this much easier.\nA NOTE needs to be added to show how to use other facilities when eliminating this form of the IMPLICIT statement.\nChange example (\"program fragment\") in para 5, C.9.2.2, page 556, pg 572\n\"There is an increased potential for undetected errors in a scoping unit that uses both implicit typing and the USE statement. ....  Logic errors resulting from this kind of situation can be extremely difficult to locate. Thus, the use of these features together is discouraged.\"\nEnd of edits.\nThe next step would be to declare implicit typing rules obsolescent. Eventually, both will be deleted."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-29 15:29:44+00:00",
                    "text": "@ThemosTsikas wrote:\n\n..\nThe next step would be to declare implicit typing rules obsolescent. Eventually, both will be deleted.\n\nI agree with you in principle.\nIn practice, I'll be thrilled if the order is reversed in order to achieve a \"compromise\"!\nMeaning, a relatively minor edit is made to the standard which is to effectively make IMPLICIT NONE the default.  Now, I have not pondered over fully in terms of accuracy and the implications but my proposal is the paragraph corresponding to mapping of letters with types in the current standard i.e., 18-007r1 document toward Fortran 2018, Section 8.7 IMPLICIT statement, paragraph 3 be edited as follows:\n[114:29-34]\nChange\n29 3 In each scoping unit, there is a mapping, which may be null, between each of the letters A, B, ..., Z and a\n30   type (and type parameters). An IMPLICIT statement specifies the mapping for the letters in its letter-spec-\n31   list. IMPLICIT NONE with an implicit-none-spec of TYPE or with no implicit-none-spec-list specifies the null\n32   mapping for all the letters. If a mapping is not specified for a letter, the default for a program unit or an interface\n33   body is default integer if the letter is I, J, ..., or N and default real otherwise, and the default for a BLOCK\n34   construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.\n\nto\n29 3 In each scoping unit, there is a mapping, which may be null, between each of the letters A, B, ..., Z and a\n30   type (and type parameters). An IMPLICIT statement specifies the mapping for the letters in its letter-spec-\n31   list. IMPLICIT NONE with an implicit-none-spec of TYPE or with no implicit-none-spec-list specifies the null\n32   mapping for all the letters. **If a mapping is not specified for a letter in a scoping unit, the default is null**.\n32   The default for a BLOCK construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.\n\nSuch a small change - only one sentence in the standard is modified - will make a world of difference in the domains I work where the full intent of powers-that-be and also the coders is to have no default mapping of letters with types (e.g., no default mapping of n with integer, etc.) but they have to take great care to add IMPLICIT NONE to each scope or resort to compiler options, both of which are frowned upon by an overwhelming majority of the teams I have worked with.\nAnd I'm personally convinced such a small change will have no adverse effect in other domains also because the situation everywhere is the same based on what I've researched: the intent everywhere is to have no default mapping of letters with types.  Every code one can see on GitHub or SourceForge, etc. either includes or intends to have IMPLICIT NONE in all their scopes.  So this small change of a proposal in this comment is only enabling what is overwhelmingly the practice."
                },
                {
                    "user": "certik",
                    "date": "2020-01-29 17:14:02+00:00",
                    "text": "@ThemosTsikas thanks for your comment! And thank you for participating here. If you have any other comments or suggestions to other proposals or have some proposals of your own, please definitely comment or open new issues here."
                },
                {
                    "user": "ThemosTsikas",
                    "date": "2020-01-29 17:40:39+00:00",
                    "text": "I think that the order I suggest has the merit that it first removes (or rather, marks as obsolescent) a bit of syntax before making changes in the semantics, and syntax is easier to check than semantics."
                },
                {
                    "user": "ThemosTsikas",
                    "date": "2020-01-30 13:26:30+00:00",
                    "text": "In #90 (comment), I wrote what would be needed to delete the IMPLICIT implicit-spec-list feature. What is needed is similar text for the marking of the feature as Obsolescent."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-03-06 23:21:25+00:00",
                    "text": "To those interested in this issue, here's a comment to take note at comp.lang.fortran thread where \"Lynn McGuire\" posted:\n\nThe number one dysfunctional item in Fortran is variable typing and\ndeclaration.  At the 1977 specs, much less the 1990 specs, all Fortran\nvariables should be explicitly declared and typed.  The implicit rule is\nok for small programs.  Not at all for anything more than say, a\nthousand lines of code."
                },
                {
                    "user": "elecprog",
                    "date": "2021-01-12 19:23:48+00:00",
                    "text": "I've been thinking a bit more on this issue lately, especially having used Fortran some more (after seemingly having partially opened Pandora's box with this thread).\nFirst four assumptions I'm making (which to my knowledge are true, but please correct me if I'm wrong):\n\nWe really want to get rid of implicit by default, but implicit semantics themselves don't have to go (in the short term at least).\nHaving code not compile\u2014but not break\u2014is a lesser evil than implicit by default, if that code can automatically be fixed.\nIf implicit none changes the semantics of the code, this always results in the code failing to compile.\nProgram units are easily detected.\n\nIf these assumptions are true, getting rid of implicit typing as a default is actually pretty straightforward:\nMake implicit none the default in the next standard and include a tool that detects the outer most program units, sees if there is any implicit statement and if not adds\nIMPLICIT INTEGER (I-N), REAL (A-H, O-Z)\nOptionally this tool could even verify if this change is needed, but it doesn't have to.\nAdditionally we could deprecate the implicit statement all together and leave it up to vendors if they support old code or not."
                },
                {
                    "user": "certik",
                    "date": "2021-01-12 20:33:31+00:00",
                    "text": "Thanks @elecprog for writing down the assumptions that you used. Under your assumptions I think your proposal could work.\nThe issue that we have is that we can't get a community agreement on the assumptions. I have seen opposition to the assumption 2., and consequently also 1. I personally agree with 2. (i.e., implicit by default being more evil), but some others disagreed (older code not compiling being more evil: Fortran historically tries very hard to compile older code, so I understand this position)."
                }
            ]
        },
        {
            "number": 89,
            "user": "ivan-pi",
            "date": "2019-11-15 21:49:58+00:00",
            "title": "Optional dimensioning in assumed-shape arrays",
            "text": "Assumed-shape arrays are often used to make calling subroutines easier, i.e. by not having to explicitly pass the array size (or bounds). Say we have a function which solves a system of equations for multiple right-hand sides returning the solution in right hand size array. The subroutine might look something like this:\nsubroutine solve(A,b,ierr)\n  real, intent(inout) :: A(:,:)\n  real, intent(inout) :: b(:,:)\n  integer, intent(out) :: ierr\n  ! check shapes match, if not, produce an error flag\n  ! perform factorization of A...\n  ! perform back substitution for columns of b...\nend subroutine\nThis interface is not optimal since, due to the rules of matrix multiplication, we actually know that the number of rows in b should be equal to the number of rows in A. Therefore one might expect it to be possible to use the following interface:\nsubroutine solve(A,b)\n  real, intent(inout) :: A(:,:)\n  real, intent(inout) :: b(size(A,1),:)\n \n  ! perform factorization of A...\n  ! perform back substitution for columns of b from 1 to size(b,2)...\nend subroutine\nThis way we could avoid the need for writing assertion statements to check if the first dimensions of A and B match, and forcing the user to check an error flag. Of course this problem can be avoided completely by using explicit shape arrays, defeating the entire point of having assumed-shape ones. A second (unattractive) option would be to use an assumed-size array, and explicitly pass only the number of columns in b:\nsubroutine solve(A,b,nb)\n  real, intent(inout) :: A(:,:)\n  real, intent(inout) :: b(size(A,1),*)\n \n  ! perform factorization of A...\n  ! perform back substitution for columns from 1 to nb...\nend subroutine\nCould someone perhaps explain what is the reason that the second example above is not allowed and the compiler flags it as a \"bad array specification\"?",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-15 21:56:24+00:00",
                    "text": "Thanks @ivan-pi for raising this issue. This is something I encounter very frequently myself. The explicit-shape arrays are actually more readable in this case:\nsubroutine solve(A, b, n, k)\n  real, intent(inout) :: A(n,n)\n  real, intent(inout) :: b(n,k)\n  integer, intent(in) :: n, k\n \n  ! perform factorization of A...\n  ! perform back substitution for columns of b from 1 to k...\nend subroutine\nExcept that one has to pass n and k as arguments. It would be nice to be able to do something like this with assumed-shape arrays."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-11-15 22:35:26+00:00",
                    "text": "I was annoyed by this today, while creating wrappers of some old least squares routines.\nI suppose that if assert statements (#70) were available then the current assumed-shape syntax would be sufficient."
                },
                {
                    "user": "certik",
                    "date": "2019-11-16 00:13:50+00:00",
                    "text": "Here is how it would look like with an assert statement:\nsubroutine solve(A, b)\n  real, intent(inout) :: A(:,:)\n  real, intent(inout) :: b(:,:)\n  assert(size(A,1) == size(A,2))\n  assert(size(A,1) == size(b,1))\n\n \n  ! perform factorization of A...\n  ! perform back substitution for columns of b from 1 to size(b,2)...\nend subroutine"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-16 17:51:00+00:00",
                    "text": "There have been some recent efforts to capture the array properties in Fortran like here and here,\nI wonder if the ideas in such papers can be improved upon to achieve something that works with dummy argument characteristics like array shapes or parts thereof?"
                }
            ]
        },
        {
            "number": 88,
            "user": "certik",
            "date": "2019-11-15 20:07:34+00:00",
            "title": "USE statement \u2013 wish: permit specifying additionally the access-spec",
            "text": "Tobias Burnus wrote:\nI want to suggest to permit the 'access-spec' to the use-stmt to set the\npublic/private default for the symbols use-associated (overridable by an\nexplicit access-stmt). \u2013 Thoughs?\nReal-world use case the following:\nI have two modules, one contains some definitions of parameters and the\nother contains some internal procedures. I now use-associate the two and\nwhat I would like to do is the following.\nNote the 'use, private' and 'use, public' with the access-spec.\nCurrently, I end up using 'private' and then adding 'public' for all\nsymbols from 'openacc_kinds', which is neither very readable nor\nmaintainable.\nmodule openacc\n   use, private :: openacc_internal\n   use, public :: openacc_kinds\n   implicit none (type, external)\n\n   private\n   public :: acc_get_num_devices\n\n   interface acc_get_device_type\n      ! shall be private, from openacc_internal\n     procedure :: acc_get_device_type_h\n   end interface",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-15 20:09:00+00:00",
                    "text": "Bill Long wrote:\nWe already allow\nmodule A\n   use B\n   private :: B\n\nwhich has the effect of making everything accessed from B private. Hence the things public in B do not \u201cleak\u201d through to a scope that as a USE A.\nTobias replied:\nI had missed this addition of Fortran 2018; Fortran 2008 didn't allow it.*\nI still believe that a use-stmt with access-spec is more readable than\nuse-stmt + access-stmt, but I agree that the functionality is already\ncovered. Hence, I think one should still (re)consider it \u2013 but with low\npriority."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 23:00:03+00:00",
                    "text": "I also think, that the use-stmt with access spec would be much more readable. Especially, with the original syntax, can you tell without detailed knowledge of the standard, what the public :: statement would make private? (Or is the code not-standard conforming at all?)\nmodule B\nend module B\n\nmodule C\n  integer, parameter :: B = 1\nend module C\n\nmodule A\n  use B\n  use C\n  private :: B\nend module A\n\nWriting on the other hand\nmodule A\n  use, private :: B\n  use, public :: C\n\nwould be obvious, I guess."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-21 16:44:56+00:00",
                    "text": "Yes, USE, PUBLIC and USE, PRIVATE is on my wish-list too."
                }
            ]
        },
        {
            "number": 87,
            "user": "certik",
            "date": "2019-11-15 20:02:15+00:00",
            "title": "Namespaces",
            "text": "@FortranFan wrote in #86 (comment):\nI have long debated in my own mind whether Fortran should formally introduce the concept of NAMESPACEs or whether MODULEs can themselves be elevated to first-class namespaces.  Looking at the proposal at #86 and with #1, I'm presently inclined toward the former.\nWhilst I don't quite have a list of the requirements and specifications necessary toward an initial proposal, a sketch of the idea is to include either a new NAMESPACE scope and/or NAMESPACE attribute to MODULEs in addition to PUBLIC/PRIVATE visibility of MODULEs in a NAMESPACE.  Then a given NAMESPACE can IMPORT other NAMESPACEs.  Fortran can formally define a GLOBAL namespace and state all EXTERNAL MODULEs (a la external procedures) in a program are part of this namespace.  The language can then have some rules for name qualification and aliasing.  Code then might look like the following with illustrative syntax:\nnamespace my_lib\n   public module constants\n      real, parameter :: PI = 3.14\n   end module\n   private module utils !<-- can be USE'd only by modules in the same namespace\n      interface\n         module subroutine draw()\n         end subroutine\n      end interface\n   end module\nend namespace\n\nnamespace my_lib !<-- A namespace can be extended with more modules\n   public module solver\n      use constants, only : PI !<-- It can USE modules from the same namespace\n   contains\n      function calcradius( a ) result( r )\n         real, intent(in) :: a\n         result :: r\n         r = sqrt(a/PI)\n      end function\n   end module\nend namespace\n\nnamespace global !<- optional, for 'global' namespace will exist by default\n   import my_lib, only : constants, solver ! import 'public' modules only from another namespace\n   program p !<-- A program unit can only be part of GLOBAL namespace\n      use constants, only : PI !<-- does not 'clash' with my_lib::constants\n      real :: area\n      print *, \"PI = \", PI !<-- PI from USE-associated 'constants' module \n      area = 100.0\n      associate ( PI => my_lib::constants%PI, calcrad => my_lib::solver%calcradius )\n         print *, \"circumference = \", 2.0*PI*calcrad(area)\n      end associate\n   end program\nend namespace\n\nNote the above is based on the use cases in #1 and #86; once more use cases are brought to light, it might help refine the idea of a NAMESPACE.",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 21:09:33+00:00",
                    "text": "I can't decide yet, whether I prefer this over the 'module elevation'.\nTil I can, one remark: if you add Fortran after the three ` that begin the code section, you get Fortran syntax highlighting =)"
                },
                {
                    "user": "certik",
                    "date": "2019-12-16 21:20:54+00:00",
                    "text": "@Libavius the above quote has fortran-modern after ```. The issue with just fortran is that GitHub colors it incorrectly, because it doesn't understand this proposed syntax, as it is not a standard Fortran syntax yet."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-09-22 01:59:29+00:00",
                    "text": "A thought I've been carrying once the work toward fpm commenced and how well fpm has been received is the notion of a formal language construct that itself can demarcate a package (or an assembly).  Especially how it can help make it viable for objects to be consumed across MODULEs readily within such a construct but not externally.\nSuch a formal construct (say a package) can open up the notion of an \"internal\" entity that is USE'able within that construct but not externally to it.  This can help greatly relative to the current limitations of PUBLIC/PRIVATE visibility of entities in MODULEs.\nThus one can include some of the characteristics that namespaces tend to offer (such as in C++ and those \"inspired\" by it). But not be constrained by that concept which is now in common parlance in much of computer science literature but which is not without limitations.\nThat is, the facility that ultimately comes about in Fortran can be \"Fortranesque\" when it comes to serving the practical needs of practitioners and not carry the \"baggage\" of familiarity and resultant expectations with namespaces."
                }
            ]
        },
        {
            "number": 86,
            "user": "certik",
            "date": "2019-11-14 23:15:29+00:00",
            "title": "Allow modules to be nested like in Python",
            "text": "Use Cases\nModule name clashes\nIt is very common to have modules named constants.f90, mesh.f90, solver.f90, utils.f90, types.f90, etc. (the modules have the same name as the file name in this example). When writing an application this is not a problem. But when writing a library, one cannot name modules like that, because if the application that uses the library also has constants.f90, then the modules will clash. Pretty much the only solution is to name the modules as libraryname_constants (usually implemented in libraryname_constants.f90).  This is suboptimal, because when the application uses any module from the library, it has to type in the long name (e.g., use libraryname_constants, only: pi).\nDistribution\nWhen you distribute a Fortran library, you have to distribute all modules, which can easily be dozens and dozens of .mod files, which all end up littering your $PREFIX/include.\nSolution\nAllow modules to be nested. In Python, one creates the following directory structure:\nmylib\n\u251c\u2500\u2500 a.py\n\u251c\u2500\u2500 b.py\n\u2514\u2500\u2500 __init__.py\n\nand then one can import files as follows:\n>>> import mylib\n>>> import mylib.a\n>>> import mylib.b\n\nThis particular import will become possible in Fortran with #1, but in the meantime one could do the equivalent of this:\n>>> from mylib import something\n>>> from mylib.a import something\n>>> from mylib.b import something\n\nThis solution fixes both uses cases above. There can be mylib.constants and there will be no name clashes. When the library is distributed, it is installed as:\n$PREFIX/include/mylib.mod\n$PREFIX/include/mylib/a.mod\n$PREFIX/include/mylib/b.mod\n\nPerhaps it could even be:\n$PREFIX/include/mylib/__module__.mod\n$PREFIX/include/mylib/a.mod\n$PREFIX/include/mylib/b.mod\n\nSo there is no littering.\nIssues to resolve\nThe Fortran standard does not talk about files and filesystem. Unless we want to change it, the module nesting feature must be implemented similar to submodules. The exact syntax needs to be figured out.\nWhy not submodules? Submodules unfortunately do not allow to implement the above use case with mylib to be able to import nested modules. With submodules a large Fortran library would have to stop using modules, it would only have one module and lots of small submodules. My understanding is that the submodule can only extend things declared in the main module. So you cannot for example do use mylib%b, only: something. You would have to have something in mylib.f90 itself. This does not scale for large libraries with hundreds of files.\nSyntax: Regarding syntax, probably using % would work, to make it consistent with #1, so the above Python imports would translate to:\nuse, namespace :: mylib\nuse, namespace :: mylib%a\nuse, namespace :: mylib%b\n...\ncall mylib%a%something()\n\nand\nuse mylib, only: something\nuse mylib%a, only: something\nuse mylib%b, only: something\n...\ncall something()",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-14 23:22:11+00:00",
                    "text": "I think that you conflate source file names with module names above.  They're actually independent.  Can you state the problem you're trying to solve just in terms of module names and Fortran?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:33:58+00:00",
                    "text": "In the above I assume the module name is the same as the file name. I agree the standard does not care about the file name, just the module name. The two use cases I give are already formulated in terms of module names (edit: I see, I updated the above description to be specific that I mean module names, not file names). If you have some specific question, I'll be happy to clarify."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 23:56:03+00:00",
                    "text": "The set of global identifiers (19.2) is a flat namespace.  I think you're proposing that, at least for module names and submodule identifiers (q.v.), that they could be distinct members of an independent set of identifiers associated with a module rather than in the set of global identifiers.\nIf that's right, then I suggest that way to indicate that module M be nested within another module's namespace is to put that top-level module's name on M's MODULE statement, as in\nMODULE(TOP) M\n\nA USE X within M would search for and prefer a module X in TOP, if it exists, before attempting to associate with a global module X.\nDoes this make sense, or have I missed the point?\n(EDIT: syntax changed to look more like SUBMODULE statement)"
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 00:01:09+00:00",
                    "text": "@klausler yes that's exactly what I am proposing. (There might be more details to iron out beyond what you just wrote.)"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-15 00:05:10+00:00",
                    "text": "That seems quite useful and would be easy to implement."
                },
                {
                    "user": "tskeith",
                    "date": "2019-11-15 00:13:49+00:00",
                    "text": "If that's right, then I suggest that way to indicate that module M be nested within another module's namespace is to put that top-level module's name on M's MODULE statement, as in\nMODULE(TOP) M\n\n\nIs TOP really another module? If so does M have visibility to any declarations in TOP besides modules?\nOr is TOP more like a C++ namespace? I.e. it comes into being when it's mentioned as above and all it does is organize module names. This seems a lot simpler."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-15 00:29:11+00:00",
                    "text": "If that's right, then I suggest that way to indicate that module M be nested within another module's namespace is to put that top-level module's name on M's MODULE statement, as in\nMODULE(TOP) M\n\n\nIs TOP really another module? If so does M have visibility to any declarations in TOP besides modules?\nOr is TOP more like a C++ namespace? I.e. it comes into being when it's mentioned as above and all it does is organize module names. This seems a lot simpler.\n\nI guess that I was thinking the former rather than the latter, since other parts of the program would contain USE TOP to access its external interfaces."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-15 02:50:04+00:00",
                    "text": "After more reflection: how is this concept any different from using SUBMODULE?  There's a top-level MODULE with the public API, and then nested submodules in their own module-specific namespace."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-15 04:21:30+00:00",
                    "text": "@certik wrote:\n\nUse Cases\nModule name clashes\nIt is very common to have modules named constants.f90, mesh.f90, solver.f90, utils.f90, types.f90, etc. (the modules have the same name as the file name in this example). When writing an application this is not a problem. But when writing a library, one cannot name modules like that, because if the application that uses the library also has constants.f90, then the modules will clash. Pretty much the only solution is to name the modules as libraryname_constants (usually implemented in libraryname_constants.f90). This is suboptimal, because when the application uses any module from the library, it has to type in the long name (e.g., use libraryname_constants, only: pi).\nDistribution\nWhen you distribute a Fortran library, you have to distribute all modules, which can easily be dozens and dozens of .mod files, which all end up littering your $PREFIX/include.\n..\n\n@certik, I have long debated in my own mind whether Fortran should formally introduce the concept of NAMESPACEs or whether MODULEs can themselves be elevated to first-class namespaces.  Looking at your proposal here and with #1, I'm presently inclined toward the former.\nWhilst I don't quite have a list of the requirements and specifications necessary toward an initial proposal, a sketch of the idea is to include either a new NAMESPACE scope and/or NAMESPACE attribute to MODULEs in addition to PUBLIC/PRIVATE visibility of MODULEs in a NAMESPACE.  Then a given NAMESPACE can IMPORT other NAMESPACEs.  Fortran can formally define a GLOBAL namespace and state all EXTERNAL MODULEs (a la external procedures) in a program are part of this namespace.  The language can then have some rules for name qualification and aliasing.  Code then might look like the following with illustrative syntax:\nnamespace my_lib\n   public module constants\n      real, parameter :: PI = 3.14\n   end module\n   private module utils !<-- can be USE'd only by modules in the same namespace\n      interface\n         module subroutine draw()\n         end subroutine\n      end interface\n   end module\nend namespace\n\nnamespace my_lib !<-- A namespace can be extended with more modules\n   public module solver\n      use constants, only : PI !<-- It can USE modules from the same namespace\n   contains\n      function calcradius( a ) result( r )\n         real, intent(in) :: a\n         result :: r\n         r = sqrt(a/PI)\n      end function\n   end module\nend namespace\n\nnamespace global !<- optional, for 'global' namespace will exist by default\n   import my_lib, only : constants, solver ! import 'public' modules only from another namespace\n   program p !<-- A program unit can only be part of GLOBAL namespace\n      use constants, only : PI !<-- does not 'clash' with my_lib::constants\n      real :: area\n      print *, \"PI = \", PI !<-- PI from USE-associated 'constants' module \n      area = 100.0\n      associate ( PI => my_lib::constants%PI, calcrad => my_lib::solver%calcradius )\n         print *, \"circumference = \", 2.0*PI*calcrad(area)\n      end associate\n   end program\nend namespace\n\nNote the above is based on the use cases in #1 and this one; once more use cases are brought to light, it might help refine the idea of a NAMESPACE."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 06:14:21+00:00",
                    "text": "@FortranFan would you mind please opening a separate issue for namespaces? Let's discuss it there. Namespaces are another approach how to fix some of the issues reported here, but it is I think premature to decide that modules are dead, namespaces are the way to go, because namespaces have downsides also. We just need to discuss both approaches and see.\nUpdate: I created #87 for namespaces."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 06:17:29+00:00",
                    "text": "After more reflection: how is this concept any different from using SUBMODULE? There's a top-level MODULE with the public API, and then nested submodules in their own module-specific namespace.\n\nSubmodules do not allow you to import a symbol from a submodule. For example, let's say you have a parent module TOP and a submodule A. If A defines sin, you cannot import it from elsewhere. The only way to do that is if TOP itself defines sin (it can be implemented in A).\nIn otherwords, with submodules you have to move every declaration to the TOP module.\nWith nested modules as I am proposing, the TOP module can be empty. You can still put things into it if you want to, but you don't have to. Just like in Python."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 08:39:58+00:00",
                    "text": "Further advantage of nested modules over submodules: Nested modules would not (should not!) share names via host association.\nIf in a big library you have several levels of sub- modules, e.g. modules, sub-modules, sub-sub-modules, it can become very cumbersome to find out, where a given name comes from. Looking at a name in the sub-sub-module, it can be either something local, something defined in the parent sub-module or in grand-parent module, so you would have to look up 3 files to check for it.\nI think, submodules are a perfect way to separate interfaces from implementations in order to avoid re-compiling cascades. (For this, you only need modules and one level of submodules.)  But I don't think, that they are the right construct for structuring a big library."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-15 16:16:42+00:00",
                    "text": "Thanks for the clarification vs. submodules, I think that I understand the distinction.\nSo something like this would work for you?\nMODULE(parent) child\n  ...\nEND MODULE\n...\nMODULE parent\n  USE, NESTED :: child\nEND MODULE\n\n(with additional extensions to SUBMODULE so that they can still be used with nested modules)\nEDIT: Make NESTED look like other module-nature keywords in the USE statement."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 19:59:41+00:00",
                    "text": "@klausler I think that would work. And I want multiple level of nesting, just like in Python.\nIt's just too bad that submodules were designed the way they were. It's a missed opportunity. I don't know if there is a way to adapt them to do what we want, or if the above must be a separate functionality."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 20:05:15+00:00",
                    "text": "Even for nested modules it would make sense to divide each of them into an interface part and an implementation part to avoid recompilation cascades. For that, the submodule construct is perfect as it is now. So, I think, what we need is an additional mechanism enabling module nesting."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-15 20:05:26+00:00",
                    "text": "@klausler I think that would work. And I want multiple level of nesting, just like in Python.\nIt's just too bad that submodules were designed the way they were. It's a missed opportunity. I don't know if there is a way to adapt them to do what we want, or if the above must be a separate functionality.\n\nSubmodules seem entirely complementary to your nested modules.  Submodules automatically inherit from their ancestors and supply implementations.  Nested modules define interfaces (and implementations) to be composed by their parents.  The information flows in opposite directions."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 20:12:34+00:00",
                    "text": "Yes you are right, indeed the nested modules are exactly the opposite of submodules. So we should have both."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 22:53:37+00:00",
                    "text": "In Python, the package hierarchy is tightly connected to the directory structure. In Fortran, due to the lack of that concept in the standard, we can not rely on any file system information for the hierarchy. That means the hierarchy information basically reduces to an arbitrary hierarchy-prefix you can add to your modules (a kind of name mangling). The only rule we need, I guess, to require that no module can import any other module being above it in the hierarchy. Connected with namespaces (#1) we could get quite close to what Python offers. And we could still keep the sub-module concept for the separation of interface and implementation. Based on @klausler's suggestion, I am thinking about something like the following:\n! module without prefix\nmodule level1\n  use, namespace, relative :: level2\nend module level1\n\n! module with prefix\nmodule (level1) level2\ncontains\n  subroutine level2_test()\n  end subroutine level2_test\nend module level1\n\n! module with prefix\nmodule (level1%level2) level3\ncontains\n  interface\n    module subroutine level3_test1()\n    end subroutine level3_test1\n    module subroutine level3_test2()\n    end module subroutine\n  end interface\nend module level3\n\n! submodule\nsubmodule (level1%level2%level3) level3impl\ncontains\n  subroutine level3_test1()\n  end subroutine level3_test1\nend submodule level3impl\n\n! sub-sub-module\nsubmodule (level1%level2%level3:level3impl) level3impl2\ncontains\n  subroutine child_test2()\n  end subroutine child_test2\nend submodule level3impl2\n\n\nprogram test\n  ! Imports level1 as namespace\n  use, namespace :: level1\n  use, namespace :: level1%level2%level3\n\n  call level1%level2%test_level2()\n  call level1%level2%level3%test_level3()\n\nend program test\n\nIt could be realized also without namespaces, if that turns out to be a problem, then it would correspond to the from level1.level2.level3 import * kind of imports in Python."
                }
            ]
        },
        {
            "number": 85,
            "user": "gronki",
            "date": "2019-11-14 17:56:17+00:00",
            "title": "modern do loop syntax (#80)",
            "text": "originally proposed by Espen Myklebust in #80\nNew syntax for iterated DO loops\nProposal\nAdd a new syntax for declaring a DO statement loop-control that follows the pattern of modern Fortran. This syntax will be further enhanced with subsequent syntax proposals\nRationale\n\nThe \u201cregular\u201d DO construct index/control specification has a completely different form than the modern Fortran constructs\n\n\nA comma separated list specifying the control variable (instead of a triplet)\na label (legacy from non-block DO)\nno parenthesized expression or specification\n\n\nIt also lacks some additional features of the DO CONCURRENT and FORALL index specifications\nA consistent notation should be pursued\n\n\nextremely helpful when learning the language\n\nProposed syntax\n[do-construct-name :] DO [ ,] FOR( [type-spec ::] index-spec-list [ , scalar-mask-expr] )\n:\nEND DO [do-construct-name]\n\nThis matches the DO CONCURRENT syntax exactly, with the obvious difference in the \u201cDO-keyword.\u201d However, if more than one index variable is specified there must be a rule for determining in which order the indices are incremented, in contrast to the case for a DO CONCURRENT construct where this does not matter. The following rule is suggested:\nThe leftmost index declared is incremented first, then the second leftmost and so on.\nThis is consistent with how the subscript order value increases in array element order which have a pleasant\nimplication when looping through arrays.\nExample\nThe following loop\nDO j=1,m\n  DO i=1,n\n    IF ( i.LT.n .AND. j.LT.m ) THEN\n      a(i,j) = a(i,j) + a(i+1,j+1)\n    END IF\n  END DO\nEND DO\ncould be written much more compactly as\nDO FOR( i=1:n, j=1:m, i.LT.n .AND. j.LT.m )\n  a(i,j) = a(i,j) + a(i+1,j+1)\nEND DO\nIn both loops the indices are specified in the order that should(?) achieve the best performance, but whereas for the present syntax the outermost construct (usually declared first?) must have the last index and the innermost construct the first one, the proposed syntax declares the indices in the same order as they (should!) appear in the array qualifier. This is perhaps a minor detail (that some compilers automatically mend), but in the writers experience, at least beginners and those that are not aware of this, tend to declare the nested loops \u201cin the reverse order.\u201d Of course it would also be possible to maintain the structure of the first code block, only changing the loop-control parts to the new syntax, as shown below\nDO FOR( j=1:m )\n  DO FOR( i=1:n )\n\nComments\n\nThe proposed syntax makes it easy to switch between a CONCURRENT and regular DO by just changing\nthe token, as opposed to having to respecify the whole statement\nCompared to the present \u201clegacy\u201d DO construct it also adds the possibility\n\n\nto declare multiple index/control variables,\ntheir type parameter, and\nfor a mask expression\n\n\nThe token FOR is widely used for this kind of loop\nIn the last code block it could be possible to include the masking expression since the loop control variables would be equally well known to the program as in the middle code block.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 18:29:00+00:00",
                    "text": "I overall like it and it would be a quality-of-life improvement.\nI like the rule where the index increment order is specified left-to-right.\nfor seems redundant though. Why not just\ndo ( i=1:n, j=1:m, i < n .and. j < m )\n  a(i,j) = a(i,j) + a(i+1,j+1)\nend do\nWith this syntax, the do concurrent() would then be a special case of this more general form."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 20:45:30+00:00",
                    "text": "It will be nice if Espen Myklebust can be acknowledged explicitly upfront in the original post.\n\n\nI had the same thought as @milancurcic, one of the two tokens DO/FOR appears redundant.  Why not try to avoid any impact on DO construct, the most important and perhaps the most complicated block construct in the language, why not consider this a new FOR construct?\n\n\n   for ( i=1,n; j=1,m; (i < n) .and. (j<m) )\n      a(i,j) = a(i,j) + a(i+1,j+1)\n   end for\n\n\n\nThere appears an unwritten rule in the language with FORALL and DO CONCURRENT constructs that colon notation e.g., 1:n is intended to signal loop iterations in no specified order.  So one might end up needing some change to the syntax, perhaps one that retains the comma as in 1,n but introduces the line separator of semi-colon to separate the loop variables.\n\n\nNow, making the loop variables a construct entity and thus being able to declare them with a <type-spec> is rather important.  However this might be the opportunity to introduce iterators into Fortran, so the loop control needn't be using only an integer variable.\n\n\nLoop control schemes need to be worked out, especially with CYCLE, EXIT.\n\n\nNote though the development of a good set of requirements and specifications for such a construct is the real challenge; syntax is the easy part."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 20:48:50+00:00",
                    "text": "Sorry I thought it was clear enough. I updated it :)"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 21:02:34+00:00",
                    "text": "What problem does this proposal solve?  Is this problem important enough to justify all of the work needed to define the feature precisely, implement a demonstration prototype, compile the edits needed to formalize it in the standard, implement it in all current compilers and IDEs, document it in tutorials and reference works, and maintain it forever?\nSorry if it seems like I'm picking on this particular proposal; the question that I posed is one that I think about with every proposal that arises here.  In this case, the price seems higher than average, and I don't understand the payoff."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 22:03:29+00:00",
                    "text": "As I see it, technically any syntax improvements are \"just to make it\neasier on the eye\", but this is as important as adding a new functionality.\nIn this case, it removes the discrepancy between the \"old\" do and new \"do\nconcurrent\" constructs; it enables to simplify nested loops (very prevalent\nin scientific computing); it allows to declare the loop variable in the\nloop statement (having to declare ``integer :: i, j, k`` on top of the each\nprocedure to use in all following loops is annoying). Loops are one of the\nmost important things Fortran is made for and the first thing you notice in\nthe code. So I would say it will highly improve the language.\n\nczw., 14 lis 2019 o 22:02 Peter Klausler <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n What problem does this proposal solve? Is this problem important enough to\n justify all of the work needed to define the feature precisely, implement a\n demonstration prototype, compile the edits needed to formalize it in the\n standard, implement it in all current compilers and IDEs, document it in\n tutorials and reference works, and maintain it forever?\n\n Sorry if it seems like I'm picking on this particular proposal; the\n question that I posed is one that I think about with every proposal that\n arises here. In this case, the price seems higher than average, and I don't\n understand the payoff.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#85?email_source=notifications&email_token=AC4NA3LYJ62XGIHQLNKNCF3QTW4GXA5CNFSM4JNPMB7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEDI5UQ#issuecomment-554077906>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NQMWJL5TVM4VE5NWDQTW4GXANCNFSM4JNPMB7A>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 22:11:24+00:00",
                    "text": "@klausler wrote:\n\nWhat problem does this proposal solve? Is this problem important enough to justify all of the work needed to define the feature precisely, implement a demonstration prototype, compile the edits needed to formalize it in the standard, implement it in all current compilers and IDEs, document it in tutorials and reference works, and maintain it forever?\nSorry if it seems like I'm picking on this particular proposal; the question that I posed is one that I think about with every proposal that arises here. In this case, the price seems higher than average, and I don't understand the payoff.\n\nAs I tired to suggest above, there are several problems with current DO loop that can be addressed with such a proposal:\n\n\nAllow the DO loop variable to be a construct entity.  Coders then need not introduce the silly integer :: i, j, k, .. statements in the declaration section of a program unit only to consume these in DO loops.\n\n\nAllow the looping using iterators, not just integer variables\n\n\nReduce verbosity with compound loops\n\n\nReduce the learning curve of using DO loops efficiently, particularly for those who use Fortran as a second/third or a part-time coding language."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 22:32:54+00:00",
                    "text": "@klausler wrote:\n\nWhat problem does this proposal solve? Is this problem important enough to justify all of the work needed to define the feature precisely, implement a demonstration prototype, compile the edits needed to formalize it in the standard, implement it in all current compilers and IDEs, document it in tutorials and reference works, and maintain it forever?\nSorry if it seems like I'm picking on this particular proposal; the question that I posed is one that I think about with every proposal that arises here. In this case, the price seems higher than average, and I don't understand the payoff.\n\nAs I tired to suggest above, there are several problems with current DO loop that can be addressed with such a proposal:\n\nAllow the DO loop variable to be a construct entity.  Coders then need not introduce the silly integer :: i, j, k, .. statements in the declaration section of a program unit only to consume these in DO loops.\nAllow the looping using iterators, not just integer variables\nReduce verbosity with compound loops\nReduce the learning curve of using DO loops efficiently, particularly for those who use Fortran as a second/third or a part-time coding language.\n\n\n\nIndex variables in DO CONCURRENT and FORALL are already construct entities (19.4.6), and an integer-type-spec is allowed in the concurrent-header (R1125).\nFortran doesn't have iterators.\nOther alternatives exist; as a case in point, the example presented to support this feature really should be written as an array assignment A(1:N-1,1:M-1) = A(1:N-1,1:M-1) + A(2:N,2:M).\nIf you mean \"easier to learn\", that claim needs to be substantiated; it's not immediately obvious to me why it would be so."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 22:47:06+00:00",
                    "text": "Ad 1: Yes exactly. This is the point. It is allowed in ``do concurrent``\nbut not in plain ``do`` which are obviously not the same. So the point is\nto unify do syntax so it also uses *concurrent-header*.\n\nAre there any non-trivial conflicts that this might cause? Because for now\nI don't see any real problems with this proposition.\n\nczw., 14 lis 2019 o 23:32 Peter Klausler <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n @klausler <https://github.com/klausler> wrote:\n\n What problem does this proposal solve? Is this problem important enough to\n justify all of the work needed to define the feature precisely, implement a\n demonstration prototype, compile the edits needed to formalize it in the\n standard, implement it in all current compilers and IDEs, document it in\n tutorials and reference works, and maintain it forever?\n Sorry if it seems like I'm picking on this particular proposal; the\n question that I posed is one that I think about with every proposal that\n arises here. In this case, the price seems higher than average, and I don't\n understand the payoff.\n\n As I tired to suggest above, there are several problems with current DO\n loop that can be addressed with such a proposal:\n\n    1. Allow the DO loop variable to be a construct entity. Coders then\n    need not introduce the silly integer :: i, j, k, .. statements in the\n    declaration section of a program unit only to consume these in DO loops.\n    2. Allow the looping using iterators, not just integer variables\n    3. Reduce verbosity with compound loops\n    4. Reduce the learning curve of using DO loops efficiently,\n    particularly for those who use Fortran as a second/third or a part-time\n    coding language.\n\n\n    1. Index variables in DO CONCURRENT and FORALL are already construct\n    entities (19.4.6), and an *integer-type-spec* is allowed in the\n    *concurrent-header* (R1125).\n    2. Fortran doesn't have iterators.\n    3. Other alternatives exist; as a case in point, the example presented\n    to support this feature really should be written as an array assignment A(1:N-1,1:M-1)\n    = A(1:N-1,1:M-1) + A(2:N,2:M).\n    4. If you mean \"easier to learn\", that claim needs to be\n    substantiated; it's not immediately obvious to me why it would be so.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#85?email_source=notifications&email_token=AC4NA3M4H4CSM34BGUGPHPDQTXGZRA5CNFSM4JNPMB7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEDRJLY#issuecomment-554112175>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KKUTZJ4X4RBGNOJO3QTXGZRANCNFSM4JNPMB7A>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 22:51:43+00:00",
                    "text": "The strongest argument for this proposal is that the do loop becomes consistent with its parallel / concurrent variant: one only adds the concurrent keyword to a loop to make it run parallel, with no other syntax changes."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-15 15:33:51+00:00",
                    "text": "@certik wrote:\n\nThe strongest argument for this proposal is that the do loop becomes consistent with its parallel / concurrent variant: one only adds the concurrent keyword to a loop to make it run parallel, with no other syntax changes.\n\nDo (!) keep in mind it can prove extremely difficult to do (!) anything with the DO construct, to make it consistent with DO CONCURRENT syntactically while not impacting adversely any of the existing semantics appears anything but simple e.g., with CYCLE, EXIT; or the definition of loop variables upon termination; or one-pass/zero-pass.  This can prove to be the backward compatibility issue on steroids!\nHence a new construct e.g., FOR that can possibly help introduce other facilities also might be a safer approach."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-15 15:59:30+00:00",
                    "text": "@FortranFan that's an important point regarding cycle and exit semantics.\nMy default assumption is that this doesn't deprecate the existing do. It only adds this general do() construct to the language. Maybe this isn't what @gronki meant."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-15 17:19:59+00:00",
                    "text": "Yes I think the do() will be a new construct so I don't see any backwards\ncompatibility issues.\n\npt., 15 lis 2019 o 16:59 Milan Curcic <notifications@github.com> napisa\u0142(a):\n\u2026\n @FortranFan <https://github.com/FortranFan> that's an important point\n regarding cycle and exit semantics.\n\n My default assumption is that this doesn't deprecate the existing do. It\n only adds this general do() construct to the language. Maybe this isn't\n what @gronki <https://github.com/gronki> meant.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#85?email_source=notifications&email_token=AC4NA3PKVP4WSPPLXAP3XYTQT3BOHA5CNFSM4JNPMB7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEF35WQ#issuecomment-554417882>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3PZJ6LEPWKQKFGNYKLQT3BOHANCNFSM4JNPMB7A>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 19:56:30+00:00",
                    "text": "@FortranFan good point, I haven't thought about it that way. I just don't like 2 different ways of doing the same thing, but maybe we have to in this case."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-15 21:35:34+00:00",
                    "text": "Well the new DO will only share the name with old DO. The old DO did not\nallow multiple loop variables and mask expression. It is an entirely new\nconstruct with a different syntax and behavior, including corner cases you\nmentioned. So any backwards compatibility arguments do not apply here.\n\npt., 15 lis 2019 o 20:56 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n @FortranFan <https://github.com/FortranFan> good point, I haven't thought\n about it that way. I just don't like 2 different ways of doing the same\n thing, but maybe we have to in this case.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#85?email_source=notifications&email_token=AC4NA3PB7VUKQA7NUMTQ3ULQT35HBA5CNFSM4JNPMB7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEGRKNA#issuecomment-554505524>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3JU3YE3OK7IESBCRVLQT35HBANCNFSM4JNPMB7A>\n ."
                }
            ]
        },
        {
            "number": 84,
            "user": "aradi",
            "date": "2019-11-14 11:42:04+00:00",
            "title": "Mod file completeness",
            "text": "I would find it useful, if the standard required mod-files to be complete / self-contained. Given a library consisting of several modules and a wrapper module exposing the public API\nmodule library_api\n  use library_module1\n  use library_module2\n  implicit none\n  private\n\n   public :: public_entry1, public_entry2\n\nend module library_api\n\nthe standard should enforce, that the mod-file generated for the module library_api should contain all information necessary to import the module (via use library_api) in any application.\nCurrently, there is at least one compiler I know (NAG), where use library_api requires not just the presence of library_api.mod, but also all the modfiles for the modules imported by library_api directly or indirectly. This is annoying, if you want to distribute the library in binary form, and it also unnecessarily exposes the internal structure of the library (and enables the consumer to basically import any module of the library directly and call routines from it).",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-14 15:23:46+00:00",
                    "text": "The standard has nothing to say about module files, not even their existence.\nIs it possible to always \"flatten\" modules in Fortran into single modules, even in the presence of renaming?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-14 17:00:09+00:00",
                    "text": "The problem here is that when you have large, nested modules the module files become enormous and slow down compilation. DEC Fortran started with making each .mod file self-contained, but the impact on build times was intolerable, so it shifted to opening each .mod as needed.\nFor library developers what you usually need to do is separate public and private interfaces and definitions. Submodules can help. As for distributing in binary form, this simply does not work as each compiler has its own binary format and its own API into the support library."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 17:38:14+00:00",
                    "text": "Why is one combined module file bigger/slower than the combined size of the transitive closure of the module files that it uses?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 20:04:51+00:00",
                    "text": "I would find it useful, if the standard required mod-files to be complete / self-contained. ..\n\nThis is outside the purview of the current standard.  Before something like this can even be considered, a clear vision and scope would need to be developed toward which all aspects of implementation details should be covered by the standard.  That is a monumentally difficult thing to pursue."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-14 20:29:02+00:00",
                    "text": "For library developers what you usually need to do is separate public and private interfaces and definitions. Submodules can help. As for distributing in binary form, this simply does not work as each compiler has its own binary format and its own API into the support library.\n\n@sblionel Thanks a lot. Yes, exactly, I would wish for a good support for exposing only interfaces which are meant to be public. If I think about submodules, then the entire library would have to be a single module (containing the public API of the library) with several sub- and sub-sub-modules containing the actual implementation details. Is this the way you suggest?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:17:36+00:00",
                    "text": "with several sub- and sub-sub-modules containing the actual implementation details. Is this the way you suggest?\n\nSubmodules do not scale in my opinion to large libraries, as explained in #86. The issue #86 was one of the first issues that I had when I joined the committee, but I only created an actual GitHub issue for it now. I got reminded of it, since this issue #84 is very similar to #86."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 09:40:42+00:00",
                    "text": "Yes, nested modules are a nice idea, I fully support it (see my comment there). But, it still does not solve the problem, that you may need to expose the internal structure of your library (in form of having to provide the mod-files for all modules in it), when it should be imported by a program. In C / C++, you would only install the include file for the public API, which I find much cleaner. But in terms of costs, maybe this proposal would not be worth the effort, indeed. So let's concentrate on nested modules (#86) instead."
                },
                {
                    "user": "zerothi",
                    "date": "2021-11-10 13:03:06+00:00",
                    "text": "I would support this effort for fortran.\nA big problem with fortran libraries is the requirement of shipping together the compiled *.mod files. And so having a uniform way in the standard to define module/include files for external use is paramount to not complicate matters for end-users!\nUsing compiler A with dependency on library X compiled with compiler B is currently a nightmare!\nCurrently one is just told: don't do this but this is limiting the use of fortran I think!"
                },
                {
                    "user": "aradi",
                    "date": "2021-11-10 15:06:46+00:00",
                    "text": "@zerothi Unfortunately, this proposal would not solve the issue you raised. Since the Fortran libraries compiled with various compilers are not ABI compatible, it still remains, that all modern Fortran libraries your project depends on must be compiled with the same compiler."
                },
                {
                    "user": "zerothi",
                    "date": "2021-11-10 20:26:17+00:00",
                    "text": "Exactly. :)\nIn addition to what you have here it would be ideal if the module files are not binary files, or at least ensures that different compilers can inspect the interfaces/derived types in a non-compiler specific format."
                },
                {
                    "user": "klausler",
                    "date": "2021-11-10 20:29:16+00:00",
                    "text": "The format of module files is not within the purview of the standard.  (f18 uses a module file format that any other Fortran compiler could inspect, though; maybe that will help you someday.)"
                },
                {
                    "user": "zerothi",
                    "date": "2021-11-10 20:35:24+00:00",
                    "text": "The format of module files is not within the purview of the standard. (f18 uses a module file format that any other Fortran compiler could inspect, though; maybe that will help you someday.)\n\nBut why could it not be part of the standard? ;)\nThis problem is recurring and prohibits system admins from choosing fortran coding for sys-tools (granted it isn't made for this but...)."
                }
            ]
        },
        {
            "number": 83,
            "user": "aradi",
            "date": "2019-11-13 09:12:27+00:00",
            "title": "Language version keyword",
            "text": "There are several features in Fortran many of us wish to see changed / deprecated in order to support and enforce modern programming practices (see for example . Unfortunately doing so would break backwards compatibility of the language, which would sacrifice one of Fortrans advantages.\nWhat about adding a keyword to the language, which indicates the language version of the code in a given unit (module). Something like:\nmodule my_modern_module\n  language_version 2022\n ...\nend module my_modern_module\n\nAll module files without explicit language version keyword would be treated as having code complying  to the last standard without this keyword (e.g 2018). All module files with the language version keyword would be treated accordingly to the specified version.\nAdvantages:\n\nOne could deprecate features much faster without fearing to break backwards compatibility.\nThe user would not have to deal with compiler specific flags to enforce a given practice or language standard (like -assume realloc_lhs or similar). Especially, if you have source files with different language standards in a project (no nice, but can happen), you won't need to fiddle with the compilation options for each file individually.\nA single line could enforce several requirements without too much verbosity, so instead of having\nimplicit none(type, external)\nimplicit save off\nshort_circuiting on\n...\n\none would just write\nlanguage_version 2022\n\nto profit from all the features / requirements a given Fortran standard offers / enforces.\nFinally, its marketing value would tremendous. Every source file in a modern Fortran project, every slide presented in a Fortran course, would advertise, that this beautiful language, despite being the first high level (modern!) language, is still alive and is able to adapt to the requirements of the present.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 13:38:48+00:00",
                    "text": "@aradi , please see this thread at comp,lang.fortran where a similar idea re: a 'version specifier' was posted.\nWhile I am personally not sold yet on the specific keyword idea (I wonder if a simpler semantic alternative might be attainable for the same), I wholeheartedly agree with and support your sentiment you express, particularly in your last bullet, toward Fortran language.  The relevance of Fortran in scientific and technical programming is profound and hope it can remain as such, its strength lies in both in its legacy but more importantly with the potential for the future that can allow scientists and technologists to focus almost exclusively on their domain expertise and their computations without having to get their hands \"dirty\" with the nitty-gritty details and artifacts of computer engineering (pointers, LValue/Rvalue, etc.)"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 14:13:18+00:00",
                    "text": "@FortranFan Thanks for the link, I was not aware of that discussion. By looking at it, I could not find any serious counter arguments, why this idea can not be or should not be done.\nAs for the keyword itself: If there is any other superior semantic solution, we should go with that then. For me, it is only important that we can adapt the language to current programming customs faster. While every programming language has its own peculiarities, those peculiarities should have a good justification other than we always did this way. As I mentioned on the other issue here, I am often feeling ashamed, when explaining to students that they must put implicit none in every module (especially if their project should pass the exam \ud83d\ude06 )."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 15:51:58+00:00",
                    "text": "I don't have strong feelings one way or another about the general idea, but I will caution that standardizing keywords such as standard version numbers is fraught with risk for compiler developers and users. Consider that the name of Fortran 2018 changed in the year or so before publication. What you would end up with is either vendors having to support multiple, synonymous keywords (some of which would not be conforming in the new standard), or delaying support until the standard is published meaning a delay before programmers could use them.\nThere is also the issue of incomplete implementations and TSes, assuming a TS changed the meaning of a past standard (unlikely but it could happen.)\nSee also my 2013 thoughts on a related topic."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 16:31:06+00:00",
                    "text": "Available options\nIn Fortran, we do not break old code (#79), so the only way to introduce a breaking feature is to signal to the compiler that the given source file is using the new feature, and by default no signalling is done, so the old feature is being used. So the only question is how to signal to the compiler. Here are the options that I have seen proposed:\n\n\nFile suffix specifying a version (.f90, .f03, .f08, .f18, .f2x, .f2y)\n\n\nCompiler option for the version (-std=f95, -std=f18, -std=f2x)\n\n\nCompiler option for a feature (-frealloc-lhs, -fimplicit-none, ...)\n\n\nKeyword for the version (this issue #83)\n\n\nKeyword for a specific feature (implicit none, implicit save off (see #40), ...)\n\n\nKeyword for modern (modern module X) which would not use obsolete features (features can become obsolete in the future and one would need to update the code)\n\n\nIs there fundamentally any other way to consider?\nAnalysis\nThe option 1. does not seem to be a good way as @sblionel explained here, and I agree.\nThe option 2. is already used in compilers such as gfortran, but my understanding is that the standard does not enforce new features, so even with the latest -std=f18, the feature implicit none is not enabled unless explicitly told so. In other words, the newest standard does not break old code. So the options 1., 2., and 4. actually cannot impose implicit none, unless F202x or F202y introduces a breaking change of enabling implicit none by default, and historically this is not how we have done things. But unless that is changed, you would still have to do:\nlanguage_version 202x\nimplicit none(type, external)\nimplicit save off\nshort_circuiting on\n...\n\nThat leaves options 3. and 5., both of which one can use today, but the problem with these is that as more and more optional features are added, it will be more and more painful to be always explicitly enabling them at the beginning of each module, such as:\nimplicit none(type, external)\nimplicit save off\nshort_circuiting on\n...\n\nThe objection from Steve regarding the fact that the name of the standard changes until it is released is easily fixed by simply using the placeholder -std=f2x, until F202X is released and then changing it to -std=f23 (for X=3). That's how C++ does it and f2x just becomes an alias for f23. I think that's not a problem in practice.\nSo the main issue that I can see in here is that some future standard, say 202y will introduce a breaking change such as enabling implicit none by default. And if you tell the compiler (no matter whether using an option -std=f2y, or by using a keyword language_version 2y), then the new feature will be used by default. That is a fundamentally different way of doing it --- and that's what we should discuss if we want that.\nUpdate: added option 6."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 16:44:49+00:00",
                    "text": "@certik That's a nice summary on the possible options, thanks! One note on the topic, whether to realize it via compiler option or language construct: I think, a programming language should be self-contained. A compiler should be able to generate correctly behaving code (and stop on standard violation) just by reading the source code itself without the need of any additional hints in form of command line options. Latter should in my opinion only serve 'fine-tuning' purposes instead of being indispensable for the correctness of the generated code."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 16:49:35+00:00",
                    "text": "And yes, I would vote for breaking backwards compatibility in newer standards for the sake of simplicity and code robustness, provided a standardized language construct ensures that old code can be still compiled without the necessity of using extra (vendor dependent!) compiler options."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 16:56:31+00:00",
                    "text": "@aradi so let's discuss some of the breaking features that could be considered:\n\n#40\n#19 (however it seems it won't pass, and instead .andthen will be introduced which is not a breaking feature)\nrealloc LHS\n\nAnything else? Because if it's just these, then there might be a way to achieve what we want without breaking backwards compatibility (for example #40 can be fixed by changing \"implicit none\" to \"explicit all\" or something like that --- still just one line to be added to every module), so we do not need the feature discussed in this issue."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-13 17:12:03+00:00",
                    "text": "I will be the devils advocate here, since I am usually the hater on the old code, but I will argue that this solution is inherently dangerous.\nFirst, let me prefice that with what I consider the absolutely basic design feature I expect Fortran to have: prevent silent errors. So ugly syntax or not, what I personally get paid for is to get good numeric results.\nConsider the very root of such solutions, which probably is the familiar line\nimplicit none\nThe implicit typing feature was deemed to be unsafe and thus new, stricter rules for typing can be enabled with this switch. Please notice:\n\nif you omit the implicit none, the functionality of the code will not change\nif you use -fimplicit-none (or equivalent) switch, the functionality of the code will not change\n\nReading the code mid-file, you don't need to check the top of the file to see the implicit none. You just use the implicit typing and whether this mode is enabled or not, you will be good. Now if you start using implicit typing and implicit none was in effect, you will get a compiler error. All good.\nNow consider the proposed switch (let's stick to my favorite implicit save). For example:\nimplicit nosave\n\nIf you do that, the behavior of the code will change violently in a completely non-distinguishable way. Whenever you see:\ninteger :: i = 0\n\nyou have no idea whether i will be zero on each call or not. And worst of all, if you make a mistake, you will not be warned.\nNow when you work with different files, some of them written in 1980s, other in 2010s, you cannot just write right Fortran: you have to keep in mind which typing/saving/... rules are in place. Which is exactly the reason why implicit typing was deemed unsafe!\nAs much as I hate and despise this feature, I think we cannot provoke such situations. It must be clear looking at the code whether the variable is save or not. A couple of solutions have been proposed:\n\ninteger, nosave :: i = 0 -- IMO pain to type\ninteger, init :: i = 0 -- nicer to type on QWERTY keyboard\ninteger :: i := 0 -- or some other operator, such as =>. The good side is that there are no keywords that clutter the code.\n\nAny solution must be nice to type. This keyword/syntax will be used a lot. So I personally would prefer some operator-based syntax because having nosave every 3 lines would cause a lot of clutter, especially in editors with syntax highlighting. But the worst case init would be not that much pain.\nNow this ended up being an implicit save post which I didn't intend but I did not know how to split it so maybe I will post exactly the same thing in the other place."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 17:46:23+00:00",
                    "text": "@gronki thank you. These are precisely the kinds of arguments that we have to have. I commented at #40 (comment) with my proposal there."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 19:06:58+00:00",
                    "text": "@aradi so let's discuss some of the breaking features that could be considered:\n\n#40\n#19 (however it seems it won't pass, and instead .andthen will be introduced which is not a breaking feature)\nrealloc LHS\n\nAnything else? Because if it's just these, then there might be a way to achieve what we want without breaking backwards compatibility (for example #40 can be fixed by changing \"implicit none\" to \"explicit all\" or something like that --- still just one line to be added to every module), so we do not need the feature discussed in this issue.\n\nThat list could be a lot longer.  All \"deleted\" and most \"obsolescent\" features could finally be disabled (e.g., EQUIVALENCE, Hollerith, extensions like STRUCTURE) in a program unit that declares itself to be \"modern\".\nSyntactically, this sort of thing might look best as a prefix on the MODULE statement, i.e. MODERN MODULE FOO.  And it should be inherited and enforced in submodules."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 19:33:23+00:00",
                    "text": "@klausler, that's a great idea. Perhaps the standard can simply declare some features as \"obsolescent\", and those would work by default, but if you use modern module foo, all \"obsolescent\" features will get disabled.\nOne problem that I can see is that when a future standard makes something \"obsolescent\" and you happen to use that feature in your modern module foo, your code will break. And you cannot just remove modern, because you use some other \"modern\" features, so your code will simply stop working until you fix it. I think that's a problem."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 19:33:50+00:00",
                    "text": "@gronki I think the point you raise is absolutely right. Having a language version keyword would indeed make the behavior of certain constructs \"context-dependent\". Actually, we have that already in the language, since\ninteger, allocatable :: a(:), b(:)\n...\na = b\n\ntriggers LHS reallocation depending whether you stick with Fortran 95 or 2003. And, which one of the both is used, depends on the compiler options you use for compilation. There is no way to tell it by looking at the source code alone. The language keyword would at least let you know it by declaring the standard conformance at the beginning of your scope."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 19:40:13+00:00",
                    "text": "@klausler Thanks, indeed the list could be considerably longer. And I agree that it is a good idea to encode the standard compliance already into the module statement. However, I'd suggest to keep it general with possibilities for future adjustments, so using something more specific as modern, e.g.\nmodule, language(f2008) :: my_module\nor something similar."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-13 23:55:09+00:00",
                    "text": "@aradi I would argue that this is an unfortunate exception from the past which should not be a reason to introduce even more unfortunate exceptions like this. It is not a problem anymore since f2003+ compliant compilers are available for free so there is no reason to use f95 compiler anymore. The time to version Fortran was in 1990: it was great moment to fork the language and make it independent of F77 pains. This was not done and now with F2018 this is far too late.\nPlease also keep in mind that not everyone using the Fortran language is as passionate as us to remember which year number will enable which behavior. This is also an important factor. It's about making programming simpler, not harder."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 00:01:03+00:00",
                    "text": "@klausler, that's a great idea. Perhaps the standard can simply declare some features as \"obsolescent\", and those would work by default, but if you use modern module foo, all \"obsolescent\" features will get disabled.\n\nSee Annex B, especially B.3."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-14 09:26:21+00:00",
                    "text": "@gronki You are right, we definitely should not expect Fortran practitioners to be language history experts.\nI think, we have to differentiate between different kind of backwards compatibility breaks:\n\n\nFeatures becoming deprecated/obsolete/deleted because they are considered harmful and newer constructs allow more robust implementation of the same or similar functionality (e.g. GOTO EQUIVALENCE, common blocks, etc.)\n\n\nSemantic changes, where the same code behaves differently dependent which version of the standard one adheres to (e.g. automatic LHS-reallocation, a possible redefinition of assignment on declaration, etc.)\n\n\nThe acceptable frequency for those two categories is clearly different. For the first one, I would wish that nearly each standard would deprecate old eventually harmful features, when new more robust alternatives had been introduces. Semantic changes on the other hand should be as rare as possible. For me, having 1-2 changes every 20-25 years would be acceptable (max. 2 changes during my entire professional career from writing the first code as student till being retired at the age of 67), but of course your opinion may differ on this.\nWhen we had a language version keyword, it would cover both kind of changes. If semantic changes happen only every 2 or 3 decades, Fortran practitioners would not have to be language history experts, because a given code line would be warranted to keep its exact meaning/behavior for at least that amount of time. But if such a change happens, the explicit language keyword at the top of the module would make sure, that it still compiles (and behaves) as before without the necessity of vendor dependent compiler switches.\nAdditionally, by specifying the language version at the top of your modules, beginners looking at your modern Fortran projects could immediately realize, that the language constructs used in that code are still considered to be good practice. Having something like module, language(f2018) :: my_module would ensure, no language construct has been used, which the Fortran committee considered harmful or obsolete in the year 2018."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 14:34:01+00:00",
                    "text": "@certik wrote:\n\nAvailable options\nIn Fortran, we do not break old code (#79), so the only way to introduce a breaking feature is to signal to the compiler that the given source file is using the new feature, and by default no signalling is done, so the old feature is being used. So the only question is how to signal to the compiler. Here are the options that I have seen proposed:\n\nFile suffix specifying a version (.f90, .f03, .f08, .f18, .f2x, .f2y)\nCompiler option for the version (-std=f95, -std=f18, -std=f2x)\nCompiler option for a feature (-frealloc-lhs, -fimplicit-none, ...)\nKeyword for the version (this issue #83)\nKeyword for a specific feature (implicit none, implicit save off (see #40), ...)\n\nIs there fundamentally any other way to consider?\n..\n\nWhy not allow the nearly 30 years of usage to be of guidance in some matters at least such as the IMPLICIT problem in Fortran?  What I mean by this is take advantage of the built-in \"signaling\" in the language with free-form source and how this option is being used by the practitioners.\nCan anyone point to any code-base using free-form source where \"implicit typing\" is employed per code design?  Code after code that uses free-form source tries to have the \"IMPLICIT NONE\" line in all the scopes yet end up with embarrassment and grief and anger at the Fortran standard when this line is omitted unintentionally with some disastrous consequences in a scope e.g., INTERFACE block which does not inherit the \"IMPLICIT NONE\" from the host.\nSimilarly, can anyone point to any code-base that explicitly relies on implied SAVE in its code design?\nWhat the discussion here and elsewhere show is there are no perfect solutions to this pernicious IMPLICIT problem, both with types and the SAVE  attribute.  The situation is akin to the legendary Gordian knot.  Why not then take an obvious solution from history which is to simply cut the damn thing out?\nAs is, there are crucial differences in syntax (and by extension, I would argue, in semantics) between free-form and fixed source.\nSo what breaking impact and damage is expected if both IMPLICIT typing and implied SAVE are deleted altogether from free-form source?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-14 17:09:04+00:00",
                    "text": "While I hate implicit typing as much as any of you, it is such an integral part of the language I don't see having it off by default being taken seriously. (\"God is real, unless declared integer\") I would also not be in favor of tying this to source form - the whole idea is that the source forms are equivalent.\nUsers have learned to account for implicit typing with coding and usage standards (requiring use of compiler options that turn it off, for example). I don't see it worthwhile spending time arguing this after so long.\nImplicit save is harder - the posts here have focused on initialization in declarations, but that is a recent (!) addition to the language, supplanting DATA, where a large body of code expects SAVE semantics and breaks if that doesn't occur. Again, this is an integral aspect to the language and I don't see changing it worthwhile. I'd be in favor of adding IMPLICIT (NOSAVE)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 21:49:41+00:00",
                    "text": ".. implicit typing .. it is such an integral part of the language I don't see having it off by default being taken seriously. (\"God is real, unless declared integer\")\n\nJokes apart, \"implicit typing\" only belongs to the past history of this language.  It's not \"integral\" in any way; every scope of a Fortran unit one see out there strives to negate it.  There is so much time and energy wasted to inform coders to avoid it (an example here) and there is so much loss of goodwill toward Fortran on account of this 'feature', Fortran is seriously hurting itself by retaining this aspect.\n\nI would also not be in favor of tying this to source form - the whole idea is that the source forms are equivalent.\n\nThe two source forms are not equivalent, one only has to look at the syntax and semantics of line continuation which is so important given the restrictions of fixed-form source.\n\nUsers have learned to account for implicit typing with coding and usage standards (requiring use of compiler options that turn it off, for example). I don't see it worthwhile spending time arguing this after so long.\n\nNo, many a new user does not learn to accept this and that's the point.  Trying to get new coders to work on Fortran codes, particularly in industry, is a huge challenge.  Few join with any background in Fortran, few schools teach Fortran.  Then one loses them at 'hello' itself, meaning at the very beginning stage when one stresses to them the need to type 'implicit none' in every scope.\n\nImplicit save is harder - .. this is an integral aspect to the language and I don't see changing it worthwhile. I'd be in favor of adding IMPLICIT (NOSAVE).\n\nTo reiterate, both implicit typing and implied save introduce 'silent errors' (to borrow the term by @gronki), these two aspects are pernicious, they bring tremendous vulnerabilities to Fortran code.  To argue they are integral to the language in year 2019 conveys an entirely wrong message about Fortran.\nSeparately, the added risk that will get introduced with yet another addition to the IMPLICIT statement was mentioned upthread just yesterday by @gronki.  That's what made me think further about using the source form itself has a signal to the compiler.\nI inquire again of the several questions in #83 (comment).\n\nCan anyone point to any code-base using free-form source where \"implicit typing\" is employed per code design?\nCan anyone point to any code-base that explicitly relies on implied SAVE in its code design?"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 22:02:18+00:00",
                    "text": "I would also not be in favor of tying this to source form - the whole idea is that the source forms are equivalent.\n\nThe two source forms are not equivalent, one only has to look at the syntax and semantics of line continuation which is so important given the restrictions of fixed-form source.\n\nAny Fortran program can be represented in both source forms without differing in their semantics as the term is otherwise universally understood.  Altering the language so that source form affects semantics is a non-starter."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 22:10:52+00:00",
                    "text": "@FortranFan People use implied save unfortunately. For example here:\nhttps://github.com/abinit/abinit/blob/056c00bbb1a2f55c1b9851bf873a329dd8edf3e2/src/95_drive/m_gstate.F90#L2614\nI am sure there are tons of other places. Looking at this particular code, I do wonder if it's intended, or if it's a bug."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-14 22:50:37+00:00",
                    "text": "@certik wrote:\n\n@FortranFan People use implied save unfortunately. For example here:\nhttps://github.com/abinit/abinit/blob/056c00bbb1a2f55c1b9851bf873a329dd8edf3e2/src/95_drive/m_gstate.F90#L2614\nI am sure there are tons of other places. Looking at this particular code, I do wonder if it's intended, or if it's a bug.\n\nThanks much, I've contacted ABINIT to find out whom I can reach out to learn about this particular section of their code.  My hunch looking at that code is their intent is different and it's not a significant use of implied SAVE, but I hope to find out more."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 22:59:15+00:00",
                    "text": "It would be extremely ironic if, contrary to all the fears about backwards compatibility, silently removing \"implicit save\" would fix more codes than it would break. ;)"
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:25:45+00:00",
                    "text": "I must say I am leaning towards @FortranFan's idea of simply removing implied save, exactly as I initially proposed in #40. I posted there a comment how it can be done: #40 (comment). What I like about #40 is that we actually very conservatively discuss the various pros and cons, and breaking backwards compatibility is a huge con that we all agree on, and we try to figure out how to best proceed. But the pros are very compelling and in the end, if done right, might outweigh the con.\n(With a backwards compatibility breakage like this, we absolutely need to have a prior compiler implementation and actually test it on real production codes. And we need automatic facility to find implicit save usage in codes and fix it, automatically. That's a given requirement.)"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-14 23:53:08+00:00",
                    "text": "And we need automatic facility to find implicit save usage in codes and fix it, automatically.\n\nThis would be quite easy to write. We wouldn't even need a full parser. All that would be necessary is the ability to:\n\nDetect what sort of program unit you are in (program, module, subroutine, function, etc.)\nDetect assignment within variable declaration\nDetect attribute lists within variable declaration\nDetect SAVE ::  statements\n\nFORD already does essentially all of this just with regular expressions, although the way it manipulates the source code internally means it would not be suitable for performing the fixes. However, I reckon I could write a single file script along these lines in about a week if I could devote the time to it."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:59:02+00:00",
                    "text": "@cmacmackin yes, it's absolutely doable. All I am saying we have to do it, test it with real codes, and provide good guidelines how to upgrade, as part of any such change."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-15 05:10:32+00:00",
                    "text": "@FortranFan People use implied save unfortunately. For example here:\nhttps://github.com/abinit/abinit/blob/056c00bbb1a2f55c1b9851bf873a329dd8edf3e2/src/95_drive/m_gstate.F90#L2614\nI am sure there are tons of other places. Looking at this particular code, I do wonder if it's intended, or if it's a bug.\n\n@certik, I'm currently inclined to think the authors of ABINIT meant for that variable to be an entity of the module rather than a local in that procedure, so I'm unsure as to whether I can accept ABINIT is a code-base that explicitly relies on implied SAVE in its code design.\nmodule m_gstate\n      ...\n      integer, target, protected, save :: ndtpawuj = 4\n      ..\n   contains\n      ...\n      subroutine subroutine pawuj_drive( ..\n      ...\n\nAnd I'm not convinced the Alexandrian measure of removing implied SAVE from the language will 'break' ABINIT: with such a change in the language and with current ABINIT code remaining as-is. a local variable ndtpawuj will come into existence with a value of 4 and with a TARGET attribute each time the procedure 'pawuj_drive' is invoked and that's all ABINIT might care about.\nI will be really surprised to find FOSS-type of code on GitHub, SourceForge, etc. rely on implied SAVE, or if they do, anyone throwing a fit about refactoring to include the explicit SAVE attribute with variable declarations.  It's a matter of mindset, a certain openness to adopt FOSS which also enables good sense to be explicit in everything in order to maximize clarity for the widest audience of one's code.\nThe issue is with unverifiable claims about code held privately.  Now I happen to work with a lot of teams in industry who have such 'private/proprietary' code.  If there is one thing I know for sure it is that none of the critical 'private/proprietary' code are going to remain in Fortran for long unless this language keeps apace fully with modern trends and truly enhances type safety and reduces code vulnerabilities, particularly as cloud and parallel computing come to the fore.  Imagine one line somewhere hidden with an implied SAVE also has the potential to cause data race conditions or lock scenarios with the risk of rendering a Fortran library not thread-safe and thus unfit for consumption in a cloud service.\nI too can attest and that is to so many code-bases moving away Fortran permanently.  An initiative such as #40 by @certik et al. can be a truly positive intent to help reduce this 'bleeding'."
                },
                {
                    "user": "certik",
                    "date": "2019-11-15 06:10:23+00:00",
                    "text": "@FortranFan what we absolutely have to prevent is the Python 3 fiasco (e.g., just saw this: https://stackoverflow.blog/2019/11/14/why-is-the-migration-to-python-3-taking-so-long/), when Python 3 was released 11 years ago, and there are still many huge code bases in Python 2 that just cannot upgrade, and the amount of effort it took Facebook, Dropbox, etc. to port is just unbelievable, and all pretty much for nothing.\nAt the same time, I agree with you, we want to fix some of these things. We just need to figure out how to do it carefully."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 08:03:50+00:00",
                    "text": "@sblionel I think, we have to balance between not making to much trouble to existing Fortran projects and keeping Fortran appealing enough for new projects. The long term survival of the language may depend even more on new projects than on existing ones. And when the decision for the programming language in a new scientific / numeric project is made, Fortran has to compete mostly with Python, Julia and C++, so the competition is quite strong. While you can bring rational pro and con arguments for all those languages, the appeal of the language will also play a major role. And implicit none for example is definitely not sexy.\n@certik The comparison with the Python 2 / Python 3 framework holds only partially. By introducing for example a language keyword (OT of this issue \ud83d\ude09 ), all projects would be warranted to compile unchanged till the end of times, as the language keyword (or its absence) would let the compiler know, which backwards incompatible changes it is allowed to consider and which ones not.\nI am not advocating the language keyword as the ultimate solution (explicit all as suggested in  #40 would solve several our current issues as well). But I think it demonstrates very well, that we could have ways to improve on the language,  retire constructs which did not prove to be useful and make it more appealing for new projects without affecting existing projects."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-17 02:35:15+00:00",
                    "text": "@klausler wrote:\n\n..\nAny Fortran program can be represented in both source forms without differing in their semantics as the term is otherwise universally understood. Altering the language so that source form affects semantics is a non-starter.\n\nSemantics in programming language theory begins with the evaluation of syntactically valid tokens in a language and when a token itself is syntactically invalid in one form in Fortran e.g., P R I N T versus another, the argument the two source forms are semantically equivalent is totally bogus\n      P R I N T *, \"Hello there, the differences between free source for\n     1m and fixed form in Fortran are in the gray area between syntax an\n     2d semantics, particularly with the significance or lack thereof wi\n     3th blanks in statements and with line continuation in character co\n     4ntext\"\n      END"
                },
                {
                    "user": "certik",
                    "date": "2019-11-17 04:23:50+00:00",
                    "text": "@FortranFan If possible, please give @klausler some benefits of the doubt. My own understanding is also that the semantics of fixed form and free form are indeed identical. What I mean by that is that once you do the parsing (one way or another) and represent the syntax using Abstract Syntax Tree (AST), the AST nodes are identical, as far as I can tell so far. The example you gave would have the same AST node (Print), and it would have an argument of type string, that is properly processed. Then when you add the semantics (types), it should still be identical. I think there are some differences that you pointed out, but they do not seem to translate to any differences on the AST level."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-17 05:51:51+00:00",
                    "text": "@certik  wrote:\n\n.. I think there are some differences that you pointed out, but they do not seem to translate to any differences on the AST level.\n\nI really don't think how a parser might represent some source in AST or whatever format has anything to do with semantics at the most basic level.  For a given programming language, semantics would allow instructions to be evaluated based on some rules in a completely independent manner by anyone or anything, it can be a group of faithful after a Sunday service or 'Despicable Me' minions or whatever that can strictly follow the rules.\nUnder the circumstances, the shortest (perhaps) of a complete fixed-form source E N D cannot evaluated at all under the rules of free-form source and thus the argument the 2 forms are equivalent semantically or otherwise becomes entirely moot.\n\nC:\\temp>type p.for\n      E N D\n\nC:\\temp>gfortran -c p.for\n\nC:\\temp>type p.f90\n      E N D\n\nC:\\temp>gfortran -c p.f90\np.f90:1:6:\n\n       E N D\n      1\nError: Unclassifiable statement at (1)\n\nC:\\temp>\n\nSure, the source can be modified syntactically to remove the 2 offending blanks and the processor for free-form can then translate it into something that will be the same as with fixed-form.  The entire premise of viewing the two as same resides on trivializing the action behind the removal of 2 blanks.\nBut the bothersome aspect here is there is no consistency in such 'courtesy': should one have to port some implicitly typed code in fixed-form to free-form, why not be totally open-minded to the need to perform an 'action' like explicitly declare the variable when one is open to do the same with the supposedly insignificant blanks in one's fixed-form source anyway?  Once such an action is taken, both forms would output the same AST nodes.\nC:\\temp>type p.for\n      I = 42\n      END\n\nC:\\temp>gfortran -c p.for\n\nC:\\temp>type p.f90\n      I = 42\n      END\n\nC:\\temp>gfortran -c -fimplicit-none p.f90  !<-- simulate 'new' default with -f switch\np.f90:1:7:\n\n       I = 42\n       1\nError: Symbol 'i' at (1) has no IMPLICIT type\n\nC:\\temp>type p.f90\n      INTEGER I\n      I = 42\n      END\n\nC:\\temp>gfortran -c p.f90\n\nC:\\temp>"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-18 17:16:22+00:00",
                    "text": "I think that I'm wasting my time here."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-18 20:35:56+00:00",
                    "text": "@klausler, @FortranFan  We should come back to the original topic: is it desirable to have a keyword which allows to deprecate harmful features without breaking backwards compatibility? Therefore, we are talking about an explicit new keyword, not about existing source code format. Currently, this could help us to deprecate:\n\nimplicit typing\nimplicit saving\nimplicit external subroutines\nvarious old language constructs (equivalence, entry, etc.)\n\nAll those deprecations would be backwards compatible in the sense that all codes not specifying this keyword (or specifying an old language version) would behave as ever. Only new codes explicitely declaring being modern Fortran would be affected.\nThe first two items could be equivalently realized in a backwards compatible way by implicit none (type, external, save) or by the much shorter and in my opinion much more appealing explicit all as suggested by @FortranFan.\nSo the the question really is, whether the possibility of deprecating all other constructs and the possibility of being able to handle future deprecations on the same foot (by using a language version identifier) are worth to introduce a new keyword in the language. And whether the concerns raised so far (e.g. by @gronki ) are severe enough we dispose the idea (and close this issue)."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-18 21:21:54+00:00",
                    "text": "Are there any other commonly used programming languages that have such a concept, and if so, what does it look like?\nI get the desire for disabling some of the older features, and a coding standard (organization imposed) that might require same, but I'm struggling to see how this feature helps with existing code or would make life easier for new development. The changes to IMPLICIT allow the compiler to detect missing types or external attributes, but disabling implicit SAVE is not something a compiler could reliably detect a violation of.\nI'll note that obsolescent and deleted features (EQUIVALENCE, ENTRY, etc.) are already easily called out simply by asking the compiler to issue standards warnings, though I often heard from users that they would like this to be finer grained (VAX FORTRAN allowed you to say that tab source form was ok, but not other standards violations, for example.)\nThere have been attempts before (F, ELF) to trim down the language to \"only the new stuff\", and they were roundly ignored. Once you start down this road, where do you stop? Does every Fortran program need an associated XML document enabling or disabling hundreds of language features? Is that Fortran anymore?\nI agree 100% that some of these ancient features are responsible for subtle errors in applications - I sure saw enough of them in my decades of doing Fortran user support. I'm just having a hard time with the idea of versioning the language."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-19 03:01:24+00:00",
                    "text": "@aradi wrote:\n\n.. @FortranFan We should come back to the original topic: is it desirable to have a keyword which allows to deprecate harmful features without breaking backwards compatibility? ..\n..\n\n@aradi with respect to the issues at hand with implicit typing and implied save, trying to retain backwards compatibility in the standard itself is a severely limiting constraint that will likely lead to highly suboptimal solution(s).\nAnd it also appears an exercise in futility since almost all the processors figure out other ways to continue supporting the removed features any way..\nThus with implicit typing and implied save, I prefer to see the language just delete them outright.\nSuch a move can be a boon for vendors who will then invent ways their processors can avoid the breaking of old code that rely on these 2 aspects, should there be such code-bases out there at all.\nBut everyone else will be freed up once and for all to cleanly work with a modern, type-safe Fortran that perhaps will also allow in situ variable declarations and initialization.\nThe other 2 categories are not of much concern:\n\n\nexternal procedures are mostly a thing of the past, at least in the few codes that are in Fortran in the teams I work with; unlike implicit typing and implied save, we don't worry about hidden traps involving them especially because the few new coders are more than happy to develop CONTAINed procedures in MODULEs and SUBMODULEs.\n\n\nsame with old features such as EQUIVALENCE, ENTRY, etc. or constructs such as arithmetic GOTO - there is hardly any risk of inadvertent usage of these things since no one I know who wants to use these facilities.\n\n\nThus I feel the language version keyword is not needed."
                },
                {
                    "user": "certik",
                    "date": "2019-11-19 05:11:49+00:00",
                    "text": "Javascript also has use strict: https://www.w3schools.com/js/js_strict.asp"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-19 15:43:57+00:00",
                    "text": "@sblionel No, I don't know any languages having this kind of versioning, so maybe it is not a very good idea at all. Still, I see it as a good compromise since it would allow to deprecate bad practices without breaking backwards compatibility. (In this point I disagree with @FortranFan as I still think that keeping backwards compatibility is important for a serious programming language.) It should not be an individual choice, allowing each one to cherry-pick his favourite features  / deprecations (as you suggest with the XML-file approach). This you can do by using appropriate compiler flags anyway already. It would rather offer a standardized (compiler vendor independent) way for a programmer to make sure, she/he complies with those coding practices, which the Fortran standard committee has found advisable at the time of a given standard."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-19 16:35:54+00:00",
                    "text": "I think that some form of \"hardening\" keyword is perharps the golden\nsolution as long as, similarly to \"implicit none\", it prohibits obsolete\nprogramming style (implicit typing, implicit save without explicit \"save\"\nkeyword, etc.) and does not change behavior of already conforming codes.\nWhich means when if removed the program will behave exactly the same.\n\nPerhaps a keyword like \"strict\" could be introduced (or, proposed by\nsomeone, \"modern\") that would enable \"implicit none\" and keep strict\nprohibition of features marked as \"obsolete\" in the standard. At the same\ntime, programs with that keyword would not be guaranteed to be\nstandard-conforming indefinitely. If you want your software to run for the\nnext 50 yrs unchanged (for example, because of certification issues), just\ncomment/remove that line in the code you deliver to the customer.\n\nWhat do you think about this approach?\n\nwt., 19 lis 2019 o 16:43 B\u00e1lint Aradi <notifications@github.com> napisa\u0142(a):\n\u2026\n @sblionel <https://github.com/sblionel> No, I don't know any languages\n having this kind of versioning, so maybe it is not a very good idea at all.\n Still, I see it as a good compromise since it would allow to deprecate bad\n practices without breaking backwards compatibility. (In this point I\n disagree with @FortranFan <https://github.com/FortranFan> as I still\n think that keeping backwards compatibility is important for a serious\n programming language.) It should not be an individual choice, allowing each\n one to cherry-pick his favourite features / deprecations (as you suggest\n with the XML-file approach). This you can do by using appropriate compiler\n flags anyway already. It would rather offer a *standardized* (compiler\n vendor independent) way for a programmer to make sure, she/he complies with\n those coding practices, which the Fortran standard committee has found\n advisable at the time of a given standard.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3OCHJRSE6YEUXMG5ILQUQCT7A5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEOUMXA#issuecomment-555566684>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KG35U5JMUD2M5GJ3LQUQCT7ANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-19 16:39:59+00:00",
                    "text": "And the reason that I propose this as a part of the language (and not a\ncompiler switch) is that I think standard should be more enforcing about\nnot using old features. Just because implicit typing is in the standard for\nbackwards compatibility, nobody seriously considers it a legitimate of the\nlanguage in 2019. For now, I feel the standarization entities are too\npassive about letting people still use this features.\n\nwt., 19 lis 2019 o 17:35 Dominik Gronkiewicz <gronki@gmail.com> napisa\u0142(a):\n\u2026\n I think that some form of \"hardening\" keyword is perharps the golden\n solution as long as, similarly to \"implicit none\", it prohibits obsolete\n programming style (implicit typing, implicit save without explicit \"save\"\n keyword, etc.) and does not change behavior of already conforming codes.\n Which means when if removed the program will behave exactly the same.\n\n Perhaps a keyword like \"strict\" could be introduced (or, proposed by\n someone, \"modern\") that would enable \"implicit none\" and keep strict\n prohibition of features marked as \"obsolete\" in the standard. At the same\n time, programs with that keyword would not be guaranteed to be\n standard-conforming indefinitely. If you want your software to run for the\n next 50 yrs unchanged (for example, because of certification issues), just\n comment/remove that line in the code you deliver to the customer.\n\n What do you think about this approach?\n\n wt., 19 lis 2019 o 16:43 B\u00e1lint Aradi ***@***.***>\n napisa\u0142(a):\n\n> @sblionel <https://github.com/sblionel> No, I don't know any languages\n> having this kind of versioning, so maybe it is not a very good idea at all.\n> Still, I see it as a good compromise since it would allow to deprecate bad\n> practices without breaking backwards compatibility. (In this point I\n> disagree with @FortranFan <https://github.com/FortranFan> as I still\n> think that keeping backwards compatibility is important for a serious\n> programming language.) It should not be an individual choice, allowing each\n> one to cherry-pick his favourite features / deprecations (as you suggest\n> with the XML-file approach). This you can do by using appropriate compiler\n> flags anyway already. It would rather offer a *standardized* (compiler\n> vendor independent) way for a programmer to make sure, she/he complies with\n> those coding practices, which the Fortran standard committee has found\n> advisable at the time of a given standard.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#83?email_source=notifications&email_token=AC4NA3OCHJRSE6YEUXMG5ILQUQCT7A5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEOUMXA#issuecomment-555566684>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AC4NA3KG35U5JMUD2M5GJ3LQUQCT7ANCNFSM4JMWOOTQ>\n> .\n>"
                },
                {
                    "user": "certik",
                    "date": "2019-11-19 22:11:11+00:00",
                    "text": "I think this modern (or strict) keyword is another way, so I added it to my list above: #83 (comment)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-20 03:16:00+00:00",
                    "text": "@aradi wrote:\n\n.. In this point I disagree with @FortranFan as I still think that keeping backwards compatibility is important for a serious programming language.)  ..\n\n@aradi , please note I'm not against backwards compatibility in a general sense, I'm completely for a thorough consideration always to \"do no harm\" a la Hippocratic oath when it comes to introducing new features in the language.  But I do think implicit typing and implied save are so harmful to Fortran's well-being, these two are so gangrenous that I now believe they need to be amputated."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-12-11 03:32:10+00:00",
                    "text": "@certik wrote:\n\nI think this modern (or strict) keyword is another way, so I added it to my list above: #83 (comment).\n\nSometimes I wonder, for how long will we the current Fortran be \"modern\". I imagine future Fortranners will laugh back at us Fortran 2018 people at some point too. If I can remember correctly, there are some books that referred to even Fortran 77 (or perhaps 90) as \"modern\" Fortran (in comparison to Fortran IV).\n@gronki wrote:\n\nAnd the reason that I propose this as a part of the language (and not a\ncompiler switch) is that I think standard should be more enforcing about\nnot using old features.\n\nI don't see why the standard should be more enforcing. Aren't we all responsible users? Most modern ;) Fortran books mark these features as obsolescent, meaning that as long as programmers are up to date with the current language standard (much easier with Fortran, than any other programming language I know), these features should not appear in any newly developed codes. If you depend on some old codes you can always use one of the automatic tools to convert it to Fortran 90, or perhaps even refactor it.\nNow, to comment on the actual issue. Something which I find vaguely similar to the proposed language version keyword is the way one can specify the file encoding in Python: https://www.python.org/dev/peps/pep-0263/#defining-the-encoding\nA simple way to get the desired effect would be to have a similar thing, e.g.\n!!! -*- version: Fortran 2060 -*-\nprogram main\n    ! no implicit none needed because explicit typing is now default ;)\n    ...\nend program\nThe way I see it the compiler would then just turn the right language subset compilation flags on and voila."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-12 10:10:30+00:00",
                    "text": "@ivan-pi I absolutely agree, a term like modern has a very short half-life. This is why I proposed explicitly using the standard publication year. As for the format: one could also make it a special comment instead of a language keyword, then probably more similar how OMP-comments work, e.g. !$FLANG VERSION(2028), but that is only a technical question. The big question is, whether the syntax should be specified by the standard or not. If it is not specified by the standard, then different compiler would probably use a different syntax (similar how different compiler use different flags to enforce certain language features), which would be not really helpful.\n@septcolor Yes, one could make it at the module level also in Fortran, as I suggested above (module, language(f2035) :: my_module). The slight issue is, that module level modifiers (e.g. implicit none, private, etc.) in Fortran usually come after the module level imports via use statement, although, I am not sure about the exact reasons."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 13:13:27+00:00",
                    "text": "Do we all agree that the \"strict\" keyword will only disable obsolescent\nfeatures and not change the behavior of the existing features?\n\nczw., 12 gru 2019 o 11:10 B\u00e1lint Aradi <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n @ivan-pi <https://github.com/ivan-pi> I absolutely agree, a term like\n modern has a very short half-life. This is why I proposed explicitly\n using the standard publication year. As for the format: one could also make\n it a special comment instead of a language keyword, then probably more\n similar how OMP-comments work, e.g. !$FLANG VERSION(2028), but that is\n only a technical question. The big question is, whether the syntax should\n be specified by the standard or not. If it is not specified by the\n standard, then different compiler would probably use a different syntax\n (similar how different compiler use different flags to enforce certain\n language features), which would be not really helpful.\n\n @septcolor <https://github.com/septcolor> Yes, one could make it at the\n module level also in Fortran, as I suggested above (module,\n language(f2035) :: my_module). The slight issue is, that module level\n modifiers (e.g. implicit none, private, etc.) in Fortran usually come\n after the module level imports via use statement, although, I am not sure\n about the exact reasons.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3IBHSBGUBNS2HSGIXDQYIEZPA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGWEYAA#issuecomment-564939776>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NZVI2XZDGPE3ZSP7LQYIEZPANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-13 16:14:11+00:00",
                    "text": "Do we all agree that the \"strict\" keyword will only disable obsolescent features and not change the behavior of the existing features?\n\nNo, we don't.  It's the opposite, at least when it comes to implicit SAVE from object initializers."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-13 16:22:33+00:00",
                    "text": "I agree to @klausler.  The idea (at least what I had in my mind) is exaclty the opposite. A language version keyword would allow us to change the default behaviour of Fortran (requiring explicit declarations, explicit save attributes, etc.) in new codes specifying that keyword and without affecting existing codes where the keyword is not specified. So we want to introduce a gentle backwards incompatibility without affecting existing codes."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 16:27:16+00:00",
                    "text": "Then I disagree. This idea is absolutely catastrophic. Under no\ncircumstance should the code behavior change after removing the language\nversion modifier.\n\npt., 13 gru 2019, 17:22 u\u017cytkownik B\u00e1lint Aradi <notifications@github.com>\nnapisa\u0142:\n\u2026\n I agree to @klausler <https://github.com/klausler>. The idea (at least\n what I had in my mind) is exaclty the opposite. A language version keyword\n would allow us to change the default behaviour of Fortran (requiring\n explicit declarations, explicit save attributes, etc.) in new codes\n specifying that keyword and *without affecting existing codes* where the\n keyword is not specified. So we want to introduce a gentle backwards\n incompatibility without affecting existing codes.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3O42AWHNSKZZVYTBA3QYOZEXA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEG2O3YY#issuecomment-565505507>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LPS6ZGTWTYGJ6ZQ2LQYOZEXANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-13 16:31:00+00:00",
                    "text": "I think that there's two features being discussed here under the same heading.  One would disable some features (e.g., generate an error if an ASSIGN statement appears).  Another would imply some features (viz., IMPLICIT NONE, implicit SAVE, &c.).  These two concepts don't have to use the same keyword."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-13 16:35:04+00:00",
                    "text": "@gronki  Can you maybe explain more in detail, why you think the idea is \"catastrophic\"?\nI would like to \"get rid\" of old ballasts, like having to specify implicit none, having to check for implicit save in subroutines etc. (It is embarassing to explain Fortran newcommers, why they should never write integer :: a = 5 within a subroutine.) To make sure, we won't break old code, however, the new default should come with a new global keyword specified somewhere in the code."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 16:42:05+00:00",
                    "text": "I personally very dislike this idea. To sum up my voice:\n- keyword is removed and the code works the same: I'm happy\n- keyword is removed and the code doesn't compile: I'm happy\n- keyword is removed and code behavior changes quietly: this is a disaster\nIf there's a keyword, it can remove features or enable new ones. Never\nchange behavior. Ever.\n\nThere should be one language. Not ten variants configurable by different\nswitches. This introduced confusion and is not a very classy solution. If\nimplicit save was an infection, that solution would be like spreading it\nfurther. Or rubbing your eyes when they itch which only makes them itch\nmore. It only aggravates the problem we have now and creates dozen of other\nproblems. This is a can of worms. I'd rather live with implicit save. At\nleast there's one way how things work even if not intuitive and very\nannoying. And I think this should be the paradigm that is strictly followed\nin all future design decisions.\n\npt., 13 gru 2019, 17:33 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n I think that there's two features being discussed here under the same\n heading. One would *disable* some features (e.g., generate an error if an\n ASSIGN statement appears). Another would *imply* some features (viz., IMPLICIT\n NONE, implicit SAVE, &c.). These two concepts don't have to use the same\n keyword.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3LYHCXZ2HBSFDWYKJDQYO2MRA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEG2PVNY#issuecomment-565508791>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3P3WNDD7OZ2XEVO7IDQYO2MRANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 16:49:33+00:00",
                    "text": "Fortran is used by plenty of scientists who can't code and aren't Fortran\npassionates (barely users) so they don't keep up with language versioning.\nHaving worked with my collaborators for years I know they will never ever\nremember such a subtle details as which version number induces which\nbehavior. Please think about scientists. One Fortran for all.\n\n\ud83d\ude05\n\npt., 13 gru 2019, 17:44 u\u017cytkownik B\u00e1lint Aradi <notifications@github.com>\nnapisa\u0142:\n\u2026\n @gronki <https://github.com/gronki> Can you maybe explain more in detail,\n why you think the idea is \"catastrophic\"?\n\n I would like to \"get rid\" of old ballasts, like having to specify implicit\n none, having to check for implicit save in subroutines etc. (It is\n embarassing to explain Fortran newcommers, why they should never write integer\n :: a = 5 within a subroutine.) To make sure, we won't break old code,\n however, the new default should come with a new global keyword specified\n somewhere in the code.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3OY2O3JEVNFG4FKNZTQYO3VZA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEG2QCGY#issuecomment-565510427>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LOHCTZ6QQSIOM3Q7LQYO3VZANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-13 17:07:18+00:00",
                    "text": "So would you also disapprove of an IMPLICIT NOSAVE statement?"
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 17:18:12+00:00",
                    "text": "With all my hate for implicit save, yes. \ud83d\ude22 Unless it would just ban using\nthe feature altogether (so saved variable declarations would just require\nexplicit save keyword). But that's just my opinion.\n\npt., 13 gru 2019, 18:15 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n So would you also disapprove of an IMPLICIT NOSAVE statement?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3MFLYCANX3TAWSXQ5DQYO7KRA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEG2TCNY#issuecomment-565522743>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LTVYXLZHVXXUJNY2DQYO7KRANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-13 17:24:22+00:00",
                    "text": "Could you be placated if the syntax for a non-SAVE (C-like) initialization expression syntax were distinct from the current = expr and the STRICT keyword had the effect of disabling the current syntax?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-13 17:31:18+00:00",
                    "text": "With all my hate for implicit save, yes. ..\n\nSee #40 (comment)\nPer the syntax adopted by the standard since 2008 revision, one would think it would be\n   implicit none (save)  ! Given the standard has gone with implicit none (type/external)\nShort of deleting certain pernicious features such as implicit typing and implied save in one strong Alexandrian cut of this Gordian knot of an issue in Fortran, I still prefer as I suggested earlier:\n   explicit all"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-13 17:36:57+00:00",
                    "text": "I am with @gronki on \"one language\".\nHow about implicit none (*) as meaning everything has to be explicit? I think that would be a better fit for the language and would keep all the related things in one place."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-13 17:41:06+00:00",
                    "text": "I like implicit none (*) which is especially Fortranic since is adds another user of *. \ud83d\ude03\nI also like explicit all.\nI'm not looking forward to having to type implicit none (type, external) everywhere, or explaining that to newcomers."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-13 17:53:15+00:00",
                    "text": "I am not sure if in this thread but I feel we discussed it somwhere. I\nthink := syntax was proposed as an alternative.\n\nSo then IMPLICIT NO SAVE or STRICT would make these two valid\nINTEGER :: I := 5\nINTEGER,SAVE :: J = 8\nbut the following would fail to compile\nINTEGER :: K = 4\n\nDo any of my arguments make sense?\n\npt., 13 gru 2019, 18:24 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n Could you be placated if the syntax for a non-SAVE (C-like)\n initialization expression syntax were distinct from the current = expr\n and the STRICT keyword had the effect of disabling the current syntax?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#83?email_source=notifications&email_token=AC4NA3OTGUGMUBKVTB3OX63QYPAMPA5CNFSM4JMWOOT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEG2UYSA#issuecomment-565529672>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3OVNWH4YFXF2VII5BTQYPAMPANCNFSM4JMWOOTQ>\n ."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-13 20:11:36+00:00",
                    "text": "I could leave with both, implicit none (*) and explicit all with stronger preferences towards the latter.\nLet's assume, the keyword is introduced into the language. What would the processor then do with\nsubroutine test\n  integer :: i = 5\nend subroutine test\n\n\nCompilation error?  Then we eliminate the possibility of having assignment / initialization on declaration, unless a new special notation is introduced for it. I personally find somewhat confusing using a different operator for assignment on declaration as for assignment in the code, and for beginners just an annoying nuance to remember.\nWould it be treated as a normal assignment? That would be my preference, but the \"one language\" rule would be broken again.\n\n@gronki I develop a quantum mechanical simulation package in Fortran and also teach Fortran to students, so I know what you're talking about. Still, I prefer a language, where teaching does not have to start with teaching work-arounds due to historical heritage."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-03 14:48:26+00:00",
                    "text": "@certik commented on Nov 14, 2019:\n\n@FortranFan People use implied save unfortunately. For example here:\nhttps://github.com/abinit/abinit/blob/056c00bbb1a2f55c1b9851bf873a329dd8edf3e2/src/95_drive/m_gstate.F90#L2614\nI am sure there are tons of other places. Looking at this particular code, I do wonder if it's intended, or if it's a bug.\n\n@certik, as I had mentioned in #83 (comment), I'd contacted ABINIT team about this.\nTheir software engineering support contact has gotten back to me the Fortran developer for their PAW component (you'll know m_gstate.F90 is part of this) is going to look into making that variable a module-level entity with an explicit SAVE attribute to make the intent clear for readers."
                }
            ]
        },
        {
            "number": 82,
            "user": "klausler",
            "date": "2019-11-13 00:18:43+00:00",
            "title": "Dummy procedure characteristics need not match effective arguments' quite so exactly",
            "text": "In 15.5.2.9(1) appears a requirement that the effective argument procedure must have the same characteristics as the corresponding dummy procedure when the interface of the dummy procedure is explicit, with two exceptions (a PURE procedure passed to an impure dummy procedure, and an elemental intrinsic procedure passed to a necessarily non-elemental dummy).\nThis requirement can be relaxed in more circumstances than the two exceptions that appear in the text.  For example, if the passed procedure has an interface with an INTENT(IN) dummy argument whose counterpart in the interface of the dummy procedure has no intent, it would be safe.\nmodule m\n  abstract interface\n    subroutine interface(x)\n     real :: x\n    end subroutine\n  end interface\n contains\n  subroutine actual(x)\n    real, intent(in) :: x\n  end subroutine\n  subroutine callee(p)\n    procedure(interface) :: p\n  end subroutine\n  subroutine demo\n    call callee(actual) ! <- not conformant today, characteristics differ\n  end subroutine\nend module\n\nA function whose result is CONTIGUOUS could be safely passed as an effective argument when the dummy procedure's interface is not.  There may be other ways in which characteristics could harmlessly differ.  When dummy procedure interfaces recursively include dummy procedure arguments, the same additional exceptions should apply.\nAnalogous exceptions could also be made in procedure pointer assignments, structure constructors with procedure pointer components, &c.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 14:19:50+00:00",
                    "text": "The standard has made certain allowances with procedure interfaces and procedure pointer targets e.g., a PURE procedure can be a valid target for a procedure pointer that is not PURE provided other requirements are met:\nmodule m\n   abstract interface\n      subroutine Isub( x )\n         integer, intent(inout) :: x\n      end subroutine\n   end interface\n   procedure(Isub), pointer :: psub => sub\ncontains\n   pure subroutine sub( y )\n      integer, intent(inout) :: y\n      y = y + 1\n   end subroutine\nend module\n\nSo one would think it is possible to extend the list of allowances in consideration of their value proposition in conjunction with other constraints and issues of course.\nBut I wonder if such changes are best handled on a case-by-case basis so readers can better think them through?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 16:09:59+00:00",
                    "text": "CONTIGUOUS is a red herring - there is no requirement that this characteristic match, In fact, the standard says that the processor must make sure that any effective actual passed to a CONTIGUOUS dummy is in fact CONTIGUOUS when received, which can mean copy-in/copy-out.\nIntel Fortran supports, as an extension, limited kind mismatches for INTENT(IN) arguments, doing the conversion at the point of call. (For example, INTEGER(2) to INTEGER(4)) It generates a warning by default, but allows compilation to continue.\nI would like to see some realistic examples of where this suggestion would be helpful. The one about INTENT is interesting but feels artificial to me."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 16:50:36+00:00",
                    "text": "See #34 for the CONTIGUOUS question. There is a lot of confusion around this feature."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 18:17:05+00:00",
                    "text": "CONTIGUOUS is a red herring - there is no requirement that this characteristic match, In fact, the standard says that the processor must make sure that any effective actual passed to a CONTIGUOUS dummy is in fact CONTIGUOUS when received, which can mean copy-in/copy-out.\nIntel Fortran supports, as an extension, limited kind mismatches for INTENT(IN) arguments, doing the conversion at the point of call. (For example, INTEGER(2) to INTEGER(4)) It generates a warning by default, but allows compilation to continue.\nI would like to see some realistic examples of where this suggestion would be helpful. The one about INTENT is interesting but feels artificial to me.\n\nYou may have misunderstood my point about CONTIGUOUS; I was not referring to a CONTIGUOUS data dummy argument, but rather the result of an actual argument function.\nmodule m\n  real :: x(100)\n  abstract interface\n    function interface(j)\n      integer, intent(in) :: j\n      real, pointer :: interface(:)\n    end function\n  end interface\n contains\n  subroutine s(dummy)\n    procedure(interface) :: dummy\n  end subroutine\n  function actual(j)\n    integer, intent(in) :: j\n    real, pointer, CONTIGUOUS :: actual(:)\n    actual => x(1:j)\n  end function\n  subroutine demo\n    call s(actual) ! <- not conformant, characteristics of \"actual\" /= characteristics of \"interface\"\n  end subroutine\nend module"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 18:23:27+00:00",
                    "text": "For a real example of where INTENT(IN) should be allowed as a mismatched dummy/actual procedure characteristics, just consider the use of an unrestricted specific intrinsic function (e.g., SIN) being passed as an actual argument procedure when the interface of the corresponding dummy procedure has no intent on its argument.\nmodule m\n  abstract interface\n    real function interface(x)\n      real :: x\n    end function\n  end interface\n contains\n  subroutine s(dummy)\n    procedure(interface) :: dummy\n  end subroutine\n  subroutine demo\n    call s(sin) ! <- not conformant, the argument of \"sin\" has INTENT(IN)\n  end subroutine\nend module"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 18:40:03+00:00",
                    "text": "Your example of passing SIN conforms to F2018, since SIN is pure:\n\n15.9.2.9p1 If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as those of its effective argument, except that a pure effective argument may be associated with a dummy argument that is not pure and an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be elemental).\n\nThis example seems quite contrived to me. Yes, with a small effort you could rework it to use INTENT(IN) explicitly, but is this sort of mismatch a real-world scenario?"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 18:41:20+00:00",
                    "text": "See #34 for the CONTIGUOUS question. There is a lot of confusion around this feature.\n\nThat's a completely distinct concern that relates to dummy data arguments.  See my example above."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 18:42:44+00:00",
                    "text": "Also, I think even with an explicit INTENT it would be conformant because the interface specifies no intent, therefore there is nothing to match. The standard says:\n\n8.5.10p5 If no INTENT attribute is specified for a dummy argument, its use is subject to the limitations of its effective argument (15.5.2)."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 18:45:42+00:00",
                    "text": "Your example of passing SIN conforms to F2018, since SIN is pure:\n\n15.9.2.9p1 If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as those of its effective argument, except that a pure effective argument may be associated with a dummy argument that is not pure and an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be elemental).\n\nThis example seems quite contrived to me. Yes, with a small effort you could rework it to use INTENT(IN) explicitly, but is this sort of mismatch a real-world scenario?\n\nThe clause that you quote allows the actual argument procedure to have distinct characteristics of being pure &/or (in the case of unrestricted specific intrinsics) elemental.  It is not a general license for unrestricted specific intrinsics to have other mismatching characteristics; one could not expect to associate SIN as an actual argument procedure with a dummy procedure expecting 2 CHARACTER arguments."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 18:47:58+00:00",
                    "text": "Also, I think even with an explicit INTENT it would be conformant because the interface specifies no intent, therefore there is nothing to match. The standard says:\n\n8.5.10p5 If no INTENT attribute is specified for a dummy argument, its use is subject to the limitations of its effective argument (15.5.2).\n\n\nThat's the clause that allows one to dodge the requirement for definability of the actual argument that would otherwise be required by INTENT(IN OUT).\nLack of INTENT is still a characteristic."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 20:25:23+00:00",
                    "text": "CONTIGUOUS is a red herring - there is no requirement that this characteristic match..\n\nThe example given by @klausler about with effective function result with a CONTIGUOUS pointer does indeed appear non-conforming relative to the current standard:\n\nThe standard states in section 15.5.2.9 Actual arguments associated with dummy procedure entities, \"If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as those of its effective argument argument, except that a pure effective argument may be associated with a dummy argument that is not pure and an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be elemental)\" (emphasis mine).\nIn section 15.3.3 Characteristics of function results, it lists, \"The characteristics of a function result are .. whether it has the CONTIGUOUS attribute,\"\n\nAs I mentioned earlier, note the \"except that ..\" phrase in the standard text above: one could argue to add more to this list of exceptions.\nBut I think it'll be better if each case, (a) allow effective arg INTENT(IN) with dummy no INTENT; b) allow effective function result characteristic of CONTIGUOUS with a dummy that does not have it, etc., are studied individually in conjunction with the rationale for their change in the standard so as to minimize confusion and conflation and to prevent errors and omissions,"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 21:33:03+00:00",
                    "text": "For what it's worth, gfortran 9.1.0 and nagfor 6.0.1044 complain when SIN is passed as an actual argument to a dummy procedure whose interface has an argument that isn't INTENT(IN).  Other compilers (pgfortran, ifort, xlf) don't appear to be checking the arguments vs. the interface at all when SIN is passed as the actual argument -- not their number, types, or other characteristics."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 21:49:34+00:00",
                    "text": "This is a F2018 change, I don't expect all compilers to have picked it up. ifort certainly does check arguments, but it does seem to be missing something here. Note that you also need to add intrinsic sin in the subroutine (or use it as a function), or else sin is a variable."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 21:55:34+00:00",
                    "text": "Note that you also need to add intrinsic sin in the subroutine (or use it as a function), or else sin is a variable.\n\nThanks for the tip, but  I did have intrinsic sin in my test.  A variable isn't (and must not be) accepted as an actual argument associated with a dummy procedure by any of these compilers."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 22:15:13+00:00",
                    "text": "While I'm here, I've also noticed that the definition of the characteristics of a function result in 15.3.3 neglect to include the VOLATILE attribute in the case of a function returning a data POINTER; this is a hole that should be plugged."
                }
            ]
        },
        {
            "number": 81,
            "user": "milancurcic",
            "date": "2019-11-12 22:01:39+00:00",
            "title": "Allow declaration statements anywhere",
            "text": "Problem\nCurrently the Fortran standard requires that all declaration statements are in the declaration section of the program unit, for example:\nfunction foo()\n  <use-statements>\n  <declaration-statements>\n  <executable-statements>\nend function foo\nand similar for other executable units.\nPrograms or procedures that are too long to fit on the programmer's screen can be more difficult to read and understand if variable references and their declarations can't be seen on the same page.\nProposal\nDon't limit declaration statements to declarative section of the code. However, a variable must not be referenced before it's declared (assuming implicit none).\nThe key premise is: Declare variables where you use them. You don't have to, but if you want, you can.\nThe outcome is improved code readability.\nExample\nConsider a long program. Normally, you put all declarations at the top:\nprogram a_long_program\n  integer :: a, b, c\n  a = 42\n  ... ! many lines of code follow\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  b = 2 * a ! what is b again?\n  ... ! many lines of code follow\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  c = b**2 ! hmm, let me scroll up and see what c is\n  print *, 'The result is ', c\nend program a_long_program\nThis proposed feature would make the following program valid:\nprogram a_long_program\n  integer :: a\n  a = 42\n  ... ! many lines of code follow\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  integer :: b\n  b = 2 * a\n  ... ! many lines of code follow\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  ...\n  integer :: c\n  c = b**2\n  print *, 'The result is ', c\nend program a_long_program\nComments\n\nBlock construct could be used to a limited extent to emulate this behavior, however it isn't suitable for this purpose due to other restrictions, especially local scope.\nC, Go, Rust, Nim, Zig, and statically typed Python are examples of popular languages that allow this.\nI think it can be easily implemented in the Standard by simply removing the restriction on where declarations go. I don't know how easy or difficult would this be to implement in compilers.\nThis feature does not affect backward compatibility.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-11-12 22:14:41+00:00",
                    "text": "Sadly, this would require removing the faulty feature of implicit save (#40), and we already know where this is gonna go."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 22:39:26+00:00",
                    "text": "This has been requested by some of my colleagues at LANL also. It is common to have a 50 or 100 lines long subroutine with loops which is not really feasible to split it into further subroutines, but it would help to declare variables where they are used, as it would simplify reading the code, if you can see the type of the variable close to where it is used."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-12 22:42:29+00:00",
                    "text": "Agreed, this would be very helpful. If it is too controversial, perhaps we could allow variables to be declared with local scope at the start of block constructs (if/then statements, loops, etc.). Essentially we'd be saying that each of them is implicitly a block construct."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-12 22:58:44+00:00",
                    "text": "Sadly, this would require removing the faulty feature of implicit save (#40), and we already know where this is gonna go.\n\n@gronki Can you explain why? Implicit save would remain regardless of where declaration happens. Maybe I'm missing something."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-12 23:18:48+00:00",
                    "text": "Being able to declare the variable right where it's given a value is going to make people want to do it all on one line... and then disaster will strike."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 23:24:34+00:00",
                    "text": "I think there is a way to fix #40 that's backwards compatible (several approaches are suggested there), so if there is enough support for this from the Fortran community, we can make this happen."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-13 23:08:30+00:00",
                    "text": "Being able to declare the variable right where it's given a value is going to make people want to do it all on one line... and then disaster will strike.\n\nGood! It'll make people learn that pitfall quickly.\nI still don't see a technical conflict with implicit save, hopefully @gronki can explain. As far as I can tell they're compatible both in terms of syntax and semantics."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 23:11:09+00:00",
                    "text": "Being able to declare the variable right where it's given a value is going to make people want to do it all on one line... and then disaster will strike.\n\nGood! It'll make people learn that pitfall quickly.\n\nI find it hard to characterize this as a good thing, myself."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-13 23:26:47+00:00",
                    "text": "@klausler Do you think it's a bad thing, or neutral, and why?\nMy reasoning for why it's good: Implicit save is an obscure feature. If a novice Fortran programmer is not aware of it, the sooner they encounter it the better, because that will be an opportunity to learn about it and (hopefully) never use it again.\nIn contrast, as the novice Fortran programmer builds knowledge, experience, and code-base, while still not becoming aware of implicit save, it becomes more likely that this will appear as a bug in code that shipped, whether it's an open source library, or a student class project."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-13 23:29:22+00:00",
                    "text": "The existence of the implicit SAVE pitfall is the bad thing."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-13 23:33:20+00:00",
                    "text": "That I agree with, and has little to do with what I wrote. :)"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-13 23:42:20+00:00",
                    "text": "@milancurcic,\nthey might seem compatible but they are not. Please take note that while in the following code:\nsubroutine do_xyz\ninteger :: counter = 0\ninteger :: i\nread (*, *) i\ncounter = counter + i\nyou can kind of forgive what was in mind of those designing it: since variable declarations are in what can be considered a \"header\" of a code block, the value zero is in some way pre-assigned to it before the first execution. Whereas if you declare it mid-code:\nx = y + z\nreal :: w = 0\nw = w + x\nit is quite obvious that in the third line you expect that w = 0. Which, in this case, will be true only in the first call. Thus leading to quietly producing incorrect results.\nI think static/save variables should remain declared in the beginning of the block only. Otherwise it's making the implicit save problem only deeper and more burning.\nAnd I agree with @cmacmackin that probably allowing declaring variables in more places (beginning of if blocks, within the loops, in the do loop header similarly to forall) would probably resolve most of the problems. As long as you can see the declaration on the same screen as assignment it should be good.\nLast but not least, the implicit save feature is so toxic that I would think that committee should consider making an exception from \"backwards compatibility\" argument here. Like forall, this feature never really caught up, but led to lots of confusion and is misleading. Compiler vendors will probably maintain some compatibility mode for the rare customers that use it."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 00:31:10+00:00",
                    "text": "it is quite obvious that in the third line you expect that w = 0. Which, in this case, will be true only in the first call.\n\nThis is the argument against implicit save. It holds regardless of where you put the declaration statement.\n\nThus leading to quietly producing incorrect results.\n\nNo -- this is the correct behavior according to implicit save, whether we like it or not.\nAs I understand it, you're talking about what's intuitive and what we'd expect some code to do. I'm talking about whether they are technically compatible. They still seem very much so!\nYes, I admit there is an issue if a positive feature (declare anywhere) makes a negative feature (implicit save) even more negative. I explained in the earlier message why I think this is a sum-positive.\nIf I could help in any way, I'd love to see implicit save deprecated and eventually deleted, and declare anywhere enabled, concurrently. But I think two separate issues are conflated here. They should be differentiated.\nI don't think an existing negative feature should be a roadblock to implementing other, positive features to the language."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 01:02:20+00:00",
                    "text": "I don't think these can be differentiated. Intuitiveness is one of the\nprimary factor behind design. It's also one of the main reasons why we all\nconsider implicit save a bad design. I cannot see how making a bad design\ncatastrophic will be net plus no matter the benefits. In this weighing you\ncan either care more about what can be added to the language (your\napproach) or what should be forbidden in the language to avoid mistakes (my\napproach). I think we have to agree to disagree here. ;)\n\nczw., 14 lis 2019 o 01:31 Milan Curcic <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n it is quite obvious that in the third line you expect that w = 0. Which,\n in this case, will be true only in the first call.\n\n This is the argument against *implicit save*. It holds regardless of\n where you put the declaration statement.\n\n Thus leading to quietly producing incorrect results.\n\n No -- this is the correct behavior according to implicit save, whether we\n like it or not.\n\n As I understand it, you're talking about what's intuitive and what we'd\n expect some code to do. I'm talking about whether they are technically\n compatible. They still seem very much so!\n\n Yes, I admit there is an issue if a positive feature (declare anywhere)\n makes a negative feature (implicit save) even more negative. I explained in\n the earlier message why I think this is a sum-positive.\n\n If I could help in any way, I'd love to see implicit save deprecated and\n eventually deleted, *and* declare anywhere enabled, concurrently. But I\n think two separate issues are conflated here. They should be differentiated.\n\n I don't think an existing negative feature should be a roadblock to\n implementing other, positive features to the language.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#81?email_source=notifications&email_token=AC4NA3OUEJXDP5UQ6MTCSNTQTSL47A5CNFSM4JMJV3Y2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEAFAFA#issuecomment-553668628>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3ORQ6KJTAB4BUB3MSLQTSL47ANCNFSM4JMJV3YQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 02:26:15+00:00",
                    "text": "OK, thanks for clarifying -- it's a matter of design rather than a\ntechnical issue. I didn't understand that from your original message and I\nagree with that part.\n\nMaking a negative feature appear more negative helps your persuasion when\nyou argue for removing that feature. Things that are more obviously bad are\nmore difficult to ignore. This proposal will boost the argument against\nimplicit save.\n\u2026\nOn Wed, Nov 13, 2019, 20:02 Dominik Gronkiewicz ***@***.***> wrote:\n I don't think these can be differentiated. Intuitiveness is one of the\n primary factor behind design. It's also one of the main reasons why we all\n consider implicit save a bad design. I cannot see how making a bad design\n catastrophic will be net plus no matter the benefits. In this weighing you\n can either care more about what can be added to the language (your\n approach) or what should be forbidden in the language to avoid mistakes (my\n approach). I think we have to agree to disagree here. ;)\n\n czw., 14 lis 2019 o 01:31 Milan Curcic ***@***.***>\n napisa\u0142(a):\n\n > it is quite obvious that in the third line you expect that w = 0. Which,\n > in this case, will be true only in the first call.\n >\n > This is the argument against *implicit save*. It holds regardless of\n > where you put the declaration statement.\n >\n > Thus leading to quietly producing incorrect results.\n >\n > No -- this is the correct behavior according to implicit save, whether we\n > like it or not.\n >\n > As I understand it, you're talking about what's intuitive and what we'd\n > expect some code to do. I'm talking about whether they are technically\n > compatible. They still seem very much so!\n >\n > Yes, I admit there is an issue if a positive feature (declare anywhere)\n > makes a negative feature (implicit save) even more negative. I explained\n in\n > the earlier message why I think this is a sum-positive.\n >\n > If I could help in any way, I'd love to see implicit save deprecated and\n > eventually deleted, *and* declare anywhere enabled, concurrently. But I\n > think two separate issues are conflated here. They should be\n differentiated.\n >\n > I don't think an existing negative feature should be a roadblock to\n > implementing other, positive features to the language.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <\n #81?email_source=notifications&email_token=AC4NA3OUEJXDP5UQ6MTCSNTQTSL47A5CNFSM4JMJV3Y2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEAFAFA#issuecomment-553668628\n >,\n > or unsubscribe\n > <\n https://github.com/notifications/unsubscribe-auth/AC4NA3ORQ6KJTAB4BUB3MSLQTSL47ANCNFSM4JMJV3YQ\n >\n > .\n >\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#81?email_source=notifications&email_token=AA7RDPQASQ26VZOA3FGJL6LQTSPR3A5CNFSM4JMJV3Y2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEAGWUA#issuecomment-553675600>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AA7RDPW46NLIRHLSL5ZUL2TQTSPR3ANCNFSM4JMJV3YQ>\n ."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-14 17:12:31+00:00",
                    "text": "I would object to allowing declarations anywhere, as variables tend to be used throughout large sections of code and the reader would have to scan the entire procedure to find the declaration.\nIf you're truly using a variable in a limited context, use BLOCK - that's what it's for."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 17:39:32+00:00",
                    "text": "Thanks Steve. I understand the argument to keep this restriction because the reader then always knows that the declarations are on top, without exception.\nRemoving this restriction would affect only new code written. I don't know, but I think that most uses of this would be to declare the variable immediately before it's first used. In my opinion, there's value to this, especially in the era of modern text editors with easy pattern search through the file. If nothing else, it allows the programmer to adopt the preferred development practice for their project.\nYes, technically block could be used for this, but limiting the local scope for variables is not the intent of this proposal."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 17:45:57+00:00",
                    "text": "@sblionel @klausler  is there any reason from the compiler implementation/performance side for not allowing variable declarations to be in the beginning of constructs like if and do? From what I know, in C++ such variables are usually easily optimized out, but in code they contribute to readibility.\nI have been using block for a while and I think it's a genius and versatile construct. I structure my codes a lot using it. But perharps the ability to declare variables could be extended to a few more constructs. For example, block behaves somewhat similar to do i = 1,1 (executed once). Very often variables are used within a loop and are only relevant for the local context. I see having to declare a variable total on the top of the procedure just to use it in  within one nested loop as very bad for cleanliness and readibility. (Or even worse, used in a few different loops in different meanings.)\nI still don't know if declarations everywhere are the best idea, but clearly there must be a way to make it easier to restrict the scope of variables."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 17:53:24+00:00",
                    "text": "I like this a lot as well. If there is to be a proposal for reducing the restriction, it should bring to the table and discuss both (and any other) approaches."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-14 18:08:24+00:00",
                    "text": "@sblionel @klausler is there any reason from the compiler implementation/performance side for not allowing variable declarations to be in the beginning of constructs like if and do? From what I know, in C++ such variables are usually easily optimized out, but in code they contribute to readibility.\nI have been using block for a while and I think it's a genius and versatile construct. I structure my codes a lot using it. But perharps the ability to declare variables could be extended to a few more constructs. For example, block behaves somewhat similar to do i = 1,1 (executed once). Very often variables are used within a loop and are only relevant for the local context. I see having to declare a variable total on the top of the procedure just to use it in within one nested loop as very bad for cleanliness and readibility. (Or even worse, used in a few different loops in different meanings.)\nI still don't know if declarations everywhere are the best idea, but clearly there must be a way to make it easier to restrict the scope of variables.\n\nThe grammar of the Fortran language pretty clearly distinguishes the specification part of a subprogram from its execution part.  While a few statements (e.g., FORMAT and DATA) can appear in each (at least today), the two parts are almost like distinct programming languages.  Older compilers that perform semantic analysis as they parse would complete the definitions in the symbol table when the parse detected the transition from the specification part to the executable part.\nToday, the only concern that I might raise about intermixing some (which?) specification statements into the executable part is that it would slow down the parser on all codes -- it'll have more possibilities to consider in the execution part.  But wouldn't want to raise such a concern without first prototyping the feature and measuring the performance difference.\nI doubt that it would be prohibitive, and I hope that it's not, because -- at least in the case of type-declation-stmt with a \"no implicit SAVE\" option, such inline usage greatly improves readability of code in other languages.  I consider it a best practice in C++ to always initialize each local variable as I declare it with the value of an expression that usually involve references to other declared and initialized locals, similar to a let or where block in Haskell (apart from ordering).\nSo the potential value of this feature depends on solving the \"implicit SAVE due to initialization\" problem, since it seems less useful absent initializers on the intermixed declarations.  I suggest that a combined proposal be drafted.\nI'm not sure it helps much to allow other specification statements to leave the specification-part."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-11-15 23:24:58+00:00",
                    "text": "Agreed, this would be very helpful. If it is too controversial, perhaps we could allow variables to be declared with local scope at the start of block constructs (if/then statements, loops, etc.). Essentially we'd be saying that each of them is implicitly a block construct.\n\nI see how this could be done for the internal scope of if/then statements and do loops, but I cannot see it done in a nice way for the iterator of a loop. Would the declaration statement be directly above the do loop, or on the same line like do integer i = 1, n? Perhaps fit it in the newly suggested modern do, i.e.  do (integer :: i, j: i=1:n, j=1:m) construct (see #85)?\nWhile I agree this is one of the features I like most from C++, like @sblionel  suggested, in Fortran it can already be done with the  block construct (I found some nice examples here). Of course the solution matches the general verbosity of Fortran. A good editor with snippet completions can help to reduce the typing effort.\nPerhaps we just need a preprocessor to convert curly brackets into block constructs? \ud83d\ude09\nif (condition) then { \n  ! do something\n} end if"
                },
                {
                    "user": "LydiaMarieWilliamson",
                    "date": "2021-10-13 00:19:45+00:00",
                    "text": "I don't see how this issue interferes with \"implied save\" any more than intermixing statements and declarations interferes with the \"static\" attribute in C or C++. Compilers for those languages handle intermixing both auto and static declarations with statements quite well; so it shouldn't be a problem for Fortran compilers to use similar methods to handle intermixed declarations in conjunction with the \"save\" attribute.\nAlso, I don't see why \"implicit save\" should be removed, either. If you need a way to prevent \"save\" being implicitly attached to a local, then provide either a compiler switch for this (e.g. \"-auto\") or appropriate a keyword for this; e.g. \"implicit no save\" when implied save is enabled and \"implicit save\" when implied save is disabled, even \"implicit save(A-Z)\", or \"implicit no save(A-Z)\" (or maybe also \"implicit none (save)\"). A standard, over time, can then change the default from being \"implicit save until otherwise disabled\" to \"implicit no save until otherwise disabled\", which requires only a change in a compiler switches when recompiling an older module, with no intrusion into the module itself, and minimal disruption of existing programs."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-10-28 13:51:45+00:00",
                    "text": "This was requested also on Discourse: https://fortran-lang.discourse.group/t/declare-variables-anywhere/2179."
                }
            ]
        },
        {
            "number": 80,
            "user": "certik",
            "date": "2019-11-12 18:25:14+00:00",
            "title": "Feature Proposals for Fortran from Espen Myklebust",
            "text": "There is a list of ideas here:\nhttps://wg5-fortran.org/N1951-N2000/N1972.pdf\nthat we should extract into individual issues, much like we are doing in #49.\nNote: this was originally posted by @jacobwilliams in #49 (comment), so I created a standalone issue for it.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-11-12 18:35:29+00:00",
                    "text": "This is pretty awesome. I had almost exact ideas considering some of the\nissues (like ``do`` syntax consistent with ``do concurrent``), while others\n(for example using ``@`` as reference to LHS expression) are purely\nbrilliant and solve the issue of lack of operators such as ``+=`` and\n``*=``. I hope at least half of these eventually pass because they are\nsimple concept that *hugely* improve the usability of the language.\n\nwt., 12 lis 2019 o 19:25 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n There is a list of ideas here:\n\n https://wg5-fortran.org/N1951-N2000/N1972.pdf\n\n that we should extract into individual issues, much like we are doing in\n #49 <#49>.\n\n Note: this was originally posted by @jacobwilliams\n <https://github.com/jacobwilliams> in #49 (comment)\n <#49 (comment)>,\n so I created a standalone issue for it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#80?email_source=notifications&email_token=AC4NA3KNNEYF62H7BCXAF7TQTLYI3A5CNFSM4JMHIXCKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HYY26YQ>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3KUKFC66WZUSE6BE5DQTLYI3ANCNFSM4JMHIXCA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 18:39:37+00:00",
                    "text": "Let's create separate issues for each idea, so that we can properly discuss them."
                }
            ]
        },
        {
            "number": 79,
            "user": "FortranFan",
            "date": "2019-11-12 17:37:35+00:00",
            "title": "On backward compatibility",
            "text": "Backward compatibility, or not to break existing code, is often put forth as the argument against many a proposal, this issue #40 is a classic instance of this.  This issue #72 is also seeing a similar debate.\nHowever there appear to be 2 major issues with this argument:\n\n\nit is very difficult, almost impossible, to find an objective analysis of the risks due to a change.  If a breaking change is only a theoretical possibility but if most or all the publicly known codebases are not noticed to be at risk due to the change, how valid is the argument then to not consider an idea?\n\n\non the other hand, there exist quite a few instances in the standard where compatibility with an earlier revision has been dropped for some aspect or other, often presented as different interpretations but they also include features which are DELETED such as from FORTRAN 77 and earlier editions.\n\n\nConsider the current Fortran 2018 standard: with respect to Fortran 2008 itself, one can argue changes have been incorporated that break existing code, at least under the theoretical possibility of conforming processors offering support for the prior interpretation.  With object-oriented facilities in Fortran, my codes have had to deal with \"breaking changes\" in going from processors supporting Fortran 2003 thru' 2018.\n20 4.3.3 Fortran 2008 compatibility\n21 1  Except as identified in this subclause, and except for the deleted features noted in Annex B.2, this document is\n22    an upward compatible extension to the preceding Fortran International Standard, ISO/IEC 1539-1:2010 (Fortran\n23    2008). Any standard-conforming Fortran 2008 program that does not use any deleted features, and does not use\n24    any feature identified in this subclause as being no longer permitted, remains standard-conforming under this\n25    document.\n26 2  Fortran 2008 specifies that the IOSTAT= variable shall be set to a processor-dependent negative value if the flush\n27    operation is not supported for the unit specified. This document specifies that the processor-dependent negative\n28    integer value shall be different from the named constants IOSTAT_EOR or IOSTAT_END from the intrinsic\n29    module ISO_FORTRAN_ENV.\n30 3  Fortran 2008 permitted a noncontiguous array that was supplied as an actual argument corresponding to a\n31    contiguous INTENT (INOUT) dummy argument in one iteration of a DO CONCURRENT construct, without\n32    being previously defined in that iteration, to be defined in another iteration; this document does not permit this.\n   4  Fortran 2008 permitted\n1     a pure statement function to reference a volatile variable, and permitted a local variable\n2     of a pure subprogram or of a BLOCK construct within a pure subprogram to be volatile (provided it was not\n3     used); this document does not permit that.\n4 5   Fortran 2008 permitted a pure function to have a result that has a polymorphic allocatable ultimate component;\n5     this document does not permit that.\n6 6   Fortran 2008 permitted a PROTECTED TARGET variable accessed by use association to be used as an initial7\n      data-target; this document does not permit that.\n8 7   Fortran 2008 permitted a named constant to have declared type LOCK_TYPE, or have a noncoarray potential\n9     subobject component with declared type LOCK_TYPE; this document does not permit that.\n10 8  Fortran 2008 permitted a polymorphic object to be finalized within a DO CONCURRENT construct; this docu11\n      ment does not permit that.\n12 9  Fortran 2008 permitted an unallocated allocatable coarray or coindexed object to be allocated by an assignment\n13    statement, provided it was scalar, nonpolymorphic, and had no deferred type parameters; this document does\n14    not permit that.\n15 10 Fortran 2008 permitted the processor to use a common pseudorandom number generator for all images. This\n16    document requires separate seeds on each image for the pseudorandom number generator.\n\nSo what it appears to me is an inconsistency in how the \"backward compatibility\" argument is applied and perhaps even an inaccuracy in the argument \"oh, that will break existing code and that is a no-no\" that is put forth.\nIt'll be valuable for Fortran if a technical approach to address the bugaboo of backward compatibility can be adopted.\nOne aspect of such an approach might involve the establishment of a \"registry\" of Fortran codebases: such a registry only need to have links to existing projects online such as GitHub, SourceForge, etc. or to institutional sites e.g., DOE, NASA, NOAA, academia, etc., or simply be entries which provide a brief description of what code does and the coding styles adopted per true intent e.g., the use of IMPLICIT typing (as opposed IMPLICIT NONE), or IMPLICIT SAVE, data types, and so forth.  This can a \"green\" registry of course, meaning it should grow as new applications are developed using Fortran.\nThen when a proposal is presented, one can crosscheck it against such a registry for impact analysis  (and where possible like with GitHub or online repositories with a code review) to yield a somewhat quantitative assessment of the risk due to the change; this is as opposed to someone's 'gut feel' at present which might be overestimating the adverse impact of a proposal.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2019-11-12 17:46:39+00:00",
                    "text": "As a former vendor, I can say with authority that paying customers blame the vendor when their existing code breaks due to a change. Rather than fix their code, they want a switch to revert to the old behavior. If the existing code was non-conforming, I have little sympathy, but the cases where a standard change breaks code are rare. Most of the cases mentioned in the text you quote are where the earlier standard was silent about some combination of uses.  Changing the kind that an intrinsic returns, as has been suggested in #72 , would break code that used these intrinsics as actual arguments.\nRegistry of code libraries is a non-starter. Keep in mind that the usages you see are like the part of an iceberg above water - the vast majority of code is kept privately by organizations loathe to make changes.\nWhether you like it or not, a major strength of Fortran is that, by and large, standard revisions have not broken existing code bases, allowing the vast extent of code libraries to continue to be used."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 17:58:22+00:00",
                    "text": "Thanks @FortranFan for opening an issue for this. Thanks @sblionel for your comment. I agree with it.\nWhat we can do is to write up what we mean by \"backwards compatibility\" in some document here in the repository, so that new proposals can check against it that they are not breaking it."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 18:11:47+00:00",
                    "text": "I guess here we go back to the idea of Fortran testsuite #57 (although huge\norganizational effort and workforce needed to construct) where most usual\napplications and usage patterns for constructs can be used, and whatever\nbreaks it is considered backwards incompatible. As I said in another\nthread, the example of \"using as actual argument\" given by @sblionel is\nquite fair and I agree with it. Using size(x) as an actual argument is not\nan inherently bad coding practice. But I can also totally see how some\nother good and highly beneficial proposition could be rejected just because\nsomebody found one exotic combination of common blocks, namelists and\nequivalences that standard permitted even if it was objectively bad\nprogramming and affected only one code. Are \"losses vs benefits\" weighted\nin that case?\n\nAre *obsolescent* features still the subject of backwards compatibility\nconsiderations? I understand that *deleted* features are not?\n\nwt., 12 lis 2019 o 18:58 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n Thanks @FortranFan <https://github.com/FortranFan> for opening an issue\n for this. Thanks @sblionel <https://github.com/sblionel> for your\n comment. I agree with it.\n\n What we can do is to write up what we mean by \"backwards compatibility\" in\n some document here in the repository, so that new proposals can check\n against it that they are not breaking it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#79?email_source=notifications&email_token=AC4NA3K3CMTCGGKJ7IAEJPLQTLVEBA5CNFSM4JMGYGLKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOED3FKBA#issuecomment-553014532>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LW7UT7YUX5L3XOQTLQTLVEBANCNFSM4JMGYGLA>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 19:24:17+00:00",
                    "text": "Older codes should compile and execute without change with newer compilers, possibly implementing new editions of a language standard, everything else being equal.  That latter part is important.  Sometimes target architectures differ from each other or evolve in place in ways that require some porting of codes.  In those situations, compilers (especially from hardware vendors) are going to want to ease the porting, and the standard should assist both coders and implementors with features that maximize and maintain portability.\nHere's a specific example.  Let's say that Big DOE Lab has a code that runs great on 32-bit x86 systems.  When recompiled with a new compiler for 32-bit x86, it should just work, everything else being equal.  And maybe that's enough for that code & customer.  When recompiled for 64-bit x86 targets, if that's desired, it'll probably need some porting so that the larger address space can be exploited to serve larger sets of data.  What features make that porting effort easiest on the customer?  That's the question that should be driving the designs and standards."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 00:48:14+00:00",
                    "text": "See this observation re: implied SAVE: #40 (comment).\nSo as brought up by @gronki , how are the pros of a change to be weighed against the cons which favor status quo on an issue?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 13:45:24+00:00",
                    "text": "#83 suggests a new keyword to work around certain issues pertaining to backward compatibility."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-24 23:13:49+00:00",
                    "text": "Implicit typing (#90) can impact a new facility in a subtle way - see #57 (comment).  Processors can get the details wrong which negatively impact users in terms of time and lost productivity or worse.  And many a user does find the whole notion with implicit typing in Fortran very confusing which further affects the adoption of the language.\nModern programming languages try to be rigorously type-safe and/or dynamically-typed.  But implicit typing is something almost all of them avoid.  But Fortran can choose to ignore the gathering wisdom of modern practitioners and continue to supporting IMPLICIT statements where, users can use such a facility to introduce implicit typing in their scopes and be responsible for their actions.\nBut what is pernicious is the continued support for implicit typing in Fortran as the **default**.\nThen to expect any and all users to circumvent such a default only by introducing \"IMPLICIT NONE\" in all their scopes is truly \"cruel and unusual punishment\".  It's one aspect that this language needs to shed - pronto."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 16:30:46+00:00",
                    "text": "I believe that while backwards compatibility is desirable in language development, it should not be a primary value, and should not prevent truly useful features from being added to the language.\nI believe a significant reason that people choose languages other than Fortran for new work, even in scientific and engineering applications, is because those other languages have features which enable one to write safer, more maintainable, easier to understand code with less effort. In fact, organizations are encouraged to keep their code bases more maintainable and ensure continuity of knowledge because of the occasional breaking changes that occur in those languages. It seems a lack of backwards compatibility can actually be a virtuous cycle keeping your users in a better position.\nI fear that Fortran's commitment to backwards compatibility at (practically) any cost has actually lead its users down a dangerous path to a precarious position. Eventually one of two things will happen:\n\nIt will no longer be possible to make changes to the language any more and it will die, forcing organizations to rewrite code that they no longer understand\nA feature will come along that is worth breaking backwards compatibility, forcing organizations to fix code that they no longer understand\n\nIn my opinion, the sooner this happens the better, because it will only cost more the longer we wait. It's like continuing to spend on a credit card while only making the minimum payments. Eventually the introductory rate runs out or you hit your limit and you're really up a creek. Better to stop digging and take your lumps now."
                },
                {
                    "user": "certik",
                    "date": "2020-01-27 16:41:20+00:00",
                    "text": "@FortranFan, @everythingfunctional it seems based on the feedback at this repository that the vast majority of the outside community agrees with your comments. When I talk to other Fortran developers, I do not see any strong opposition either to new features and even breaking features as long as old code does not just suddenly start breaking. In other words, as long as there is a path how to keep old code working without modifications, but new code can use breaking changes, it seems the community will be on board. Whether this is done with a new language keyword (#83) or some other way.\nThe best way forward is to have a serious discussion about this at the Committee meeting. And until then, @FortranFan, @everythingfunctional, do you want to help prepare some proposals for this? They do not have to be completely formal proposals that will get submitted, but it would help guide the discussion at the Committee if we have some documents in hand showing a way forward. It seems there are several ways, so it would be nice to have a document for #83, and another one for let's say the implicit save #40 with the implicit none(save) approach etc., and iron out the most obvious objections to such proposals, so that we can have a real discussion about the actual problem in person."
                },
                {
                    "user": "tskeith",
                    "date": "2020-01-27 19:12:55+00:00",
                    "text": "@FortranFan, @everythingfunctional it seems based on the feedback at this repository that the vast majority of the outside community agrees with your comments. When I talk to other Fortran developers, I do not see any strong opposition either to new features and even breaking features as long as old code does not just suddenly start breaking. In other words, as long as there is a path how to keep old code working without modifications, but new code can use breaking changes, it seems the community will be on board.\n\nI don't understand this. If old code works without modification, the changes aren't breaking (by definition).\n\nWhether this is done with a new language keyword (#83) or some other way.\n\nMy understanding of the language keyword proposal is that it is a backward-compatible way to change default behavior."
                },
                {
                    "user": "certik",
                    "date": "2020-01-27 19:15:54+00:00",
                    "text": "I don't understand this. If old code works without modification, the changes aren't breaking (by definition).\n\nThere are people on the Committee as well as some in the wider community that are opposed to this, as you can read in responses at #83 or #40. The reason they are opposed to it is that if you enable the modern feature (even if it is opt-in) for old code, the old code will break (for example if an implicit save now becomes implicit init). What I am saying is that I think the majority in the community would be ok with such a compromise (that unless you opt-in, the old code will keep working; but if you opt-in, then old code can break). The alternative (which I am suggesting we do not do) is that even if you opt-in, the old code will keep working (which is greatly tying our hands in what we can introduce into the language)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 19:42:11+00:00",
                    "text": "As @tskeith said, an opt-in requirement for new features is backwards compatible. I think that having new features be opt-in is the right approach in the near term, but it is still only a stop-gap measure. We need a long term strategy to eventually get to a point where the committee can at least entertain the idea of proposals that are not backwards compatible. Eventually we will need a change to the standard that will make old code no longer valid, and it shouldn't be DOA just because it's not backwards compatible.\nMaybe we never get there and it will never be needed, but we should be heading in that direction. The whole point of software is being able to easily modify the behavior of the machine. If you can't change your software, it's already broken, whether you realize it or not. And the committee should stop enabling people to hide from it indefinitely."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 19:49:40+00:00",
                    "text": "What cannot happen is a silent change to the meaning of an unmodified existing program that works today."
                },
                {
                    "user": "certik",
                    "date": "2020-01-27 19:50:42+00:00",
                    "text": "Eventually we will need a change to the standard that will make old code no longer valid\n\nCan you give an example how exactly what that work? For example in the context of #83? Essentially the opt-in \"edition\" keyword would then become the default (with the latest edition), which would make old code to not work anymore? But one could put \"edition F2003\" into old code, and it would still work?\n(Or are you proposing that there literally would be no way to make old code work at all? I think that would not be a good idea.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 20:04:54+00:00",
                    "text": "My thought is the progression would go something like this:\n\nThe version/edition keyword/option is introduced. This allows us to introduce non-backwards compatible features that are essentially \"opt-in\", but may render old code invalid or possibly change its behavior.\nAt some point, compilers are no longer required to support older versions/editions in order to be considered standards compliant. And in fact, not specifying a version/edition would probably be an error (to prevent \"silent\" change to behavior).\n\nAt that point compilers aren't required to drop support, and you could of course continue to use older versions of compilers, but some old code would no longer be considered standards compliant.\nSo long as you give enough time, and are vocal and public about it, I don't see why this would be an unreasonable path."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 20:24:50+00:00",
                    "text": "Existing code must continue to work unchanged with new revisions of the standard and new versions of compilers unless there's extraordinarily compelling reasons; no serious examples of such have arisen in these discussions.  Barring the introduction of zero-trip DO loops and the removal of extended ranges in FORTRAN '77, and the ephemeral CoCo, I can't think of any instances where the progress of the language has invalidated old code.  Fortran 90 famously invalidated nothing (see section B-1 of that document)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 20:50:45+00:00",
                    "text": "@klausler , It's been asked plenty of times if it would be possible to remove implicit typing and implicit save from the language. I think they should, and so do many others. Maybe not  for 202X, or even 202Y, but maybe by 203Z if you put edition 203Z at the top of your module, you won't need to put implicit none(type, save).\nIf we continue to treat that as a breaking change, and\n\nExisting code must continue to work unchanged with new revisions of the standard and new versions of compilers\n\nthen it can never be done.\nThe \"yeah, that'd be nice, but it breaks code written to the Fortran 77 standard so we won't even entertain it\" is hindering progress and killing the language."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 20:56:39+00:00",
                    "text": "@klausler , It's been asked plenty of times if it would be possible to remove implicit typing and implicit save from the language. I think they should, and so do many others. Maybe not for 202X, or even 202Y, but maybe by 203Z if you put edition 203Z at the top of your module, you won't need to put implicit none(type, save).\nIf we continue to treat that as a breaking change, and\n\nExisting code must continue to work unchanged with new revisions of the standard and new versions of compilers\n\nthen it can never be done.\n\nIf you are modifying a program to add a version marker, then it is no longer unchanged existing code.\n\nThe \"yeah, that'd be nice, but it breaks code written to the Fortran 77 standard so we won't even entertain it\" is hindering progress and killing the language.\n\nNonsense."
                },
                {
                    "user": "certik",
                    "date": "2020-01-27 21:02:49+00:00",
                    "text": "@klausler please try to understand @everythingfunctional's point of view, even if you disagree with it. In particular, please try to explain your position instead of just saying \"nonsense\", in order to move the discussion forward."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 21:07:19+00:00",
                    "text": "If you are modifying a program to add a version marker, then it is no longer unchanged existing code.\n\nThen I think we agree, and my proposed path forward would be acceptable to you, provided we never actually got to the point of dropping the requirement for supporting old standards, which I admit may never be necessary or desired.\nBut I have gotten the impression from mentions of old discussions that not everyone agrees with that stance. I got the feeling that some proposals were rejected in the past, even though they were opt-in, because \"adding that one line changed the meaning of old code\". Unless I'm mistaken, which I admit I may be, I don't think it is \"Nonsense\"."
                },
                {
                    "user": "certik",
                    "date": "2020-01-27 21:10:26+00:00",
                    "text": "@everythingfunctional let's talk about your proposal at #79 (comment) some more. It seems it actually satisfies what @klausler wants.\nFor example, for current (old) code, if the version specifier is not specified, then the standard can say that it means the code implicitly assumes Fortran 202X. If you want to use features from a later Fortran standard (say 202Y), you have to put the version specifier in, such as \"edition Fortran 202Y\". However, the minute you put in \"edition Fortran 202Y\", it can break the code (say implicit save becomes implicit init).\nThis proposal has the following features:\n\n\nOld code will continue working unmodified indefinitely.\n\n\nIf you put in \"edition 202Y\" then the old code will break, and it will have to be updated to work again. We should obviously try to provide automatic tools to update the code and excellent error messages to help update old code, good guidelines and we should only introduce breaking features that have a good \"upgrade path\" that can be done with big legacy codes. This would be file by file based, so it could be done incrementally.\n\n\nLater on it can become an error not to specify the \"edition\" keyword. In that case, simply put \"edition 202X\" into old code and it will continue working umodified. Compilers can add an option such as \"-legacy\" that would assume \"edition 202X\". This point 3. might not be implemented in the standard. To me an acceptable solution would be that compilers would give warnings if \"edition\" is not specified, and you can turn off the warning with a compiler option."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-27 21:18:31+00:00",
                    "text": "I'm in favor of backward compatibility so I support points 1. and 2. here.\nPoint 3. is okay if not implemented in the standard, or if implemented as \"the compiler should warn that edition is not specified\".\nIn general, I think it's okay to consider new language-breaking features if the benefits clearly outweigh the costs. I haven't seen such proposals so far."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 21:39:23+00:00",
                    "text": "Version specifiers must not silently change the meaning of code.  It's okay if they cause existing code to begin to elicit new error messages (e.g., they imply new checks akin to IMPLICIT NONE(SAVE)).  But it would be dangerous to use versioning as a means for introducing silent changes to semantics.  How would one know whether they occurred?\nRequiring a version number to appear in the program at some point in the future would cause unmodified existing code to stop working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 21:40:00+00:00",
                    "text": "@certik , I am in favor that, of course so long as there is nothing in 202X that would be \"breaking\", but I believe that has already been determined."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 21:49:38+00:00",
                    "text": "@klausler please try to understand @everythingfunctional's point of view, even if you disagree with it. In particular, please try to explain your position instead of just saying \"nonsense\", in order to move the discussion forward.\n\nYou should have seen the first draft of that word.\nThe claim that 'The \"yeah, that'd be nice, but it breaks code written to the Fortran 77 standard so we won't even entertain it\" is hindering progress and killing the language.' is hyperbolic and unsupported by evidence.  The single example of a feature on this site that would have been a breaking change was a profoundly bad idea anyway (viz., allowing new enumeration names to stand alone as statements without keywords, so END would not necessarily be an END statement if somebody was declaring it as an enumerator)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 22:20:28+00:00",
                    "text": "Version specifiers must not silently change the meaning of code. It's okay if they cause existing code to begin to elicit new error messages (e.g., they imply new checks akin to IMPLICIT NONE(SAVE)).\n\nI think this would forever require Fortran to carry around the baggage of its past mistakes. One would not be able to make a new proposal without first considering all of the possible implications to all prior versions of the language. Of course it wouldn't be a good idea to have silent changes between consecutive versions, but to never be able to change the meaning of old code?\n\nBut it would be dangerous to use versioning as a means for introducing silent changes to semantics. How would one know whether they occurred?\n\nYour test suite I would expect. If we're never going to expect our users to start using modern software development practices, who are we modernizing the language for?"
                },
                {
                    "user": "klausler",
                    "date": "2020-01-27 22:28:07+00:00",
                    "text": "One would not be able to make a new proposal without first considering all of the possible implications to all prior versions of the language.\n\nThat is a good thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 22:59:39+00:00",
                    "text": "@klausler please try to understand @everythingfunctional's point of view, even if you disagree with it. In particular, please try to explain your position instead of just saying \"nonsense\", in order to move the discussion forward.\n\nYou should have seen the first draft of that word.\nThe claim that 'The \"yeah, that'd be nice, but it breaks code written to the Fortran 77 standard so we won't even entertain it\" is hindering progress and killing the language.' is hyperbolic and unsupported by evidence. The single example of a feature on this site that would have been a breaking change was a profoundly bad idea anyway (viz., allowing new enumeration names to stand alone as statements without keywords, so END would not necessarily be an END statement if somebody was declaring it as an enumerator).\n\nThere are multiple examples of breaking changes being proposed in this repo. Not the least of which are removing implicit typing and implicit save. And multiple mentions of backwards compatibility have been given as to why this wasn't done in the past or shouldn't be done now, even though they are regarded as the biggest mistakes of the language and the cause of the most confusion and error to new programmers. My statement may have been a bit hyperbolic, but it is not entirely \"unsupported by evidence\"."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-27 23:01:56+00:00",
                    "text": "One would not be able to make a new proposal without first considering all of the possible implications to all prior versions of the language.\n\nThat is a good thing.\n\nI disagree. There are multiple pushes to encourage the committee to move faster. But if after every revision we now have to consider the sum total of all the revisions before the next one can be released, the cycles will take longer and longer, and we'll never be able to go faster."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-28 00:05:54+00:00",
                    "text": "..\nI think this would forever require Fortran to carry around the baggage of its past mistakes. One would not be able to make a new proposal without first considering all of the possible implications to all prior versions of the language. Of course it wouldn't be a good idea to have silent changes between consecutive versions, but to never be able to change the meaning of old code?\n..\n\nI agree with @everythingfunctional.\nAnd I do NOT AT ALL think deletions are \"silent changes\".\nAnd I do NOT think \"One would not be able to make a new proposal without first considering all of the possible implications to all prior versions of the language\" is a \"good thing\" at all.\nDeleting \"implicit typing as the default\" and deleting \"implied SAVE\" in a future standard revision will in all likelihood be received far more positively than the 8 deletions already in the standard (c.f. Section B).\nFor example, a code such as\n      I = 42\n      END\ncan be allowed to be rejected by a future processor.  By the way, every \"legacy\" code I have seen either already has \"IMPLICIT NONE\" (which was the most commonly used non-standard extension prior to Fortran 90) or \"IMPLICIT INTEGER(I-N), XXX(A-H,O-Z)\" (where XXX is REAL*N or DOUBLE PRECISION, etc.) and none of such code will be impacted by the deletion of \"implicit typing as the default\".\nSimilarly, a code such as\n      INTEGER FUNCTION COUNTR()\n      LOGICAL FIRST = .TRUE.\n      IF (FIRST) THEN\n          COUNTR = 1\n          FIRST = .FALSE.\n      ELSE\n          COUNTR = COUNTR+ 1\n      END IF\n      END\ncan be allowed to be rejected by a future processor.  But should the code have SAVE specification in some form (e.g., SAVE statement and/or LOGICAL, SAVE :: FIRST = .TRUE.), then deletion of \"implied SAVE\" will have no impact.\nMoreover, if \"implied SAVE\" is deleted and processors support such a change by default, quite a few purse-string holders I know will only be happy and start to view Fortran a little more positively.\nNote it's already the silent introduction of vulnerabilities in code such as via \"implicit typing\" and \"implied SAVE\" that bothers many a manager."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-28 00:16:07+00:00",
                    "text": "@certik wrote:\n\n.. for example if an implicit save now becomes implicit init ..\n\n@certik , please note what I've been suggesting is only for \"implied SAVE\" to be deleted, not that \"implied SAVE\" becomes \"implicit init\".\nMy own suggestion, as I've mentioned in other issue threads, is for no more \"implicit\" semantics.\n\n\nSo if coders want \"SAVE\" behavior, it must be instructed explicitly.  An example, logical, save :: first = .true\n\n\nAnd if coders want initialization, to instruct so explicitly - say if INIT keyword is introduced, then perhaps using integer, init :: x= 42"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 01:18:29+00:00",
                    "text": "@FortranFan regarding your last comment, yes, that is the minimal proposal that we seem to get an agreement in #40. I plan to write it up soon. (Yes, I do think we want more, but we do not have an agreement on that.)\n@klausler yes I agree @everythingfunctional could have formulated it better also. Thank you for explaining it."
                },
                {
                    "user": "gronki",
                    "date": "2020-01-29 17:17:53+00:00",
                    "text": "Sorry for being inactive in this board for a longer while.\n\nCan I ask those who are familiar with arguments that are actually held by\nthe standarization entity: what is actually the reason behind absolutely\nstrict preservation of backward compatibility in some cases (such as:\nmaking implicit none as default) and less strict in other cases (some\nfeatures *have* been deleted from the language). As far as I understand,\n99% of the codes would not have issue with introducing one line of code\nthat re-enables some obsolete features. If for some reason this is not\npossible, the remaining 1% can use compiler switches that compiler vendors\nwill certainly provide. I do not understand how holding back the\ndevelopment of the language is in any way explained by few codes that could\npotentially require re-certification.\n\nI feel the \"backwards compatibility\" argument is used very inconsistetnly\nand only where it is convenient and the supposed penalty for doing that is\nhighly exaggerated. After all, it's not the language gets obsolete every 5\nyears: it is literally two or three features to be deleted that actually\nthat recur in every discussion and that do hold back the language. And none\nof the proposals change silently the behavior of the language but they are\nbetter characterized by \"hardening\" or making code \"strict\".\n\nI think there should be only one Fortran, the current one. It can still\nbenefit from the power of legacy of F77 codebase, but I feel this argument\nis often exaggerated and overused to prevent good change from happening. I,\npersonally, would be happy with \"strict\" or \"hardened\" or \"explicit\" or\n\"modern\" keyword as a middle ground that disables all terrible features\nwithout having to write 10 lines like \"implicit this\" and \"explicit that\"\nand that would also make backwards compatiblity a non-issue (if you use\n\"strict\", you keep code up to date cause it might become obsolete according\nto the the future revisions of the standard, if not, don't include it and\nyou're good for the next 50 years).\n\u2026"
                },
                {
                    "user": "certik",
                    "date": "2020-01-29 17:23:14+00:00",
                    "text": "@gronki thank you for explaining your position. Your last comment is what I believe also that we should do. (I thought previously you were against doing what you just wrote.)\n@sblionel you are the most prominent person on the Committee that is active here, what do you think? This is something I would like to discuss informally in person at our next meeting to see what others on the Committee think."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-29 18:43:40+00:00",
                    "text": "@certik , I have already suggested to Dan Nagle that we spend a few minutes at the next meeting to discuss the general issue of backwards compatibility. I've written some on this topic already, but here are some more thoughts...\n\n\nDeleting features is worse than pointless, it is harmful. Compilers will not actually remove \"deleted\" features because too many of their users/customers will raise a stink if they suddenly have to rewrite code that has worked for years/decades. Or, worse, the users will just switch to another compiler that hasn't removed support. And by \"remove\" I include complaining about it by default and requiring some sort of build option to bring it back. From the standard's perspective, deleting features is harmful as it removes descriptions of how the deleted feature should work with other parts of the language.\n\n\nWhen people ask me what Fortran's strengths are, I always include its compatibility with a broad catalog of existing software, and that a (correct) program written in the 1960s probably compiles, builds and runs just fine in today's compilers. Yes, there are exceptions to this, but they generally relate to rarely used or inadequately specified features.\n\n\nMost of the discussions here of candidates for deletion are about fixed-form source, implicit typing and implicit SAVE. Fixed-form is already marked obsolescent, but it is still VERY widely used. Implicit typing is also very widely used in older codes, but the standard provides a simple way of removing it through IMPLICIT NONE, and compilers have options to default to that - I don't see the need to do more. Implicit SAVE is a much harder thing to remove, as it is a semantic behavior not a syntax, so a compiler could not detect whether the user intended SAVE semantics or not. I'd have no objections to adding SAVE to the F18 IMPLICIT NONE() list, requiring positive action on the part of the user. (Don't forget that DATA has implied SAVE since forever...)\n\n\nI do not agree with those who argue that backwards compatibility prevents new features from being added. As I have already written, it can affect how we specify the new feature.\nLast, I'm puzzled and disappointed at all the energy being devoted to this general topic, which I view as being a silly hill to die on. But I'm done here and will be interested in what J3 folk have to say about it next month."
                },
                {
                    "user": "certik",
                    "date": "2020-01-29 19:49:07+00:00",
                    "text": "@sblionel thank you for the feedback, I really appreciate it. Let's discuss more at the meeting."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-02 16:46:22+00:00",
                    "text": ".. I do not understand how holding back the development of the language is in any way explained by few codes that could potentially require re-certification. ..\n\nCan anyone please post here some basic information (name, domain, etc.) on FORTRAN codes making use of implicit typing that are in \"production\" use?  Also, the ones which may have constraints such as software recertification?"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-03 14:58:06+00:00",
                    "text": "As implied in my #83 (comment), my impression remains the use of implied SAVE as deliberate intent that is part and parcel of code design is absent in codebases developed using facilities introduced with Fortran 90 and later standard revisions.\nAn improvement in Fortran which forces explicitness in terms of SAVE attribute (thus no implied SAVE) will be a tremendous blessing that helps many a codebase rather than prove detrimental."
                },
                {
                    "user": "certik",
                    "date": "2020-02-03 22:16:35+00:00",
                    "text": "At the upcoming Committee meeting I would like us to\n\nFigure out what the Committee (as a whole) stance on this is\nWrite it down\nPost it prominently in this repository, as guidelines how to improve the language (similar to the Python guidelines that @septcolor posted)\n\nThen that would put the conclusion to this debate. But until we do that, we are not done here."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-29 20:52:18+00:00",
                    "text": "The change to NAMELIST in #67 is another situation (#67 (comment)) where backward compatibility is also of concern, \"Changing the default behavior of namelist will change the behavior of existing programs. This may be done only for a very important reason, and a convenience issue, such as a default setting, likely does not rise to that level..\nI do find the concern in this case rather odd because\n\n\nthe compiler behavior as per current standard makes it not particularly usable (a standard-conforming program can fail to input edit what it itself output!),\n\n\nthere are no identified \"existing programs.\" that rely on current behavior, and\n\n\nit's often alleged NAMELIST is used rarely.\n\n\nSo to do something here to improve the default behavior appears more beneficial overall (that may also make the practitioners employ the corrected NAMELIST facility more) than any cost due to a \"breaking\" change or by not doing anything."
                },
                {
                    "user": "sblionel",
                    "date": "2020-02-29 21:54:05+00:00",
                    "text": "Backward compatibility was a concern on the NAMELIST change, sure, but more important was that the desired behavior could be easily obtained with already existing features, such as adding DELIM= on the OPEN, READ and/or WRITE. We\u2019re generally disinclined to add \u201cyet another way\u201d to so something, and even less so to force a behavior that some might not want.\nI\u2019d also note that list-directed I/O is a place where you probably would not want this, and a blanket ignoring DELIM-\u2018NONE\u2019 or changing the default does not add value. Restricting the change to NAMELIST adds needless complexity."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-29 22:10:08+00:00",
                    "text": "I have modified #67 to make it clear that current list-directed output should not be affected.\nAnd objection to greater complexity does not feel like a valid argument for me.  It's a complex situation caused by the existing rules (i.e. namelist output formatted according to list-directed output rules) and is producing incompatible output.  Why not introduce the necessary level of complexity which resolves the problem?  (And given that GFortran is already doing the sustainable thing, I doubt it ought to be considered a complex rule.)\nAnd I'm only raising this because I have supported and still support models which use namelists which get passed through workflow managers of greater complexity as times goes on.  These problems with string formatting happen too often and take too much time to debug.   And telling users to add a DELIM does not inspire faith in the language.\nI apologize if this is getting off track from the larger conversation of retaining backwards compatibility.    And I also fully understand that this isn't a serious problem for most Fortran users, which is already a very rarefied group.  But I don't see the point in retaining backwards compatibility to something which is broken."
                }
            ]
        },
        {
            "number": 78,
            "user": "FortranFan",
            "date": "2019-11-11 16:12:46+00:00",
            "title": "Default KINDs for constants and intrinsics",
            "text": "A proposal from UK national body from year 2013: https://wg5-fortran.org/N1951-N2000/N1975.txt\n--------------------------------------------------------------------------\nNumber: UK-01\nTitle: Default KINDs for constants and intrinsics\nStatus: For Consideration\nBasic Functionality:\nProgram-specified default KIND for constants etc.\nRationale:\n(a) In the 64-bit world default integer generally being 32-bit is\n    increasingly leading to incorrect programs.\n(b) In the floating-point world default real generally being 32-bit\n    not infrequently leads to incorrect programs.\n(c) It is tedious and error-prone to have to attach kind_param's to\n    individual literal constants.\n(d) It is tedious and error-prone to have to specify a KIND= argument as\n    required for each individual reference to an intrinsic function.\n(e) Program specification of the default type parameters is possible for\n    derived types but not intrinsic types.\n\nSpecification (requirements):\n1. Provide a mechanism for specifying the default kind parameter for the\n   intrinsic types REAL and INTEGER.\n2. Decouple the concepts of \"default kind\" from those of \"single precision\"\n   and \"basic integer\"; \"default kind\" to be used for literal constants,\n   implicit typing, etc., while \"single precision\" et al to be used for the\n   old storage association contexts.\n\nDiscussion:\n\nSpecifications (detailed):\n--------------------------\na. There will be a new statement, that can appear only between the USE\n   statements and IMPLICIT statements, to specify the default kind for a\n   particular intrinsic type.\nb. The effect of this statement is to change the default kind for the\n   remainder of the scoping unit.  To avoid circular dependencies, it does\n   not affect the default kind of literals appearing in or before the\n   statement itself, nor does it affect the type implied by a PARAMETER\n   statement that appears before the statement.\n   Rationale: circular dependencies bad, named constants good.\nc. The default kind setting in a scoping unit is initially that of its\n   host scoping unit; note that as nested scoping units appear necessarily\n   after any IMPLICIT statements, this will inherit the user setting.\nd. In the case of REAL, the default kind for COMPLEX is also affected.\n   It does not affect double precision kind, which remains as twice single\n   precision in storage.\ne. Terminology:\n     \"default kind\" = user-specifiable default kind\n     \"single precision kind\" = old default real kind\n     \"basic integer kind\" = old default integer kind\nf. OPTIONAL: There is a reasonable argument to be made that permitting the\n   user to specify the kind for \"double precision\" constants and variables\n   would also be valuable.\ng. Table of places where \"default kind\" is used, and what that should\n   correspond to in the new scheme, follows.\n\n    Context                                         Should be\n    ---------------------------------------------------------\n(1) integer literal with no <kind-param>            default kind\n(2) \"kindly\" intrinsics with absent KIND=           default kind * Note T0\n(3) intrinsics with no KIND argument                default kind * Note T1\n(4) <type-spec> with no KIND parameter, e.g. REAL   default kind * Note T2\n(5) arguments to generic intrinsics                 accept both * Note T3\n(6) args/result for specific intrinsics, e.g. AMIN1 basic kind * Note T4\n(7) constants in ISO_FORTRAN_ENV                    basic kind * Note T5\n(8) having the size of one numeric storage unit     basic kind\n(9) EQUIVALENCE/COMMON real/integer matching        basic kind\n\nNote T0.\n  This includes LBOUND, LCOBOUND, SIZE, SHAPE ... i.e. all the ones that\n  have a KIND= argument and return a REAL/INTEGER/COMPLEX result of the\n  specified kind when present, and default kind when not.\n\nNote T1.\n  Actually these don't really matter much, as the value always fits into\n  basic kind.  However, it would be more convenient when passing as an\n  actual argument, and more consistent, for these to be the new\n  user-specifiable default kind too.  Here is a representative list of\n  the intrinsics concerned: DIGITS, PRECISION, RANGE, EXPONENT,\n  MAX_EXPONENT, and THIS_IMAGE.\n\nNote T2.\n  Wherever the <type-spec> is, viz a type declaration statement, component\n  definition statement, array constructor, etc.\n\nNote T3.\n  The affected intrinsics:arguments are DATE_AND_TIME: VALUE,\n  EXECUTE_COMMAND_LINE:EXITSTAT,CMDSTAT, GET_COMMAND:LENGTH,STATUS, and\n  similar.  Not a big deal (values always representable in the basic kind)\n  but why not relax the requirement to permit larger kinds always anyway?\n\nNote T4.\n  Not actually important.  These are wholly redundant anyway.\n\nNote T5.\n  As if it were a user-defined module with those constants.\n\nSyntax (illustrative):\n----------------------\n   DEFAULT <intrinsic-type-name> ( [ KIND = ] <int-constant-expr> )\n     where <intrinsic-type-name> is INTEGER or REAL.\n   Cnnn (Ryyy) The kind number specified in a DEFAULT INTEGER statement\n     shall specify a kind whose storage size is at least as great as that\n     of basic integer kind.\n   {Reason: To stop the user shooting his foot off with a short integer\n            kind.}\n\n   OPTIONAL: If we permit specification of double precision kind, add this\n             additional syntax:\n   DEFAULT DOUBLE PRECISION ( [ KIND = ] <int-constant-expr> )\n   Cnnn The kind number specified in a DEFAULT DOUBLE PRECISION\n     statement shall not specify a kind whose storage size is less than\n     that of default real kind.\n   {Reason: There might not be a bigger real kind than the user-specified\n            default, but it would be counter-intuitive to permit\n            specification of a double precision kind that is actually\n            smaller than default real.}\n\nExample:\n--------\nThis is just to show how it works, it is too trivial to show much\nadvantage.\n\nProgram sum_tan_prefix\n  Default Integer (Kind=Selected_Int_Kind(18))\n  Default Real (Kind=Selected_Real_Kind(15))\n  Real,Allocatable :: x(:)\n  Print *,'Input vector length N'\n  Read *, n\n  If (n<2) Stop 'Don''t be silly.'\n  Allocate(x(n))\n  Print *,'Input vector with',Size(x),'values in degrees'\n  Read *,x\n  tmp = 0\n  Print *,'SUM_TAN_PREFIX results'\n  Do i=1,Size(x)\n    tmp = tmp + Tan(x(i)*3.1415926535897932384/180)\n    Print *,i,x\n  End Do\nEnd Program",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-11 19:44:11+00:00",
                    "text": "@FortranFan, thanks for this idea. I think this is a long standing issue in Fortran and a source of a lot of errors, at least in the codes that I have seen. Do you mind editing the title of this issue to just \"Default KINDs for constants and intrinsics\", the \"Brilliant\" Proposal part does not add value.\nIn a similar spirit, if possible, please try to keep the discussion technical. Trust me, I think I fully understand your frustration, and we have to streamline how the committee works. But I want these discussions here on issues to be purely technical (if the issue is technical like this one), so that we can move the discussion forward on technical terms. You can open another issue to discuss how the committee can improve how it works."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 21:03:17+00:00",
                    "text": "@certik wrote:\n\n..the \"Brilliant\" Proposal part does not add value.\nIn a similar spirit, if possible, please try to keep the discussion technical. Trust me, I think I fully understand your frustration, and we have to streamline how the committee works. But I want these discussions here on issues to be purely technical (if the issue is technical like this one), so that we can move the discussion forward on technical terms. You can open another issue to discuss how the committee can improve how it works.\n\n@certik , as asked, the title and the body have been edited - please let me know if there's anything else objectionable."
                },
                {
                    "user": "certik",
                    "date": "2019-11-11 21:14:30+00:00",
                    "text": "@FortranFan thank you, I think it looks great!"
                }
            ]
        },
        {
            "number": 77,
            "user": "jacobwilliams",
            "date": "2019-11-09 19:15:03+00:00",
            "title": "Optional applied to groups of arguments",
            "text": "I have no idea what the syntax would look like, but I have often wished that we could have some way of checking at compile time the presence/absence of a group of optional arguments (if they are all present or not). The only way currently to do this is at run time.\nThe use case is to avoid code like this:\nsubroutine test(x,y,z,opt1,opt2)\n...\nif (present(opt1) .eqv. present(opt2)) then\n   if (present(opt1)) then\n     ! both are present ...\n   else \n     ! neither are present ...\n   end if\nelse\n   error stop 'error: have to use opt1 and opt2 at the same time'\n   ! or return some error code...\nend if\n...\nI'd like some way to be able to call a routine like this such as:\n   call test(x,y,z)        ! ok\n   call test(x,y,z,o1,o2)  ! ok\n   call test(x,y,z,o2=o2)  ! this is a compile time error\nOverloading multiple functions works for some cases like this, but not all (say you have many variables like this of the same type grouped into different sets that you want to test). Using derived types also works for some cases but may be unsatisfactory or not possible for others.\nJust an idea.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-10 15:47:35+00:00",
                    "text": "@jacobwilliams, can you elaborate further on the 2 points you make?\n\n\n\"Overloading multiple functions works for some cases like this, but not all (say you have many variables like this of the same type grouped into different sets that you want to test).\"  - this comes across more as a design issue for one's code rather than a case for a new language facility which can possibly then aid and abet suboptimal code designs.  Subprograms with long argument lists (thus the case of \"many variables like this\") are best avoided as-is, but then if the argument list includes \"groups of optional dummy arguments\" the situation is questionable.\n\n\n\"Using derived types also works for some cases but may be unsatisfactory or not possible for others.\" - well, if the use of derived types is \"unsatisfactory or not possible\" but instead a library designer is dealing with \"many variables like this of the same type grouped into different sets\" that are optional, again something appears amiss with code design."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-10 22:05:35+00:00",
                    "text": "The venerable ENTRY statement might be of use to you in such situations."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 01:15:33+00:00",
                    "text": "The venerable ENTRY statement might be of use to you in such situations.\n\nTry writing a subprogram with the obsolescent ENTRY statements for a case that effectively corresponds to many dummy arguments which are optional and \"of the same type grouped into different sets.\""
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-11 08:52:12+00:00",
                    "text": "Could this be more generally solved by introducing a compile-time assert statement? Something I've wished for in situations like this where you are forced to throw runtime errors to check correctness."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-11 17:30:38+00:00",
                    "text": "The venerable ENTRY statement might be of use to you in such situations.\n\nTry writing a subprogram with the obsolescent ENTRY statements for a case that effectively corresponds to many dummy arguments which are optional and \"of the same type grouped into different sets.\"\n\nIt should be obvious, but ok:\nsubroutine WithBothGroups(a,b,c,x,y,z)\n  real :: a, b, c\n  integer :: x, y, z\n  logical :: areABCpresent, areXZYpresent\n  areABCpresent = .true.; areXYZpresent = .true.\n  go to 1\n  entry WithFirstGroup(a,b,c)\n  areABCpresent = .true.; areXYZpresent = .false.\n  go to 1\n  entry WithSecondGroup(x,y,z)\n  areABCpresent = .false.; areXYZpresent = .true.\n1 continue\n  ...\n\nYou can learn more about the ENTRY statement in 15.6.2.6.  Hope this helps."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-11 18:46:57+00:00",
                    "text": "@klausler Ooo...that is diabolical! :)\n@FortranFan The use case I had in mind is, say, for a library that presents a class that implements some complicated algorithm. Maybe this algorithm has lots of input parameters. Some of them are optional, some of them only make sense when used together. I don't think it's bad practice to have the constructor just have a lot of inputs. It makes it very easy for the user of this library to instantiate the class like so:\n type(trajectory_optimization_method) :: t\n call t%initialize(method=encke, relative_tol=1.0e-6, absolute_tol=1.0e-9, &\n    event_function=my_func, event_tol=1.0e-12, event_method=brent, etc...)\n call t%go(...)\nMaybe in this made up example, the event ones have to be used together (either not present, or all present). Sure, I could force the user to declare another type with these variables and then that's the single optional argument. But it does make it more verbose for the user, since they now have to declare another class & instantiate it.  Now imagine there are multiple groups of variables like this for the algorithm.\nAnyway, not really a huge deal. But I just wanted to mention this since I have come across this before.\n@LKedward Maybe assert is the way to go. I think there's a another issue for that? I can't say I've thought about that too much."
                },
                {
                    "user": "certik",
                    "date": "2019-11-11 18:57:55+00:00",
                    "text": "See the issue #70 for the assert statement."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 23:36:49+00:00",
                    "text": "..\n@FortranFan The use case I had in mind is, say, for a library that presents a class that implements some complicated algorithm. Maybe this algorithm has lots of input parameters. Some of them are optional, some of them only make sense when used together. I don't think it's bad practice to have the constructor just have a lot of inputs. ..\n\nYou'll note it's fairly common practice with OO classes to make use of 'helper classes' (say event_t) especially when there are a set of related data and methods with operate with such data.  Now, if as you write it proves 'more verbose for the user, since they now have to declare another class & instantiate it' then for such situations OO class designs do tend to adopt additional 'setter' methods that are invoked only as needed:\n type(trajectory_optimization_method) :: t\n call t%initialize(method=encke, relative_tol=1.0e-6, absolute_tol=1.0e-9)\n call t%setevent( event_function=my_func, event_tol=1.0e-12, event_method=brent )\n ! other such setters\n call t%go(...)\n\nAnyways, I assume you have seen in other languages the kind of facilities you have in mind toward managing groups of optional parameters in subprogram invocations?  Perhaps you can show some examples from these languages?  Thanks,"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 16:40:41+00:00",
                    "text": "I would agree with Fortran Fan that there seems to be a problem with the code design. In the given example, type trajectory_optimization_method has a field method, whereas in OO programming paradigm, it is a method. So here the proper solution would be:\ntype, extends(trajectory_optimization_method) :: encke_tr_opt_method\n! ...\nend type"
                }
            ]
        },
        {
            "number": 76,
            "user": "jacobwilliams",
            "date": "2019-11-09 19:01:45+00:00",
            "title": "Variadic functions",
            "text": "Has this even been discussed? Some other languages have it. Why not Fortran?",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2019-11-09 19:21:48+00:00",
                    "text": "Can you describe what this is? I've been programming since 2006 and never heard of these until now. I understand now because I Googled it, but we shouldn't have to Google stuff proposed here. An example would go a long way.\nNow for my view on this idea: I use it occasionally in Python via *args and **kwargs, but can't say I ever wished for it in Fortran (not an argument against though). I suspect that this would significantly complicate compiler implementation, although I don't know as I never programmed compilers. Curious to hear more experienced people's opinions here."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-09 19:26:31+00:00",
                    "text": "If I'm using the term correctly, I just meant a function that has an unknown number of arguments. It's not entirely unknown to Fortran, since the intrinsic max or min routines behave like this. You can call it like:\na = max(1,2)\na = max(1,2,3)\na = max(1,2,3,4,.....etc)\nBut, we have no ability to write routines like this ourselves."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-09 19:31:21+00:00",
                    "text": "Interesting, I had no idea I could use min and max with more than 2 arguments."
                },
                {
                    "user": "certik",
                    "date": "2019-11-09 21:28:03+00:00",
                    "text": "I didn't know that either."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-10 23:11:18+00:00",
                    "text": "The use of MIN/MAX with more than two arguments goes all the way back to the original Fortran compiler for the IBM 704, although the names of the functions were different."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-10 23:28:11+00:00",
                    "text": "For example, function HYPOT(x,y) has just two arguments while it could have more. By the way, does any know what was the reason for introducing this as intrinsic function in F2008? Do some architectures provide hardware implementation for this?\nAs for variadic functions, Python handles such arguments to the function as list. For example:\ndef hypot(*p): \n    import math \n    return math.sqrt(sum([x**2 for x in p]))\nprint(hypot(1))\nprint(hypot(3,4))\nprint(hypot(1,4,8))\nI am guessing in Fortran the issue would be how to implement that without the performance hit of unnecesary construction of a temporary array."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-11 01:15:51+00:00",
                    "text": "Ok, a quick google search revealed the answer. Please ignore the first paragraph of my last post. :)\nhttps://en.wikipedia.org/wiki/Hypot"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 08:33:20+00:00",
                    "text": "Maybe useful, indeed, but the interaction of those arguments with the usual optional ones may be non-trivial. Does one allow for both, convention optional arguments and the variadic ones in the same subroutine? How does it work with named argument in subroutine calls, e.g. call nonvariadic(b=1, c=2, d=3, a=1) is completely valid for a normal subroutine with positional or optional dummy arguments, but I can't see, how something like this would work with variadic routines.\nSome cases can be handled by using arrays instead, like hypot([1.,0, 2.0, 3.0, 4.0]). Actually, since the introduction of the norm2() function, it is already part the language.\nIs there a showcase, where anyone can demonstrate the necessity of variadic routines and show, that it would be impossible or very inconvenient to implement the same functionality using arrays and/or optional arguments? Otherwise, it would be quite difficult to argue for a non-trivial language extension."
                },
                {
                    "user": "LKedward",
                    "date": "2019-11-11 09:20:33+00:00",
                    "text": "There have been several times that this would have been useful for me, I have code at the moment that looks like:\nclass(*), intent(in), optional, target :: a1,a2,a3,a4,a5,a6,a7,a8,a9,a10\n...\nif (present(a1)) then\n  call someFunction(i0+0,a1)\nend if\nif (present(a2)) then\n  call someFunction(i0+1,a2)\nend if\nif (present(a3)) then\n  call someFunction(i0+2,a3)\nend if\net cetera...\nNot impossible to implement, but inconvenient and limiting, since there is necessarily a finite number of optionals.\nSince variadics generalise the concept of optional arguments, their use would presumably be mutually exclusive - it makes no sense to use both simultaneously so don't allow it - and there won't be any ambiguity in the interface.\nFinally since the intrinsics support it, it would be nice to be able to use it in our own functions and subroutines."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 11:39:07+00:00",
                    "text": "OK, I see. Further question would be, how one ensures type safety? Does one request all variadic arguments to have the same type/rank? Or should a routine iterating over the arguments return type(*)/rank(..) objects? Latter would be more flexible, but then type and rank checking would be shifted to run-time instead of done at compile time. (And you would have to embed the evaluation of the arguments into select type and select rank constructs, which does not make it very convenient to use...)"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-11 14:08:03+00:00",
                    "text": "I think yes, similarly to almost all intrinsic subroutines having to have\narguments of the same type and kind. Everything else would be a mess. \ud83d\ude09\n\npon., 11 lis 2019, 12:39 u\u017cytkownik B\u00e1lint Aradi <notifications@github.com>\nnapisa\u0142:\n\u2026\n OK, I see. Further question would be, how one ensures type safety? Does\n one request all variadic arguments to have the same type/rank? Or should a\n routine iterating over the arguments return type(*)/rank(..) objects?\n Latter would be more flexible, but then type and rank checking would be\n shifted to run-time instead of done at compile time. (And you would have to\n embed the evaluation of the arguments into select type and select rank\n constructs, which does not make it very convenient to use...)\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#76?email_source=notifications&email_token=AC4NA3M6L6UKE2UKFU774MTQTE75ZA5CNFSM4JLJDHZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDWRSWA#issuecomment-552409432>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3MC7JQOG3V6YLLATHTQTE75ZANCNFSM4JLJDHZA>\n ."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-11 14:44:33+00:00",
                    "text": "I've been thinking about this a bit and come up with an idea of how the syntax could work, loosely inspired by how C handles variadic arguments. A procedure without any optional arguments could have zero or one argument with the attribute variadic. There would be two additional intrinsic procedures defined, similar to those used for getting command line arguments: get_variadic_count and get_variadic_argument. The first of these would return the number of variadic arguments passed to the function. The second would make the argument specified as variadic point to the desired argument. Their interfaces would be as follows:\nfunction get_variadic_count()\n  integer :: get_variadic_count\nend function\n\nsubroutine get_variadic_argument(number, value, status)\n  integer, intent(in) :: number\n  type(*), dimension(..), intent(out) :: value\n  integer, intent(out), optional :: status\nend subroutine\nAs an example, I'll show how these could be used for an implementation of max that works on rank-1 arrays:\nfunction array_max(arrays)\n  integer, dimension(:), intent(in), variadic :: arrays\n  integer :: array_max\n  integer :: i, j, n\n  n = get_variadic_count()\n  do i = 1, n\n    call get_variadic_argument(i, arrays)\n    if ( i == 1) array_max = arrays(1)\n    do j = 1, size(arrays)\n      if (arrays(j) > array_max) array_max = arrays(j)\n    end do\n  end do\nend function array_max\nThe advantage of can see of this is that the variadic argument could support pass-by-reference, with the compiler implementing it as a pointer in the background. It would avoid the need to copy the individual arguments into a new array. It would allow enforcing all of the arguments to be of the same type/kind/rank but not necessarily the same size. There would also be nothing to stop the variadic argument being declared as unlimited polymorphic, assumed type, or assumed rank, in which case each argument would not necessarily need to be the same type/rank, but the usual type-guards would be needed before you could do anything interesting with the argument. This approach would also allow for all the usual attributes (intent, pointer, allocatable, etc.) to be applied to the variadic argument in a meaningful way."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 16:04:56+00:00",
                    "text": "@cmacmackin Just for clarification and make sure I understand your proposal correctly. Did you mean\nif (arrays(j) > array_max) array_max = arrays(j)\n\non line 10 in the 2nd example?"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 16:19:06+00:00",
                    "text": "@cmacmackin I like your approach a lot. Just a minor remark. The interface you specify won't work with your example,  as the dummy argument type class(*) :: value won't match integer, dimension(:) :: arrays due to rank mismatch. It would have to be more general, being able to handle all different kind of ranks and types, including type(*) and class(*)"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-11 16:20:41+00:00",
                    "text": "Ah yes, thanks for catching those. I'll update the code fragments accordingly."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-11 16:31:22+00:00",
                    "text": "The use of MIN/MAX with more than two arguments goes all the way back to the original Fortran compiler for the IBM 704, although the names of the functions were different.\n\n62 years later, FORTRAN doesn't cease to impress me!"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 16:42:17+00:00",
                    "text": "I think, the calling of such a routine with named arguments needs also some thoughts. Given the variadic routine\nsubroutine testvariadic(posarg1, posarg2, vararg)\n  integer, intent(in) :: posarg1, posarg2\n  integer, intent(in), variadic :: vararg\n...\nend subroutine testvariadic\n\nwhich of the following calls should be valid:\ncall testvariadic(1, 2, 3, 4, 5, 6)   ! Trivially yes\ncall testvariadic(posarg2=2, posarg1=1, 3, 4, 5, 6)\ncall testvariadic(posarg1=1, 3, 4, 5, 6, posarg2=2)\ncall testvariadic(posarg1=1, 3, 4, 5, posarg2=2, 6)\ncall testvariadic(posarg2=2, posarg1=1, vararg=3, vararg=4, vararg=5, vararg=6)\netc."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 01:14:39+00:00",
                    "text": "From what I understand, currently the keywords argument must come after all positional arguments. So I think vararg must be restricted that it always comes as a positional argument or things can get very very messy. I feel it might be actually quite difficult to design it in a good way that will not cause confusion."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 10:46:44+00:00",
                    "text": "Currently, having\n  subroutine testoptional(a, b, c, d)\n    integer, intent(in) :: a, b\n    integer, optional, intent(in) :: c, d\n  end subroutine testoptional\n\nthe calls\ncall testoptional(1, c=3, d=4, b=2)\ncall testoptional(b=2, c=3, d=4, a=1)\n\nare valid. If varargs must be positional arguments, then basically this would invalidate keyword-like arguments in the call of such a routine. Unless, one allows for multiple occurancies of a given keyword if it belongs to the vararg:\nsubroutine testvariadic(posarg1, posarg2, vararg)\n  integer, intent(in) :: posarg1, posarg2\n  integer, intent(in), variadic :: vararg\nend subroutine testvariadic\n\ncall testvariadic(1, vararg=3, vararg=4, vararg=5, posarg2=2)\ncall testvariadic(posarg2=2, vararg=3, vararg=4, vararg=5, posarg1=1)\n\nI think, this would be the most compatible with the way how kewyord arguments work in Fortran now."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-12 10:48:34+00:00",
                    "text": "Unless, one allows for multiple occurancies of a given keyword if it belongs to the vararg\n\nI was thinking that would be the tidiest solution."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-12 13:52:36+00:00",
                    "text": "Keep in mind how the intrinsic procedures are set up:\nFrom 16.9 Specifications of the standard intrinsic procedures of the standard:\n27   16.9.125 MAX (A1, A2 [, A3, ...])                                                                              \n28 1 Description. Maximum value.                                                                                    \n29 2 Class. Elemental function.                                                                                     \n30 3 Arguments. The arguments shall all have the same type which shall be integer, real, or character and they shall\n31   all have the same kind type parameter.                                                                         \n..                                                                                                                  \n\nNote the following:\n   print *, max( a1=1, a2=2, a42=3, a142=4 )\nend\n\noutputs 4.\nConsistency with how intrinsic procedures are specified as being ELEMENTAL and being able to accept any number of dummy arguments of the same type such as MAX, MIN, .. work with argument names of A1, A2 [, A3, ...] might be the best option.\nNow these intrinsic procedures only accept intrinsic types of course (usually integer, real, or character) but I think it'll be useful if such user procedures can accept dummy arguments which are derived types of the same declared type."
                },
                {
                    "user": "ivan-pi",
                    "date": "2019-11-15 22:49:05+00:00",
                    "text": "This would have been useful for me in the past is when writing N different subroutines to print N different column vectors. With support for variadic arguments I imagine it would be possible to have a single subroutine call print_columns(filename,a,b,c,...) where a,b,c,... would be a variable number of arrays with the same dimension in rank one."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 23:05:24+00:00",
                    "text": "@FortranFan You are right, then we should allow for enumerating the varargs in the call to be similar to already existing intrinsic functions:\nsubroutine testvariadic(posarg1, posarg2, vararg)\n  integer, intent(in) :: posarg1, posarg2\n  integer, intent(in), variadic :: vararg\nend subroutine testvariadic\n\ncall testvariadic(1, vararg1=3, vararg2=4, vararg129=5, posarg2=2)\ncall testvariadic(posarg2=2, vararg1=3, vararg2=4, vararg129=5, posarg1=1)"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-07-07 16:54:19+00:00",
                    "text": "FYI: here's another example where this would be handy: https://github.com/urbanjost/M_msg/blob/master/src/M_msg.f90"
                }
            ]
        },
        {
            "number": 75,
            "user": "klausler",
            "date": "2019-11-08 23:08:55+00:00",
            "title": "Type aliasing: some options",
            "text": "It would be useful to be able to establish a name as an alias for a type so that the name could be (for example) USE-associated.  This is presently possible for derived type names, of course, but not intrinsic types, and perhaps only aliases for intrinsic types need to be supported.\nThe syntax could be something like TYPE(type-spec), ALIAS :: name or TYPE :: name => type-spec.\nUse case (sorry):\nMODULE M\n  TYPE(REAL(4)), ALIAS :: M_TYPE\nEND MODULE\nUSE M, ONLY: M_TYPE\nTYPE(M_TYPE) :: X ! same as REAL(4) :: X\n\nPerhaps type parameters could be deferred\nAdditionally or alternatively: if type aliases could be defined as pseudo-components of derived types, that would likely be sufficient, and may well be more useful; e.g.,\n  TYPE :: DT(K)\n    INTEGER, KIND :: K\n    TYPE(REAL(K)), ALIAS :: R ! or TYPE :: R => REAL(K)\n    TYPE(R), ALLOCATABLE :: A(:,:)\n    ...\n  END TYPE\n  TYPE(DT(4)) :: X\n  TYPE(DT(4)%R) :: Y\n  TYPE(X%R) :: Z\n\nLast, if it were possible to inquire about the type of an entity and use that type in another declaration, that may also suffice.  Something like TYPE(OF(expr)) and (for derived types) CLASS(OF(expr)).  Then one could gain the same effect as a type alias through the use of a prototype entity, similar to decltype in C++.\nNone of the syntax above is particularly important, and implementation of any/all of these would be straightforward.\nApologies in advance to any who may think these ideas are insufficiently developed before being described here.  I would rather lay out the various options that I know about for discussion than propose a fully elaborated design of the wrong alternative.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-08 23:29:41+00:00",
                    "text": "A related feature to also consider: conditional typing via TYPE(IF(constant-logical-expr,t1,t2)) and CLASS(IF(constant-logical-expr,t1,t2)) or some other syntax."
                },
                {
                    "user": "rweed",
                    "date": "2019-11-09 18:48:25+00:00",
                    "text": "I've always wondered why we couldn't put further restrictions on pointers so they can only act as aliases for other variables (ie, can't be allocated and can't point to array segments). I've found in refactoring old code that its sometimes convienent to make existing old variable names contiguous pointers (usually something in an EQUIVALENCE statement) because that is easier for me than trying to do ASSOCIATE on 20 or 30 variables. I guess CONTIGUOUS probably does the same thing. While my preference would just be an ALIAS attribute instead of having to reference POINTER at all (ie REAL, ALIAS :: someValue(:,:))\nI could live with just\nREAL, POINTER, ALIAS :: someValue(:,:)"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-10 04:42:06+00:00",
                    "text": "@rweed wrote:\n\nI've always wondered why we couldn't put further restrictions on pointers so they can only act as aliases for other variables (ie, can't be allocated and can't point to array segments). I've found in refactoring old code that its sometimes convienent to make existing old variable names contiguous pointers (usually something in an EQUIVALENCE statement) because that is easier for me than trying to do ASSOCIATE on 20 or 30 variables. I guess CONTIGUOUS probably does the same thing. While my preference would just be an ALIAS attribute instead of having to reference POINTER at all (ie REAL, ALIAS :: someValue(:,:))\nI could live with just\nREAL, POINTER, ALIAS :: someValue(:,:)\n\n@rweed, it does not appear your comments pertain to the issue in this thread."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-10 05:12:55+00:00",
                    "text": "An idea long considered by the J3 Fortran committee appears to be \"New Types from Existing\" that is supposed to include support for the kind of aliasing indicated in the original post of this thread:, see the following for a couple of recent discussions:\nhttps://j3-fortran.org/doc/year/18/18-113r1.txt\nhttps://j3-fortran.org/doc/year/18/18-255.txt\nUnfortunately the work toward developing a facility of \"New types from existing\" is another one of those items that keeps getting pushed back by the committee, the last it was discussed they came away with \"No action, understand the desire but contradiction between different bits; generic resolution would be ambiguous, intrinsic operators interconnect in interesting ways (math functions, intrinsics, etc)\"\nI personally like the idea of a TYPE ALIAS, both user-defined and also some intrinsic ones.  On another issue #13, there is some back and forth between the use of REALNN named constants for supported kinds in a processor toward floating-point types vis-a-vis the use of SELECTED_REAL_KIND intrinsic function (but not to forget the IEEE_SELECTED_REAL_KIND one!).\nAs I wrote in a separate thread at comp.lang.fortran:\nWith near-universal support of IEEE 754 floating-point arithmetic with current processors, what Fortran can do for its practitioners is to offer SHORT-HAND notation to more easily consume the IEEE 754 number format in codes.\nFor heaven's sake, the Fortran standard committee would do well to introduce INTRINSIC ALIASes of, say, FP32, FP64, FP128 that map to the corresponding 32-bit, 64-bit, and 128-bit formats (i.e., \"real(KIND=ieee_selected_real_kind(P=..,R=.., RADIX=..)\") that are listed in the IEEE 754 standard in great detail and which have been supported by all the processors for nearly 30 years now.  This is so that a young, bright middle-schooler can readily start doing 'formula translation' in Fortran with IEEE 754 formats like so\n    fp64, parameter :: Rgas = ..\n    fp64 :: T, P, density\n    ..\n    density = P/Rgas/T\n\ninstead of the verbose and ill-communicated 'canon':\n    integer, parameter :: RK = ieee_selected_real_kind( p=..)\n    real(kind=RK), parameter :: Rgas = ..\n    real(kind=RK) :: T, P, density\n    ..\n    density = P/Rgas/T"
                },
                {
                    "user": "rweed",
                    "date": "2019-11-10 15:36:09+00:00",
                    "text": "@FortranFan  sorry, you are correct. I didn't read the original post close enough. However, what is being proposed is similar to my suggestion about making the values returned by the selected_..._kind functions and the intrinsic KIND value in ISO_FORTRAN_ENV (REAL32, INT32, etc) unique. The ISO_FORTRAN_ENV variables in particular are then effectively the type aliases used in the current context. in particular instead having to type\ntype(real(REAL64) :: areal\ntype(integer(INT32) :: anint\nyou only need\ntype(REAL64) :: areal\ntype(INT32)    :: anint"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 03:44:39+00:00",
                    "text": "@rweed wrote:\n\n.. what is being proposed is similar to my suggestion about making the values returned by the selected_..._kind functions and the intrinsic KIND value in ISO_FORTRAN_ENV (REAL32, INT32, etc) unique.  ..\n\n@rweed, do note what is proposed in the J3 papers (e.g., 18-255) is more comprehensive, it allows an ALIAS for intrinsic as well as user-defined types.\nSeparately, as you know well the standard since Fortran 90 has not mandated \"unique\" values for the KINDs across all intrinsic types.  That's nearly 30 years now.  And there are quite a few processor implementations where the KINDs are not unique.  So it appears infeasible now, in addition to being of limited value, to include something like this in the standard."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 08:47:56+00:00",
                    "text": "@FortranFan As for your example with the fp64 type, how would the parameter assignment work? I find\ninteger, parameter :: wp = selected_real_kind(...)\nreal(wp), parameter :: myconst = 0.1234_wp\n\nmaybe somewhat verbose, but consistent. If you used fp64 instead\nfp64, parameter :: myconst = 0.1234_wp\n\nlooks rather inconsistent and confusing to me. Of course, you could also introduce fp64 as a kind value, then\nfp64, parameter :: myconst = 0.1234_fp64\n\nwould be at least consistent again, but not necessarily less verbose than the original one."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 16:43:05+00:00",
                    "text": "@aradi wrote:\n\n@FortranFan As for your example with the fp64 type, how would the parameter assignment work? ..\n\n@aradi , thank you for your interest.\nMy vision is by the time something like a TYPE ALIAS facility makes it into the language, Fortran would have great strides in what it offers the practitioners of Fortran with LITERAL CONSTANTS, perhaps along the lines of ideas in #78, so much so the issue of type and kind of \"magic numbers\" become intuitively obvious from the \"context\" (e.g., what the coders has enabled in the scoping unit) as they do with beautiful formulae in science and math, that codes in Fortran are allowed to get closer and closer to formula translation and achieve blackboard abstraction.  With that in mind, my hope is one should be simply be able to do the following with no risks or dangers in terms of type, kind mismatch and any consequent loss of precision, etc.:\n! The scoping unit for the statement below shall be able to state the KIND for the\n! literal is the same as that of the named constant\nfp64, parameter :: myconst = 0.1234\n\nI do think Fortran needs to advance beyond the _wp kind of suffix/prefix in literal constants."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-11 19:05:47+00:00",
                    "text": "I should add that my conception of type aliases are true aliases, not a newtype in the sense of Haskell.  An alias should work exactly as if the type to which it resolves had been specified instead, and there must be no consequences to the semantics of generic resolution, intrinsic operators and functions, I/O, or anything else."
                },
                {
                    "user": "vansnyder",
                    "date": "2022-04-23 20:55:45+00:00",
                    "text": "I haven't seen a use case for type aliases that cannot be satisfied by new types from existing ones. One use case for new types is the example of a code designed to run with different precisions. If you declare two kind type parameters, say SELECTED_REAL_KIND(7) and SELECTED_REAL_KIND(14), create procedures having REAL variables with those kinds, and join them with a generic interface block, all is well -- until your code arrives in a processor where those inquiry functions have the same value. It won't even compile, let alone get generic resolution right. If you could declare different types, not type aliases and not different kinds of the same type, there would be no problem.\nThis proposal foundered at Tokyo in 2019 when Malcolm asked \"what would be the kind of the result of a mixed type operation such as multiplication?\" Of course the answer was \"a simple generalization of the rules in Clause 10\" (10.1.9.3 in 22-007r1) but that didn't carry the day."
                }
            ]
        },
        {
            "number": 74,
            "user": "certik",
            "date": "2019-11-05 19:51:23+00:00",
            "title": "Generic Programming: modules parameterized over other modules",
            "text": "@klausler suggested in #4 (comment):\nFrom an implementation perspective, the form of polymorphism that I think would solve the most use cases with the least compiler grief would be modules parameterized over other modules, with explicit instantiation.\nMODULE LIST(E)\n  USE E, ONLY: ELEMENT\n  TYPE :: NODE\n    TYPE(ELEMENT) :: X\n    TYPE(NODE), ALLOCATABLE :: LINK\n   CONTAINS\n    PROCEDURE :: LENGTH ! & c.\n  END TYPE NODE\nEND MODULE LIST\n\nMODULE MYTYPE\n  TYPE :: ELEMENT\n    ...\n  END TYPE\nEND MODULE\n\nPROGRAM\n  USE MYTYPE, ONLY:\n  USE LIST(MYTYPE), INSTANTIATE ! causes compilation of module template instance\nEND PROGRAM",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-11-06 00:51:40+00:00",
                    "text": "I do not think this solution is good or generic at all. So what is required from the programmer is to have a module with derived type called in a particular way (ELEMENT). What about a list of integers? What if we have an arbitrary type where we do not control how type is called? Create a wrapper module like:\nMODULE WRAPPER\nUSE MYTYPE2, ONLY: ELEMENT => WHATEVERNAMEWAS\nEND MODULE\nWhat if I want to use the list for some higher generic container? How do we then ensure that the module has type called ELEMENT? I cannot then create a wrapper module. What if we need two lists, both containing different kind of items? What about generic programming in terms of real/integer kinds?\u00a0\nI am against half-baked solutions that in 20 years everyone will hate but they will stay in the language forever because \"backwards compatibility\".\nFirst of all, what do we need the generic programming for? We won't have it for everything unless full-blown C++-like tempates are implemented. Do we need it to create linked lists and containers? I think they should be provided by the language. Do we need it to write one code for any kind of real/integer? Then probably we need something better than parametrized derived types that do not solve any problem.\nI think some realistic use cases from the industry should be taken. Everyone seems to be keen on writing containers (as they are missing from the language currently) but the truth is that should not even be the basic use case. So what else?"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-06 16:22:45+00:00",
                    "text": "I did not mean to be disrespectful. What I meant was that i thought this solution was very specific (similarly to parametrized derived types)."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-06 17:23:52+00:00",
                    "text": "I did not ask for this idea to be a top-level issue and I'm not going to waste time defending it."
                },
                {
                    "user": "certik",
                    "date": "2019-11-06 17:25:28+00:00",
                    "text": "@septcolor thank you. @gronki yes, next time please try to formulate exactly the same point in a nicer way. Instead of saying:\n\nI am against half-baked solutions that in 20 years everyone will hate but they will stay in the language forever because \"backwards compatibility\".\n\nYou can say:\n\nI feel this proposal is half-baked in a sense that it does not solve the problem in its entirety, and it could easily happen that in 20 years that most people will end up not liking this feature, but we will be stuck with this feature forever, because we want Fortran to be backwards compatible. And if that is the case, I would be against it.\n\nThere are other ways to say it also. That way you still say exactly what you wanted to point out, and without risking of offending anyone, or putting anybody on the defense. We are all on the same team, and we have to trust each other that none of us wants to introduce some half-baked solutions into Fortran.\nI really appreciate that you are participating here, and I am actually in the same camp as you are --- I think it's better if we can figure out how to put features into the language itself (such as arrays which are already in Fortran), as opposed to making the language more general like C++ that does not have arrays and as a consequence there are dozens of incompatible array implementations. However there are other valid points of views. It's not black and white."
                },
                {
                    "user": "certik",
                    "date": "2019-11-06 17:30:02+00:00",
                    "text": "I did not ask for this idea to be a top-level issue and I'm not going to waste time defending it.\n\nI put this as a top level issue as I think it's worth discussing because it's an interesting idea. Thank you for contributing it.\nI am sorry some of the discussion wasn't the nicest, we will do better the next time."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 18:56:21+00:00",
                    "text": "I think this is an idea worth trying to flesh out. It seems to me you wouldn't want to restrict it to only be parameterized by other modules, because it implicitly couples other modules to the parameterized one. I.e. the module cannot be used if it doesn't conform to the \"interface\" the parameterized one expects, but this isn't made explicit anywhere. However, treating it like a preprocessor type feature that only operates at the source code level might be able to get you far enough. This all needs more thought."
                },
                {
                    "user": "klausler",
                    "date": "2020-01-06 19:58:01+00:00",
                    "text": "Here is a draft proposal.\n\nIntroduction\n\nThis proposal defines a means by which modules may be parameterized and instantiated upon\nother modules and use-names as a facility for generic programming.\n\nModified and additional requirements to Fortran 2018\n\nAn optional module-dummy-list is added to module-stmt; module-name is\nreplaced with module-spec in use-stmt.\n(R1405) module-stmt ::= MODULE module-name [ ( module-dummy-list ) ]\n(new)   module-dummy ::= module-dummy-name [ = default-module-spec ]\n(new)   module-dummy-name ::= name\n(new)   default-module-spec ::= module-spec\n(new)   module-spec ::= module-name [ ( module-actual-list ) ]\n                    OR  module-dummy-name [ ( module-actual-list ) ]\n(new)   module-actual ::= [ module-dummy-name = ] module-spec\n                      OR  [ module-dummy-name = ] use-name\n\n(R1409) use-stmt ::= USE [ [ , module-nature ] :: ] module-spec [ , rename-list ]\n                 ::= USE [ [ , module-nature ] :: ] module-spec, ONLY: [ only-list ]\n\n\nChanges to text\n\nC1404: \"module-name shall be the name of an intrinsic module\" shall be changed\nto read \"the module-spec shall have a module-name that is the name of an intrinsic module\"\nC1405: \"module-name shall be the name of a nonintrinsic module\" shall be changed\nto read \"the module-spec shall have a module-name that is the name of a nonintrinsic module\"\n14.2.2 paragraph 3, change \"If the module-name is the name of both...\" to read\n\"If the module-spec is a module-name without a module-actual-list, and\nthat module-name is the name of both...\".\n\nAdditional constraints\n\n(R1405) The module-dummy-names of a module-dummy-list shall be pairwise distinct.\n(R1405) In a module-dummy-list, a module-dummy-name in a default-module-spec shall\nbe the module-dummy-name of a previous module-dummy in the same list.\n(The usual positional and keyword-matching association scheme of Fortran applies\nbetween a module-dummy-list and a module-actual-list, and will be described in\nfull later without surprises.)\n\nInstantiation\n\nA module with no module-dummy-list constitutes its own instantiation.\nFor each distinct instantiation of a module, there is corresponding instantiation\nof each of its submodules.\nA module-spec in a use-stmt constitutes a reference to an instantiation of a module.\nIn the body of each distinct instantiation of the module, and in each of its submodules,\nwherever one of its module-dummy-names appears in a module-spec or as a use-name,\nthe module-dummy-name is replaced with the associated module-actual in the\nmodule-actual-list of the module-spec that instantiates the module, or else the\ndefault-module-spec of the module-dummy when the module-dummy-name is not\nassociated with a module-actual.\nA module instantiation shall not reference itself directly or indirectly.\n\nExample\n\n  MODULE LISTS(MOD, T)\n    USE MOD, ONLY: TYPE => T\n    TYPE :: LIST\n      TYPE(TYPE) :: VALUE\n      TYPE(LIST), ALLOCATABLE :: LINK\n     CONTAINS\n      PROCEDURE :: EMPTY, LENGTH, PUSH_HEAD, BEGIN, NEXT\n    END TYPE LIST\n    INTERFACE\n      MODULE LOGICAL FUNCTION EMPTY(L)\n        TYPE(LIST), ALLOCATABLE, INTENT(IN) :: L\n      END FUNCTION EMPTY\n      MODULE INTEGER FUNCTION LENGTH(L)\n        TYPE(LIST), ALLOCATABLE, INTENT(IN) :: L\n      END FUNCTION LENGTH\n      MODULE SUBROUTINE PUSH_HEAD(L, X)\n        TYPE(LIST), ALLOCATABLE, INTENT(IN OUT) :: L\n        TYPE(TYPE), INTENT(IN) :: X\n      END SUBROUTINE PUSH_HEAD\n      MODULE FUNCTION BEGIN(L)\n        TYPE(LIST), ALLOCATABLE, INTENT(IN) :: L\n        TYPE(LIST), POINTER :: BEGIN\n      END FUNCTION BEGIN\n      MODULE FUNCTION NEXT(P)\n        TYPE(LIST), POINTER, INTENT(IN OUT) :: P\n        TYPE(LIST), POINTER :: NEXT\n      END FUNCTION NEXT\n    END INTERFACE\n  END MODULE LISTS\n\n  SUBMODULE(LISTS) IMPLEMENTATIONS\n   CONTAINS\n    MODULE PROCEDURE EMPTY\n      EMPTY = .NOT. ALLOCATED(L)\n    END PROCEDURE EMPTY\n    MODULE PROCEDURE LENGTH\n      LENGTH = 0\n      BLOCK\n        TYPE(LIST), POINTER :: P\n        P => L%BEGIN()\n        DO WHILE (ASSOCIATED(P))\n          LENGTH = LENGTH + 1\n          P => P%NEXT()\n        END DO\n      END BLOCK\n    END PROCEDURE LENGTH\n    MODULE PROCEDURE PUSH_HEAD\n      TYPE(LIST), ALLOCATABLE :: NEW\n      ALLOCATE(NEW)\n      NEW%VALUE = X\n      IF (.NOT. L%EMPTY()) CALL MOVE_ALLOC(L, NEW%LINK)\n      CALL MOVE_ALLOC(NEW, L)\n    END PROCEDURE PUSH_HEAD\n    MODULE PROCEDURE BEGIN\n      IF (L%EMPTY()) THEN\n        BEGIN => NULL()\n      ELSE\n        BEGIN => L\n      END IF\n    END PROCEDURE BEGIN\n    MODULE PROCEDURE NEXT\n      IF (ASSOCIATED(P)) THEN\n        NEXT => P%LINK\n      ELSE\n        NEXT => NULL()\n      END IF\n    END PROCEDURE NEXT\n  END SUBMODULE IMPLEMENTATIONS\n\n  MODULE TYPES\n    TYPE :: T1\n      INTEGER :: FIELD\n    END TYPE\n  END MODULE\n\n  PROGRAM DEMO\n    USE TYPES\n    USE LISTS(TYPES, T1), T1_LIST => LIST\n    TYPE(T1_LIST), ALLOCATABLE :: T1S\n    CALL T1S%PUSH_HEAD(T1(666))\n    PRINT *, T1S%LENGTH()\n  END PROGRAM"
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 19:43:05+00:00",
                    "text": "I proposed a general facility for parameterized modules in 2004. The J3 paper was 04-383r1. I think it does what Klausler asked for. It does what Magne Haveraaen asked for in Tokyo.\n04-383r1.pdf"
                },
                {
                    "user": "klausler",
                    "date": "2021-03-09 22:04:30+00:00",
                    "text": "A variation on this idea seems attractive to me, so I'll jot it down here rather than forget it.\nFortran can support genericity with its current modules by using them as paradigms.  For example, to define a generic linked list container, one would first write a model implementation with a fairly empty derived type for the payload in each node.  This module would be compilable and testable, and would fully describe all of the requirements on the payload type.\nThen, to build a linked list of some specific type, one would reinstantiate the paradigmatic module with a type substitution.  The replacement type must support all of the interfaces published for the payload type in the paradigm, and this would be checked.\nSubstitution of types and parameters (or just their values) in paradigmatic modules would solve the most pressing use cases for generic programming that have been put forward, and would avoid a need for \"requirements\" or \"concepts\"."
                }
            ]
        },
        {
            "number": 73,
            "user": "klausler",
            "date": "2019-11-05 18:07:40+00:00",
            "title": "The default KIND of some size/position intrinsic functions should not be default integer",
            "text": "Fortran mandates that the default kind of INTEGER occupy one numeric storage unit; so does the default kind of REAL.  In 2019, default REAL is expected to be IEEE-754 single precision.  Consequently, the default kind of INTEGER ends up having to be 32 bits wide.\nThis is a problem for real applications using arrays that are (or can be) very large, as the default KIND= parameter values for intrinsic functions like SIZE, SHAPE, LBOUND, UBOUND, FINDLOC, MAXLOC, and MINLOC (*) are all defined to be the default kind of INTEGER.  One must determine the proper kind of \"long\" integer (or assume it) and remember to specify that KIND= on every use of these intrinsic functions in order to ensure that they work with large arrays.\nI propose that the default result kinds of these intrinsic functions be redefined to be processor-dependent, so that a processor supporting large memories can do the obvious right thing.\n(*) this list is probably incomplete; maybe it should include LEN but that's less of an issue and it would be the hardest to change",
            "is_open": false,
            "labels": [
                "duplicate"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-05 18:08:15+00:00",
                    "text": "Duplicate of #72."
                }
            ]
        },
        {
            "number": 72,
            "user": "klausler",
            "date": "2019-11-05 18:07:25+00:00",
            "title": "The default KIND of some size/position intrinsic functions should not be default integer",
            "text": "Fortran mandates that the default kind of INTEGER occupy one numeric storage unit; so does the default kind of REAL.  In 2019, default REAL is expected to be IEEE-754 single precision.  Consequently, the default kind of INTEGER ends up having to be 32 bits wide.\nThis is a problem for real applications using arrays that are (or can be) very large, as the default KIND= parameter values for intrinsic functions like SIZE, SHAPE, LBOUND, UBOUND, FINDLOC, MAXLOC, and MINLOC (*) are all defined to be the default kind of INTEGER.  One must determine the proper kind of \"long\" integer (or assume it) and remember to specify that KIND= on every use of these intrinsic functions in order to ensure that they work with large arrays.\nI propose that the default result kinds of these intrinsic functions be redefined to be processor-dependent, so that a processor supporting large memories can do the obvious right thing.\n(*) this list is probably incomplete; maybe it should include LEN but that's less of an issue and it would be the hardest to change",
            "is_open": true,
            "labels": [
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-05 18:20:54+00:00",
                    "text": "I wasn't aware that size(A) will return an incorrect number if A is larger than 4GB. In fact, it already fails for larger than 2GB, here is an example with gfortran that fails:\nprogram test_size\nreal, allocatable :: A(:)\nallocate(A(3000000000_16))\nA = 1\nprint *, size(A)\nprint *, size(A, kind=16)\nend\nWhen compiled and executed, it prints:\n -1294967296\n 3000000000\n\nThe array gets correctly allocated and assigned to, but the default size(A) fails to return the correct result (it returns a wrapped around 32 bit integer value). The size(A, kind=16) works correctly.\nThis needs to be fixed."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-05 18:44:12+00:00",
                    "text": "This is indeed critical as these kind of mistakes easily go unnoticed.\n\nwt., 5 lis 2019, 19:20 u\u017cytkownik Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142:\n\u2026\n I wasn't aware that size(A) will return an incorrect number (or fails?)\n if A is larger than 4GB. In fact, it already fails for larger than 2GB,\n here is an example with gfortran that fails:\n\n program test_sizereal, allocatable :: A(:)allocate(A(3000000000_16))\n A = 1print *, size(A)print *, size(A, kind=16)\n end\n\n When compiled and executed, it prints:\n\n  -1294967296\n  3000000000\n\n The array gets correctly allocated and assigned to, but the default\n size(A) fails to return the correct result (it returns a wrapped around\n 32 bit integer value). The size(A, kind=16) works correctly.\n\n This needs to be fixed.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#72?email_source=notifications&email_token=AC4NA3I5S2EQLQ5UVWUPJ6DQSG2QPA5CNFSM4JJGCR32YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDDZW3Y#issuecomment-549952367>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3K5G7LTZUCAEE5XSUTQSG2QPANCNFSM4JJGCR3Q>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 16:15:20+00:00",
                    "text": "Please see #78 with a proposal by UK national body from year 2013 that I think had addressed the concern in this thread quite well."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-11 17:44:44+00:00",
                    "text": "Please see #78 with a proposal by UK national body from year 2013 that I think had addressed the concern in this thread quite well.\n\nThere's some overlap, but it's not the same essential problem.  Whether or not the program is able to define the default kinds of intrinsic types, the default kinds of the results of the particular intrinsic functions related to size should not be the default kind of INTEGER."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-11 19:39:52+00:00",
                    "text": "This is why these intrinsics now have an optional KIND= argument. The problem with changing the default behavior is that it would break some existing programs, which is almost always a killer.\nOne might think that implementations would start shifting default integer from 32 to 64 bits much the way that it changed from 16 to 32 bits in the late 70s. (I am ignoring old platforms with 36, 48 and 60-bit word sizes.)  But then you run into the issue @klausler originally noted that this would also change the size of default REAL, and I don't think people are ready for that.\nOffhand, I am not in favor of any proposal that adds a new implicit behavior. I understand that dealing with constants of non-default kind can be messy, and things such as SIZE can be problematic, but the programmer already needs to be aware when an array might exceed a default integer extent, and use larger kind integers throughout the code.\nI know this general topic was discussed when the KIND arguments were added, but I can't find details in the 2014 papers."
                },
                {
                    "user": "certik",
                    "date": "2019-11-11 19:48:44+00:00",
                    "text": "I know this general topic was discussed when the KIND arguments were added, but I can't find details in the 2014 papers.\n\nTo fix this particular problem, that the discussion around a particular new feature gets lost, I plan to capture any such future (technical) discussion that happens in person at the committee and document it here in the relevant issues, so that the wider community as well as committee members can in the future reference the arguments that were made, and thus build upon the previous work that was done."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-11 19:57:40+00:00",
                    "text": "I understand full well that those intrinsics have KIND= arguments.  Unfortunately, a program using large arrays must specify an adequately-sized kind value for every call to these intrinsics, and ensure that the libraries into which it calls are also free of any missing or inadequate KIND= argument.\nAllowing implementations to ability to determine the default value of these KIND= arguments may lead to warnings and errors when codes that can't handle large arrays are recompiled.  That seems preferable to mysterious and hard-to-debug crashes, and an implementation needs to pick either the \"emit a message\" or \"crash mysteriously at runtime\" option when compiling for large-memory targets; the codes that will fail have not been \"broken\" by the compiler either way, and the former seems more conformable with a desire to promote portability."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-11 20:01:24+00:00",
                    "text": "I fully agree with Peter here. Backwards compatibility does not seem a good\nargument in this case. Dangerous silent errors do more harm than possibly\nbreaking one old code.\n\npon., 11 lis 2019, 20:57 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n I understand full well that those intrinsics have KIND= arguments.\n Unfortunately, a program using large arrays must specify an\n adequately-sized kind value for every call to these intrinsics, and ensure\n that the libraries into which it calls are also free of any missing or\n inadequate KIND= argument.\n\n Allowing implementations to ability to determine the default value of\n these KIND= arguments may lead to warnings and errors when codes that\n can't handle large arrays are recompiled. That seems preferable to\n mysterious and hard-to-debug crashes, and an implementation needs to pick\n either the \"emit a message\" or \"crash mysteriously\" option when compiling\n for large-memory targets; the codes that will fail have not been \"broken\"\n by the compiler either way, and the former seems more conformable with a\n desire to promote portability.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#72?email_source=notifications&email_token=AC4NA3KWBRG6LO5SZZP55XLQTG2LLA5CNFSM4JJGCR32YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDX54UQ#issuecomment-552590930>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3JUBZCZ77LEZKY4PQLQTG2LLANCNFSM4JJGCR3Q>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-11 23:06:40+00:00",
                    "text": "@klausler wrote:\n\n.. the default kinds of the results of the particular intrinsic functions related to size should not be the default kind of INTEGER.\n\nThe way things are, it might be too late now, user definable kinds like in the UK proposal appear the only option for future programmers if they seek certain brevity and cleanliness along with safety in their codes.\nWG5 is unlikely to ever agree to a change to intrinsics such as SIZE as suggested in the original post, but it's fathomable WG5 may proceed with the UK proposal with user definable default KINDs at some stage."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 00:04:13+00:00",
                    "text": "@klausler wrote:\n\n.. the default kinds of the results of the particular intrinsic functions related to size should not be the default kind of INTEGER.\n\nThe way things are, it might be too late now, user definable kinds like in the UK proposal appear the only option for future programmers if they seek certain brevity and cleanliness along with safety in their codes.\nWG5 is unlikely to ever agree to a change to intrinsics such as SIZE as suggested in the original post, but it's fathomable WG5 may proceed with the UK proposal with user definable default KINDs at some stage.\n\nI repeat, these features are solving largely distinct problems.  If the UK proposal were adopted, there would still be a problem.\nI would hope that WG5 would approve a change to the specification of the default kinds of the results of these intrinsic functions; that would allow the f18 compiler to remove an item from its documented list of \"intentional violations of the standard\".  Standardized or not, it seems like the right thing to do in an implementation for modern targets."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-12 15:56:08+00:00",
                    "text": "@klausler wrote:\n\n..\nI repeat, these features are solving largely distinct problems. If the UK proposal were adopted, there would still be a problem.\nI would hope that WG5 would approve a change to the specification of the default kinds of the results of these intrinsic functions; that would allow the f18 compiler to remove an item from its documented list of \"intentional violations of the standard\". Standardized or not, it seems like the right thing to do in an implementation for modern targets.\n\nWell, some might argue what f18 is trying to address is also \"solving largely distinct problems\" particularly with SIZE intrinsic since it now includes the optional KIND option.  And if  f18 is adopting \"intentional violations of the standard\", then there must be users out there concerned about this, those who rather prefer a new processor such as f18 to adopt strict consistency with the standard by default.  Now of course when an implementation feels strongly about certain stipulations in the standard, it can separately offer its users an alternate path forward,say an option to pursue another dialect e.g., how GCC/gfortran does with -std='gnu'."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 16:07:43+00:00",
                    "text": "One workaround can be that in Debug mode the compiler can emit code to check the size of the array at runtime and produce a warning (or error if instructed) if a size with incorrect kind option is being used, so that at least users have good means to ensure their code is not broken.\nBut as @sblionel suggested, even if you loop over the array with a default integer, the code will still break, so the user must be aware of this anyway. But a compiler (in Debug mode) can check this and tell users to fix their code (by adding the appropriate kind)."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 16:17:50+00:00",
                    "text": "One workaround can be that in Debug mode the compiler can emit code to check the size of the array at runtime and produce a warning (or error if instructed) if a size with incorrect kind option is being used, so that at least users have good means to ensure their code is not broken.\nBut as @sblionel suggested, even if you loop over the array with a default integer, the code will still break, so the user must be aware of this anyway. But a compiler (in Debug mode) can check this and tell users to fix their code (by adding the appropriate kind).\n\nIt's useful to the user to detect potential problems in their code before executtion time, when possible."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 16:23:32+00:00",
                    "text": "It's useful to the user to detect potential problems in their code before executtion time, when possible.\n\nThe code can read the size from an input file, in which case it will not be known until runtime. The only way that I can think of to give a warning at compile time is to keep track of how the array is allocated, and if at any point it is allocated using, say, integer(int64) (even if the value is read from an input file), then it will give warnings to all usages of size that do not have kind=int64 with it, as well as all integers used for iteration over the array. The only possible issue is if the array gets allocated in code that the compiler does not have access to. Otherwise it might actually be possible to check this at compile time."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 16:34:19+00:00",
                    "text": "In C size_t is 8 bytes on x86_64.\n#include <stdio.h>\n#include <stddef.h>\n\nint main() { size_t a; printf(\"sizeof(a) = %d\\n\", sizeof(a)); }\noutput: sizeof(a) = 8\nThe fact is, backwards compatibility is a poor reasoning here. No decently written code will break just because size returns 8 byte instead of 4 byte integer. And understanding backwards compatibility as \"all codes that previously worked must still work\" is inherently wrong with Fortran language giving so much forgiveness for poor coding practices for years (which was recently pointed out in one of the publications)."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 16:39:17+00:00",
                    "text": "And understanding backwards compatibility as \"all codes that previously worked must still work\" is inherently wrong with Fortran language giving so much forgiveness for poor coding practices for years (which was recently pointed out in one of the publications).\n\nCan you please point me to the publication you are referring to?\nThat's one of the great strengths of Fortran that old code continues running and does not require a massive rewrite like Python 3 forced on all Python 2 code. So we want to keep that feature. But there might be a way to get what we want without breaking old code."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 16:59:12+00:00",
                    "text": "It was mentioned on this github but it was a while ago. I need a moment to\nfind it. (Maybe somebody will remember what it was faster.)\n\nI see it mostly as a weakness. I still see common blocks, data statements\nand gotos in recently developed codes which I think is terrible. But we\nwill clearly disagree on this so let's not discuss this here. ;)\n\nwt., 12 lis 2019 o 17:39 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n And understanding backwards compatibility as \"all codes that previously\n worked must still work\" is inherently wrong with Fortran language giving so\n much forgiveness for poor coding practices for years (which was recently\n pointed out in one of the publications).\n\n Can you please point me to the publication you are referring to?\n\n That's one of the great strengths of Fortran that old code continues\n running and does not require a massive rewrite like Python 3 forced on all\n Python 2 code. So we want to keep that feature. But there might be a way to\n get what we want without breaking old code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#72?email_source=notifications&email_token=AC4NA3JYP6UVYJQQKDD4VYDQTLL3NA5CNFSM4JJGCR32YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOED236OI#issuecomment-552976185>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3MLRC25YCLT7HF7IS3QTLL3NANCNFSM4JJGCR3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 17:29:27+00:00",
                    "text": "I still see common blocks, data statements and gotos in recently developed codes which I think is terrible.\n\nI agree with you those should not be used in new codes. But I think compilers should still support it, so that old codes continue to work."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 18:23:28+00:00",
                    "text": "It's useful to the user to detect potential problems in their code before executtion time, when possible.\n\nThe code can read the size from an input file, in which case it will not be known until runtime. The only way that I can think of to give a warning at compile time is to keep track of how the array is allocated, and if at any point it is allocated using, say, integer(int64) (even if the value is read from an input file), then it will give warnings to all usages of size that do not have kind=int64 with it, as well as all integers used for iteration over the array. The only possible issue is if the array gets allocated in code that the compiler does not have access to. Otherwise it might actually be possible to check this at compile time.\n\nWhat we can warn about at compilation time are things like DO J=1,SIZE(A) when the 64-bit size value must be truncated to a 32-bit default-kind integer J."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-17 12:34:24+00:00",
                    "text": "I have some questions:\n\nAren't the dimensions of arrays already part of current array descriptors?  If that's the case, would it be that difficult / a bad idea that the standard demands in the definition of intrinsic procedures that if the kind of the result of a call to size will not represent correctly the value that size would return, the runtime aborts?\nYes, this would break some existing programs, but only those that are poorly designed:\nprogram p\nuse, intrinsic :: iso_fortran_env\nlogical :: big\nreal, allocatable :: A(:)\nread(*,*) big\nif (big) then\n   allocate(A(2_int64**40_int64))\nelse\n   allocate(A(1))\nend if\nwrite(*,*) size(A)\nend program\nIf the call to size above is legal Fortran 2018, it is at least a bad idea (if (big) the result is processor dependent?).\nRather than changing the default kind of the result of these functions to be processor dependent as you propose (or to the integer kind with the largest decimal exponent range, which the standard requires to be at least 18), would it be possible to remove in the near future the requirement that default integer, default real, and default logical have the same length?  My understanding was that this is mainly a requirement to support common blocks, and they are already obsolescent."
                }
            ]
        },
        {
            "number": 71,
            "user": "jacobwilliams",
            "date": "2019-11-05 03:48:56+00:00",
            "title": "Fortran Committee",
            "text": "I think it would be helpful if the committee produced some documentation on:\n\nWhat exactly is the Fortran committee?\nHow does it currently work?\nHow does it relate to the ISO committee? Are there two committees? Why is that?\nHow does one join either or both of these committees?",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-05 05:09:27+00:00",
                    "text": "Fortran is an ISO standard. ISO has an international committee (https://wg5-fortran.org/), and national bodies. The US national body is (https://j3-fortran.org/).\nMost of the work seems to happen in the J3 committee (the US national body).\nTo join the committee, simply join the J3 mailinglist, email Steve Lionel and start attending the meetings. Anybody can join, and you would be an observer. In order to be able to vote, you have to be part of some organization that is part of ISO (and pays the fees) and you become their representative.\nI agree it would be nice to document this in the README of this repository, or elsewhere."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-11 19:48:31+00:00",
                    "text": "https://software.intel.com/en-us/blogs/2011/09/22/the-real-doctors-of-fortran touches on this.\nI am not the contact for J3, that would be Dan Nagle. The rules from INCITS (which manages US standards committees on behalf of ANSI) say that you may attend only twice as an \"observer\" - to attend more you have to join. If you want to join as your own member, as I do now, you have to pay INCITS each year, currently about $1300 for an individual. Or, you may get your employer or other organization to pay the fee. But many J3 members are \"alternates\" of primary members, and that is free. Generally we're always glad to have new members and will find someone to sponsor you as an alternate if needed. The caveat is that alternates don't get to vote in plenary if the primary member is present.\nAs for ISO, becoming a member of J3 automatically gets you an ISO membership (which has no fees.)"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 16:23:06+00:00",
                    "text": "I should also add that anyone can join the J3 mailing list - there's no relationship with membership. All we ask is that you have an interest in Fortran. Just go to https://mailman.j3-fortran.org/mailman/listinfo/j3 and fill in the join request. It will then be reviewed by list administrators, mainly to keep out spammers."
                },
                {
                    "user": "marshallward",
                    "date": "2020-01-03 17:05:23+00:00",
                    "text": "Should we consider closing this issue and moving the information to the wiki?  It's not a language proposal, but it's invaluable information."
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 22:48:28+00:00",
                    "text": "@marshallward yes, let's move this into the Wiki, or even README. After that we can close this."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2019-11-04 23:25:36+00:00",
            "title": "Add assert statement to Fortran",
            "text": "One very common use case for a preprocessor is a custom ASSERT macro, that is empty in Release mode, but in Debug mode it checks the condition and prints out the filename and line number. As discussed in #65, Fortran is moving away from a preprocessor, and so by adding an assert statement into the language would eliminate one more use case for a preprocessor.\nFrom a user perspective, the syntax can be something like:\ninteger :: i\ni = 5\nassert(i == 5)\nIn Release mode, the assert would do nothing, in Debug mode the assert would evaluate the condition (e.g., i == 5) and if it fails, it would print a nice stacktrace. This would be a much better behavior than the current practice, where typically the ASSERT macro only prints a filename+line, but not a full stacktrace, so it can be hard to figure out why it happened.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2019-11-04 23:49:33+00:00",
                    "text": "Assert has been proposed before (https://j3-fortran.org/doc/year/04/04-376.txt)  This was before my time on the committee, but I gather from what evidence I can find that there was not sufficient interest to move it forward. I have seen it implemented as a vendor extension."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 00:12:41+00:00",
                    "text": "@sblionel thanks! I would like for each idea at this GitHub repository to eventually have a technical response from the committee why it was rejected. And if there is no technical reason, just a lack of sufficient interest at some point in the past, then I think we can revisit such an idea. For example in this particular case in light of #65 we can argue that rather than standardizing a preprocessor, let's improve Fortran so that the preprocessor is not needed (as much)."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 00:37:10+00:00",
                    "text": "ASSERT is also a potential optimization aid:\n  ASSERT (K >= 0)\n  DO J = 1, N\n    A(J) = A(J + K)  ! known to not cause a data dependence cycle\n  END DO"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 16:45:38+00:00",
                    "text": "Probably, ASSERT should not be used for optimization. As evaluation of an assert could be time consuming (imagine ASSERT(all(big_array > 0)), I'd wish that it is not considered when the code is compiled for production. Therefore, it could even be a pre-processor feature instead of a compiler feature (see also #65)."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 16:47:47+00:00",
                    "text": "@aradi the proposal here, as I understand it, is that ASSERT(all(big_array > 0)) will do nothing in Release mode. But I do not understand your argument why the compiler couldn't still use it for optimization."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-12 16:55:51+00:00",
                    "text": "DEC implemented ASSERT as follows: It is a declaration from the programmer to the optimizer that the given condition is met. The optimizer can then use that information. A separate option tells the compiler to generate run-time code to check that assertion, so you can choose to do that or not.\nIntel Fortran currently supports an ASSUME directive that provides information, but there is not currently any run-time code associated with that."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 17:01:06+00:00",
                    "text": "@certik What happens, if in production mode (for whatever buggy reasons) the criteria is not met. The run-time code does not check for it, but it was taken into account during the optimization. Then the optimized code may produce results which are hard to understand/debug. But on the other hand, probably you can say, it is the programmers fault..."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 17:24:31+00:00",
                    "text": "@certik What happens, if in production mode (for whatever buggy reasons) the criteria is not met. The run-time code does not check for it, but it was taken into account during the optimization. Then the optimized code may produce results which are hard to understand/debug. But on the other hand, probably you can say, it is the programmers fault...\n\nYes, it would give wrong results in Release mode, but not in Debug mode. In exactly the same way as you get wrong results if you go out of bounds (in Release mode). But in Debug mode, out of bounds, as well as the assert conditions are all checked."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 20:19:36+00:00",
                    "text": "@certik OK, that's a good point. It makes sense, I agree, and would be consistent with current compiler behavior as well."
                },
                {
                    "user": "rweed",
                    "date": "2020-01-03 14:49:09+00:00",
                    "text": "If we can't have an ASSERT statement, I would be in favor of a standard assert subroutine. You can then use the pre-processor to create a macro ASSERT (or ERROR_ABORT) command. Here is my version that I \"borrowed\" from the FTL project\n! Macros for assertions\n#ifdef GFORTRAN\n#define ASSERT(x) call assert(x,\"x\",FILE,LINE)\n#define ERROR_ABORT(x,y) call assert(x,\"x\",FILE,LINE,y)\n#else\n#define ASSERT(x) call assert(x,#x,FILE,LINE)\n#define ERROR_ABORT(x,y) call assert(x,#x,FILE,LINE,y)\n#endif\nERROR_ABORT just adds a logical to signal if you want to do a hard aborut (STOP,\nERROR_STOP) or continue after printing an error message"
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 14:56:33+00:00",
                    "text": "@rweed I think this would be a perfect addition to stdlib. Can you please open up an issue there? We already have a minimal assert subroutine there:\nhttps://github.com/fortran-lang/stdlib/blob/924ee5459fab5c9fa4deb30e75c12c00b2864598/src/stdlib_experimental_error.f90#L8\nSo let's extend it, and then let's discuss the macros also, per your comment."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-01 21:09:05+00:00",
                    "text": "C++ 2020 and Ada (2012?) defined three statements intended to make \"Design by Contract\" (DbC) an intrinsic part of the language. In C++ these three statements define the attributes: requires, asserts, and ensures, where requires and ensures are in effect assert statements that are executed upon subprogram entry and exit respectively. requires, in effect, defines the pre-conditions the caller must meet for correct operation of the subprogram, and ensures the post-conditions the caller can expect to be satisfied by the subprogram if it has operated correctly.\nI have written a draft proposal for the incorporation of DbC in Fortran 202y. It, of course, includes an ASSERT statement as part of the proposal. If there is interest I can upload the proposal to my branch of the proposals directory. Once there, given the problems with my last PR, where it got added on to an existing PR, I don't know if I should do a PR or have someone else do the PR for me."
                },
                {
                    "user": "certik",
                    "date": "2020-08-01 21:11:30+00:00",
                    "text": "@wclodius2  Yes, please upload it here. Try to create a new branch and put it there. Once you learn the process, it becomes simple. I can help."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-01 21:39:12+00:00",
                    "text": "GitHub doesn\u2019t let me do an additional fork on https://github.com/wclodius2/fortran_proposals <https://github.com/wclodius2/fortran_proposals>, but does let me do a fork on the original https://github.com/j3-fortran/fortran_proposals <https://github.com/j3-fortran/fortran_proposals>. Should I fork the original again?\n\u2026\n On Aug 1, 2020, at 3:11 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> Yes, please upload it here. Try to create a new branch and put it there. Once you learn the process, it becomes simple. I can help.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#70 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDORJEOLRGNHAYVX7WHDR6SAI7ANCNFSM4JI3NFHQ>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-02 16:48:16+00:00",
                    "text": "FWIW in not letting me fork on my repository it tells me \"Cannot fork because you own this repository and are not a member of any organization.\""
                },
                {
                    "user": "certik",
                    "date": "2020-08-04 14:53:32+00:00",
                    "text": "@wclodius2 here is how you do it. You already have a fork at GitHub (https://github.com/wclodius2/fortran_proposals) so that is all you need. Let's start from scratch on your computer, that way things will work exactly as I write them here. You will see that once you learn this workflow, you can apply it to any other project at GitHub.\nGo to some place on your computer where you want to have the fortran_proposals directory. Then initialize it as follows:\ngit clone https://github.com/j3-fortran/fortran_proposals\ncd fortran_proposals\ngit remote add william git@github.com:wclodius2/fortran_proposals.git\n\nThen create a branch assert (you can name it any other way) and put your document in:\ngit checkout -b assert\n# copy your document to proposals/assert, let's call it `assert.pdf` (I don't know what you call it)\ngit add proposals/assert/assert.pdf\ngit commit # an editor will open, write a commit message\ngit push william\n\nThis will push the assert branch into your fork, and it will also give you a link that will allow you to submit the Pull Request (PR).\nLet me know if this works, and if something does not work, I'll help."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-04 16:21:38+00:00",
                    "text": "Before I do anything irreversible what is the meaning of <name> in\ngit remote add <name> <url>\nwhere you have put william for <name>, i.e., is it arbitrary or should it be my user name on my computer or something else?\n\u2026\n On Aug 4, 2020, at 8:53 AM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> here is how you do it. You already have a fork at GitHub (https://github.com/wclodius2/fortran_proposals <https://github.com/wclodius2/fortran_proposals>) so that is all you need. Let's start from scratch on your computer, that way things will work exactly as I write them here. You will see that once you learn this workflow, you can apply it to any other project at GitHub.\n\n Go to some place on your computer where you want to have the fortran_proposals directory. Then initialize it as follows:\n\n git clone https://github.com/j3-fortran/fortran_proposals\n cd fortran_proposals\n git remote add william ***@***.***:wclodius2/fortran_proposals.git\n Then create a branch assert (you can name it any other way) and put your document in:\n\n git checkout -b assert\n # copy your document to proposals/assert, let's call it `assert.pdf` (I don't know what you call it)\n git add proposals/assert/assert.pdf\n git commit # an editor will open, write a commit message\n git push william\n This will push the assert branch into your fork, and it will also give you a link that will allow you to submit the Pull Request (PR).\n\n Let me know if this works, and if something does not work, I'll help.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#70 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOTH72WGDCOILTM5PY3R7AOH3ANCNFSM4JI3NFHQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-08-04 16:25:21+00:00",
                    "text": "The meaning of <name> is an arbitrary identifier of your choosing that you then reference in git push. When you do git remote -v, it will show what is setup. And you can always rename <name> using git remote rename william something_else. Here is how I have it setup for myself:\nondrej@pn1707483:~/repos/fortran_proposals(master)$ git remote -v\nondrej\tgit@github.com:certik/fortran_proposals (fetch)\nondrej\tgit@github.com:certik/fortran_proposals (push)\norigin\thttps://github.com/lfortran/fortran_proposals (fetch)\norigin\thttps://github.com/lfortran/fortran_proposals (push)\n\nWhich is analogous to what I suggested for you. If I add william to mine, see what happens:\nondrej@pn1707483:~/repos/fortran_proposals(master)$ git remote add william git@github.com:wclodius2/fortran_proposals.git\nondrej@pn1707483:~/repos/fortran_proposals(master)$ git remote -v\nondrej\tgit@github.com:certik/fortran_proposals (fetch)\nondrej\tgit@github.com:certik/fortran_proposals (push)\norigin\thttps://github.com/lfortran/fortran_proposals (fetch)\norigin\thttps://github.com/lfortran/fortran_proposals (push)\nwilliam\tgit@github.com:wclodius2/fortran_proposals.git (fetch)\nwilliam\tgit@github.com:wclodius2/fortran_proposals.git (push)\n\nNow I can pull branches from you using git fetch william. So that's the idea."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-04 18:29:56+00:00",
                    "text": "On the\ngit push william\nI get\nThe authenticity of host 'github.com (140.82.114.3)' can't be established.\nRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com,140.82.114.3' (RSA) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n\u2026\n On Aug 4, 2020, at 8:53 AM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> here is how you do it. You already have a fork at GitHub (https://github.com/wclodius2/fortran_proposals <https://github.com/wclodius2/fortran_proposals>) so that is all you need. Let's start from scratch on your computer, that way things will work exactly as I write them here. You will see that once you learn this workflow, you can apply it to any other project at GitHub.\n\n Go to some place on your computer where you want to have the fortran_proposals directory. Then initialize it as follows:\n\n git clone https://github.com/j3-fortran/fortran_proposals\n cd fortran_proposals\n git remote add william ***@***.***:wclodius2/fortran_proposals.git\n Then create a branch assert (you can name it any other way) and put your document in:\n\n git checkout -b assert\n # copy your document to proposals/assert, let's call it `assert.pdf` (I don't know what you call it)\n git add proposals/assert/assert.pdf\n git commit # an editor will open, write a commit message\n git push william\n This will push the assert branch into your fork, and it will also give you a link that will allow you to submit the Pull Request (PR).\n\n Let me know if this works, and if something does not work, I'll help.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#70 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOTH72WGDCOILTM5PY3R7AOH3ANCNFSM4JI3NFHQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-08-04 19:03:11+00:00",
                    "text": "That means your ssh key is not at GitHub (I assume it already was there). All you need to do is to create an ssh key:\nssh-keygen\n\nand copy ~/.ssh/id_rsa.pub (assuming you are on linux) to your GitHub profile: https://github.com/settings/keys"
                }
            ]
        },
        {
            "number": 69,
            "user": "gronki",
            "date": "2019-11-03 22:57:57+00:00",
            "title": "formatted i/o improvements",
            "text": "In this example we will attempt to print a following message:\nimportant parameter =    1.5 for n =   4\ngiven by the format:\n(\"important parameter = \", f6.1, \" for n = \", i3)\nsyntax coloring in formats\nback in the times when space shuttles were still flying, you would do something along the lines of\n666 format (\"important parameter = \", f6.1, \" for n = \", i3)\nprint 666, 1.5, 4\nthis is terrible for many reasons, one of them is that 666 does not tell anything about the format (surely not anything good) and you might spend next 15 minutes looking for it in the code. Later, character literals were allowed as formats, which brought us to the following:\nprint '(\"important parameter = \", f6.1, \" for n = \", i3)', 9.5, 11\nthis would be good if not the fact that github, like all text editor I've worked with, display the entire format in string color. If that was not bad enough, you need to use different kind of quotes inside the format than to enclose the character literal, and you have to remember which one you used.\nMy proposal is to introduce something to distinguish between format strings and other strings. Internally they could be handled the same, but text editors would be able to highlight .\n\nOption 1: use apostrophes ``. The downside is that they are difficult to distinguish from single quotes, but some languages (like MySQL) actually do use them. Alternatively, other characters could be used, like // (whatever doesn't conflict with already existing syntax). Example: \nprint `(\"important parameter = \", f6.1, \" for n = \", i3)`, 2.4, 3 \nprint /(\"important parameter = \", f6.1, \" for n = \", i3)/, 2.4, 3\nOption 2: revive format as \"function\". The downside is that its quite a long word and would not be very clear when used directly in print/write/read. Example: \ncharacter(len = *), parameter :: fmt = format(\"important parameter = \", f6.1, \" for n = \", i3)\nOption 3: use character prefix, similarly to z being used for hex numbers. The downside is that you still have to escape the quotes. Example: \nprint f'(\"important parameter = \", f6.1, \" for n = \", i3)', 2.4, 3\n\nYes, this is syntactic sugar, but it is something that compilers just need to allow (does not introduce new rules into the language) but makes life of the developers much easier.\nallow format without parethesis\nconsider the following:\nprint '(3i3)', 1, 2, 3, 4, 5\nOf course, the output will be\n  1  2  3\n  4  5\n\nNow, in 99% of the cases the repetition of the format will never occur as the number of arguments matches the number of format fields. Therefore, parethesis () only obfuscate the syntax. I propose the following format (currently invalid):\nprint '3i3', 1, 2, 3, 4, 5\n\nwould produce the output:\n  1  2  3\n\nIn that case, our example would be along the lines of\nprint '\"important parameter = \", f6.1, \" for n = \", i3', 9.5, 11\nprint /\"important parameter = \", f6.1, \" for n = \", i3/, 9.5, 11\n\nObviously, not all of them look very good, but there are many choices here that can be made to improve readability.\nallow character literals in input formats\nthis was discussed in comp.lang.fortran. Yet, I still think it is worth considering as it is a simple thing (also to implement) that would increase the functionality of the language.\nConsider the following code:\ninteger i\nreal f\n\n666 format (\"important parameter = \", f6.1, \" for n = \", i3)\n667 format (22x, f6.1, 9x, i3)\n\nread (*, *) f, i\nopen (33, status = 'scratch')\nwrite (33, 666) f, i\nrewind (33)\n! note: we have to use 667 format instead of 666\nread (33, 667) f, i\nclose(33)\n\nprint 666, f, i\n\nend\nIn action:\n$ gfortran test.f90 && ./a.out\n3 3\nimportant parameter =    3.0 for n =   3\n\nAs you can see, a whole new format 667 needs to be constructed to read the data written with format 666. That deprecates the whole idea of separating formatting from data. In this case, I have written a simple function that replaces any character literal within the format with Nx when N is the length of that literal. But I see no reason why this could not be handled internally by the compiler, reducing complexity of maintaining two formats (for write and read). There are two options how this could be done:\n\nOption 1: simply treat any character literal as Nx, where N is the length of that literal\nOption 2: read next N characters into a hidden variable and compare with what's in the format, throwing an error if these sequences do not match.\n\nExample in C:\n#include <string.h>\n#include <stdio.h>\n\nvoid main() {\n\nint d, r;\nconst char fmt1[] = \"wolf has %5d sheep\\n\";\nconst char fmt2[] = \"sheep is %5d kilos\\n\";\nchar buf[128];\n\nscanf(\"%d\", &d);\n\nsprintf(buf, fmt1, d);\n\nd = 0;\nr = sscanf(buf, fmt1, &d);\nprintf(fmt1, d);\nprintf(\"sscanf exited with %d\\n\", r);\n\nd = 0;\nr = sscanf(buf, fmt2, &d);\nprintf(fmt2, d);\nprintf(\"sscanf exited with %d\\n\", r);\n\n}\nresult:\n$ gcc test.c && ./a.out\n7\nwolf has     7 sheep\nsscanf exited with 1\nsheep is     0 kilos\nsscanf exited with 0\n\nAs you can see, when wrong format was used, sscanf returned 0 which means that 0 variables has been assigned their value.\nAs far as I know there should be no conflict with legacy code as character constants were not allowed in formats before.\nsummary\nThese are just a few ideas. I think there are many more possible simple improvements to Fortran formatted i/o, I think they can be collected in this thread and then the best ones extracted in clean and polished version.\nDominik",
            "is_open": true,
            "labels": [
                "Clause 13"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-04 19:07:08+00:00",
                    "text": "The outermost parentheses in CHARACTER formats are useful to determine the end of the format without having to skip over trailing blanks."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-04 19:29:40+00:00",
                    "text": "I am not sure if I understood you correctly. Did you mean that it's helpful\nwhen parsing format string?\n\npon., 4 lis 2019, 20:07 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n The outermost parentheses in CHARACTER formats are useful to determine\n the end of the format without having to skip over trailing blanks.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#69?email_source=notifications&email_token=AC4NA3K2G4OQ4ZPK7JCFJSLQSBXF3A5CNFSM4JINP5DKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDALSLI#issuecomment-549501229>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3IU7E3YDJ53ENZJBSTQSBXF3ANCNFSM4JINP5DA>\n ."
                }
            ]
        },
        {
            "number": 68,
            "user": "rweed",
            "date": "2019-11-03 21:57:07+00:00",
            "title": "Mods to support refactoring legacy codes to remove GO TO",
            "text": "Over the last few months, I've gone through the process of \"depastafying\" some old codes with the goal to remove all instances of GO TO. I did this because in many cases deconstructing the code was the only way I could figure what it was doing. In a large percentage of cases, the GO TOs are used in cases where we would today use IF-THEN-ELSE-ENDIF blocks and the modifications are straightforward. In other cases where you have interlacing branch-backwards, branch-forward GO TOs that iterate through blocks of code, I've found that combinations of unindexed DO, the BLOCK construct and internal subroutines are needed. Finally, the third most frequent use of GO TOs is to jump out of an iteration directly to output statements that print error or other information prior to exiting or stopping. Based on this experience, I've come up with a few modifications that I think would be helpful for those as foolish as me that feel the need to exteriminate GO TO in all its forms.\nFirst, I would like to propose a new construct I call an ITERATION that combines the functionality of BLOCK and unindexed DOs into a single construct. Currently, you can exit BLOCK but not CYCLE it. Unindexed DO allows both.  Just about every Fortran code ever written will have the\nfollowing code fragment;\nInteger :: reccount = 0\n10 Read(7, ('(A)'). ERR=20, END=30) buf\n! Translate buf to something\nreccount = reccount + 1\nGO TO 10\n20 Print something\nRETURN\n30 Print EOF message\n My mod would replace this with\nREADLOOP: ITERATION\n Integer :: ioval\n Integer :: reccount = 0\n Character(LEN=80) :: buffer\n Read(7, '(A)', IOSTAT=ioval) buffer\n If (ioval /= 0) EXIT READLOOP\n\nEnd ITERATION READLOOP\nThis is a simple example but the utility of it really becomes clear when you have to use a BLOCK statement around a large block of code just to handle exiting out of the enclosed BLOCK to some error handling code (usually selected by a SELECT CASE parameter set prior to exiting the BLOCK). I know that this replicates current capabilities by I've always felt that unindexed DO was a poor syntax choice  (one of many syntax \"crimes\" I believe were made by prior committes and have to date gone unpunished)\nIn addition, I would like to implement an EXIT_TO clause in all the named constructs (DO, BLOCK, etc) that allows you to jump directly to another named construct. The constraint is unlike GO TO it can only jump to the beginning of a block of code contained in another named construct\nExample\nDo i=1,n\nIf (error_detected) EXIT_TO error_output\nEnd Do\n! lots of lines of code inbetween\nerror_output: Block\n! process error code etc\nEnd Block error_output\nFinally, if we still have a need for statement labels, at least let them be fully alphanumeric instead of just numbers. This would make them a lot more readable. In particular, I would like to be able to assign a meaningful label to FORMAT statements that reflect what they are doing.\nExample\nWrite (7,threeReals) a, b, c\n\nthreeReals: Format(3(f10.5))\nI know you can do the same using character strings but for the target application( refactoring old code) I think this would be a useful feature.\nI can supply examples of real code where I've use both BLOCK and unindexed DO to remove GO TO if that would help\nAnother reason for proposing these is a hope that some enterprising young person in search of a Masters or Ph.D. thesis topic will develop some open source refactoring tools based on AI/Deep Learning that can remove Go Tos automatically. Maybe a Google Summer of Code project. These constructs would give the refactoring tools something to convert the old code into.\nJust some ideas based on recent experience",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-04 16:44:39+00:00",
                    "text": "@rweed, your statement, \"combinations of unindexed DO, the BLOCK construct and internal subroutines\" hits the nail on the head in that a combination of these form the \"canonical\" construct in terms of \"structured programming\" implied by current standard.\nConsidering there are more than enough nuances that need to be handled in each code-base usually and particularly in scientific and technical computing that has to deal to considerable domain-specific complexity, an imperative language such as Fortran might be better off offering general constructs that can be used by coders broadly e.g., general DO which can be used for  IO, numeric iterations and also any other instructions requiring a loop.\nYour second example involving a jump to another construct in terms of \"EXIT_TO error_output\" appears more of a case of structured exception handling and it is perhaps better addressed in this issue #66 .  Besides the exception handling use case, an EXIT_TO appears no different than a GO TO and given your title and description, it appears something which is better avoided,  Also, it is unclear how any limited \"GO TO\" in the form of an EXIT_TO construct can make refactoring any more accurate or easier, if you can show an actual refactoring tool (Python script. etc.) that might help make your case.\nNow, re: your case, as you know you will get steered toward named constants or CHARACTER variables generally as FORMAT strings:\n   ..\n   character(len=*), parameter :: UnlimitedReals = \"(*(f10.5))\"\n   ..\n   Write (7, UnlimitedReals) a, b, c\n\nSo my hunch is a major \"selling\" effort on your part will be necessary to get committee's attention on such aspects."
                }
            ]
        },
        {
            "number": 67,
            "user": "marshallward",
            "date": "2019-11-03 02:21:07+00:00",
            "title": "Permit namelist character delimiters to default to quotes",
            "text": "Currently there is a somewhat paradoxical issue related to namelist support, where a namelist produced by WRITE() and using the default DELIM value of None does not conform to the namelist specification when it contains a character array.\nA namelist as described in F2018 requires that all character arrays be delimited with single or double quotes (13.11.3.3 p7):\n\nWhen the next effective item is of type character, the input form consists of a sequence of zero or more rep-chars whose kind type parameter is implied by the kind of the corresponding list item, delimited by apostrophes or quotes.\n\nHowever, the default value of DELIM=None will produce a namelist without delimiters (i.e. space-delimited).  From 13.11.4.2 p1:\n\nValues in namelist output records are edited as for list-directed output (13.10.4).\n\nIf we go back to 13.10.4, it highlights three forms of character array output based on DELIM, with NONE being the default.  In other words, the default is incompatible with the namelist format.\nNote 1 of 13.11.4.2 clarifies this point:\n\nNamelist output records produced with a DELIM= specifier with a value of NONE and which contain acharacter sequence might not be acceptable as namelist input records.\n\nIn practice, this is often not a problem, and a robust parser can usually resolve the non-delimited strings if whitespace can act as a delimiter.  But it becomes a more problematic, if not impossible, if the string contains a lexical token, such as &, =, or /.  For example, strings containing paths are almost guaranteed to cause problems.\nTo summarize, a namelist containing character arrays when written with DELIM=NONE does not conform to the namelist specification, and a compiler can not read its own namelist if DELIM is not set to either QUOTE or APOSTROPHE.\nCurrently, gfortran ignores this requirement and defaults to using quote (\") delimiters.  Intel Fortran does not, and will produce a namelist that it cannot read.\n\nWhile this particular problem can be avoided by requiring the programmer to use DELIM for all namelist output (e.g. DELIM='QUOTE'), it will inevitably cause problems for the less experience developer, and could lead to output with errors.\nI'd like to propose that this problem be address in some way.  Two possible solutions:\n\n\nRequire that that DELIM be set for a namelist input, and DELIM='QUOTE' or DELIM=APOSTROPHE) when writing a namelist.  If WRITEis called with aNMLargument and withoutDELIM`, then it is an error.\n\n\nFollow GFortran and silently use DELIM='QUOTE' (or APOSTROPHE) when the output is a namelist.\n\n\nThere may be others possible solutions.\nThis is not a problem that needs to be solved, since users could just be trained to use DELIM when writing namelists.  But I believe that this change would be an improvement in usability and would help to avoid future errors.\n\nThis was prompted by the following discussion on the Intel forums:\nhttps://software.intel.com/en-us/forums/intel-fortran-compiler/topic/831685#comment-1947391",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-03 02:41:21+00:00",
                    "text": "@marshallward, I totally agree.\nI personally find NAMELIST a very useful facility in Fortran even if it is generally underutilized and maligned at times.  I also think the support toward NAMELIST in derived-type IO (so happy for that!) can also help with user-friendly serialization and deserialization of object instances of 'classes' (derived types) in Fortran, so anything that nourishes or otherwise keeps fresh the NAMELIST facility is a good thing in my opinion.\nYour proposal looks valuable, it should be relatively easy to add to the standard if there is will for the same."
                },
                {
                    "user": "certik",
                    "date": "2019-11-03 04:24:11+00:00",
                    "text": "@marshallward thanks a lot for reporting this. I agree, I think we should fix it. Let's try to write a proposal for this and let's get the committee to consider this at the next meeting."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-04 15:11:47+00:00",
                    "text": "Thanks for the positive feedback, @FortranFan @certik .  My impression from past interactions with J3 members is that there is little interest in doing anything related to namelists, so this is encouraging to hear.\nI'll defer to more experienced members here on how to properly write and submit a proposal."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-04 15:23:25+00:00",
                    "text": "I'll defer to more experienced members here on how to properly write and submit a proposal.\n\nPlease, please, at least start a draft (submit via PR). You already have substantial material in this original post of this thread. It will significantly lower the bar for others to add contributions to the proposal once there's something concrete there. See a current early proposal draft as an example:\nhttps://github.com/j3-fortran/fortran_proposals/blob/master/proposals/namespace_modules/19-246.txt\nI will put an effort soon toward a proposal template which will help streamline the bootstrapping of a proposal."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-04 15:34:39+00:00",
                    "text": "Sure, in that case I'm happy to put something together.  I'll look over some of the proposals and will ping for feedback when it's ready."
                },
                {
                    "user": "certik",
                    "date": "2019-11-04 15:43:32+00:00",
                    "text": "Thanks @marshallward. I would like the wide community to create proposals, and then the J3 members can help refine it and provide feedback. Such a process scales well with people."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-18 20:38:46+00:00",
                    "text": "I've drafted most of a proposal here:\nhttps://github.com/marshallward/fortran_proposals/blob/namelist_delim/proposals/namelist_delimiters/namelist_proposal.rst\nI am not entirely sure how it is supposed to look, and I did deviate a bit from the example.  For example, I don't have a \"use cases\" section, since I was suggesting a different interpretation of existing rules, rather than a new feature.  I also would expect that the final section is to be removed, I mostly left those as my own personal notes.\nI can either send it as a PR or suggestions can be made on my local branch, whatever is easier."
                },
                {
                    "user": "certik",
                    "date": "2019-11-18 21:22:00+00:00",
                    "text": "@marshallward thanks! Send a PR please to this repository.\nI would like to have a template here about what a proposal should look like so that the committee can consider it. In the meantime, create a PR and let's discuss it."
                },
                {
                    "user": "marshallward",
                    "date": "2019-11-19 15:07:52+00:00",
                    "text": "I've created a PR here: #94\nIf you'd like to close this issue and move discussion there, that's fine with me."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 23:32:28+00:00",
                    "text": "I shared @marshallward 's #154 proposal with the J3/JoR subgroup. Dan gave me very detailed feedback summarizing their conclusions:\n\n\n\nChanging the default behavior of namelist will change the behavior of existing programs.  This may be done only for a very important reason, and a convenience issue, such as a default setting, likely does not rise to that level.\n\n\nThe default will also affect list-directed transfers, which is likely unintended, and will be surprising to list-directed users.  This also argues that a very good reason will be required to overcome the desire not to break programs.\n\n\nNote that one may set the delim value via the OPEN statement or the specific transfer (read/write print) statement in question. The ease of setting the desired behavior per connection or per transfer argues that we not proceed with a change like this one.  As a changeable mode, delim may be set and reset as needed via the initial OPEN and (re)OPEN statements.\nAlso, we have added several features included in the last several revisions of the standard to help input/output of csv records.  Specifically, the unlimited format item allows writing \"item [separator item] ...\" style records. Including a g data edit descriptor in the unlimited format item can treat different types (perhaps when a derived type has had a new component added, for example). The new f202x SPLIT intrinsic operates similarly to strtok(), and helps decode csv records read into a (possibly long) character entity.\nThese are my interpretation of JoR's conclusions and not J3's, nor WG5's. I say 'likely' above because it is a committee decision, and I do not know with certainty what the outcome of votes would be."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-27 23:53:21+00:00",
                    "text": "Thanks very much for providing the feedback.\nI'm sympathetic to point 1, both options would change default behavior, and perhaps that is an automatic veto.\nI think my only response would be to point 2.  I deliberately did not intend for list-directed output to be affected here, and that DELIM would default to different values depending on whether or not NML= has been set in a WRITE() statement.  If the NML= is absent, and the output is list-directed, then the default DELIM from OPEN() (or perhaps WRITE()) would be respected.\nSo I feel that there ought to be a solution which does not affect list-directed input.  In fact, given that GFortran is already doing this, it is proof that there is a way to implement this which does not affect list-directed output.\nIn other words, I am requesting that the non-compliant GFortran behavior become the standard behavior.\nNot sure if there's any constructive way to relay this feedback, so perhaps I am just talking to the air.  But thanks very much for presenting the proposal and sending the feedback, I really do appreciate it."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 23:56:44+00:00",
                    "text": "@marshallward is your new proposal (make GFortran behavior the default) different to what you submitted above? If so, let's write a new proposal and we will present it at the next meeting."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-28 00:00:11+00:00",
                    "text": "These were the two proposals:\nA. If namelist-group-name appears, then a DELIM= specifier with the\nvalue of either APOSTROPHE or QUOTE shall also appear.\nB. If namelist-group-name appears and a DELIM= specifier has the value\nof NONE, then this value is ignored and the data transfer uses a\nvalue of APOSTROPHE.\nSeems pretty explicit that the change would only apply if NML= appears."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-28 00:00:56+00:00",
                    "text": "You are very welcome, I'm happy to help! Our response from the committee has overall been very positive, I think they are happy to have this venue to interact with the programmer community. As @certik said, if we work on a new proposal we can present it at the next meeting."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-28 00:02:45+00:00",
                    "text": "Oh, I may not have addressed your question @certik .  Yes, AFAIK option (B) does describe default behavior in GFortran (perhaps using QUOTE rather than APOSTROPHE)."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 00:04:06+00:00",
                    "text": "@marshallward ok, then let's write a proposal just for B, incorporating any feedback so far, and we can present it at plenary next time."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-28 00:05:42+00:00",
                    "text": "Seems pretty explicit that the change would only apply if NML= appears.\n\nWell, a namelist-group-name would have to appear; the NML= specifier is (very unfortunately!) optional.\n(If NML= were always required, NAMELIST group names could inhabit their own namespace.)"
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-28 00:09:58+00:00",
                    "text": "Thank you @klausler , in that case I am mistaken about the NML= part.\nBut given that the interpreter is capable of identifying the argument as a namelist-group-name, should it also not be possible to identify the WRITE() operation as a namelist output and therefore not list-directed output?  If so, then I think that the current wording might be OK to leave list-directed output unaffected?"
                },
                {
                    "user": "klausler",
                    "date": "2020-02-28 00:14:45+00:00",
                    "text": "Thank you @klausler , in that case I am mistaken about the NML= part.\nBut given that the interpreter is capable of identifying the argument as a namelist-group-name, should it also not be possible to identify the WRITE() operation as a namelist output and therefore not list-directed output? If so, then I think that the current wording might be OK to leave list-directed output unaffected?\n\nI haven't thought much about your conclusion, but the first part of your statement is correct; it is the case that the compiler can distinguish a namelist write ([NML=]group) from a list-directed write([FMT=]*)."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-28 02:17:27+00:00",
                    "text": "I've updated the proposal here:\n#159\nIt removes the first option and makes explicit that there is no intention to change list-directed output.  I also (hopefully) cleaned up and clarified the problem in the introduction."
                },
                {
                    "user": "marshallward",
                    "date": "2020-02-28 02:35:16+00:00",
                    "text": "I would also like to add a rebuttal to point 1.  I don't consider this simply a matter of convenience.  I see it as a remedy to a real problem, which is that the default namelist output is not a namelist and is potentially unparseable.\nPerhaps it is considered a convenience simply because it can be avoided by a careful programmer who judiciously uses DELIM for every unit destined to produce a namelist.  But I do consider it a concern when two very simple commands:\nopen(5, file=some_path)\nwrite(5, nml=some_nml) my_data\n\nproduces a thing which is almost - but not quite - a namelist.  So in my mind, this is an important reason for changing the default behavior.\nAgain, I don't really know if there's any way to pass along these comments.  I suppose I'm just adding it here for the sake of discussion."
                },
                {
                    "user": "klausler",
                    "date": "2021-04-07 18:52:42+00:00",
                    "text": "Suggestion: add a new OPEN/INQUIRE argument with a distinct name, say NAMELIST_DELIM=, that would be independent of DELIM= and allow you get what you want for a whole run with just one statement."
                },
                {
                    "user": "marshallward",
                    "date": "2021-05-26 16:10:59+00:00",
                    "text": "@klausler Sorry for not replying to this at the time, I think the idea of a separate namelist delimiter argument is a very good compromise.\n\nlist-directed IO is left unchanged\nIn most cases, the argument would be unneeded\nthe default could be left unspecified, to the discretion of the compiler.\n\nWhen I find some time, I'll revise the proposal to recommend this."
                },
                {
                    "user": "vansnyder",
                    "date": "2022-04-23 21:06:49+00:00",
                    "text": "A related problem is that namelist and list-directed input are less similar than they could be. In list-directed input, a character datum that does not contain a blank need not be surrounded by quotes or apostrophes. In namelist, it's always required.\nHere's a weird (but handy) use case.\nPut what looks like namelist input on your command line (without the namelist name) -- name=value pairs.\nRead the entire command line (not individual command arguments) into a character variable, after putting the slash and namelist name at the beginning. Add a slash at the end. Read the variable using namelist input. Now you have all your command-line arguments in one gulp, and it's really easy to change them. But if you have a character variable in the namelist, you need to put it into quotes or apostrophes. But command shells treat quotes and apostrophes specially, so you need to escape them. Ugh."
                }
            ]
        },
        {
            "number": 66,
            "user": "FortranFan",
            "date": "2019-11-02 12:35:24+00:00",
            "title": "Use Cases for Exception Handling in Fortran",
            "text": "I request this thread be used to collect examples, thoughts, and comments on the use cases for Exception Handling in Fortran.\nAs reference, please see this paper  from the J3 meeting in Las Vegas earlier this year which documents a set of closely related cases.\nException Handling is a facility long requested by practitioners but which keeps getting deferred.  It was under consideration for Fortran 202X but WG5 resolved at the Tokyo meeting this past August not to include it in Fortran 202X.  It is now unclear when, if ever, Exception Handling will be standardized in Fortran.\nHowever the concept remains important and perhaps the FOSS and user community can take the lead in distilling further the needs, in ironing out the wrinkles, also \"smoothing\" out the edge cases that can possibly cause \"bleeding\" either in terms of performance or added vulnerabilities in programs, and may be even prototype ideas in implementations such as LFortran, etc.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-02 12:46:44+00:00",
                    "text": "In issue #64 , @klausler wrote:\n\nNote that RETURN with alternate returns would be much more useful if it were possible to forward an incoming alternate return dummy argument as an outgoing alternate return label. Many of the use cases for exception handling would be covered with safe deallocation and finalization if such forwarding were supported, and such support would be trivial to implement.\n\nNote @arjenmarkus has a nice paper on the applicability of \"ALTERNATE RETURN\" (now obsolescent) facility toward Exception handling in Fortran.\nI agree  with @arjenmarkus' and @klauer's ideas that a certain (limited?) form of Exception Handling, which might meet a bulk of the use cases for Fortranners especially in the domains of scientific and technical computing, may be feasible by availing the existing compiler implementations on ALTERNATE RETURNs but which may be simply repackaged with some additional facilities like forwarding and improved syntax that addresses concerns not only with performance but also convenience and ease-of-use in modern codes in Fortran."
                },
                {
                    "user": "certik",
                    "date": "2019-11-02 13:46:51+00:00",
                    "text": "See also #6 for error handling."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-02 14:30:12+00:00",
                    "text": "See also #6 for error handling.\n\nGood point, I missed out on that thread."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-02 16:00:09+00:00",
                    "text": "Could anyone please give an example how to use revived alternate returns\nfor exception handling? I think the desired behavior is \"handle the\nexception yourself\" or \"don't handle exception and crash the program\". Can\nyou show a simple procedure and two calls (once where error is handled and\nonce where it is unhandled)? How to guarantee that the execution of the\nprogram will stop if the error is unhandled? The behavior to quietly\nproceed with execution in absence of error handler is very dangerous.\n\nsob., 2 lis 2019 o 15:30 FortranFan <notifications@github.com> napisa\u0142(a):\n\u2026\n See also #6 <#6>\n for error handling.\n\n Good point, I missed out on that thread.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#66?email_source=notifications&email_token=AC4NA3OBGJYWUGNO2TGYQ43QRWFHNA5CNFSM4JIFBE5KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEC45D3A#issuecomment-549048812>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3POINI3ONM5WWLF6FLQRWFHNANCNFSM4JIFBE5A>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-02 21:24:47+00:00",
                    "text": "@gronki wrote:\n\nCould anyone please give an example how to use revived alternate returns for exception handling? I think the desired behavior is \"handle the exception yourself\" or \"don't handle exception and crash the program\". Can you show a simple procedure and two calls (once where error is handled and once where it is unhandled)? How to guarantee that the execution of the program will stop if the error is unhandled? ..\n\nThere are no guarantees with anything but nominally the following might be a rough \"template\" on how the concept of ALTERNATE RETURNs can be employed by implementations to mimic Exception Handling like the TRY-CATCH constructs.\nSay there is a library subprogram with a 'contracted' interface that operates on a dummy argument of real type 'x' that is discovered to encounter an exception for values in a certain range of x.  The library code can refactor the method to issue an ERROR STOP and hope the caller can deal with the consequences:\n   subroutine sub_x( x )\n      real, intent(inout) :: x\n      ! An arbitrary range that causes an exception\n      if ( (x > 0.4).and.(x < 0.6) ) then\n         error stop \"In sub_x: invalid value of x\"\n      end if\n      x = x + 1.0\n      return\n   end subroutine\n\nNow, should an implementation want to support some form of handling the exception without the ERROR STOP with its inadvertent side effects, they might provide some wiring as follows:\n   subroutine sub_e( x, *, e )\n      real, intent(inout) :: x\n      class(except_t), intent(out), optional :: e\n      ! An arbitrary range that causes an exception\n      if ( (x > 0.4).and.(x < 0.6) ) then\n         e%procname = \"sub\"\n         e%line = 17\n         e%estat = 1\n         e%emsg = \"Invalid value of x\"\n         return 1\n      end if\n      x = x + 1.0\n      return\n   end subroutine\n\nwhere an ALTERNATE RETURN is combined with an additional argument of OPTIONAL ATTRIBUTE which is of an arbitrary EXCEPTION class (say except_t) that can hold 'data' pertaining to the exception like so:\nmodule except_m\n   implicit none\n   type :: except_t\n      integer :: line = 0\n      integer :: estat = 0\n      character(len=:), allocatable :: procname\n      character(len=:), allocatable :: emsg\n   end type\nend module\n\nImplementation might also overload the library method so it can be invoked with or without such 'handling':\n   generic :: sub => sub_e, sub_x\n\nThen on the caller side the implementation might 'parse' out their own TRY-CATCH syntax with Fortran semantics described using the standard facility of BLOCK construct as follows:\ntry_catch: block\n   use except_m, only : except_t\n   type(except_t) :: e\n   call sub(x, *1, e)  !<-- note here\n   exit try_catch\n   ! Catch exception section\n1  continue\n   print *, \"Exception occured in \", e%procname, \" at line # \", e%line\n   print *, \"Error status = \", e%estat\n   print *, e%emsg\n   print *, \"Execution is continued\"\nend block try_catch\n\nThus when a caller decides for whatever reason not to use exception handling, the call sub(x) option remains.\nA complete working example is\nmodule except_m\n   implicit none\n   type :: except_t\n      integer :: line = 0\n      integer :: estat = 0\n      character(len=:), allocatable :: procname\n      character(len=:), allocatable :: emsg\n   end type\nend module\nmodule m\n   use except_m, only : except_t\n   implicit none\n   interface sub\n      module procedure sub_e\n      module procedure sub_x\n   end interface\n   !generic :: sub => sub_e, sub_x  !<-- Fortran 2018, not supported by gfortran\ncontains\n   subroutine sub_e( x, *, e )\n      real, intent(inout) :: x\n      class(except_t), intent(out) :: e\n      if ( (x > 0.4).and.(x < 0.6) ) then\n         e%procname = \"sub\"\n         e%line = 17\n         e%estat = 1\n         e%emsg = \"Invalid value of x\"\n         return 1\n      end if\n      x = x + 1.0\n      return\n   end subroutine\n   subroutine sub_x( x )\n      real, intent(inout) :: x\n      ! An arbitrary range that causes an exception\n      if ( (x > 0.4).and.(x < 0.6) ) then\n         error stop \"In sub_x: invalid value of x\"\n      end if\n      x = x + 1.0\n      return\n   end subroutine\nend module\nprogram p\n   use m, only : sub\n   implicit none\n   real :: x\n   integer ::  i\n\n   blk1: block\n\n      print *, \"Block 1\"\n      do i = 1, 10\n         call random_number( x )\n         print *, \"x = \", x\n\n         try_catch: block\n            use except_m, only : except_t\n            type(except_t) :: e\n            call sub(x, *1, e)\n            exit try_catch\n            ! Catch exception section\n         1  continue\n            print *, \"Exception occured in \", e%procname, \" at line # \", e%line\n            print *, \"Error status = \", e%estat\n            print *, e%emsg\n            print *, \"Execution is continued\"\n         end block try_catch\n\n      end do\n\n      print *\n\n   end block blk1\n\n   blk2: block\n\n      print *, \"Block 2\"\n\n      do i = 1, 10\n\n         call random_number( x )\n         print *, \"x = \", x\n\n         call sub( x )\n\n      end do\n\n      print *\n\n   end block blk2\n\n   stop\n\nend program p\n\nUpon execution, output can be as follows:\n Block 1\n x =   0.414278448\n Exception occured in sub at line #           17\n Error status =            1\n Invalid value of x\n Execution is continued\n x =   0.313940883\n x =    3.59865427E-02\n x =   0.298014879\n x =    6.91809058E-02\n x =   0.301655293\n x =   0.212819457\n x =   0.951416492\n x =    7.51928091E-02\n x =   0.804682851\n\n Block 2\n x =   0.217340648\n x =   0.727119923\n x =   0.489649057\nERROR STOP In sub_x: invalid value of x\n\nError termination. Backtrace:\n\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 19:05:55+00:00",
                    "text": "@FortranFan , that looks intriguing. How far could you get with that technique by just utilizing a good error handling framework/library like this one? You could make the errors an optional argument and put a stop statement if one isn't provided."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-12-30 21:33:32+00:00",
                    "text": "@everythingfunctional wrote:\n\n@FortranFan , that looks intriguing. How far could you get with that technique by just utilizing a good error handling framework/library like this one? You could make the errors an optional argument and put a stop statement if one isn't provided.\n\n@everythingfunctional, the basic idea of the example above in #66 (comment) is that with limited syntax/keywords/intrinsic procedures a la how coarrays came about with [] syntax starting Fortran 2008, the processor can implement some form of exception handling by doing \"all the wiring\" by reusing what it has had to do to support the obsolescent but not deleted \"alternate return\" facility.  What's shown in the example is just an attempt to show a simple-minded way a processor might go about doing this.  That example is not meant as a library implementation."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 21:59:48+00:00",
                    "text": "@FortranFan , that example makes it look more like the code is trying to support a language feature than a language feature actually supporting more clear and concise code. I would much rather utilize a library than have the language require that much boiler plate/rigmarole.\nIn order to properly support exception handling you really need to add some keywords, constructs and intrinsics to the language.\ntry\n    call somethingThatMightThrow()\ncatch(e)\ntype is (IOException)\n    call doSomethingToRecover()\nclass is (Exception)\n    call justCrash(e)\nend try\n\nthrows subroutine somethingThatMightThrow()\n   ...\n   throw exception(\"Something went wrong\")\n   ...\nend subroutine\n\nProcedures that throw could (or should) not be able to be pure or elemental, and procedures that call procedures could (or must) inherit that they throw as well.\nI think anything you tried to shoehorn in based on or around other features, or that wasn't designed well would probably not be a good idea. If Fortran does add in exception handling it should probably be based on good designs from other languages."
                },
                {
                    "user": "victorsndvg",
                    "date": "2020-01-08 12:14:19+00:00",
                    "text": "Hi all,\nI was playing with a dummy project called ForEx (https://github.com/victorsndvg/ForEx) to explore how to implement user defined exception handling in OO Fortran taking advantage of the preprocessor.\nThe experience was nice exploring the flexibility of the language to do this sort of things, but in my opinion I found a key point that unable Fortran to manage exceptions. Non-local jumps. As fas as I know, non-local jumps are not supported by the standard.\nWhen handling exceptions, one wants to abruptly stops the program at a given point and manage the program behaviour in a different point. Without using non-local jumps one can only \"handle exceptions vertically\" and per block-of-code instead of per-instruction.\nMy proposal here is to support non-local jumps.\nHope to be helpful!"
                }
            ]
        },
        {
            "number": 65,
            "user": "klausler",
            "date": "2019-11-01 20:27:30+00:00",
            "title": "The preprocessor should be standardized",
            "text": "Most Fortran compilers support some form of source code preprocessing using a syntax similar to the preprocessing directives and macro references in C/C++.  The behavior of the preprocessing features in the various Fortran compilers varies quite a bit (see https://github.com/flang-compiler/f18/blob/master/documentation/Preprocessing.md for a summary of the situation).  To improve code portability, the Fortran standard should accept the existence of preprocessing, and standardize the behaviors that are common and/or most useful.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "sblionel",
                    "date": "2019-11-03 20:48:01+00:00",
                    "text": "I'd guess you are unaware that Fortran 2003 contained an optional Part 3 that was conditional compilation. I'm not sure any vendor implemented it, there was little interest, and it got withdrawn in F2008. I really don't see us going back there.\nThe reality is that people use cpp (or a variant) and that seems to work for most everyone. The better question to ask is \"what are the use cases for a preprocessor, and can better language design satisfy that need?\" Look at the C interop stuff, for example - it eliminates a large swath of what preprocessors were used for. A proper generics feature would eliminate more."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-04 17:41:16+00:00",
                    "text": "I am aware of CoCo and how poorly it fared.  The fact remains, C-like preprocessing is a real-world feature that is available in all compilers.  Fortran would be more portable if the language acknowledged the existence of preprocessing and defined a standardized portable subset of behavior."
                },
                {
                    "user": "certik",
                    "date": "2019-11-04 23:26:00+00:00",
                    "text": "@klausler thanks for bringing this up. Related to this is the fact that the default behavior is to not use a preprocessor for .f90 files and to use it for .F90 files. And so in practice one must rename a .f90 file to .F90 in order for the preprocessor be be applied automatically, which is annoying.\nWhy not standardize a subset of the current behavior, and automatically apply it to .f90 files?\n@sblionel's counterpoint is valid though --- just like C++ is moving away from using preprocessor by adding language features, Fortran is moving in that direction too. So I think the counterpoint is to not standardize a preprocessor, but rather improve language features so that the preprocessor is not needed.\nBesides templates, one common use case for a preprocessor that I have seen in many codes is a custom ASSERT macro, which is empty in Release mode, and in Debug mode it checks the condition and prints out the filename and line number. I have created #70 for this."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-04 23:45:39+00:00",
                    "text": "Keep in mind that the Fortran standard knows nothing about .f90 files or source files in general. It would be a broad expansion to try to legislate behavior based on file types. Note also that some operating systems are not case-sensitive for file names.\nI don't think that the current state of preprocessing is broken enough to warrant the standard trying to get involved."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-04 23:58:02+00:00",
                    "text": "The standard doesn't have any concept of source files, much less source file names.  The f18 compiler always recognizes and follows preprocessing directives and applies macro replacement, ignoring the source file name suffix, since its preprocessing capabilities are built in to its source prescanning and normalization phase, and are essentially free when not used.\nI absolutely agree that some common subset of preprocessing behavior should be standardized.  This is the one major part of Fortran that every compiler provides that is not covered by the standard language document; but perhaps improving portability of Fortran programs across vendors, writing interoperable header files usable by Fortran and C++, or providing safe guarantees of portability into the future are no longer primary objectives.\nAs part of defining f18's preprocessing behavior, I performed a survey of various Fortran compilers and wrote a collection of tests to check how their preprocessors interacted with difficult Fortran features like line continuation, fixed form, &c.  The current state of the art is far more fragmented than I expected to find (see my link above for details and a compiler comparison table), and none of the existing compilers seemed to stand out as a model to be followed.\nEDIT: The standard does have a concept of source files in the context of INCLUDE lines, of course; my first sentence was too broad."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 00:02:03+00:00",
                    "text": "@sblionel yes, the standard currently does not have concept of source files, but perhaps it should. I see this GitHub repository as broader than what is strictly covered by the standard today --- because we might decide in the future to include some such things (such as more details about source files) into the standard.\nAnd I must say I agree with @klausler's on this. There is a lot that Fortran should standardize and improve. Perhaps it does not need to go into the standard itself, but then let there be a document that we all agree upon, we do not need to call it the \"standard\" (perhaps we can call it \"vendor recommendation\"), but it will achieve what we want: improving portability across vendors."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 16:39:08+00:00",
                    "text": "I am not sure, whether pre-processing must be necessarily implemented within the compiler or being standardized at all. Using an appropriate interpreter language (e.g. Python) it is possible to implement a pre-processor satisfying all requirements @klausler formulated (and even much more) within a single file. You add this one file to your project, and you can build your project with all Fortran compilers, as your pre-processor on board makes sure that the compiler only sees standard conforming source files. You will have to have the interpreter of course around whenever the project is built, but by choosing something wide-spread as Python, it would be the case on almost all systems automatically.\nDisclaimer: I may be biased as I myself also wrote such a one file pre-processor (Fypp) which apparently has found its way into several Fortran projects."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 16:44:58+00:00",
                    "text": "@aradi I think you having written fypp perfectly proves that there is a need for a preprocessor. Contrary to what @sblionel said, it seems that generic programing will not be around for years, whereas a good preprocessor (so not cpp...) can solve 95% of the use cases for generic programming."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 16:45:53+00:00",
                    "text": "@aradi Thanks for the link, I wasn't aware of Fypp. Its syntax seems incompatible with the other preprocessors though. I can see that it has more features, so that's probably the reason. But having the preprocessor syntax standardized I think is valuable."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-12 16:56:48+00:00",
                    "text": "@certik The syntax is different from the usual cpp-derived pre-processors to make sure, nobody tries to run those on files meant to be processed Fypp. \ud83d\ude09  (Also, it allows better escaping and ensures better prevention against unwanted substitutions, which is sometimes tricky with cpp-based approaches.)\n@gronki Fypp was actually written in order to allow for easy generation of templates, so yes, a pre-processor can help to work around (but not solve) many of the generic programming needs. Still, I am not sure, whether it is a good idea to use \"standardized pre-processor based workarounds\" for generics, as we will stick then with them for the next few decades. \ud83d\ude04"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-12 17:01:20+00:00",
                    "text": "@gronki , I never suggested a timeframe for generics. But there is a lot of resistance to adding features that paper over shorter-term problems. But there is an existing preprocessor solution that works, why complicate issues with trying to wedge preprocessing into the standard? I'd prefer the energy and cycles to be put into solving the language issues that make people reach for a preprocessor."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 17:02:39+00:00",
                    "text": "Depends whether you believe that full generics will make it into Fortran. I\nwould rather cut this absolute insanity of copy-pasting the same code using\nsome simple but decent preprocessing language rather than wait 10 years.\n\nwt., 12 lis 2019 o 17:56 B\u00e1lint Aradi <notifications@github.com> napisa\u0142(a):\n\u2026\n @certik <https://github.com/certik> The syntax is different from the\n usual cpp-derived pre-processors to make sure, nobody tries to run those on\n files meant to be processed Fypp. \ud83d\ude09 (Also, it allows better escaping and\n ensures better prevention against unwanted substitutions, which is\n sometimes tricky with cpp-based approaches.)\n\n @gronki <https://github.com/gronki> Fypp was actually written in order to\n allow for easy generation of templates, so yes, a pre-processor can help to *work\n around* (but not solve) many of the generic programming needs. Still, I\n am not sure, whether it is a good idea to use \"standardized pre-processor\n based workarounds\" for generics, as we will stick then with them for the\n next few decades. \ud83d\ude04\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#65?email_source=notifications&email_token=AC4NA3MODDAPT4MDBJECU2LQTLN5FA5CNFSM4JH7T652YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOED26AIA#issuecomment-552984608>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3ICF2YZIBKPWTNJNGDQTLN5FANCNFSM4JH7T65Q>\n ."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 17:05:23+00:00",
                    "text": "@sblionel sure you have the point. Agree that including it in the core standard could be a waste of resources. But what about TS, just like it was with CoCo? Is there any idea or information why CoCo \"lost\" with cpp (despite implementation being available)? I didn't see anything wrong with it other than it just didn't take off."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 17:22:23+00:00",
                    "text": "In terms of priorities, I think I agree with @sblionel that it makes sense to invest our efforts in getting generics into the standard, rather than prioritize a short term solution over the long term. That's a good point."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-12 17:38:02+00:00",
                    "text": "@gronki, CoCo was before my time on the committee. All I know is that vendors didn't implement it and users didn't ask for it - they continued to use cpp.\nCoCo was an optional part of the standard, not a TS. A TS has the expectation that it will be incorporated in a future standard largely unchanged. Our experience so far with optional standard parts is that neither users nor implementors are all that interested in them.\nI will also trot out my oft-used point that everything that goes into the standard (and a TS or optional part is no different) has a cost, in terms of the resources and time of the committee members."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-12 17:53:19+00:00",
                    "text": "Thank you for great explanation! I did not recognize the difference between the optional part and the TS."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 18:30:42+00:00",
                    "text": "@gronki , I never suggested a timeframe for generics. But there is a lot of resistance to adding features that paper over shorter-term problems. But there is an existing preprocessor solution that works, why complicate issues with trying to wedge preprocessing into the standard? I'd prefer the energy and cycles to be put into solving the language issues that make people reach for a preprocessor.\n\nIt's not either/or, and people have work to do today.  Fortran compilers have preprocessors, people use them, and code portability would benefit from standardizing them to the extent that they can be."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2019-12-16 13:44:00+00:00",
                    "text": "It's not either/or, and people have work to do today. Fortran compilers have preprocessors, people use them, and code portability would benefit from standardizing them to the extent that they can be.\n\nThe preprocessors of fortran compilers are in fact standardized by the cpp standard. I think this is more than sufficient. (eg. C18 (ISO/IEC 9899:2018) 6.10 preprocessor directives"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-16 17:26:51+00:00",
                    "text": "It's not either/or, and people have work to do today. Fortran compilers have preprocessors, people use them, and code portability would benefit from standardizing them to the extent that they can be.\n\nThe preprocessors of fortran compilers are in fact standardized by the cpp standard. I think this is more than sufficient. (eg. C18 (ISO/IEC 9899:2018) 6.10 preprocessor directives\n\nRunning Fortran through a \"bare\" cpp that doesn't know about Fortran commentary, line continuations, column-73 fixed-form line truncation, CHARACTER concatenation operator, and built-in INCLUDE lines will produce poor results.  Real production Fortran compilers either use a modified cpp or implement a cpp-like facility internally.  The ways in which the Fortran features that I just mentioned interact with the preprocessors' implementations of their features (directive processing, macro replacement) show too much variation across Fortran compilers, and that is why they need standardization by a committee that should take code portability seriously."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-18 20:23:06+00:00",
                    "text": "Just for clarity, is this proposal focusing on standardizing the behavior of existing preprocessors (cpp, fpp) rather than extending or adding new features for more robust code conversion or metaprogramming facilities (i.e., the latter should be posted elsewhere)?"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-18 20:27:39+00:00",
                    "text": "I do not exclude the addition of new features to a standardized preprocessor in my concept, but I don't know of any particular new feature that I would want that isn't already implemented in at least one compiler.  What do you have in mind?"
                },
                {
                    "user": "aradi",
                    "date": "2019-12-18 21:13:14+00:00",
                    "text": "I think, in case generics do not make it into the standard, loop constructs would be useful to generate various specific cases for a given template.\nWe are using that a lot for creating library functions with the same functionality but different data types / kinds. (For example wrapping MPI-functions as in MPIFX). We use currently Fypp for that (shipping Fypp with each project), but would be more than happy to change it to any other pre-processor language, provided we can be sure, each compiler can deal with it."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-18 21:19:01+00:00",
                    "text": "As for code conversion, my immediate use case is to iterate over multiple symbols to generate codes from a templated one. For example I often have a pattern like\nopen( newunit= data % file_foo, file=\"foo.dat\" )\nopen( newunit= data % file_bar, file=\"bar.dat\" )\nopen( newunit= data % file_baz, file=\"baz.dat\" )\n! similar lines follow\n\nclose( data % file_foo )\nclose( data % file_bar )\nclose( data % file_baz )\n! similar lines follow\n\nto open or close files for each type component.  Although those lines are the same except for property names (like foo), I cannot write them conveniently at once (with standard Fortran/cpp/fpp). A similar situation occurs when doing some operation for all (or some of) type components,  e.g. scaling by some factor\ndata % ene_foo = data % ene_foo * scale\ndata % ene_bar = data % ene_bar * scale\ndata % ene_baz =ydata % ene_baz * scale\n! similar lines follow\n\nIf a preprocessor supports iteration over symbols, I may be able to write, e.g.\n#for x in [ foo, bar, baz, ... ]\ndata % ene_$x = data % ene_$x * scale\n#endfor\n\n(where I suppose \"$\" is interpreted as in Bash). Fypp already has this facility\ninterface myfunc\n#:for dtype in ['real', 'dreal', 'complex', 'dcomplex']\n  module procedure myfunc_${dtype}$\n#:endfor\nend interface myfunc\n\nand Julia also uses such loops over symbols sometimes, e.g.\nhttps://github.com/JuliaLang/julia/blob/master/base/math.jl#L1100\nhttps://github.com/JuliaLang/julia/blob/master/base/math.jl#L548\nhttps://github.com/JuliaLang/julia/blob/master/base/math.jl#L382\nI think it would be useful if standard Fortran or preprocessor will support such a feature somehow, if Fortran generics (discussed on Github) may not cover such a feature.\nApart from the feature request, I am a bit concerned that the extensive use of \"#\" or \"$\" can make a code very noisy or cryptic (the worst case of which might be Pe*l??), which I hope to be avoided (if possible...). In particular, if cpp/fpp requires the directive to start from column 1 with \"#\",  the code may become less readable (as I often feel for codes with a lot of \"#ifdef MPI\")."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-19 20:45:35+00:00",
                    "text": "Another feature request for a preprocessor (according to StackOverflow) might be to support output of multi-line processed sources (without using semicolon).\nFortran Preprocessor Macro with Newline\nhttps://stackoverflow.com/questions/59309458/fortran-preprocessor-macro-with-newline"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-19 22:01:00+00:00",
                    "text": "Another feature request for a preprocessor (according to StackOverflow) might be to support output of multi-line processed sources (without using semicolon).\nFortran Preprocessor Macro with Newline\nhttps://stackoverflow.com/questions/59309458/fortran-preprocessor-macro-with-newline\n\nThe reason he or she does not want to use semicolons is fear of a 132-character line limit, which is something that a compiler with a built-in preprocessing stage should enforce before macro expansion, not after."
                },
                {
                    "user": "aradi",
                    "date": "2019-12-19 22:11:21+00:00",
                    "text": "Still, I can think of scenarios where passing multiline arguments to macros would be useful. Thinking about macro based unit test systems (as in Google Test or Catch for C++) you would need the ability to pass multiline macros to Fortran."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-19 22:14:51+00:00",
                    "text": "Multi-line arguments are a different problem from multi-statement expansions.  Both should work; specifically, Fortran line continuations should be usable within macro invocations."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-09 03:38:36+00:00",
                    "text": "I hate preprocessors and yet have written several; so I do not think cpp(1) is sufficient even if it is a modified \"Fortran-safe\" version such as fpp. That type of preprocessing it usually most useful for hiding portability issues between different systems and compilers which I find I need far less than in the past; partly because of more standardized OSes; and partly because of Fortran standardization and the inclusion of the ISO_C_BINDING module (a lot of cpp processing had to do with interfacing with C in my case).  More recently I find I use preprocessing to make up for these missing Fortran features:\nMULTI-FILE FILES\nbeing able to have blocks of text in the same file for  plain text documentation, Fortran, and related C\ncode and unit tests.\nbeing able to define strings with blocks of plain text. IE\nDEFINING CHARACTER VARIABLES WITH PLAIN BLOCKS OF TEXT (IE. \"HERE\" documents)\nhelp=```\na block of text without any\nother need for quotes or continuation characters and so on.\n>>>_scratch1\n   test data\n<<<\n\nrunning code thru other utilities such as bash, sed, m4, ... to loop over routines to create generics. bash is even more commonly available than python, very standardized and surprisingly good as a \npreprocessor, and has a large number of people familiar with it. \n\nIt GREATLY helps me to keep my document (usually in markdown syntax, sometimes in HTML or LaTex right in the file with my Fortran and C code and test scripts;  my intent is not to say everyone should use one of my preprocessors but to say  preprocessing is still useful for making up for missing features and customizing the development environment in useful ways. \n\nEven using cpp as an example, it can be very useful just to do something like\n#ifdef DOCUMENT\nNAME\n   my routine -- it does this stuff\nSYNOPSIS\n       my_routine(parm1, parm2, parm3)\nDESCRIPTION\n       everything you ever wanted to know about my \n       routine\nEXAMPLE\n       bet you wish there was an example here\n#elif defined(FORTRAN)\n    subroutine my_routine\n   end subroutine my_routine\n#elif defined(CCODE)\n   my_routine_c(){\n}\n#endif   \n\nit is then easy to make scripts or makefile rules to extract the document and run it thru man2txt to make a man page, turn it into comments and include it with the Fortran code and put that into a .f90 file, and put the C code into a .c file. \n\ncan be really a very useful use of a preprocessor.  Note that m4 can be used to do all kinds of preprocessing.  \n\nPut more to the topic,  preprocessing is often still desirable, especially for helping to simulate missing Fortran capabilities like templating and allowing flat block text; and if anyone is going to create a standard preprocessor cpp(1) is not a model I would recommend. People put up with using cpp for Fortran pre-processing for lack of simple alternatives; they do not find it sufficient (or even safe)."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-31 18:29:58+00:00",
                    "text": "If we can't get J3 to standardize minimum requirements on this essential and universally implemented feature, perhaps the community can at least give some guidance to implementors.  I would like f18 to predefine a macro that specifies the edition of the Fortran standard that it implements, something like #define __FORTRAN_STD__ 2018.  Is that the best name, or can anyone suggest something better?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-31 20:15:31+00:00",
                    "text": "@klausler yes, we should come up with conventions as a community.\nWill this macro change if you tell the compiler to stick with F2003 for example (like the -std=f2003 option for gfortran)? How are you imagining users would use this macro?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-31 20:40:59+00:00",
                    "text": "This proposal seems unworkable to me. It means that a compiler that implements all but one minor feature of F2018 can't say it supports F2018. When you have a compiler such as gfortran that isn't even full F2003, yet has features from F2008 and F2018, what would you have it define?\nAs I wrote above. J3 did standardize a preprocessor and it was roundly ignored by the community. I have also observed that programmers are often misinformed about the revision of the standard they are using.\nI would like to see preprocessors die and would not want to put anything in the standard that encourages their use. They're useful today because the language lacks features such as robust generics/templates, but work in that area is progressing with some 202X features helping. Past use to deal with C interoperability is no longer necessary. If you feel you need to write different code for different compilers, it would better to use the greatest common subset and enhance that as the compilers you use catch up. The alternative feels like a testing and maintenance nightmare to me.\nA common strategy I have seen is to not use a feature that isn't supported in at least three compilers. I observe that this is likely to be less of a problem over the coming years as I see compilers catching up to the standard much more quickly than in the past 5-10 years."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-31 20:42:20+00:00",
                    "text": "@klausler yes, we should come up with conventions as a community.\nWill this macro change if you tell the compiler to stick with F2003 for example (like the -std=f2003 option for gfortran)? How are you imagining users would use this macro?\n\nI don't know of any use cases for limiting the compiler to an older standard, apart from wanting pre-2003 allocatable array assignment semantics, and there's better syntactic solutions (viz., A(:)=... rather than A=...) for that use case.  Do you?\nThe use for a __FORTRAN_STD__ predefined macro would be for making code that uses newer features conditional, for those cases where there's a less preferable approach that works with older standards that could be in an #else case.  It could also appear in programs that absolutely depend on newer features to provide more useful error messages:\n#if __FORTRAN_STD__ < 2008\n#error This program uses coarrays; get a newer Fortran compiler.\n#endif \n\nThat's something that I often do with C++ code that uses C++2017 features."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-31 21:04:00+00:00",
                    "text": "This proposal seems unworkable to me. It means that a compiler that implements all but one minor feature of F2018 can't say it supports F2018. When you have a compiler such as gfortran that isn't even full F2003, yet has features from F2008 and F2018, what would you have it define?\nAs I wrote above. J3 did standardize a preprocessor and it was roundly ignored by the community. I have also observed that programmers are often misinformed about the revision of the standard they are using.\nI would like to see preprocessors die and would not want to put anything in the standard that encourages their use. They're useful today because the language lacks features such as robust generics/templates, but work in that area is progressing with some 202X features helping. Past use to deal with C interoperability is no longer necessary. If you feel you need to write different code for different compilers, it would better to use the greatest common subset and enhance that as the compilers you use catch up. The alternative feels like a testing and maintenance nightmare to me.\nA common strategy I have seen is to not use a feature that isn't supported in at least three compilers. I observe that this is likely to be less of a problem over the coming years as I see compilers catching up to the standard much more quickly than in the past 5-10 years.\n\nI'm not proposing anything for the standard here.  I understand that you don't want to standardize preprocessing, and that you get to decide whether preprocessing is standardized or not.  Fine.\nBut preprocessing is still used in real codes by real users, it's part of every Fortran implementation, and I would like to provide the best implementation of preprocessing for them that I can in f18 in the absence of guidance from a standard."
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-31 22:46:11+00:00",
                    "text": "I understand that you don't want to standardize preprocessing, and that you get to decide whether preprocessing is standardized or not.\n\nNo, I don't get to decide. I am just one vote among all WG5. But as I have said, we already did standardize preprocessing (though this happened before I was on the committee) and it was ignored and has now been dropped from the standard. Nothing I or WG5 say will stop people from using preprocessing using the tools (cpp) they are already using."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-31 23:59:15+00:00",
                    "text": "I understand that you don't want to standardize preprocessing, and that you get to decide whether preprocessing is standardized or not.\n\nNo, I don't get to decide. I am just one vote among all WG5. But as I have said, we already did standardize preprocessing (though this happened before I was on the committee) and it was ignored and has now been dropped from the standard. Nothing I or WG5 say will stop people from using preprocessing using the tools (cpp) they are already using.\n\nDoes any production Fortran compiler actually use cpp?  It doesn't interact well with line continuation, line truncation, Hollerith, or (especially) INCLUDE.  I don't know of a compiler that preprocesses with a stock cpp.\nCoCo wasn't rejected by users and implementors because people didn't need or want preprocessing.  CoCo was a failure because it was gratuitously different from the C-like preprocessing and local tooling that people were already using, and it wasn't a better solution (in fact, it's really weird and ugly)."
                },
                {
                    "user": "sblionel",
                    "date": "2020-08-01 00:09:11+00:00",
                    "text": "I don't know what every compiler uses, but I often see cpp invoked with an option that better handles Fortran. ifort has its own fpp that accepts cpp directives. I think pretty much every Fortran in common use has something similar.\nMy point was that people are already using cpp or a cpp-like preprocessor that they already have. I agree that CoCo was \"gratuitiously different\", but what the users told us was that cpp (or cpp-like) was working for them."
                },
                {
                    "user": "klausler",
                    "date": "2020-08-01 00:37:24+00:00",
                    "text": "And if the common subset of the behaviors of Fortran-aware preprocessors (and built-in preprocessing phases) were to be documented, then both users and implementors would know what's portable and what's not.  This is exactly the sort of thing that should be in a de jure standard.  But that's not going to happen, and the best I could do for f18 was to determine that common subset myself, figure out the most reasonable behavior in edge cases where compilers differ, and ask users for guidance.   If you have better advice for an implementor, I'm all ears.\nEDIT: See here for a table of preprocessing behaviors of various compilers, using fixed and free form samples in this directory.  As one can see, things are not terribly compatible today, but there is a common portable subset."
                },
                {
                    "user": "certik",
                    "date": "2020-08-01 03:50:46+00:00",
                    "text": "@klausler I agree with you and I think the best we can do is to get a community / vendors consensus of what should be supported and document it. Most production Fortran codes that I have seen use macros in some form, and thus compilers must support them.\nThank you for taking the lead on that in the document you shared."
                },
                {
                    "user": "certik",
                    "date": "2021-03-05 05:07:57+00:00",
                    "text": "Here is a permanent link to the preprocessor documentation:\nhttps://github.com/llvm/llvm-project/blob/8a07c4a10b23acf05c6aaca2800081df56f44f82/flang/docs/Preprocessing.md"
                },
                {
                    "user": "certik",
                    "date": "2021-03-05 05:27:51+00:00",
                    "text": "We are currently figuring out how to add preprocessor support for LFortran. I can see that in Flang it is integrated into the compiler. I don't know if it is feasible to pre-process ahead of time (de-coupled from the compiler) and keep line numbers consistent, this is also relevant:\n\nLast, if the preprocessor is not integrated into the Fortran compiler, new Fortran continuation line markers should be introduced into the final text.\n\nThat would be my preferable approach, but I assume the down side are worse error messages and possibly it is slower?"
                },
                {
                    "user": "klausler",
                    "date": "2021-03-05 16:37:27+00:00",
                    "text": "In f18 the first phase of compilation is called prescanning.  It reads the original source file, and expands any INCLUDE or #include files, normalizes the source in many ways (preprocessing directives, macro expansion, line continuation, comment removal, space insertion for fixed form Hollerith, space removal / collapsing, case lowering, &c.) to construct a big contiguous string in memory.  This string is what the parser parses, and it makes parsing so much easier.  Each byte in that string can be mapped to its original source byte or macro expansion or whatever by means of an index data structure.  In the parser and semantics we just use const char * pointers to represent source locations in messages and the name strings of symbols, and those get mapped back to source locations for contextual error message reporting later."
                },
                {
                    "user": "aradi",
                    "date": "2021-03-11 08:42:55+00:00",
                    "text": "I think, it would be much more important, that all compiler accept and process #line directives in the source code. Then people can use whatever pre-processor suits their purpose most. As long as the preprocessor emits those directives (as for example Fypp does if requested), the user would always get correct error messages."
                },
                {
                    "user": "certik",
                    "date": "2021-03-11 17:59:33+00:00",
                    "text": "I think the #line directives only ensure the correct line is being reported, but if your pre-processor expands a macro, it changes the line itself, so the compiler will report an error on the expanded line that is not what the user sees before calling the pre-processor."
                },
                {
                    "user": "aradi",
                    "date": "2021-03-11 19:24:05+00:00",
                    "text": "No, if the source file is around, the compiler will show the right line. You can test it yourself.\ntest.F90:\n#:def ASSERT(cond)\n  #:if defined(\"DEBUG\")\n  $:cond\n  #:endif\n#:enddef\n\nprogram test\n  implicit none\n\n  #! expression is incorrect to trigger compiler error\n  @:ASSERT(1 ?= 2)\n\nend program test\n\nExecuting\nfypp -n -DDEBUG test.F90 > test.f90; gfortran test.f90\n\nyou obtain the error message:\ntest.F90:11:3:\n\n   11 |   @:ASSERT(1 ?= 2)\n      |   1\nError: Invalid character in name at (1)"
                },
                {
                    "user": "certik",
                    "date": "2021-03-11 20:14:37+00:00",
                    "text": "My bad, you are right. The only issue will happen if there is a syntax error in the expanded ASSERT macro, wouldn't it? Like this:\n:ASSERT(1 ?= 2)@\n\nI would expect it to show an incorrect column number."
                },
                {
                    "user": "aradi",
                    "date": "2021-03-12 13:01:50+00:00",
                    "text": "If the error occurs in the expanded text, the error message can be indeed confusing. E.g.\n#:def ASSERT(cond)\n  if (.invalid. ${cond}$) error stop \"Assert failed\"\n#:enddef\n\nprogram test\n  implicit none\n\n  @:ASSERT(1 == 2)\n\nend program test\n\nwith\nfypp -n  test.F90 > test.f90; gfortran test.f90\n\nresults in\ntest.F90:9:6:\n\n    9 |   @:ASSERT(1 == 2)\n      |      1\nError: Unknown operator \u2018invalid\u2019 at (1)\n\nIn this case, one would have to drop the line marker generation as with\nfypp test.F90 > test.f90; gfortran test.f90\n\nto obtain\ntest.f90:5:6:\n\n    5 |   if (.invalid. 1 == 2) error stop \"Assert failed\"\n      |      1\nError: Unknown operator \u2018invalid\u2019 at (1)\n\nBut, this is independent of, whether the pre-pocessor is external or built in into the compiler. Do you show the original line or the expanded line (or both), when the error occurs in an expanded code? Whichever strategy one goes for, it can be equally realized with built-in as well as with external pre-processors (provided they generate line marker directives and the compiler understands them)."
                },
                {
                    "user": "certik",
                    "date": "2021-03-12 15:09:25+00:00",
                    "text": "@aradi I am glad you posted here, I think you are right. Indeed the compiler could now about the pre-processor, as a black box, and it could show errors either in the expanded form, or unexpanded form, and in each way it would show the correct line.\nHow would it know the line comes from a macro expansion? Well, I guess once it found the line with the error in the expanded form, it can compare the unexpanded line (from the #line directive) and if it differs, it can show both, i.e. the error can look something like this:\ntest.f90:5:6:\n\n    5 |   if (.invalid. 1 == 2) error stop \"Assert failed\"\n      |      1\nError: Unknown operator \u2018invalid\u2019 at (1)\n\ntest.F90:9:6:\n\n    9 |   @:ASSERT(1 == 2)\n      |      2\nNote: the line at (1) where the error happens came from a macro expansion at (2)\n\nIf the line does not differ, then it can simply show the unexpanded form, as that will be the one which users see in their files.\nI think this might be a very acceptable approach, with the advantage that we can use different pre-processors, such as fypp.\nSummary of the black box approach:\n\nCorrect line and column numbers in the expanded form\nCorrect line, but potentially incorrect column number in the unexpanded form\n\nI can still see some potential advantages of integrating the pre-processor more deeply with the compiler:\n\nPotentially faster (no need to write a new source file out and to parse #line directives)\nIt knows which macro got expanded to what, so clang for example gives you error messages almost as if macros were part of the language itself\nPart of the previous point is that it will give you correct column numbers in the unexpanded form\n\nBut the black box approach is not bad, and one can implement both."
                },
                {
                    "user": "aradi",
                    "date": "2021-03-12 15:25:00+00:00",
                    "text": "@certik I fully agree. Yes, the column number will be incorrect in the unexpanded form. And yes, a tight integration can give even deeper insights. But that assumes the existence of a well defined (standardized) pre-processor language which all Fortran compilers implement and follow, and which covers all the pre-processing needs people may come up with. In the mean time, the line directives can serve as a \"bridging technology\", allowing the usage of custom pre-processors."
                },
                {
                    "user": "certik",
                    "date": "2021-03-12 15:43:17+00:00",
                    "text": "I created an issue at https://gitlab.com/lfortran/lfortran/-/issues/281 to implement this in LFortran."
                },
                {
                    "user": "klausler",
                    "date": "2021-03-12 16:46:23+00:00",
                    "text": "f18 -fsyntax-only ppdemo.f90\n./ppdemo.f90:2:10: error: Actual argument for 'x=' has bad type 'CHARACTER(1)'\n  print *, CALL(sin, 'abc')\n           ^^^^^^^^^^^^^^^^\n./header.h:1:1: in a macro defined here\n  #define CALL(f,x) f(x)\n  ^^\n./ppdemo.f90:1:1: included here\n  include \"header.h\"\n  ^^^^^^^^^^^^^^^^^^\nthat expanded to:\n  sin( 'abc')\n  ^\nf18: Semantic errors in ppdemo.f90\n\nI think that it's necessary to have an integrated preprocessing facility in the same part of the compiler that's handling INCLUDE statements, line continuation, case normalization, &c.  It's not hard to implement and it should be standardized."
                }
            ]
        },
        {
            "number": 64,
            "user": "gronki",
            "date": "2019-11-01 18:24:26+00:00",
            "title": "make \"exit\" work instead of \"return\" in subroutines",
            "text": "With strict requirement to define variables in the beginning of a code section, blocks are amazing construct to write self-explanatory code.\ncount_sheep: block\n  integer n\n  read (*, *) n\n  print '(i0, \" sheep on the roof\")', n\n  exit count_sheep\n  n = n - 1\n  print '(\"one sheep fell and \", i0, \" sheep remained\")', n\nend block count_sheep\n\nend\nIn this example, there's no need for comment as what the code does: it counts sheep. As easy to expect, the second line will not be printed as the block exits before a sheep falls off the roof. Another advantage of using blocks is that as the complexity grows it gives us the encapsulated code segment that is ready separate into a subroutine. The blocks statement can almost be treated like in-place subroutine which is called exactly once, and many of the behaviors (such as access and overriding global variables) are the same. However, this symmetry is not complete, as all exit statements have to been replaced with return:\nsubroutine count_sheep\n  integer n\n  read (*, *) n\n  print '(i0, \" sheep on the roof\")', n\n  exit count_sheep ! solution: replace this with return\n  n = n - 1\n  print '(\"one sheep fell and \", i0, \" sheep remained\")', n\nend subroutine count_sheep\n\ncall count_sheep()\n\nend\nThe return statement is a bit outdated, as its only purpose in modern Fortran is to exit the subroutine (the alternate returns are not used). In C, return is responsible for the return value of the procedure. However, in Fortran functions this works differently. So we are left with only one situation where return is used, while in other contexts (loops, blocks) exit is used.\nAlthough it seems like a minor detail and unnecesary burden, I think this solution would be very in the Fortran spirit, as it brings more explicit and cleaner programming.\nDominik",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-11-01 19:13:40+00:00",
                    "text": "As you yourself state, it does seem \"like a minor detail\",  Since change is slow in Fortran and there is  wait before something - especially if it has potential to impact semantics like the crucial RETURN statement in subprograms and/or EXIT in block constructs - gets introduced, the following \"burden\" might be another option in the long interim :\nsubroutine sub_count_sheep()\n   count_sheep: block\n     integer n\n     read (*, *) n\n     print '(i0, \" sheep on the roof\")', n\n     exit count_sheep\n     n = n - 1\n     print '(\"one sheep fell and \", i0, \" sheep remained\")', n\n   end block count_sheep\nend subroutine\n\nand many IDEs now allow the ability to create keystroke bindings to generate code from selected chunks which might ease such \"burden\" also."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-01 19:25:04+00:00",
                    "text": "Note that RETURN with alternate returns would be much more useful if it were possible to forward an incoming alternate return dummy argument as an outgoing alternate return label.  Many of the use cases for exception handling would be covered with safe deallocation and finalization if such forwarding were supported, and such support would be trivial to implement."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-01 19:31:34+00:00",
                    "text": "I think using any kind of numerical labels (format or instruction) is a big big no-no. Let 80s be 80s ;)"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-01 19:40:44+00:00",
                    "text": "I think using any kind of numerical labels (format or instruction) is a big big no-no. Let 80s be 80s ;)\n\nThink more generally about the idea and don't get distracted by the current syntax, which would be easy to prettify."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-01 20:32:56+00:00",
                    "text": "I still think that a proper but simple exception system (where error stop\nthrows an exception) would be easier to adopt and intuitive.\n\npt., 1 lis 2019, 20:40 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n I think using any kind of numerical labels (format or instruction) is a\n big big no-no. Let 80s be 80s ;)\n\n Think more generally about the idea and don't get distracted by the\n current syntax, which would be easy to prettify.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#64?email_source=notifications&email_token=AC4NA3MTXUQZXXKJAH6QBP3QRSA33A5CNFSM4JH6M3ZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEC362MQ#issuecomment-548924722>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3L6DFSMD4GO2VLMAMTQRSA33ANCNFSM4JH6M3ZA>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-02 12:37:36+00:00",
                    "text": "@klausler wrote:\n\nNote that RETURN with alternate returns would be much more useful if it were possible to forward an incoming alternate return dummy argument as an outgoing alternate return label. Many of the use cases for exception handling would be covered with safe deallocation and finalization if such forwarding were supported, and such support would be trivial to implement.\n\nI suggest using issue #66 for discussions on Exception Handling in Fortran."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-03 20:52:28+00:00",
                    "text": "This suggestion is the type we call \"syntactic sugar\" - it proposes an alternate syntax for something you can already do. Sometimes this makes sense when the alternative is cumbersome, but that's not the case here. Furthermore, it complicates the description of EXIT by making you look at what the label is before understanding what it does. I'd argue that this proposal makes code more confusing to the reader, not less."
                }
            ]
        },
        {
            "number": 63,
            "user": "arjenmarkus",
            "date": "2019-11-01 08:00:50+00:00",
            "title": "Allow multiple levels of internal routines",
            "text": "Just a thought: currently internal routines can not contain internal routines themselves. There is probably a good reason for that restriction, but I am unaware of it. Allowing internal routines to contain internal routines in turn may be useful in large programs or complicated tasks. Of course, it may also mean an inordinate additional complexity for compiler implementation.\nI would like to discuss the pros and cons for this idea.",
            "is_open": true,
            "labels": [
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-01 13:10:23+00:00",
                    "text": "I was also wondering about this. It might become a little bit hard to read if you nest subroutines a few times. That's the only reason I was able to think of."
                },
                {
                    "user": "tclune",
                    "date": "2019-11-01 13:35:05+00:00",
                    "text": "In general, the Fortran standard has made some \"interesting\" choices with regard to nesting of  language structures.      My guess aligns with Arjen's conjecture that the largest impediment is the difficulty of doing this in the compilers.     But the language in the standard may be tricky to change as well.\nAside from generality, though, is there a compelling use case where something reasonable cannot be done with a sibling internal procedure?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-11-01 15:38:28+00:00",
                    "text": "I have no compelling case myself, other than the feeling that it is a non-essential limitation."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-11-01 15:41:49+00:00",
                    "text": "As a side remark: though it may seem non-essential, that is not a good reason in itself of course to have it in the language. Tom may be quite right: a formal description and a thorough analysis of such a feature might very well lead to very convoluted language."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-01 19:28:56+00:00",
                    "text": "Multiple levels of nested subprograms (when used) would complicate the implementation of access to escaping host-associated variables."
                }
            ]
        },
        {
            "number": 62,
            "user": "certik",
            "date": "2019-11-01 02:14:49+00:00",
            "title": "DO CONCURRENT might be broken",
            "text": "@klausler reported in #60 (comment):\n\nDO CONCURRENT is fundamentally broken. It only guarantees to the compiler that the iterations of the loop can be run in any serial order. Its default localization rule (any variable read in an iteration will see the most recent value written in the same iteration, if any) prevents straightforward parallel execution.\n\nLet's discuss that here. @klausler, can you work with @gklimowicz to fix that? Gary has some proposals regarding \"do concurrent\". Or there is no way to fix this issue.",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-01 16:31:49+00:00",
                    "text": "See https://j3-fortran.org/doc/year/19/19-134.txt , which describes the problem and suggests a solution.  The Committee \"deferred\" this problem and hasn't wanted to discuss it since."
                },
                {
                    "user": "certik",
                    "date": "2019-11-04 19:29:22+00:00",
                    "text": "@klausler thanks a lot for submitting the proposal! Thanks also for commenting under the other issues. I am really sorry the committee didn't discuss this. Did they provide any feedback at all?"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 00:52:27+00:00",
                    "text": "I received no official response."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 01:14:25+00:00",
                    "text": "@klausler thank you. As a member of the committee, I apologize. This is unacceptable to me and I am trying to convince the committee that we need to consider every proposal that gets officially submitted (even if for just 5 to 10 minutes). In fact I was at the February 2019 meeting, but I don't recall what happened to your paper, as that was my first meeting and I was just trying to figure out how the committee works. Now when we have this GitHub repository, I plan to track every technical comment the committee makes in issues.\nIf it makes you feel any better, the committee didn't consider my proposal either (in #1). I know it happened to others too. I feel it's very inefficient, because had the committee provided feedback to you, you could have submitted a better paper for the October 2019 meeting, and so on, and we could have had this feature in a much more \"ready\" shape.\n@sblionel, here is an example of a proposal that I suggest the committee spends 5 to 10 minutes at plenary to discuss and then I volunteer to summarize the feedback in this issue here. I still think this would be the most efficient. But I would be fine with the alternative that multiple committee members provide feedback here directly in the issue and the committee does not officially consider any such proposals until later, as that would still be an improvement and it would move us in the right direction."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 17:51:50+00:00",
                    "text": "My problem, as an implementor, is that Fortran users expect from its name that DO CONCURRENT is sufficient to guarantee to the compiler that loop iterations can be safely executed in parallel; but the standard only suffices to guarantee that the iterations can be executed in arbitrary serial order.  What are my options?  (1) just parallelize it anyway; (2) provide an option or directive or extension to force parallelization in the face of unresolvable localizations; (3) emit a warning about unresolvable localizations and recommend the use of OpenMP directives instead?  People expect DO CONCURRENT to just mean \"do concurrently\", and it needs to be fixed or replaced so that it does."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 18:10:49+00:00",
                    "text": "@klausler I agree. Let's discuss it further. Your proposal has an example:\nSUBROUTINE FOO(N, A, B, T, K, L)\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: N, K(N), L(N)\n  REAL, INTENT(IN) :: A(N)\n  REAL, INTENT(OUT) :: B(N)\n  REAL, INTENT(INOUT) :: T(N)\n  INTEGER :: J\n  DO CONCURRENT (J=1:N)\n    T(K(J)) = A(J)\n    B(J) = T(L(J))\n  END DO\nEND SUBROUTINE FOO\nHow would this be written if your proposal is accepted? Using the LOCAL specifier."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 18:55:06+00:00",
                    "text": "I should correct this case; I intend T() to be dead after the loop.\nThe validity of this loop depends on the values of K() and L().  Today, this loop is valid if the elements of K() are pairwise distinct from each other and from the noncorresponding elements of L() (obviously), and also in the case that K(J)==L(J) for all J.  Even the extreme case of K(J)==L(J)==CONSTANT is fine.\nI would restrict DO CONCURRENT to be valid only under the first condition.  There's wouldn't be recourse to a LOCAL clause.  If you want the compiler to automatically localize a temporary variable, it would have to be an obvious whole variable, not an array element or pointer target or anything else whose identity could not be known until execution."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 19:46:44+00:00",
                    "text": "@klausler let's write down the actual examples, it's will be much easier for me (and I am sure others) to follow the arguments.\n\n\n\nK = [1, 2, 3]\nL = [4, 5, 6]\n\n\n\nK = [1, 2, 3]\nL = [1, 2, 3]\n\n\n\nK = [1, 1, 1]\nL = [1, 1, 1]\nCurrently 1., 2., and 3. are allowed. You are proposing for 1. and 2. to be allowed, but 3. to be forbidden (I corrected this sentence based on the comment below). Given that this depends on the values of the arrays K  and L, which are only known at runtime, how would the compiler enforce it?\nIsn't the idea of do concurrent that the user is responsible for ensuring that the loops are independent, which in many cases (such as this one) is impossible to do for the compiler, but quite possible for the user, since he knows his problem?"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 19:54:13+00:00",
                    "text": "@klausler let's write down the actual examples, it's will be much easier for me (and I am sure others) to follow the arguments.\nK = [1, 2, 3]\nL = [4, 5, 6]\n\nK = [1, 2, 3]\nL = [1, 2, 3]\n\nK = [1, 1, 1]\nL = [1, 1, 1]\n\nCurrently 1., 2., and 3. are allowed. You are proposing for 1. to be allowed, but 2. and 3. to be forbidden. Given that this depends on the values of the arrays K  and L, which are only known at runtime, how would the compiler enforce it?\nIsn't the idea of do concurrent that the user is responsible for ensuring that the loops are independent, which in many cases (such as this one) is impossible to do for the compiler, but quite possible for the user, since he knows his problem?\n\nNo, I'm proposing only that your third case be disallowed.  And I don't know what the original idea behind DO CONCURRENT was, but I think that the users and implementors that I deal with would agree with your characterization of the obligations that it places on the compiler and programmer (basically the same as an OpenMP parallel loop).  The bug in DO CONCURRENT is that the compiler has to allow for your third case and make it work, either by running the code serially or detecting it and handling it dynamically.\nEDIT: Your second case is fine as written; change it to K==L==[1,1,2] and it would be a better example of the condition I had in mind."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 20:02:20+00:00",
                    "text": "I corrected my comment above to match what you are proposing.\nRegarding your last edit K==L==[1,1,2], let's call this a case 4. Isn't case 4 the same as case 3 that should be disallowed? I am still a bit confused."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 20:15:50+00:00",
                    "text": "When all of the elements of K() are pairwise distinct, and distinct from all of the noncorresponding elements of L(), the loop is safe to parallelize.\nOtherwise, and this is the problem, DO CONCURRENT also permits elements of K() to match each other, so long as K(J)==L(J).  This is the problem.  (The case of all elements of K() and L() being the same value is a degenerate case of this second situation.)\nSo K==[1,2,3],L==[4.5,6] is fine; so are K==[1,2,3],L==[1,5,6] and K==[1,2,3],L==[1,2,3].\nBut K=[1,1,2],L=[1,1,2] should not be; nor should K==[1,1,1],L=[1,1,1], and these are the cases that I think should be invalidated."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 20:26:58+00:00",
                    "text": "Thank you. I think it is clear now which cases are allowed and which ones are not.\nLet's get some feedback from other members of the committee.\n@sblionel, do you know what the original idea behind do concurrent was and if what we are proposing here is aligned with it? See @klausler's previous comment: #62 (comment), and the rest of the discussion here.\nIf other members of the committee agree that this should be fixed, then the next step is to update the proposal. I am happy to help."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-05 20:52:13+00:00",
                    "text": "This discussion puzzles me somewhat, as I don't agree with some of the assertions made. However, this is not my area of expertise and I would prefer to see opinions of committee members more versed in parallelism, such as Bill Long of Cray.\nDO CONCURRENT was designed as a replacement for F95's FORALL as it was determined that FORALL's semantics made parallelism very difficult. The whole idea of DO CONCURRENT is that the iterations in any order and to any degree of parallelism, as the user promises there are no cross-iteration dependencies. There are already Fortran implementations that successfully parallelize DO CONCURRENT (Intel and probably Cray), so I don't really understand what the problem is. DO CONCURRENT was mainly modeled on OpenMP PARALLEL DO, especially with the F18 additions of locality clauses.\nI see that Peter's paper got \"deferred\" at the February 2019 meeting and not taken up again. I'm not a good person to discuss this with."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 21:42:06+00:00",
                    "text": "I suspect that the language in what is now 11.1.7.5 para. 4 (first bullet) was intended to handle cases like:\nDO CONCURRENT (J=1:N)\n  TMP = ...\n  ... = TMP\nEND DO\n\nby requiring the processor to automatically localize the obvious temporary TMP.  Unfortunately, the language is vague enough to also cover the cases that I've mentioned above where the \"variable\" in question can't be identified at compilation time.  It doesn't make a difference if the iterations of the loop are executed in some arbitrary serial order, but it does matter when parallelizing (or failing to parallelize because of the requirement in 11.1.7.5 para. 4, first bullet).\n(The specific language reads: If a variable has unspecified locality, \u2022 if it is referenced in an iteration it shall either be previously defined during that iteration, or shall not be defined or become undefined during any other iteration; if it is defined or becomes undefined by more than one iteration it becomes undefined when the loop terminates; ...)"
                },
                {
                    "user": "klausler",
                    "date": "2019-12-02 18:21:52+00:00",
                    "text": "This discussion puzzles me somewhat, as I don't agree with some of the assertions made. However, this is not my area of expertise and I would prefer to see opinions of committee members more versed in parallelism, such as Bill Long of Cray.\nDO CONCURRENT was designed as a replacement for F95's FORALL as it was determined that FORALL's semantics made parallelism very difficult. The whole idea of DO CONCURRENT is that the iterations in any order and to any degree of parallelism, as the user promises there are no cross-iteration dependencies. There are already Fortran implementations that successfully parallelize DO CONCURRENT (Intel and probably Cray), so I don't really understand what the problem is.\n\nI will try to make this as clear as I possibly can, using the example that I presented earlier.\nsubroutine foo(N, A, B, T, K, L)\n  implicit none\n  integer, intent(in) :: N, K(N), L(N)\n  real, intent(in) :: A(N)\n  real, intent(out) :: B(N)\n  real, intent(inout) :: T(N)\n  integer :: J\n  do concurrent (J=1:N)\n    ! During execution, K(J) and L(J) are both always 1.  So the store\n    ! and load to/from T() always affect T(1) in each iteration.  Since\n    ! T(1) is defined in each iteration before it is referenced, this\n    ! program conforms with F2008 and F2018.\n    T(K(J)) = A(J)\n    B(J) = T(L(J)) ! must be A(J) whenever K(J)==L(J)\n  end do\nend subroutine foo\n\nThis subroutine complies with all of the constraints and \"shalls\" in the Fortran 2018 standard that pertain to DO CONCURRENT.  But it cannot be executed in parallel and produce correct results.\nThis is because the DO CONCURRENT construct, despite its name, imposes restrictions on the program that are sufficient to guarantee that the iterations of the loop may be run in any sequential order.  The restrictions necessary to guarantee safe execution in arbitrary sequential order are not sufficient to guarantee safe execution in parallel.\nWhen ifort parallelizes this loop (ifort -parallel), it will fail during execution when placed in a test harness.  (Alternatively, when this subroutine appears in the same source file as the test harness, ifort will expand it inline and then refuse to parallelize it due to a correctly diagnosed data dependence.)\n\nDO CONCURRENT was mainly modeled on OpenMP PARALLEL DO, especially with the F18 additions of locality clauses.\n\nExcept that OpenMP PARALLEL DO imposes stricter restrictions on the loop, so that it can be safely executed in parallel.  DO CONCURRENT's restrictions are only strong enough to ensure safe serial execution in arbitrary order of iterations.  Perhaps it was believed that these weaker restrictions would be easier to comply with, and that a sufficiently smart compiler could apply automatic localization and then safely parallelize.  This turns out not to be the case, since a compiler can apply automatic localization only to variables that can be identified at compilation time.\n\nI see that Peter's paper got \"deferred\" at the February 2019 meeting and not taken up again. I'm not a good person to discuss this with.\n\nWhy not?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-02 20:04:19+00:00",
                    "text": "Why not?\n\nBecause I don't head J3, nor even the HPC subgroup under whose purview this would fall.\nAs I wrote above, I do not consider myself an expert on the parallel features - I have a general understanding but that is all. Bill Long of Cray is the person I consider most knowledgeable about parallelism, though there are others on the committee who seem to understand it well.\nI will ask Bill to take a look at this thread and see if he wants to offer an opinion."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-06-25 16:34:28+00:00",
                    "text": "@klausler your paper is written more as a feature request (this is the language of the standard, this is how I interpret the language, this is how it should be changed) when I think an interpretation request (this is the language of the standard, this is how I interpret the language, is my interpretation correct for that language, is my interpretation what was intended) would get more prompt attention."
                },
                {
                    "user": "klausler",
                    "date": "2020-06-25 17:47:15+00:00",
                    "text": "@klausler your paper is written more as a feature request (this is the language of the standard, this is how I interpret the language, this is how it should be changed) when I think an interpretation request (this is the language of the standard, this is how I interpret the language, is my interpretation correct for that language, is my interpretation what was intended) would get more prompt attention.\n\nIt's been 16 months, so prompt attention is a lost cause at this point.  As is J3.  I've removed myself from membership on that committee."
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-04 13:48:08+00:00",
                    "text": "I raised this question again yesterday on the J3 email list. You can read the thread here.  If I understand it correctly, these issues have been known for a while and are what prompted the addition in F2018 of the DEFAULT(NONE) locality specifier, as requiring the compiler to analyze the loop for possible sharing was difficult. The general opinion seems to be that explicitly specifying the locality of all variables is needed to enable parallelization, but that changing the F2008 behavior would break programs."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-04 16:28:27+00:00",
                    "text": "If anybody had tried to solve the problem of my specific example, they would have learned that the recently added locality clauses are not sufficient to its needs.  They accept only the names of whole variables (and, less important, can't distinguish between a pointer and its target)."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-04 17:46:34+00:00",
                    "text": "DO CONCURRENT's locality rules are broken even apart from parallelization concerns.\nIs the following a conforming program under Fortran 2018?\nPROGRAM ONE\nREAL :: A(2) = 0.\nINTEGER :: J\nDO CONCURRENT (J=1:2) SHARED(A)\nA(J) = A(J) + 1.\nEND DO\nPRINT *, A\nEND\nQuoting 11.1.7.5(3):\nIf a variable has SHARED locality, appearances of the variable within\nthe DO CONCURRENT construct refer to the variable in the innermost\nexecutable construct or scoping unit that includes the DO CONCURRENT\nconstruct. If it is defined or becomes undefined during any iteration,\nit shall not be referenced, defined, or become undefined during any\nother iteration.\nA has SHARED locality but is both defined and referenced in all iterations.\nIf A had unspecified locality (no SHARED(A) locality specifier), then\nparagraph (4) (first bullet point) would apply:\nIf a variable has unspecified locality, if it is referenced in an iteration\nit shall either be previously defined during that iteration, or shall not be\ndefined or become undefined during any other iteration; if it is defined or\nbecomes undefined by more than one iteration it becomes undefined when the\nloop terminates;\nAnd the program would not be conforming, both for referencing A in each\niteration without a prior definition, and for using the undefinied\nvariable after the termination of the loop.\nCan the word \"variable\" possibly refer to the elements of A, rather than\nto its entirety?  Elsewhere in subclause 11.1.7, there are sites in\nwhich the word \"variable\" clearly refers to whole arrays:\n11.1.7.5(2), emphasis added\nA variable that has LOCAL or LOCAL_INIT locality is a construct entity with\nthe same type, type parameters, and rank as the variable with the same\nname in the innermost executable construct or scoping unit that includes\nthe DO CONCURRENT construct, and the outside variable is inaccessible by\nthat name within the construct. ... If it is not a pointer, it has the\nsame bounds as the outside variable.\n11.1.7.5(4)\nIf a variable has unspecified locality, ... if it is noncontiguous and\nis supplied as an actual argument corresponding to a contiguous\nINTENT (IN OUT) dummy argument in an iteration, it shall either be\npreviously defined in that iteration or shall not be defined in any\nother iteration;"
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-04 18:05:04+00:00",
                    "text": "Peter, would you please ask this on the J3 email list, of which you're still a member? I think you'd get a more authoritative response there. But to answer the question, \"Can the word variable possibly refer to the elements of A\", the answer is yes. R902 defines variable as including designator and designator (R901) includes array-element.\nI admit it can be a bit confusing where sometimes variable names are mentioned (and thus excluding array elements), but in the places where it just says variable, then an array element qualifies. In your example, the variable reference is A(J), not A, and hence I would say that your example conforms, since no element of A is referenced or defined in more than one iteration."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-04 18:21:05+00:00",
                    "text": "Thanks for the reminder."
                },
                {
                    "user": "certik",
                    "date": "2020-07-06 15:51:43+00:00",
                    "text": "I just asked on the J3 mailinglist to clarify the main problem raised in this issue:\nhttps://mailman.j3-fortran.org/pipermail/j3/2020-July/012241.html"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 03:08:51+00:00",
                    "text": "@klausler here is an answer by Malcolm:\nhttps://mailman.j3-fortran.org/pipermail/j3/2020-July/012244.html\nIf I understand it correctly, he says that to get maximum performance, one has to do DEFAULT(SHARED). He provided some background and motivation why things are designed the way they are. He said \"We discussed them at great length.\" I wish the discussion was archived somewhere, so that we don't need to repeat it. But at least we are discussing this now and it is archived now."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-07 16:06:41+00:00",
                    "text": "@klausler here is an answer by Malcolm:\nhttps://mailman.j3-fortran.org/pipermail/j3/2020-July/012244.html\nIf I understand it correctly, he says that to get maximum performance, one has to do DEFAULT(SHARED). He provided some background and motivation why things are designed the way they are. He said \"We discussed them at great length.\" I wish the discussion was archived somewhere, so that we don't need to repeat it. But at least we are discussing this now and it is archived now.\n\nThere is no DEFAULT(SHARED) in Fortran.  It might be a good idea, but it's not in the language."
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-07 16:18:19+00:00",
                    "text": "Right - to me, DEFAULT(SHARED) is as bad as IMPLICIT. Much better to explicitly specify the localities of all the variables in the block."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-07 16:45:49+00:00",
                    "text": "The value of a DEFAULT(SHARED), if it actually were in the language, is that it would apply to variables that can't be named in an explicit locality specifier."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 19:55:14+00:00",
                    "text": "@klausler I am still confused: with the current Fortran Standard and your example, compilers are required to put in (potentially) costly runtime checks, or is there a way to write it using explicit locality specifiers to parallelize efficiently?"
                },
                {
                    "user": "klausler",
                    "date": "2020-07-07 21:00:54+00:00",
                    "text": "@klausler I am still confused: with the current Fortran Standard and your example, compilers are required to put in (potentially) costly runtime checks, or is there a way to write it using explicit locality specifiers to parallelize efficiently?\n\nIt depends.   If the loop is safe to parallelize in a straightforward manner -- any object that is modified is neither referenced nor modified in any other iteration -- and any potential cases that might be ambiguous due to the crazy default localization rule are confined to objects with simple names, then an explicit SHARED locality specifier would resolve the problem and permit parallelization.  That probably covers my original example, depending on the contents of the indirect indexing arrays.\nFor cases involving objects that don't have simple names, it's not clear.  (Take my original example, but make T a  component.)  This is why I said that the DEFAULT(SHARED) that Malcolm told you to use would be an improvement, if it existed in the language.\nIf there were a locality specifier (or other syntax) that changed the treatment of variables with unspecified locality so that the compiler would automatically localize only variables that were simple names of scalars, that would solve the problem."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-13 02:51:35+00:00",
                    "text": "@klausler  I'm teaching two Fortran training courses over the next 4 weeks and would greatly benefit from hearing any advice I could give attendees regarding do concurrent.  I was planning to recommend that every do concurrent contain a default(none), but I see your comment above that this is insufficient because of limitations on what can appear in the locality specifiers.  Is there some non-trivial class of problems for which users can reasonably expect a compiler to be able to optimize do concurrent, whether by vectorization, parallelization, or offloading?   For example, I think you've mentioned in separate correspondence with me that the problem that arises in the code you provided in comment 560517989 above would not occur in code that makes no use of indirect addressing or pointers.  I think there are many structured-grid scientific computing calculations that can be done without such features so it's not a severe restriction.  (By contrast, it's probably very hard to write unstructured-grid codes without indirect addressing or pointers.) Could a programmer reasonably expect that a compiler could effectively optimize  a do concurrent loop with no indirect addressing, no pointers, and with a default(none) clause?  If not, is there any class of problems for which developers can reasonably expect a compiler to optimize do concurrent or are all bets off because of the issues discussed in this thread?"
                },
                {
                    "user": "klausler",
                    "date": "2020-07-13 15:45:22+00:00",
                    "text": "I don't know of a Fortran compiler that recognizes the locality specifiers yet; the latest Intel compiler doesn't, anyway.  So even if they fixed the problems with default locality, your students would probably have to wait to use them.  This also applies to Malcolm Cohen's suggestion to use DEFAULT(SHARED), which isn't even in the language.\nI suggest that you treat DO CONCURRENT as a convenience for writing multidimensional iteration spaces with a single construct, no more.  I don't think that the implementations or standard for Fortran can help your parallelize sparse matrix codes without recourse to directive-based solutions.  For codes without pointers or indirection, one can try DO CONCURRENT and see if it works, but be ready to resort to directives on good old DO where it doesn't.  It's not performance portable."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 16:04:04+00:00",
                    "text": "@klausler so coming to your original example, the following code would require runtime checks (thus not efficient), but it would work for any arrays K and L:\nSUBROUTINE FOO(N, A, B, T, K, L)\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: N, K(N), L(N)\n  REAL, INTENT(IN) :: A(N)\n  REAL, INTENT(OUT) :: B(N)\n  REAL, INTENT(INOUT) :: T(N)\n  INTEGER :: J\n  DO CONCURRENT (J=1:N)\n    T(K(J)) = A(J)\n    B(J) = T(L(J))\n  END DO\nEND SUBROUTINE FOO\nOn the other hand, the following code would parallelize well, but it is now the responsibility of the user to ensure that the arrays K and L do not introduce data races (e.g., are not of the type K=[1,1,2],L=[1,1,2]and similar):\nSUBROUTINE FOO(N, A, B, T, K, L)\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: N, K(N), L(N)\n  REAL, INTENT(IN) :: A(N)\n  REAL, INTENT(OUT) :: B(N)\n  REAL, INTENT(INOUT) :: T(N)\n  INTEGER :: J\n  DO CONCURRENT (J=1:N) DEFAULT(NONE) SHARED(T, A, B, K, L, N) LOCAL(J)\n    T(K(J)) = A(J)\n    B(J) = T(L(J))\n  END DO\nEND SUBROUTINE FOO\nIs the above analysis correct?"
                },
                {
                    "user": "klausler",
                    "date": "2020-07-13 16:16:16+00:00",
                    "text": "Surely you don't need to specifiy locality for K, L, or A -- they are not defined in the loop.  I don't read DEFAULT(NONE) to mean that the locality of variables that are merely referenced, not defined, has to be specified -- if so, it's crazy.  I'm also not sure whether it's allowed or necessary to specify the name of a loop index like LOCAL(J) -- that is at best redundant.\nDeclaring SHARED(T) makes a promise that T is not defined in any iteration and then referenced or defined in any other.  Whether that applies to the elements of T is not explicit in the standard, but it should be.  T is obviously defined and referenced in every iteration.  But if we use the obvious intent of the standard rather than the actual wording, and if it is true that no element of T (or B) that is defined in one iteration is referenced or defined in another, then the loop is trivially parallelizable."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-13 16:28:00+00:00",
                    "text": "@klausler Intel recently issued a beta release that is fully Fortran 2018 compliant so should support the locality specifiers.  For anyone interested in testing it, Intel's beta release includes two compilers:\n\nifort: Fortran 2018 compiler (the final release in this product line), which is in the oneAPI beta07.\nifx: LLVM-based Fortran 90 compiler (the beginning of a new product line).\n\nBelow are the links you'll need to access the beta compilers.  There is no license needed.   You will need two toolkits:\n\n\nFirst install \"Intel(R) oneAPI Base Toolkit(Beta)\":\nhttps://software.intel.com/content/www/us/en/develop/tools/oneapi/base-toolkit.html\n\n\nThen install \"Intel(R) oneAPI HPC Toolkit\":\nhttps://software.intel.com/content/www/us/en/develop/tools/oneapi/hpc-toolkit.html"
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 16:40:53+00:00",
                    "text": "@klausler it seems there is confusion about the meaning of the Fortran Standard. But if we rewrite the code to use OpenMP:\nSUBROUTINE FOO(N, A, B, T, K, L)\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: N, K(N), L(N)\n  REAL, INTENT(IN) :: A(N)\n  REAL, INTENT(OUT) :: B(N)\n  REAL, INTENT(INOUT) :: T(N)\n  INTEGER :: J\n  !$OMP PARALLEL DEFAULT(NONE) SHARED(T, A, B, K, L, N) PRIVATE(J)\n  !$OMP DO\n  DO J = 1, N\n    T(K(J)) = A(J)\n    B(J) = T(L(J))\n  END DO\n  !$OMP END PARALLEL\nEND SUBROUTINE FOO\nThen we can use, e.g., GFortran with the -fopenmp option to compile it. With GFortran, you can remove the PRIVATE(J), but if you remove any of the K, L or A, you will get an error like:\na.f90:11:0:\n\n     T(K(J)) = A(J)\n \nError: \u2018a\u2019 not specified in enclosing \u2018parallel\u2019\na.f90:8:0:\n\n   !$OMP PARALLEL DEFAULT(NONE) SHARED(T, B, K, L, N)\n \nError: enclosing \u2018parallel\u2019\n\nBut this issue aside, in the above code, does the SHARED(T) apply to elements of T? If so, then the user is responsible to ensure that elements of T \"are not defined in any iteration and then referenced or defined in any other\", and the compiler will parallelize this efficiently?"
                },
                {
                    "user": "klausler",
                    "date": "2020-07-13 16:50:53+00:00",
                    "text": "But this issue aside, in the above code, does the SHARED(T) apply to elements of T? If so, then the user is responsible to ensure that elements of T \"are not defined in any iteration and then referenced or defined in any other\", and the compiler will parallelize this efficiently?\n\nDoes SHARED(T) apply to the elements of T?  Clearly that's the intent, but I'm not sure whether the specification in the standard makes that clear.  What if T were a derived type with an array component -- would the locality specifier apply to the component?  What if T were a pointer -- would it apply to the pointer, or its target, or both?  It needs further work.\nIs the user guaranteeing to the compiler that the stores to the elements are safe to parallelize?  Yes, that's the point.\nWill the compiler parallelize it efficiently?  That's up to the implementation, of course.  But at least there shouldn't be any remaining need to generate code to resolve ambiguous \"all equals\" data dependences at runtime -- forwarding from stores to loads in the same iteration will either be via localized names or nonconflicting shared elements."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 17:09:36+00:00",
                    "text": "Even the assignment to B(J) = ... assumes that SHARED(B) applies to elements of B (as guaranteed by the user), doesn't it? Otherwise the compiler would either have to figure out that the elements are independent (which in this case it can, but not in general), or insert runtime checks.\nRegarding the derived type, I would assume as the user that the locality specifier applies to all components."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-13 18:19:49+00:00",
                    "text": "Even the assignment to B(J) = ... assumes that SHARED(B) applies to elements of B (as guaranteed by the user), doesn't it? Otherwise the compiler would either have to figure out that the elements are independent (which in this case it can, but not in general), or insert runtime checks.\n\nB is not referenced in the loop, and if (an element of) B is defined by more than iteration of the loop it may not be referenced afterwards the termination of the loop -- so there's really nothing for a compiler to do with it."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-14 02:57:44+00:00",
                    "text": "@sblionel Do you think there would be any support for designing a new feature that would be trivially distinct from do concurrent syntactically but would have semantics that compiler developers agree would be more amenable to optimization?  I'm imagining something like simply replacing concurrent with independent or some other word but keeping the syntax otherwise identical,  changing the default localization rules, and adding any other semantic restrictions that compiler developers agree would facilitate  optimizations such as vectorization, parallelization, or offloading are feasible."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-14 02:59:44+00:00",
                    "text": "@certik  I wonder if it would make sense to prototype my above suggestion in an open-source compiler or interpreter?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 03:08:39+00:00",
                    "text": "Yes! I am sure Peter would be happy to help with Flang also. I have two summer students working on this very exact issue also for LFortran. Peter, Damian and Steve, would you be interested in a video call to get us on the same page?\n\nIn general this is one of the most important issues to get right in Fortran, and the main reason why people move away from Fortran around me.\n\u2026\nOn Mon, Jul 13, 2020, at 8:59 PM, Damian Rouson wrote:\n\n\n @certik <https://github.com/certik> I wonder if it would make sense to\n prototype my above suggestion in an open-source compiler or interpreter?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#62 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWFQYD3MQJT57YNSPRLR3PC2ZANCNFSM4JHVFRYA>."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-14 03:15:39+00:00",
                    "text": "@certik yes, I would be very interested in joining a call.  Scheduling it will be challenging: if it's not within the next 2 days, I probably won't be able to join until the week after next.  There's also a new gfortran developer who expressed interest in working on do concurrent so we should invite him too."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-14 16:42:33+00:00",
                    "text": "We're still figuring out how we're going to move ahead on this in f18 given J3's lack of a useful response.  Options range from command-line flags and inline directives to new syntax.  For example, f18 could assume better default locality rules by default and add a -fstd-do-concurrent flag to opt out.  Or add a DO PARALLEL with the fixed semantics and let the user use the preprocessor to port to it (-Dconcurrent=parallel) or away (-Dparallel=concurrent).  We'll keep you posted.  I don't think that a call would be terribly helpful at this point."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-14 17:06:28+00:00",
                    "text": "@klausler To quote a feature request that I once submitted to Intel, \"Please, I'm\nbegging you to make standard behavior the default.\"  I can't count how many\nhours of my life I've lost searching for a bug that turned out not to be a\nbug but was instead a compiler making non-standard behavior the default\nbehavior.  It's really frustrating for anyone who uses multiple compilers\nand expects the compiler to support the standard without the programmer\nhaving to search for the proper flag to enforce the standard.  At an\nabsolute minimum, I'd hope there would be one all-encompassing flag like\nIntel has \"--standard-semantics,\" but even that only reduces the\nfrustration rather than eliminating it because one still has to remember to\nadd that to every project in which one uses a given compiler."
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-14 17:30:36+00:00",
                    "text": "@klausler , what exactly would be a \"useful response\" from J3? Three J3 members have explained in detail the situation and how the F18 locality specs essentially solve the problem, if programmers use them. It was also explained that the issues you raised had previously been discussed in detail. I'm failing to understand the continued antipathy here.\n@rouson , I have said often that parallelism is not one of my strengths, so I rely on the advice and opinions of others who live this stuff. My (perhaps flawed) understanding is that as of F18, DO CONCURRENT enables more parallelism than F08 did. I know it is following what OpenMP did, and I have to believe that the folks developing OpenMP know what they are doing. I also have faith in J3, with representatives from multiple HPC compiler vendors, that DO CONCURRENT does what compiler vendors want for parallelism.\nI have not yet seen any evidence that yet another parallel construct adds any value. The Fortran standard does not attempt to solve 100% of any possible programmer need. There is a balance between complexity and usability. Consider RANDOM_NUMBER, for an example of something I understand better. Does the spec for RANDOM_NUMBER satisfy every numerical analysis or statistical developer? Of course not, as some might want different distributions, etc., but it works well for a lot of cases. For those where it doesn't, there are libraries.\nRegarding your asking Intel to make standard-conforming behavior the default - you're unlikely to get that from a long-history commercial compiler, as the howls from paying customers will be loud. As you note, Intel has a single flag that does what you want, and even offers a way to set this system-wide (or user wide). Intel has changed defaults in places where it could be done transparently, such as automatic reallocation on assignment.\nThere's a related discussion going on in comp.lang.fortran where a couple of users are bashing the (few remaining) gfortran developers for having the temerity to have the compiler check by default for violation of standard rules that have been in place since F66. At least these are compile-time messages for violations of the standard - think of what the response would be if programs that were standard-conforming before (because the standard didn't specify something) behaved differently at run-time without any obvious cause.\nThe Fortran standard has always been in the position of asking the programmer to follow certain rules, and if they do, then they are rewarded with expected behavior. The rules for DO CONCURRENT about definition changes across iterations are there to allow compilers to parallelize, and there exist compilers that can and do parallelize these when the rules are followed. I don't pretend to claim that every possible loop body can be parallelized, but my understanding is that the current syntax and rules are good enough for most usages. If one wants even more control, then look at OpenMP. I can't find much enthusiasm for examples of constructs that have always been difficult to parallelize, even with the most capable of methods."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-14 19:01:43+00:00",
                    "text": "The response that came closest to a solution involved syntax (DEFAULT(SHARED)) that strengthens the stipulations from the program(mer) about the lack of any need for the default localization rules in order to safely execute iterations in parallel.  But DEFAULT(SHARED) doesn't exist in the language, and would necessitate wordy and error-prone LOCAL() specifiers for non-shared variables (or BLOCK).  A DO CONCURRENT plus DEFAULT(SHARED) with further automatic localization for the obvious scalar variable names that are unconditionally defined in each iteration would solve the problem.  DEFAULT(SHARED_EXCEPT_NO_BRAINER_SCALARS) seems like too much typing, though.\nThe discussion on comp.lang.fortran about extant code that associates scalar actual arguments with dummy arrays across implicit interfaces exposes the distinction between de facto and de jure standards.   IMO, something that's worked for decades with mulitple compilers is not something that should be messed with absent very good reasons.  Nobody really benefits when something universally used like NetCDF stops compiling."
                },
                {
                    "user": "rouson",
                    "date": "2020-07-14 23:41:45+00:00",
                    "text": "@klausler if the problems you raised could be addressed by adding a new default(...) clause, then that seems like a lot of bang for the buck.   My understanding is that it was once common for features to start as compiler extensions before entering the standard.   I would definitely give such an extension a try if it appears in a compiler.  It seems like something that would be very easy to incorporate via preprocessor macros when working with a compiler that supports it. I would also back a proposal for such a feature at the appropriate time (presumably 202Y)."
                },
                {
                    "user": "klausler",
                    "date": "2020-08-27 17:39:00+00:00",
                    "text": "https://reviews.llvm.org/D86556\nWe\u2019re still trying to figure out what we\u2019re going to do with DO CONCURRENT in f18 (flang). I wrote a short documentation file to describe its basic problem: a programmer writing parallel code with DO CONCURRENT may not enjoy parallel execution because the standard imposes weaker requirements on the body of DO CONCURRENT that suffice only to allow safe serial execution of iterations in arbitrary order, and a compiler can assume only that those weaker requirements have been respected and thus has no general way to know that concurrency is safe \u2013 even when the programmer knows that it is.\nPlease let me know where the note can be made more clear, correct or complete. I\u2019m trying to summarize the problems in one place in the source base to which we can direct new users in the future when they need to know why DO CONCURRENT isn\u2019t working as one might expect. If you have LLVM reviewing permissions, you can comment in place if you like. Thanks!"
                },
                {
                    "user": "rouson",
                    "date": "2020-09-06 06:49:45+00:00",
                    "text": "Hi Peter,\n\nThanks for writing this.  I'll copy the list of solutions under\nconsideration, (re)number them, and intersperse comments and questions.\n\n1. Add syntax (e.g., `DO PARALLEL` or `DO CONCURRENT() DEFAULT(PARALLEL)`)\n   by which we can inform the compiler that it should localize only\n   the obvious cases of simple local scalars.\n   Such syntax seems unlikely to ever be standardized, so its usage\n   would be nonportable.\n\nThis would be my first choice, especially given the historical precedents\nfor features being supported first as extensions before becoming part of\nthe standard.  Coarray features might be the most appropriate precedent\nbecause they relate to parallelism.  Didn't Cray support coarrays for years\nbefore they became standard?  I imagine it was a much heavier lift to get\nall the coarray features into the standard than either of the above\nchoices. In the interim, a preprocessor could easily switch either of the\nabove to standard syntax.\n\n2. Add a command-line option &/or a source directive to stipulate\n   the stronger guarantees.  Obvious non-parallelizable usage in the\nconstruct\n   would elicit a stern warning.  The `DO CONCURRENT` loops in the source\n   would continue to be portable to other compilers.\n\nThe command-line option would be my third choice, but it's really not such\na bad choice.  The code would remain standard and portable and anyone\nserious about optimizing code is likely to spend time investigating the\ncommand-line options for each compiler they use.  I'd rather not clutter\nthe code with compiler-specific directives, especially if other compilers\ngo down a similar path but choose different syntax.  If the directive\napproach is taken, I hope the directive is a potential candidate for\ninclusion into the OpenMP standard, but that seems a lot less likely than\ngetting option 1 into the Fortran standard.\n\n3. Assume that these stronger conditions hold by default, and add a\ncommand-line\n   option &/or a source directive to \"opt out\" back to the standard\n   behavior in the event that the program contains one of those\n   non-parallelizable `DO CONCURRENT` loops that should never have\n   been possible to write in a conforming program in the first place.\n   Programmers writing parallel `DO CONCURRENT` loops would get what\n   they wanted without ever knowing that there's a problem with the\n   standard.\n   But this could lead to non-standard behavior for codes that depend,\n   accidentally or not, on non-parallelizable implicit localization.\n\nAs I mentioned previously, I can't count the number of hours of my life\nthat I've lost looking for a bug in my code only to find eventually that\nthere was no bug.  I had just forgotten to pass a flag to get the compiler\nto comply with the standard.  I beg you to make standard behavior the\ndefault behavior.\n\n4. Accept the standard as it exists, do the best job of automatic\n   parallelization that can be done, and refer dissatisfied users to J3.\n   This would be avoiding the problem.\n\nThis would be my second choice.  I think of this as being embedded in the\nfirst option.  Create a new syntax that does what you want and accept the\nstandard as is when users choose the standard syntax.\n\nI hope this is helpfu.\n\nDamian\n\u2026\nOn Thu, Aug 27, 2020 at 10:39 AM Peter Klausler ***@***.***> wrote:\n https://reviews.llvm.org/D86556\n\n We\u2019re still trying to figure out what we\u2019re going to do with DO CONCURRENT\n in f18 (flang). I wrote a short documentation file to describe its basic\n problem: a programmer writing parallel code with DO CONCURRENT may not\n enjoy parallel execution because the standard imposes weaker requirements\n on the body of DO CONCURRENT that suffice only to allow safe serial\n execution of iterations in arbitrary order, and a compiler can assume only\n that those weaker requirements have been respected and thus has no general\n way to know that concurrency is safe \u2013 even when the programmer knows that\n it is.\n\n Please let me know where the note can be made more clear, correct or\n complete. I\u2019m trying to summarize the problems in one place in the source\n base to which we can direct new users in the future when they need to know\n why DO CONCURRENT isn\u2019t working as one might expect. If you have LLVM\n reviewing permissions, you can comment in place if you like. Thanks!\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#62 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ADEANBFGPRZAWAKPZ6FHXRTSC2K4FANCNFSM4JHVFRYA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-09-06 21:38:25+00:00",
                    "text": "In my opinion none of these options are ideal.\nI think the ideal solution is to bring this back to the Fortran Standard Committee and have serious discussion about what the problem is and how to fix that, and then fix it."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-08 16:18:51+00:00",
                    "text": "Damian: Thanks for your response.\nAre you using DO CONCURRENT to write parallel code?"
                },
                {
                    "user": "rouson",
                    "date": "2020-09-08 17:04:08+00:00",
                    "text": "Hi Peter,\n\nI use DO CONCURRENT for what it communicates to the reader and for the\ndiscipline it imposes on the programmer.  I would love it if that then also\nleads to performance improvements, whether they be by parallelization or\nvectorization or offloading.  Short of that, I would also be satisfied if\nOpenMP can be used to parallelize or vectorize or offload DO CONCURRENT in\nthe absence of the compiler doing it automatically.  I just submitted a\nproposal to do work for a government agency wherein performance\nimprovements associated with DO CONCURRENT could play a very useful role --\nagain whether by compiler automation or via OpenMP.\n\nDamian\n\u2026\nOn Tue, Sep 8, 2020 at 9:19 AM Peter Klausler ***@***.***> wrote:\n Damian: Thanks for your response.\n\n Are you using DO CONCURRENT to write parallel code?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#62 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ADEANBDAB5QWF62YYPDNVMLSEZKPZANCNFSM4JHVFRYA>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-08 17:13:36+00:00",
                    "text": "What do you think that \"it [DO CONCURRENT] communicates to the reader\"?"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-08 17:22:39+00:00",
                    "text": "In my opinion none of these options are ideal.\nI think the ideal solution is to bring this back to the Fortran Standard Committee and have serious discussion about what the problem is and how to fix that, and then fix it.\n\nOh, sure; all of these options are competing for \"second best\", under the assumption that J3 doesn't fix DO CONCURRENT."
                },
                {
                    "user": "rouson",
                    "date": "2020-09-08 17:34:05+00:00",
                    "text": "It communicates that all of the constraints in the standard apply.  As\nexamples, it communicates that every procedure invoked is PURE and there\nare no segment-ordering statements.\n\nAs a general rule, if one program statement covers a subset of the cases\nthat another program statement covers, I choose the more specific one in\nhopes that doing so decreases the time it takes for the reader to\nunderstand the code.  I think of DO CONCURRENT as covering a subset of the\nloops that can be written with just DO so I start with DO CONCURRENT but\nresort to DO when I have a compelling reason to do so.\n\nSimilarly, I think of SELECT CASE as covering a subset of the conditional\nbranching that can be accomplished with IF THEN... ELSE IF... ELSE... END\nIF.  Choosing the more specific statement communicates information that\nmight otherwise require the reader to read through each branch to discover\nthe logic of the branching.\n\nDamian\n\nP.S.  On a related note, I just completed an exercise in co-developing a\nmini-app in which we attempted to take functional programming to a logical\nextreme: with the exception of I/O procedures, every procedure in the\nmini-app is a PURE function with no local variables -- just associations\nwherein a name is associated with a function result or expression and is\ntherefore immutable state.  I was surprised at just how far this got us and\nwith the ultimate clarity of the code.  At just of shy of 1,500 lines, it\nwas the longest code I've ever written that worked almost flawlessly on\nfirst testing.  This experience emboldens me to write PURE functions more\nand more and one benefit will be that all of my functions can be invoked\ninside DO CONCURRENT.  I suspect that code written in this style will be\nmuch easier for the programmer to parallelize even in the absence of\nautomatic compiler parallelization.  One of the first places I encountered\nthe notion that functional programming aids parallelization was in a 1991\nLawrence Livermore technical report entitled \"Retire Fortran? A debate\nrekindled.\"  It's fascinating to me just how much of what that paper was\ncalling for in a new language (SISAL) instead resembles what Fortran\neventually became.\n\nEdit by @certik: here is the report: https://doi.org/10.1145/135226.135231"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-08 18:04:05+00:00",
                    "text": "Thanks, that helps.  I agree that programs should use PURE wherever they can do so.  But in the context of DO CONCURRENT, the purity requirement is not an end in itself, but a means to another end, namely concurrency.  The language shouldn't define DO CONCURRENT in such a way as to exclude a long list of concurrency-breaking behavior without making the list complete -- that punishes the programmer who is writing concurrent code but is still not rewarded with concurrency because a compiler can't assume that following the rules in the standard is sufficient."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 18:24:38+00:00",
                    "text": "@klausler thanks for your efforts and I agree with you this is the second best.\nAs we get more experience as a community with using do concurrent in codes, I think Damian, myself and others will be able to bring any potential limitations to the committee to get further discussed and fixed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 19:15:10+00:00",
                    "text": "After seeing all the discussions around this, I am now under the following impression. The standard chose to use DO CONCURRENT but only specified constraints for (and if we had a time machine should have used) DO UNORDERED. It seems many (if not most) people assumed that the constraints actually were sufficient to allow for parallelism, but it would seem to be highly unlikely the committee would \"break existing code\" by adding constraints to DO CONCURRENT. Thus it seems we will need to introduce (and I would be in favor of) a new keyword to allow a way of specifying constraints sufficient for parallelism, most likely DO PARALLEL.\nOf course, for those of us who considered concurrent and parallel to be synonyms it makes the language a bit more confusing, but is probably the only truly backwards compatible way to get the necessary constraints added. It seems to me quite similar to the way PURE procedures don't have sufficient constraints, hence the proposal to introduce SIMPLE procedures."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-08 19:22:54+00:00",
                    "text": "After seeing all the discussions around this, I am now under the following impression. The standard chose to use DO CONCURRENT but only specified constraints for (and if we had a time machine should have used) DO UNORDERED. It seems many (if not most) people assumed that the constraints actually were sufficient to allow for parallelism, but it would seem to be highly unlikely the committee would \"break existing code\" by adding constraints to DO CONCURRENT. Thus it seems we will need to introduce (and I would be in favor of) a new keyword to allow a way of specifying constraints sufficient for parallelism, most likely DO PARALLEL.\nOf course, for those of us who considered concurrent and parallel to be synonyms it makes the language a bit more confusing, but is probably the only truly backwards compatible way to get the necessary constraints added. It seems to me quite similar to the way PURE procedures don't have sufficient constraints, hence the proposal to introduce SIMPLE procedures.\n\nSee subclause 4.3.3 in Fortran 2018 for some precedents in which features from earlier standards are disallowed, including some features from DO CONCURRENT.  Backward compatibility to mistakes is fixable."
                },
                {
                    "user": "klausler",
                    "date": "2020-11-18 00:01:41+00:00",
                    "text": "I've checked in a description of the outstanding problems with DO CONCURRENT in the LLVM documentation.  Still not sure what we're going to do in the flang compilers -- there's good arguments for both standard conformance as well as for just doing the right thing."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-11-18 01:53:55+00:00",
                    "text": "@klausler wrote Nov. 17, 2020 7:01 PM EST:\n\n.. Still not sure what we're going to do in the flang compilers -- there's good arguments for both standard conformance as well as for just doing the right thing.\n\nc.f. https://mailman.j3-fortran.org/pipermail/j3/2020-July/012244.html where J3 \"effectively\" suggested something which is not yet in the standard.\nSo, is it possible for flang compilers to do both!?\nThat is, first have a standard-conforming implementation of DO CONCURRENT.\nBut then also consider an \"Experimental\" edition of flang compiler(s) that attempts to do the \"right thing\", perhaps via a \"DEFAULT(SHARED)\" or some suitable extension that is Fortrannic and which can then be proposed for Fortran 202Y as further improvement to be incorporated into the standard?"
                },
                {
                    "user": "klausler",
                    "date": "2020-11-18 02:27:06+00:00",
                    "text": "@klausler wrote Nov. 17, 2020 7:01 PM EST:\n\n.. Still not sure what we're going to do in the flang compilers -- there's good arguments for both standard conformance as well as for just doing the right thing.\n\nc.f. https://mailman.j3-fortran.org/pipermail/j3/2020-July/012244.html where J3 \"effectively\" suggested something which is not yet in the standard.\nSo, is it possible for flang compilers to do both!?\nThat is, first have a standard-conforming implementation of DO CONCURRENT.\nBut then also consider an \"Experimental\" edition of flang compiler(s) that attempts to do the \"right thing\", perhaps via a \"DEFAULT(SHARED)\" or some suitable extension that is Fortrannic and which can then be proposed for Fortran 202Y as further improvement to be incorporated into the standard?\n\nAnything is possible, but these are all just second-best alternatives to J3 just fixing the problems."
                }
            ]
        },
        {
            "number": 61,
            "user": "rweed",
            "date": "2019-10-31 13:53:58+00:00",
            "title": "Add deallocate/reallocate option to ALLOCATE",
            "text": "This idea was originally proposed a few months back on C.L.F. b someone else so I'm echoing it here\nAdd an optional deallocate/reallocate logical argument to ALLOCATE to tell it to check allocation status of any variable in its allocate list and deallocate it prior to allocating to a new size if it is already allocated.\nExample\nInstead of having to code\nIf (ALLOCATED(A)) DEALLOCATE(A)\nALLOCATE(A(N))\ndo\nALLOCATE(A(N), REALLOCATE=.TRUE.) or\nALLOCATE(A(N), DEALLOCATE=.TRUE.) ! either syntax works for me\nBasically you are telling the compiler to check allocation status and instead of issueing an error (absent the status variable), do the deallocation for me and then reallocate.\nThis can save several lines of code if you have a lot of dynamic arrays that you need to periodically resize",
            "is_open": true,
            "labels": [
                "Clause 9"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-31 14:47:09+00:00",
                    "text": "@rweed actually this would be very useful. I often have code like this to run some convergence study:\ndo i = 1, max_iter\n    n = n * 2\n    allocate(A(n), B(n), C(n), ...)\n    ....\n    deallocate(A, B, C)\nend do\nSo it would get reduced to just this:\ndo i = 1, max_iter\n    n = n * 2\n    allocate(A(n), B(n), C(n), ..., reallocate=.true.)\n    ....\nend do\nThat way one does not need to repeat 10 arrays in the deallocate statement and remember to deallocate when I add another array."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-31 15:11:47+00:00",
                    "text": "@certik wrote:\n\n@rweed actually this would be very useful. ..\n\nHere's a recent thread at comp.lang.fortran forum on this, perhaps the same as what @rweed mentioned.\nI wrote in that thread, \"what interested users can do is to make a case for enhancements such as this in the standard and put a together a proposal paper for submission with one or more contacts listed at the WG5 Fortran website.  GitHub is a good platform for users to group together and collaborate to capture their needs, collect use cases, and summarize what is of interest for an enhancement or addition to the language.  The standards committee can best work on the response: either No, or if at all yes, as to how and when!\"\nMega Kudos to @certik and @zjibben for making GitHub happen!\nNow, if only WG5 Fortran can follow \"common sense\" which will be to not proceed with a \"frozen\" work-list with J3 on Fortran 202X revision!  Rather they can follow a somewhat open approach which allows work to proceed on many good ideas based of course on some objective, initial screening.  Then, in this day and age of modern collaborative platforms such as GitHub and amazing multitasking abilities of interested and multi-talented folks, considerable progress can occur online in parallel and near-ready features for official standard publication can be developed. so much so that committee can increasingly be in a critical review mode, to cross-check and resend for correction or refine work, thereby saving themselves so much time.  What is needed mostly are some guidelines or criteria - clearer the better - on what to do or not do in terms of additions/changes to the Fortran standard.\nDelegate to develop faster is what the committee can best do for Fortran.\nMany, many ideas like the one with ALLOCATE statement in this thread can then be absorbed into the next revision.\nIt is then too bad something like this will have to wait for Fortran 202Y."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-31 22:37:29+00:00",
                    "text": "I would like to add that modifications like this fit my criterion for things that the committee should give priority to above adding new capabilities that will take much longer to develop and implement. Namely,\n\n\nIts a (on the surface) straightforward and simple extension to an existing cabability. I doubt if implementation will require more than a few lines of code\n\n\nIts something that most users will probabaly use immediately (or at least when it becomes available in their compiler of choice). While many of the new proposed features are interesting and I'll probably find a use for them some time in the future, very few of them are things I would use right away.  There are still some proposed features (and things in the current standard) that I'll probably never use and appear to me to have been (or are) the pet project of one of the committee members that addresses a narrow focused need in their own work or their organization.\n\n\nTherefore (and this this touches on issue #36) I would like to see the committee priortize their work along these lines.\n\nSimple and quick to implement and most members agree would be adopted and used by the user community immediatly\nImprovements and extensions that will take much longer to implement but address a clear need or deficiency in the langauge but still might not be immediatly adopted by the user community\nThings that address only an application specific area and would not be widely used\n\nI would move as suggested to a 3 year development cycle with the first 1.5 years addressing an agreed upon number of priority 1 items. This could be released as an interim standard (a TS or TR) some time between year 1 and 2 and allow the developers to implement them prior to the release of the full standard. Concurrently, Priority 2 items can be developed over the full 3 year cycle. Priority 3 items could be pushed into a five year cycle\nI strongly agree with @FortranFan that the current development process is too inflexible and doesn't allow for items that have an obviously short development and implementation cycle to be added in a specified window after the initial feature set for each standard revision is agreed upon"
                },
                {
                    "user": "certik",
                    "date": "2019-10-31 23:10:42+00:00",
                    "text": "@FortranFan, @rweed thanks for the feedback. I think we are all in full agreement how this should work. I just posted in a similar spirit at https://groups.google.com/d/msg/comp.lang.fortran/dFenjU25o9k/TaLSwNS3DQAJ.\nNow, in order to move forward from here, can you please both help me in the issue #26 to formalize what you just wrote above? We need two documents:\n\n\na document that will summarize how we want to work in this repository and that proposal does not require any changes how the committee itself works. Well, except one change: the committee must give feedback to any solid proposal submitted to it at any meeting.\n\n\na formal proposal to the committee how the committee itself should work and why. That will require changes to the committee. As such, the committee might say no, and explain why. And we will work as community to address such objections.\n\n\nIt's important however to have this written up in documents, and truly think all the arguments out (let's collaborate on that), so that when committee members read it, they can say: \"These are really good points, why don't we try that?\". Such a document also gives me and many others on the committee something to bring up and collect feedback on. (As opposed to just a GitHub issue.)\n\nIf you are for it, why don't you just post a draft of such documents into #26 as comments, and then we'll create a PR and create an actual document, once we can agree on the wording."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2022-03-06 17:09:12+00:00",
                    "text": "Why not just make this the default behavior of allocate? Is there ever a situation where you want the current behavior (crashing if it is allocated?) I would say no."
                },
                {
                    "user": "certik",
                    "date": "2022-03-06 17:37:00+00:00",
                    "text": "Is there ever a situation where you want the current behavior (crashing if it is allocated?)\n\nI think I want this behavior while developing, to catch double allocation bugs. I think the user should specifically say when reallocation is wanted, otherwise it should give an error."
                }
            ]
        },
        {
            "number": 60,
            "user": "arjenmarkus",
            "date": "2019-10-31 08:31:10+00:00",
            "title": "Coroutines",
            "text": "Coroutines represent a method to let two parts of a program cooperate with each other. The Wikipedia page on corotuines explains the concept. In the context of Fortran programming paradigms, think of the way reverse communication is implemented. Coroutines would make this much easier.",
            "is_open": true,
            "labels": [
                "Fortran 202y",
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-31 13:09:34+00:00",
                    "text": "From what one can see at J3 websites, coroutines have been proposed, see a recent paper.\nThis item is not on the Fortran 202X work-list though.\nSo interested parties can use the long waiting period until Fortran 202Y to develop the idea and perhaps try prototype implementations e.g., in LFortran?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-31 14:45:31+00:00",
                    "text": "My, the paper has worked out a complete specification - far better than my half(*)-thought-through idea ;).\n(*) Well, \"half\" is exaggerating it a bit, a more accurate estimate is \"one-eighth\". I merely thought, let's throw up this concept, so that it will not be forgotten."
                },
                {
                    "user": "certik",
                    "date": "2019-10-31 14:49:59+00:00",
                    "text": "@FortranFan let's work towards fixing the \"long waiting period\", as proposed in #36. With enough support in the large community, as well as enough members on the committee, it can happen."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-31 16:15:06+00:00",
                    "text": "Coroutines are one of possible concurrent models. The bottom-line question is whether Fortran needs concurrency (I am not convinced). Although it's possible to write concurrent (not parallel) programs with coarrays, they were not designed to do that.\nThis perhaps also puts the cart before the horse. Let's discuss whether Fortran needs concurrency (perhaps in #59), and if yes, then it's useful to evaluate different concurrency models."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-31 22:15:22+00:00",
                    "text": "@milancurcic wrote:\n\nCoroutines are one of possible concurrent models. The bottom-line question is whether Fortran needs concurrency (I am not convinced). Although it's possible to write concurrent (not parallel) programs with coarrays, they were not designed to do that.\nThis perhaps also puts the cart before the horse. Let's discuss whether Fortran needs concurrency (perhaps in #59), and if yes, then it's useful to evaluate different concurrency models.\n\ni don't think there is any doubt or question here.  Not only does the Fortran standard in no way seek not to support concurrency, but with the importance given to DO CONCURRENT construct in the language starting Fortran 2008 and the considerable flexibility granted to processors in terms of their concurrency approaches and as well as other design considerations in the standard (e.g. REDUCE intrinsics) as well as other actions by the committee such as actively liasing with OpenMP,  Fortran appears to fully affirm broad support toward this aspect.  Besides the value of coroutines can come into play when a program is executed in different ways e.g., by means other than a Fortran processor.  So it appears to me this feature has several valid use cases."
                },
                {
                    "user": "klausler",
                    "date": "2019-10-31 23:49:14+00:00",
                    "text": "@milancurcic wrote:\n\nCoroutines are one of possible concurrent models. The bottom-line question is whether Fortran needs concurrency (I am not convinced). Although it's possible to write concurrent (not parallel) programs with coarrays, they were not designed to do that.\nThis perhaps also puts the cart before the horse. Let's discuss whether Fortran needs concurrency (perhaps in #59), and if yes, then it's useful to evaluate different concurrency models.\n\ni don't think there is any doubt or question here. Not only does the Fortran standard in no way seek not to support concurrency, but with the importance given to DO CONCURRENT construct in the language starting Fortran 2008 and the considerable flexibility granted to processors in terms of their concurrency approaches and as well as other design considerations in the standard (e.g. REDUCE intrinsics) as well as other actions by the committee such as actively liasing with OpenMP, Fortran appears to fully affirm broad support toward this aspect. Besides the value of coroutines can come into play when a program is executed in different ways e.g., by means other than a Fortran processor. So it appears to me this feature has several valid use cases.\n\nDO CONCURRENT is fundamentally broken.  It only guarantees to the compiler that the iterations of the loop can be run in any serial order.  Its default localization rule (any variable read in an iteration will see the most recent value written in the same iteration, if any) prevents straightforward parallel execution."
                },
                {
                    "user": "certik",
                    "date": "2019-11-01 02:15:29+00:00",
                    "text": "Let's discuss the \"do concurrent\" problem in #62."
                },
                {
                    "user": "certik",
                    "date": "2020-01-06 15:31:53+00:00",
                    "text": "@FortranFan do you remember the committee's feedback on the 19-169 paper that you mentioned above? Let's document the feedback here."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-06 16:11:40+00:00",
                    "text": "@certik wrote:\n\n@FortranFan do you remember the committee's feedback on the 19-169 paper that you mentioned above? Let's document the feedback here.\n\n@certik, one or more attendees from the meeting last August 2019 in Tokyo, Japan will be better positioned to provide feedback.  I was unable to attend that meeting.  \"Officially\" the documentation from that meeting minutes is paper 19-169 (and many others) were \"out-of-order\" and \"no action\" was taken: https://j3-fortran.org/doc/year/19/minutes219.txt:\n\nNo action on the following papers, all considered to be\nout-of-order features:\n19-169 \"Coroutines and Iterators\"\n19-172 \"Specification part in more s\"\n19-186 \"Option to derive an inextensible type\"\nNo action on the following papers, all considered to be\nfor information only:\n19-171 \"Ada Committee Liaison Report\"\n19-175 \"Concerning N2165\"\n19-189 \"GNU view on templates\"\nAlso, no action on these containers papers:\n19-167 \"Preliminary requirements for support for containers\"\n19-168 \"Containers\"\n19-170 \"Specifications and syntax for container support\"\nData recommends against US25 (Exceptions)"
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 19:54:25+00:00",
                    "text": "There are more uses for coroutines than concurrency. One of my codes solves a bunch of related problems of different sizes. Numerous arrays depend on the problem size. Profiling showed the code was spending a lot of time in the storage allocator. So I made the arrays automatic, depending upon the maximum size. Iteration over the different problems moved into that procedure. Procedures it needed, that need arrays depending upon the problem size, became internal procedures. The module became a monster.\nAs coroutines, instead of being internal, each could be in its own module, and invoked with the maximum size, immediately suspending, then resumed with each different size, without re-creating the activation record.\nAnd, of course, iterators are useful independently of concurrency. They're just the function analogue of coroutines."
                }
            ]
        },
        {
            "number": 59,
            "user": "certik",
            "date": "2019-10-28 02:27:10+00:00",
            "title": "Formulate long term vision for Fortran in terms of features",
            "text": "I would like the community and the committee to formulate a long term vision what features we would like to work towards in Fortran and how they work together, and consequently, which features we do not want.\nAs an example, let's say that we would like to have some form of templates and exceptions. Then the two features should be formulated in a way so that it allows us to write all the things we want and that they work well together. Then there are a lot of features that should be implemented in a way to play well together, such as: #44, #45 and then there are features that are not needed, such as #58, because one can achieve the same thing with templates and strong concepts / interfaces.\nAs another example, let's say we do not want generic programming. In that case, we might consider something like #58.\nThe goal should be to design the language features well, so that we do not end up with lots of orthogonal features that do not play well together. Having such a vision will help us guide which proposals and features we should prioritize and also help us design all the features to work well together.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-29 16:20:48+00:00",
                    "text": "@FortranFan, in #2 (comment) you mentioned:\n\n\nFortran is not a general-purpose language. Rather, it is a domain specific language for array oriented scientific computing.\n\nThat may be the current reality with Fortran, but almost everyone who have worked on its language design and continue to do so will greatly dislike being reduced as such and would very much want Fortran to be seen as a general-purpose language.\n\nCan you expand on this a bit?\nMy view is that I want Fortran to be strong for array oriented scientific computing. If I want to write compilers, C++ is a better language (and so I chose C++ for LFortran). If I want to write web servers, then Python, Go, or other languages are much better also. But if I want to write numerical code, Fortran is a much better language than C++ (easier to write, read and for compilers to optimize), and I would like it to stay that way.\nWhen you say \"general-purpose\", what domains do you want Fortran to be used in? And as part of this, what features would you like to see added?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-29 22:13:13+00:00",
                    "text": "@certik asked:\n\nWhen you say \"general-purpose\", what domains do you want Fortran to be used in? And as part of this, what features would you like to see added?\n\nI think the Wikipedia page  on Fortran got it correct with its description, \"Fortran is a general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing.\"  And it summarizes Fortran as \"multi-paradigm: structured, imperative (procedural, object-oriented), generic.\"  Fortran is now also a  parallel programming language - cheers!\nNumeric computations and scientific computing are now highly multidisciplinary and they involve a lot of cross-fertilization and collaboration, as you know.  And increasingly, there is the acceptance of \"computational science\" as a veritable third branch of scientific advancement that draws from and also feeds into progress in the traditional ones of theory and experiments.  Given all this, Fortran needs to continually evolve with advances with science and computing and it needs to offer features that cover almost all the paradigms, as listed above.\nProcessing of massive amounts of data in whatever format, machine or human-readable, toward all manner of activities - whether it be climate modeling, DNA research, machine learning, AI/automation, visualization, etc.  - is also just as important to scientific and numeric computing as floating-point computation of matrices.  It's often counter-productive, I think, to stress one area, say array arithmetic of reals, too much above some other e.g., bit stream processing,\nMy vision is for Fortran to rise back as the lingua franca in scientific and technical computing.  I think this requires Fortran to be an evolving and advancing language that keeps pace in terms of being \"feature complete\" toward the programming needs of scientists and technologists.\nThe way I see things is that Fortran currently has GAPS in a few areas of critical interest to computational scientists and technologists including in research, academia, and especially industry.  Thus it is NOT \"feature complete\".  The results of the survey by WG5 cover most of these gaps e.g., generics, exception handling, bit data processing, unsigned integers, etc.  And I would add a few more in object-oriented aspects as well as good coding practices.  Most of these are essentially \"solved problems\" in terms of computer engineering; robust and functional implementations are available in too many languages and there is little to no open-ended computer science research/investigation element in almost any of the current gaps e.g., Ada added support for generics during the early 1990s.\nSo my immediate mission will be to try to help \"knock off\"  as many items on the gaps list as quickly as possible, so Fortran can get back to being competitive with other languages and compute platforms.\nModern Fortran is, unfortunately, like the curate's egg, good only in parts and that too only with a modern i.e., \"p.c.\" interpretation of that phrase.   When one tries to \"use it in anger\" toward any big, new effort or attempt a significant refactoring of an existing FORTRAN legacy code-base one ends up uttering stuff like in this cartoon:  WG5 is either unaware or in denial about this basic fact.  That has gotta change, otherwise Fortran will soon lose its raison d'etre."
                },
                {
                    "user": "certik",
                    "date": "2019-10-29 22:59:20+00:00",
                    "text": "@FortranFan thank you. I think that's fine to expand Fortran's reach to be especially suited for \"numeric computation and scientific computing\". (I think your \"general purpose\" is the same as my \"domain specific\". We both want a language for scientific computing, as opposed to, say, for web servers.)\nI just want to caution against thinking that generics or exceptions are a solved problem, I don't think they are. For example just half a year ago the committee was considering generics in a form that I would be against. It's extremely easy to get it wrong and end up with a system that has more negatives (such as long compilation time, bad error messages, unreadable code, etc.) than positives. At the same time, I am optimistic, and I think there is a way to do it right, but we have to work hard on that and I think having well designed templates in Fortran would be beneficial to its goal of being the language for scientific computing."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-29 23:22:53+00:00",
                    "text": "@certik wrote:\n\n..\nI just want to caution against thinking that generics or exceptions are a solved problem, I don't think they are. For example just half a year ago the committee was considering generics in a form that I would be against. It's extremely easy to get it wrong and end up with a system that has more negatives (such as long compilation time, bad error messages, unreadable code, etc.) than positives. ..\n\nI agree.\nWhen I wrote \"solved problem\", I only meant the computer science and engineering behind the approach and language design that might be needed to develop any particular feature.\nWhat's extremely, extremely difficult, as can be seen on any issue thread on this site, is to first establish the use cases of sufficient interest, to gain any sense of consensus around them especially when 2 or more people particularly \"long in the tooth\" are involved, to then agree on requirements and to set priorities.  Basically, problem formulation is itself very hard.  But once it is done for any of the features including generics, a solution can be developed given the current state of compiler \"technology\".  Now the direction Fortran was going previously with generics was driven by an attempt to limit the language to certain use cases and that was pushed by an influential few.  A narrow mind can greatly hijack the conceptualization phase and bias the problem formulation."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-01 18:34:26+00:00",
                    "text": "What I consider a \"Fortran spirit\" (or: what makes it NOT C++):\n\ncode fast, don't waste time on reinventing the wheel\nlet compiler do the optimization\nencapsulate common operations and let vendors provide lightning fast implementations native for the hardware\nbe explicit, save time on debugging\nmake language rules force clean, self-explanatory code as your students will have to use it in 10 years\n\nThis is all in the context that it is mostly used by people who are paid for the results of their computations rather than the code itself. This is why I think tinkering with user-written primary components (strings, list) is very against the goal here and would like to see more common operations closed in intrinsic functions/subroutines."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-21 15:55:56+00:00",
                    "text": "A comment based on DRY/WET discussions in #1: I hope the vision for Fortran will always consider it as a general-purpose, multi-paradigm language even as it retains a strong focus on scientific and technical programming!\nRe: multi-paradigm: to achieve it I think one has to practice it regularly even in small aspects and being more open-minded to facilities that might be in areas outside their own experience base or inclinations (e.g., being considerate to needs in generics even if one doesn't care for it because of being interested only in, say, Fortran 95 style code-bases with coarrays perhaps) and to generally have a wide, open tent attitude to allow its practitioners to follow different approaches that suit their needs, all within some reasonable boundaries of course.\nI've lost count of the number of times I suggest some improvement in the realm of object-oriented (OO) programming and some other Fortranner will comment they don't particularly care for OO and they never use it.  But now, OO is such a critical aspect of so many large and new code-bases coming up in the scientific and technical computing domains even (particularly in industry) and it's blended so much together with other paradigms including parallel programming that to overlook areas of improvement toward OO in Fortran is a major disservice.\nBack to the smallish aspect: I think it is entirely reasonable for a group of practitioners to want to control \"namespaces\" and particularly their \"pollution\" (which are at the root of several issues like #1, #87, etc.) in one way, say via\nuse, namespace :: foo_m\n..\ncall foo_m::bar(..  ! note :: is only an illustrative token\n..\nand another group to do so by\nuse foo_m, only : bar ..\n..\ncall bar(..\n..\nand for Fortran to support both the options which legitimately fall in the category of good coding practices.\nThe usual arguments against this are language bloat and time-resource constraints for standard development.  I personally do not think the first is applicable once a matter at hand has the passed the filter of good coding practice.  The latter is something that can be managed better and better by striving continuously for improved collaboration and greater workflow efficiency with online platforms like this.\nFortran seriously needs to evolve faster and further to have any hope of being relevant in the future."
                },
                {
                    "user": "certik",
                    "date": "2019-11-21 16:46:13+00:00",
                    "text": "Fortran's strengths are in writing prototype codes and pure numerical codes. Much better than C++ there (faster and easier to develop, faster compilation, faster runtime execution, ...). However, for large multiphysics codes, a lot of time is spent doing all the maintenance around the numerical core (reading input files, managing the many multiphysics pieces, turning features on and off, ....) and for that C++ does provide more building blocks that one can use, while in Fortran the hands are tied. And so even though C++ is worse for the numerical part, one you get a very large code, the argument for C++ is very compelling. (It becomes subjective, I personally prefer using Fortran for very large codes also, but people who know both and prefer C++ have a very solid reason for that, that cannot be dismissed as \"they don't know what they are talking about\").\nAnd so that is the main motivation for adding dictionaries, lists into the language, better string support (#24), some generic programming, improvements in OO, etc., to help maintain large codes and give maintainers of those codes tools to choose from so that their hand is not so tied behind their back. For the performance critical parts of the codes, one should still use raw arrays and loops, just like today.\nFortran strength can also be in parallel programming (coarrays being in the language) and in principle on GPU also. But currently C++ has at least a way to run on GPUs (Kokkos, RAJA), while Fortran does not (yes, there is CUDA Fortran which some of our teams use, but it does not work in every compiler...) --- and that is the primary motivation why there is a strong push away from Fortran to C++."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-09 04:09:12+00:00",
                    "text": "I wrote up a blog post about what I think should be done to develop Fortran's \"vision\". I base my opinion's there heavily on some of the ideas the Rust team seems to be using as found in this video. (the stuff most relevant to my point starting around the 13 minute mark).\nI'm curious what you guys would think Fortran's \"core values\" should be? What about secondary values? What shouldn't we care about?"
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-08 06:24:45+00:00",
                    "text": "I hope that Fortran finds a better balance between maintaining backward compatibility and modernization. I know that backward compatibility is important to many users, but I have the impression that it stops the further evolution of the language. The 'code once, run/compile forever' idea that the Fortran community sticks to is IMHO obsolete. Unit testing is industry standard today and enables continuous refactoring and modernization.\nI find it ridiculous that fixed form code is still used. Instead of forcing compiler developers to spend their time and efforts to ensure that such old code still works, the respective maintainers should to their job and modernize their code.\nOne striking example is LAPACK: It is the prime example for a very critical, and maintained software that is needed by virtually everyone doing linear algebra. It is written in Fortran, but one does not even get type checks during compilation from modules. Modules are a feature introduced in Fortran 30 years ago! As a result, using this Fortran library from python/numpy is more convenient that using it directly in Fortran. I'm convinced that pressure in the form of 'make modules mandatory' for F2008 would have triggered a re-write of LAPACK in truly modern Fortran and the situation would be much better now.\nSo my vision of Fortran is a fast, compiled language for scientific and engineering applications that values stability and innovation at the same time. To put numbers on this: A new revision every 2 years, a reference compiler that implements the new features after 2 more years and removal of deprecated features after 10 years."
                },
                {
                    "user": "epagone",
                    "date": "2021-06-10 21:25:22+00:00",
                    "text": "@MarDiehl I entirely agree. Some time ago, as a stepping stone in this \"modernisation\" direction, I have proposed a set of defaults for fpm to encourage this transition but reactions were, uhm, mixed."
                },
                {
                    "user": "certik",
                    "date": "2021-06-10 21:55:06+00:00",
                    "text": "@MarDiehl, I would suggest a slightly bigger scope than what you proposed: not to delete deprecated features, but perhaps they have to be enabled with a compiler option. The ability to compile old codes is very nice and I would like to keep it. Furthermore, many production Fortran codes span much longer than 10 years.\nRegarding Lapack, the fact that they do not maintain Fortran modules is probably caused by most of their users being in C, C++ or Python anyway, as well as the fact that the de-facto standard regarding the API has been the  F77/C style API, no modules. The Fortran user base has just not been big enough to warrant maintaining modules or to modernize the Fortran API. Also their next generation Lapack will be written in C, for that reason: https://fortran-lang.discourse.group/t/why-abandon-fortran-for-linear-algebra/1191\nThe solution to the Lapack issue is actually quite simple: we should maintain the modern Fortran interface to it as a community under https://github.com/fortran-lang, and make the package fpm installable. As more and more people use fpm and use such modern Fortran libraries, the demand will rise and eventually everybody will do that."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-11 07:42:33+00:00",
                    "text": "@certik Would it be correct to summarize your vision as 'continue as before, just add fpm and stdlib'? I doubt that this will give Fortran a future, it at best will slow down its decline.\nIf Fortran is not the first choice for a library like LAPACK, for which type of projects should it be first choice?\n\nFurthermore, many production Fortran codes span much longer than 10 years.\n\nYes, even my application is older than 10 years. But if someone is interested in a code, it should be possible to remove deprecated features within 10 years. Removing some features doesn't mean that one has to rewrite the whole code. It only requires to have a readable and maintained code.\nWhen I see F77 code, I simply want to scream and run away. So I don't think any investment in supporting it is a good investment. IMHO it would be much better to spend the time on implementing new features than support old ones. I have the impression that most compiler developers are short on man power and I would prefer if they allocate their scarce resources towards the modern language. I also believe that this would make it possible to advance the standard for quickly. The intersection between features required by the community (https://isotc.iso.org/livelink/livelink?func=ll&objId=19530634&objAction=Open&viewType=1) and the features going into 202X (https://wg5-fortran.org/N2151-N2200/N2184.pdf) is basically empty. Is it wrong to assume that this happened because of compiler vendors being afraid of getting extra work that they cannot handle?"
                },
                {
                    "user": "certik",
                    "date": "2021-06-15 17:55:22+00:00",
                    "text": "Here is a short mission statement that I like:\n\nEnable scientists, engineers, and other domain experts to write programs that naturally express the mathematics and algorithms employed, are portable across HPC systems, remain viable over decades of use, and extract a high percentage of performance from the underlying hardware.\n\nI would argue this is the original mission of Fortran and that should still be the mission today. We can perhaps reformulate the HPC, by which I simply understand \"modern computers\" of the given era, including (but not limited to) the fastest available at the given time."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-16 15:03:25+00:00",
                    "text": "Some comments on the aspect remain viable over decades of use and backward compatibility after yesterdays monthly call.\nWhy backward compatibility?\nWith backward compatibility I mean the fact that almost any valid F77 program is a valid F2018 program. It is frequently claimed that this type of backward compatibility is one of the features that the community loves about Fortran. But what is the community?\nSince there are hardly any new Fortran projects,to me it seems that the community are people working on old projects that are not modernized.That is a pity, but it should be their problem.\nWhat can they do?\n\nIn my opinion, there is one reasonable solution:\nCare about your code and step-by-step re-implement functionality. Use of modern Fortran adds value to the code: readability, maintainability, robustness.\nThere is another solution that I find less reasonable:\nSet the standard flag of your compiler to F77/F90 and clearly communicate to the world that you don't care about your project.\nThe current way how Fortran standards are written provides another option:\nCompile with F2018 standard flag and ignore the fact that your code has reached a complexity that you cannot handle any more.\n\nSo backward compatibility just helps you to ignore the reality, where reality could mean:\n\nMe and my team stopped learning and we only want to do things in the same way as we have always done it.\nThe code of my project is an unmaintainable mess.\n\nThe cost of backward compatibility\nI think Fortran suffers from feature creep (C++ is also criticized for that). The language specification gets longer with each revision and this clearly increases the complexity. The problem is, IMHO, that the current standard has reached a complexity that cannot be handled anymore. I - not a compiler developer, but a long time (10 years) Fortran user - came to that conclusion based on the following observations:\n\nIt takes years until a standard is supported by at least some compilers (I use gfortran and ifort).\nFortran compilers are buggy: I have reported about 10 serious compiler bugs (rejection of valid code, wrong results, segmentation faults in my application, internal compiler errors) in the compilers I use (Intel, GNU) or tried to use (PGI).\nI never found a bug in Python which I use equally extensive.\n2/3 attempts to get a Fortran compiler into LLVM failed. Fortunately, the current efforts seems to be on a good way.\n\nThe only solution if one cannot handle complexity is to decrease it. The current Fortran strategy is not sustainable: Slow down the increase in complexity by avoiding the addition of new features as far as possible.\nBreaking changes\nBreaking changes just mean that a decision was revised.\n\nWas fixed form a good choice in the 1960? Probably yes!\nWould any sensible person today design a programming language with fixed form? Certainly not!\n\nSo why not simply acknowledge that and expect that in 2021 source code is not written in fixed form?\nManaging breaking changes\nBreaking changes are annoying. I know this because I am a user of PETSc. They do not care about backward compatibility at all: We will never keep in a bad design decision simply because changing it will require a lot of editing. By the way, reading the rest of https://www.mcs.anl.gov/petsc/documentation/faq.html#work-efficiently is also very enlightening.\nThis means that every time there is a new PETSc version I need to check if my code still runs. Ironically, I need to do the same when a new Fortran compiler version is released: Not because they contain intentional changes, simply because the Fortran compilers that I use tend to get new bugs at approximately the same rate that old bugs get removed.\nThe good point about the strategy of PETSc is the following: The changes I need to make my application are usually small, predictable, documented: Release early, release often\nAnd programmers can not only cope with these changes, they apparently like it. I think the impact of PETSc on contemporary science/engineering applications is bigger than than Fortan's impact. The PETSc user manual has 300 citations per year, more than the whole Fortran Forum journal.\nFunction to remove from the standard:\nAs outline above, I believe that cleaning up the standard to get room for improvements would be a sensible step. The following functionality came into my mind when I thought about the less valuable parts of the language:\n\nfixed form: Belongs into the museum, together with punch cards.\ncode not included in modules/submodules: The compiler of a strongly and statically typed language should be able to tell the programmer if a function was called with the wrong arguments. Immediately. Always.\nname-list IO: Not flexible enough for many realistic use cases.\ncommon blocks: Global variables are the best option for ruining code.\ndata statement: The only thing it seems to add is partial initialization of arrays.\nequivalence: Now there are pointers.\nco-arrays: I like the feature, but I'm not aware of any serious application using it. Not much bang for the buck.\n\nA comment to F202X\nI hope that no one from the standard committee takes this personal, but to me the addition of ACOSD, ASIND, ATAND, ATAN2D, COSD, SIND, TAND, ACOSPI, ASINPI, ATANPI, ATAN2PI, COSPI, SINPI, and TANPI is ridiculous. Even an unskilled programmer can write these functions in 1 hour. Why even bother? A multiplication with a constant has no performance implications in modern, memory bound applications. Providing a function deg2rad or even defining a constant PI (so far the best solution I found is real, parameter :: PI = acos(-1.0)) would be much more general and internally a compiler could optimize statements like sin(deg2rad(()) if there is really the need for that. This is really feature creep at its best. To me it summarizes the evolution of the standard pretty well: Add features that almost no one really needs as long as they are easy to implement.\nMy vision, finally\nA breaking change in the Fortran strategy: Look forward, not backward. Accept that breaking changes are needed.\nThe risk of trying is much smaller than the risk not trying it. Fortran has little to loose but a lot to gain. Continuing as before and hope scientists/engineers to use Fortran for their projects reminds me of the saying: The definition of insanity is doing the same thing over and over again and expecting a different result."
                },
                {
                    "user": "gronki",
                    "date": "2021-06-16 16:46:15+00:00",
                    "text": "Hello and I hope that everything is going well in these challenging times.\n\nWhile I agree with your approach, there seems to be a rather big attachment\nto legacy fortran, especially from the industry side (if it ain't broke\ndon't fix it). I would also love to see Fortran as a modern and faster\ncompetitor to Numpy/Matlab and easier for scientists to handle than C/C++.\nWhile I like it that my Fortran programs will likely be valid in 20 years,\nI feel like the decisions which features are okay to drop are rather\narbitrary and probably come from large customers of compiler developers\n(such as government agencies). And I understand their point, after all\nwhile \"cleaning up\" the language would be wonderful for us enthusiasts, it\nalso needs to keep doing the job it was intended to, or otherwise it would\njust lose its relevance. As many codes are being moved from Fortran to\nC/C++, hopefully less legacy will be holding the decision makers back from\ndropping rather objectively bad features of the language (common blocks\netc).\n\nDominik\n\n\n\u015br., 16 cze 2021 o 17:03 Martin Diehl ***@***.***> napisa\u0142(a):\n\u2026\n Some comments on the aspect remain viable over decades of use and\n backward compatibility after yesterdays monthly call.\n Why backward compatibility?\n\n With backward compatibility I mean the fact that almost any valid F77\n program is a valid F2018 program. It is frequently claimed that this type\n of backward compatibility is one of the features that the community loves\n about Fortran. But what is *the community*?\n\n Since there are hardly any new Fortran projects,to me it seems that *the\n community* are people working on old projects that are not\n modernized.That is a pity, but it should be their problem.\n\n What can they do?\n\n    1. In my opinion, there is one reasonable solution:\n    Care about your code and step-by-step re-implement functionality. Use\n    of modern Fortran adds value to the code: readability, maintainability,\n    robustness.\n    2. There is another solution that I find less reasonable:\n    Set the standard flag of your compiler to F77/F90 and clearly\n    communicate to the world that you don't care about your project.\n    3. The current way how Fortran standards are written provides another\n    option:\n    Compile with F2018 standard flag and ignore the fact that your code\n    has reached a complexity that you cannot handle any more.\n\n So backward compatibility just helps you to ignore the reality, where\n reality could mean:\n\n    - Me and my team stopped learning and we only want to do things in the\n    same way as we have always done it.\n    - The code of my project is an unmaintainable mess.\n\n The cost of backward compatibility\n\n I think Fortran suffers from feature creep (C++ is also criticized for\n that). The language specification gets longer with each revision and this\n clearly increases the complexity. The problem is, IMHO, that the current\n standard has reached a complexity that cannot be handled anymore. I - not a\n compiler developer, but a long time (10 years) Fortran user - came to that\n conclusion based on the following observations:\n\n    - It takes years until a standard is supported by at least some\n    compilers (I use gfortran and ifort).\n    - Fortran compilers are buggy: I have reported about 10 serious\n    compiler bugs (rejection of valid code, wrong results, segmentation faults\n    in my application, internal compiler errors) in the compilers I use (Intel,\n    GNU) or tried to use (PGI).\n    I never found a bug in Python which I use equally extensive.\n    - 2/3 attempts to get a Fortran compiler into LLVM failed.\n    Fortunately, the current efforts seems to be on a good way.\n\n The only solution if one cannot handle complexity is to decrease it. The\n current Fortran strategy is not sustainable: Slow down the increase in\n complexity by avoiding the addition of new features as far as possible.\n Breaking changes\n\n Breaking changes just mean that a decision was revised.\n\n    - Was fixed form a good choice in the 1960? Probably yes!\n    - Would any sensible person today design a programming language with\n    fixed form? Certainly not!\n\n So why not simply acknowledge that and expect source code from 2021 is not\n written in fixed form?\n Managing breaking changes\n\n Breaking changes are annoying. I know this because I am a user of PETSc.\n They do not care about backward compatibility at all: *We will never keep\n in a bad design decision simply because changing it will require a lot of\n editing*. By the way, reading the rest of\n https://www.mcs.anl.gov/petsc/documentation/faq.html#work-efficiently is\n also very enlightening.\n\n This means that every time there is a new PETSc version I need to check if\n my code still runs. Ironically, I need to do the same when a new Fortran\n compiler version is released: Not because they contain intentional changes,\n simply because the Fortran compilers that I use tend to get new bugs at\n approximately the same rate that old bugs get removed.\n\n The good point about the strategy of PETSc is the following: The changes I\n need to make my application are usually small, predictable, documented: Release\n early, release often\n <https://en.wikipedia.org/wiki/Release_early,_release_often>\n And programmers can not only cope with these changes, they apparently like\n it. I think the impact of PETSc on contemporary science/engineering\n applications is bigger than the impact of Fortran. It's user manual has 300\n citations per year.\n Function to remove from the standard:\n\n As outline above, I believe that cleaning up the standard to get room for\n improvements would be a sensible step. The following functionality came\n into my mind when I thought about the less valuable parts of the language:\n\n    - *fixed form*: Belongs into the museum, together with punch cards.\n    - *code not included in modules/submodules*: The compiler of a\n    strongly and statically typed language should be able to tell the\n    programmer if a function was called with the wrong arguments. Immediately.\n    Always.\n    - *name-list IO*: Not flexible enough for many realistic use cases.\n    - *common blocks*: Global variables are the best option for ruining\n    code.\n    - *data statement*: The only thing it seems to add is partial\n    initialization of arrays.\n    - *equivalence*: Now there are pointers.\n    - *co-arrays*: I like the feature, but I'm not aware of any serious\n    application using it. Not much bang for the buck.\n\n A comment to F202X\n\n I hope that no one from the standard committee takes this personal, but to\n me the addition of ACOSD, ASIND, ATAND, ATAN2D, COSD, SIND, TAND, ACOSPI,\n ASINPI, ATANPI, ATAN2PI, COSPI, SINPI, and TANPI is ridiculous. Even an\n unskilled programmer can write these functions in 1 hour. Why even bother?\n A multiplication with a constant has no performance implications in modern,\n memory bound applications. Providing a function deg2rad or even defining\n a constant PI (so far the best solution I found is real, parameter :: PI\n = acos(-1.0)) would be much more general and internally a compiler could\n optimize statements like sin(deg2rad(()) if there is really the need for\n that. This is really feature creep at its best. To me it summarizes the\n evolution of the standard pretty well: Add features that almost no one\n really needs as long as they are easy to implement.\n My vision, finally\n\n A breaking change in the Fortran strategy: Look forward, not backward.\n Accept that breaking changes are needed.\n\n The risk of trying is much smaller than the risk not trying it. Fortran\n has little to loose but a lot to gain. Continuing as before and hope\n scientists/engineers to use Fortran for their projects reminds me of the\n saying: *The definition of insanity is doing the same thing over and over\n again and expecting a different result.*\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#59 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3PY4MLG7HHFXVE7JNLTTC4M7ANCNFSM4JFUVZ6A>\n ."
                },
                {
                    "user": "certik",
                    "date": "2021-06-16 16:55:27+00:00",
                    "text": "Thanks @MarDiehl for writing this up. There are a lot of threads, I'll try to answer them. Overall, what you described is incredibly frustrating, and that is why I decided to get involved and see if I can help fix this.\n\nI hope that no one from the standard committee takes this personal, but to me the addition of ACOSD, ASIND, ATAND, ATAN2D, COSD, SIND, TAND, ACOSPI, ASINPI, ATANPI, ATAN2PI, COSPI, SINPI, and TANPI is ridiculous. Even an unskilled programmer can write these functions in 1 hour. Why even bother?\n\nIf it was me, I would not put these in either! The argument that I heard was that sin(pi) might not be exactly 0, and that if you want the degree functions to return exactly zero, it requires some special implementation. To which I would say, in the rare cases when a simple multiplication by pi/180 is not enough, we can have more accurate versions in stdlib. This should not go into the standard.\nLong term solution: involve the community in these decisions what should and should not get standardized. Functions like these should go into stdlib first, get some usage. If there is large and documented interest in the community, we can think about adding them to the standard later.\n\nFunction to remove from the standard:\n\nI think these can be implemented in a compiler to give warnings when you use it. I plan to do this in LFortran.  I agree with your list except co-arrays. Co-arrays are not used currently much. But they are not bad as a feature and once compilers support them reliably on all platforms, I think this allows to write more readable parallel programs. I think the jury is still out.\n\nManaging breaking changes\n\nI think the way to manage breaking changes is along the lines of some of the proposals in #83.\nHowever, with good default compiler warnings (or even errors) to effectively disable things like implicit typing, there might be just a few things that would need breaking. If there is a way to figure out how not to make any breaking changes, that is always preferable. But if we want to introduce something that would not be compatible, doing it via the langauge or edition keyword would ensure that old code continues working.\nOnce LFortran works, I am happy to brainstorm with you and others what (possibly breaking) changes we would like to see and prototype them in the compiler. Then we can have a productive discussion and experience and evaluate the pros and cons.\n\nFixed form\n\nI still like the idea of using .f for free form and that can be done via new compilers as well as fpm (fortran-lang/fpm#363). Yes, we should not use fixed form for new codes, I think everybody agrees.\n\nQuality of Fortran compilers\n\nAs a user I wish that Fortran compilers were better. So I decided to start LFortran and see if I can do it better from the perspective of both organizing the development by the community as well as arriving at a technically high quality product. This can't be done overnight, this is a long term project, an investment. As I mentioned on the call, two years ago I was asking people to give us 5 years to deliver. So 3 years from now, summer 2024. To clarify: we are shooting to compile first projects this summer, so I am hoping we can deliver much sooner. But a conservative estimate for a new compiler to deliver in 5 years is reasonable, in fact people usually say 10 years.\n\n@certik Would it be correct to summarize your vision as 'continue as before, just add fpm and stdlib'? I doubt that this will give Fortran a future, it at best will slow down its decline.\n\nThat is not my vision. I agree that just adding stdlib and fpm is not enough, that would only slow down (at best) the decline, exactly as you said. We need a high quality compiler or compilers, we need a good community, we need to start seeing lots of new projects being started in Fortran, and Fortran needs to be able to compete on both technical and social level with the alternatives. (We also need the Standard Committee to work more with the community, to get a community buy-in and agreement with the direction where things are heading --- we made big progress on this too, as evidenced by this very discussion on the \"incubator repository\", but I do not consider the problem fixed yet.)\nAlso: compilers should drive the development. Let's brainstorm and implement prototypes or extensions for new features and directions. Only later let's standardize.\nIf you (or anyone else!) want to chat more about this, I am happy to do a video call anytime."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-16 17:12:09+00:00",
                    "text": "@MarDiehl  wrote:\n\nAccept that breaking changes are needed.\n\nI simply don't understand this conclusion at all.  Older features that you don't like aren't slowing progress.  If you don't want to use the older features, then don't use the older features.  If you want to delete them from the standards, that just makes their documentation harder to find.  If you want compilers to delete the older features, you're in for a disappointment; we all have users (& paying customers, for commercial products) that would be affected, and there's no advantage to be gained for us for removing working features.\nBackward compatibility is not what's dooming Fortran.  Backward compatibility is not at the expense of new features.  The reason you don't have templates or parametric modules or threading and memory models or multicore/GPU support in the standard language is not because the standard still has fixed form!"
                },
                {
                    "user": "certik",
                    "date": "2021-06-16 17:21:02+00:00",
                    "text": "If you want compilers to delete the older features, you're in for a disappointment; we all have users (& paying customers, for commercial products) that would be affected, and there's no advantage to be gained for us for removing working features.\n\nNot all compilers, for LFortran I want to have an optional mode where the compiler warns (or perhaps even gives errors) for features that you don't want to use. This would be super helpful to ensure your (new) project does not accidentally use some older features. This was one of the selling points of Python, that there was just \"one obvious way\" to do things. One can achieve something similar if the compiler \"encourages\" (via warnings and errors) just \"one obvious way\". (We can discuss if we can agree on such a subset as a community, or whether this might need to be configurable per project.)"
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-16 18:17:05+00:00",
                    "text": "@MarDiehl wrote:\n\nAccept that breaking changes are needed.\n\nI simply don't understand this conclusion at all. Older features that you don't like aren't slowing progress.\n\nThe logic is the following:\n\nThe standard is large and complicated.\nThis makes implementation of the standard difficult.\nNew features make the standard even larger and more complicated.\nIt would make sense to sacrifice some old features in favor of new ones.\n\n@klausler: What is than slowing down the progress in your opinion?\n\nIf you don't want to use the older features, then don't use the older features.\n\nYes, I certainly don't use them. But I'm affected by the poor quality of the compiler and the slowly evolving language.\n\nIf you want to delete them from the standards, that just makes their documentation harder to find.\n\nIt would even be good if people don't find concepts like fixed form if they google for Fortran because it will scare them away. But those who insist on using old style can simply get a copy of the old standard.\n\nIf you want compilers to delete the older features, you're in for a disappointment; we all have users (& paying customers, for commercial products) that would be affected, and there's no advantage to be gained for us for removing working features.\n\nI don't suggest to remove features without notification. But if there is a clearly communicated roadmap and sufficient time, people can adopt. I know that this requires work, but continuous modernization is the only way to prevent a code from getting unmaintainable legacy.\nAs I wrote, I am not a compiler developer, but as a Fortran developer I'm not satisfied with the quality of the compilers that I have tried (Intel, GNU, PGI) and I also see that even F202X is missing features that would make my life easier.\nSetting priorities needs to be done in every software project. One cannot implement every possible feature because every feature comes at the price of complexity. Backward compatibility was always top priority of Fortran. But the result is obvious: Fortran is popular among old projects that benefit from backward compatibility, but new projects rarely choose Fortran. So I agree with @klausler, backward compatibility is on short term the right strategy. But it is pretty obvious that it is not a future-proof long term strategy to simply milk the cash cows of today and don't care about tomorrows customers."
                },
                {
                    "user": "gronki",
                    "date": "2021-06-16 18:19:23+00:00",
                    "text": "I think everyone agrees that removing features is good and it actually\nhappens in the standard. There have been many deleted features. I guess the\ndisagreement is about how fast this process happens. Am I correct?\n\nDominik\n\n\u015br., 16 cze 2021, 20:17 u\u017cytkownik Martin Diehl ***@***.***>\nnapisa\u0142:\n\u2026\n @MarDiehl <https://github.com/MarDiehl> wrote:\n\n Accept that breaking changes are needed.\n\n I simply don't understand this conclusion at all. Older features that you\n don't like aren't slowing progress.\n\n The logic is the following:\n\n    1. The standard is large and complicated.\n    2. This makes implementation of the standard difficult.\n    3. New features make the standard even larger and more complicated.\n    4. It would make sense to sacrifice some old features in favor of new\n    ones.\n\n @klausler <https://github.com/klausler>: What is than slowing down the\n progress in your opinion?\n\n If you don't want to use the older features, then don't use the older\n features.\n\n Yes, I certainly don't use them. But I'm affected by the poor quality of\n the compiler and the slowly evolving language.\n\n If you want to delete them from the standards, that just makes their\n documentation harder to find.\n\n It would even be good if people don't find concepts like fixed form if\n they google for Fortran because it will scare them away. But those who\n insist on using old style can simply get a copy of the old standard.\n\n If you want compilers to delete the older features, you're in for a\n disappointment; we all have users (& paying customers, for commercial\n products) that would be affected, and there's no advantage to be gained for\n us for removing working features.\n\n I don't suggest to remove features without notification. But if there is a\n clearly communicated roadmap and sufficient time, people can adopt. I know\n that this requires work, but continuous modernization is the only way to\n prevent a code from getting unmaintainable legacy.\n\n As I wrote, I am not a compiler developer, but as a Fortran developer I'm\n not satisfied with the quality of the compilers that I have tried (Intel,\n GNU, PGI) and I also see that even F202X is missing features that would\n make my life easier.\n\n Setting priorities needs to be done in every software project. One cannot\n implement every possible feature because every feature comes at the price\n of complexity. Backward compatibility was always top priority of Fortran.\n But the result is obvious: Fortran is popular among old projects that\n benefit from backward compatibility, but new projects rarely choose\n Fortran. So I agree with @klausler <https://github.com/klausler>,\n backward compatibility is on short term the right strategy. But it is\n pretty obvious that it is not a future-proof long term strategy to simply\n milk the cash cows of today and don't care about tomorrows customers.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#59 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NITIKEKM6ZUDTKJVLTTDTDBANCNFSM4JFUVZ6A>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2021-06-16 18:29:13+00:00",
                    "text": "You seem to think that a compiler has some fixed maximum number of features that it can support, and once that limit is reached, that each new feature added requires an existing feature to be deleted.  That is not the case."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-16 18:52:00+00:00",
                    "text": "@certik: Many thanks for your detailed reply.\nAs mentioned yesterday, I really find your work on building a community (stdlib, https://fortran-lang.org) for Fortran amazing. I totally agree that involving the community is something that pushes the language forward. Apparently, Fortran users and Fortran compiler developers have different interests and I'm willingly to express my interests as a Fortran user.\nRegarding co-arrays: This was is certainly an interesting feature and I was hesitating to put it on the list. But from an outside-view, it seems to be a rather complicated feature with (at least currently) a few users. Maybe @klausler can enlighten us about NVIDIAs plans for co-array support."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-16 19:13:53+00:00",
                    "text": "You seem to think that a compiler has some fixed maximum number of features that it can support, and once that limit is reached, that each new feature added requires an existing feature to be deleted. That is not the case.\n\nYes, that is what I believe. But I forgot to mention that this maximum is not set by the language itself but by the capabilities of the compiler vendor. Some, like NVIDIA, struggle to include the F08 standard while others, like Intel, found a way to increase the number of features until F18 fits in."
                },
                {
                    "user": "certik",
                    "date": "2021-06-16 19:27:10+00:00",
                    "text": "Thank you @MarDiehl.\n\nApparently, Fortran users and Fortran compiler developers have different interests and I'm willingly to express my interests as a Fortran user.\n\nI think this perception comes from the fact that historically the communication between compiler vendors, users and the standards committee members was not always optimal. I think we have greatly improved the situation.\nSecond, I have been trying to ensure the goals of LFortran are aligned with the users (myself included!). More generally, I think we should have a community maintained compiler(s) as part of fortran-lang (precisely to ensure that it does what Fortran users want and that the community has a \"buy-in\"), and I'll be happy to if LFortran would eventually become one."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-06-16 22:13:59+00:00",
                    "text": "@MarDiehl wrote Jun. 16, 2021, 2:21 PM EDT:\n\nI also see that even F202X is missing features that would make my life easier.\n\nI apologize for not being able to understand your description of issues, I'm running into difficulties with your write-up above that advocates features you find backward or not useful removed e.g., coarrays.  But then you express interest in items you find convenient (\"make my life easier\") introduced in the upcoming and future revisions.  I don't know how to reconcile what comes across in your statements to readers who are remote from you and how to drive toward consensus across different needs.  Perhaps you can elaborate further on your points?"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-06-16 22:16:44+00:00",
                    "text": "@septcolor wrote jun. 16, 2021 2:19 PM EDT:\n\nIs it not possible to \"feature freeze\" the current Fortran (or possibly F202X), while continuing the development of the \"successor\" with breaking changes ..\n\n@septcolor , please note this is happening out there in the real world all the time and has picked up rapid pace in the last 5-6 years!  Just that the \"successors\" are modern C++, C#, Java, Julia, Python, etc."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-17 04:54:01+00:00",
                    "text": "@MarDiehl wrote Jun. 16, 2021, 2:21 PM EDT:\n\nI also see that even F202X is missing features that would make my life easier.\n\nI apologize for not being able to understand your description of issues, I'm running into difficulties with your write-up above that advocates features you find backward or not useful removed e.g., coarrays. But then you express interest in items you find convenient (\"make my life easier\") introduced in the upcoming and future revisions. I don't know how to reconcile what comes across in your statements to readers who are remote from you and how to drive toward consensus across different needs. Perhaps you can elaborate further on your points?\n\nsorry, it is true that my thoughts are not easy to understand.\nIn short, I propose to remove language features for which modern alternatives exist.\nI don't go into detail about new features that I like to add because the https://github.com/j3-fortran/fortran_proposals/issues contains already a long list. Personally, I find for example #1, #172, #70, and #16 relevant."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-17 11:55:28+00:00",
                    "text": "Second, I have been trying to ensure the goals of LFortran are aligned with the users (myself included!). More generally, I think we should have a community maintained compiler(s) as part of fortran-lang (precisely to ensure that it does what Fortran users want and that the community has a \"buy-in\"), and I'll be happy to if LFortran would eventually become one.\n\nYes, having a community that actively participates in pushing the standard seems to be very important. Python and Rust do that very successfully. And the list of issues on the J3 repository is already quite long."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-08-25 23:06:43+00:00",
                    "text": "See this comment at #108.\nMy view is as follows:\nAt some point, Fortran has to be open to certain targeted deletions from the standard.  The adverse impact I see from requiring implicit none in every program unit and interface body; from implicit save. and the continued need to have new features integrate with obsolescent ones are pernicious.  It's rather unfortunate there is no acceptance of this reality, it's total denial.\nNewer languages that are getting embraced and employed far more readily in technical computing, particularly in industry, are able to achieve exemplary feature introductions in about 4 years that can take decades with Fortran.  Sure, there are multiple root causes to this, however certain thorns in the attitude cannot be ignored.\nThis is my primary reason to hope for and nudge the Fortran Community to become more aware and vigilant and brave and absolutely demanding with at least some targeted deletions from the modern Fortran standard, in opposition to certain WG5 members and certain vendors.\nOtherwise, progress will really be held back and the old features will simply remain a millstone around the neck of poor, persevering, practitioners striving to use modern Fortran even.  And who might as well then just wrap their existing creations of Fortran codebase in libraries invokable from other programming languages and migrate away from Fortran.  Vast swaths of domains elsewhere, particularly in industry, have done so and doing more of this.\nThis is again a vision thingy for the language, it's entirely lacking in some key spaces among the language bearers."
                }
            ]
        },
        {
            "number": 58,
            "user": "jacobwilliams",
            "date": "2019-10-28 01:21:56+00:00",
            "title": "Multiple inheritance",
            "text": "Why not allow multiple inheritance? I believe some think this is a bad thing, but from time to time I wish we had it.\nExample:\ntype,extends(base1,base2),public :: myclass\nend type myclass\nProbably it was discussed at some point?",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 02:12:22+00:00",
                    "text": "Fyi for the readers, here are a couple of articles that might be of interest:\nWhy doesn\u2019t C# support multiple inheritance?\nWhy not multiple inheritance?  Find out why Java's creators prohibited multiple inheritance"
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 02:28:20+00:00",
                    "text": "I feel this feature is the kind of feature that depends on having a long term plan, see #59. The long term plan will then determine whether this is on its path, or not.\nAs I mentioned in #59, the generic templates should allow an effective \"multiple inheritance\", so then this feature as proposed here would be superfluous and it'd be better not to have it, to keep the language smaller, without loosing any expressiveness. However, if we decide in #59 that we do not want templates, then this feature might be more compelling."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-01 19:34:24+00:00",
                    "text": "Would common base classes be duplicated or combined like C++ virtual bases?"
                },
                {
                    "user": "vansnyder",
                    "date": "2022-04-23 20:44:21+00:00",
                    "text": "I read a long time ago, but I don't remember where (maybe in something that Leslie Hatton wrote), that some language theorist had proven that multiple inheritance is never required. The argument against it is usually entitled \"the dreaded diamond-shaped inheritance diagram.\""
                }
            ]
        },
        {
            "number": 57,
            "user": "certik",
            "date": "2019-10-28 00:01:40+00:00",
            "title": "Create a testsuite for the standard",
            "text": "Currently each compiler must develop its own tests for every feature in the standard. One could imagine, down the road, that the committee can maintain a \"blessed\" set of tests for each feature in the standard, which if the compiler passes, then the feature can be considered \"implemented\".\nOne can then maintain an automatic matrix of features and compilers to see which compilers implement which features.\nSuch a testsuite for each feature can be a nice complement to the standard, giving an example for all the corner cases how a certain feature should behave.\nThis might seem like a lot of work to do from scratch, but we can start doing it for every new feature from now on. And eventually implement the tests for old features as time allows. Doing it for new features would not be as hard, since the committee spends a lot of time designing each feature carefully. So writing tests for it might even make the process easier.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 15:43:39+00:00",
                    "text": "@certik this will be tremendously helpful.\nDo you think GitHub can be used for this?\nAnd do you think it will be possible to get a \"critical mass\" of support from the Fortran committee to engage and contribute to such an effort?  For example, to review and confirm the standard-conformance of each of the tests in a suite because such a \"blessing\" is what will validate the test suite."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 21:39:52+00:00",
                    "text": "@FortranFan Yes, GitHub or GitLab can be used. Regarding convincing the committee, I think as we keep discussing and proposing the various ideas in this repository, I think it will become clear in the future which ideas are very popular, and then we should all work towards convincing the committee to do those."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-01 20:44:07+00:00",
                    "text": "A thorough suite of positive and negative tests for every feature, requirement, and constraint in the standard would be incredibly valuable to implementations, as well as to commercial customers requiring proof of conformance."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-03 16:05:09+00:00",
                    "text": "For FORTRAN 77, there was an official ANSI test suite which vendors would pay the US government annually to come in, run, and certify the results. The suite was rather simplistic overall and never changed. ANSI/NIST discontinued it.\nThere have been several attempts to create a more comprehensive test suite for newer revisions. The Hendrickson/Spackman SHAPE95 suite was licensed by multiple vendors, and it was good, but work stopped on it. While I was at Intel I became aware of an Italian user, whose name escapes me, who appeared to be creating a useful test suite covering all the syntax, but maybe not the full semantics. I have no idea what happened to that as we stopped hearing from him (bug reports) after a while.\nThis is a far bigger task than you might imagine, and requires serious, ongoing resources. It is not something the Fortran committee, all volunteers taking time from their day jobs, can develop or even specify/manage. As a former vendor, I can tell you that vendors would be happy to pay for a good test suite with ongoing maintenance and support. But who is going to create it? These vendors (and I'll include freeware developers in this) all have their own test suites, largely comprised of collected applications, unit and regression tests; but they are far from comprehensive, no matter how good intentioned.\nWriting a good test is much harder than you might think. Compiler developers are the wrong people to write tests, as they will test what they think the feature is supposed to do. For a while, Intel had a dedicated team, separate from the compiler group, writing tests based on the documentation; it worked very well and uncovered many bugs, but the team, funded by a different organization, was disbanded and we lost that resource.\nThe big problem as I see it is that the market for such a test suite is small compared to the cost of creating and maintaining it. The only way I could see this happening is if some government funded the effort, as they did in the F77 days, and I don't see that happening today, especially for Fortran.\nSo, yes, it would be fantastic if a good, modern Fortran test suite existed and was maintained. Who is going to do it?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-03 20:07:09+00:00",
                    "text": "@sblionel Thanks a lot for your feedback, I really appreciate it. My approach is to first figure out ideas that the community would like to see. This seems to be one of the more popular ideas.\nOnce we have established that we want to get this done, we can shift the discussion into how to get it done. I can see several approaches, and there might be more ways to get it done:\n\n\nVendors can collaborate on a common opensource project. But as you said, in some sense they are the \"wrong people\" to write such tests.\n\n\nVendors can all pool to fund a separate entity to write and maintain such a testsuite. As you said, vendors might be willing to pay for such a thing. There are several models how this can be done. I am at a NumFOCUS summit conference right now and there are many efforts to allow precisely such funding. One is OpenTeams, where the idea is that (opensource) projects can propose an idea, and OpenTeams facilitates the discussion with companies to sell the idea to them and companies can pool together to fund this. Writing modern Fortran testsuite might be a good fit. There are other ways to get it funded also.\n\n\nSo it might be possible to secure and facilitate the funding. The next question is who will do that. Again, there are several approaches here:\n\n\nI talked with @nncarlson a few days ago, and we are actually both interested in working on such a testsuite. But as you said, this is a much bigger task than two people can do. But we can help. This is just an example that it is possible to find interested parties to help.\n\n\nCompiler vendors can actually help a lot too, as long as this project is properly lead by somebody who understands the task at hand and can ensure the overall quality of the testsuite.\n\n\nSomebody would need to assemble a team and lead this effort and try to get it funded. This comment can serve as some ideas how to do so."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-12 00:35:27+00:00",
                    "text": "@certik wrote:\n\n.. My approach is to first figure out ideas that the community would like to see. ..\n\n@certik, there might be some people like me who are restricted in terms of what they can do with GitHub (e.g., basic use via browser ok, but not much else) but who can contribute some unit tests for consideration toward inclusion in the \"modern Fortran testsuite\".\nIf it's possible for you or others on such a team on the \"standard\" testsuite to set up some kind of infrastructure for such a suite (perhaps on GitHub itself?) and some mechanism for community submissions which can then be reviewed for correctness/suitability, etc. particularly in terms of standard conformance (or lack thereof as intended failures) and approved for inclusion in the suite, that might be another resource this team can start drawing upon.\nOver the years, I've assembled quite a few \"informal\" and small unit tests on a variety of standard features including OO facilities, parameterized derived types, UDDTIO, coarrays, interoperability with C, pure and elemental subprograms, submodules, block constructs, etc. which I can start to \"clean up\" and share with the team working on the \"standard testsuite\".  And there might be other community members willing to contribute similarly.\nTo show an example, here's a case I've been grappling with the last couple of weeks: I think the code is conforming per my read of current standard, however it fails with 2 processors I tried which then makes me wonder if the compilers have bugs in their implementations or whether I'm in the wrong.  If it is the former i.e., compiler bugs, then this might be a possible case for inclusion in the \"modern Fortran testsuite\":\n#include <stdio.h>\n#include <assert.h>\n#include \"ISO_Fortran_binding.h\"\n\nvoid Csub(const CFI_cdesc_t *, size_t);\n\nvoid Csub(const CFI_cdesc_t * dv, size_t locd) {\n\n   CFI_index_t lb[1];\n   lb[0] = dv->dim[0].lower_bound;\n   size_t ld = (size_t)CFI_address(dv, lb);\n\n   printf(\"In C function: CFI_address of dv = %lx\\n\", ld);\n   assert( ld == locd );\n   return;\n\n}\n! Unit Test #: Test-1.F2018-2.7.5\n! Author     : FortranFan\n! Reference  : The New Features of Fortran 2018, John Reid, August 2, 2018\n!              ISO/IEC JTC1/SC22/WG5 N2161\n! Description:\n! Test item 2.7.5 Fortran subscripting\n! void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);\n! that returns the C address of a scalar or of an element of an array using\n! Fortran sub-scripting.\n!\n\n   use, intrinsic :: iso_c_binding, only: c_int, c_size_t, c_loc\n\n   implicit none\n\n   integer, parameter :: LB_A = -2\n   integer, parameter :: UB_A = 1\n   character(len=*), parameter :: fmtg = \"(*(g0,1x))\"\n   character(len=*), parameter :: fmth = \"(g0,1x,z0)\"\n\n   blk1: block\n\n      interface\n         subroutine Csub(a, loc_a_1) bind(C, name=\"Csub\")\n            import :: c_size_t\n            type(*), intent(in) :: a(:)\n            integer(c_size_t), intent(in), value :: loc_a_1\n         end subroutine\n      end interface\n\n      integer(c_int), target :: a( LB_A:UB_A )\n      integer(c_size_t) :: loc_a\n\n      print fmtg, \"Block 1\"\n\n      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )\n      print fmth, \"Address of a: \", loc_a\n\n      call Csub(a, loc_a)\n\n      print *\n\n   end block blk1\n\n   blk2: block\n\n      interface\n         subroutine Csub(a, loc_a_1) bind(C, name=\"Csub\")\n            import :: c_int, c_size_t\n            integer(kind=c_int), allocatable, intent(in) :: a(:)\n            integer(c_size_t), intent(in), value :: loc_a_1\n         end subroutine\n      end interface\n\n      integer(c_int), allocatable, target :: a(:)\n      integer(c_size_t) :: loc_a\n\n      print fmtg, \"Block 2\"\n\n      allocate( a( LB_A:UB_A ) )\n      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )\n      print fmth, \"Address of a: \", loc_a\n\n      call Csub(a, loc_a)\n\n      print *\n\n   end block blk2\n\nend\n\nHere're the compilation and linking steps used using MinGW gfortran along with program execution which shows the failure:\n\nC:\\Temp>type c.c\n#include <stdio.h>\n#include <assert.h>\n#include \"ISO_Fortran_binding.h\"\n\nvoid Csub(const CFI_cdesc_t *, size_t);\n\nvoid Csub(const CFI_cdesc_t * dv, size_t locd) {\n\n   CFI_index_t lb[1];\n   lb[0] = dv->dim[0].lower_bound;\n   size_t ld = (size_t)CFI_address(dv, lb);\n\n   printf(\"In C function: CFI_address of dv = %I64x\\n\", ld);\n   assert( ld == locd );\n   return;\n\n}\n\nC:\\Temp>x86_64-w64-mingw32-gfortran.exe -c -Wall -Wextra c.c -o c.o\n\nC:\\Temp>type p.f90\n! Unit Test #: Test-1.F2018-2.7.5\n! Author     : FortranFan\n! Reference  : The New Features of Fortran 2018, John Reid, August 2, 2018\n!              ISO/IEC JTC1/SC22/WG5 N2161\n! Description:\n! Test item 2.7.5 Fortran subscripting\n! void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);\n! that returns the C address of a scalar or of an element of an array using\n! Fortran sub-scripting.\n!\n\n   use, intrinsic :: iso_c_binding, only: c_int, c_size_t, c_loc\n\n   implicit none\n\n   integer, parameter :: LB_A = -2\n   integer, parameter :: UB_A = 1\n   character(len=*), parameter :: fmtg = \"(*(g0,1x))\"\n   character(len=*), parameter :: fmth = \"(g0,1x,z0)\"\n\n   blk1: block\n\n      interface\n         subroutine Csub(a, loc_a_1) bind(C, name=\"Csub\")\n            import :: c_size_t\n            type(*), intent(in) :: a(:)\n            integer(c_size_t), intent(in), value :: loc_a_1\n         end subroutine\n      end interface\n\n      integer(c_int), target :: a( LB_A:UB_A )\n      integer(c_size_t) :: loc_a\n\n      print fmtg, \"Block 1\"\n\n      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )\n      print fmth, \"Address of a: \", loc_a\n\n      call Csub(a, loc_a)\n\n      print *\n\n   end block blk1\n\n   blk2: block\n\n      interface\n         subroutine Csub(a, loc_a_1) bind(C, name=\"Csub\")\n            import :: c_int, c_size_t\n            integer(kind=c_int), allocatable, intent(in) :: a(:)\n            integer(c_size_t), intent(in), value :: loc_a_1\n         end subroutine\n      end interface\n\n      integer(c_int), allocatable, target :: a(:)\n      integer(c_size_t) :: loc_a\n\n      print fmtg, \"Block 2\"\n\n      allocate( a( LB_A:UB_A ) )\n      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )\n      print fmth, \"Address of a: \", loc_a\n\n      call Csub(a, loc_a)\n\n      print *\n\n   end block blk2\n\nend\n\nC:\\Temp>x86_64-w64-mingw32-gfortran.exe -c -std=f2018 -Wall -Wextra p.f90 -o p.o\n\nC:\\Temp>x86_64-w64-mingw32-gfortran.exe c.o p.o -o p.exe\n\nC:\\Temp>p.exe\nBlock 1\nAddress of a:  87FE10\nIn C function: CFI_address of dv = 87fe10\n\nBlock 2\nAddress of a:  A3930\nIn C function: CFI_address of dv = a3928\nA s s e r t i o n   f a i l e d !\n\n P r o g r a m :   C : \\ T e m p \\ p . e x e\n F i l e :   c . c ,   L i n e   1 4\n\n E x p r e s s i o n :   l d   = =   l o c d\n\nThis application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information.\n\nProgram received signal SIGABRT: Process abort signal.\n\nBacktrace for this error:\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n\nC:\\Temp>"
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 17:48:44+00:00",
                    "text": "@FortranFan I will setup the infrastructure very soon and I will update this issue when I do so.\nHere is my plan so far:\nThe testsuite would be separate and independent of any compiler. It would contain metadata about what feature is being tested, which files, and any other useful info, and then it would also contain (probably Python) library showing how to load all the tests and process them.\nThere can be lots of backends, either as part of the test suite, or separate, for things like autogenerated CMake build system to test any compiler, or to generate a nice website with the coverage for each compiler, etc.\nThen compilers, such as LFortran, can have scripts that take this and process the files and create an LFortran specific testsuite from it, for example I'd like to generate parts of this test file.\nOther compilers could do something similar. For example for Flang the files in https://github.com/flang-compiler/f18/tree/fdb351ca2afb0d71028785da4687113343e11f54/test/semantics could be generated from such a testsuite. One downside is that the Flang testsuite has a compiler dependent checks for error messages, so it might not be possible to generate such tests from a compiler independent test suite.\nOne worry that I have is that if the testsuite files change (for whatever reason), then when Flang or LFortran specific testsuite gets regenerated, it will break (the test won't pass anymore). Or to formulate it in another way --- to what extent can a compiler testsuite be \"outsourced\" to a compiler independent testsuite? Can it even work? I don't have the answer.\nIf it cannot be done, then the answer is that each compiler still has to maintain its own testsuite, and the compiler independent \"standard\" testsuite is then used to automatically check what features are being implemented by each compiler, and also each compiler can at least take the standard testsuite as a starting point and then adapt it to its needs.\n@klausler what are your thoughts on this?"
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 18:57:14+00:00",
                    "text": "I think that the tests themselves are what's important, not the test suite infrastructure around them, so I would avoid getting too tightly integrated with tools like Python that change incompatibly over the years.  Test cases that can be run manually through a compiler without knowledge of infrastructure are the most useful.\nIn practical terms, I suggest making a distinction between three kinds of tests:\n\nTests meant to compile and execute successfully if a particular requirement/constraint/feature is correctly and completely implemented.\nTests meant to compile successfully but abort during execution as they violate some constraint or \"shall\" clause; execution to completion means that the implementation has failed the test.\nTests meant to not compile successfully, with errors being indicated at/near some locations in their source code.\n\nTests in the first group should be as self-contained as possible and execute in such a way that it's easy to determine from the shell or other tools that they terminated happily; perhaps via STOP 'PASS'.\nTests in the second group should terminate with an expected error code at runtime; if they run to completion, they should indicate to the shell or other tools that they failed to detect a required error, perhaps via STOP 'FAIL'.\nTests in the third group should have their source code marked with comments describing expected error messages.  Testing this group against a particular compiler may be best done by capturing error messages from that compiler, validating them manually, and saving them as \"known good\" compiler output, deviation from which may indicate errors later.  If a compiler fails to catch an error and the program somehow survives to execution, it should crash with a message, perhaps via ERROR STOP 'FAIL'.  It would be best if tests in this third group were as small as possible, eliciting a single error message, so that useful results could be obtained just by throwing these cases at a compiler and verifying that it refuses to compile each of them."
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 19:23:15+00:00",
                    "text": "@klausler thanks for the feedback. What would be some example in the category 2.? Things like sqrt(-1._dp) where the standard says \"its value shall be greater than or equal to zero\"? That's a great point.\nWhat's your opinion on whether compilers like Flang could (in principle) use such a testsuite, or whether compilers will have to maintain their own testsuite anyway."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-12 19:40:22+00:00",
                    "text": "It's not either/or.  I would love to have access to an authoritative suite of tests for the current revision of the standard, so that I wouldn't have to wade my way through all the ambiguity and imprecision in the text itself in an attempt to write tests for it.  An authoritative test suite would reduce the size of f18's future test directories as the standard evolves; and if the committee had to develop or subcontract the development of such tests, perhaps ambiguity would be exposed earlier and fixed sooner.  As is, we have access to many open- and closed-source test suites as well as applications, and depend heavily on all of them.\nOh, one last point that's really more important than it might seem:  the Fortran standard updates section, requirement, and constraint numbers in incompatible ways with each revision.  It's important for f18 compiler and test source code to refer frequently to the standard document.  When Fortran 202x arrives, all of those textual citations are going to have to be updated if the standard continues to gratuitously renumber them.  The C++ language standard has moved to using names rather than numbers for these referential purposes."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-13 00:18:29+00:00",
                    "text": "@klausler wrote:\n\nI think that the tests themselves are what's important, not the test suite infrastructure around them\n\nI would like to make it abundantly clear when I used the phrase \"set up some kind of infrastructure for\" a test suite, I only meant something that can help community members submit cases - like the example I showed upthread - for consideration and which can then be reviewed by the team for suitability.  It'll be useful to some (basic) indexing scheme to reference the tests (perhaps something that follows a numbering scheme of features in the standard might help?) and preferably some description/comments/results summary to go along with these tests."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-04 20:19:51+00:00",
                    "text": "Re: numbering of clauses, constraints, and requirements:\nIn Principles and rules for the structure and drafting of ISO and IEC documents\nsection 5.6 (page 8):\nConsistency should be maintained within each document, and within a series of associated\ndocuments.\n\u2022 The structure of associated documents and the numbering of their clauses should, as far as\npossible, be identical.\n\nIf the series of Fortran standards constitute a \"series of associated documents\", future revisions should avoid needless renumberings of their contents."
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-04 21:04:16+00:00",
                    "text": "Again, I'll note that the numbering is largely due to ISO rules for standards documents. These are why the chapter numbers changed by three this time around and notes don't have section numbers. Syntax rules and constraints have to be sequentially numbered and there's no feasible way to keep the numbering consistent without freezing the language, as both get additions and deletions over time. Clauses (chapters) are consistent across versions, subject to ISO constraints, and added clauses (for example, C interoperability.)\nI have sympathy for code and documentation (including error messages) that want to refer to specific sections of the standard, but I just don't see a way to get there other than qualifying these references with a specific standard and updating them once the implementation fully supports a revision. The DEC/Compaq/Intel compiler had many such references in error messages, but we ended up taking them out."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-04 21:25:03+00:00",
                    "text": "Syntax rules and constraints have to be sequentially numbered\n\nWhy? Because they're assigned by LaTeX and you don't want to change that, or is there an external requirement from INCITS or ISO that they be so?"
                },
                {
                    "user": "sblionel",
                    "date": "2019-12-04 21:53:20+00:00",
                    "text": "You'd need to ask Malcolm Cohen for details, but I think so. This would be ISO, not INCITS.  I think it would be chaos if rules and constraints weren't sequential, and what do you do if you want to add new rules in between old ones? Constraints that apply to syntax rules appear in order of the rule (and come before those that don't apply to rules.)\nTo me, this is like requiring that words in the dictionary always appear on the same page number."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-24 21:34:09+00:00",
                    "text": "Here's a case for consideration toward a test suite for the standard:\n! Unit Test #: Test-1.F2018-8.7\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! Section 8.7 IMPLICIT statement in above pdf\n! c.f. page 116 NOTE 3:\n! Implicit typing is not affected by BLOCK constructs\n!\n\n   integer :: x\n   x = fn()\n   print *, \"x = \", x\n   if ( x /= 42 ) then\n      error stop \"FAILURE: expected function return is 42.\"\n   else\n      stop \"SUCCESS\"\n   end if\ncontains\n   function fn() result(r)\n      integer :: r\n      block\n         i = 42\n      end block\n      r = i\n   end function\nend\nOne processor I tried works as I expect with this test whereas another doesn't:\n\nC:\\Temp>type p.f90\n\n! Unit Test #: Test-1.F2018-8.7\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! Section 8.7 IMPLICIT statement in above pdf\n! c.f. page 116 NOTE 3:\n! Implicit typing is not affected by BLOCK constructs\n!\n\n   integer :: x\n   x = fn()\n   print *, \"x = \", x\n   if ( x /= 42 ) then\n      error stop \"FAILURE: expected function return is 42.\"\n   else\n      stop \"SUCCESS\"\n   end if\ncontains\n   function fn() result(r)\n      integer :: r\n      block\n         i = 42\n      end block\n      r = i\n   end function\nend\n\nC:\\Temp>gfortran p.f90 -o gnu-p.exe\nC:\\Temp>gnu-p.exe\nx =   -889191990\nERROR STOP FAILURE: expected function return is 42.\nError termination. Backtrace:\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff\nC:\\Temp>ifort p.f90 /exe:ifort-p.exe\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.5.281 Build 20190815\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.24.28314.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:ifort-p.exe\n-subsystem:console\np.obj\nC:\\Temp>ifort-p.exe\nx =           42\nSUCCESS\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-24 21:48:07+00:00",
                    "text": "Here's a variant of the case shown in #57 (comment) for consideration:\n! Unit Test #: Test-2.F2018-8.7\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! Section 8.7 IMPLICIT statement in above pdf\n! c.f. page 116 NOTE 3:\n! Implicit typing is not affected by BLOCK constructs\n!\n\n   integer :: x\n   x = fn()\n   print *, \"x = \", x\n   if ( x == 42 ) then \n      error stop \"Expected x is some arbitrary processor-dependent value, not 42.\"\n   end if\ncontains\n   function fn() result(r)\n      integer :: r\n      block\n         integer :: i\n         i = 42\n      end block\n      r = i\n   end function\nend\nBoth the processors I tried appear to get this case right:\n\nC:\\Temp>gfortran p.f90 -o gnu-p.exe\nC:\\Temp>gnu-p.exe\nx =   -889191990\nC:\\Temp>ifort p.f90 /exe:ifort-p.exe\nIntel(R) Visual Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.5.281 Build 20190815\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\nMicrosoft (R) Incremental Linker Version 14.24.28314.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n-out:ifort-p.exe\n-subsystem:console\np.obj\nC:\\Temp>ifort-p.exe\nx =            0\nC:\\Temp>"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-21 04:11:32+00:00",
                    "text": "A recent discussion at comp.lang.fortran involving type-bound procedure for a defined assignment and the ELEMENTAL attribute refers to compiler issues.  Here's a case which might be useful for a standard test suite - my take is 2 processors currently get this wrong.\nmodule b_m\n   type :: b_t\n      integer :: i = 0\n      logical :: defined_assignment = .false.\n   contains\n      procedure, pass(lhs) :: assign_b_t\n      generic :: assignment(=) => assign_b_t\n   end type\ncontains\n   elemental subroutine assign_b_t( lhs, rhs )\n      ! Argument list\n      class(b_t), intent(inout) :: lhs\n      class(b_t), intent(in)    :: rhs\n      lhs%i = rhs%i\n      lhs%defined_assignment = .true.\n   end subroutine\nend module\n\nprogram case1\n\n   use b_m, only : b_t\n\n   type, extends(b_t) :: e_t\n   end type\n\n   type :: f_t\n      type(e_t) :: e\n   end type\n\n   type(f_t) :: foo(2), bar(2)\n\n   bar = foo\n   print *, \"bar(1)%e%defined_assignment = \", bar(1)%e%defined_assignment, \"; expected value is T.\"\n   if ( .not. bar(1)%e%defined_assignment ) error stop \"Program did not work as expected.\"\n   stop \"SUCCESS\"\n\nend program case1\nUpon execution of program compiled using gfortran, the run-time behavior is:\n\nbar(1)%e%defined_assignment =  F ; expected value is T.\nERROR STOP Program did not work as expected.\nError termination. Backtrace:\nCould not print backtrace: libbacktrace could not find executable to open\n#0  0xffffffff\n#1  0xffffffff\n#2  0xffffffff\n#3  0xffffffff\n#4  0xffffffff\n#5  0xffffffff\n#6  0xffffffff\n#7  0xffffffff\n#8  0xffffffff\n#9  0xffffffff"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-02-21 04:15:09+00:00",
                    "text": "Here's an even simpler scenario involving a derived type containing a component which is a derived type with a defined assignment that one processor appears to treat wrongly:\nmodule b_m\n   type :: b_t\n      integer :: i = 0\n      logical :: defined_assignment = .false.\n   contains\n      procedure, pass(lhs) :: assign_b_t\n      generic :: assignment(=) => assign_b_t\n   end type\ncontains\n   elemental subroutine assign_b_t( lhs, rhs )\n      ! Argument list\n      class(b_t), intent(inout) :: lhs\n      class(b_t), intent(in)    :: rhs\n      lhs%i = rhs%i\n      lhs%defined_assignment = .true.\n   end subroutine\nend module\n\nprogram case2\n\n   use b_m, only : b_t\n\n   type :: c_t\n      type(b_t) :: b\n   end type\n\n   type(c_t) :: foo(2), bar(2)\n\n   bar = foo\n   print *, \"bar(1)%b%defined_assignment = \", bar(1)%b%defined_assignment, \"; expected value is T.\"\n   if ( .not. bar(1)%b%defined_assignment ) error stop \"Program did not work as expected.\"\n   stop \"SUCCESS\"\n\nend program case2\nThe program output unexpectedly is as follows:\n\nbar(1)%b%defined_assignment =  F ; expected value is T.\nProgram did not work as expected."
                },
                {
                    "user": "rouson",
                    "date": "2020-02-27 04:22:18+00:00",
                    "text": "I haven't read this entire thread, but I like the original idea and have been thinking for some time about repurposing the AdHoc repository to automate and democratize the generation of a standards-conformance table.   Because AdHoc stores compiler bug reproducers, its build scripts are designed to continue building the remainder of the repository after a compile-time error occurs.   This makes it feasible to generate a standards-conformance table based on a test suite that includes code with features not supported by the involved compilers.  The build scripts could automatically generated table in GitHub Markdown structured something like the following:\n\n\n\n\nCompiler A\nCompiler B\n\n\n\n\nFeature A\nYes\nNo\n\n\nFeature B\nPartial\nYes\n\n\n\nEach entry would correspond to a unique subdirectory.  Contributors would submit pull requests with tests that enable the build/test scripts to set the value of each entry according to the following rules:\n\n\"No\" for an empty subdirectory or one in which all tests fail,\n\"Yes\" if all tests in the subdirectory pass, or\n\"Partial\" otherwise.\n\nFor example, the following directory tree would yield the above table if the tests foo.f90, bar.f90, and foobartoo.f90 pass but foobar.f90 fails:\n$ tree tests\ntests/\n\u251c\u2500\u2500 compiler-a\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 feature-a\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 foo.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 feature-b\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 bar.f90\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 foobar.f90\n\u2514\u2500\u2500 compiler-b\n    \u251c\u2500\u2500 feature-a\n    \u2514\u2500\u2500 feature-b\n        \u2514\u2500\u2500 foobartoo.f90\n\nFor free compilers, the tests could be run at no cost using GitHub continuous integration features.  For non-free compilers, another mechanism for running the tests might be required.  The degree of comprehensiveness of the test suite would be determined by the community."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-08 16:07:19+00:00",
                    "text": "A case for consider in a test suite for the Fortran standard, this one with finalization.\n! Unit Test #: Test-1.F2018-7.5.6\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! Section 7.5.6.3 When finalization occurs in above pdf\n! c.f. page 80 paragraph starting line 17:\n! When finalization occurs\n!\n\nmodule m\n   type :: t\n      character(len=12) :: name = \"default\"\n   contains\n      final :: final_t\n   end type\n   interface t\n      module procedure construct_t\n   end interface\ncontains\n   function construct_t( name ) result(r)\n      character(len=*), intent(in), optional :: name\n      type(t) :: r\n      if ( present(name) ) r%name = name\n   end function\n   subroutine final_t( this )\n      type(t), intent(inout) :: this\n      print *, \"final_t: this%name = \", this%name\n      return\n   end subroutine\n   subroutine sub1()\n      type(t), allocatable :: foo\n      foo = t( name=\"constructor\" )\n      foo%name = \"foo\"\n   end subroutine\n   subroutine sub2()\n      type(t), allocatable :: foo\n      allocate( foo )\n      foo = t( name=\"constructor\" )\n      foo%name = \"foo\"\n   end subroutine\nend module\n   blk1: block\n      use m, only : sub1\n      print *, \"Block 1: Two lines from final_t are expected\"\n      call sub1()\n   end block blk1\n   print *\n   blk2: block\n      use m, only : sub2\n      print *, \"Block 2: Three lines from final_t are expected\"\n      call sub2()\n   end block blk2\nend\nConsider the program output using gcc version 10.0.1 (experimental)):\n\nC:\\temp>gfortran -Wall -std=f2018 p.f90 -o p.exe\nC:\\temp>p.exe\nBlock 1: Two lines from final_t are expected\nfinal_t: this%name = foo\nBlock 2: Three lines from final_t are expected\nfinal_t: this%name = foo\n\nWhereas the output I expect per the Fortran standard is this:\n\nBlock 1: Two lines from final_t are expected\nfinal_t: this%name = constructor\nfinal_t: this%name = foo\nBlock 2: Three lines from final_t are expected\nfinal_t: this%name = default\nfinal_t: this%name = constructor\nfinal_t: this%name = foo"
                },
                {
                    "user": "FortranFan",
                    "date": "2021-01-09 00:42:37+00:00",
                    "text": "Here's a variant of the previous case, this one involves the expr on the right-hand side to include a component of the variable on the LHS:\n! Unit Test #: Test-2.F2018-7.5.6\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! Section 7.5.6.3 When finalization occurs in above pdf\n! c.f. page 80 paragraph starting line 17:\n! When finalization occurs\n!\n\nmodule m\n   type :: t\n      character(len=12) :: name = \"default\"\n   contains\n      private\n      procedure, pass(lhs) :: add_t\n      procedure, pass(this) :: clone_t\n      generic, public :: operator(+) => add_t\n      generic, public :: clone => clone_t\n      final :: final_t\n   end type\n   interface t\n      module procedure construct_t\n   end interface\ncontains\n   function construct_t( name ) result(r)\n      character(len=*), intent(in), optional :: name\n      type(t) :: r\n      if ( present(name) ) r%name = name\n   end function\n   subroutine final_t( this )\n      type(t), intent(inout) :: this\n      print *, \"final_t: this%name = \", this%name\n      return\n   end subroutine\n   function add_t( lhs, rhs ) result(r)\n      class(t), intent(in) :: lhs\n      type(t), intent(in)  :: rhs\n      type(t) :: r\n      r%name = trim(lhs%name) // \"+\" // trim(rhs%name)\n   end function\n   function clone_t( this ) result(r)\n      class(t), intent(in) :: this\n      type(t) :: r\n      r%name = trim(this%name) // \"*\"\n   end function\n   subroutine sub()\n      type(t), allocatable :: foo\n      foo = t( name=\"constructor\" )\n      print *, \"1\"\n      foo%name = \"foo\"\n      foo = foo%clone()\n      print *, \"2\"\n      foo = foo + foo\n      print *, \"3\"\n   end subroutine\nend module\n   use m, only : sub\n   call sub()\nend\ngfortran program output is\n\n1\n2\n3\nfinal_t: this%name = foo*+foo*\n\nThe expected program output is\n\nfinal_t: this%name = constructor\n1\nfinal_t: this%name = foo\nfinal_t: this%name = foo*\n2\nfinal_t: this%name = foo*\nfinal_t: this%name = foo*+foo*\n3\nfinal_t: this%name = foo*+foo*"
                },
                {
                    "user": "certik",
                    "date": "2021-03-10 20:24:17+00:00",
                    "text": "There is now a project idea for Google Summer of Code (GSoC) 2021 for Fortran-lang to create such a testsuite:\nhttps://github.com/fortran-lang/fortran-lang.org/wiki/GSoC-2021-Project-ideas#standard-conformance-suite\nObviously it would initially be limited to what can be achieved over the summer and then the community can contribute more tests over time. If anyone knows about a student, please direct them to the page to apply."
                },
                {
                    "user": "sigfig",
                    "date": "2021-03-22 05:10:38+00:00",
                    "text": "as @certik suggested in #200, scalar expressions used in array shape and pdt declarations should probably be included in any conformance test suite, as the related language features are not well supported in any compiler. providing tests for this sort of language feature is pretty tricky because implementations will necessarily include lots of branching depending on the contents of the expression and the surrounding context. sanity checking and codegen bugs can be hidden in eg support for \"specification functions\" that are very difficult to uncover with unit testing. property-based testing ala haskell's quickcheck is super helpful for this sort of thing, but that would make implementation of a test suite a lot more complicated. i really have no idea what the ideal approach for testing these features should be, but it seems important to include."
                },
                {
                    "user": "certik",
                    "date": "2021-03-22 16:26:02+00:00",
                    "text": "I think for the array shapes and PDT we simply have to include lots of cases and try to get as many corner cases as we can included. Then as people report bugs in a specific compiler that is not caught by the test suite, we simply add the case in."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-05-03 17:08:46+00:00",
                    "text": "The following \"silly\" case shows a memory leak on Windows OS using gfortran but not Intel Fortran per an inhouse proprietary memory checker utility.  This silly case is used by me as a quick test followed by a host of other validation steps when a team I work with needs to consider a newer version of Intel Fortran compiler for production use.\nCan someone please run Valgrind or some such app on a different platform (Linux/macOS) and please report here if the leak is reproducible?  If yes, the community can potentially consider evaluating this case toward inclusion in a test suite for the standard.\n! Unit Test #: Test-0.F2018-general\n! Author     : FortranFan\n! Reference  : https://j3-fortran.org/doc/year/18/18-007r1.pdf\n!\n! Description:\n! A highly contrived but general test using various features of the\n! Fortran standard including the use of ALLOCATABLE local objects,\n! a derived type with a finalizer toward a component with the POINTER\n! attribute, and enhanced interoperability with C to check for\n! memory leaks\n!\n\nmodule cstring_m\n   use, intrinsic :: iso_c_binding, only : c_size_t, c_ptr\n   interface\n      function strlen( ps ) result(slen) bind(C, name=\"strlen\")\n         import :: c_size_t, c_ptr\n         type(c_ptr), intent(in), value :: ps\n         integer(c_size_t) :: slen\n      end function\n   end interface\nend module\n\nmodule foo_m\n   use, intrinsic :: iso_c_binding, only : c_char, c_size_t, c_ptr, c_f_pointer\n   use cstring_m, only : strlen\n   type :: foo_t\n      private\n      class(*), pointer :: d => null()\n   contains\n      final :: clean_foo\n      procedure :: set, get\n   end type\ncontains\n   impure elemental subroutine clean_foo( this )\n      type(foo_t), intent(inout) :: this\n      if ( associated(this%d) ) then\n         deallocate(this%d)\n      end if\n      this%d => null()\n   end subroutine\n   subroutine set( this, ps )\n      class(foo_t), intent(inout) :: this\n      type(c_ptr), intent(in), value :: ps\n      integer(c_size_t) :: slen\n      slen = strlen(ps)\n      if ( slen <= 0 ) error stop\n      block\n         character(kind=c_char,len=slen), pointer :: cs\n         character(kind=c_char,len=:), allocatable :: s\n         call c_f_pointer( cptr=ps, fptr=cs )\n         s = cs\n         cs => null()\n         call clean_foo( this )\n         allocate( this%d, source=s )\n      end block\n   end subroutine\n   function get( this ) result(r)\n      class(foo_t), intent(in) :: this\n      class(*), allocatable :: r\n      if (.not. associated(this%d)) error stop\n      allocate( r, source=this%d )\n   end function\nend module\n\nmodule bar_m\n   use, intrinsic :: iso_c_binding, only : c_char, c_loc\n   use foo_m, only : foo_t\n   type :: bar_t\n      class(foo_t), allocatable :: foo\n   end type\n   interface bar_t\n      module procedure :: construct_bar\n   end interface\ncontains\n   function construct_bar( msg ) result(r)\n      character(kind=c_char, len=*), intent(in), target :: msg\n      type(bar_t) :: r\n      allocate( foo_t :: r%foo )\n      call r%foo%set( c_loc(msg) )\n   end function\nend module\n\nmodule foobar_m\n   use, intrinsic :: iso_c_binding, only : c_char, c_size_t\n   interface\n#ifndef __GFORTRAN__\n      ! gfortran doesn't yet adequately support enhanced interoperabilty with C\n      subroutine getmsg_a( str ) bind(C, name=\"getmsg_a\")\n         import :: c_char\n         character(kind=c_char, len=:), allocatable, intent(out) :: str\n      end subroutine\n#endif\n      subroutine getmsg_p( s, lens ) bind(C, name=\"getmsg_p\")\n         import :: c_char, c_size_t\n         character(kind=c_char, len=1), intent(inout) :: s(*)\n         integer(c_size_t), intent(in), value :: lens\n      end subroutine\n   end interface\ncontains\n   function msg() result(s)\n      character(kind=c_char, len=:), allocatable :: s\n#ifdef __GFORTRAN__\n      ! Workaround due to gfortran issue with CHARACTER scalar and C interop\n      allocate( character(kind=c_char, len=14) :: s )\n      block\n         integer(c_size_t) :: lens\n         lens = int( len(s), kind=kind(lens) )\n         call getmsg_p( s, lens )\n      end block\n#else\n      call getmsg_a( s )\n#endif\n   end function\nend module\n\n   block\n      use, intrinsic :: iso_c_binding, only : c_char\n      use bar_m, only : bar_t\n      use foobar_m, only : msg\n      class(bar_t), allocatable :: bar\n      class(*), allocatable :: c\n      bar = bar_t( msg() )\n      c = bar%foo%get()\n      select type ( s => c )\n         type is ( character(len=*) )\n            print *, s\n      end select\n   end block\nend\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"ISO_Fortran_binding.h\"\n\nconst char msg[] = \"Hello World!\";\n\n// Silly function for a Fortran test\nvoid getmsg_a( CFI_cdesc_t *str ) {\n   size_t lens = strlen(msg);\n   int irc = CFI_allocate(str, (CFI_index_t *)0, (CFI_index_t *)0, lens);\n   if (irc == 0) {\n      memcpy(str->base_addr, msg, lens);\n   }\n}\n\n// Silly function for a Fortran test\nvoid getmsg_p( char *s, size_t lens  ) {\n   memcpy(s, msg, lens);\n}\nExpected program behavior:\n\nC:\\temp>cl /c /W3 /EHsc c.c\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.28.29337 for x64\nCopyright (C) Microsoft Corporation.  All rights reserved.\nc.c\nC:\\temp>ifort /c /standard-semantics /fpp /warn:all /stand:f18 p.f90\nIntel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.2.0 Build 20210228_000000\nCopyright (C) 1985-2021 Intel Corporation.  All rights reserved.\nC:\\temp>link p.obj c.obj /subsystem:console /out:p.exe\nMicrosoft (R) Incremental Linker Version 14.28.29337.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\nC:\\temp>p.exe\nHello World!\nC:\\temp>gfortran -c -Wall c.c\nC:\\dev\\Fortran\\temp\\sor>gfortran -c -Wall c.c\nC:\\dev\\Fortran\\temp\\sor>gfortran -c -cpp -std=f2018 -Wall -Wno-maybe-uninitialized p.f90\nC:\\dev\\Fortran\\temp\\sor>gfortran -o gcc-p.exe p.o c.o\nC:\\temp>gcc-p.exe\nHello World!"
                }
            ]
        },
        {
            "number": 56,
            "user": "certik",
            "date": "2019-10-27 22:22:12+00:00",
            "title": "Use lowercase for Fortran code in the standard and in proposals",
            "text": "Currently it seems to be the habit to use upper case for Fortran source code in the standard as well as any formal proposal submitted to the committee.\nI propose we switch to lowercase. It seems more familiar that way. The uppercase style looks ancient.\nThis is just cosmetic, as Fortran is case insensitive, but the way things look is important.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 21:54:10+00:00",
                    "text": "Also, uppercase is harder to read at a glance. There is simply not enough visual distinction between characters.\nAs a side note, what's the community consensus on mixed case? I've been working for the past few years under the assumption that it was ok to use mixed case as an aid to the reader, even if the compiler didn't care."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 22:13:05+00:00",
                    "text": "@everythingfunctional if it is ok, let's discuss mixedCase in a separate issue #168 that I just created for it, so that we do not hijack the discussion here."
                },
                {
                    "user": "HaoZeke",
                    "date": "2021-06-24 20:38:33+00:00",
                    "text": "The uppercase style also seems to reinforce unwelcome beliefs that Fortran is actually still FORTRAN."
                },
                {
                    "user": "FortranFan",
                    "date": "2021-06-30 21:12:58+00:00",
                    "text": "@certik wrote Oct. 27, 2019, 6:22 PM EDT:\n\n..\nI propose we switch to lowercase. It seems more familiar that way. The uppercase style looks ancient. ..\n\nI agree with this proposal strongly and brought this up at the J3/WG5 meeting #224 (June 30, 2021) 5:05 PM EDT.  The current Editor is opposed to this and stated as such.  No further action expected with the standard."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2021-07-01 13:46:27+00:00",
                    "text": "I also support this strongly. It's unfortunate and embarrassing that there is opposition to this. This one and #54 are no-brainers.\nFortunately it's highly unlikely that any new user will ever actually see the standard. We just need to make sure that Fortran code looks modern in places where people are most likely to see them (e.g. fortran-lang.org, etc.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2021-07-01 15:33:37+00:00",
                    "text": "I also support this. It's important to make the Standard more approachable to as many users as we can. The language (wording) also has great room for improvement.\nTo be fair, this was brought up in the meeting during a discussion unrelated to the document style. There needs to be a dedicated paper to propose improving readability of the standard, so we can clearly lay out pros and cons of the change in style. Then try to convince other members through discussion, and have it voted on.\nF202Y may be a good milestone to try and implement this change (lowercase + syntax highlighting). F202X is already being dragged out as it is. I understand the Editor's decision to ignore this at this time."
                },
                {
                    "user": "certik",
                    "date": "2021-07-01 16:13:00+00:00",
                    "text": "As we eventually maintain the standard at GitHub (#48), we can experiment with syntax highlighting and suggest improvements to the wording. Then we can submit such changes as proposals to J3/WG5."
                }
            ]
        },
        {
            "number": 55,
            "user": "certik",
            "date": "2019-10-27 22:12:05+00:00",
            "title": "Fortran needs packaging ecosystem",
            "text": "Most other languages have that, whether Python, Julia, Go, Rust, JavaScript....\nGoals:\n\n\nMake it easy to create an application that depends on N external libraries written in Fortran, and the build system can easily and robustly build it\n\n\nMake it easy to create a new Fortran package (that depends on other packages) and distribute it\n\n\nPackage index where people can easily search for available packages provided by other people\n\n\nBuild a community and culture of such packages\n\n\nMust work with any Fortran compiler\n\n\nThis needs to be carefully designed, we need to learn from the above mentioned languages.\nSome related projects to consider:\n\nSpack, unfortunately does not work on Windows (spack/spack#9323)\nConda and conda-forge\nJulia package manager\n\nNote: initially opened at https://gitlab.com/lfortran/lfortran/issues/109.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "zmiimz",
                    "date": "2019-10-28 09:53:16+00:00",
                    "text": "imho, one of the best to consider is the dub manager   from dlang project (it is also AIO: package manager and build system)\nhttps://github.com/dlang/dub"
                },
                {
                    "user": "septcolor",
                    "date": "2019-11-01 17:34:51+00:00",
                    "text": "FWIW, this site gathers statistics for package registries of various languages. We can see more details by clicking the name of the registries.\nhttp://www.modulecounts.com/"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-03 20:43:41+00:00",
                    "text": "Looks like all the languages mentioned are interpreted. Keep in mind that there's more to the Fortran world than Windows, Linux and Mac. The Fortran world seems to have gotten along well with libraries without something in the standard for a package manager. These sorts of things tend to go obsolete quickly, anyway. I don't see it as something appropriate to add to the standard, which doesn't even discuss what source file names look like."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-03 21:32:29+00:00",
                    "text": "While it might not be a good thing to put in the standard per se, it's\ndefinitely something that needs initiative from the standarization side.\nFor example, while the format of module files has never been standarized\n(probably for convenience of compiler vendors and annoyance of users),\ndistributing Fortran packages is hell even in the current scope (for\nexample withit one Linux distribution). So while the system itself is not\ndependent on the standard, to my knowledge the standard in its current form\ndoes not make it possible to build one.\n\nniedz., 3 lis 2019 o 21:43 sblionel <notifications@github.com> napisa\u0142(a):\n\u2026\n Looks like all the languages mentioned are interpreted. Keep in mind that\n there's more to the Fortran world than Windows, Linux and Mac. The Fortran\n world seems to have gotten along well with libraries without something in\n the standard for a package manager. These sorts of things tend to go\n obsolete quickly, anyway. I don't see it as something appropriate to add to\n the standard, which doesn't even discuss what source file names look like.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#55?email_source=notifications&email_token=AC4NA3LT7MKBKSCVTWJORYLQR4SW5A5CNFSM4JFTVA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEC54JWA#issuecomment-549176536>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3NDONJH74U2VLST45DQR4SW5ANCNFSM4JFTVA7A>\n ."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-03 21:38:55+00:00",
                    "text": "Given that compiled Fortran objects are not interoperable with those from different compilers, much less modules, I don't see a way forward for this proposal. The standard offers features (especially submodules) that help library developers. Build from source works.\nKeep in mind that the Fortran standard doesn't say anything about the world outside the \"processor\" (compiler). Source lines are delivered by fairies in the night, input and output files are up to the whim of the environment, etc.  One can use any packaging system that suits your fancy. What does one do for C or C++?"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-03 21:45:49+00:00",
                    "text": "Yes you are right about that. So the distribution system then should be\nbased on source packages and compiled as the package is downloaded.\n\nEveryone: With that knowledge, what meta information would have to be\nincluded in the package?\n\nniedz., 3 lis 2019, 22:38 u\u017cytkownik Steve Lionel <notifications@github.com>\nnapisa\u0142:\n\u2026\n Given that compiled Fortran objects are not interoperable with those from\n different compilers, much less modules, I don't see a way forward for this\n proposal. The standard offers features (especially submodules) that help\n library developers. Build from source works.\n\n Keep in mind that the Fortran standard doesn't say anything about the\n world outside the \"processor\" (compiler). Source lines are delivered by\n fairies in the night, input and output files are up to the whim of the\n environment, etc. One can use any packaging system that suits your fancy.\n What does one do for C or C++?\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#55?email_source=notifications&email_token=AC4NA3OVNFWL43TSF7J7XKDQR4ZGBA5CNFSM4JFTVA7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEC55RAQ#issuecomment-549181570>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3N4PEK6AOD5VJUP7P3QR4ZGBANCNFSM4JFTVA7A>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-03 23:27:17+00:00",
                    "text": "@sblionel, from the mentioned languages, Go and Rust are compiled, and Julia is a hybrid. Regarding your second question, there are two package managers specifically for C++: Conan and Vcpkg. A language neutral package managers that many recommend for C++ (and Fortran!) are Spack and Conda (already linked in the issue description above).\n@gronki thanks for the feedback.\nFortran needs a standard way to create and distribute libraries. There is a lot to improve.\nWhat is not clear at this stage is what things, if anything, needs to be improved in the Fortran standard itself. But there might be some things to improve there, and for that reason I would like to keep discussing it here.\nI discussed this issue with many people, and there are generally two camps: a language specific package manager (like Julia, Python, ...) and those who advocate for packaging all languages (such as C++, Fortran, Python, ...) in language neutral package managers such as Conda or Spack.\nI would much prefer if we can figure out ways to just use Conda, Spack or another solution, so that we do not need to maintain things ourselves. However, there might be some Fortran specific things that we might need to figure out.\nRegarding building from source (Spack) or distributing binaries (Conda), I think we need both. We need to build from source, as that is what is needed on HPC to build an optimized static build for a specific architecture, but also be able to distribute binaries (Conda) is very helpful for users that just want to get something working quickly and do not want to wait hours to build all the dependencies."
                },
                {
                    "user": "septcolor",
                    "date": "2019-11-04 07:54:03+00:00",
                    "text": "FWIW, D, Nim, Chapel (as well as Rust and Go) are also compiled languages, each of which has its package repository. Examples of major registries include...: Dub for D, Crates for Rust, and Gopm for Go, Hackage for Haskell, and so on.\nPersonally, I think this kind of package registry does not (necessarily) have to be \"in the standard\", but it is very nice if such a repository allows users to find \"good\" packages + install them efficiently with least troubles. The ideal situation is that a package registry (or manager) provides a search mechanism for candidate packages, show the degree of maintenance level explicitly (e.g. by showing validation/test results for major compilers/versions), show dependence (e.g. 3rd-party libraries/versions required), explicitly state license (to facilitate open-source use), and provide feedback mechanism such as popularity measures and issue reports..."
                },
                {
                    "user": "septcolor",
                    "date": "2019-11-04 08:09:14+00:00",
                    "text": "As for Rust, it is not only a new language but also the \"most loved\" one in the StackOverflow survey (2019)\nhttps://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted\nand seems even considered as a possible replacement of C/C++\n(according to Microsoft)\nhttps://visualstudiomagazine.com/articles/2019/07/18/microsoft-eyes-rust.aspx\nhttps://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/\nso I guess it may also provide a useful reference for various aspects, including package management (in comparison to more traditional languages like C++ and Java)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 19:18:48+00:00",
                    "text": "In order for this to work well, you would need to tie all the packages together with a standardized build tool. I've started putting the beginnings of this together in my own packages, but I haven't formalized it or properly automated the package management side of it yet. Basically, I put together a build tool that can scan the source tree and determine the dependency tree. Then I just manually add the src folder to the list in the build system and use git submodules to manage the dependencies. Take a look here and let me know what you think.\nIt only works if everything is in modules and doesn't deal with submodules yet. I also have extended it to work with linking in C/C++ code in one project."
                },
                {
                    "user": "traversaro",
                    "date": "2020-04-23 18:03:50+00:00",
                    "text": "Regarding your second question, there are two package managers specifically for C++: Conan and Vcpkg.\n\nAs it may be relevant that there have been some effort in the past to add support for  Fortran in vcpkg, even if until now it has not been merged upstream:\n\nmicrosoft/vcpkg#485\nmicrosoft/vcpkg#1098\nmicrosoft/vcpkg#6939"
                },
                {
                    "user": "certik",
                    "date": "2020-04-23 19:14:04+00:00",
                    "text": "@traversaro thanks for the update!\nWe are developing a Fortran Package Manager (fpm) here: https://github.com/fortran-lang/fpm/, anyone is welcome to join us. It's very much work in progress, we will announce it once it is ready for users. If anyone wants to help us get there faster, please definitely join."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-23 21:35:43+00:00",
                    "text": "To follow on @certik comment, the latest developments have made fpm usable, provided you have no dependencies. That's the next step. I have some vague idea about how to implement a minimal version, but I need to find a few hours to dedicate to it."
                },
                {
                    "user": "wolfv",
                    "date": "2020-05-01 10:01:29+00:00",
                    "text": "FPM is implemented in Haskell?\nWe are actively working on mamba (https://github.com/quantstack/mamba) again, which is becoming a complete rewrite of conda in C++ -- this will shed the dependency of conda for a Python interpreter and make it much more lightweight. In the end, you'll be able to drop a statically compiled binary on a system and use it as package manager -- and it works on Linux, Windows and OS X.\nMamba is also based upon well established dependency management libraries (libsolv, and libcurl / libarchive). So not too much NIH.\nSo far we're following conda's ideas very closely to make it 99% interoperable with existing conda packages and environments.\nWe are also toying around with the idea of adding source distribution capabilities, which would be part of mamba & the yet to be made mamba-build.\nIf the only thing you're missing from Conda is the ability to distribute source easily, maybe we can formulate a plan together to add this to mamba? I think yet-another language specific package manager is not the way to go (but I am not a fortran expert so there might be good reasons, which I didn't see in this thread at least)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-01 18:40:57+00:00",
                    "text": "@wolfv thanks for getting in touch. Yes, you and I talked about this, and I also talked at length with @SylvainCorlay and discussed at your Gitter about this exact question. We also discussed with the Julia developers a few times.\nFPM is still just a prototype, I started it in Rust, but I really wanted @everythingfunctional to join our effort and he already had a similar version implemented in Haskell, so I convinced @milancurcic to switch to Haskell for the prototype. For the production version, I still think it should be Rust or C++, to make it easier for people to contribute. But let's discuss that later, for the prototype it doesn't matter from the user perspective, as long as it produces a statically linked binary, which Haskell does.\nAbout 80% of the arguments are the same for Rust as for Fortran. So let's discuss Rust, because it already has a mature ecosystem. Why couldn't Rust just use Conda? There are multiple reasons:\n\nMust be fast and a simple binary / easy to distribute. Conda fails, but Mamba might fix this.\nMust be a source distribution, in other words, build everything from source, not a binary distribution. Conda traditionally has been a binary distribution, and so a non-starter. If there was a way to make it a hybrid, as you mention, then let's discuss this more, maybe there is a way.\nThe key really is to build from source and have a robust build system from source.\nCargo understands the Rust default layout: https://doc.rust-lang.org/cargo/guide/project-layout.html, which makes it trivial to make a new package: just put files in the correct place on the filesystem, write a generic Cargo.toml and things will just work -- no need to write any manual build system (in CMake let's say), nor telling Cargo where files are.\n\nIn addition to these, Fortran has a few specific things:\n\nIt must work with any Fortran compiler (see here https://fortran-lang.org/compilers/ for a full list: several open source ones and about 12 commercial ones). One cannot mix and match compilers, one must recompile everything from scratch\nYou must be able to compile everything for your given computer with all optimizations on, to get the best performance (Fortran applications must be fast) --- one cannot just compile on an older hardware ahead of time in order to ensure that things run everywhere (as Conda does it), because you will miss performance.\n\nFPM will also have Fortran specific knowledge, such as figuring out the dependencies between modules, and enforcing proper module naming convention based on where things are in the filesystem, and enforcing a Fortran specific layout. I don't know how that could be done with Mamba, as this is really Fortran specific.\nAlso, we want FPM to eventually become the default front end to Fortran: compiler independent invocation (i.e. you can use a compiler of your choice, and FPM will figure out the different ways Fortran compilers are being called), create a new project easily, all kinds of checks, automatic formatting, etc. (just like Cargo does this to rust --- you don't call rustc by hand, you just call cargo).\nIn general, we are aiming for a smooth and nice user experience, just like Cargo delivers it for Rust.\nLet's discuss more if you are interested."
                },
                {
                    "user": "wolfv",
                    "date": "2020-05-02 10:50:03+00:00",
                    "text": "Thanks for the lengthy reply! I know you did your homework thoroughly :)\nRegarding source distribution: I don't see anything that would prevent this in Mamba -- conda packages are (almost) just tarballs of whatever was installed into the prefix that wasn't there before. So if your build script just copies the source over to some magic directory, then I think that's totally fine.\nI understand that it's nice to have the build system and the package manager integrated tightly. In my opinion those are two slightly different roles.\nWe definitely want to do a conda-compatible mamba-build as well which should be much faster.\nWith conda-build or mamba-build nothing prevents you today from adding a package fortran-build-scripts that contains some shell scripts, depends on cmake etc. so that building Fortran packages becomes a one-liner in the meta.yaml. Here is a sample meta.yaml (for others, that's how one expresses dependencies and build steps in conda):\npackage:\n  name: my_super_fortran_pkgs\n  version: 0.12.2\n\nsource:\n  path: https://.../download.tar.gz\n\nbuild:\n   script: fcomp -DSOME_ARG -MHELLO_WORLD\n\nrequirements:\n  build:\n    - my_fortran_buildscripts\n    - {{ FORTRAN_IMPL }}\n  host:\n    - some_dependency 0.14.*\n\nIn this case, fcomp would be a shell script (or some other executable) that's part of the my_fortran_buildscripts package.\nI have a conda-forge enhancement proposal that I want to push next week that would add these kind of build scripts to conda-forge at least for CMake and autogen.\nOne other thing I want to mention: I think the API surface of mamba is somewhat cleaner. For example, here is an example on how one can use the mamba API from Python to get a solution for a set of package specs:\nhttps://gist.github.com/wolfv/cd12bd4a448c77ff02368e97ffdf495a\nSo if you wanted to you could also build on top of Mamba (and conda-packages) and implement the build system as a part on top of mamba (the same APIs shown in Python are obviously available from C++ as well). These API's will cover everything from prefix activation to repodata downloading and then to package dependency solving and installation.\nI would be incredibly excited if you decided to do this with us, and obviously I would be happy to discuss this further."
                },
                {
                    "user": "certik",
                    "date": "2020-05-02 15:56:31+00:00",
                    "text": "@wolfv thanks for the reply. Yes, we would love to collaborate!\nHere is what we really care about: the end user experience. Here is are initial tutorial that explains how to use fpm:\nhttps://github.com/fortran-lang/fpm/blob/ed5dd080d45ea4a409e63a5f9b2ff26f1d82d2db/PACKAGING.md\nEverything in there already works with the current fpm, but obviously fpm is still a prototype. As I mentioned, it is heavily inspired by Cargo, so if you want to play with a good well designed production tool, play with Cargo a little bit.\nWe are completely open about the underlying technology, but we really care about the end user experience, which we want to be exactly (or very close to) what is in the above PACKAGING.md document. The key part is that users just write a simple fpm.toml file:\nname = \"hello\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\nand fpm figures out how to build the project from the file layout (the same idea as Cargo). It knows how to build the application / executable (if present), library (if present) and tests / benchmarks (in the future).\nSo for example, we do want fpm to be able to generate a Conda package, in fact we already have an issue for it: fortran-lang/fpm#70\nIn there the easiest would be to simply call fpm from meta.yaml. That's similar to what you mentioned in your last comment.\nOnce we have dependency management (we'll start working on that very soon) there might be a way to link with mamba to help out there too."
                },
                {
                    "user": "wolfv",
                    "date": "2020-05-05 19:15:33+00:00",
                    "text": "What I am proposing is to use mamba as the tool to do everything related to \"build-environment\" and dependency management, as well as installing third party dependencies (or sources) into the environment.\nI believe you could already achieve that with what we have in mamba today:\nYou can define some dependencies and install them into a build environment, then activate the environment (prefix) and build your package in that context.\nWe might have to think about how we can do source packages well in mamba / as conda packages but I am convinced that there are great solutions out there that don't require a lot of work to get done.\nDo you guys have some sort of regular meeting / video chat? I would be happy to drop by to see how we could work together if you're interested."
                },
                {
                    "user": "wolfv",
                    "date": "2020-05-05 19:21:37+00:00",
                    "text": "This is the basic mamba CLI right now which can create new prefix's based on conda packages: https://gist.github.com/wolfv/4827a7c18ffae89242cbc46ddf012b4e"
                },
                {
                    "user": "certik",
                    "date": "2020-05-05 19:23:01+00:00",
                    "text": "@milancurcic literally just yesterday suggested to have a video chat. @milancurcic would you have time to set it up with @wolfv, @everythingfunctional and others? Let's brainstorm this.\nHonestly, using Conda for non-Fortran dependencies especially on macOS and Windows would really make the user experience awesome. Things like HDF5 are notoriously long to install and just being able to install a binary would go a long way. For Fortran stuff I think we still want to build them ourselves, but let's brain storm. I think there is a huge opportunity for collaboration."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-05 22:13:06+00:00",
                    "text": "Do you guys have some sort of regular meeting / video chat? I would be happy to drop by to see how we could work together if you're interested.\n\n@wolfv Great, thank you, I appreciate your time! I sent an email."
                },
                {
                    "user": "odiferousmint",
                    "date": "2021-04-11 03:09:18+00:00",
                    "text": "Just because no one has mentioned it yet: OCaml has a pretty great package manager too, called opam: https://opam.ocaml.org/ (https://github.com/ocaml/opam). In all fairness, I never built it from source, I just grab the binary, which is all you need to run opam. For the curious, on my current system ldd /usr/bin/opam prints:\n\tlinux-vdso.so.1 (0x00007ffddfc59000)\n\tlibstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f8c17e81000)\n\tlibglpk.so.40 => /lib/x86_64-linux-gnu/libglpk.so.40 (0x00007f8c17ba2000)\n\tlibbz2.so.1.0 => /lib/x86_64-linux-gnu/libbz2.so.1.0 (0x00007f8c17b8f000)\n\tlibz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f8c17b73000)\n\tlibm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f8c17a24000)\n\tlibdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f8c17a1e000)\n\tlibgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f8c17a01000)\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8c1780f000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007f8c1895f000)\n\tlibcolamd.so.2 => /lib/x86_64-linux-gnu/libcolamd.so.2 (0x00007f8c17806000)\n\tlibamd.so.2 => /lib/x86_64-linux-gnu/libamd.so.2 (0x00007f8c177fb000)\n\tlibltdl.so.7 => /lib/x86_64-linux-gnu/libltdl.so.7 (0x00007f8c177f0000)\n\tlibgmp.so.10 => /lib/x86_64-linux-gnu/libgmp.so.10 (0x00007f8c1776c000)\n\tlibsuitesparseconfig.so.5 => /lib/x86_64-linux-gnu/libsuitesparseconfig.so.5 (0x00007f8c17765000)\n\nThere is also a popular build system developed by Jane Street: https://opam.ocaml.org/packages/dune/."
                }
            ]
        },
        {
            "number": 54,
            "user": "jacobwilliams",
            "date": "2019-10-27 22:11:23+00:00",
            "title": "Syntax highlight the code in the standard document",
            "text": "The source code in the standards document should be syntax highlighted. Also lowercase. The listings that are in there look like they are from another age.\nIt's very easy to do in LaTeX (e.g., the listings package).\nSee also: #48",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-27 22:24:13+00:00",
                    "text": "Yes! I created another issue #56 for the lowercase thing.\nI am so glad we created this repository. All these things that I noticed about Fortran at some point in the past, and then forgot. Now we can create issues for them so that we do not forget, and eventually we can fix it."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-27 23:42:08+00:00",
                    "text": "This will be useful.\nMore importantly though, it will be very valuable if the standards document provided more code snippets generally.  And in the case of new features and facilities, it included source listings, preferably complete ones, say several compilable examples.  Toward the latter, those on the committee will just need to work a bit harder to utilize their \"mental processors\" but I think such an effort will pay great dividends by leading to better descriptions of features in the standard.  This will also help compiler implementations, particularly those developed in other languages such as C++ and whose developers don't have much background or need to use Fortran otherwise."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 00:01:58+00:00",
                    "text": "One could imagine going even a step further: #57."
                }
            ]
        },
        {
            "number": 53,
            "user": "certik",
            "date": "2019-10-27 21:47:23+00:00",
            "title": "Uniform syntax",
            "text": "Extracted from #49. Author: Van Snyder\nReference: Correspondence preceding 1986 Albuquerque meeting.\nUniform referential syntax to array elements, updaters and structure components increases\nsoftware mutability, and therefore decreases maintenance costs. (The alternative is to follow\nParnas\u2019s advice to encapsulate everything in procedures \u2014 which provides uniform referential\nsyntax with higher labor expense and lower performance). To move in that direction, it ought to\nbe allowed to access a structure component using the syntax component(structure). This should\nbe classed as a generic updater. To avoid a conflict with an array of the same name as component an array ought to be considered to be a generic updater. Access to type-bound procedures or\nprocedure pointer components with PASS OBJ could require the structure to be first, or to be\nin the same place in the reference as the corresponding dummy argument. For symmetry with\nthis syntax, array components should be referenced as component(structure,subscript,. . . ). A\nsmall step in the direction of uniform syntax is to allow type-bound functions to be referenced\nwithout parentheses enclosing the empty argument list. An anti-symmetric change to allow a\nscalar to be referenced with an empty subscript list would make it impossible to know, and\nimpossible for the syntax to depend upon, whether a reference to an entity of a derived-type\nobject is a reference to a component or a type-bound function or updater. To complete the\nability to convert an entity between an array, structure component and updater, an integer\ninterval type, using the same constructor as a subscript triplet, is needed to allow an updater\nreference with the same syntax as an array section reference.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": []
        },
        {
            "number": 52,
            "user": "certik",
            "date": "2019-10-27 21:45:06+00:00",
            "title": "Subranges of integers",
            "text": "Extracted from #49. Author: Van Snyder\nReference: 04-140r1.\nUnsigned integers, and integers that have nondecimal range, are frequent requests. These\nrequests could be satisfied, and numerous other benefits provided as well, by providing for\nnamed subranges of integers.\nOne of the additional benefits is that checking of subscript bounds can be done at compile\ntime: If the bounds of an array are specified by a subrange name, and if in that case the only\nsubscripts are of that subrange, one only need check when the subscript gets a value, not when\nit\u2019s used as a subscript. If DO control is defined by reference to the subrange, say by using\nTINY and HUGE, even that check can frequently be avoided.\nAnother benefit is that one can get most (or perhaps all) of the desired functionality of a BIT\ntype by specifying a constant subrange of 0:1.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "gronki",
                    "date": "2019-10-28 14:43:45+00:00",
                    "text": "Unsigned integers -- very important IMHO. Dominik"
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 14:57:24+00:00",
                    "text": "@gronki Specifically for unsigned integers, we have a dedicated issue at #2."
                },
                {
                    "user": "swpoole",
                    "date": "2020-04-19 09:04:24+00:00",
                    "text": "The lack of unsigned integers has for some communities, caused a migration to C/C++ or other more modern languages. Having unsigned_integer capabilities would be extremely useful in a number of computational venues."
                }
            ]
        },
        {
            "number": 51,
            "user": "certik",
            "date": "2019-10-27 21:43:58+00:00",
            "title": "Enumerations that are true types, and their enumerators",
            "text": "Extracted from #49. Author: Van Snyder\nReferences: 98-171r2, 04-125r1 and 04-139r1.\nEnumerations that are new types should be provided. If generic resolution is simultaneously\nchanged so that function result types participate (as Ada has done since 1983), and enumera-\ntors are considered to be references to zero-argument functions, enumerators of different types\ncan have the same names. Enumeration types should be extensible, with the extension type\ninheriting the enumerators of its parent type, and possibly adding more enumerators. MAX\nand MIN should work for ordered enumeration types.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-28 02:51:52+00:00",
                    "text": "Related issues: #11, #46."
                }
            ]
        },
        {
            "number": 50,
            "user": "certik",
            "date": "2019-10-27 21:42:51+00:00",
            "title": "\u201cPhysical\u201d or \u201cEngineering\u201d Units of Measure",
            "text": "Extracted from #49. Author: Van Snyder\nIntroduction\nThe proposal for which authorization to proceed as an ISO Technical Specification was requested\nin June 2016 was N2113.\nIncorrect use of physical units is a common error in scientific or engineering software. Other\ncommon errors are mismatching the types of actual and dummy arguments, and subscript\nbound violations. Explicit interfaces largely solve the latter problems, but do nothing directly\nfor the former. (One can use derived types to provide a physical units system, at the expense\nof redefining intrinsic functions, operations, and assignment, for all combinations of units \u2013 a\ntremendous job for mechanics, saying nothing about thermodynamics, electronics, ... \u2013 and then\nyou hope for inlining. If done using type parameters or integer components, it can distinguish\nlength from time, but not kilograms from pounds.) A particularly expensive and embarrassing\nexample was the loss of the Mars Climate Orbiter. The loss resulted because the NASA contract\nrequired small forces, e.g. from attitude-control maneuvers, to be reported in Newton-Seconds,\nbut Lockheed nonetheless reported them in Pound-Seconds. (This was quite inscrutable, as\nLockheed had had NASA contracts for over thirty years, and they always specified SI units.)\nProposal\nDefine a new UNIT or MEASURE attribute or type parameter (call it what you will) that\ncan be specified for any numeric variable or named constant. Literal constants are unitless.\nDefine multiplication and division operations on units. Exponentiation by an integer constant\ncould be defined to be equivalent to multiplication or division. Square root, or maybe even\nexponentiation of a unit by a rational number, would be useful. In the context of a unit\ndefinition, the integer literal constant 1 is considered to be the unitless unit.\nEach unit declaration creates one or more generic units conversion functions having the same\nname as the unit, that takes an argument with any related unit, and converts it to have units\nspecified by the name of the function. It also creates a function that casts unitless values to\nhave the specified unit. There is an intrinsic UNITLESS conversion function.\nQuantities can be added, subtracted, assigned, compared by relational operators, or argument\nassociated only if they have equivalent units. Atomic units, i.e. units that are not defined in\nterms of other units, are equivalent by name. Other units are equivalent by structure.\nWhen quantities are added or subtracted, the units of the result are the same as the units of\nthe operands. When quantities are multiplied or divided, the units of the result are the units\nthat result from applying the operation to the operands\u2019 units. Multiplication or division by a\nunitless operand produces a result having the same units as the other operand.\nUnits participate in generic resolution.\nProcedure arguments and function results can have abstract units. This allows enforcing a\nparticular relationship between the units, without requiring particular units. For example, the\nSQRT intrinsic function result has abstract units A, and its argument has abstract units A*A.\nAbstract units do not participate in generic resolution.\nDefine an intrinsic RADIAN unit, and a parallel set of generic intrinsic trigonometric functions\nthat take RADIAN arguments and produce unitless results. All of the remaining intrinsic\nprocedures have arguments with abstract units and results that are unitless (e.g. SELECTED -\nINT KIND) or have the same units as their argument (e.g. TINY). Because function results do\nnot participate in generic resolution, it is not possible to have a parallel set of generic intrinsic\ninverse trigonometric functions that return RADIAN results. It may be useful to provide an\nintrinsic module that has some public units and procedures, e.g. units TICK and SECOND and\na SYSTEM CLOCK module procedure that has arguments with units TICK, TICK/SECOND\nand SECOND.\nVariables are declared to have units by specifying UNIT(unit-name) as an attribute in their\ndeclarations, or alternatively by separate UNIT declaration statements.\nExamples:\nUNIT :: INCH, SECOND\nUNIT :: CM, INCH = 2.54 * CM\nUNIT :: CM_PER_INCH = CM / INCH\nREAL, PARAMETER, UNIT(CM_PER_INCH) :: CONVERT = 2.54\nUNIT :: SQINCH = INCH * INCH ! or INCH ** 2\nUNIT :: IPS = INCH / SECOND, FREQUENCY = 1 / SECOND ! or SECOND ** (-1)\nREAL, UNIT(SQINCH) :: A\nREAL, UNIT(FREQUENCY) :: F\nREAL, UNIT(INCH) :: L, L2\nREAL, UNIT(CM) :: C\nREAL, UNIT(SECOND) :: T\nREAL, UNIT(IPS) :: V\n\nV = A + L              ! INVALID -- SQINCH cannot be added to INCH,\n                       ! and neither one can be assigned to IPS\nV = IPS(A + SQINCH(L)) ! VALID -- I\u2019m screwing this up intentionally\nV = (A / L + L2) / T   ! VALID -- IPS is compatible with INCH / SECOND\nA = L * L2             ! VALID -- SQINCH is compatible with INCH * INCH\nF = V / L              ! VALID -- units of RHS are 1/SECOND\nC = CONVERT * L        ! VALID -- CM / INCH * INCH = CM\nC = CM(L)              ! VALID -- Clearer than the previous statement\nL = SQRT(A) * 5.0e-3   ! VALID -- exercise for reader\nFull Proposal\nA full proposal, cast as a TS, by Van Snyder: Units-TR-19.pdf",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-28 15:31:50+00:00",
                    "text": "I haven't studied the details of this proposal, but I know that built-in units would be an amazing feature for engineering applications.\nAs an aside, I think the only software I've ever used that had this was Mathcad, which in school was incredible for doing engineering homework problems. I do think the committee should certainly be thinking about how to get students to want to use Fortran, rather than only focusing on HPC people. This could certainly be one feature that could do that."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-30 01:20:06+00:00",
                    "text": "Van's proposal has been repeatedly and thoroughly considered by WG5 and found wanting. It didn't help that \"units\" would not have avoided the problem that Van kept offering as an example of why it would be useful.\nI would have to say that this proposal has been poisoned, and is unlikely to gain any traction. At the very least, WG5 (and not just J3) wanted to see a trial implementation using derived types and defined operators to see how it would work in real life. That never happened despite multiple requests over years."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-30 02:13:21+00:00",
                    "text": "See also from @szaghi: https://github.com/szaghi/FURY"
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 14:34:11+00:00",
                    "text": "@sblionel this proposal is a prime example why we need to discuss things publicly (for example here). The committee has rejected this repeatedly before my time on the committee, and I can't find any technical discussion why it was rejected. That is very inefficient. Let's use this opportunity to document the arguments.\n\nIt didn't help that \"units\" would not have avoided the problem that Van kept offering as an example of why it would be useful.\n\nIt looks like based on the article you sent that a lot more went wrong, but it did start with the wrong units. Given that this example is given in the motivation of this proposal, I would like to know the answer to these questions:\nWas the navigation system written in Fortran?\nIf Fortran had units support and units were used in the navigation system, would it actually catch this particular error?\n(I can easily imagine that it wouldn't, if the two modules communicated in some way that the units, as proposed in this proposal, would not actually catch it.)\n\nAt the very least, WG5 (and not just J3) wanted to see a trial implementation using derived types and defined operators to see how it would work in real life.\n\nIt looks like that's been done: https://github.com/szaghi/FURY, as @jacobwilliams mentioned.\nHowever, I would prefer this to be part of the language, determined at compile time (with no runtime overhead), not implemented using derived types, checked at runtime."
                },
                {
                    "user": "certik",
                    "date": "2019-11-30 14:36:24+00:00",
                    "text": "I would have to say that this proposal has been poisoned, and is unlikely to gain any traction.\n\nI believe very strongly that no Fortran feature should be \"poisoned\" (by a single person?) that we cannot even discuss it. I strongly suggest we discuss features on their technical merits and document arguments for and against. Being \"poisoned\" is not a technical argument.\nHowever, tt is useful to know that the committee repeatedly discussed this and that they might be \"allergic\" to seeing this again. And so if we are going to bring this up again, we better have solid arguments and address every single objection that the committee had. (It does not help that the committee did not write down the objections, but let's fix that from now on by documenting all objections to a given proposal.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 19:23:42+00:00",
                    "text": "I actually have an implementation of this here."
                },
                {
                    "user": "acferrad",
                    "date": "2019-12-27 21:31:22+00:00",
                    "text": "Looks good.  A few things I noticed in the conversion_factors_m file.:\n1. The exact SI - Imperial mass conversion factor = 0.45359237 kg/lb, which\nshould be the base value, not g/oz.  The latter is exactly 28.349523125.\n2. The energy conversion between Joules and calories are non-consistent\nwith BTU and Joule:  there are 2 main definitions for BTU and calorie: IT\n(the standard) and Th (Thermochemical).  The units for J/cal(IT) = 4.1868\nand for BTU(IT)/J = 1055.056. The code has Th for one and IT for the other.\n  (ref:\nhttps://www.nist.gov/pml/special-publication-811/nist-guide-si-appendix-b-conversion-factors/nist-guide-si-appendix-b8\n )\n\u2026\nOn Fri, Dec 27, 2019 at 1:23 PM Brad Richardson ***@***.***> wrote:\n I actually have an implementation of this here\n <https://gitlab.com/everythingfunctional/quaff>.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#50?email_source=notifications&email_token=AJIYC2AHQVA7ESOEHPHZYHLQ2ZI35A5CNFSM4JFTRXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEHXUVIY#issuecomment-569330339>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJIYC2H644MNQORQWP6VHPDQ2ZI35ANCNFSM4JFTRXSA>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 22:48:03+00:00",
                    "text": "Thanks @acferrad . I had trouble choosing what to use as the base for mass, because it seemed when I looked that both conversion factors were published by NIST and were inconsistent. Similar thing with calories and BTU, multiple, inconsistent conversion factors."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-29 23:53:58+00:00",
                    "text": "I think that the important aspect of this feature is the language support for having a concept of units as an attribute of types (just REAL?), having the compiler combine units correctly on multiplication and division and (some) powers, and check them on addition, subtraction, assignment, argument association, &c.  The actual names of the units and their conversion factors could come from intrinsic or library modules, and in the latter case, the Fortran language would not be responsible for determining their values."
                },
                {
                    "user": "nncarlson",
                    "date": "2019-12-30 17:55:29+00:00",
                    "text": "The actual names of the units and their conversion factors could come from intrinsic or library modules, and in the latter case, the Fortran language would not be responsible for determining their values.\n\nDefinitely should be the latter. The standard has no business mandating a set of names or conversion factors.  Simply providing an abstract unit capability should be the goal."
                },
                {
                    "user": "acferrad",
                    "date": "2019-12-30 18:51:09+00:00",
                    "text": "Definitely should be the latter. The standard has no business mandating a set of names or conversion factors. Simply providing an abstract unit capability should be the goal.\n\nTotally agree. Therefore, in this implementation of what would become a Fortran standard, the names and constants should be removed from the project, and stored in an external file or project. The Fortran standard would then need to have some way of accessing it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-30 22:22:03+00:00",
                    "text": "I don't think this is something that should be part of the language. I agree that it is something that should be done and used in new code wherever possible, just not as part of the language. I've seen several libraries trying to deal with units, and they all take different approaches to dealing with what are not entirely orthogonal or entirely compatible problems. Those being:\n\nkeeping track of the units associated with a value\nprevent passing values of one quantity where a value of a different quantity is expected\nkeeping conversions between units consistent throughout a code base\nformatting output to include units\nallowing math to be done while keeping track of units\nallowing SI prefixes to be used and understood when dealing with units\nallowing user inputs to specify units\n\nI've taken what I think is a pretty good shot at creating a library, as I mentioned above, but I think even that reveals some bugs, inconsistencies or missing features that would likely show up in trying to put something like this in to the standard. Not the least of which being that conversion factors between units aren't always simple. Think Celsius to Fahrenheit.\nI don't think I've seen a sufficiently self consistent, bug free, feature complete way of dealing with units in any language. And so I would not recommend trying to make it part of the Fortran standard."
                },
                {
                    "user": "klausler",
                    "date": "2019-12-30 22:25:58+00:00",
                    "text": "I don't think I've seen a sufficiently self consistent, bug free, feature complete way of dealing with units in any language. And so I would not recommend trying to make it part of the Fortran standard.\n\nThe implementation of units on the HP-48 programmable calculator is worth studying."
                },
                {
                    "user": "certik",
                    "date": "2019-12-30 22:58:14+00:00",
                    "text": "@everythingfunctional I agree that something like this requires a complete implementation first, and real usage before even thinking of putting this into the standard. I looked at your implementation and it seems that creating values with units is as easy as 1.0d0.unit.METERS. But how do you actually use it, say an array of quantities? Can you add some documentation and post here? Does it require to define the array of derived types? Or just reals. I read through your tests, but it is still not clear. Looking at one such test: https://gitlab.com/everythingfunctional/quaff/blob/b515ae79fa0d68d44d25aefdc103234a760a5d54/tests/speed_test.f90#L31, it seems it requires to define density and density_?\nThe advantage of figuring out how to put this into the language itself is that one might define just regular arrays of real numbers (i.e., no derived types) and assign units to it with some syntax, and the compiler will check the units at compile time with no runtime overhead, and the natural already familiar syntax.\nI agree this would require a prior compiler implementation and usage in real codes to see if this is worth putting into the language."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-31 03:59:59+00:00",
                    "text": "@certik , each quantity is it's own type. So the expression 1.0d0.unit.METERS is of type Length_t. And thus, if you wanted an array of densities, you would define one like type(Density_t) :: densities(5). It's possible add and subtract quantities of the same type, multiple and divide a quantity by a scalar, and dividing quantities of the same type returns a double precision. Quantities of the same type can also be compared with the normal operators. Additionally, each of the functions to divide or multiply different quantities is implemented specifically to return the correct resulting quantity. I.e. (1.0d0.unit.METERS) / (1.0d0.unit.SECONDS) == (1.0d0.unit.METERS_PER_SECOND) is valid and true. Additionally, all of the procedures are elemental, so you can do matrix math as well.\nThere is clearly some run time cost associated with this approach (about 3x cost to multiply 2 numbers as shown by my tests). But I find that to be acceptable in most instances given the added safety and convenience it brings. And if you're doing really performance sensitive stuff, the internal values are stored in SI units and are public so you can mitigate the slow down even further if need be.\nWith full compile time checking I'm not sure you could make this valid and extensible with new units.\nlengths(1:3) = [1.0d0.units.METERS, 1.0d0.units.FEET, 1.0d0.units.MICROMETERS]\n\nBut it works perfectly with my library. And it's possible to add new units and even quantities without actually needing to make any changes to the original library. If you want to use furlongs per fortnite for speed in your code, you just need to define a conversion factor from meters and a symbol somewhere in your code and it will work just fine."
                },
                {
                    "user": "magicmouse",
                    "date": "2021-04-09 23:16:16+00:00",
                    "text": "Mr. Snyder's specification has proved very useful, as of 2021 i am aware of various languages that fully support physical units of measure. At compile time only there is F# and Cambridge FORTRAN.  For a full implementation, including user defined units of measure, and carrying the exponents of the fundamental quantities at runtime, you have Frink language (www.frinklang.org), and Beads (www.beadslang.org).  Frink is the supreme king of Units. Beads is a general purpose graphical interactive language that emits web apps, etc., and includes a layout model and event management in the language."
                },
                {
                    "user": "urbanjost",
                    "date": "2021-06-12 23:03:25+00:00",
                    "text": "pre-f90 working with a large number of projects scattered around the world we found almost all the unit issues were bound with input and output of values (including graphics) and basically make the Unix units(1) command into a subroutine and created a standard portable self-describing file format that required a unit code, and a routine called relate(3f) that would do y=mx+b conversions along with labels for each defined unit that was used as a default for labeling, particularly on plots.  So a user could specify the units he wanted a plot in and everything would be automatically converted, for example. There was a built-in relate default table of a few thousand entries, and a \"blessed\" file with several thousand more relationships. We found in our case most unit-related issues were not in the codes doing computation so much as the routines delivering the data between programs from different departments and labs.  We often wished there was something built into the language (almost all Fortran, some Ada PL/1, pascal,...) What we found in our particular case more of an issue at the coding level was uncertainty and accumlated floating point error issues;  I remember the consensus was that would still be solved by hardware support at the processor level -- what ever happened to that?  Think it would be great if Fortran supported units whether by types or casting or ... but that does not necessarily solve the primary issues we saw that involved input and output.  Would these solutions provide some kind of labeling of data?  I am glad XML was not around in the scientific world at the time or we might have tried that."
                },
                {
                    "user": "vansnyder",
                    "date": "2021-07-06 23:16:29+00:00",
                    "text": "I disagree with Steve (@sblionel) that the units proposal has been \"repeatedly and thoroughly considered.\" I gave a brief presentation at the 2005 Delft meeting. Malcolm and Lawrie made some comments that resulted in changes. The consensus was that this was a reasonable idea but couldn't be fit into the development schedule. I tried to bring it up for discussion at later meetings but there was no discussion. I tried to elicit discussion in e-mail but that also did not happen. I proposed to develop a non-binding TS, but WG5 voted against submitting an essentially-completed document for publication, and refused to discuss reasons for that rejection. No one has provided concrete technical objections to the proposal. No one has pointed to a section or paragraph and remarked \"this cannot work\" or \"this cannot be done.\" The objections have been the difficulty to fit it into the development schedule, or the effort required by vendors to implement it. I believe the effort, on either score, would be significantly less than coarrays or interop.\nAt meeting 167, where proposals for 2008 were initially discussed, it was proposal 04-122. In 04-265r1.xls, the \"hate dislike like love\" score was 0-3-7-1. There was no technical discussion in plenary or subgroup. Nobody who cast a \"dislike\" vote offered a reason.\nAnother objection was \"nobody has asked us for it.\" Of course, this was in response to me asking for it. I wasn't just asking for myself. I was representing more than 600 Fortran users at JPL, many of whom had admitted to having had mistakes in their codes that the proposed units system would have caught. The average cost estimate was two to three work weeks per year, but only one catastrophically expensive loss.\nTo answer some of Ondrej's questions:\nThe navigation software was in Fortran -- roughly six million lines spanning about 65 programs, being maintained at a cost of 6.5 work-years per year. People who didn't know anything about Fortran insisted in about 1996 that the entire suite of navigation and trajectory planning software had to be re-written in C++ and Python, which was done at great expense -- more than 240 work years. As late as the Mars Phoenix landing in 2008, it still didn't work.\nFor Mars Climate Orbiter, small-force data from Lockheed was ingested from text files. Contrary to Steve's assertion that the proposal would not have caught the problem that resulted in that catastrophic $300 million loss, that is precisely the reason that the proposal includes units in formatted I/O. It's possible that if units had been supported in the language, and used in the software, Lockheed software engineers could have \"lied\" in their output, claiming the units were Newton seconds when they were in fact pound seconds. But they would have had to make a conscious (or boneheadedly stupid) effort to do so. It's true that a compiler could not have caught the inconsistency because it wouldn't see both codes. But within a single code, the proposal is designed so that a processor can verify units consistency, including across procedure interfaces and between modules, and convert between related measurements based upon the same fundamental units.\nA scheme using derived types, such as Grant Petty's scheme, has high runtime overhead, and requires significantly more labor than the method I proposed.\nFortran's niche for decades has been engineering and scientific applications, with a significant financial community thrown in. All these domains would benefit from units support. I don't see cell-phone apps or video games or OS kernels or MySQL or web pages getting any benefit from it. So the argument \"other languages don't offer it\" doesn't carry much weight."
                },
                {
                    "user": "certik",
                    "date": "2021-07-07 00:51:32+00:00",
                    "text": "@vansnyder thanks for this excellent comment.\nThe big problem as I saw was that the committee and community was not archiving any kind of feedback and discussion of the proposals. As such, for somebody like me joining the committee in 2019, I can't see any discussion about your units proposal.\nBut, I think we have greatly improved the process since then. Your \"units\" proposal is getting all kinds of discussion now, in this very issue and also in this Discourse thread:\n\nhttps://fortran-lang.discourse.group/t/computations-with-units-meters-seconds/1383\n\nand at least @klausler and I are both interested in implementing this in a compiler, so that people can test this out. Yes, it should be in the language and checked by the compiler at compile time. (The IO would have to be checked at runtime, but I think it could be a quick check, depending on how it is read in, and presumably the IO is usually not the performance bottleneck -- we can brainstorm this later.)\nSo far I like the idea a lot and I think it should be pursued by prototyping in a compiler and the community should play with that. And actually discuss the pros and cons of including this.\nI reserve the right to change my mind as more details are developed. As we should all --- after prototyping and user experience, if we find this is not a good idea after all, that the pros do not outweigh the cost of this feature, then let's not do that.\nHere are the costs that every feature to Fortran (including this one) should be considered against:\n\nhttps://fortran-lang.discourse.group/t/cost-of-adding-any-new-feature-to-the-fortran-language/1479"
                },
                {
                    "user": "magicmouse",
                    "date": "2021-07-07 03:23:56+00:00",
                    "text": "One of the problems with established languages is that it is almost impossible to get agreement on sensible extensions to the language, and vast amounts of time pass by while it is laboriously discussed.  We now have 2 languages (Frink and Beads) with physical units of measure both at compile time and run-time.  The advantage of runtime units is that you can store a quantity the HD and read it in and still know the exponents. One can also verify both at compile time and run time that you are mixing proper units and not combining exponents inappropriately.\nInterestingly, when I announced the feature of units of measure on Reddit in the scientific subgroup, it was met with almost sadistic levels of scorn, by scientists who snarled that they don't make units mistakes. The engineers were similarly displeased.  I concluded from this that there is a fair amount of professional snobbery and arrogance about dumb mistakes that they don't want to admit making.  We all know about the errors people make in spreadsheets costing millions. As far as i can tell human beings get up in the morning and make a lot of mistakes.\nMy point is that there are human emotional reasons for blocking this very sensible proposal to add Units of Measure.\nEven in Mobile Apps which i have quite a bit of experience (over 100 apps), there is fairly regular use of time which has units of months, days, weeks, hours, etc. and in commerce one sees \"dozen\" and \"gross\" a fair amount.  And angular measurements are also super common (degrees / radians).  Avoiding units errors is just one of many protections against human error, and people should be more open to reducing the total volume of the envelope of possible errors.\nAnd by the way, Mr. Snyder, you can run Beads under Linux by using Wine, the freeware windows EXE runner."
                },
                {
                    "user": "sblionel",
                    "date": "2021-07-07 14:37:22+00:00",
                    "text": "My observations on the history of Van's proposal... J3 and WG5 repeatedly discussed the UNITS proposal over the years. The most recent was the 2013 Delft meeting where we spent an hour or more reviewing the proposal. My notes say:\n\"Straw vote on whether to ask SC22 to authorize work item for units TS. 3/7/1 abstain\nUS abstain, UK No, JP No, NL abstain, Canada No, Germany abstain \u00a0Not going to do it.\"\nA big problem with a TS is the presumption that it will be part of the next standard revision. I and others did not like the specific proposal, which to me was very \"F77-like\". I suggested to Van that he should create a trial implementation using derived types and then see how it works when used in an application. He didn't want to do that. Another suggestion was to fork gfortran and add the feature, but that has a steep learning barrier even for an experienced compiler developer, which Van is not.\nPersonally, I don't have an objection to the concept, but as a former compiler developer I can see how this would be a lot of work for something I expect few programmers would use. You can do almost everything desired with derived types and defined operators, and I would really like to see someone model this as such before asking WG5 to add it to the language. If one of the OSS compilers wants to try it, great!"
                },
                {
                    "user": "fluidnumerics-joe",
                    "date": "2021-07-07 15:19:37+00:00",
                    "text": "I'm curious to understand what the objection is to implementing units handling and file IO in a library rather than implementing at the compiler level. Why doesn't a cross-organization group form to make something viable that doesn't require a change in the Fortran standard. IMO, this seems to be the path of least resistance, unless there are other barriers to getting something like this done and well supported (e.g. funding).\nFrom this conversation, the \"units as a standard\" request is coming from and supported by NASA and DoD contractors but doesn't appear to have support beyond these kinds of groups. While I recognize tracking units correctly in code and in file IO is important and currently error prone, perhaps its time we rethink our software development strategy, rather than modifying a standard that impacts a broader community."
                },
                {
                    "user": "certik",
                    "date": "2021-07-07 17:15:18+00:00",
                    "text": "and I would really like to see someone model this as such before asking WG5 to add it to the language. If one of the OSS compilers wants to try it, great!\n\nYes, we are in agreement on that. I think this should be prototyped first before bringing it to WG5 or J3. (Note that I would go beyond that and I think every significant feature should be prototyped first.)"
                },
                {
                    "user": "vansnyder",
                    "date": "2021-07-07 20:48:51+00:00",
                    "text": "On Wed, 2021-07-07 at 07:37 -0700, Steve Lionel wrote:\n My observations on the history of Van's proposal... J3 and WG5\n repeatedly discussed the UNITS proposal over the years. The most\n recent was the 2013 Delft meeting where we spent an hour or more\n reviewing the proposal.\nThe most recent discussion was at Boulder in 2016, not at Delft in\n2013.\nFrom Delft 2013 minutes (N1977):\n\nVan Snyder gave a presentation \"Units of Measure in Fortran\" which\nproposed a new TS which would add the ability to check physical\ndimensions and measurements in Fortran.  The slides are in N1970 and a\ndraft TS is in N1969.  It was emphasized that these were the result of\nmany years of work and discussion with engineers at JPL.  A vote on the\nsubject was postponed to allow further informal discussion.\n\nThere were votes on whether WG5 should apply for a new project to\ndevelop a TS on units of measure, following the presentation on\nWednesday.  The individual vote was: yes 3 - no 7 - abstain 1.  The\ncountry vote was: yes 0 - no 3 (CA, JP, GB) - abstain 3 (DE, NL, US).\n\nFrom the 2015 London meeting minutes (N2068):\nIn 2013 Van Snyder had introduced a draft TS on Units of Measure in\nFortran (ref N1969, N1970, N1977).  It would be useful for his sponsors\nto know why WG5 had not adopted this project.  The convenor agreed to\nprovide a document with the reasons.\nand resolutions (N2067):\nL10. Units of Measure in Fortran\nWG5 directs its convenor to provide a document describing the reasons\nwhy WG5 did not apply for a new project to develop a TS on Units of\nMeasure in Fortran when requested to do so at its 2013 meeting.\nFrom the 2016 Boulder minutes (N2109):\nThe action in resolution L10, that the convenor should provide a\ndocument describing the reasons why WG5 did not apply for a new project\nto develop a TS on Units of Measure in Fortran, was still to be\ncompleted.\nThat report has still not been produced.\nWe most emphatically did NOT spend an HOUR reviewing and discussing the\nproposal at either the 2013 Delft meeting. the 2015 London meeting, or\nthe 2106 Boulder meeting. I gave a brief presentation (about 15\nminutes) at Delft (N1970), but discussion was more like FIVE MINUTES.\nThere was no discussion of the technical merits or members' technical\nobjections, at either meeting, or any other meeting, at least not any\nin which I was included. That there was no such discussion at or after\nDelft 2013 was the reason for L10.  I was present in every plenary\nsession in every WG5 meeting but one from February 1997 until last\nyear. I had proposed it informally before Delft. Was it discussed at\nMarkham in 2012, the only WG5 meeting I did not attend in 23 years?. If\nso, why was I not informed of the results of that discussion?  There is\nno mention of it in the minutes of the Markham meeting (N1926).\nThere has been very little off-line discussion. I received one minor\nremark in e-mail from Dick Hendrickson and one from Malcolm Cohen.\nThese were proposals for improvement, not technical objections.\n My notes say:\n\n \"Straw vote on whether to ask SC22 to authorize work item for units\n TS. 3/7/1 abstain\n\n US abstain, UK No, JP No, NL abstain, Canada No, Germany abstain  Not\n going to do it.\"\n A big problem with a TS is the presumption that it will be part of\n the next standard revision.\nThat is precisely the reason that I revised the paragraph in N1969 that\nincluded the same promise as in the allocatable, IEEE, and submodule\nTR's:\nIt is the intention of ISO/IEC JTC1/SC22/WG5 that the semantics and\nsyntax specified by this technical report be included in the next\nrevision of the Fortran standard without change unless experience in\nthe implementation and use of this feature identifies errors that need\nto be corrected, or changes are needed to achieve proper integration,\nin which case every reasonable effort will be made to minimize the\nimpact of such changes on existing implementations.\nOff-line discussion had suggested that such a promise was required by\nISO rules. But a TS, for additions to C, included a different\ndiscussion of conformance, and in fact that promise is not required by\nISO rules. From C PDTR  18037 (WG14 n3574):\nAs this is a technical report, there are no conformance requirements\nand implementers are free to select those specifications they need.\nHowever, if functionality is implemented from one of these sections,\nimplementers are strongly encouraged to implement that section in full,\nnot just a part of it.\n\nIf, at a later stage, a decision is taken to incorporate some or all of\nthe text of this Technical Report into the C standard, then at that\nmoment conformance issues with respect to (parts of) this text need to\nbe addressed.\nIn the final proposal to publish N2113 as a TS, during the 2016 WG5\nmeeting at Boulder, I pointed out that the \"promise\" in N1969 had been\nreplaced:\nThis technical specification is non-normative. Some of the\nfunctionality described by thisTechnical Specification may be\nconsidered for standardization in a future revision of ISO/IEC 1539,\nbut it is not currently part of any Fortran standard. Some of the\nfunctionality in this Technical Specification may never be\nstandardized, and other functionality may be standardized in a\nsubstantially changed form.\nAddressing this procedural objection using this revision was met with\nsilence. No technical objection has ever been raised, at least not in\nmy presence. No one has commented, in any way, on N2113.\n I and others did not like the specific proposal, which to me was very\n \"F77-like\".\nThere was, and still has not been, any  discussion of technical\nobjections to the proposal (See L10 and the Boulder 2016 minutes). I\nwas present in every plenary session at every WG5 meeting other than\n2012 at Markham, and I did not hear anyone say \"F77-like.\" I have no\nidea what that means. Fixed form? Insignificant blanks? No dynamic\nmemory? No derived types? No modules? No array operations?\n I suggested to Van that he should create a trial implementation using\n derived types and then see how it works when used in an application.\n He didn't want to do that.\nAnd I pointed out that Grant Petty already did it -- several times\nduring the preceding decade. It has substantial runtime cost and\nsubstantial labor cost, and doesn't address the problem as fully as the\nTS proposal. In particular, it does not distinguish between different\nscales of the same unit, which was precisely the problem that doomed\nthe Mars Climate Orbiter (different measures of momentum). Addressing\nscale would increase both run-time and labor costs. Units' exponents\nare not checked at compile time. There is no provision for abstract\nunits. There is no provision for base units other than the ISO base\nunits. If exponents of base units are represented using kind type\nparameters, instead of components, the exponents (but not the scales)\nof derived units are checked at compile time. One must replicate all\narithmetic operations, all related intrinsic functions, and many of the\nfunctions of the user's program, not just for one type, but for all\nexpected combinations of kind type parameter values. There is an\nexponential explosion in the bulk of code, the cost to develop it, and\nthe cost to maintain it (this would be somewhat addressed by\nparameterized modules). If functions become type-bound, enormous labor\ncost is required to revise their syntax of reference (that is a\ndifferent problem for which I offered solutions -- which were rejected\n-- in 1986 and 1999).\nThe purpose of a high-level language is to reduce labor cost and\nincrease reliability, while retaining efficiency. Increasing\nreliability using minor increases in labor cost, and entailing no run-\ntime penalty, are acceptable. Proposals to increase reliability by\nincreasing labor cost substantially and reducing efficiency\nsubstantially are not to be taken seriously, especially if they do not\nand cannot address the problems well.\n  Another suggestion was to fork gfortran and add the feature, but\n that has a steep learning barrier even for an experienced compiler\n developer, which Van is not.\nI don't pretend to be a Fortran developer. I participated in\ndevelopment of three Fortran-related preprocessors. But I have written\nprocessors for several smaller interpreted languages. Units checking,\nincluding automatic scale conversion, was included in several of those,\nalthough not as comprehensively as proposed in N2113.\n Personally, I don't have an objection to the concept, but as a former\n compiler developer I can see how this would be a lot of work for\n something I expect few programmers would use.\nI do not expect units to be used in a compiler, MySQL, an OS kernel, or\ncell-phone app. Maybe in a video game. When I worked in the Applied\nMathematics Group at JPL, we provided libraries of mathematical\nsoftware, and consultancy on mathematical and software methods to\naddress scientific and engineering problems. My experience during that\nquarter century, and the next quarter century during which I developed\nscientific and engineering software, was that I and about 600 of my\ncolleagues frequently made masteakes in the use of units. It was that\nexperience, and the urging of our colleagues, that led our group to\npropose to Colonel Whittaker in 1976 that the requirements for the\nlanguage that became Ada should include units facilities. Colonel\nWhittaker couldn't understand why one would want software libraries,\nlet alone checking something as important as correct usage of units, in\na language explicitly designed for reliability. \"I used a software\nlibrary once, and it got the wrong answer.\"\n You can do almost everything desired with derived types and defined\n operators, and I would really like to see someone model this as such\n before asking WG5 to add it to the language.\nAs I remarked above, and several times during the preceding decade,\nGrant Petty already did this.\nIf someone has an idea for something other than Grant Petty's project,\nI would like to see someone explain it using a bit more than this vague\nhandwaving. Grant Petty's module has significant runtime cost and\nsignificant labor cost, and doesn't address the problem well. I have\nnot seen a discussion of or proposal for a method using \"derived types\nand defined operators\" that circumvents these problems.\nAnd N2113 didn't promise to add it to the language. I believe the fear\nwas that if N2113 were published as a non-normative non-binding TS,\nmore people who use Fortran than just those who participate in\nstandards committees (as opposed to developers) might see the value of\nit, and ask WG5 to incorporate it into a future standard.\n If one of the OSS compilers wants to try it, great!\nPublishing a TS is the traditional way to specify how to \"try it.\"\n\u2026\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\n [\n {\n ***@***.***\": \"http://schema.org\",\n ***@***.***\": \"EmailMessage\",\n \"potentialAction\": {\n ***@***.***\": \"ViewAction\",\n \"target\": \"\n #50 (comment)\n \",\n \"url\": \"\n #50 (comment)\n \",\n \"name\": \"View Issue\"\n },\n \"description\": \"View this Issue on GitHub\",\n \"publisher\": {\n ***@***.***\": \"Organization\",\n \"name\": \"GitHub\",\n \"url\": \"https://github.com\"\n }\n }\n ]"
                },
                {
                    "user": "vansnyder",
                    "date": "2021-07-07 20:54:31+00:00",
                    "text": "On Wed, 2021-07-07 at 08:19 -0700, Joseph Schoonover wrote:\n I'm curious to understand what the objection is to implementing units\n handling and file IO in a library rather than implementing at the\n compiler level.\n1. Errors that could have been detected at compile time are raised\nat run time. Errors raised at run time can have catastrophic impact,\nand occasionally cannot be corrected. For example, the developer has\ndied or retired, the company, division, or group has closed, or the\nsource code has been lost.\n   2. Labor cost is substantially greater.\n   3. Run-time penalties are significant.\n Why doesn't a cross-organization group form to make something viable\n that doesn't require a change in the Fortran standard. IMO, this\n seems to be the path of least resistance, unless there are other\n barriers to getting something like this done and well supported (e.g.\n funding).\n\n From this conversation, the \"units as a standard\" request is coming\n from and supported by NASA and DoD contractors but doesn't appear to\n have support beyond these kinds of groups. While I recognize tracking\n units correctly in code and in file IO is important and currently\n error prone, perhaps its time we rethink our software development\n strategy, rather than modifying a standard that impacts a broader\n community.\nIf units checking were added to the Fortran standard as proposed in WG5\nN2113, and implemented in processors, it would have no impact on\nexisting codes, and no impact on codes that choose not to exploit it.\n\u2026\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\n [\n {\n ***@***.***\": \"http://schema.org\",\n ***@***.***\": \"EmailMessage\",\n \"potentialAction\": {\n ***@***.***\": \"ViewAction\",\n \"target\": \"\n #50 (comment)\n \",\n \"url\": \"\n #50 (comment)\n \",\n \"name\": \"View Issue\"\n },\n \"description\": \"View this Issue on GitHub\",\n \"publisher\": {\n ***@***.***\": \"Organization\",\n \"name\": \"GitHub\",\n \"url\": \"https://github.com\"\n }\n }\n ]"
                },
                {
                    "user": "certik",
                    "date": "2021-07-07 21:47:09+00:00",
                    "text": "@vansnyder my understanding is that the main feedback from WG5 is to implement this in a Fortran compiler as a prototype (which has never been done yet).\nWhat has been done is to prototype this using derived types and operators, e.g., by Grant Petty. I have found the following references to his work:\n\nhttps://onlinelibrary.wiley.com/doi/abs/10.1002/spe.401 (pdf)\nThe paper provides a link: http://meso.aos.wisc.edu/~gpetty/physunits.tar.gz to the module and sample programs (the link does not work anymore, but I linked it via the wayback machine which seems to work)"
                },
                {
                    "user": "vansnyder",
                    "date": "2021-07-07 22:33:08+00:00",
                    "text": "On Wed, 2021-07-07 at 14:47 -0700, Ond\u0159ej \u010cert\u00edk wrote:\n @vansnyder my understanding is that the main feedback from WG5 is to\n implement this in a Fortran compiler as a prototype.\n\n What has been done is to prototype this using derived types and\n operators, e.g., by Grant Petty. I have found the following\n references to his work:\n\n\n https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.401 (pdf)\n The paper provides a link:\n http://meso.aos.wisc.edu/~gpetty/physunits.tar.gz to the module and\n sample programs (the link does not work anymore, but I linked it via\n the wayback machine which seems to work)\n\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\nWe already have experience with Grant Petty's package. It doesn't check\nexponents of base units at compile time. It can't do anything about\ndifferent scalings of the same derived unit, such as momentum. It\nrequires more labor. It imposes run-time penalties.\n\nI realize that the proposal in N2113 would require more development\nwork within the compiler. I suspect that at least some of it would be\nhandled by an extension of the work that was required to allow more\nthan one kind type parameter for a variable. In many ways, the UNIT\nspecification acts like a kind type parameter. Tests for structural\ncompatibility would be entirely new. Calculating units by combining\nfactors within a term would be entirely new. Creating conversion\nfunctions would be entirely new. I/O would be entirely new. Even with\nall this entirely new work, I suspect the effort would be substantially\nless than the work required for coarrays or C interop."
                },
                {
                    "user": "certik",
                    "date": "2021-07-07 23:09:25+00:00",
                    "text": "I realize that the proposal in N2113 would require more development work within the compiler. I suspect that at least some of it would be handled by an extension of the work that was required to allow more than one kind type parameter for a variable. In many ways, the UNIT specification acts like a kind type parameter. Tests for structural compatibility would be entirely new. Calculating units by combining factors within a term would be entirely new. Creating conversion functions would be entirely new. I/O would be entirely new. Even with all this entirely new work, I suspect the effort would be substantially less than the work required for coarrays or C interop.\n\nYes. It is my understanding that WG5 recommends to implement it in the compiler as the next step.\nYes I think it would not be that difficult, and I know at least @klausler and myself would be interested in attempting it. Hopefully more people would help."
                },
                {
                    "user": "magicmouse",
                    "date": "2021-07-08 03:28:29+00:00",
                    "text": "Using Van Snyder's proposal as a starting point, i added Units of Measure to my Beads language. In the syntax, i allow a new datatype that of meas, which has the normal engineering unit families of angle, mass, length, area, pressure, energy, etc. In each unit family there are various units, with either constant scaling factors that relate a unit like kilometer to the meter, or specifies a function to go to and from the base unit.  The user can create their own unit families, with a unique set of fundamental primitives like mass/length/ etc, and is limited to ratio of integer exponents.  During compile time and runtime the measurement internally consists of a record consisting of a magnitude, the unit family it belongs to, and the current array of exponents in a canonical form.  As you multiply quantities the exponents add.  The user can thus conveniently write 3 kg + 2 lb + 3 g, and it will automatically do the units conversions.   3 kg * 4 m / 2 sec would remember the exponents.  As there are only a few operators, it is not a big effort to carry these units around, and one can always uses scalars in large matrics so as to not burden the system.\nAnyone claiming that we can't tolerate any extra overhead in calculations to ensure they are correct has not been paying attention to the over 1 million to 1 reduction in the cost of computation, since i was using the Univac 1108 at JPL in 1971. And let's not forget that stupid BitCoin used terawatt-hours of electricity doing useless calculations in a proof-of-waste scheme that is the greatest peacetime waste of resources in modern times.\nThe complexity to implement physical of units is fairly small. You have to handle meas * meas, scalar *meas, and one needs a few conversion functions so you can get a value to and from the preferred unit. The compiler has to track quite a bit more information (the array of exponents, the unit family, etc.) as it does its type calculations, but it isn't that hard, and compared to the fancy code optimizations that exist in the back-ends of compilers, this front end work is not a difficult task.\nThat the FORTRAN committee ignores the brilliant work of Van Snyder, whose long tenure at one of the crown jewels of the US high tech industry, and ignores the pioneering work of Fermat who invented the technique of checking units to proofread formulae in the 1800's is inexcusable inertia.\nIt is faster to write a whole new language (it took me 4 years so far) than to get a committee off its rear ends.  C. Northcote Parkinson wrote extensively about how committees function, and perhaps the committee is too large; i think he set the limit at 8 or 12 i can't remember."
                },
                {
                    "user": "magicmouse",
                    "date": "2021-07-08 05:03:25+00:00",
                    "text": "And with regards to proposal such as adding refinement types: by the time you have added sufficient abstraction power to have families of related units, and tracking exponents, you have built a more complex type system than Haskell or any other Category-theory laden language. The point is not to turn FORTRAN into a super-Haskell, but to gracefully and minimally extend FORTRAN to support his vital function.\nAddition of this new data type is slightly more work than adding COMPLEX numbers was; you convert a single scalar value into 2 values in complex numbers, for a unit of measurement it is a record of a few fields. Since there are only 5 operations:  addition, subtraction, multiplication, division, and exponentiation to fractional powers, that is only 5 runtime functions to invoke.  It's just not that hard."
                },
                {
                    "user": "certik",
                    "date": "2021-07-08 13:26:45+00:00",
                    "text": "@magicmouse thank you for your comments. Just a reminder that we have a Code of Conduct: let's criticize the committee if you think they have not done a good job sometimes, but let's not be demeaning about it.\nRegarding performance:\n\nAnyone claiming that we can't tolerate any extra overhead in calculations to ensure they are correct has not been paying attention to the over 1 million to 1 reduction in the cost of computation, since i was using the Univac 1108 at JPL in 1971.\n\nIt is my understanding that unit would not have any runtime overhead, except perhaps a very small overhead in IO (if you use them). Is that not the case?\nRuntime overhead would be unacceptable for me. Yes, computers got faster, but that's besides the point: if Fortran suddenly intrinsically becomes slower for array operations, then somebody else will write a language that is faster. The way Fortran is designed is that it allows the compiler to (in theory) extract high percentage of the available performance, there are no intrinsic features that prevent performance. Well, there is the new reallocate LHS feature that possibly slows things down (and I am against it for the same reason, but that's another discussion). The point us: just the fact that hardware is fast compared to the past does not mean that we can waste cycles: if that was true, then everybody would be using Python for HPC. I love Python, and use it precisely because it is easy. It's often at least 200 times slower than Fortran, and yet computers have got 200 faster since the first time I used Python: one can definitely use Python now and be faster than any Fortran code 30 years ago --- and yet people including myself still want to use Fortran today, not Python, for high performance computing.  As possibly the single core performance will stop getting faster in the next 10 years or so, I think performance of compilers will become even more important."
                },
                {
                    "user": "vansnyder",
                    "date": "2021-07-08 18:28:23+00:00",
                    "text": "On Thu, 2021-07-08 at 06:26 -0700, Ond\u0159ej \u010cert\u00edk wrote:\n @magicmouse thank you for your comments. Just a reminder that we have\n a Code of Conduct: let's criticize the committee if you think they\n have not done a good job sometimes, but let's not be demeaning about\n it.\n\n Regarding performance:\n\n > Anyone claiming that we can't tolerate any extra overhead in\n > calculations to ensure they are correct has not been paying\n > attention to the over 1 million to 1 reduction in the cost of\n > computation, since i was using the Univac 1108 at JPL in 1971.\n\n It is my understanding that unit would not have any runtime overhead,\n except perhaps a very small overhead in IO (if you use them). Is that\n not the case?\nThat was the intent of my design. The only runtime overhead is where\nthere is an explicit conversion between scales of the same base (or\nderived) unit. This is done by a function reference. The function is\ncreated automatically by the unit declaration. If your program deals\nwith different scales -- Newton-seconds as opposed to pound-seconds,\nfor example -- you would need to write and invoke these functions\nanyway.\n Runtime overhead would be unacceptable for me.\nFor me, at least in the last project before I retired, it would be\nunacceptable too. The project has a small (by today's standards)\ncomputer, consisting of 384 cores. It is analyzing data from an Earth-\nobserving instrument that returns 500 million measurements of microwave\nthermal emission from the atmosphere every day. By inverting the\nradiative-transfer equation using a Newton iteration, it produces about\nfive million measurements of temperature, humidity, and about fifteen\nminor constituents of the atmosphere -- such as ozone -- on 3500\nprofiles at 72 pressure levels between 8 and 80 kilometers altitude,\nevery day. The instrument scans only in the orbit plane, so we get a\nview of a 2-D slice of the atmosphere (http://mls.jpl.nasa.gov). The\nnext proposed instrument would scan like a TV, providing a 3-D view of\nthe atmosphere. It would return 400 times as much data. Making the\nprogram 3-10 times slower by  computing things at runtime that could be\ncomputed at compile time would not be acceptable.\n\u2026\n Yes, computers got faster, but that's besides the point: if Fortran\n suddenly intrinsically becomes slower for array operations, then\n somebody else will write a language that is faster. The way Fortran\n is designed is that it allows the compiler to (in theory) extract\n high percentage of the available performance, there are not intrinsic\n features that prevent performance. Well, there is the new reallocate\n LHS feature that possibly slows things down (and I am against it for\n the same reason, but that's another discussion). The point us: just\n the fact that hardware is fast compared to the past does not mean\n that we can waste cycles: if that was true, then everybody would be\n using Python for HPC. I love Python, and use it precisely because it\n is easy. It's often at least 200 times slower than Fortran, and yet\n computers have got 200 faster since the first time I used Python: one\n can definitely use Python now and be faster than any Fortran code 30\n years ago --- and yet people including myself still want to use\n Fortran today, not Python, for high performance computing.  As\n possibly the single core performance will stop getting faster in the\n next 10 years or so, I think performance of compilers will become\n even more important.\n\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\n [\n {\n ***@***.***\": \"http://schema.org\",\n ***@***.***\": \"EmailMessage\",\n \"potentialAction\": {\n ***@***.***\": \"ViewAction\",\n \"target\": \"\n #50 (comment)\n \",\n \"url\": \"\n #50 (comment)\n \",\n \"name\": \"View Issue\"\n },\n \"description\": \"View this Issue on GitHub\",\n \"publisher\": {\n ***@***.***\": \"Organization\",\n \"name\": \"GitHub\",\n \"url\": \"https://github.com\"\n }\n }\n ]"
                }
            ]
        },
        {
            "number": 49,
            "user": "certik",
            "date": "2019-10-27 21:34:15+00:00",
            "title": "Wish List for Fortran after 2015 from Van Snyder",
            "text": "Van has collected feedback over the past 50 years and with his permission, I am posting his document here:\n\nwishlist.pdf (November 17, 2017)\nwishlist.pdf (February 2, 2022)\n\nI plan to extract all ideas from the document and create issues here. Many of the ideas are interesting, but would have to be developed more. Some of the ideas were rejected by the committee, but I would still like to create an issue for it, and then write up arguments why it was rejected, along with the link to the formal proposal that was submitted to the committee. So that future proposals can learn from the previous work.\n1 Important\n\n1.1\u201cPhysical\u201d or \u201cEngineering\u201d Units of Measure (#50)\n1.2 Improvements to the type system\n\n1.2.1 A more complete type system should be provided (#51, #52)\n1.2.2 New types \u2013 not type synonyms \u2013 from existing types\n\n\n1.3 Updaters\n1.4 Uniform syntax (#53)\n1.5 Exception generation and handling\n1.6 Coroutines\n1.7 Generic programming\n1.8 An assertion system would have several benefits\n1.9 Structured parallelism would assist to exploit modern architectures\n\n2 Useful\n\n2.1 Improvements to constructs\n\n2.1.1 All constructs should be allowed to have specification parts\n...\n\n\n...",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-12 03:25:48+00:00",
                    "text": "This one also has some good stuff in there: https://wg5-fortran.org/N1951-N2000/N1972.pdf"
                },
                {
                    "user": "certik",
                    "date": "2019-11-12 18:26:17+00:00",
                    "text": "@jacobwilliams thanks, I moved your link into #80. I would like this issue to be just Van's ideas."
                }
            ]
        },
        {
            "number": 48,
            "user": "jacobwilliams",
            "date": "2019-10-27 14:08:20+00:00",
            "title": "Put the standard on GitHub",
            "text": "Put the LaTeX code for the standard on GitHub, and allow the community to help edit it.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-27 14:53:35+00:00",
                    "text": "I would very much like that! However the ISO doesn't allow that. Ultimately I would like to figure out some compromise. Right now we can't do it, and I agree we need to work on fixing it. How does C++ do it? They have the same problem.\n\u2026\nOn Sun, Oct 27, 2019, at 8:08 AM, Jacob Williams wrote:\n Put the LaTeX code for the standard on GitHub, and allow the community to help edit it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub <#48?email_source=notifications&email_token=AAAFAWG456RRDSY3MP4XGPTQQWOFJA5CNFSM4JFR2WU2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUTKCIA>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGUQKSWJ5TORTKMO63QQWOFJANCNFSM4JFR2WUQ>."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-27 17:00:59+00:00",
                    "text": "There has to be a way since C++ does do it: https://github.com/cplusplus/draft"
                },
                {
                    "user": "certik",
                    "date": "2019-10-27 17:32:17+00:00",
                    "text": "Great! I was told this cannot be done. Yet C++ is doing it. Let's do what they do.\n\u2026\nOn Sun, Oct 27, 2019, at 11:00 AM, Jacob Williams wrote:\n There has to be a way since C++ does do it: https://github.com/cplusplus/draft\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#48?email_source=notifications&email_token=AAAFAWCOO5JPNHRMRYOVK63QQXCMXA5CNFSM4JFR2WU2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECLDANY#issuecomment-546713655>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWCKXMB6YFK7VRJB33DQQXCMXANCNFSM4JFR2WUQ>."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-27 23:12:16+00:00",
                    "text": "@jacobwilliams wrote:\n\nPut the LaTeX code for the standard on GitHub, and allow the community to help edit it.\n\nUsing an online collaborative platform - GitHub being ideal at present - for language development which then includes whatever postscript is used for the standard document is exactly what Fortran needs to speed up the process and erase certain feature deficits that are holding it back.  This will help Fortran rise back as the lingua franca of scientific and technical/numerical programming.\nAlas this has been discussed elsewhere in the past and this idea faces great resistance.\nIdeally the core development of the Fortran language will, in a deep, philosophical sense, be independent and separate from the Fortran standard and the IEC ISO document for the Fortran standard would simply fall naturally out of the development process, as if a byproduct.  And most of the \"heavylifting\" to pull together the IEC ISO document would be mechanical that can be scripted/automated or otherwise be collated and refined by many sharp minds looking at it together i.e.,, the online collaborative model feasible using GitHub should work well for this.\nUnfortunately though, it appears as if the standard document is the cart that is placed before the horse for quite a while now and it is the product that dictates what Fortran can be or not i.e., an inverted development model is influencing matters.  The advancement of the language likely suffers as a consequence of this.\nAs things stand, the job of the standard editor is considered the most difficult and demanding.  And none but one is seen as being capable of it.  That should not be the case, it's way too risky for a language to be in such a precarious position, to be so badly dependent on one individual.  An online collaborative model that is designed to greatly ease the burden can make it such many, many people will aspire and be seen as capable of the editor's job.\nFortran really needs such security."
                },
                {
                    "user": "certik",
                    "date": "2019-10-27 23:52:29+00:00",
                    "text": "I agree the cart is currently before the horse. It will take time before we can get the horse at front.\nIn the meantime, even with the cart in front of the horse, we still need to be using github for the standard and collaborate on it. All pull requests (PRs) can still be merged just by one person initially. Until more people gain the trust of the community that they can have merge rights.\nAlso, this standard editing process should really be a byproduct of which proposals the committee approves. The committee itself can (almost) work like today, with formal proposals and such, as long as the committee will consider proposals that we will submit for all subsequent meetings as a result of this github collaboration."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-30 12:47:17+00:00",
                    "text": "At a minimum, this site should provide either a link to the F2018 interpretation document which is probably very close to the public standard (currently at https://j3-fortran.org/doc/year/18/18-007r1.pdf) or make the pdf available for download directly from this site"
                },
                {
                    "user": "rweed",
                    "date": "2019-10-30 15:09:17+00:00",
                    "text": "I have converted the interpretation document (18-007r1.pdf) to HTML, TeX, and Markdown using pdftohtml and the pandoc utility on Linux. I've verified that the HTML and TeX are readable by Firefox and TexMaker. I'm new to Markdown so I'm looking for a good Linux reader. I'll upload here if someone can tell me the best way to upload a ZIP or tgz file. The resulting files are very big and pdftohtml created several hundred PNG images (don't know why) so uploading them in an archive is the best option. Caveat, as with all format conversion tools I don't expect a 100% accurate translation from PDF so somethings in the original PDF might have gotten mangled."
                },
                {
                    "user": "certik",
                    "date": "2019-10-30 15:55:11+00:00",
                    "text": "@rweed thanks! I think this is what we would do if we lost the sources to the standard. But the committee has the sources (or to be more precise, at least one person on the committee has the sources), so I will try to convince the committee to put the sources on github."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-30 19:09:16+00:00",
                    "text": "@rweed wrote:\n\nI have converted the interpretation document (18-007r1.pdf) to HTML, TeX, and Markdown ..\n\nI'll strongly recommend contacting WG5 and/or PL22.3 and confirm there are no copyright or other restrictions with document 18-007r1, especially with distributing any changes online anywhere even if they are in the electronic format only."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-30 19:49:58+00:00",
                    "text": "@FortranFan, I agree. However, there appears to be no restriction on downloading the PDF from J3 (which implies to me that redistribution is O.K.) and as I understand it WG5 only limits distribution of the final version of the standard that goes to the publisher.  Still, you are correct we should get a ruling on if there are any unstated restrictions on distribution/redistribution."
                }
            ]
        },
        {
            "number": 47,
            "user": "jacobwilliams",
            "date": "2019-10-27 14:06:42+00:00",
            "title": "Fortran needs an official logo",
            "text": "It should be modern, iconic, and hopefully not that ugly brown color from the original Fortran manual.\nEven C++ has a logo now.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-27 14:48:27+00:00",
                    "text": "Yes!\n\nOne idea could be to convey a combination of old, trusted, robust, fast and modern. Because it's old, but also modern.\n\u2026\nOn Sun, Oct 27, 2019, at 8:06 AM, Jacob Williams wrote:\n It should be modern, iconic, and hopefully not that ugly brown color from the original Fortran manual.\n\n Even C++ <https://github.com/isocpp/logos> has a logo now.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub <#47?email_source=notifications&email_token=AAAFAWAXUU3SH5XLZCNYTH3QQWN7FA5CNFSM4JFR2PW2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUTJ7MA>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGAKFUZHJ2UXHDQBL3QQWN7FANCNFSM4JFR2PWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-27 21:25:07+00:00",
                    "text": "I love this. I suggest that the Fortran logo should not:\n\nBe a white lowercase letter f on a blue background\nHave an illustration of a punchcard in it\n\nI think this thread could be used to submit mock-ups or even finished designs, and people can vote up their favorites."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-27 21:37:30+00:00",
                    "text": "Nooooo punchcards!!!"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-27 21:59:57+00:00",
                    "text": "I love this. I suggest that the Fortran logo should not:\n* Be a white lowercase letter `f` on a blue background\n\n...\n\nI'm feeling a bit attacked in my choice of logo/favicon for FORD \ud83d\ude06"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-27 22:01:59+00:00",
                    "text": "I made this some time ago, but I'm not wild about it."
                },
                {
                    "user": "septcolor",
                    "date": "2019-10-28 13:09:50+00:00",
                    "text": "It seems that some services also want to find a Fortran logo, but no widely accepted ones found...\nFortran / official or unofficial logo\nexercism/meta#46\nLogo needed\nexercism/fortran#5\nSearching for \"Fortran logo\" gives these images.\nSearching for \"formula translator logo\" gives these ones.\nSearching for \"formula one logo\" gives these images (just for comparison)."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-28 13:23:35+00:00",
                    "text": "What does \"official\" mean here? Does it mean approved by the committee? Or selected by the community?\nFor a first stab, a simple and incremental approach could be surprisingly effective:\n\nPick a background color (not brown);\nPick a foreground color (not brown);\nPick a font style;\nType \"Fortran\";\n\nI also like just the initial variant of it (F), like that of @jacobwilliams, but something less brown \ud83d\ude04\n(caveat: I'm not a designer, and am not known for good design :D)"
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 13:30:46+00:00",
                    "text": "Ideally it would be first selected by the community and then approved by the committee.\n\u2026\nOn Mon, Oct 28, 2019, at 7:23 AM, Milan Curcic wrote:\n What does \"official\" mean here? Does it mean approved by the committee? Or selected by the community?\n\n For a first stab, a simple and incremental approach could be surprisingly effective:\n\n * Pick a background color (not brown);\n * Pick a foreground color (not brown);\n * Pick a font style;\n * Type \"Fortran\";\n I also like just the initial variant of it (F), like that of @jacobwilliams <https://github.com/jacobwilliams>, but something less brown \ud83d\ude04\n\n (caveat: I'm not a designer, and am not known for good design :D)\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#47?email_source=notifications&email_token=AAAFAWBTM47MNMJPWOVOPYLQQ3RVPA5CNFSM4JFR2PW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECM3EUI#issuecomment-546943569>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGZEHAX7GDZE44S7S3QQ3RVPANCNFSM4JFR2PWQ>."
                },
                {
                    "user": "septcolor",
                    "date": "2019-10-28 14:05:16+00:00",
                    "text": "Using some online (free) service and typing \"Fortran\" gives me this kind of image:\n\nIt might be interesting to experiment with such services and gather samples (as a starter). Another idea might be to use some animal or fictitious/symbolic icon :)\nPersonally, I also like a single letter \"F\" (but not so brown..)"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-28 14:18:02+00:00",
                    "text": "Just thinking out loud here, but sometimes language and library logos will somehow incorporate a key feature or concept. For example, the NumPy logo (which I can't say I particularly like) has a representation of a multi-dimensional array.\nI would consider Fortran's key features to be its speed and its powerful array handling. So perhaps some syntax to indicate array slicing could be incorporated. Say, instead of just an F it could be F(:) or F(:,:)."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-28 14:27:56+00:00",
                    "text": "I would consider Fortran's key features to be its speed and its powerful array handling. So perhaps some syntax to indicate array slicing could be incorporated. Say, instead of just an F it could be F(:) or F(:,:).\n\nI'm a strong advocate for Fortran's native parallelism and array features, so would F(:)[:] work? \ud83d\ude04"
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-28 14:31:09+00:00",
                    "text": "Another idea might be to use some animal or fictitious/symbolic icon :)\n\nI like it. Some recent languages (Rust, Go, etc.) have a language mascot, which helps them appear cute, whimsical, playful, and friendly. Seems like a silly thing, but it would help Fortran's long term image IMO."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 15:04:12+00:00",
                    "text": "I am not a big fan of a mascot personally, but I really like the other proposed ideas."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-28 15:16:10+00:00",
                    "text": "Given the resistance of the committee and some vocal compiler developers to anything that will \"break legacy code\", it should contain an image of a punch card or the old Fortran coding forms (AKA green sheets) :>)"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-28 16:12:53+00:00",
                    "text": "Possible spirit animals: cheetah or peregrine falcon (two of the fastest animals)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 18:14:05+00:00",
                    "text": "One would think the first step would be to grab a suitable domain, say HTTPS fortran.org or some such, similar to that for other languages e.g., Python, C++ under the auspices of WG5 org itself or a seeded foundation dedicated to Fortran.  The logo can be part of this."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-28 18:21:38+00:00",
                    "text": "I've owned fortran-lang.org for some time now (unused). Will be happy to transfer it to the org, or continue managing it myself if somebody can contribute a basic, static, good-looking site (I know basic, but not good looking).\nI agree that in the long term, a Fortran foundation is the way to go to ensure the language well being, but that's a whole another beast on its own."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 21:20:13+00:00",
                    "text": "@milancurcic good point. Python has a Python Software Foundation (PSF), but I actually don't know how the PSF is involved in approving PEPs (the proposals to improve the Python language). It seems the language standard itself might be different from the foundation."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-28 21:52:43+00:00",
                    "text": "I think the standard (and the committee) should be separate and independent from the hypothetical Fortran Foundation (FF).\nFF would seek donations from orgs invested in Fortran, and would fund the hosting of community websites, meetups, and eventually the development open source compilers and libraries.\nIn the long term, the FF could fund new members to join J3, which I hear is expensive unless not an alternate to an existing member.\nI think foundations should act to funnel unallocated funds into useful causes. I don't think FF should make calls about Fortran Standard proposals.\nOf course, as I and others mentioned in other issues, once there is a reference implementation with enough many developers to implement and test experimental features, then we could have a cart behind the horse. In this way a FF could contribute to language development, but I see it a long term vision."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-30 02:54:50+00:00",
                    "text": "Some food for thought (made with Logoist):\n\nI'm still going to make a peregrine falcon one when I get a chance. :)"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-30 11:50:55+00:00",
                    "text": "@jacobwilliams wrote:\n\nSome food for thought (made with Logoist):\n\nI'm still going to make a peregrine falcon one when I get a chance. :)\n\nA couple of points for consideration:\n\nFortran array slice notation as in say F(:) can have considerable adverse impact in code and should be used sparingly after considerable thought.  So its presence in a logo might convey a questionable message\nThere might be value in retaining focus on Formula Translation and perhaps draw inspiration from famous formulae in science and engineering for the Fortran logo? example"
                },
                {
                    "user": "rweed",
                    "date": "2019-10-30 12:59:43+00:00",
                    "text": "How about something that reflects the many things Fortran helped bring to the world. As an old Aerospace Engineer, I would suggest SR71, Apollo/Saturn5, Space Shuttle, F15/F16, etc. You could also find various examples of buildings, dams, bridges etc along with automobiles. Also ballistic missile and attack subroutines which for those familiar with the technology and the challenges posed by the operating enviroment were as big a challenge as going to the moon."
                },
                {
                    "user": "certik",
                    "date": "2019-10-30 16:03:16+00:00",
                    "text": "@rweed great idea. It's actually surprisingly hard to find more details how Fortran was used for some of the things you mention. For example for the Saturn 5 rocket, there is this: https://en.wikipedia.org/wiki/Saturn_V_instrument_unit, and no mention of Fortran. The Apollo 11 Guidance Computer sources are on GitHub: https://github.com/chrislgarry/Apollo-11, and they used their own assembly like language. So I don't know if Fortran was used at all. I assume it was at some point."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-30 16:49:32+00:00",
                    "text": "I can verify that Fortran was used quite extensively for both Apollo and Shuttle for things like trajectory design, mission planning, guidance, navigation and Control algorithm verification etc. NASA had a Fortran program called Space Vehicle Dynamic Simulation (SVDS) that was used for the above. I was one of the guys in the late 1970s that was responsible for its care and feeding to support Shuttle prior to first launch. What might interest the younger folks is this program (although the code base contained several thousand lines of code) ran on an UNIVAC 1108 system that had 64K (yes 64K) of memory to run programs in. The code had a preprocessor that figured out just what parts of the code you needed for your particular task based on your input and only compiled that. The UNIVAC compiler also supported OVERLAYS (which made debugging fun) so youcould go a little beyond the 64K into extended memory. Of course unlike today, the compiler was for the most part bullet proof. I don't remember ever encountering anything like an ICE in all the years I used the UNIVAC compilers (or VAX, CDC, early CRAY compilers from that era for that matter).  These days ICE appears to be the norm rather that the exception.\nAlso another historical note: The Space Shuttle on-board computers ran a language called Higher-Order Assembly Language/Shuttle (HAL/S) that was a derivative of XPL which in turn was a derivative of PL/I. It came out of MIT I believe because Draper Labs was heavily involved in the Guidance and Control software design."
                },
                {
                    "user": "nncarlson",
                    "date": "2019-10-30 20:30:08+00:00",
                    "text": "Possible spirit animals: cheetah or peregrine falcon (two of the fastest animals).\n\nThis reminded me of a short exchange on the lfortan discussion board on the same topic where someone suggested a dragon (some connection to llvm?) Which prompted this tongue-in-cheek response from me: \"Or a somewhat similar dinosaur :) as a nod to the popular impression of Fortran, but pick something agile and quick like a velociraptor!\""
                },
                {
                    "user": "certik",
                    "date": "2019-10-30 21:49:22+00:00",
                    "text": "I guess I am in a conflict of interest here, since I am also searching for a logo for LFortran... I do like the idea of a Velociraptor."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-31 01:21:16+00:00",
                    "text": "This talk of spirit animals reminds me of the pictures of animals that grace the covers of O'Reilly books. The two Fortran related books I remember are Unix for Fortran Programmers which featured a wooly mammoth/mastadon and Kerigan's Migrating to Fortran 90 which featured a Canada goose (a migratory bird). like @nncarlson's dinosaur I think the mammoth (or its modern descendents) might unfortunately be a metaphor for the current state of Fortran ie overly large, clumsy but still capable of covering a lot of ground in a hurry once it gets going.  However, since the current \"migration\" to Fortran 2003/2008/2018 and beyond is happening at glacial pace, I would propose the Monarch butterfly that migrates from Mexico to as far as southern Canada but takes five generations to do it. ie the butterflies that complete the migration are descendents of the ones that started from Mexico. All the other generations perish along the way. I'm afraid that like the Monarchs some of us will be long dead before Fortran completes its current \"migration\""
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-03 16:19:52+00:00",
                    "text": "Digital Visual Fortran had a logo that I liked, and hinted at the range of application types for which Fortran was well suited."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-14 15:12:43+00:00",
                    "text": "I really like the Digital Fortan one.  I once had a discussion about this and everyone was settling on a checkered flag that looked somewhat like an F. The checkered flag represented arrays and some thought it evoked the word \"Formula\" as in Formula 1 racing. It was black and white which was easy to reproduce on paper and in low-res. Been looking and have not found it yet. It was waving but not much so it did not loose the \"F\" appearance.  At the time something like the Digigal Fortran one would have been too \"expensive\" to be used as a simple icon.  Is the Digital Visual Fortran one I could use on my web page or is it restricted (if anyone knows)?"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-14 15:31:21+00:00",
                    "text": "I would not use the DVF logo as it is - I don't know if the photos in the individual blocks were licensed or were \"freeware\", so if you do decide to reuse it I suggest you recreate it using different photos. As far as I know, DEC never claimed the logo as a trademark and I really doubt HP would care if the general design was reused."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-01-15 03:43:57+00:00",
                    "text": "If a were going to pick a mascot how about a phoenix?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-15 04:36:11+00:00",
                    "text": "The Fortran Phoenix does have a nice ring too it, but somehow I was picturing a turtle with an F on it's back."
                },
                {
                    "user": "certik",
                    "date": "2021-07-01 20:38:31+00:00",
                    "text": "I think this is now fixed!   @jacobwilliams and @milancurcic have created a Fortran logo:\nhttps://fortran-lang.org/\nThis might be the first issue that we fixed in this repository."
                }
            ]
        },
        {
            "number": 46,
            "user": "FortranFan",
            "date": "2019-10-27 04:22:55+00:00",
            "title": "An alternate take on Enumeration Types: an approach seeking to help Fortranners avoid \"magic\" values in code",
            "text": "I submitted this paper 19-229 at the recent J3 meeting in Las Vegas (October 14 - 18, 2019) but it was ignored on account of being inconsistent with the decision(s) at the joint WG5/J3 meeting in Tokyo earlier in August.  I was motivated to submit 19-229 based on the needs, use cases, and requirements (as explained below) I foresee users will want in Fortran towards their applications in scientific and technical computing and which were either not tabled during the discussion at Tokyo  or they were addressed rather inadequately.\nTake the IEEE spectrum rankings for most popular languages now and review the facilities toward enumerations in any of the top ones e.g., Swift as described here.  Should Fortranners want to start expressing their coding constructs in Fortran as clearly and succinctly as possible using any of these other options available to engineers and scientists and where type-safety is to be valued and \"magic\" values are to be avoided (I'll provide more information toward this later on in the comments section), they will seek a comprehensive facility similar to what is offered by, say, Swift language.  However what is on the anvil for Fortran 202X is a poor shadow of this, so the situation is of great concern to me.\nFrom the paper:\nIntroduction\nThis paper, while trying to build upon the benefits and features of enumeration types known generally and also stated in the above referenced papers, attempts to document the use-cases and example code snippets derived from extensive use of enumeration types with other programming languages that are currently used indescribably more widely than Fortran in chemical processing and manufacturing industry even in engineering and scientific technical/numerical domains and applications.  \"No magic numbers in code\" and type-safe programming are among the most basic aspects of the good coding practices (GCP) sought after by managers and technical leads toward computing in such industry.  But even in these aspects, Fortran falls short relative to other top programming languages today and this gap compounds the reasons why Fortran does not get considered for any large and/or new application developments.  It is therefore critically important the facility toward enumeration types in Fortran be developed comprehensively to support a wide spectrum of beneficial use cases in scientific and technical programming.  The section below strives  to list all the cases from industrial experience and to extract feature requirements from these examples so that the formal specifications toward this facility can be pursued.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-27 05:03:42+00:00",
                    "text": "@FortranFan Thanks a lot for opening a discussion regarding this. I was on the Data subcommittee where your paper got discussed --- if I remember well, we went over your paper and tried to extract useful things that were not part of the other proposal in #11. The issue was that there was apparently already an effort from Tokyo, as documented in #11, and your effort was not coordinated with them. Had we used github already, we would know about these efforts and could coordinate better.\nBy looking at the use cases and motivation at #11, I am not convinced that they have done due diligence to explore how other languages do that, nor many examples how enumeration is actually used in codes.\nEither way, let's start over, and discuss the use cases, then try to formulate what features the community would like and then try to create a solid proposal for the next meeting.\nI see several issues that the committee was trying to figure out, and we need to have good arguments why yes, or why not:\n\n\nShould you be able to assign values to enumerators? If so, only integers, or other things such as strings, floats, etc., per examples in 19-229.\n\n\nShould you be allowed to set some enumerators as private?\n\n\nShould enumerators be class 1 names?\n\n\nShould next / prev functions be added? (Swift does not seem to have it, neither does C or C++, as far as I know)\n\n\nThere was also a lot of discussion about syntax, some of which happened at the J3 mailinglist\n\n\nAre there other questions that we do not have agreement on?\nI would start thoroughly discussing these and find an agreement on these questions first, or at least list pros and cons. I noticed suggestions at the J3 mailinglist for not doing any work on this until our next meeting, when somehow it will be time for action. I think we should do the opposite -- we should try to do as much work as we can remotely, so that when we meet the next time, we either have a solid proposal, or solid lists of pros and cons, and we can vote what we want to do."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-27 16:15:29+00:00",
                    "text": "I agree that the committee needs to do a more extensive review of how enumerators are used in other languages and even more thought on how they would be used in Fortran codes. Given Fortrans traditional focus on scientific and engineering programming, some of the use cases in other languages might not be appropriate. I currently use them extensively as a convienient way of defining parameters for SELECT CASE selectors since I find that easier than creating individual INTEGER, PARAMETER values for each one. Most of the time you care less about what the actual value is than is it different from other values. As a first step to defining a full enumerator cabability I would do the following.\n\n\nRemove the BIND(C) requirement since it makes no sense if you aren't doing C interop.\n\n\nIf its decided that more intrinsic data types should be supported just add the ability to set the KIND with the enum statement, ie ENUM(KIND=INT64) or ENUM(KIND=REAL32)\n\n\nAllow enumerators to be named (Cray did this in its pre F2003 compilers and might still allow it as an extension) ie\nENUM(KIND=REA64) :: PiValues\nEnumerator :: PI=3.1415---, TWOPI=2*PI\nEnd Enumerator\n\n\nAdd capability to change/set the default increment\nENUM(KIND=REAL32, INCREMENT=3.0_REAL32) :: threeValues\nEnumerator :: THREE=3.0_REAL32, SIX, NINE, TWELVE\nEND ENUM\n\n\nThis addresses what I consider the first and most important (for me at least) of use case for enumerators. Ie as a more convienient way of defining parameters without resorting to individual PARAMETER statements for each value"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-27 18:51:43+00:00",
                    "text": "@rweed wrote:\n\n.. Given Fortrans traditional focus on scientific and engineering programming, some of the use cases in other languages might not be appropriate. ..\n\nRe: other languages and what is appropriate or not, consider J3 Fortran paper 19-216r1 discussed at the Tokyo meeting which was the basis for crucial decision(s) by the WG5 body, decision(s) that might constrain and limit what will get introduced to Fortran 202X.  That paper mentions 4 other programming languages in its Introduction starting with C;  it also states, \"Pascal, Modula-2, Ada, ... have proper enumeration types, and enumerators of those types, because they are useful.\" and elsewhere in WG5/J3 documents it has been mentioned Fortran 202X shall have \"proper enumeration types\".\nNow, note in connection with Ada being mentioned in 19-216r1: one of the features under consideration toward enumeration types in Fortran is %NEXT ( or ..%NEXT()) ) and %PREV ( or ..%PREV() ) to loop over enumerators in a type instance.  This has similarities with facilities in Ada such as 'SUCC and 'PRED in Ada: see here. Few other languages support such as a facility with their enumeration types.\nI then ask:\n\n\nif certain languages such as C or Ada and their use cases are acceptable for consideration of feature design in Fortran, even for year 2022/2023 (!!), why not other languages?  Why not look wider say toward IEEE Spectrum and its current rankings toward the most widely used languages?  IEEE is, after all, among the largest organizations for engineers and applied scientists, if not THE biggest.  Also, if one is learning from other languages and their applications, why ignore recent and modern advancements?  C language is in \"maintenance mode\", Ada the same since 2012; do Pascal and Modula-2 need to be discussed?\n\n\nNow, also note Ada (dating even before the Ada-95 standard) supported the specification of values of enumerators and also character literals and boolean types in enumerations: see here and here.  Note my paper (19-229) does make use cases for character literals and logical types kinda like Ada in addition to integer and floating-point types which are supported, by the way, in Swift language.  However the disappointing situation is the Fortran proposal toward Fortran 202X will likely NOT support any of these aspects: if something does make it in, it'll likely be along the lines of following:\n\n\nenum :: CALC_SPEC\n   enumerator :: FUNC\n   enumerator :: FIRST_DERIV\n   enumerator :: SECOND_DERIV ! value = 4 (say) will not be allowed; Ada does\n   ..\nend enum\n\n\n\nSo if Ada is going to be used as a basis of one feature (e.g.,NEXT, PREV as explained above), then why not other aspects, particularly when these other aspects can be seen to be supported by other top lanaguages on the IEEE Spectrum and ALSO when I see there are modern applications in technical computing in industry that actually employ these enumeration type facilities to develop code that read so well and which are easier to maintain and improve over time as well?\n\n\nSo then, who really gets to decide use case X based on Ada is ok but use case Y from modern C++ or Java or C#, or use case X from Swift language are NOT acceptable?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-27 19:08:50+00:00",
                    "text": "@certik wrote:\n\n..\nI would start thoroughly discussing these and find an agreement on these questions first, or at least list pros and cons. I noticed suggestions at the J3 mailinglist for not doing any work on this until our next meeting, when somehow it will be time for action. I think we should do the opposite -- we should try to do as much work as we can remotely, so that when we meet the next time, we either have a solid proposal, or solid lists of pros and cons, and we can vote what we want to do.\n\nThank you @certik , your proposed path forward makes perfect sense.  Issue threads such as this and the comments therein can hopefully provide the background material for all interested Fortranners to provide better input and develop better proposals and make better decisions."
                },
                {
                    "user": "certik",
                    "date": "2019-10-27 19:26:56+00:00",
                    "text": "@FortranFan I agree with you that the justification based on Ada is not consistent with the idea to look at all modern highly used languages (I like your IEEE list) and see what they do and then choose what's best for Fortran. It seems that Ada is cherry-picked, and even that inconsistently, as you pointed out.\nNote that Ada seems to have succ and pred functions that work on other types such as integer (per \"'Succ and 'Pred work with any scalar type\" from here and per \"X'Succ(Y) is an Ada attribute where X is any discrete type and Y is a value of that type\" from here). As such it makes perfect sense to extend those to enumeration type also.\nIn case of Fortran, we do not have succ and prev and so it does not make sense to somehow for Enumeration to have those. The closest that Fortran has is nearest.\nSo given that, the \"natural\" position is not to have first, last, succ and pred. If we want to have those, I would like to hear very good arguments for that.\nIn a similar way, I would like to tackle all the other questions."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 14:45:42+00:00",
                    "text": "@certik and all interested in Enumerations in Fortran, please take a look at this PEP  for Python.\nWith paper 19-229 mentioned above, my hope was to provide the background and use cases that would help the Fortran committee develop a comprehensive facility that is consistent with the legacy, semantics, and syntax of Fortran, similar to what one notices the Python org did with their PEP 435 back in year 2013.\nIf one looks at Python PEP, one can effectively feel the care and concern and the motivation to really help the practitioners of Python do better with their code.\nAnd consider the basic aspect of enum type in Python with the ability of assign value to an enumeration member (aka enumerator per current papers on Fortran):\n>>> from enum import Enum\n>>> class Color(Enum):\n...     red = 1\n...     green = 2\n...     blue = 3\nThis is something you will notice with almost all the languages seeing any significant use in numerical computing, whether it be Ada (embedded and real-time systems e.g., avionics and aerospace applications), C++, C#, Java, etc.\nWhat is on the horizon for Fortran plans to deny this basic ability to assign any values in Fortran enumerations (they can only be auto-assigned starting with unity in the order of enumerators) which, right off the bat, invalidates so many use cases based on existing codebases toward engineering and technical computing I have seen.\nFor a language like Fortran which essentially disallows any named constants or variables to come into existence with an automatic value (without negative consequences), it appears entirely orthogonal to existing semantics what is being considered with the current plan for enumeration type.  This is highly bothersome to me."
                }
            ]
        },
        {
            "number": 45,
            "user": "pbrady",
            "date": "2019-10-25 22:43:58+00:00",
            "title": "indexable (indexible?) derived types ",
            "text": "",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "pbrady",
                    "date": "2019-12-23 18:04:14+00:00",
                    "text": "Closed in favor of #119"
                }
            ]
        },
        {
            "number": 44,
            "user": "pbrady",
            "date": "2019-10-25 22:42:29+00:00",
            "title": "callable derived types",
            "text": "",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "pbrady",
                    "date": "2019-12-23 18:03:51+00:00",
                    "text": "Closed in favor of #119"
                }
            ]
        },
        {
            "number": 43,
            "user": "certik",
            "date": "2019-10-25 01:31:13+00:00",
            "title": "Add Code of Conduct",
            "text": "@milancurcic, would you mind reviewing this please?",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-25 13:47:42+00:00",
                    "text": "@milancurcic thanks for the review."
                }
            ]
        },
        {
            "number": 42,
            "user": "rweed",
            "date": "2019-10-24 01:29:27+00:00",
            "title": "Add an examples directory",
            "text": "Would it be possible to add an examples directory we can upload complete code examples to. I find that looking at complete working code is more instructive than code fragments. This would be a way to contrast how we have to currently do things within the confines of the standard with proposed changes that could be embedded as comments etc. in the working code. I think that would give a better idea how the proposed modification would impact code size, readability, possible implementation issues etc. Of course everyone would be free to protect their code with the open source license of their choice.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-24 06:01:58+00:00",
                    "text": "@rweed, what I was thinking is to create a directory for each proposal, and in that directory there would be all the papers submitted for the committee, as well as examples as .f90 files. In few years, once we have compilers that can be used to have the feature implemented, those examples can be even compiled."
                }
            ]
        },
        {
            "number": 41,
            "user": "kaigaox",
            "date": "2019-10-23 18:54:45+00:00",
            "title": "Proposal for default value of optional function/subroutine arguments",
            "text": "Fortran cannot set default value in function/subroutine definition for optional arguments. This is an apparent inconvenience if there are multiple optional arguments, compared with C/C++. In such case, using if(present()) can become rather cumbersome. I'd hope that future fortran has such functionality.",
            "is_open": false,
            "labels": [
                "duplicate"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-23 18:57:02+00:00",
                    "text": "@nebulaekg thanks for reporting this. Isn't this a duplicate of #22?"
                },
                {
                    "user": "kaigaox",
                    "date": "2019-10-23 19:00:26+00:00",
                    "text": "@nebulaekg thanks for reporting this. Isn't this a duplicate of #22?\n\nHi Ondrej, Yes I missed it. Sorry about this. -Kai"
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 19:01:56+00:00",
                    "text": "@nebulaekg no worries! Go ahead and upvote #22 or comment there with improvements. I am going to close this one."
                }
            ]
        },
        {
            "number": 40,
            "user": "certik",
            "date": "2019-10-23 18:09:17+00:00",
            "title": "Deprecate and remove implicit save behavior",
            "text": "Currently, if you do:\ninteger :: x = 5\nFortran implicitly adds a save attribute:\ninteger, save :: x = 5\nThis is a common gotcha (https://www.fortran90.org/src/gotchas.html#variable-initialization-using-initialization-expression). I would like this behavior to get deprecated somehow, then removed, and instead use the syntax integer :: x = 5 to mean that the variable gets initialized to 5. Because this implicit save behavior is used extremely rarely in modern Fortran codes.\nOne approach would be that when you declare a module, you do something like:\nimplicit save(.false.)\n\nRight next to implicit none (we should find a better syntax), and then this behavior is disabled. There are other approaches.",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-23 18:46:51+00:00",
                    "text": "Bravo!\nSee a recent thread with lots of debate at comp.lang.fortran!\nNote Fortran 2018 standard introduced\n   implicit none (type, external)\n\nWG5 document N2161 by J. Reid states, \"The appearance of external requires that the names of external and dummy procedures with implicit interfaces in the scoping unit and any contained scoping units be explicitly declared to have the external attribute. The appearance of type requires the types of all data entities in the scoping unit and any contained scoping units to be explicitly declared\"\nThe standard could extend the above abomination with\n   implicit none (type, external, save)\n\nOr why not short-circuit all this once and for all with a new\n   EXPLICIT ALL\n\nOr better yet, make one BIG BRAVE LEAP forward by changing the default in all scopes to the equivalent of implicit none (type, external, save) so most coders do not have to worry about IMPLICIT semantics any longer!\nOff-topic: can anyone point to a link/reference to any current OPEN codebase in FORTRAN or modern Fortran that employs implicit typing and save (i.e., no 'implicit none' but the implied use of 'implicit integer(i-n), real(a-h,o-z)', etc.)  per code design i.e., not as an outstanding bug, or a legacy carry-over that is simply awaiting code refactoring."
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 18:55:20+00:00",
                    "text": "I think there should be a mechanism to fine grain these things (such as implicit none (type, external, save)). But then I would actually suggest that if you do not have any implicit none present, then by default it would be your explicit all. And have a compiler option that can do the old behavior, so that you can enable it for legacy code. This idea might be an uphill battle, and I might be convinced otherwise, as I do not want to break backwards compatibility. But let's at least consider it. It would be great if things \"just worked\" by default."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-23 18:57:14+00:00",
                    "text": "I absolutely agree! However, while deprecating integer :: x = 5 may be done at some point, I don't think it is reasonable to allow this syntax later again, but with a different meaning as it had before (simple initialization instead of implicit save).\n@FortranFan EXPLICIT ALL is a great idea! It would not break backwards compatibility, and with one simple line you could enforce good programming practice. Whether it ever becomes default, I doubt."
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 19:00:03+00:00",
                    "text": "@aradi are you against allowing integer :: x = 5 to mean initialization only if implicit none (save) is added? That would not break backwards compatibility."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-23 19:06:47+00:00",
                    "text": "If you introduce implicit none (save) or explicit all then that would be OK!  But, then, it would be not a \"deprecation\" of implicit save (which maybe the committee won't support anyway), but just adding a new feature to change the behaviour of integer :: x = 5 if explicitly asked for. (And we could hope, that compiler vendors will offer appropriate switches to enforce explicit all during compilation, even if it had not been specified.)"
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 19:10:06+00:00",
                    "text": "@aradi I see. I am fine almost either way, as long as the natural syntax integer :: x = 5 can eventually mean initialization, one way or another."
                },
                {
                    "user": "gronki",
                    "date": "2019-10-28 14:49:43+00:00",
                    "text": "Well, I think the \"no implicit save\" behavior should be the default. It was introduced 30 years ago, which is not long for the industry standards (most codes until 2000s were still written in F77), therefore I don't believe changing the default behavior and then compiler vendors providing switches to satisfy their government customers would hurt anyone. Some people argue that \"it's again Fortran spirit\" but that the dark side of Fortran spirit I'd rather have nothing to do with. Dominik"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-12 23:25:29+00:00",
                    "text": "I've seen implicit save cause so many problems over the years. I've literally never seen it used on purpose, only by mistake. It's just a weird and terrible feature and needs to go."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-13 17:13:31+00:00",
                    "text": "I will argue that the solution of using a switch to not break old code is inherently dangerous. Either the default behavior should be changed or a new syntax should be used. Here is my argumentation. (Note: this is a cross-post from another thread.)\nFirst, let me prefice that with what I consider the absolutely basic design feature I expect Fortran to have: prevent silent errors. So ugly syntax or not, what I personally get paid for is to get good numeric results.\nConsider the very root of such solutions, which probably is the familiar line\nimplicit none\nThe implicit typing feature was deemed to be unsafe and thus new, stricter rules for typing can be enabled with this switch. Please notice:\n\nif you omit the implicit none, the functionality of the code will not change\nif you use -fimplicit-none (or equivalent) switch, the functionality of the code will not change\n\nReading the code mid-file, you don't need to check the top of the file to see the implicit none. You just use the implicit typing and whether this mode is enabled or not, you will be good. Now if you start using implicit typing and implicit none was in effect, you will get a compiler error. All good.\nNow consider the proposed switch (let's stick to my favorite implicit save). For example:\nimplicit nosave\n\nIf you do that, the behavior of the code will change violently in a completely non-distinguishable way. Whenever you see:\ninteger :: i = 0\n\nyou have no idea whether i will be zero on each call or not. And worst of all, if you make a mistake, you will not be warned.\nNow when you work with different files, some of them written in 1980s, other in 2010s, you cannot just write right Fortran: you have to keep in mind which typing/saving/... rules are in place. Which is exactly the reason why implicit typing was deemed unsafe!\nAs much as I hate and despise this feature, I think we cannot provoke such situations. It must be clear looking at the code whether the variable is save or not. A couple of solutions have been proposed:\n\ninteger, nosave :: i = 0 -- IMO pain to type\ninteger, init :: i = 0 -- nicer to type on QWERTY keyboard\ninteger :: i := 0 -- or some other operator, such as =>. The good side is that there are no keywords that clutter the code.\n\nAny solution must be nice to type. This keyword/syntax will be used a lot. So I personally would prefer some operator-based syntax because having nosave every 3 lines would cause a lot of clutter, especially in editors with syntax highlighting. But the worst case init would be not that much pain."
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 17:42:30+00:00",
                    "text": "@gronki I agree with your overall sentiment here and many of your points. Here is the best proposal that I have so far. All of these will be allowed:\n\ninteger, init :: i = 0\ninteger, save :: i = 0\ninteger :: i = 0\n\nThe 1. will initialize the variable, the 2. will do the save attribute, and finally 3. will emit a compiler warning that you are using \"implicit save\" feature which is deprecated, and you should convert 3. to 2."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 19:50:21+00:00",
                    "text": "That's a reasonable proposal. However, one should keep in mind, that if combined with the possibility of variable declarations at arbitrary positions (#81), one would probably see a lot of\n! some code\ninteger, init :: i = 0\n! some more code\n\nkind of lines, which when occuring too often I find still more verbose then it should be. (But on the other hand, I agree, it is explicit and does not break backwards compatibility.)\nAn other question: What would those assigments do within a block statement?\nsubroutine test()\n  ! some code\n  block\n    integer, init :: i = 0\n    integer, save :: i = 0\n    integer :: i = 0\n  end block\nend subroutine test\n\nWould any of these be allowed, and if yes, with which behavior?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-13 20:08:16+00:00",
                    "text": "To be honest I've never used the block statement, so I don't know yet: is there any reason why any of that would not work, once #81 is implemented?\nA bigger issue that I can see is this: many times codes declare more than one variable on one line, such as:\ninteger :: i, j, k, l, a\nAnd if I want to initialize a, but not the rest, I have to now split it:\ninteger :: i, j, k, l\ninteger, init :: a = 5\nBut perhaps that's fine, similarly to specifying dimensions like:\ninteger :: i, j, k, l, a(:)\nversus:\ninteger :: i, j, k, l\ninteger, dimension(:) :: a\nUpdate: although at that point, it's shorter to use the current syntax:\ninteger :: i, j, k, l, a\na = 5\ninstead of:\ninteger :: i, j, k, l\ninteger, init :: a = 5\nEspecially after #81 is implemented."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-11-14 16:40:58+00:00",
                    "text": "All of these will be allowed:\n   integer, init :: i = 0\n   integer, save :: i = 0\n   integer :: i = 0\n\n\nI agree this is the way forward. I plan to write proposals (in this repo) for #22 and #81 to be considered for f202y during the Feb 2020 meeting -- I hope @certik will agree to contribute and advocate for them. I think it'd be important that this proposal (deprecate implicit save) gets going at the same time, as #81 and this proposal support each other design-wise. The init attribute syntax proposed here could also be used in support of #22 if applied to an optional dummy argument."
                },
                {
                    "user": "septcolor",
                    "date": "2019-11-14 17:12:04+00:00",
                    "text": "Golang has var := expr; which declares var to have the type of the value of expr, which is also assigned to it. The fact that an initializing declaration must necessary have an expr does make the explicit type somewhat redundant on the statement. So I suggest AUTO :: a = expr, b = expr, ... and AUTO, POINTER :: p => target, ....\n\nWhile I feel the init keyword appealing (also to distinguish from save), the above auto approach also seems nice in that it allows type inference and avoids the need to write a (possibly long) type name (which is redundant if a structure constructor is used on the RHS,  in a way similar to the Java case below). As for keyword,var :: a = expr might also be nice (because one character shorter).\nhttps://dzone.com/articles/finally-java-10-has-var-to-declare-local-variables"
                },
                {
                    "user": "septcolor",
                    "date": "2019-11-14 17:24:57+00:00",
                    "text": "A bigger issue that I can see is this: many times codes declare more than one variable on one line, such as:\ninteger :: i, j, k, l, a\n\nAnd if I want to initialize a, but not the rest, I have to now split it:\ninteger :: i, j, k, l\ninteger, init :: a = 5\n\n\nI think we can just write\ninteger, init :: i, j, k, l, a = 5\n\nbut is this problematic? (Here, i,j,k,l are given no initial values.)\nAnother approach might be to define the default initial value (e.g., 0 for integer) if not specified in a line with init. But I am not sure if it works for derived types."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 17:32:29+00:00",
                    "text": "I don't know what implications for compiler optimizations and performance would the default value requirement have."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-14 19:57:06+00:00",
                    "text": "Another approach might be to define the default initial value (e.g., 0 for integer) if not specified in a line with init. But I am not sure if it works for derived types.\n\nI think, default initialization if a value is not provided is not a good idea. In my experience it often makes finding obvious bugs (e.g. a variable has not set an explicit value before it is used) harder, as one always get consistent results (just the wrong ones).\nAlso, if the init attribute will be the favorite (I can not come up with anything better either), I would not allow for\ninteger, init :: a, b, c = 2\n\nThis line suggest the picture of creating initialized integers a, b and c (since attributes apply to all entities after ::), but only initializes c in reality. So, I think, it is didactically sub-optimal.\nOn the other hand, if it were the nosave attribute (which I like much less), then\ninteger, nosave :: a, b, c = 2\n\nwould be meaningful, as it tells you that neither a, nor b or c will be saved, which is indeed what happens. (And = 2 tells you, that c will always have the value 2).\nFurther question: Would pointer assignment be allowed for a well?"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 20:02:20+00:00",
                    "text": "Or, if we use a new operator, the statement gets self-consistent (but maybe less visible):\n! a is uninitialized, b is static, c is initialized\ninteger :: a, b = 3, c => 4"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-14 20:09:56+00:00",
                    "text": "Yes, but if we introduce a new operator for assignment on declaration, and later maybe also allow initialization of pointers on declaration, then one would have to invent yet an other operator. So, I'd then rather favor an attribute.\nMy only concern is exploding verbosity. Especially when #81 is also considered, you will have all around the code this additional init or nosave popping up. I still sympathize with the idea of @FortranFan to have explicit all instead of implicit none (none, external, save) at the beginning of the module scope, and then just write\ninteger :: i = 2\n\nand be surprised, that it exactly does what it should. \ud83d\ude04"
                },
                {
                    "user": "gronki",
                    "date": "2019-11-14 20:32:16+00:00",
                    "text": "Sorry, we can swap it for other similar op. It's about the concept. I took\nthis as an analogy with associate.\n\nczw., 14 lis 2019, 21:10 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n Or, if we use a new operator, the statement gets self-consistent (but\n maybe less visible):\n\n ! a is uninitialized, b is static, c is initialized\n integer :: a, b = 3, c => 4\n\n => should be reserved for POINTER, and it's dangerous to have such an\n important distinction depend on easy-to-mistype syntax anyway.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#40?email_source=notifications&email_token=AC4NA3ICLUXR2N6B6CJ7QM3QTWWEPA5CNFSM4JEGJAF2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEEDEGRI#issuecomment-554058565>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3JKYVR3JKS722NCR53QTWWEPANCNFSM4JEGJAFQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 22:23:40+00:00",
                    "text": "Thank you everybody, we are moving nicely with the various pros and cons. I like that you could write\ninteger, init :: a, b, c = 2\nto mean that a and b are not initialized, but I agree with @aradi that it's not consistent with the fact that init is applied to a and b. And I also agree that things should not initialize automatically to 0.\nI also agree that this will mean that init will start popping all over the place. And by looking at how people use this feature, you can apparently use integer :: a, b, c = 2 in the main program, in module variable and in derived types already, and it will not imply save.\nGiven all this, I am now leaning towards simply making integer :: a, b, c = 2 to imply init.\nIn order to get this in, I think we have to have two proposals. One is to introduce init, and I think that integer, init :: a, b, c = 2 should mean that a is not initialized, even if it's slightly inconsistent. This proposal does not break backwards compatibility.\nThe reason is that we will have a second proposal that changes the syntax integer :: c = 2 to mean implied init instead of implied save. After this second proposal is in, you can simply go into your code and remove init and things will still work. This proposal would break backwards compatibility, and so again it probably must be done in two stages. First it will introduce implicit none(save), which will not break compatibility. Then a second proposal will make implicit none(save) the default. The very last proposal might not pass --- but that will come in the category of simply making implicit none(all) the default, which is a separate discussion (perhaps it will just be a compiler option that would be recommended to always use)."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:39:59+00:00",
                    "text": "If we have IMPLICIT NONE(SAVE), however it's spelled, there's no need for an INIT or NOSAVE attribute on a type-declaration-stmt, right?\n\nThat's a good point. The only argument for keeping init anyway that I can think of is that it would allow you to use it even when the implied save is enabled.\nMy initial idea was to introduce this feature slowly, without needing implicit none(save) initially. But you are right, since the goal is to have implicit none(save) eventually, we might as well just do it directly, and not even introduce init."
                },
                {
                    "user": "certik",
                    "date": "2019-11-14 23:51:14+00:00",
                    "text": "Let's also learn from how C++ handles a similar situation. They would like to use the syntax a[1, 2, 3] for multidimensional indexing. Currently they can't do that because the comma operator already has a special (incompatible) meaning. So they first deprecated it in C++20: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1161r2.html, and then later, after a reasonable time, they will change its meaning, as described in the proposal. The comma operator is very rarely used, it was simply a mistake, similarly to implied save, to assign a very rare feature to a commonly used syntax."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-15 09:01:32+00:00",
                    "text": "@certik I think, we should be pragmatic. If the feature is introduced in two steps, people should need as few code line changes as possible to keep up with it. That would indeed suggest to drop the idea of init and keep with the following two steps:\n\n\nIntroducing a keyword making non-save behavior the default within a given scope, e.g. implicit none(save), and I would probably also suggest a proposal for allowing explicit all as a synonym for implicit none(type, save, external).\n\n\nAt a later stage require implicit none(save) (or even explicit all) as default behavior when nothing has been specified explicitly.\n\n\nPeople would only have to change one single line in every module to adapt. And in case the 2nd step never gets accepted (as it breaks backwards compatibility), it is still easier to convince people about using good programming practices,  if they have to change / add a single line to their code as opposed to add the init attribute all over."
                },
                {
                    "user": "tskeith",
                    "date": "2019-11-19 05:15:10+00:00",
                    "text": "Are there any compilers that warn about implicit save? It seems like that would be a good place to start to help beginners and detect code that depends on that behavior."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-12-30 05:10:43+00:00",
                    "text": "Just FYI: here is another code where implicit save is used by accident, and will produce incorrect results if called multiple times with certain inputs. Scroll down to DOW2DOY and consider the DAYS_PER_MONTH variable. As was mentioned (in some thread here), removing implicit save would probably fix more bugs than it would cause! \ud83d\ude04"
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 17:06:47+00:00",
                    "text": "I plan to write a proposal for this one. The best idea is expressed in #40 (comment), that is:\n\nIntroduce implicit none(save)\nIntroduce explicit all for implicit none(type, save, external) and any future addition to implicit none (what else is currently implicit in Fortran?)\nAt a later stage, require explicit all to be the default.\nThis is not unprecedented: C++ is also changing the rarely used comma syntax to mean something else, as described in #40 (comment).\n\nPros:\n\nOne can apparently use integer :: a, b, c = 2 in the main program, in module variable and in derived types already, and it will not imply save. So the above proposal makes the syntax integer :: a, b, c = 2 valid everywhere and to mean the same thing.\n\nThe alternative approaches discussed above and their Cons:\n\n\ninit or nosave keyword. Not needed in the end, so it adds unnecessary bloat to the language.\n\n\nNew operator. Adds bloat to the language.\n\n\n(@jacobwilliams that particular case should work even with save, because the subroutine does not modify DAYS_PER_MONTH, is that right?)"
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 18:10:21+00:00",
                    "text": "@klausler it seems the auto proposal is a little bit orthogonal. In other words, even if we have this auto keyword in the language, some people would still prefer to declare their variables explicitly. Let me explain.\nFor example, I use C++ often, and I do not like the auto keyword for simple types such as integer or float. I use auto for complicated iterators, as that simplifies the code a lot (e.g., in \"for auto\"). But otherwise whenever I can, I try to list the type explicitly, because it makes the code a lot more readable --- the reader can immediately see the types of everything. With auto everywhere, the code starts looking like Python. And Python, while I like it and have been using for 20 years (I can't believe it's so long!), I find it much less readable than C++ or Fortran, precisely for the lack of visible types.\nIn other words, I think the auto proposal has some Cons (i.e., the lack of visible type), that the above implicit none(save) proposal does not have. At the same time, in some use cases, the lack of visible type is a Pro. For this reason, I think the auto proposal is orthogonal to implicit none(save), and so I created a new issue #129 for it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 18:19:01+00:00",
                    "text": "auto would not preclude an explicit type (or shape).\n\nGood point. See my comment. I am starting to like the auto proposal."
                },
                {
                    "user": "gronki",
                    "date": "2020-01-07 19:57:44+00:00",
                    "text": "I also think this is a very bad solution due to the reasons I explained\nbefore (code quietly changes the behavior = unacceptable). But we might end\nup preparing more than one alternative proposal perhaps?\n\nwt., 7 sty 2020 o 19:19 Ond\u0159ej \u010cert\u00edk <notifications@github.com> napisa\u0142(a):\n\u2026\n auto would not preclude an explicit type (or shape).\n\n Good point. See my comment\n <#129 (comment)>\n .\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#40?email_source=notifications&email_token=AC4NA3JMIAC2HF5LVONSPVLQ4TBRNA5CNFSM4JEGJAF2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIJZDUY#issuecomment-571707859>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3I4GOEFWPTTNKNZ263Q4TBRNANCNFSM4JEGJAFQ>\n ."
                },
                {
                    "user": "gronki",
                    "date": "2020-01-07 19:58:52+00:00",
                    "text": "Or does it just disable implicit save and not change the behavior? Sorry\nfor posting before thinking twice :(\n\nwt., 7 sty 2020 o 20:57 Dominik Gronkiewicz <gronki@gmail.com> napisa\u0142(a):\n\u2026\n I also think this is a very bad solution due to the reasons I explained\n before (code quietly changes the behavior = unacceptable). But we might end\n up preparing more than one alternative proposal perhaps?\n\n wt., 7 sty 2020 o 19:19 Ond\u0159ej \u010cert\u00edk ***@***.***>\n napisa\u0142(a):\n\n> auto would not preclude an explicit type (or shape).\n>\n> Good point. See my comment\n> <#129 (comment)>\n> .\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#40?email_source=notifications&email_token=AC4NA3JMIAC2HF5LVONSPVLQ4TBRNA5CNFSM4JEGJAF2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEIJZDUY#issuecomment-571707859>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AC4NA3I4GOEFWPTTNKNZ263Q4TBRNANCNFSM4JEGJAFQ>\n> .\n>"
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 20:31:14+00:00",
                    "text": "Yes, definitely can have several proposals where each is as well thought as possible and where each can have some significant support of the community.\nThe candidates that I can see so far are:\n\ndo nothing\nimplicit none(save) (#40 (comment)) --- yes, the idea I had was that it would change the behavior\nthe auto keyword (#129)\nthe init or nosave keyword (#40 (comment))\nnew operator (#40 (comment))\n\nIs there some other alternative?\n@gronki which of these do you prefer?"
                },
                {
                    "user": "aradi",
                    "date": "2020-01-08 09:06:21+00:00",
                    "text": "As for me: I am definitely for option 2, allowing implicit none(save) and  explicit all to change the behavior of the assignment on declaration. I am happy to assist with the proposal, if any help is needed.\nBy the way, Is it possible to offer alternatives in a proposal (allowing the committee to pick the one which a majority can be found for)? We could then in the same proposal offer the alternative, that implicit none(save) and explicit all just forbid assignment on declaration, causing the compiler to throw an error message if such assignments are found. If I understood @gronki correctly, this is what he would favor. If the committee favors this \"small\" solution, it would be still better than leaving things as they are now. We could later either introduce a new keyword (like the proposed init) to allow assignment on declaration without side effects, or again try to convince the committee with stronger arguments that it is a good idea to allow assignment on declaration despite explicit all (with the changed meaning of having no implicit saving)."
                },
                {
                    "user": "certik",
                    "date": "2020-01-08 15:15:04+00:00",
                    "text": "Yes, a proposal can have alternatives. If assignment is not allowed, what would be the point of implicit none(save)? The compilers can add an option already today to warn if implicit save is used. At that point, I think the \"do nothing\" proposal would be better (or the init or auto proposals).\n@aradi, thanks for your offer to help --- I will get to writing this up very soon and I will tag you and others who are interested."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-15 16:17:17+00:00",
                    "text": "I very much prefer extending the syntax of the implicit none argument to allow for implicit none (*), as in #83 (comment), rather than introducing a new explicit all statement.  However, I am not sure implicit none (*) (or any other alternatives) are good or clear enough:\nAbout the introduction of explicit all:\n\nFortran has had an implicit none statement for 30 years.  This is a statement that most Fortran developers are familiar with, since using it became one of the (if not the) most basic and generally applicable good practice for writing post-77 Fortran code.  I think it would be fair to call implicit none a well known part of the standard.\nFrom a linguistic point of view, I think most people would agree that the meanings of \"implicit none\" and \"explicit all\" are exactly the same.\nThe proposed explicit all statement, according to this thread and to #83, would mean something different to implicit none.\nI think this is a bad idea: it would be confusing to most existing developers, who might (quite reasonably) assume that explicit all was a \"modern\", completely equivalent syntax to the implicit none they know so well.\nThe addition of such an explicit all statement to the standard would create yet another new \"gotcha\" in the language due to historical reasons.\nIts effects to newcomers may not be particularly positive: who would feel attracted to learn a language where, say, public none and private all mean different things, with a story dating back to decades before you were born?\n\nAbout the introduction of implicit none (*) or other alternatives\n\nThis implicit none(*) syntax seems more in line with the changes to the implicit none statement made in the 2018 standard, where its optional spec-list was introduced.\n\nHowever, I share the concerns expressed elsewhere about changes to its meaning in future standards:\n\nimplicit none(*) by itself would be perfect in a world where the list of possible implicit-none-spec's never changed.\nUnfortunately we don't live in that world: just a few years after the standard first introduced the two currently possible implicit-none-spec's (external and type) there is discussion about the need to add a third one (nosave).\nThe nosave spec is not a problem in itself, since the implicit none (*) syntax would probably be introduced at the same time as the nosave spec, or later.\nThe problem is what will happen if in the future another implicit-none-spec is added to the standard: if the committee follows the approach suggested by @certik in #40 (comment) , where an expression (explicit all in his comment) refers to \"any future addition\" to the arguments to implicit none, then the meaning of implicit none (*) will depend on the version of the standard.  [The alternative would be that  implicit none meant the same as implicit none (<list of its three oldest specs>) but something different to implicit none (<list of all possible specs>), which is quite difficult to imagine.]\nIf the new implicit-none-spec meant that code using implicit none(*) needed to be changed in order to be valid and compile, that would be an acceptable problem: users would always notice that something is wrong, and they would be able to take action: they would probably be able to select an older standard in the compiler, or they could modernise the code.\nIf the new implicit-none-spec silently changed the behaviour of valid code (as will be the case with the nosave option), then that would probably be the point at which the version of the standard would need to be specified in the source code (implicit none (*=Fortran203z) or whatever)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-15 18:52:28+00:00",
                    "text": "@jme52 , We're already in a place where the meanings of things aren't consistent. It seems strange to me that implicit none doesn't actually mean implicit none (list all the things). But you are correct, that this would be another gotcha when trying to make backwards compatible additions to the behavior of the implicit (or explicit) statements.\nThis is one of those areas where the goals of having a coherent language and a backwards compatible language come at odds with each other. I think the specification of the version/standard of the language shouldn't go in the source code though. it should be a compiler option, like it already is for many compilers."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:13:09+00:00",
                    "text": "I agree with all the concerns and like others I don't have a solution that is perfect. Let's figure out if we can agree on some subset, and that would be a good start.\nI listed the possible ways forward here:\n#40 (comment)\nand there might be some more and slight variations of them.\n@gronki you were opposing several of the suggestions, but you didn't say what you want to do instead. What is your preferred way forward? It could be the \"do nothing\" proposal. But if you could clarify what you want to do, it would help to move the conversation forward."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:47:05+00:00",
                    "text": "@klausler I was hoping IMPLICIT NONE(SAVE) would trigger INTEGER :: N=666 to lose it's save attribute. If that was not the case, and instead it would become an error, what would be the mechanism to allow INTEGER :: N=666 to mean (non-save) initialization? A compiler option, or some other syntax around implicit none?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-15 19:50:45+00:00",
                    "text": "I would say it is acceptable (if annoying to users) to make a change that causes code to fail to compile. It is not acceptable to change behavior."
                },
                {
                    "user": "qolin1",
                    "date": "2020-01-15 19:59:25+00:00",
                    "text": "I agree with @Klauser. IMO we don't want to make INTEGER :: N=666 loose its save attribute. Rather, presence of IMPLICIT NONE(SAVE) should make it illegal, and cause the compiler to issue a diagnostic and refuse to compile the code.\nIf the user really wants to save the value, he can put INTEGER, SAVE :: N=666. And if the user wants to initialize on the declaration, without having it SAVEd and without getting a compile error, he should be able to put INTEGER, AUTO :: N=666 (or whatever alternative keyword we think is the opposite to SAVE)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-15 20:08:04+00:00",
                    "text": "I think @qolin1 idea of a new keyword makes sense. I would suggest INIT."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-15 21:14:19+00:00",
                    "text": "I think that @qolin1's option makes most sense to me, let me spell it out / work it out a bit more (please replace \"init\" and implicit none(*) with your favourite expressions for those functionalities):\n\nIn the absence of implicit none(save):\n\nIf the variable is given a value in its declaration, and it doesn't have any save or init status: it behaves as if it was saved.\nIf the variable is given a value in its declaration, and it doesn't have a save or init status, it behaves accordingly.\n\n\nIn the presence of implicit none (save):\n\nThe compiler raises an error if a variable that is given a value in its declaration does not have a save or an init status.\nIf a variable that is given a value in its declaration has a save or an init status, it behaves accordingly.\n\n\nAn init statement and attribute analogous to the current save statement is introduced:\ninit [ [ :: ] inited-entity-list ]\nThe rules for combining init and save statements and/or attributes within a scoping unit are almost equivalent to those of accessibility statements and attributes (public and private):\n\nIf no saved-entity-list /  inited-entity-list is present, the save / init statement grants all variables in the scoping unit the respective init or save status.\nIf a saved-entity-list /  inited-entity-list is given, the save / init statement only applies to those entities.\nA scoping unit cannot have more than one save or init statement with omitted entity lists.\nIf the entity-list is present, those listed entities cannot appear in another save or init statement, or be given the save or init attribute in their declaration.\nIf the entity-list is not present, entities can be given the opposite save/init status through the corresponding statement or attribute in the declaration.  Note that at the moment public / private accessibility can be reinstated (public;integer,public::a is valid), but save cannot (save;integer,save::a is invalid), and rules for init should be the same as for save (I don't know why the standard does not allow repeated saves, so I don't know if this could be changed to unify behaviour with accessibility statements).\nNote that within the scoping unit of a save or init statement without an entity-list, the implicit none (save) statement has no effect.  While the possibility of writing the combination implicit none(save);save may sound not particularly clever, note that this would underpin the possibility of writing implicit none(*);save, which makes some sense.\n\n\n\nWhat do you think about this?  I am sure that many more details and subtleties are missing or need to be carefully considered (e.g.: derived types, pointers,...).\nBy the way, while writing this I noticed another default that may become questionable in the future: public accessibility...  Would it make sense to also create an implicit none(access) and also add it to the meaning of implicit none(*)?"
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-01-15 21:20:57+00:00",
                    "text": "Personally, I would much prefer to see some way to completely remove\nimplicit save and assignment have it's obvious meaning. While strictly\nspeaking it is safer to take the route people describe above, implicit save\nis such a terrible feature that I don't think anyone intentionally uses it.\nWe'd be better off excising it as best we can without the increased\nverbosity that an init attribute would introduce. The language is already\nverbose enough and that is the biggest threat to its continued survival. We\nshould not introduce additional verbosity.\n\u2026\nOn Wed, 15 Jan 2020, 21:14 Jos\u00e9 M\u00aa Escart\u00edn, ***@***.***> wrote:\n I think that @qolin1 <https://github.com/qolin1>'s option makes most\n sense to me, let me spell it out / work it out a bit more (please replace\n init and implicit none(*) with your favourite expressions for those\n functionalities):\n\n    1. In the absence of implicit none(save):\n       1. If the variable is given a value in its declaration, and it\n       doesn't have any save or init status: it behaves as if it was saved.\n       2. If the variable is given a value in its declaration, and it\n       doesn't have a save or init status, it behaves accordingly.\n    2. In the presence of implicit none (save):\n       1. The compiler raises an error if a variable that is given a value\n       in its declaration does not have a save or an init status.\n       2. If a variable that is given a value in its declaration has a save\n       or an init status, it behaves accordingly.\n    3. An init statement and attribute analogous to the current save\n    statement is introduced:\n    init [ [ :: ] *inited*-*entity*-*list* ]\n    The rules for combining init and save statements and/or attributes\n    within a scoping unit are equivalent to those of accessibility statements\n    and attributes (public and private):\n       1. If no *saved*-*entity*-*list* / *inited*-*entity*-*list* is\n       present, the save / init statement grants all variables in the\n       scoping unit the respective init or save status.\n       2. If a *saved*-*entity*-*list* / *inited*-*entity*-*list* is\n       given, the save / init statement only applies to those entities.\n       3. A scoping unit cannot have more than one save or init statement\n       with omitted entity lists.\n       4. If the *entity*-*list* is present, those listed entities cannot\n       appear in another save or init statement, or be given the save or\n       init attribute in their declaration.\n       5. If the *entity*-*list* is not present, entities can be given the\n       opposite save/init status through the corresponding statement or attribute\n       in the declaration. Note that at the moment public / private\n       accessibility can be reinstated (public;integer,public::a is\n       valid), but save cannot (save;integer,save::a is invalid), and\n       rules for initshould be the same as forsave(I don't know why the\n       standard does not allow repeatedsave`s, so I don't know if this\n       could be changed to unify behaviour with accessibility statements).\n       6. Note that within the scoping unit of a save or init statement\n       without an *entity*-*list*, the implicit none (save) statement has\n       no effect. While the possibility of writing the combination implicit\n       none(save);save may sound not particularly clever, note that this\n       would underpin the possibility of writing implicit none(*);save,\n       which makes some sense.\n\n What do you think about this? I am sure that many more details and\n subtleties are missing or need to be carefully considered (e.g.: derived\n types, pointers,...).\n\n By the way, while writing this I noticed another default that may become\n questionable in the future: public accessibility... Would it make sense to\n also create an implicit none(access) and add also add it to the meaning\n of implicit none(*)?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#40?email_source=notifications&email_token=AB6ESPP3HE2DPFZSOJYKBZTQ554C3A5CNFSM4JEGJAF2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJB2N4I#issuecomment-574858993>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPLLKUV6NQN6PGKQT5TQ554C3ANCNFSM4JEGJAFQ>\n ."
                },
                {
                    "user": "cmacmackin",
                    "date": "2020-01-15 21:29:23+00:00",
                    "text": "I could accept your proposed approach; it is certainly an improvement over\nwhat exists today. However, I think it is still unnecessarily verbose.\n\u2026\nOn Wed, 15 Jan 2020, 21:26 Peter Klausler, ***@***.***> wrote:\n If it were true that nobody has intentionally relied upon implicit SAVE\n semantics (and this is not actually the case), nobody would be any worse\n off from adding IMPLICIT NONE(SAVE) to their codes; and something like AUTO\n :: N=666 is *less* verbose than the INTEGER :: N; N=666 that they must be\n using today.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#40?email_source=notifications&email_token=AB6ESPK5VHY364ZRXERQH5TQ555Q3A5CNFSM4JEGJAF2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJB3R6Y#issuecomment-574863611>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPOHBNWKQZY5XZQ7LNTQ555Q3ANCNFSM4JEGJAFQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 21:29:28+00:00",
                    "text": "@klausler I agree, let's concentrate on your question first.\nHow about the following proposal:\n\ninteger :: i = 0 becomes an error in 202Y\ninteger :: i = 0 becomes an initialization in 202Z (or some later standard, but it will eventually be used as an initialization)."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 23:42:08+00:00",
                    "text": "But it should never become something other than what it is now.\n\nI see. Well, if we agreed to do that, then I think that can be achieved already with an optional new compiler flag that would warn not to use integer :: i = 0 and instead recommend to use integer, save :: i = 0.\nI am not against such a minimal proposal if we could agree to at least have a discussion in the future how to use the syntax for something else in the future (and yes, we might agree in the future to never use this syntax again).\nI would like to use the syntax integer :: i = 0 for \"something else\" (i.e., initialization without save) down the road and see if we can get a community agreement on that, and also how to technically achieve it, so that we do not break existing programs."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 03:38:38+00:00",
                    "text": "@klausler ok. I think your proposal is essentially equivalent to this proposal: #40 (comment). Let me phrase it with the latest details:\n\nAdd new syntax integer, init :: i = 0 (we can discuss changing init to auto, perhaps combining it with #129)\nThe following syntax stays the same: integer, save :: i = 0\nIf implicit none(save) is present (or an equivalent compiler option), then the syntax integer :: i = 0 is a compiler error\nIf implicit none(save) is not present (nor the equivalent compiler option), then the syntax integer :: i = 0 means integer, save :: i = 0.\n\n@klausler is this what you are proposing?"
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 12:42:17+00:00",
                    "text": "My \"vote\" goes for implicit none(save) changing the meaning of an assignment at declaration. I feel similar to  @cmacmackin, that the init attribute makes an already very verbose language even more verbose. What happened if variable declarations were enabled at arbitrary places as in #81 and maybe later even in loop-declarations. Would you really want to write (or even worse, try to teach newcommers to write)\ndo integer, init :: i = 1, 10\n...\nend do\n\nI'd also suggest not to mix the discussions about auto and about implicit save. It is absolutely not clear to me, that if auto gets introduced (would be cool!), whether it would be a placeholder for just the type of the variable or determine its attributes (dimension, target, etc.) as well. I find former one more likely, but then you would need init also with auto\nauto, init :: i = 10\n\nto avoid implicit saving. So, if init gets introduced, we would be probably forced to use it in many situations..."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 13:25:40+00:00",
                    "text": "@aradi: I think that implicit none(save) changing the meaning of assignment at declaration is a bad idea. implicit none has been used so far in order to force more strict and detailed declarations, not to change the meaning of existing statements.  What you are describing really is a new init statement, an opposite to the existing save statement.\n\nWhat happened if variable declarations were enabled at arbitrary places as in #81 and maybe later even in loop-declarations. Would you really want to write (or even worse, try to teach newcommers to write)\ndo integer, init :: i = 1, 10\n...\nend do\n\n\nIf that day ever arrives, I think it would not be difficult to include as part of the standard that any loop iterator that is declared as part of the do statement (which I assume means is only defined within the loop, and then goes out of some kind of scope) does not need an init/save status: even if it was saved, this no longer has any effect after it goes out of scope.  So this syntax would never be needed.\nFor the other cases, I think yes, it would be needed to write init or save, for clarity."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 14:05:51+00:00",
                    "text": "If that day ever arrives, I think it would not be difficult to include as part of the standard that any loop iterator that is declared as part of the do statement (which I assume means is only defined within the loop, and then goes out of some kind of scope) does not need an init/save status: even if it was saved, this no longer has any effect after it goes out of scope. So this syntax would never be needed.\n\n@jme52 Try to run the following snippet:\nmodule testmod\n  implicit none\ncontains\n  subroutine testsub()\n    integer :: i = -1\n    print *, \"outer:\", i\n    i = i + 1\n    block\n      integer :: i = 2\n      print *, \"inner1:\", i\n      i = i + 1\n    end block\n  end subroutine testsub \nend module testmod\n\nprogram testprog\n  use testmod\n  call testsub()\n  call testsub()\nend program testprog\n\nCurrently, Fortran is consistent on saving a variable if it was initialized at declaration, independent of where it appears. In the example above, both i variables are saved, even the one within the block construct!. That means, if we'll ever have variable declarations in loop headers (would be cool!), then also those variables would have to get saved implicitly in absence of the init attribute, if you want to keep consistency.\nI understand all your concerns about changing code behavior with implicit none(save). I agree, that this would be a bad thing. But in my opinion, not introducing \"normal\" (non-saved) initialization on declaration or requiring the init attribute for it does more harm to the language on the long term than the first option."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 14:58:10+00:00",
                    "text": "Just one additional question/example. Let's assume, implicit none(save) disables assignment on declaration, unless you specify either init or save, would then the following snippet be also invalid?\nmodule testmod\n  implicit none(save)\n\n  integer :: i = 2\n\nend module testmod\n\nCurrently, module variables are also implicitely saved, as the snippets below are equivalent (or I think at least) :\nmodule testmod\n  integer, save :: i = 2   ! Adding explicitely the save attribute\nend module testmod\n\nmodule testmod\n  integer :: i = 2   ! No explicit save attribute, variable still \"saved\"\nend module testmod"
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 14:59:55+00:00",
                    "text": "@aradi: thank you for the lesson about  blocks, I had managed to completely forget about that.  Although I think this should really be part of another thread, let me try a second way to justify why there wouldn't be any point in a save/init status for variables declared as part of a do statement: the do variable is an integer (R1124/C1120), and according to section 11.1.7.4 of the standard the first thing that happens to it when the execution of a do construct starts is that it (the variable) becomes defined with the value of the initial parameter (the integer expression after the =).  So even if some other generic rule established that the final value at the exit of the loop from the last time the loop was executed had to ve saved, that saved value would be overwritten before it could be used."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 15:13:33+00:00",
                    "text": "@jme52 Thanks. I see your point, I think, you are right, the hypothetical loop header variable declaration won't be an issue."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 16:02:18+00:00",
                    "text": "Let's assume, implicit none(save) disables assignment on declaration, unless you specify either init or save, would then the following snippet be also invalid?\nmodule testmod\n  implicit none(save)\n\n  integer :: i = 2\n\nend module testmod\n\n\nI think that yes, you would need to\nmodule testmod\n  implicit none(save)\n  save\n  integer :: i = 2\nend module testmod\n\nor\nmodule testmod\n  implicit none(save)\n  integer, save :: i = 2\nend module testmod\n\nI know, this takes us to another issue: do save and init statements without arguments in a program unit or subprogram also affect their contained subprograms?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 16:14:50+00:00",
                    "text": "@klausler thanks. So now we have a proposal that you would be ok with.\n@jme52 are you ok with the proposal at #40 (comment)?\n@gronki you also agree on that, correct?\n@aradi is the proposal at #40 (comment) acceptable as a starting point?\nAs to myself, I think I could be fine with that proposal as a starting point in our discussions, because it does allow to later change the syntax integer :: i = 2 to mean integer, init :: i = 2 without breaking any code --- and while currently we can't get an agreement on that, we are not closing the door to later get an agreement on that. And this minimal proposal does fix the biggest issue, that integer :: i = 2 currently does something that is totally unexpected and people keep making this mistake all the time. And that would get fixed."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 16:21:23+00:00",
                    "text": "@certik Yes, I agree, that's a reasonable starting point. \ud83d\udc4d"
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 16:47:37+00:00",
                    "text": "@jme52 are you ok with the proposal at #40 (comment)?\n\nYes - but note that your proposal does include the new init attribute."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 17:53:05+00:00",
                    "text": "@klausler looks like the answer to your question whether we can agree on this is that yes, I think we can agree this is a reasonable starting point.\nIf that's the case, we can now move on to the second part of this, which is, whether to use init or auto (and auto as in #129 or some other way) and all the details of that."
                },
                {
                    "user": "septcolor",
                    "date": "2020-01-16 17:53:27+00:00",
                    "text": "Just one additional question/example. Let's assume, implicit none(save) disables assignment on declaration, unless you specify either init or save, would then the following snippet be also invalid?\nmodule testmod\n  implicit none(save)\n\n  integer :: i = 2\n\nend module testmod\n\n\nBecause module variables are global variables, isn't it OK to assume that they are always saved? I guess it is also a common behavior in C-like languages (so I feel it more natural for implicit none(save) to have no effect on the current behavior of module variables).\n#include <stdio.h>\n\nint xg = 1;  // global\n\nvoid test() {\n    static int xs = 1;  // static or saved\n    int xl = 1;  // local\n    xg += 1;\n    xs += 1;\n    xl += 1;\n    printf(\"xg=%d xs=%d xl=%d\\n\", xg, xs, xl);\n}\n\nint main() {\n    test();  test();  test();\n}\n/* Result:\nxg=2 xs=2 xl=2\nxg=3 xs=3 xl=2\nxg=4 xs=4 xl=2\n*/"
                },
                {
                    "user": "aradi",
                    "date": "2020-01-16 19:29:49+00:00",
                    "text": "Allowing the automatic type setting in connection with init as in\ninit :: n2 = 2\n\nwould make init and save asymmetric, since  you can not make\nsave :: n2 = 2\n\neither."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 19:53:37+00:00",
                    "text": "@klausler thanks for the proposal. Now we are moving forward. How about this case:\ninteger, init :: n1 = 1, n2\nWould this be a compiler error and if not, would n2 be not initialized?"
                },
                {
                    "user": "klausler",
                    "date": "2020-01-16 19:57:09+00:00",
                    "text": "@klausler thanks for the proposal. Now we are moving forward. How about this case:\ninteger, init :: n1 = 1, n2\nWould this be a compiler error and if not, would n2 be not initialized?\n\nIt would be a user program error if n2 were not initialized somewhere in the specification-part.  It would not necessarily have to be done there."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 19:58:44+00:00",
                    "text": "How about this case:\ninteger :: n1, n2\ninit :: n1 = 1\nWould that be allowed and n2 will not be initialized?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 20:12:56+00:00",
                    "text": "Ok. So I think the proposal should also mention the motivation why we need the bare init and save statements. The motivation that I can see is that when I have some existing code with declarations:\ninteger :: a, b, c, d, e, f\nreal(dp) :: x, y, z\nreal(dp), allocatable :: h(:,:), t(:)\n...\nand decide that variable c should be initialized to 0, then I can do it just by adding init :: c = 0 right underneath the declaration of c:\ninteger :: a, b, c, d, e, f\ninit :: c = 0\nreal(dp) :: x, y, z\nreal(dp), allocatable :: h(:,:), t(:)\n...\nand do not need to modify the previous declaration by removing c from it. Then later, once I am done developing my subroutine, I can refactor the above code to (perhaps some auto formatting can do that):\ninteger :: a, b, d, e, f\ninteger, init :: c = 0\nreal(dp) :: x, y, z\nreal(dp), allocatable :: h(:,:), t(:)\n...\nA counter argument against adding init :: c = 0 is that one can do the same just by adding c = 0 code there as follows (which is shorter and can be done already):\ninteger :: a, b, c, d, e, f\nreal(dp) :: x, y, z\nreal(dp), allocatable :: h(:,:), t(:)\n...\nc = 0\nBut the downside is that the initialization is far from the declaration, while the init :: c = 0 allows the initialization to be right next to the declaration, which makes it much easier to later refactor into integer, init :: c = 0, as shown above."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 22:21:10+00:00",
                    "text": "@klausler, @certik: I think that what you are proposing about automatic typing and dimensioning is really something different to what this thread was about.  To me you are starting to get too close to just being able to declare n=3 without init, save or parameter.  Do you think this could be discussed separately?  It does not really need the other changes discussed in this thread - it could apply to existing save statements, e.g.."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 22:43:05+00:00",
                    "text": "I agree with the possibility of init statements and attributes analogous to the existing save statements and attributes - I already tried to outline how they could work in #40 (comment) .\nAbout whether init requires variables to be initialised, I am not sure what extent that can have, and if that's a good idea:\n\nsaved variables don't need to be given a value, so that would be an asymmetry vs. init.\nAssume the following snippet:\nsubroutine calculate_and_print()\ninit   ! I don't want to be caught with that save stuff,\n       ! so I make sure nothing is saved unless explicitly requested.\nlogical :: solution_found = .false.\ninteger, save :: number_of_executions = 0\ninteger :: n=0\nreal :: a, b, c(:)\nThat looks like reasonable programming to me.  Would that be an error following your logic because a, b, c(:) are not initialised?\nIf it is an error, it tremendously limits the power of an init statement that is not followed by an explicit list of names.\nIf it is not an error, because the standard says that an init statement without a list works different to an init statement with a list and/or to an init attribute in a declaration... well, it can make sense (integer, init :: n does look like a bug), but it may be starting to get too complex..."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 23:02:08+00:00",
                    "text": "I am not sure I like the bare init statement either. The proposal does seem to mix #129 with #40, I agree with @jme52 on this.\nA more minimal proposal for init that hopefully we can all agree upon as a starting point is to allow:\ninteger, init :: x = 5\n\nbut not\ninteger :: x\ninit :: x = 5\n\nnor:\ninit\ninteger :: x = 5\n\nBtw, the last example's syntax is pretty much the same as:\nimplicit none(save)\ninteger :: x = 5\n\nand I thought the main argument why we are even doing init is that we do not want to change the meaning of integer :: x = 5. So if we are going to allow bare init, then I vote to simply rename bare init to implicit none(save) and we arrive back at my original proposal."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 23:08:57+00:00",
                    "text": "@klausler said:\n\nVariables in modules and submodules have the SAVE attribute implicitly already. IMPLICIT NONE(SAVE) should not apply to them. (Maybe this should also be the case for main programs; I could make a case either way.)\n\nVariables in modules and submodules have the save attribute implicitly in the same way that other program units and subprograms, so that cannot be a reason to treat them differently.\nI think it would be more fair to say that it makes more sense (to us?) to have saved variables in modules by default than to have them saved in functions and subroutines, where we are more likely to want them inited.\nIf we want implicit none(save) to have similar inheritance rules as implicit none or implicit none(external) (which are actually defined in different parts of section 8.7: paragraph 3 and constraint C895, respectively), then an implicit none(save) at the beginning of a module would also affect contained subprograms.  However, having a module-wide implicit none(save) that does not have any effect in the module variables sounds very weird.\nIt would make more sense to enforce implicit none(save) everywhere, and keep the current limits of save (and init) to scoping units, so\nmodule m\n  implicit none(save)\n  save ! needed to avoid error in m\n  m = 0\ncontains\n  subroutine s\n    init ! needed because implicit none(save) is inherited from the host\n    integer :: n = 0\n    [...]\n  end subroutine\nend module"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 23:12:05+00:00",
                    "text": "As far as I can see, the only difference between \"bare init\" and implicit none(save) (if both are used in a subroutine) is that bare init requires all variables to be initialized, while implicit none(save) makes this optional. Is there any other difference? Both features have the issue that the syntax integer :: x = 5 which previously implied save would now imply init. Also both are opt-in."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 23:14:36+00:00",
                    "text": "init   ! I don't want to be caught with that save stuff,\n       ! so I make sure nothing is saved unless explicitly requested.\nAre you confusing a bare INIT with an IMPLICIT NONE(SAVE)? Your comment seems to mean that you want IMPLICIT NONE(SAVE), not a bare INIT.\n\nNo, I am not confusing it.  implicit none(save) forces everything to explicitly be either inited or saved, but does not prevent save by itself.  init is the command that prevents save."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 23:24:26+00:00",
                    "text": "Aren't the three of us saying the same thing? It seems to me we are."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-17 09:12:22+00:00",
                    "text": "I think, they are two distinct issues here:\n\n\nShould implicit none(save) effect only routine variables or also module and program variables.\n\n\nShould the init statement be allowed.\n\n\nAs for 1: I am for letting implicit none(save) only act on routine variables. Having to specify save for every module variable, just because you specified implicit none(save) globally  would be a pain. (And I would hate to specify implicit none(save) in each routine just to avoid its effect on module variables as well.) Additionally, it is not clear to me, what a non-initialized module variable would mean, if implicit none(save) is in effect, as in\nmodule testmod\n  implicit none(save)\n\n  integer :: somevar\n\nend module testmod\n\nWould this variable get lost if the module \"goes out of scope\"?\nAs for 2: I agree with @certik , allowing the init statement would mean, you can write\nmodule testmod\n  init\n\ncontains\n\n  subroutine test()\n     integer :: n = 3\n  end subroutine test\n\nend module testmod\n\nThen, we are back to the original proposal, that adding some module level keyword changes code behavior further down.  I'd go for using init only as an attribute in the first round."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-17 13:26:44+00:00",
                    "text": "@klausler\n\nSee 8.5.16, paragraph 4. Variables declared in modules, submodules, and main programs implicitly have the SAVE attribute, initialized or not.\n\nSorry, you are right - I don't know what I was thinking.  Let me rephrase:  At the moment,\n\n\"Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be confirmed by explicit specification.\" (section 8.4, paragraph 3).\n\"A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or submodule implicitly has the SAVE attribute, which may be confirmed by explicit specification.\" (section 8.5.16, paragraph 4).\n\nBoth are cases where the SAVE attribute is implicit.  If an implicit none(save) statement option is introduced, I think it will be confusing if it only affects variables that obtain their implicit SAVE via explicit initialisation."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-17 13:48:07+00:00",
                    "text": "I think we agree on implicit none(save), init and save within a subprogram - please do check:\nsubroutine foo()\n   implicit none(save)\n   integer :: n  ! No initialisation, so everything ok.\n   real, save :: a = 1. ! Requires explicit save. Would have been\n                        ! implicitly saved if implicit none(save) was missing.\n   logical :: c = .False.\n   init :: c, q  ! we need to provide the list because,\n                 ! if not, the uninitialised n would be an error\n                 ! Declarations may appear above or below the statement\n   integer :: q = 3\n   [...]\n\nfunction bar()\n   init\n   integer :: n = 2     ! If it wasn't initialised it would be an error.\n   real, save :: a      ! Overrides the function-wide init.\n                        ! save does not require initialisation.\n   [...]\n\nsubroutine baz()\n   integer :: n = 2     ! Initialisation implies implicit save.\n   real, init :: a = 1. ! Overrides the default implicit save.\n   [...]\n\n(modulus the existance of the bare init statement, but I think the real problems are others, see my next post)."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-17 14:02:21+00:00",
                    "text": "What we may not agree on yet is:\n\nEffect of implicit none(save) on variables (initialised or not) declared in a main program, module or submodule.  Do we want them to have the same rules subprograms will have, or different ones?\nInheritance of implicit none(save): currently other implicit nones affect contained subprograms or BLOCK constructs.  Do we want the same for this third implicit none spec or not?\nInheritance of save and init statements: currently a save statement only affects its scoping unit (see definition in 3.123: \"BLOCK construct, derived-type definition, interface body, program unit, or subprogram, excluding all nested scoping units in it\"), i.e., is not inherited.  Do we want to keep this, and extend this rule to the init statement?"
                },
                {
                    "user": "jme52",
                    "date": "2020-01-17 14:30:45+00:00",
                    "text": "My current views on them:\n-> 2) Yes, same inheritance rules for all spec's of implicit none, for simplicity of the rules and of the code.\n-> 3) Yes, save and init statements should only affect the current scoping unit, there is no need to inherit them - they should be tuned in every contained subprogram or block.\n-> 1) Yes, I want the same rules for program units and subprograms.  When using implicit none(save) in the program unit, we can recover the old program unit-wide implied save by adding a spec-less save there.  Since save is not inherited by contained subprograms, this won't affect them.\nExample:\nmodule mym\n   implicit none(save)\n   save ! only affects module variables\n   integer :: n ! saved even if not initialised\n   real, init :: x = 0. ! unlikely to be of much use, but possible\ncontains\n   subroutine sub()\n      integer :: l, m   ! not saved because they are out of the scope of the module save\n      integer, init :: p = 3\n      real, save :: x = 2. ! requires explicit save because of initialisation +\n                           ! inherited implicit none(save)\n[...]"
                },
                {
                    "user": "aradi",
                    "date": "2020-01-17 15:16:55+00:00",
                    "text": "@jme52 I agree on your view for 2).\nAs for 1): What meaning do you suggest then for a module variable in presence of implicit none(save) but in absence of an init attribute:\nmodule testmod\n  implicit none(save)\n  integer :: n\nend module testmod\n\nWould this behave like a global (saved) variable (as it is now)? Or would it when a module goes out of scope (whatever that means) loose its value? I think, from your argumentation latter would follow, but I definitely would prefer the former.\nAs on 3): I would argue against having an init keyword at all, I'd propose to have it only in the attribute form. If we allow for its keyword version, we again come back to the original problem: A line somewhere in the code changes the meaning of other lines somewhere else, as in:\nmodule testmod\n! Note: no `implicit none(save)`  had been specified\ncontains\n[...]\n  subroutine testsub()\n    integer :: a = 1   ! Is this saved or not? Not known!\n    [...]\n    init :: a                ! Now, it turns out, a will not be saved.\n\nI think, such a scenario would degrade code readability a lot! Furthermore it would be basically equivalent the original proposal to let implicit none(save) turn all assignments at a declaration into a non-saved assignment, but doing it more complicated (with two keywords instead of one). There was no consensus on that (although I still favor it...), this is why the init attribute was suggested as a compromise."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 15:18:15+00:00",
                    "text": "What does save mean for module level (or program level) global variables? The Fortran module never goes \"out of scope\". If we equate save for Fortran with static for C, then C allows to have global variables that are non-static. But in Fortran's semantic, that would make no sense. The standard talks about save in section 8.5.16, and the definition of save is that\n\nThe SAVE attribute specifies that a local variable of a program unit or subprogram retains its association status, allocation status, definition status, and value after execution of a RETURN or END statement unless it is a pointer and its target becomes undefined (19.5.2.5(6)). If it is a local variable of a subprogram it is shared by all instances (15.6.2.4) of the subprogram.\n\nIf this is the definition, then it makes no sense for module variables or the main program because there is no end or return.\nWhat exactly does this mean:\n\nA variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or submodule implicitly has the SAVE attribute,\n\nbecause they didn't define what save means in this case...\nUnless somebody can clarify that, I will continue assuming that module level and program variables do not have save attribute, because it makes no sense. So implicit none(save) (obviously) does not apply to them either."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 19:41:31+00:00",
                    "text": "What does it mean for a variable in a module to have a save attribute?  I know you can write code like this:\nmodule a\nimplicit none\ninteger, save :: x\ninteger :: y\nend module\nwhere x has explicit save and y has implied save attributes. But I do not understand what that (implied) save means in this case. I quoted the definition above, and that definition does not seem to apply for this case."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 20:17:17+00:00",
                    "text": "@klausler thanks a lot for the explanation. I didn't realize that the module variable could have been destroyed between subroutine calls if it didn't have the implied save attribute. You are right that it make sense that common blocks could override each other to save memory in the early days of computing. I think EQUIVALENCE was used for the same reason."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 21:07:57+00:00",
                    "text": "I didn't realize that the module variable could have been destroyed between subroutine calls if it didn't have the implied save attribute.\n\nThis is not true. All variables declared in a module (initialized or not) have the save attribute automatically and implicitly and I think that's what is meant by this:\n\nA variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or submodule implicitly has the SAVE attribute\n\nFor example, if you declare this in a module:\nmodule mymod\n  ...\n  integer :: a ! value of a is preserved between procedure calls and module uses\nend module mymod\nand use it from other modules, procedures, or a main program, it's value is preserved between uses. It's a true global.\nBut this is also why the implicit save rule doesn't matter for modules and programs:\nmodule mymod\n   ...\n   integer :: a ! value of a is preserved\n   integer :: b = 1 ! value of b is initialized and also preserved\nend module mymod\nThis is why the caveat of implicit save is irrelevant for modules and programs."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:30:19+00:00",
                    "text": "@milancurcic we are in agreement (you might have misunderstood my comment). @klausler was explaining the history behind this, that in a common block, if you didn't have the save attribute, the contents could get destroyed. And a module is successor of a common block, and from the beginning they made all variables implicitly saved, so that their contents cannot get destroyed. So the reason they have an implicit save is so that they do not behave like variables in a common block. That's what I meant by:\n\nI didn't realize that the module variable could have been destroyed between subroutine calls if it didn't have the implied save attribute."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 21:39:44+00:00",
                    "text": "Ah, okay, I missed that piece, great!"
                }
            ]
        },
        {
            "number": 39,
            "user": "jacobwilliams",
            "date": "2019-10-23 02:25:35+00:00",
            "title": "Default value for allocatable derived type component",
            "text": "Allow for the default state of allocatable variables to be allocated with a specified value:\ntype my_type\n  integer :: i = 1  ! this has \"always\" been possible\n  character(len=:),allocatable :: str = 'default'  ! this is not currently possible\nend type my_type\nI'd also like to be able to define parameters with allocatable components like so:\n  type(my_type),parameter :: t1 = my_type(1,'option 1')\n  type(my_type),parameter :: t2 = my_type(2,'option 2')\n  type(my_type),dimension(2),parameter :: list_of_ts = [t1,t2]",
            "is_open": true,
            "labels": [
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-23 07:34:19+00:00",
                    "text": "@jacobwilliams thanks for reporting it. This is related to #22 a bit. I thought that when you write integer :: i = 1, it is setting the save attribute automatically, which is rarely what you want."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-23 12:48:55+00:00",
                    "text": "I think, as long as it is an assignment in a derived type declaration, it does not have any direct implications for the save attribute of eventual instances of it. However, the spirit of this kind of assignment could be also carried over to proposal #22 by allowing default values for optional allocatable dummy arguments as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-23 16:59:46+00:00",
                    "text": "Implicit save behavior is relevant only in procedures.\nHowever, now I realize that in the context of default value for derived type components, which I've been happily using for years, the type constructor uses the same style as proposed in #22. For example:\ntype my_type\n  integer :: i = 1  \nend type my_type\n\ntype(my_type) :: t1 = my_type()  ! this works, t1 % i is 1\ntype(my_type) :: t2 = my_type(3) ! this works also, t2 % i is 3\nSo, the proposal #22 (sorry to hijack the thread :)) is consistent with the current syntax for default values of derived type components, except there we need an extra attribute (default) to work around the implicit save behavior.\nI like this proposal also. It could be merged with #22, or have two separate smaller proposals. We should make whatever is easier to digest by the committee."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-23 17:56:13+00:00",
                    "text": "Frankly, I think the implicit save behavior should be removed. It is a malicious anti-feature of the language. But, of course it will be be with us until the end of time (like implicit typing I suppose)."
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 18:09:42+00:00",
                    "text": "@jacobwilliams I created #40 for removing the implicit save behavior."
                }
            ]
        },
        {
            "number": 38,
            "user": "jacobwilliams",
            "date": "2019-10-23 02:20:46+00:00",
            "title": "More flexible SELECT TYPE",
            "text": "Something so we can avoid these annoying nested select type blocks.\nSo if you want to check if several variables are integers:\n! if several variables are integers\nselect type (a,b,c)  ! new syntax\nclass is (integer)\n  d = a + b + c\nend select\nOr if you want to check if a variable is any integer kind:\nselect type (a)\nclass is (integer(kind=*))  ! new syntax\n  d = a * 2\nend select\nOr any numeric kind:\nselect type (a)\nclass is (integer(kind=*), real(kind=*))  ! new syntax\n  d = 1 * 2\nend select\nAnd all together:\nselect type (a,b,c)  ! new syntax\nclass is (integer(kind=*), real(kind=*))   ! new syntax\n  ! a, b, and c are all either integers or reals, \n  ! so compiler knows what to do here:\n  d = a + b + c\nend select",
            "is_open": true,
            "labels": [
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "septcolor",
                    "date": "2019-10-23 17:11:36+00:00",
                    "text": "In the above codes, a, b, and c are supposed to be some dummy arguments of class(*)? (and so the purpose of the code is to determine their dynamic types in a subroutine, for example?) If that is the case, I'm wondering if the same thing may be achieved by generics with constraints (like \"where\" in some languages?)"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-23 17:47:44+00:00",
                    "text": "Yes, something like this:\ninteger function multiply_by_two(a) result(d)\n\nclass(*),intent(in) :: a   \n\nselect type (a)\nclass is (integer(kind=*))  ! new syntax \n  d = a * 2\nend select\n\nend function multiply_by_two\nOr, via some sort of a limited polymorphic dummy argument like so:\ninteger function multiply_by_two(a) result(d)\n\nclass(integer(kind=*)),intent(in) :: a    ! some new syntax like this  -- any integer kind\n\nd = a * 2\n\nend function multiply_by_two\nMaybe a sort of \"poor man's\" generics."
                },
                {
                    "user": "rweed",
                    "date": "2019-10-24 01:08:52+00:00",
                    "text": "I think this is a great idea. I went through the process a few years ago of creating a library of Abstract Data Types (lists, queues, RBtrees, hashmaps etc) using unlimited polymorphic containers etc. I went the extra mile and decided to support all the intrinsic types plus a user defined type. This started as a project to learn something about UP and kind of got out of hand. I can safely say that it doesn't take long before you really really hate SELECT TYPE and baseing ADTs on unlimited polymorphic values is NOT the best approach. We really do need templates or something similar for that. I even went so far as to emulate what Jacob is suggesting by creating my own enumerator parameters for each intrinsic type and my user type along with a function that takes an unlimited polymorphic value as an argument and returns one of my enumerator parameters as an INTEGER. I then use this value as a CASE selector in SELECT CASE just so I can do\nSELECT CASE(kind_type)\nCASE(INT64, INT32, INT16, INT8)\n    Do something with integers\nCASE(REAL64, REAL32)\n    Do something with reals\n\netc."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-24 17:20:12+00:00",
                    "text": "I have made analogous comments to the committee in a slightly different context (SELECT RANK).   There was a strong objection to having multiple cases in one statement.  E.g. RANK(1,3,5).   The reason given was that the compiler is generating rank-specific code within the clause.   Putting multiple type/kinds within the TYPE IS clause would be even worse, so I am doubtful that aspect could proceed.\nAs a developer, I find these arguments a bit frustrating.   It is of course quite obvious how to write a preprocessor that would repeat the clause for each item in the list.   But apparently this is much more difficult/subtle inside the compiler.\nHowever,  those objections would not affect the desire to put multiple variables in the SELECT TYPE statement.      There is a common pattern of nested SELECT TYPE's that have been complained about during meetings on multiple occasions.    I can't recall what sort of syntax was proposed if any, but I like what I see here."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-20 20:54:18+00:00",
                    "text": "The frequent need for nested \"select type\" statements is indeed an abomination in present Fortran. However, I am in favor of getting completely rid of such \"downcasting\" as it is called in other languages and to not ever have to use it at all.\nSelect type statements are just a nasty symptom, and not the actual disease. The disease is that Fortran presently does not support any form of multiple inheritance. If we had Java-like interface inheritance (or traits as they have been called in Issue #125) in addition to implementation inheritance (the one that present Fortran provides), there would be no need to use \"select type\". The same would hold if we had C++ like multiple inheritance.\nIt is the conflict between having to conform to some extended type's interface while at the same time wishing to inherit implementation from a base type that typically leads to the use of \"select type\" statements."
                },
                {
                    "user": "Beliavsky",
                    "date": "2022-02-28 14:00:48+00:00",
                    "text": "I also suggested this in a Fortran Discourse thread Allow TYPE IS to select multiple types, where there was both support and opposition. A few people said they often had identical code for several select type cases."
                },
                {
                    "user": "tclune",
                    "date": "2022-02-28 14:07:30+00:00",
                    "text": "The compiler developers were adamant that \"the way compilers work\" does not allow such seemingly simple code transformations as to replicate code for multiple cases in this manner.  (For both SELECT RANK and SELECT TYPE.   I don't recall the TYPE IS case being discussed, but possibly the same reason exists.  But it would seem to be even simpler as there is no dependent code to compile and execute in this case.\nI will say that the \"frequent need\" for SELECT TYPE does diminish considerably in many cases with careful design.   The primary ones that do not involve intrinsic types.      E.g., a common case that two objects must have the same type appears as a doubly nested mess of SELECT TYPE statements.   However the Visitor (also called Bridge) design pattern provides a way to implement double dispatch in a single dispatch language.    Whether the extra complexity is better than the tangle of SELECT TYPE depends on the use case and the eye of the developer.\nAnd of course, next generation Generics features in the language will also reduce the need for such nested SELECT TYPE's in the future.  But that's a ways off."
                }
            ]
        },
        {
            "number": 37,
            "user": "FortranFan",
            "date": "2019-10-22 19:26:27+00:00",
            "title": "Feature proposal: open to derive an inextensible derived type",
            "text": "I submitted this paper 19-186 for the joint WG5/J3 meeting in Tokyo (August 5 - 9, 2019) but the paper was ignored on account of the worklist for Fortran 202X being closed.  I don't know how to get it considered now for Fortran 202Y, perhaps various \"thumbs up\" by readers here might help push its case?\nIntroduction\n18-007r1 states in section 7.5.7.1 Extensible, extended, and abstract types, \"A derived type, other than the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, that 7 does not have the BIND attribute or the SEQUENCE attribute is an extensible type.\"  An extension type can thus be derived from any other user derived type which does not have the BIND or the SEQUENCE attributes.\nConsider a user derived type in Fortran that does not have the BIND or the SEQUENCE attributes and which is employed toward calculational needs involving data structures of some complexity in scientific and technical computing, particulary in industry: the allowance per current standard to extend said type is a matter of great concern in terms of security and predictability of computer operations and results, especially to senior software design architects, computational technology leaders, and budget and business managers.\nThe facility in current Fortran standard to be able to extend all derived types except as stated above makes it feasible, at least conceptually, to manipulate the data and states of objects of such types and to corrupt or otherwise misuse them via type extension, either intentionally or unknowingly.  It then becomes difficult, if not impossible, to develop technical software involving specialized derived types because it leaves open the possibility of violation of a technical/business understanding across or within teams not to override some type behavior or functionality via type inheritance.\nThis situation hinders the adoption of Fortran in new engineering and/or scientific software projects where the design paradigm of object-orientation is important but where the needs of the projects also include the requirement to encapsulate the business/technical logic using data structures which are 'sealed' so that objects of such structures can then be consumed across the  program or libraries without concern of easy alteration.\nIn addition to the above-stated use case of added security and reliability of a 'sealed' derived type, it is also expected that a few or all of the processor implementations will be able to provide some performance benefit with the use of bound procedures with such 'sealed' types.  This is on account of some or all processors succeeding in providing more efficient code via nonpolymorphic descriptors of the passed-object dummy argument utilized in procedure calls.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-22 21:28:25+00:00",
                    "text": "I don't feel strongly about this particular proposal. But I feel strongly about the fact that the committee essentially ignored your proposal on procedural grounds, instead of providing feedback. They did the same to me with the 19-246 proposal that I submitted as part of #1 at the last meeting. It effectively got ignored. All I wanted is some general feedback \"yes, submit a full proposal\" or \"no, not worth it\".\nAs a solution, I think we need the committee to consider all proposals not just for 202x, but for 202y also, all the time, so that we can push all proposals forward (or not if they get rejected), but what we do not want is to wait the next several years until to even consider 202y proposals. So I created #36 to address this exact issue."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-23 03:40:52+00:00",
                    "text": "I don't feel strongly about this particular proposal. ..\n\nTo hope to make readers care about this, please note\n\nC++ starting with C++11 allows classes to be made 'final',\nJava permits classes to be 'final' and many of the widely consumed classes are so,\nC# (and all Microsoft.NET languages) allows classes to be non-inheritable via 'sealed' and many of the most commonly used classes from Microsoft's own .NET Framework e.g., the ubiquitous StringBuilder class is 'sealed',\nPython too has recognized the need and has a PEP with a Status of accepted,\nFortran's own intrinsic derived types such as C_PTR (that has private components only) are inextensible\n\nSo why can't the Fortran standard extend the same courtesy to user derived types that it allows itself when it comes to intrinsic derived types?  It's a basic need in object-oriented (OO) inheritance scheme after all that so many OO languages offer such support.  Avoidance of \"deep inheritance hierarchies\" is increasingly a compelling design consideration and involves a strong business need when it comes to encapsulation, development, and utilization of knowledge frameworks in any domain.  Many now seek to design 'classes' and use them but without the travails of inheritance.\nIt'll really help those among my acquaintance develop code with better 'insurance' toward program vulnerabilities if such a low-cost facility were added to Fortran - the idea of an inextensible type already exists in the standard, the wiring is mostly there, and the feature mainly requires only EDITS.  In addition, such a facility can really free up compiler implementations to optimize instructions on data components of derived types operated via type-bound procedures (TBPs) by no longer having to be mindful of possible polymorphic nature of the passed dummy object.  One just has to look at some commercial implementations out there (clue: xxxxx inside) to see how guarded and conservative they are at the moment with TBPs when it comes to optimization.\nThere are other aspects as well which become cleaner with inextensible derived types e.g., finalization because Fortran, similar to C++, does not allow 'virtual destructirs' (the dummy argument is TYPE(..) with INTENT(INOUT)( that then doesn't provide any kind of a 'guard rail' when it comes to enforcing any finalizer discipline by extension types.\nA question is how much of a benefits case does one have to make for a reasonable group of 'modern' Fortranners to extend (pun intended!) support for this proposal!?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 07:31:35+00:00",
                    "text": "@FortranFan My apologies if my sentence sounded dismissive. When I said to not feel strongly, I meant that in my list of priorities, there are other issues that are higher priority that I want to concentrate on personally, such as #1, #36, #26, #4 and the general success of this repository and figuring out a way for the committee to consider our proposals. But that's why we have a community, and hopefully other people have different priorities and so we can improve Fortran as a language together.\nRegarding your proposal, thanks for posting the links to other languages. I think that significantly strengthened your argument. Python seems to have it proposed. C++ has it (https://en.cppreference.com/w/cpp/language/final). So I think your proposal should be improved with these links. Also, what alternative syntax keywords can be used? I don't know if sealed is the best. What are some other options?"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-23 07:39:18+00:00",
                    "text": "A keyword in line with Fortran's general verbosity would be `nonextensible`.\n\u2026\nOn Wed, 23 Oct 2019, 08:31 Ond\u0159ej \u010cert\u00edk, ***@***.***> wrote:\n @FortranFan <https://github.com/FortranFan> My apologies if my sentence\n sounded dismissive. When I said to not feel strongly, I meant that in my\n list of priorities, there are other issues that are higher priority that I\n want to concentrate on personally, such as #1\n <#1>, #36\n <#36>, #26\n <#26>, #4\n <#4> and the\n general success of this repository and figuring out a way for the committee\n to consider our proposals. But that's why we have a community, and\n hopefully other people have different priorities and so we can improve\n Fortran as a language together.\n\n Regarding your proposal, thanks for posting the links to other languages.\n I think that significantly strengthened your argument. Python seems to have\n it proposed. C++ has it (https://en.cppreference.com/w/cpp/language/final).\n So I think your proposal should be improved with these links. Also, what\n alternative syntax keywords can be used? I don't know if sealed is the\n best. What are some other options?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#37?email_source=notifications&email_token=AB6ESPMKEDMOGDUQ5QKCYRDQP74VTA5CNFSM4JDUHGY2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECAMMDY#issuecomment-545310223>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPMS4RJ5CYKDS3G2SGDQP74VTANCNFSM4JDUHGYQ>\n ."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-23 18:28:39+00:00",
                    "text": "A keyword in line with Fortran's general verbosity would be nonextensible.\n\nThe proposal does try to leave the keyword up to the committee!\nNow, with favor to English dictionary, INEXTENSIBLE  makes more sense to me.\nOr per the ugliness of many of the terms in the Fortran standard, NON_OVERRIDABLE can be reapplied here!!?  c.f. ISO IEC standard for C++ standard with 'final' for both classes (derived types in Fortran parlance) as well as functions (TBPs in Fortran).\nOr to add to confusion with further terminology in the language but in a consistent manner in terms of hyphenation, NON_EXTENSIBLE??!"
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 18:43:42+00:00",
                    "text": "@cmacmackin, @FortranFan let's discuss the options here, that's what github is for.\nCan final be used?"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-23 18:58:26+00:00",
                    "text": "That keyword already has a meaning in Fortran (destructor). I feel like\nit would be confusing if it were given two meanings.\nOn 23/10/2019 19:43, Ond\u0159ej \u010cert\u00edk wrote:\n\n @cmacmackin <https://github.com/cmacmackin>, @FortranFan\n <https://github.com/FortranFan> let's discuss the options here, that's\n what github is for.\n\n Can |final| be used?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#37?email_source=notifications&email_token=AB6ESPOA6H3EYCZ3CMLCNV3QQCLOBA5CNFSM4JDUHGY2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECCO25Y#issuecomment-545582455>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPITW2CDOP2JL4IPBWTQQCLOBANCNFSM4JDUHGYQ>.\n\n-- \nChris MacMackin\ncmacmackin.github.io <http://cmacmackin.github.io>"
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 19:01:08+00:00",
                    "text": "That keyword already has a meaning in Fortran (destructor). I feel like it would be confusing if it were given two meanings.\n\nI see, I forgot about that. (It gave away that I actually never use destructors...)"
                }
            ]
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2019-10-22 18:13:30+00:00",
            "title": "Consider releasing Fortran standard every 3 years instead of 5",
            "text": "Currently there is some pushback from the community that if some feature does not get into 202x (current plans around 2023 and the feature list is already fixed), the next opportunity is 202y (2028), which is almost 10 years from now, and then another few years for the compilers to catch up, and so in practice this is too slow to be usable before many people retire.\nAnother related issue is that the committee currently does not seem to consider 202y features too much, it is concentrating on 2020x features. That means that discussing and working on new features, such as those proposed in this repository, is very slow.\nA more efficient way would be to release a standard every 3 years on a set schedule. What gets in gets in, what is not ready will go to the next standard. Furthermore, the committee should consider all good proposals at all times, and push them forward, because good proposals take years of refining, and it's not enough to just start in a very short window (1 year) between Fortran standards, and then stop working on new features until another short window in 5 years.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-22 19:14:49+00:00",
                    "text": ":-)))\nThis will require being open-minded and taking inspiration from that \"other\" ISO standard!! \"Draft FAQ: Why does the C++ standard ship every three years?\""
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-23 17:26:21+00:00",
                    "text": "I am strongly in favor! Shorter feedback cycles -> more frequent minor updates. This may even percolate to faster implementation in compilers. I like it. Of course, this will come down to whether the committee can agree to do this, and how can we help to make it happen.\n@FortranFan and others have raised (many times in the past) the issue of the how many years it takes for proposals to reach the committee, be considered, accepted, published, and then for the features to be actually implemented by vendors who may or may not prioritize features based on customer requests. I strongly agree and wonder what can we do about it. On one side, it seems to be the reality of things:\n\nCommittees are slow\nBusinesses follow money\nCompiler developers are scarce\n\nOn the other side, this is the Fortran development model we've grown up with and know, but there may be another path forward (complementary to the existing, not replacing it!).\nI'm rambling now and going a bit off topic, but how feasible do you all think it is to plan for the long term to have a open source reference implementation of Fortran? This would include something like:\n\nAn open source compiler + interpreter (remember that compiled/interpreted is not a property of the language but of the implementation!) that mirrors the development of the language;\nAllow implementing and testing experimental features and proposals, which would make it easier to evaluate in practice (both ease of use and performance), and to argue for to the committee;\nHave a \"master\" branch of the language that evolves fast and in short cycles; The committee reviews proposals as usual, and releases \"tags\" or 3/5/whatever - yearly standard releases of the language.\n\nI think Rust follows a similar model. The language is open source and has a reference implementation. If you check out the master, you get whatever is latest. There are also versioned stable releases (1.38.0 current). And then there are editions -- Rust 2015, Rust 2018 (analogous to Fortran standard releases). Developers who need the rock solid stuff use editions; those who want to experiment or want the bleeding edge use nightly or latest versioned build. I think it's an elegant model.\nThis warrants a separate issue (again, sorry for hijacking), and I'd be happy to write one soon, but for now just probing the temperature of people here."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-23 18:46:16+00:00",
                    "text": "I absolutely agree on the 3 years term, as it could/should speed up the language feature implementation process in compilers. It would also kind of send the message: \"yes the language is still alive...\"\nAs for the reference implementation: We have already GFortran based on GCC suite and flang/f18 based on LLVM. Both open source. As for the licensing policy, f18/llvm would be a better option for a community driven reference implementation, since compiler vendors could incorporate the reference implementation directly into their code, provided their compiler is also based on llvm. (Actually, the flang/f18 is provided by NVIDIA/PGI and I heard some rumours that Intel may also come up with an llvm-compiler backend at some point).\nHowever, I think the main bottleneck is lack of human resources..."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-23 19:06:22+00:00",
                    "text": "I agree, building from an existing implementation like f18 or maybe even LFortran rather than starting from zero."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-23 19:11:55+00:00",
                    "text": "Oh, I was not aware of LFortran, but indeed looking at it, that may be also an option."
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 19:12:53+00:00",
                    "text": "Our goal should be to have two independent compiler implementations of every proposed feature into Fortran. If those compilers can be open source, even better.\n(Yes, I absolutely want LFortran to be able to eventually compile any Fortran code, and to allow implement new features on a branch.)"
                },
                {
                    "user": "tclune",
                    "date": "2019-10-23 19:18:57+00:00",
                    "text": "While the current F202x plan is not exactly 3 years, the concept was to make it a shorter cycle for the various reasons that have been identified in this thread.      I defer to those with more experience, but it is possible that we will have x=2 rather than x=3.\nThere are consequences to this though.    In particular the feature list is smaller per revision, and disproportionately so as there is some constant overhead of committee review for each revision.    One noticeable consequence: even though generic programming is the top priority in our approved features, it is not part of F202x."
                },
                {
                    "user": "certik",
                    "date": "2020-04-16 19:26:36+00:00",
                    "text": "@tskeith, thank you for being involved here. I would be interested in learning what in the proposal you disagree with and why. I'll be happy to discuss."
                },
                {
                    "user": "tskeith",
                    "date": "2020-04-16 19:40:48+00:00",
                    "text": "I disagree that releasing a standard every 3 years is more efficient than every 5 years. Given the overhead associated with the release, it's probably less efficient.\nIf you can figure out a way to get the committee to work faster or more efficiently then it might make sense. But that should come first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-16 19:54:55+00:00",
                    "text": "The standard is released every 5 years or less often because of how the committee works.\nOf course that a more frequent release model would require the committee to work more efficiently. I think that is implied here, and in part addressed by this repository.\nFor comparison, consider the Rust development model where specific and narrow RFCs are continuously implemented and the language is updated in short iterations, several times per year."
                },
                {
                    "user": "certik",
                    "date": "2020-04-16 19:58:57+00:00",
                    "text": "@tskeith thanks for the feedback. Yes, just releasing every 3 years while keeping the committee workflow the same would not work. I 100% agree. That is not what I am proposing.\nThe big part of the above proposal is to switch to a set release schedule, so we ship a new standard on a given date, what goes in goes in, what doesn't gets to the next standard. There are other approaches, as @milancurcic mentioned. I agree with you that the hardest part is to switch how the committee operates and that it must come first. And then lowering 5 years to 3 years will be much easier."
                },
                {
                    "user": "tclune",
                    "date": "2020-04-16 20:28:03+00:00",
                    "text": "The optimum pace for rolling out new standards is difficult to assess.  As indicated in this thread, there is some minimum overhead to get new features \"right\" and review the entire standard for consistency for those new features.    That sets a lower bound  of about 3 years.\nBut having a slower process (with more features) can delay when any given feature is commonly available across implementations.  Each vendor makes its own choice for the order of feature implementation.\nAnd yes, the sweet spot for frequency of releases would likely be significantly different if there were reference implementations prior to standardization."
                },
                {
                    "user": "tclune",
                    "date": "2020-04-16 20:31:47+00:00",
                    "text": "With regard to pinning the date and letting incomplete features slip  into the next standard:  while this works well in some software projects, it is less simple in the case of a standard.   Features are often not isolated and lots of little bits of the document must be edited and reviewed.   Pulling those edits back out when a problem is discovered late in the day is generally worse than delaying the release and fixing the problem.   But when the problem is severe or the edits are more isolated, features have been dropped rather than slowing a release."
                },
                {
                    "user": "certik",
                    "date": "2020-04-16 20:55:51+00:00",
                    "text": "Part of the solution in my opinion is to also \"crowdsource\" the editing of the Standard itself, i.e. have the Standard latex sources as a GitHub repository (perhaps a private) and allow multiple people to collaborate on it, just like any other software project. That might be a lot more efficient than our current process of \"writing the patch by hand\" in a proposal, and then have a single person do the edits.\n(Btw, no incomplete feature should ever slip into the standard.)"
                },
                {
                    "user": "tclune",
                    "date": "2020-04-17 13:07:04+00:00",
                    "text": "Quite possibly, though \"efficient\" is probably not the right word.   It would undoubtedly be much less efficient in terms of person hours but would be distributed across many more individuals."
                },
                {
                    "user": "sblionel",
                    "date": "2020-04-18 21:08:06+00:00",
                    "text": "The standard publishing process itself adds about a year to the timeline."
                }
            ]
        },
        {
            "number": 35,
            "user": "zjibben",
            "date": "2019-10-22 15:29:54+00:00",
            "title": "Better C interoperability for strings",
            "text": "It would be nice to have a more convenient way of converting Fortran-style character(len=X) :: a (where X > 1) to a null-terminated array which can be easily passed to a C function character(len=1) :: a(X+1).\nThis is target US09 for Fortran 202x.\n\n19-197r3 (Passed)\n18-258r2 (Passed)\n18-147 (Passed)",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023"
            ],
            "comments": []
        },
        {
            "number": 34,
            "user": "zjibben",
            "date": "2019-10-22 15:11:38+00:00",
            "title": "Clarification on behavior of contiguous dummy arguments",
            "text": "This relays a question posed by the LANL community: Is the behavior of contiguous dummy arguments specified by the standard, or implementation dependent? If one passes a discontiguous slice, you get copy in/out, and a reference otherwise? Or does this potentially doom a program to always copy in/out, even for contiguous slices?",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "klausler",
                    "date": "2019-11-05 23:01:49+00:00",
                    "text": "The rules in 15.5.2.3 are written so that in cases where a compiler (ahem, processor) might use a temporary to make an actual argument contiguous, the programmer is given weak guarantees about the validity of pointers after the call that were associated during the call with the dummy argument.  Various Fortran compilers differ in their behavior when the actual argument turns out at runtime to actually be contiguous; some will notice that a temporary is not required for contiguity and pass a reference instead (if a temp isn't needed anyway for other circumstances; it's messy)."
                }
            ]
        },
        {
            "number": 33,
            "user": "milancurcic",
            "date": "2019-10-22 15:04:46+00:00",
            "title": "Proposal template",
            "text": "I think it'd be useful to include in this repo a proposal template with a recommended structure.\nThis can be a simple markdown file with a few headings like Problem, Proposed solution, Syntax, Use cases etc. Kind of like GitHub issue templates in some open source projects.\nThe idea is to make it easier to bootstrap a proposal from scratch, streamline the process, and have proposals in a structure that is easiest to parse by the committee.\nIt'd be also helpful to include one or few high quality proposals that were approved by the committee in the recent past, to serve as examples.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-22 16:24:31+00:00",
                    "text": "Yes! Let's get it started, and then we should ask more experienced members of the committee like  @tclune and @gklimowicz to help."
                }
            ]
        },
        {
            "number": 32,
            "user": "arjenmarkus",
            "date": "2019-10-22 13:49:13+00:00",
            "title": "Just some experiments - they may or may not be useful",
            "text": "A couple of months ago I wrote two notes regarding programming features that might be useful in specific cases, with matching code examples. They were intended just as experiments, but since this project is gathering ideas for further development of Fortran, I thought they might fit in here.\nThey can ben found at my Flibs project, but here are copies of the notes:\nThe prototype pattern as an alternative to class-based object-oriented programming -\nprototypes_pattern.pdf\nLambda expresssions (anonymous functions) -\nlambda_expressions.pdf\nLike I said: At this moment they are no more than experiments.",
            "is_open": true,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-22 16:32:58+00:00",
                    "text": "@arjenmarkus thank you for sharing it. These are precisely the kind of discussions and experiments that we need to be doing as a community to move the generic programming forward. I think this will be useful for @tclune's efforts."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-23 06:38:55+00:00",
                    "text": "Thanks. That was certainly one reason to create the issue.\nIt is fun to work on such experiments - of course, an actual application is not always easy to fit into existing programs. It is also revealing that such things are possible, though perhaps clumsy or laborious, with the current Fortran standard. I feel that with a bit of work, most of clumsiness or labour can be done away with."
                }
            ]
        },
        {
            "number": 31,
            "user": "aradi",
            "date": "2019-10-21 18:46:01+00:00",
            "title": "Add proposal for protected attribute in derived types",
            "text": "",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-21 18:59:27+00:00",
                    "text": "@aradi, thanks for submitting this. I have a few questions. Wouldn't your example work with current Fortran already? I would like to see an example which does not work with current Fortran, and shows how the \"protected\" attribute improves things."
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 19:21:51+00:00",
                    "text": "Ah I see --- it's something like const in C++? It makes the attribute constant / read only. I thought this was about making the member \"private\"."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 19:22:16+00:00",
                    "text": "I added some more explanation. The case presented would be only possible, if the component were made public, but that would jeopardize data consistency."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 19:23:35+00:00",
                    "text": "Yes, it was meant like const in C++ (and not as protected in C++ \ud83d\ude09 )"
                },
                {
                    "user": "zbeekman",
                    "date": "2019-11-08 20:49:17+00:00",
                    "text": "I've wanted this for a long time. Writing a ton of getter methods is a pain in the ass and a waste of time. An attribute that would only allow modification by TBPs would be really nice, and would allow for direct reading of UDT components."
                },
                {
                    "user": "certik",
                    "date": "2019-11-08 21:02:50+00:00",
                    "text": "@aradi I did not forget about this PR --- I first want to figure out a workflow with the committee how to consider proposals such as this one. Things will start moving in the next few weeks."
                },
                {
                    "user": "aradi",
                    "date": "2019-11-11 08:09:29+00:00",
                    "text": "All fine, thanks in advance and especially thanks for all your efforts into involving the community!"
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 05:06:49+00:00",
                    "text": "@aradi, can you comment on #122 and (hopefully) list it among your top 5? We'll now start drafting proposals, so we'll figure out some good template and help you finish it, and you can help us with other proposals also."
                },
                {
                    "user": "aradi",
                    "date": "2020-02-21 06:02:03+00:00",
                    "text": "@zjibben Thanks! I think, the proposal is trivial enough not to have side effects or unwanted implications, this is why there was not much discussion about it."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-02-21 08:38:55+00:00",
                    "text": "Thanks for this proposal. It is something I tried intuitively once (without success of course ;) ), before reading one more time the documentation of protected."
                },
                {
                    "user": "certik",
                    "date": "2020-02-21 18:48:05+00:00",
                    "text": "I assigned to @zjibben to merge when he thinks it's ready."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-21 19:22:20+00:00",
                    "text": "I went ahead and merged. I agree, I think this is straightforward enough to not need more clarification, but if anyone thinks of something please leave a comment or submit a PR! I\u2019ll submit this weekend otherwise. Thanks for the proposal @aradi !"
                }
            ]
        },
        {
            "number": 30,
            "user": "cmacmackin",
            "date": "2019-10-21 08:38:14+00:00",
            "title": "Getter and setter procedures for derived types",
            "text": "Some languages such as Python and C# allow the definition of special getter and setter methods. Although these are methods, syntactically they allow the client code to behave as though the represent a public component of the class. This has the following advantages:\n\nmore compact syntax\nability to refactor which type components are public without breaking API\n\nThe latter, in particular, is important. It means that a type component can be left public (or protected, if #16 is accepted) without fear of having to break the API when refactoring. This would save the developer from having to manually implement getter and setter routines and reduce the amount of boiler-plate code.\nI propose the following syntax:\ntype example_type\n  ! ...\ncontains\n  get :: foo => get_foo\n  set :: foo => set_foo\nend type\nThe getters and setters could have permissions just like a type-bound procedure, but given the use-case presumably we'd just want them to always be public. The interface for the getters and setters would be\npure function get_interface(this) result(component)\n  class(...), intent(in) :: this\n  type(...) [, (pointer | allocatable | dimension | ...)*] :: component\nend function\n\nelemental subroutine set_interface(this, value)\n  class(...), intent(inout) :: this\n  type(...), intent(in) [, (pointer | allocatable | dimension | ...)*] :: value\nend subroutine\nClient code could then call the getter and setter as follows:\ntype(example_type) :: bar\ninteger :: val\nval = bar%foo ! invokes getter\nbar%foo = val * 2 ! invokes setter",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-21 19:19:22+00:00",
                    "text": "I think you listed the arguments for this feature. A few arguments against such a feature is that adding any such new feature to the language makes it more complicated and more opaque, e.g., now it is not clear what exactly bar%foo = val * 2 does --- now it will be a method invocation, instead of a simple (member) variable assignment.\nAs such, the Pros should outweigh the Cons. I personally am not very convinced (yet) in this particular case.\nOne thing that I would like us to formulate are general rules of what features should not go into Fortran. For example, we probably do not want to make Fortran another C++ by simply adding every feature that is in C++ (or Python). One huge advantage of Fortran is that it is (still) a very simple language. What you see is (typically) exactly what happens. We would lose some of that with syntax like bar%foo = val * 2, which ultimately does make it just a little bit harder to learn (with every such feature). I guess it depends what direction we want Fortran to go. And having some kind of general guidelines that we all agree on would help I think.\nUltimately that's why there is a committee, so it does not really matter what I think personally, but I am just posting here to discuss the possible negatives of such a proposal."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-21 21:07:29+00:00",
                    "text": "I think a compelling case can be made for adding setters to the language, e.g., in the context of improved support for containers.    (Getters don't really need any new functionality, IMO.)    Yes, workarounds exist but at the cost of extra copies or requiring the use of pointers, and always with some loss of clarity.\nI suspect the biggest obstacle would actually be gaining consensus on the syntax.   Array-like syntax would be the most natural, but obviously conflicts with, er, array syntax.    And square brackets have already been coopted for coarrays.    So I'm thinking something like curly braces or \"@\":\nmy_obj{idx} = expr\nmy_obj@(idx) = expr\nNote that something like the latter syntax is likely going to emerge in F202X for a different purpose:  rank-agnostic array references."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-22 15:38:42+00:00",
                    "text": "I disagree that this syntax makes Fortran more complicated or opaque to any significant degree; it does this no more so than does defined-assignment.\nI also think the advantages go beyond what I described in my opening post. In order to ensure future changes won't break the API, currently all derived type components should be declared private and then accessors added for those meant to be publicly available. For large derived types this is extremely tedious, especially given the verbosity of Fortran. Because intrinsic getters and setters make a function call and direct access to the variable syntactically indistinguishable, that means the API can be preserved even if a previously public component is made private or outright removed from the derived type.\nThis allows for considerable time savings when writing code and reduction in the amount of boilerplate which is needed. In addition to making the programmer's life easier, this also makes them more productive and therefore improves Fortran's reliability as a language. The problem which Fortran currently runs into is that it takes significantly longer to write the same program in it than in Python (or other, higher-level languages). While it will certainly run faster, in most use-cases a programmer's time costs more than computational run-time. As such, we increasingly see people moving towards wrapping bits of legacy Fortran code with f2py while writing the rest of their software in Python. If we wish to preserve the viability of Fortran as a language we must take steps to improve productivity in it.\nThe fact that future-proofing the API requires the programmer to write trivial getters/setters even when they are not strictly necessary also impacts on performance. There will be the overhead of an extra function call, especially when the type-bound-procedure is not nonoverrideable and requires consulting a vtable. Functions which return polymorphic variables or (if I am not mistaken) a dynamic array do not tend to get optimised into subroutines by the compiler. This means that two assignments will tend to occur (first to the return variable in the function, then to whatever the function result is assigned to in the calling procedure) and possibly two memory allocations as well."
                },
                {
                    "user": "septcolor",
                    "date": "2019-12-19 21:04:38+00:00",
                    "text": "In current Fortran, I feel it very tedious to define accessors (or setter/getter). This may be because of the verbosity of TBP syntax, which even seems to discourage coding for encapsulation. I think this situation is in contrast to other languages which often provide a more convenient syntax for the same purpose.\nPersonally, I use a combined approach of getter/setter + raw access of components (+ status flags),  and the main purpose is to let each object self-manage its status and determine what to do in background. I think I am not an enthusiastic \"fan\" of OO, but still think that the above merit of self-management very useful (and indeed helped my coding a lot).\nSo, although it is not clear what is a best improved syntax (if any), I guess it would be nice if some new syntax/facility makes such coding easier (and hopefully less verbose)."
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 20:10:13+00:00",
                    "text": "Array-like syntax would be the most natural, but obviously conflicts with, er, array syntax.\n\nTom:\nI proposed array/function syntax for structure components, getters, and setters at the X3J3 meeting in Albuquerque in 1986, when % was still controversial. John Reid, Rex Paige, and Brian Smith understood it. Others said \"Fortran programmers want to see what their program is doing.\" Of course, you DO NOT want to see HOW your program is doing things. Parnas had explained that 16 years earlier.\nThere is no syntax conflict. Processors can already work out the difference between function and array references. Setters would not be a new problem. Indeed, an assignment to an array element is an invocation of a setter that the processor knows how to write and inline."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-01-18 01:15:58+00:00",
                    "text": "If the protected attribute is allowed for members of derived types as already under discussion in #16 and #156, the \"getter\" problem would be solved for many usage cases.\nI can still imagine instances where I would like to have something closer to the idea of Pythons @property decorator. An example of what I have in mind is something along the lines of\n\ntype :: matrix\n  real, allocatable :: A(:,:)\n  integer, property :: rows = size(matrix%A,1)  ! a read-only property\n  integer, property :: cols = size(matrix%A,2)   ! a read-only property\ncontains\n  procedure :: get_nrows  ! I would like to avoid having to write this function\nend type\n\ntype(matrix) :: mat \n\nmat%A = reshape([1,2,3,4],[2,2])\n\nprint *, A%rows, A%cols    ! prints:       2       2\n\nI am guessing this would conflict with the way some intrinsic functions work. The gfortran documentation says that size() will only return a meaningful result for an allocated array. On the other hand ifort appears to return 0 as the size of unallocated objects. In any case the idea is that the actual call to size() would be made when the member A%rows is referenced somewhere. It would probably make sense to limit the allowable property functions to pure intrinsic functions."
                },
                {
                    "user": "acikek",
                    "date": "2021-04-29 02:32:47+00:00",
                    "text": "@ivan-pi to clarify, that property attribute would mean that the assigned value is an executable statement, yes? While I agree with you on that it would definitely only allow pure intrinsic functions, even within those constraints, it wouldn't allow for properties that call multiple statements.\nThis is dissimilar to Python's @property decorator. It seems that what you want is more alike to JavaScript's arrow syntax for defining functions (conveniently using the same => operator), which is a whole different ordeal. For getters and setters, personally, pointing to a contained function or subroutine such as in the original proposal makes more sense."
                }
            ]
        },
        {
            "number": 29,
            "user": "arjenmarkus",
            "date": "2019-10-21 07:44:27+00:00",
            "title": "Proposal for general-use templates",
            "text": "Generic features and the apparant lack of them in Fortran (up to the 2018 standard) are a widely discussed subject. I have written a note on the use of modules to achieve a (limted) form of genericity and that has inspired me to a new note which contains a concrete proposal for general-use templates. See the attachment.\nNote: this note has been extended after discussion with Magne Haveraaen an Damian Rouson. I realise that the ideas may not have been formulated as clearly as required.\nproposal_templates.pdf",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 07:53:20+00:00",
                    "text": "Interesting. I was thinking of something similar to your generic types and contracts actually. I took inspiration from the experimental concept feature in the new language Nim: https://nim-lang.org/docs/manual_experimental.html#concepts"
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 08:32:01+00:00",
                    "text": "Nice proposal Arjen! One comment: this would require a separate module for every type, rank and attribute combination, one would like to generate. Imagine, you would like to use a list with 5 different types and 3 different ranks each in your project. You would have to create 15 modules... Then, I would still resort to pre-processors offering branches (e.g. Fypp \ud83d\ude09 ) in order to make it automatic, so we would be still stuck in the dark area of pre-processors. \ud83d\ude04\nWould it be possible to generalize the syntax in a way, that a user can generate the template for several different types within one module?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-21 08:43:52+00:00",
                    "text": "@cmacmackin : I knew of NIM, never had a look at it though. I have now printed the document (being old-fashioned I do prefer reading from paper ;)).\n@aradi : I should make that clearer, While I have modelled this proposal on templates, it is not meant to generate individual modules only. The one thing you need to take care of when putting several instantiations into one module is to make sure that types (and variables and ...) have unique names. Hm, intriguing: should that be a problem to be solved by designging the language feature in that way or by the user (on the principle of \"caveat emptor\")?"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-21 08:45:01+00:00",
                    "text": "The nice thing about this kind of language feature is that you can easily experiment with it (via preprocessing of course) but still."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 09:33:29+00:00",
                    "text": "Taking another look at this, something which I think is missing is the ability to define procedures which operate on two distinct types which satisfy the generic type. I suppose one way to approach this would be to simply define multiple generic types with the same contract but different names. That would work fine for types without any required components or type-bound procedures but would become repetitive for more complex generic types.\nAnother issue is that this approach only allows you to define the components and type-bound procedures required for the generic type. You can't require any non-type-bound procedures to take it as an argument.\nFinally, any (non-type-bound) procedures would have to be renames if they are to share a scope with another instantiation of the template. I'd suggest some means of automatically making this happen and creating a generic interface for the procedures."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-21 09:40:19+00:00",
                    "text": "When I wrote it, it seemed fairly straightforward - apart from a few bits and pieces like the \"implicit\" statement maybe ending up in the wrong place and complications regarding \"type(data_type)\" and plain \"data_type\". But you have uncovered another issue indeed.\nI would like to avoid unnecessary verbosity, as that would hinder the use of such a feature. Thanks, I will definitely revise my proposal :)."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 10:24:46+00:00",
                    "text": "Another question: how would this proposal interact with parameterised derived types? While I don't particularly like how those work, they are a part of the standard and we have to deal with them. Can your generic types be parameterised? We'd have to think through how that could work.\nAnother issue which I see is that you are treating kind/len (possibly rank, size, and other attributes as well?) as though they are simply part of type. However, they are different things. I'm not convinced that it is appropriate to replace a map a type/kind combo to a generic type, as you show in a number of your examples. I feel like your approach comes too much from the perspective of substituting bits of syntax in such a way to ensure the code compiles. However, I'm not convinced that it is semantically appropriate for Fortran."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 10:39:06+00:00",
                    "text": "I think, we need a syntax which immediately allows the compiler to generate unique names via name mangling, so that user should not have to care more about it, as with normal generic routines. What do you think about something along the following:\nmodule swaptemplate<T, R>\n  generics, type :: T\n  generics, rank :: R\n  implicit none\n  private\n\n  public :: swap\n\n  ! This should be generated by the compiler probably\n  interface swap\n    module procedure swap<T,R>\n  end interface swap\n\ncontains\n\n  subroutine swap<T, R>(arg1, arg2)\n    <T>, dimension(<R>) :: arg1\n    <T>, dimension(<R>) :: arg2\n\n    <T>, dimension(<R>), allocatable :: buffer\n\n    allocate(buffer, source=arg1)\n    arg1 = arg2\n    arg2 = buffer\n\n  end subroutine swap<T, R>\n\nend module swaptemplate\n\n\nprogram test_swap\n  use swaptemplate<integer, 0>\n  use swaptemplate<integer, 1>\n  use swaptemplate<real, 0>\n  use swaptemplate<real, 1>\n  implicit none\n\n\n  real :: r0a, r0b, r0c\n  real :: r1a(2), r1b(2), r1c(2)\n  real :: i0a, i0b, i0c\n  real :: i1a(2), i1b(2), i1c(2)\n\n\n  call swap(r0a, r0b, r0c)\n  call swap(r1a, r1b, r1c)\n  call swap(i0a, i0b, i0c)\n  call swap(i1a, i1b, i1c)\n\nend program test_swap"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 10:46:33+00:00",
                    "text": "I agree, something like that seems sensible (although we could debate whether the compiler should automatically generate the interface swap block). This is similar to the old proposal for parameterised modules, which I always liked."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-21 10:56:17+00:00",
                    "text": "Valid questions and useful suggestions. My, there is a lot to think about, isn't there?\nHow about this to avoid repetition:\ntype, generic :: data_type\n... properties\nend type data_type\ntype, copy(data_type) :: new_type\n... possibly additional properties\nend type\n\"copy(...)\" would be akin to \"extends(...)\" in syntax, not in semantics"
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 11:03:18+00:00",
                    "text": "@cmacmackin Yes, indeed. However, one could even carry it further and allow for \"generics\" on the type level (although, probably, that is much more complex on the compiler side):\nmodule generic_module\n  implicit none\n\n  public :: template_type<T,R>\n\n\n  type :: template_type<T, R>\n    generics, type :: T\n    generics, rank :: R\n    <T>, dimension(<R>), allocatable :: content\n  end type template_type<T, R>\n\nend module generic_module\n\n\nprogram test_generics\n  use generic_module, my_type_int0 => template_type<integer, 0>,&\n      & my_type_int1 => template_type<integer, 1>\n  implicit none\n\n  type(my_type_int0) :: i0\n  type(my_type_int1) :: i1\n\n  !...\n\nend program test_generics"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 11:17:08+00:00",
                    "text": "I've been thinking a bit about the Fortran type system. In a language like C++, a variable's type encapsulates the sort of data it stores (int, uint, string, etc., with each of these corresponding to a unique kind), whether it's a pointer, whether it's an array, etc. In Fortran, there are really four different aspects to the type system, each of which is somewhat independent:\n\ntype (integer, real, derived type, etc): either known at compile time or deferred until run-time using polymorphism\nkind (how a particular type is stored in memory): must be known at compile time\nrank (number of dimensions of an array): until recently had to be known at compile time, but now can be deferred to run-time using the assumed-rank feature. Unlike type and len, however, it can not be dynamically allocated at run-time, making it more like old-fashioned assumed-size arrays rather than modern assumed-shape arrays\nlen/size (number of elements in each dimension of an array): can be deferred to run-time\n\nParameterised derived types take care of kind and len, where the latter can be deferred until run-time but the former must be known at compile-time. That severely limits the usefulness of parameterising the kinds in a type, because every combination of kind values requires its own implementation of a procedure which takes that type as an argument. And just to make it all the more confusing, unlimited polymorphic variables are able to take on any kind that the user wants, despite polymorphism really being about the type and not the kind.\nTemplates/generic programming in a language like C++ are conceptually fairly straightforward. While the code is written in such a way that it does not state the exact type (which, as we said, contains the information on the kind, rank, len) of the data it is operating on, all of this information will be available at compile-time. I don't think anyone has adequately considered how templates in Fortran should deal with the fact that there are really (up to) four pieces of information they need to know about, rather than one like in C++. Worse, the way these pieces of information are currently handled by the compiler are not really consistent, with some needing to be known at compile-time and others put off until run-time under certain circumstances.\nMy feeling is that we're going to need to step back somewhat if we are to consider how best to make generic programming work within the type-system as a whole. Perhaps we should think about introducing \"assumed-kind\" variables and a select kind construct. This could be modelled after the assumed-rank feature, with similar restrictions in place. (More ambitiously, we could think about making both rank and kind dynamically allocatable, I suppose, although I don't think that would be necessary for what I'm thinking about here). There need not be any additional run-time overhead, as the compiler could generate all necessary combinations of kind-parameters for a type or procedure at compile-time.\nLet's say that derived types could then be parameterised on rank and that len parameters could then be a 1-D array:\ntype :: foo(r, s)\n  integer, rank :: r = 2\n  integer, dimension(r), len :: s = [3, 5]\n  real, dimension(s) :: bar\nend type foo\n(Note that it remains unclear as to exactly how we'd handle allocatable/pointer arrays of parameterized rank, in that case.)\nWith those changes we could eliminate some of the inconsistency within the Fortran type system. At that point it starts to become easier to think about how we do the same for the type itself through templating. I think parameterised modules (with the inclusion of some sort of type parameter), the addition of a type-parameter to derived types, and/or (potentially parameterised) generic types described above might be able to handle it."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 12:40:42+00:00",
                    "text": "Could you make a demonstration, how the swap-module above would look then alike? I think, swap is a pretty good example, as it covers many aspects of the generics while being super simple."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 12:45:44+00:00",
                    "text": "My thoughts aren't quite concrete enough for that yet. I'll try to come up with some examples of what we could do though."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 12:51:55+00:00",
                    "text": "Cool! I just have realized, that issue #4 has a very similar subject, maybe it would be worth to close this issue and continue discussion there?"
                },
                {
                    "user": "rweed",
                    "date": "2019-10-21 13:44:42+00:00",
                    "text": "First thanks a big thanks to Ondrej and Zach for standing up this site. Its something some have advocated for a while and is long overdue. Also, thanks to Arjen. Your proposal looks like it might be a workable first step to templates and to me fits into current Fortran syntax etc. better than some of the other proposals I've seen. One idea that i had as a first step to a generic container was an extension of parameterized types to allow the syntax introduced in F2008 that allowed the type statement to define intrinisic variables to be allowed in the definition of the PDT but with an associated modification to the underlying KIND parameter facility to make it truly generic (syntax wise). Specifically, in F2008 you can do the following to define a double precision variable\nUSE ISO_FORTRAN_ENV\nType(REAL(REAL64)) :: areal\nIdeally you would want to be able to just write\nType(REAL64) :: areal\nUnfortunately, because the standard does not mandate that KIND parameters be unique in the sense that the values returned by the SELECTED_REAL, SELECTED_INT, and KIND functions along with the intrinsic parameters in ISO_FORTRAN_ENV are never the same value. Currently I think the majority of compilers will return 4 for both KIND(1) and KIND(1.0) plus INT64 and REAL64 are both 8. If the values were unique then for me parameterized types become a little more generic because I can do the following\nType :: genval(listkind)\nInteger(kind) :: listkind\nType(listkind) :: aval\nEnd Type\nwithout having to create a separate type for each intrinsic value.\nThe only reason I can see that the current KIND facility doesn't mandate unique values is to placate people who still (foolishly) insist on doing\nReal(8) :: areal\nInteger(8) :: aint\nHowever, I can't see any reason that the values returned by the various KIND setting functions and the intrinsic values in ISO_FORTAN_ENV can't be unique and still support the old Real(8) syntax. For the functions etc. just let the kind values returned for each intrinsic type live in a predefined range (ie. integers live in 100-199, reals in 200-299 etc).\nThese modifications would help to address support for containers with intrinsic values but still leave open how you support user defined types in a similar manner. I would like to hear others ideas on how the compiler might do this. And has been pointed out, you still have the len parameter issue that prevents PDT's from being statically polymorphic which is what templates are really all about."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-21 14:02:30+00:00",
                    "text": "Thanks for these comments. I am going to study this conversation in more detail. Hope to reformulate my proposal in a couple of days."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 14:34:34+00:00",
                    "text": "@rweed Would it be possible to present a simple self containing example using your generalisation idea? For example, how would the swap-algorithm above look like when using your suggestion? (As stated above, the swap-algorithm contains many aspects of generic programming, while being very-simple.)\nI think whatever we come up with, it should work with intrinsic types, derived types (maybe even with parameterized ones) and classes as well, each of those with arbitrary ranks. Do you think, your approach can cover those cases?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 18:29:44+00:00",
                    "text": "@arjenmarkus thanks for opening an issue for this. I posted here how to get involved with @tclune who is leading the effort:\n#4 (comment)"
                },
                {
                    "user": "rweed",
                    "date": "2019-10-22 14:37:24+00:00",
                    "text": "@aradi requested an example of what I'm proposing for modifying PDTs. First look at the following code that uses PDTs to define a node and list type for a circular-doubly-linked list of integers. This code compiles without errors with Intel 2019.5 ifort\nProgram testpdt\nUSE ISO_FORTRAN_ENV\nImplicit NONE\nType :: CDLnode_t(ikind)\nInteger, kind :: ikind\nType(CDLnode_t(ikind)), Pointer :: next_p => NULL()\nType(CDLnode_t(ikind)), Pointer :: prev_p => NULL()\nInteger(KIND=ikind) :: ival\nEnd Type\nType :: CDLlist_t(ikind)\nInteger, kind :: ikind\nType(CDLnode_t(ikind)), Pointer :: head_p => NULL()\nInteger(INT64)                  :: counter = 0_INT64\nEnd Type\nEnd Program testpdt\nNow assume that the modification to KINDS I'm proposing is in place. CDLnode_t now becomes\nType :: CDLnode_t(ikind)\nInteger, kind :: ikind\nType(CDLnode_t(ikind)), Pointer :: next_p => NULL()\nType(CDLnode_t(ikind)), Pointer :: prev_p => NULL()\nType(KIND=ikind) :: aval\nEnd Type\nThis gives you an truly generic container for reals and ints. Support for character strings might take a little more thought. There is support for deferred length strings etc for PDTs but how to fit that into a truly generic framework is something we can discuss.  The big issue is how do you support user defined types using just the kind parameters. There are obviously a lot of other issues that need to be addressed but I think what I'm proposing is a tiny first step that builds on current Fortran syntax and gives programmers another option besides using unlimited polymorphic variables (I've done this for lists, trees, hashmaps etc and its not pretty) or relying on preprocessor tricks to emulate templates."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-22 15:51:08+00:00",
                    "text": "@tclune, in issue #30 you mentioned that \"rank-agnostic array references\" are likely to emerge in the 202X standard. This would likely be an important enabling feature for generic programming/templating, as it would allow the same code to work on any rank of array. I've been struggling a bit to think of decent syntax for generic rank variables (beyond what already exists for assumed-rank arrays, which aren't doing quite what we're looking for here given that their rank remains unknown at run-time). It might be useful if you could elaborate on what is being discussed for this new feature, as it could stimulate some ideas on this issue."
                },
                {
                    "user": "certik",
                    "date": "2019-10-22 16:08:02+00:00",
                    "text": "Let's create a separate issue for \"rank-agnostic array references\" to track that feature (link to committee papers/proposals, etc.)."
                },
                {
                    "user": "haraldkl",
                    "date": "2019-10-22 16:24:57+00:00",
                    "text": "I think Ada has a quite sophisticated generics system. I'd love it if some those concepts could be adopted in Fortran. See https://en.wikibooks.org/wiki/Ada_Programming/Generics."
                },
                {
                    "user": "vansnyder",
                    "date": "2020-05-09 20:02:21+00:00",
                    "text": "I proposed parameterized modules in 2004. The paper was 04-383r1. It's similar in spirit to Arjen's proposal, but uses the MODULE and USE statements. It provides what Magne Haveraaen asked for in Tokyo.\n04-383r1.pdf"
                }
            ]
        },
        {
            "number": 28,
            "user": "cmacmackin",
            "date": "2019-10-20 21:52:13+00:00",
            "title": "Allow derived type components to have target attribute",
            "text": "Currently the target attribute is not allowable for derived type-components. Thus, the only way to return a pointer to a component is either to declare it as a pointer itself (with all the extra work required for manual memory management) or by ensuring that the entire derived type variable itself has attribute target.\nThere have been times when I've wanted an accessor type-bound procedure to return a pointer to a component which takes up a large amount of memory, to avoid having to make a copy of it. Currently the only way to do this is by making that component a pointer itself, which introduces risks of memory leaks. It would be safer if I could just declare that component to have attribute target. Is there any particular reason this can't be done?",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-21 00:43:11+00:00",
                    "text": "@cmacmackin good question!  You may be interested in reading this response  from several years ago on comp.lang.fortran: I'm yet to see a better explanation!"
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 08:16:28+00:00",
                    "text": "Thanks for the link. I'm still not convinced that this is a good reason. If necessary, the compiler can simply enforce that the entire object be a target if a component has that attribute, surely?"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-22 19:54:47+00:00",
                    "text": "Thanks for the link. I'm still not convinced that this is a good reason. If necessary, the compiler can simply enforce that the entire object be a target if a component has that attribute, surely?\n\nYes, surely I think too.\nFortran 2008, for example, introduced the feature, \"A pointer dummy argument with intent in may be argument associated with a non-pointer actual argument with the target attribute. During the execution of the procedure it is pointer associated with the actual argument\" known colloquially as \"automatic pointer targetting\" or auto-targetting which, if I'm not mistaken, complemented a previous mod (Fortran 2003?) where an actual argument without the TARGET attribute can be used with a dummy argument with one.  I think what you suggest can loosely be placed in these categories..\nObjections for such matters are often attributed to the invisible/indeterminable/intangible compiler benefits or lack thereof with optimization.  But once the standard is modified to permit an erstwhile abomination, few bat an eyelid in objection!"
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-21 14:09:48+00:00",
                    "text": "Thumbs up, for this proposal. This is something I really miss. In my opinion it is an irregularity of the language to allow something like real, dimension(:), allocatable, target :: array while prohibiting\ntype :: wrapped\n   real, dimension(:), allocatable, target :: array\nend type wrapped\n\nAfter all, allocatables were allowed to be used in derived types by Fortran 2003 because of their many advantages (regarding safety, and automatic memory management). But we still can't point to them and thus have to use pointers again, making that whole point moot. This needs to be fixed as soon as possible (i.e. in the upcoming standard)."
                },
                {
                    "user": "aradi",
                    "date": "2020-01-23 16:07:59+00:00",
                    "text": "You can point to the allocatable component in the derived type:\nmodule testmod\n  implicit none\n\n  type :: target_t\n    integer, allocatable :: array(:)\n  end type target_t\n  \nend module testmod\n\nprogram testprog\n  use testmod\n  implicit none\n\n  type(target_t), target :: instance\n  integer, pointer :: ptr(:)\n\n  instance%array = [1, 2, 3]\n  ptr => instance%array\n  print *, ptr\n\nend program testprog\n\nYou just have to make sure, that the instance of the containing derived type has the target attribute.\nI think, a derived type is an \"inseparable\" unit. Whenever you have one component of it in the memory, all the other components must be there as well. Therefore, the constraints a target attribute puts on a specific component, would have to be applied to all of them. To me, it is more logical then to specify the target attribute for the entire derived type instead for its components, as it is now."
                },
                {
                    "user": "difference-scheme",
                    "date": "2020-01-23 16:53:35+00:00",
                    "text": "I see. They obviously followed a different philosophy on this one. Thanks for pointing this out."
                }
            ]
        },
        {
            "number": 27,
            "user": "cmacmackin",
            "date": "2019-10-20 21:45:25+00:00",
            "title": "Remove restrictions on proc-component-ref",
            "text": "There may be a reason why the standards committee has chosen not to allow this, but I've found it very irritating that a proc-component-ref (R1039 in the draft 2018 standard) requires that the variable on the left-hand-side of the % character be a data-ref (according to C1027). This prevents type-bound function calls being performed on function results, as can be done in pretty much every other object-oriented language. Thus, the following code is illegal:\nvar = object%get_another_object()%get_yet_another()\nInstead, something along the lines of\ntmp = object%get_another_object()\nvar = tmp%get_yet_another()\nis required. This is more verbose, especially as you try to chain more and more function calls together. Is there any reason for this restriction?\nI would propose changing this. The definition of proc-component-ref could stay the same as before:\nR1039  proc-component-ref        is  scalar-variable % procedure-component-name\n\nbut C1027 (\"the scalar-variable shall be a data-ref that is not a coindexed object\") would be amended to\n\nthe scalar-variable shall not be a coindexed object.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Fortran 202y",
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "FortranFan",
                    "date": "2019-10-21 01:55:48+00:00",
                    "text": "This appears similar to a proposal made last year for Fortran 202X.\nUnfortunately that proposal was rejected, the minutes from the standard committee meeting indicate, \"Discussion: This means having a part name in a designator  being a function reference.  Suggested that parsing would not be straightforward.  Obvious workaround in the paper  SV: 3 - 0 - 10\""
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 08:18:57+00:00",
                    "text": "Do you have a link to the paper they reference?\nI'm not convinced about the parsing argument. Every other object oriented language manages to have a feature like this and I've written a grammar myself which is capable of that sort of parsing. This feels like (yet another) case of compiler vendors making programmers' lives more tedious and difficult in order to make their lives easier."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-21 19:43:24+00:00",
                    "text": "Do you have a link to the paper they reference?\n..\n\nIf I understood correctly, the paper they mention is the proposal itself which lists the use of a temporary which is just like what you mention in the original post here - that appears to be their suggested workaround ..\nIt's interesting to read of your experience with parsing such grammar: wonder if you can collaborate with @certik et al. at some point in the future, perhaps on LFortran, and prototype your great ideas in an implementation that other users can \"play around\" with!"
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-22 02:51:40+00:00",
                    "text": "Yes, this would be an amazing! Image if we had a nice dynamic string class (see #24) and could do stuff like this:\n  type(string) :: s\n  type(string),dimension(:),allocatable :: s_array\n  s = 'THIS, would, be, Amazing   '\n  s_array = s%lower()%split(',')    ! would be: ['this', 'would', 'be', 'amazing']\n  write(*,'(*(A,1X))') s_array  ! this would be amazing\nI also think the excuses from the committee about why we can't have nice things are becoming very tiresome."
                },
                {
                    "user": "certik",
                    "date": "2019-10-22 04:59:17+00:00",
                    "text": "Another usecase that I often hit is if a function returns an array, to be able to do things like\nf()(5)\nWhich might be related to this proposal. And unlike in #30 where I can see some downsides, here I don't see any downsides, it seems this proposal just naturally allows what's already in the language.\nThere are probably some reasons why this is not allowed, and so let's hear the reasons and discuss them.\n@jacobwilliams I very well understand your frustration. That was one of the reason why I joined the committee (and I invite you to join as well if you can). What I found out is that the committee is composed of very nice and reasonable people that really care about Fortran, but sometimes the priorities are not well aligned with what should be done. That is one of the goals of this repository for us to brainstorm what we want to get done, and then pick the top 3 to 5 issues and prioritize them at the committee. For example this very issue, as well as #1 are issues that keep bothering me, but I kind of got used to them and so I am very happy that they got brought up, as I think those are some of the low hanging fruits to fix, which might not be that difficult to get agreement in the committee to fix."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-22 08:04:21+00:00",
                    "text": "Yes, array access on a function result would also be useful, although I feel like that could potentially pose more issues with ambiguity in the language grammar, given that functions calls and array access both use parentheses (regrettably).\nI don't buy the argument that chaining function calls together is difficult to parse. In fact, my experience was that it is easier to allow the parser to process that than to try writing a grammar that restricts it. While I see that the LFortran grammar would not accept chaining function results together like this, it also can not recognize all allowable calls to type-bound functions. The standard specifcies that something like\na = object%array_component(1)%function_call(1.5, 2.0)\nis valid. It is far simpler to write a grammar which can recognize that and chaining together function results than one which can only recognize calling a type-bound function after array access.\nI'm currently away from my laptop, where I've been experimenting with a grammar, but once I'm back home this evening I can post the relevant portion of it."
                },
                {
                    "user": "certik",
                    "date": "2019-10-22 16:46:23+00:00",
                    "text": "Another possibly related issue is #14. If results of a function can be used, then that could allow things like:\ndiag(A) = 1\nRegarding the grammar, I agree, it's probably not difficult to parse. The latest LFortran grammar is in here: https://gitlab.com/lfortran/lfortran/blob/a2707be7386e57dc62ec9e1005a570cde2fc5b70/src/lfortran/parser/parser.yy if you want to play with it."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-22 19:02:51+00:00",
                    "text": "Another possibly related issue is #14. If results of a function can be used, then that could allow things like:\ndiag(A) = 1\n\n..\n\n@certik,\nWith respect to all the issues being reported here, you are an excellent moderator in bringing all the sides to the discussion like in your response to @jacobwilliams above.  Hats off to you for that!  I often allow my own frustration with Fortran to \"boil over\" and among my reasons for that include what I believe are the inconsistencies in both the semantics offered in the current version standard wrt the objections raised for new facilities as well as the disconnects in the work process to get new items added to the language like those in the list for Fortran 202X (more on this later elsewhere).\nBy the inconsistency in semantics, you will know the language already allows instructions such as\n   diag(A) = 1\n\nIt's just that certain conditions need to be met which are essentially that A must either be a simply contiguous target or a contiguous pointer.  Here's an example:\n   integer, parameter :: N = 3\n   integer, target :: A(N,N) !<-- mat is \"simply contiguous\"\n   integer :: i, j\n\n   A = reshape( [( (10*j + i, i=1,N ), j=1,N) ], [N, N])\n   print *, \"A before diagonal reset:\"\n   do i = 1, size(A,dim=1)\n      print \"(*(g0,1x))\", A(:,i)\n   end do\n\n   diag(A) = 1\n\n   print *, \"A after the diagonal reset to unity:\"\n   do i = 1, size(A,dim=1)\n      print \"(*(g0,1x))\", A(:,i)\n   end do\n\ncontains\n\n   function diag(Mat) result(r)\n\n      ! Argument list\n      integer, contiguous, target :: Mat(:,:)\n      ! Function result\n      integer, pointer :: r(:)\n\n      ! Local variables\n      integer, pointer :: FlattenedMat(:)\n\n      ! Flatten the matix\n      FlattenedMat(1:size(Mat,dim=1)*size(Mat,dim=2)) => Mat\n      r => FlattenedMat(::size(A,dim=1)+1)\n\n      return\n\n   end function\n\nend\n\nNow gfortran does not support the above example, but I believe it is standard-conforming and it works with another compiler.  Upon execution, the above example produces:\n A before diagonal reset:\n11 12 13\n21 22 23\n31 32 33\n A after the diagonal reset to unity:\n1 12 13\n21 1 23\n31 32 1\n\nSo my point is several of the concepts, semantics, and syntax e.g., auto-targeting,  references (pointers) in any variable-definition context, etc. which can help what's being in the proposed in the original post here have already made it into the standard.\nThus in my mind the objections such as those that lead to rejections of the paper 18-134 are either half-baked or non-technical or both and it's only Fortran that suffers.  It's a race out there and lots and lots of codebases are permanently being lost to Fortran.\nThings are getting too far delayed needlessly and features delayed are features denied to persevering practitioners of Fortran.\nHence my constant refrain to accelerate certain aspects of the standard development and to establish better and more CONSISTENT and OBJECTIVE criteria to guide the development of the standard.  Among these must be the idea to limit the objections by processor implementors on non-technical grounds (e.g., scope) until and unless they are firmly \"holding their own feet to the fire\" in terms of achieving standard-compliance per some reasonable schedule.  Right now it's having both ways \"have your cake and eat it too\": implementations will not promise nor adhere to any schedule in terms of compliance (it can take decades to get a feature in) but yet get to override good proposals on the basis of scope.  That does not seem fair in any way to all the Fortranners out there.\nAnyways, yours and @zjibben's initiative with GitHub here is an excellent step in the right direction."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-22 19:24:11+00:00",
                    "text": "I've been experimenting with a Fortran grammar implemented using the Lark library (see here for a summary of the grammar syntax). While it is not complete yet, I've made some decent progress. The relevant bit to this discussion is\n?primary_expr : primary_expr \"(\" [paren_contents] \")\" -> parentheses_access\n\t      | primary_expr \"%\" NAME -> component_access\n\t      | primary_expr image_selector -> coarray_access\n\t      | _primary\n_primary : literal_constant | NAME | array_constructor | \"(\" expr \")\""
                }
            ]
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2019-10-19 23:35:41+00:00",
            "title": "Proposal for Workflow",
            "text": "Ideal Plan\nHere is a proposal that I would like to get feedback on and discuss. This is my idea how this GitHub repository can work.\nHow Opensource Works\nSuccessful open source projects, such as SymPy that I started 13 years ago, have:\n\none or two owners/leaders\n10-20 core developers with push access, those people can merge GitHub Pull\nRequests (PRs)\nhundreds of people who contribute PRs\nthousands of people who open issues and discuss them\n\nHow the Fortran Committee Could Work\nThe Fortran Standards document is compiled from LaTeX source code, and\nproposals that eventually get approved must be of very high quality and must\nsucceed multiple rounds of approvals. Fundamentally this is no different to\nopensource development.\nHere is how it could work:\n\n\nThe J3 committee chair and the WG5 committee chair are the two owners/leaders\n\n\nThe J3 and WG5 comittee voting members are the core developers, who approve\nproposals in the same way they currently do (the proposal must be submited at\nthe J3 website, then advocated at the committee, and eventually approved).\n\n\nHundreds of people use this GitHub repository to submit PRs, where each PR is\na particular proposal. We all collaborate on the PRs, and if it gets merged,\nit means that the proposal is of very high quality and is worth for the\ncommittee to spend their time to consider it. We use issues to track how the\nproposal gets processed by the committee and either approved or rejected. We\nsend further PRs to improve upon it based on the committee feedback.\n\n\nThousands of people open issues to propose new features and discuss them.\n\n\nAnybody can create a PR to try to create a proposal. Only members of the\ncommittee have push access (are allowed to merge PRs) and if they merge a PR,\nthey are responsible to advocate for it at the committee and collect the\ncommitee's feedback.\n\n\nThe committee itself does not need to change at all how it works, members of\nthe committee who do not have time or interest to be involved at GitHub do\nnot need to. For this plan to work, just several members of the committee\nneed to be actively involved (we already have 3 or 4 members who are\ninvolved, and that is enough to get us started). As this GitHub repository\nbecomes more popular, I can imagine eventually all members of the committee\nto at least read some of the responses and activity and what issues are\npopular.\n\n\nThe whole community works on PRs and essentially works nonstop (with hundreds\nof people in all time zones one gets a new PR every couple days, as in\nSymPy). That way, when the committee meets, it has high quality proposals to\nconsider, and it does not need to spend precious committee time to develop\nhigh quality proposals, because that work is outsourced to the wide\ncommunity.\n\n\nThe core developers (committee members) are the ones who ultimately decide\nwhat goes in, and what does not. Just like now. The only thing that changes\nis that the workflow becomes more efficient.\n\n\n\nSome lessons from open source development that will apply here:\n\n\nIf we are successful, we will get thousands of issues from people all over\nthe world. Some good, some not as high quality. People will discuss issues.\nInitially, many will be frustrated at how slow the committee works. The best\nreaction that we can do is to encourage people to create PRs and try to\ncreate high quality proposals for the issue(s) that they care about. And\ninvite them to collaborate on the PRs.\n\n\nExperience shows that this scales really well. We build a team. People start\nfeeling positive about the future, because their voice is heard, and their\nwork (in PRs) is used and their (small or large) contributions help shape the\nfuture of Fortran.",
            "is_open": true,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-20 00:11:27+00:00",
                    "text": "The other issue that I think this workflow can fix is that the committee carefully discusses each proposal in a small group and then in the whole committee in person. But many of the objections and questions and back and forth are more efficient to discuss in a GitHub issues and PRs, so that we can calmly think about each question and response and then collaborate to make the proposal better. So that when the committee meets in person, the simple stuff is already done, all the pros / cons are written up, and we can spend our time weighting the alternatives, as opposed to wasting time discussing things that could have been done beforehand at GitHub (such as that the proposal needs more examples).\nI've seen how the committee works and the most common objections, and I can now ask a lot of them myself and ensure each proposal meets a minimal level of quality here at GitHub.\nA related problem is that the committee only has a few members who are true experts on almost everything in the Fortran language. Most, including myself, only know some parts of Fortran really well, and not so some other parts. So by getting feedback from lots of people about a proposal at GitHub, asking lots of questions and discussing it here, we can iteratively improve the proposal to the level that an expert committee member would write right away. I have seen that happen just last week --- we spent an hour discussing pros and cons of various approaches, eventually agreeing on an approach that neither of us liked at first, but after doing the work, it seemed like the best solution --- and in the meantime an expert committee member sent us an email with exactly the same solution, that he intuitively figured out on his own."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-20 21:45:38+00:00",
                    "text": "I think it best that this GitHub project serve as a mechanism for refining concepts into papers submitted to the committee.    Any suggestion (as above) for a process that requires active participation by committee members to manage PR's is problematic for reasons I will not discuss.\nI think it is also very important to emphasize that the new feature list for F202x is closed.    Issues opened here should either identify a specific item from the F202x in their subject line or clearly specify that the request is for a new feature in F202y."
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 03:35:10+00:00",
                    "text": "The above proposal does not require active participation by committee members beyond those already participating. And that's why I really like it.\n\u2026\nOn Sun, Oct 20, 2019, at 2:45 PM, Tom Clune wrote:\n I think it best that this GitHub project serve as a mechanism for refining concepts into papers submitted to the committee. Any suggestion (as above) for a process that requires active participation by committee members to manage PR's is problematic for reasons I will not discuss.\n\n I think it is also very important to emphasize that the new feature list for F202x is *closed*. Issues opened here should either identify a specific item from the F202x in their subject line or clearly specify that the request is for a new feature in F202y.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub <#26?email_source=notifications&email_token=AAAFAWGTQFTQGKSL4XO4R7TQPTGQFA5CNFSM4JCR34LKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBYUYTQ#issuecomment-544296014>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGA32HNV4WJNWKJWZDQPTGQFANCNFSM4JCR34LA>."
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 12:46:31+00:00",
                    "text": "The other comment is that it's not enough to just write a proposal. One has to write a proposal for every meeting, keep track of it, react and discuss comments to it, etc. So creating proposals is a big part of it, but I want this repository to be a lot more than that. I would like it to become the outward facing interface to the committee.\n\nLet me reiterate that this doesn't require current committee members to change how they work. All it takes is for a few members to participate here and to keep the issues in sync with what the committee is doing -- and we already have that. We have 3-4 members already participating here.\n\u2026\nOn Sun, Oct 20, 2019, at 8:34 PM, Ond\u0159ej \u010cert\u00edk wrote:\n The above proposal does not require active participation by committee members beyond those already participating. And that's why I really like it.\n\n On Sun, Oct 20, 2019, at 2:45 PM, Tom Clune wrote:\n > I think it best that this GitHub project serve as a mechanism for refining concepts into papers submitted to the committee. Any suggestion (as above) for a process that requires active participation by committee members to manage PR's is problematic for reasons I will not discuss.\n >\n > I think it is also very important to emphasize that the new feature list for F202x is *closed*. Issues opened here should either identify a specific item from the F202x in their subject line or clearly specify that the request is for a new feature in F202y.\n >\n > \u2014\n > You are receiving this because you authored the thread.\n > Reply to this email directly, view it on GitHub <#26?email_source=notifications&email_token=AAAFAWGTQFTQGKSL4XO4R7TQPTGQFA5CNFSM4JCR34LKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBYUYTQ#issuecomment-544296014>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGA32HNV4WJNWKJWZDQPTGQFANCNFSM4JCR34LA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-21 21:42:41+00:00",
                    "text": "I overall like this proposal for workflow a lot. My impression of this repository at its conception (even before reading this issue) was that it would allow the community to propose and discuss changes to the language in an organized, centralized, and streamlined way. GitHub provides tools to do exactly that.\nMaintainers of the repository being committee members allows them to communicate these proposals to the rest of the committee and have them considered for adoption. As Ondrej put it, it's an outward facing interface to the committee, and that's how I understood it from the get go.\nNothing about the workflow seems to suggest about how the committee should operate -- that's already in place. Other committee members may or may not choose to participate. However I'd be surprised if most chose not to participate despite this repo churning out a few high-quality proposals or more. Community needs not fight the committee. It just needs to create enough great stuff that it'd be hard to ignore it.\nI suggest to carefully put together a separate document in this repo (perhaps GUIDELINES.md) that would describe in detail how can Joe Fortran Programmer who stumbles upon this repo contribute a high quality proposal that could land onto the committee table at a meeting. Some is already in README.md (great work), and a nice proposal layed out by Ondrej in this issue."
                },
                {
                    "user": "certik",
                    "date": "2019-10-22 05:07:29+00:00",
                    "text": "@milancurcic thanks a lot for posting your opinion. I agree with you. I was thinking of putting this into the README itself, but we can certainly have a separate file such as GUIDELINES.md for this also and just reference it from the README. I'll try to create a PR for this and we can refine the wording at the PR."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-01 20:51:09+00:00",
                    "text": "@certik I've been thinking about what you asked in the comments section of #61 and it's unclear to me as to the content and value of the two documents you seek.\nBefore committing to any further work myself to develop documents toward the workflow, what I would find useful first is a honest discussion with WG5 to help answer the following basic questions:\n\n\nFor whom Fortran?\n\n\nDoes WG5's  answer to question (1) truly and directly include the needs and interests of many non-institutional practitioners like @rweed, @Beliavsky, or Jean, etc.?  If not, to what extent does WG5 think it is a problem?\n\n\nIf the answer to 2) is yes, other than the 2018 survey what does WG5 do to listen to these practitioners on a continual basis?\n\n\nWhat is up with \"national bodies\" in WG5 in this day and age?\n\n\nIf at all there must be national bodies - like US (with J3), UK, and Japan, to what extent are non-institutional practitioners residing in these nations represented in these 3 bodies?\n\n\nWhat about other national bodies or lack thereof?  What about a Fortranner in Brazil or France or Germany or India or Nigeria and how do these Fortranners' inputs get attention from WG5, particularly if they do not have any institutional support toward any ISO IEC advocacy or charter or means to get such support?  This goes back to question 1.\n\n\nMany of the practitioners in 2) are unhappy with the slow pace of Fortran language advancement and their feedback in WG5 survey appears to be mostly ignored in Fortran 202X work-list per J3, as seen in comp.lang.fortran threads, example here  and here.  What does WG5 plan to do about this?\n\n\nNow the two national bodies of UK and Japan have proposed further slowing down the pace and scope of Fortran standard revision due to insufficient processor support - this runs counter to majority views in WG5 survey as well as UK survey and comp.lang..fortran threads and now GitHub.  What does WG5 plan to address such differences in opinion?  See question 9 below re: this.\n\n\nIf WG5 accepts at face value the proposals by UK  and Japan, what are the criteria in terms of processor support toward current standard 2018?  How many processors must offer Fortran 2018 support to consider it good coverage?  Is it 2 or 5 or 10?  Which ones?\n\n\nIf there are practitioners of Fortran who wish for faster standardization of Fortran language features now and/or have needs for inclusion of more items than that intended by J3 in the work-list for Fortran 202X, what does WG5 itself propose that can be pursued to address such a need?\n\n\nBottom-line: I am strongly inclined to pose the above basic but important questions and user needs with WG5 and give WG5 some space and time to respond, rather than develop any proposals or documents toward any plans or workflows at this stage."
                },
                {
                    "user": "certik",
                    "date": "2019-11-01 22:02:41+00:00",
                    "text": "From a practical perspective, I see only two separate issues:\n\n\nHow to make WG5 and J3 more efficient, and I think I know how: consider every submitted proposal, work between sessions, shorter the Fortran standard iteration, etc.\n\n\nGet compiler vendors up to speed with the standard. There I don't have many suggestions beyond the efforts already underway, such as MLIR that, if successful, would allow compiler vendors to reuse most of the machinery, and each vendor just has to maintain its own frontend.\n\n\nThe second point is very important, I agree that if compiler vendors can't keep up, then that's a problem."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-02 15:14:24+00:00",
                    "text": "From a practical perspective, I see only two separate issues:\n\nHow to make WG5 and J3 more efficient ..\nGet compiler vendors up to speed with the standard ..\n\n\nConsider the first issue, \"How to make WG5 and J3 more efficient\".  To be blunt and frank, gaining of a genuine acceptance among the top influencers on WG5 and J3 of such a need i.e., to be \"more efficient\" is in and of itself a HUUUGE challenge.  And it will only be by a broad consideration of Diversity (of thought in terms of needs of many coders) and concern toward Inclusivity of a wider group of Fortranners to ensure their voices are consistently and sufficiently represented that WG5 and J3 can come to support and embrace the approach to do more faster.  It is with this in mind the 10 or more questions like the ones upthread become important.  Without a discussion along such lines and contemplation toward the underlying, a focus on efficiency will entirely lack any passion nor gain any urgency - things will just remain the way they are and circular arguments will defeat any change.\nNote there is a certain mass of Fortranners in the \"national\" agencies and in other institutional areas and also certain sectors elsewhere for whom status quo is either \"just fine\" or who even question or oppose revisions beyond FORTRAN 77 (but use extensions) or Fortran 90 (but want some HPC features , or especially Fortran 95 (but want improvements to ALLOCATABLEs).  The needs of those in this \"camp\" are adequately met by the current situation.  So then one can argue why bother changing anything, things are good as they are.\nConsider ISO/IEC JTC1/SC22/WG23 - Programming Language Vulnerabilities and what they write about Fortran in their document: in their last section 8 Implications for standardization, their last sentence is, \"Identifying, deprecating, and replacing features whose use is problematic where there is a safer and clearer alternative in the modern revisions of the language or in current practice in other languages.\"\nIt is only when one is willing to look at Fortran language more broadly and by paying close attention to \"other\" coders (besides the institutional ones) and \"other\" languages more intently one can have the motivation and impetus to be \"more efficient\".   This is sorely missing at present with Fortran even if there is some superficial recognition of it."
                },
                {
                    "user": "certik",
                    "date": "2019-11-02 19:18:34+00:00",
                    "text": "I think it's ok to have a very high bar for new features, especially big features like OO programming, templates or exceptions. I have a very high bar myself. But what is not ok is not to consider popular proposals, and alternatively consider proposals that do not have wide support. I think we need the committee to seriously consider any high quality proposal that we will submit. With just that we should be able to get what we want, and the committee does not need to change much. Then we'll go from there."
                }
            ]
        },
        {
            "number": 25,
            "user": "cmacmackin",
            "date": "2019-10-19 19:57:40+00:00",
            "title": "Config variables to provide a CLI",
            "text": "This is a somewhat unusual feature request, but Cray's new parallel language Chapel has an interesting approach to providing a command line interface. The programmer can define \"config variables\" and these can be set by command-line flags when executing the program (or take a default value). Parameters can also be config, in which case they can be specified to the compiler, much like macro definitions to the preprocessor. I thought this was a really clever, simple way to program a CLI. In Fortran config could just be an attribute of a variable, giving a syntax along the lines of\nprogram hello_world\n  implicit none\n  integer, config :: n = 5\n  integer :: i\n  do i = 1, n\n    print*, \"Hello world\"\n  end do\nend program hello_world\nThen, at execution,\n./hello_world\n# Hello world\n# Hello world\n# Hello world\n# Hello world\n# Hello world\n\n./hello_world -n=2\n# Hello world\n# Hello world\n\nSome tricky issues to consider:\n\nHow to deal with array variables? Have the user pass in an array constructor on the CLI?\nShould the config attribute the allowed in any program unit or only in an actual program? (I don't see an issue with allowing them anywhere, but I may be missing something.)\nIf config variables are allowed in procedures or modules, presumably it should automatically confer the save attribute\nShould config parameters be allowed? I'd be inclined to support this but it would require the compiler to accept the values as command-line arguments.\nShould the config attribute be restricted to intrinsic types or could it be allowed for derived types as well? If so, how would these be set? Using the builtin constructor? What about component permissions, in that case?\nThere are some similarities between this concept and namelists, so perhaps it would be better to model this functionality on them.",
            "is_open": true,
            "labels": [
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-19 22:46:04+00:00",
                    "text": "@cmacmackin thanks for the issue, I think this is a great idea, I haven't thought of this before. Thanks also for being involved here, I think there many many excellent ideas out there, and we just need to organize ourselves to collaborate on good proposals.\nAnother thing to consider here is:\n\n\nHow would this feature interact with the user managing the command line arguments? In Python there are libraries to handle command line arguments. Should Fortran have language constructs to do so? (I think that in general yes, the Fortran way is that good features eventually become part of the language itself.)\n\n\nThis feature would probably benefit if it can be first implemented as part of some compiler, so that we can iron out the syntax and get some usage before proposing it.\n\n\nI want to be able to prototype features like these in LFortran, realistically I am probably 6 to 12 months away to be able to do that. And I am hoping that Flang and also hopefully GFortran could be used for prototyping, as ideally we really need two independent implementation of any major feature that goes into Fortran. Right now we are standardizing things without having a single implementation, and we need to fix that."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-19 23:31:32+00:00",
                    "text": "How would this feature interact with the user managing the command line arguments? In Python there are libraries to handle command line arguments. Should Fortran have language constructs to do so? (I think that in general yes, the Fortran way is that good features eventually become part of the language itself.)\n\nUsers would not be required to utilise this feature and the intrinsics like get_command_argument would still remain part of the standard. This would allow any existing CLI libraries to continue working if users prefer them. I can see some use cases where a library might be preferable:\n\nhandling positional arguments\nimplementing sub-commands\nautomatically produce output for the --help flag\n\nThe first two of these would, I think, be quite difficult to incorporate directly into the language via config variables. The second one, I think, would be impossible unless documentation comments were integrated into the standard, which would be a pretty major semantic change."
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 23:43:26+00:00",
                    "text": "What happens when you handle arguments yourself, and then use this config attribute?\n\nShould the compiler issue a warning?\n\u2026\nOn Sat, Oct 19, 2019, at 4:31 PM, Chris MacMackin wrote:\n >\n > How would this feature interact with the user managing the command line arguments? In Python there are libraries to handle command line arguments. Should Fortran have language constructs to do so? (I think that in general yes, the Fortran way is that good features eventually become part of the language itself.)\n\n Users would not be required to utilise this feature and the intrinsics like `get_command_argument` would still remain part of the standard. This would allow any existing CLI libraries to continue working if users prefer them. I can see some use cases where a library might be preferable:\n\n * handling positional arguments\n * implementing sub-commands\n * automatically produce output for the `--help` flag\n The first two of these would, I think, be quite difficult to incorporate directly into the language via `config` variables. The second one, I think, would be impossible unless documentation comments were integrated into the standard, which would be a pretty major semantic change.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#25?email_source=notifications&email_token=AAAFAWEYAQTTAWG46F6AR5LQPOKFJA5CNFSM4JCRHG7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBX6YAA#issuecomment-544205824>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWD26GEAZWEIW73VEXLQPOKFJANCNFSM4JCRHG7A>."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-19 23:53:31+00:00",
                    "text": "My instinct would be that this should not be required, although there'd be nothing to stop individual compiler vendors from doing so. The config variables are just a high-level way of handling the arguments but would not prevent you from using the older, low-level approach. As an example, if you are using a Python library such as argparse, you won't get any warning if you also use sys.argv."
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 23:55:15+00:00",
                    "text": "Ah I see --- the compiler can still set your n above automatically and you can still process the command line by hand. The only issue that I can see is error handling -- what happens if the user passes a string and not a number for n, or if the command line is malformed and the user uses the config approach."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-20 07:43:12+00:00",
                    "text": "I've checked the Chapel documentation and they don't actually say what happens if there is a type-mismatch. My suggestion would be that the value of the config variable is undefined in that case. Something like the following intrinsic subroutine could be added to check that read-in was successful:\nsubroutine check_config_status(var, status)\n    class(*), intent(in) :: var\n    integer, intent(out) :: status ! 0 if read-in successful, non-zero otherwise.\nend subroutine\nAlternatively, we could take the approach that all config variable hold their default values until the user calls some intrinsic subroutine to populate them. This could take optional status and message arguments. It would look something like this:\nsubroutine update_config_variables(error, message)\n    integer, intent(out), optional :: error ! 0 if read-in successful\n    character(len=:), allocatable, intent(out), optional :: message ! Message explaining cause of any error\nend subroutine\nThere is a question of whether this should set the variables globally, or only in a given scope. Restricting to a given scope would provide better modularity for any library routines, as they would work without depending on update_config_variables being called elsewhere. However, the feature I propose below to deal with malformed command lines would work best if they were set globally.\nMalformed command-lines would be a bit less clear of how to deal with but my suggestion would be an additional intrinsic which would return all command-line arguments which could not be parsed as config variables because they don't match any config variable names. It could look something like\nsubroutine get_nonconfig_command_arguments(list)\n    character(len=:), dimension(:), allocatable, intent(out) :: list\nend subroutine\n\nAlternatively, I suppose some new intrinsic derived type could be defined to return this information."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-20 20:32:04+00:00",
                    "text": "I've checked the Chapel documentation and they don't actually say what happens if there is a type-mismatch. My suggestion would be that the value of the config variable is undefined in that case. Something like the following intrinsic subroutine could be added to check that read-in was successful:\nsubroutine check_config_status(var, status)\n    class(*), intent(in) :: var\n    integer, intent(out) :: status ! 0 if read-in successful, non-zero otherwise.\nend subroutine\nAlternatively, we could take the approach that all config variable hold their default values until the user calls some intrinsic subroutine to populate them. This could take optional status and message arguments. It would look something like this:\nsubroutine update_config_variables(error, message)\n    integer, intent(out), optional :: error ! 0 if read-in successful\n    character(len=:), allocatable, intent(out), optional :: message ! Message explaining cause of any error\nend subroutine\nThere is a question of whether this should set the variables globally, or only in a given scope. Restricting to a given scope would provide better modularity for any library routines, as they would work without depending on update_config_variables being called elsewhere. However, the feature I propose below to deal with malformed command lines would work best if they were set globally.\nMalformed command-lines would be a bit less clear of how to deal with but my suggestion would be an additional intrinsic which would return all command-line arguments which could not be parsed as config variables because they don't match any config variable names. It could look something like\nsubroutine get_nonconfig_command_arguments(list)\n    character(len=:), dimension(:), allocatable, intent(out) :: list\nend subroutine\n\nAlternatively, I suppose some new intrinsic derived type could be defined to return this information."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-20 22:07:10+00:00",
                    "text": "There are (at least) 2 open source projects that attempt to handle this issue.\nFLAP: https://github.com/szaghi/FLAP\nand\nfArgParse:  https://github.com/Goddard-Fortran-Ecosystem/fArgParse\nPossibly I am a bit biased as the author of fArgParse, but I do have additional reasons to prefer it.   Namely, I am trying to build an entire ecosystem around containers from gFTL.       At the same time FLAP does have some functionality that I've not yet added to fArgParse."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-20 22:14:21+00:00",
                    "text": "Yes, I am aware that libraries exist for this and as such config variables are really just a \"nice to have\" feature and not a necessity in the way that (say) generic programming is. However, I do think they provide a simpler and quicker to use approach than the existing libraries."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-20 23:41:24+00:00",
                    "text": "I agree that something built-in would have several benefits, but my intuition is that an argument parsing facility itself is unlikely to rise particularly high in the priority list.    There would likely be more support for the \"config\" feature, as it would support many additional use cases.\nCurrently the thinking is that improved generics will simplify the development of containers in general.   And the \"config\" described here is merely a special case of a container.      There are various approaches to config implementation, and the committee may well be shy of committing to a particular approach.    E.g.,   one could have everything be strings and then require users to cast to other intrinsic types, or one could do something like YAML where certain \"obvious\" items are internally converted to logical, integer, and real.\nIf the committee does attempt to add direct support for containers, my guess would be that List and Map (ala C++ STL) would be higher priority than Config.   But those 2 containers would significantly reduce the difficulty in implementing Config."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-21 02:09:39+00:00",
                    "text": "I agree that something built-in would have several benefits, but my intuition is that an argument parsing facility itself is unlikely to rise particularly high in the priority list. There would likely be more support for the \"config\" feature, as it would support many additional use cases.\n..\n\nAlso, it's unclear how a \"config\"attribute can translate into a semantically secure and reasonably featured facility for a broad set of users.  The use case shown in the original post appears insufficient toward this.  If that's the need, the Fortran standard tacitly suggests the practitioners of Fortran to follow a rather VERBOSE approach with their own \"glue code\" or 'use' it from libraries (which is not unlike many other aspects involving Fortran) as shown below that may be of interest to other users of Fortran reading this issue.\nprogram hello_world\n\n   implicit none\n\n   integer :: n\n   integer :: i, istat\n\n   call get_n(n, istat)\n   if ( istat /= 0 ) then\n      print *, \"Unable to fetch the value of command argument n\"\n      stop\n   end if\n\n   do i = 1, n\n      print*, \"Hello world\"\n   end do\n\ncontains\n\n   subroutine get_n( nval, stat )\n\n      integer, intent(out)   :: nval\n      integer, intent(inout) :: stat\n\n      integer, parameter :: n_default = 5\n      character(len=256) :: cmd\n      integer :: narg, lenc\n\n      nval = n_default ; stat = 0\n\n      narg = command_argument_count()\n      if ( narg >= 1 ) then\n         call get_command_argument(1, cmd, lenc, stat)\n         if ( stat == 0 ) then\n            if ( lenc >= 4 ) then\n               ! N.B. assuming single-digit value of n\n               if ( cmd(1:3) == \"-n=\" ) read( cmd(4:4), \"(i1)\", iostat=stat ) nval\n            end if\n         end if\n      end if\n\n      return\n\n   end subroutine\n\nend program hello_world"
                }
            ]
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2019-10-19 01:45:09+00:00",
            "title": "Array of strings",
            "text": "A common request is to simplify how to do array of strings. Currently one option is this:\ntype string\n    character(:), allocatable :: s\nend type\n\ninteger, parameter :: N = 5\ntype(string) :: A(N)\ninteger :: i\ndo i = 1, N\n    A(i)%s = \"some string\"\nend do\ndo i = 1, N\n    print *, A(i)%s\nend do\nend\nIt might be worth considering if there should be some way in Fortran to do this directly without the derived type.",
            "is_open": true,
            "labels": [
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "tclune",
                    "date": "2019-10-20 22:12:48+00:00",
                    "text": "While I sympathize, the nature of Fortran arrays really does require that the elements all be the same type and with the same type parameters.    An unfortunate, but common, design pattern for Fortran is the \"wrap it\" so that you can treat it consistently with other types.    Here one is wrapping a string to support treatment in an array, but I've also wrapped arrays so that they can be treated with CLASS(*) in a consistent manner.\nFor the specific purpose at hand, you could consider the StringVector implementation from gFTL-Shared (https://github.com/Goddard-Fortran-Ecosystem/gFTL-shared)"
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 13:08:55+00:00",
                    "text": "Wouldn't it be enough if the Fortran Standard enforced a standardized derived type type(string) with hidden internals (similar to type(c_ptr))? With most of the the current string manipulation functionality provided as type bound procedures? Also including assignment and automatic handling by the print/write statements, so that your example becomes\ntype(string) :: A(N)\ninteger :: i\ndo i = 1, N\n    A(i) = \"some string\"\nend do\ndo i = 1, N\n    print *, A(i)\nend do\nend\n\nI guess, this should not require many changes. Edit descriptors may need additional thoughs, probably."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-21 21:30:44+00:00",
                    "text": "Wouldn't it be enough if the Fortran Standard enforced a standardized derived type type(string) with hidden internals (similar to type(c_ptr))?  ..\n\nIt will be really, really nice if the Fortran standard offered something INTRINSIC that is far more well-featured (e.g., arrays of strings with different lengths) and less verbose for coders than \"CHARACTER(LEN=:), ALLOCATABLE\" or its encapsulation in a derived type!!\nConverse to \"You had me at Hello\", the number of instances where \"You LOST me at CHARA..\" when it comes to someone new looking at Fortran and not liking it is quite long.\nIt's year 2019 after all, operations with \"STRINGS\" are so basic and intrinsic in programming, a coder should simply be able to do:\n   string :: s(2)\n   s = [ \"Hello\", \"World!\" ]\n   print *, s  ! prints Hello World!\n   call to_upper( s )\n   print *, s  ! prints HELLO WORLD!\nend\n\nand so forth either along the above lines or something similar.  As to how the \"string\" type is implemented in a processor -  whether as an intrinsic derived type or some other compiler \"magic\" - doesn't matter.\nThe thought process of steering the practitioners of Fortran toward a library solution for something as simple and fundamental as a STRING type appears a grave disservice, this should be a low hanging-fruit to offer to the coders.\nThe several available library solutions out there including toward the so-called \"Part 2\" of the standard with ISO_FORTRAN_STRING has long proven the use cases and the feasibility, the challenge now is mainly in standardizing the set of operations to be offered and their names e.g., 'push_back' or 'append'; 'remove' or 'replace', etc."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-10-21 23:11:59+00:00",
                    "text": "My preference would be an intrinsic string class, that has all the expected behavior of normal characters strings (assignment, s(1:3) slice notation, works with other intrinsic routines like read, write, etc.) Without these, it's just not very useful.\nBut... I don't want the committee to provide some small set of other routines (upper, lower, or whatever) and then not update them for 20 years. What if it was possible to allow the intrinsic type to be extended? That way the user community could develop a library that has everything anybody would need (e.g., regular expressions, parsers, ... things that would never be added by the Fortran standard).\nA bonus would be some sort of backward compatibility with character dummy arguments. But that may be asking too much."
                },
                {
                    "user": "certik",
                    "date": "2019-10-22 18:14:42+00:00",
                    "text": "One approach is to do something like std::string, which the C++ standard specifies (I think) and then just keep updating it if needed, just like C++ does:\nhttps://en.cppreference.com/w/cpp/string/basic_string\nYou can see some of the methods are since C++11, C++17, C++20, and so on.\nRelated to this is that I think Fortran needs to have a standard every 3 years, just like C++, precisely to prevent not updating a feature for 20 years. I opened a new issue for this at #36."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-28 14:28:50+00:00",
                    "text": "I agree that having a new intrinsic type STRING would be of considerable benefit.    Vendors are usually somewhat reluctant to make changes in the internal type system of their compiler, so there may be some debate about the benefits vs costs.    This is esp. true since a user defined type could give most of the benefits without changing the standard at all.  (Of course, I think I can still demonstrate compiler bugs with such wrappers on most extant compilers ...)\nFailing an intrinsic type, it would be good if we could establish an aux Fortran library for such things so that my String wrapper and your String wrapper are compatible.   My current approach to such things is to have very small GitHub projects for isolated capabilities, but a better solution might be a large collection of agreed-upon functionality.      Various groups have something along these lines, but we'd want to consolidate the effort under a single umbrella.  This would evolve faster than the standard but would still require some governance structure."
                },
                {
                    "user": "gronki",
                    "date": "2019-10-28 14:38:37+00:00",
                    "text": "Fortran derived types are not capable of what C++ or Python types are. And they were never designed to be that. So I would be against any suggestion such as \"implement strings/containers/.... by derived types\". Especially that Fortran character is pretty good as it is. Instead I think some more character manipulation functions, python-like str() and regex capability would be all one needs. Also handling them intrinsically by the Fortran library or using native libraries (in case of regex) would make it way more efficient than clunky Fortran implementation. Dominik"
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 15:02:18+00:00",
                    "text": "Yes, my suggestion of std::string was to have an intrinsic type string in Fortran, or simply improve the current character type to be able to do arrays of string and other things, not to have it as a library, due to the same reasons as @gronki sad.\n@tclune and I had long discussions of \"being part of the language\", versus \"a library as in C++ or Python\". For Fortran, I am in the \"part of the language\" camp, and Tom is more open to the \"library approach\"."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 18:44:59+00:00",
                    "text": "@gronki wrote:\n\nFortran derived types are not capable of what C++ or Python types are. And they were never designed to be that. ..\n\nI don't quite agree with this.\nBesides, Fortran has always granted certain allowances to intrinsics, whether types - basic/derived, statements, procedures,- that are not feasible with user written code.  Processors can then implement whatever \"magic\" they think appropriate behind the scenes to support the facilities.  Examples include generic intrinsic procedures, derived types for interoperability with C, etc.  Thus there is no reason why an intrinsic STRING type cannot be introduced featuring considerable benefits for the practitioners of the language, and which should be the overriding motivation, in a manner that might at first appear alien to a user derived types e.g., an inextensible, single-component only container type for a new intrinsic string type which offers an \"(x:y)\" operator which aren't possible today with user derived types!\nOn the other hand, the problem with CHARACTER type is it's really at the point of being immutable, any further change to it can adversely impact some compiler implementation or other.  The resistance to any change here will be great.\nBut also, there is the issue of ARRAY semantics in Fortran which, per its original design, calls for symmetry and shies away from jagged structures.  So this is yet another issue when it comes to user needs for arrays of strings.\nThus, the best compromise in my opinion is a new string type which builds on the capabilities of current CHARACTER type but also offers further benefits for coders."
                },
                {
                    "user": "tclune",
                    "date": "2019-10-28 19:22:44+00:00",
                    "text": "@certik To clarify:   \"in-the-compiler\" is generally better that \"in-a-library\", I'm sure we can all agree.   Rather the issue is that if you want everything in the compiler you are going to be disappointed many many times due to finite resources.\nThe number of developers that could/would contribute to an open library far exceeds those that can/will contribute to the standard and esp. any commercial compiler.    Perhaps, just perhaps, flang will emerge and create a thriving ecosystem of active branches of development of new (well thought out) features, but even then I don't think the basic balance will change much.\nSo, given the finite resources for making changes to the standard and the commercial compilers, I want to focus on things that fundamentally cannot be done with user code.     Of course there are grey areas, and I'm by no means an absolutist.     An intrinsic String type would likely rise to my 2nd tier of language priorities.   (2nd tier things often happen precisely because the 1st tier things are too hard/controversial.)"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 20:49:01+00:00",
                    "text": "@tclune wrote:\n\n..\nSo, given the finite resources for making changes to the standard and the commercial compilers, I want to focus on things that fundamentally cannot be done with user code. Of course there are grey areas, and I'm by no means an absolutist. An intrinsic String type would likely rise to my 2nd tier of language priorities. ..\n\nA point to keep in mind is what is needed to \"grease the wheel to make the sale\" i.e., to get Fortran considered even as an option for new projects or for refactoring of existing code-bases.  An intrinsic string type appears to fall under this category.\nBeing able to code \"string s = 'Hello World!'\" conveys certain sense of ease-of-use and modernity which is not quite measurable but which I think is priceless.  One just loses many a sharp mind at \"character(len=:), allocatable ..\".  One can then build many a \"field of dreams\" with coarrays (an enormous amount of committee resources were expended on it), etc. in Fortran, but \"they\" rarely come to experience any of that ..\nOne can accept the argument Fortran does not necessarily need to include as a top priority feature \"in the compiler\", say, containers of the likes of C++ STL like deques and priority_queues and unordered multimaps, etc.  A vision for Fortran to offer better intrinsic capabilities (e.g., generics) at some point so coders can \"home brew\" their own libraries toward such capabilities may be ok right now.\nBut with a string type, an intrinsic capability is badly needed for Fortran's credibility.  And it doesn't seem all that difficult, almost all the heavy-lifting was already done with Part 2 of the standard with ISO_FORTRAN_STRING.  Part 2 is now effectively gone.  It's mostly a matter of merging into Part 1 a modernized version of it.\nHowever if every item, no matter how well-established in programming parlance, becomes too difficult to get added to Fortran and requires endless discussions and iterations on use cases, requirements, specifications, and syntax, then perhaps it's time for someone to contact INCITS and \"pull the plug\" on Fortran."
                },
                {
                    "user": "gronki",
                    "date": "2019-10-28 21:04:46+00:00",
                    "text": "I wholeheartedly disagree. We will end up getting 100 clunky and\nincompatible implementations of string and list whereas there should be\nexactly one way to handle strings and one way to handle lists. Let me bring\nthe example of Python, where PyPi is a real world example of thriving\necosystem of user packages. Even though it is an extremely flexible\nlanguage (more than Fortran), the most essential types (string, file, list,\n...) are the basic types of the language. There is no way in Fortran to\nimplement a generic list, and there will be no such possibility before\nactual C++-like templates come (which is uncertain and not everyone even\nagrees about it). Implementing a linked list in compiler library is 1000\ntimes easier than templates that practically turn the whole language upside\ndown.\n\nI agree that character(len = :), allocatable ... is clunky and probably\nwould be easier aliased by just \"string\" (which is an easy thing to\nimplement as is just a matter of syntax), but when it comes to properties\nit's pretty damn good. You can cut it and concatenate on the fly. Python\nstrings are immutable too, same about Java. In Fortran we just lack the\nstandard utilities to manipulate them (format, regex, etc).\n\nI think community packages are great for solving particular complicated\nproblems, but when you need to install an user library to handle a list or\nstring, it shows -- as FortranFan said -- lack of language reliability and\ncredibility.\n\nDominik\n\npon., 28 pa\u017a 2019 o 20:22 Tom Clune <notifications@github.com> napisa\u0142(a):\n\u2026\n @certik <https://github.com/certik> To clarify: \"in-the-compiler\" is\n generally better that \"in-a-library\", I'm sure we can all agree. Rather the\n issue is that if you want everything in the compiler you are going to be\n disappointed many many times due to finite resources.\n\n The number of developers that could/would contribute to an open library\n far exceeds those that can/will contribute to the standard and esp. any\n commercial compiler. Perhaps, just perhaps, flang will emerge and create a\n thriving ecosystem of active branches of development of new (well thought\n out) features, but even then I don't think the basic balance will change\n much.\n\n So, given the finite resources for making changes to the standard and the\n commercial compilers, I want to focus on things that fundamentally cannot\n be done with user code. Of course there are grey areas, and I'm by no means\n an absolutist. An intrinsic String type would likely rise to my 2nd tier of\n language priorities. (2nd tier things often happen precisely because the\n 1st tier things are too hard/controversial.)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#24?email_source=notifications&email_token=AC4NA3IYYDGZXX62BEIGHJDQQ43YLA5CNFSM4JCNV2LKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECOC4BY#issuecomment-547106311>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3IP53JFRUMU7ZJWKKTQQ43YLANCNFSM4JCNV2LA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 21:26:31+00:00",
                    "text": "@gronki I think you have a point --- as an example, C++ is a language that has much better features than Fortran to develop libraries for basic things. And so they do not have an array in the language (the idea was that C++ allows enough abstraction to implement your own), and as a result, C++ has dozens of arrays libraries, all incompatible with each other.\nThey do have std::string, implemented in a library, but this library is the C++ standard library. So we could have a Fortran standard library, so that things like strings and lists are all compatible. But at that point it must still be standardized, and so we might as well have it in the language itself.\nHowever, I do agree with @tclune's point that it is by far easier to create a library than to get something in the language."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-24 14:42:14+00:00",
                    "text": "@certik should we continue to discuss a potential intrinsic string class here, or make a new issue specifically for that? That would solve the array of strings issue, but really it's a more general topic that touches on other issues."
                },
                {
                    "user": "certik",
                    "date": "2019-11-24 19:43:11+00:00",
                    "text": "Let's create a new issue for it. I agree a string type is more general.\n\u2026\nOn Sun, Nov 24, 2019, at 7:42 AM, Jacob Williams wrote:\n @certik <https://github.com/certik> should we continue to discuss a\n potential intrinsic string class here, or make a new issue specifically\n for that? That would solve the array of strings issue, but really it's\n a more general topic that touches on other issues.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#24?email_source=notifications&email_token=AAAFAWCVJXPSGSU56FDJXKDQVKHEPA5CNFSM4JCNV2LKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEFAM3FI#issuecomment-557895061>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWC5O6MMZ6R33VGMTTDQVKHEPANCNFSM4JCNV2LA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2019-12-27 20:09:28+00:00",
                    "text": "I ended up implementing my own version of the ISO_VARYING_STRING module for a couple of reasons. gfortran still hasn't implemented it, even though it's been in the standard for quite a while now (I don't know that any other compiler has either). I hadn't seen a particularly complete, well tested, or well written version. There are significant bugs in most implementations of allocatable characters, not the least of which is that you still can't put them in an array even if they weren't buggy.\nI was under the impression that since ISO_VARYING_STRING had been approved, it was the right way to move forward. If you use a standards compliant version, if anybody ever does actually implement it in the compiler, you won't have to change any of your code, the external library will just become unnecessary. I also thought that standard covered all of the intrinsic procedures accepting or returning characters, and any additional procedures that were truly necessary.\nGranted, not every string functionality one would want is included, but that's what libraries are for."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-10 11:34:50+00:00",
                    "text": "Failing an intrinsic type, it would be good if we could establish an aux Fortran library for such things so that my String wrapper and your String wrapper are compatible.\n\nHey @tclune, we have tried to make something along these lines over at the stdlib repository. For the start we converged to a non-extensible string_type (similar to the iso_varying_string) that can be used easily in an array of strings and supports all of the intrinsic character functions (the definition of the type is in the file stdlib_string_type.f90).\nAs a second step, @awvwgk provided a demonstration of an abstract base class (ABC) for a string object, already demonstrating wrappers to ftlString and StringiFor based upon the ABC.\nSome discussions related to the (problems of the) ABC are in:\n\nfortran-lang/stdlib#69 (comment)\nfortran-lang/stdlib#334\n\nI don't think we can get much further than this within the scope of the current standard."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-27 18:05:50+00:00",
                    "text": "I was under the impression that since ISO_VARYING_STRING had been approved, it was the right way to move forward. If you use a standards compliant version, if anybody ever does actually implement it in the compiler, you won't have to change any of your code, the external library will just become unnecessary.\n\nAs I understand, the ISO_VARYING_STRING was withdrawn, see https://www.iso.org/standard/6129.html. I'm not sure if dropping the ISO prefix would cause more or less confusion at this point."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-27 18:45:32+00:00",
                    "text": "I was under the impression that since ISO_VARYING_STRING had been approved, it was the right way to move forward. If you use a standards compliant version, if anybody ever does actually implement it in the compiler, you won't have to change any of your code, the external library will just become unnecessary.\n\nAs I understand, the ISO_VARYING_STRING was withdrawn, see https://www.iso.org/standard/6129.html. I'm not sure if dropping the ISO prefix would cause more or less confusion at this point.\n\nYes, it was withdrawn, but I didn't know that at the time. I'm still a fan of the specification, even if it isn't in the standard. IMO, it's proven itself to be quite useful."
                },
                {
                    "user": "ivan-pi",
                    "date": "2021-04-27 19:19:49+00:00",
                    "text": "This would be great for a blog post, looking at the story of this module, and doing some comparisons with the string_type currently in stdlib."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2021-04-27 20:55:36+00:00",
                    "text": "That's a good suggestion. I've got lots going on, but hopefully I can get to it before too long."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-08 05:41:24+00:00",
                    "text": "I really don't understand the efforts of implementing a new string type. The current (allocatable) strings are rather flexible and serves at least my purposes very well.\nWhat is missing IMHO is a list type that can be used as a collection of arbitrary types. Strings of different length could be simply put in a list. That's how it is done in Python, where the a numpy string array is be also limited to strings of the same length."
                },
                {
                    "user": "tclune",
                    "date": "2021-06-08 12:37:14+00:00",
                    "text": "I've not followed this thread closely, but I think the distinction is that a proper String would encapsulate the allocatable aspect.  Without that any attempt to define something like a list would require a wrapper type due to Fortran's quirky syntax in this regard.  I.e., a list of Strings would be a virtually identical implementation to a list of Integers.  While a list of deferred length CHARACTER(len=:), ALLOCATABLE  would require a wrapper type and lots of boiler plate logic for diving down the extra level in the data structure."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-08 13:22:20+00:00",
                    "text": "@tclune: If you neglect that you need to define the type, string handling is not much different from python:\nprogram test_string\n\n  character(len=:), allocatable :: string\n\n  string = 'hello world'\n  print*, len(string)\n\n  string = string//', hello Github'\n  print*, len(string)\n\n  print*, string(14:)\n\n  string = ''\n  print*, len(string)\n\n  string = ' '\n  print*, len(string)\n\nend program test_string\n\n#/usr/bin/env python3\n\nstring = 'hello world'\nprint(len(string))\n\nstring = 'hello world'+', hello Github'\nprint(len(string))\n\nprint(string[13:])\n\nstring = ''\nprint(len(string))\n\nstring = ' '\nprint(len(string))\nThe boiler plate comes in when you want to define a collection of strings, but IMHO this is due to the lack of a list type that can contain arbitrary types/kinds."
                },
                {
                    "user": "tclune",
                    "date": "2021-06-08 16:44:22+00:00",
                    "text": "Introducing such generic programming capabilities is my highest priority, and the primary reason I joined the Fortran committee in the first place.   And the ability to use that for containers is my most important use case.\nI don't want to overpromise on the schedule, and there are of course risks that such a big feature can fail to get the necessary votes."
                },
                {
                    "user": "tclune",
                    "date": "2021-06-08 17:58:49+00:00",
                    "text": "It also may be worth pointing out that even if Fortran were to introduce something like a List container that can contain \"anything\" it would be a bit difficult to use.    The dynamic typing in languages like Python significantly improves the usability of such a structure.\nFor instance, suppose we want to retrieve the 5th element from a list L and store it in a variable x.    How should we declare x?   The type of the 5th element cannot be known at compile time, so even if we \"know\" that it will be of type real and we do:\nreal :: x\n...\nx = L(5)\nHow does the compiler check that the types agree?    What should it do if the types do not agree at run time?\nYou might respond that CLASS(*) is the right thing in such a context and we would do:\nclass(*), pointer :: x\n...\nx => L(5)\nThat can work (with some less interesting caveats), but ... x is not very useful here.  We can't really do much else with it without an ugly (IMO)  SELECT TYPE block.\nBasically any attempt to make containers as incredibly flexible as they are in Python, will be very problematic in Fortran.   C++ STL is probably a safer guide to what can work in Fortran.   It does allow lists of void pointers, but requires casting.  Most STL containers are declared for specific types."
                },
                {
                    "user": "MarDiehl",
                    "date": "2021-06-08 18:55:32+00:00",
                    "text": "Static typing clearly results in these constraints. SELECT TYPE is the price you need to pay if you don't want to give the programmer the responsibility (or freedom, depends on perspective) to cast to the correct type.\nI'm not very familiar with C+ STL, but to me it seems like a 'typed list'. A list of type class(*) would be then just one possibility of using this feature.\nI don't know what STL is usually used for, but from my python experience a list usually contains similar things. So I expect that a STL-like container will rarely result in long SELECT TYPE statements."
                },
                {
                    "user": "tclune",
                    "date": "2021-06-08 19:21:13+00:00",
                    "text": "Yes - that was what I was trying to say ...    Usual cases involve concrete types or pointers to base types if polymorphism is desired.   But even then C++ STL has the same memory footprint for each object, and does not readily handle items of variable size.      This allows direct computation of memory offsets ala how Fortran manages array indexing.\nOne gets around that for say varying length strings, by having a standard string template that effectively creates a wrapper type that has an allocatable character array inside.  Which gets back to what the original discussion was requesting, if I understood.   Whether Fortran accomplishes this with the new generics facility or does something special just for the case of strings, is a useful topic.   My hope is that the former is powerful enough to obviate the need for the latter.   But early days ..."
                },
                {
                    "user": "gronki",
                    "date": "2021-06-16 18:40:10+00:00",
                    "text": "I would actually not agree, introducing features of the language just so\nthat you can implement a object to represent a thing you actually need is\nwhat c++ does. I would suggest to just use C++ for such projects. Fortran\ndoes not allow much of an encapsulation or efficient OOP, it will not for\nmany more years and it doesn't even need to, so I would argue it's far from\noptimal route and it would be much better to have built in types for\ncontainers, just like allocatable character provides a good enough string\nfunctionality. Not to dismiss any efforts in creating user space libraries,\nit's awesome that the community takes the initiative on where the standard\nis lacking and far behind, but my personal preference is to use what is\nalready in the language, mostly because it just works. Fortran is not a\nflexible language like C++ because it's user target is different. I think\nthat introducing a couple of popular data structures and routines that\nwould be very well optimized by a compiler under the hood seems like much\ncloser to what Fortran aims at. Python is much more flexible than Fortran\nyet it does have data structures built in without the need to reinvent the\nwheel.\n\nJust my opinion!\nWishing you all good health\nDominik\n\nwt., 8 cze 2021, 18:25 u\u017cytkownik Peter Klausler ***@***.***>\nnapisa\u0142:\n\u2026\n I really don't understand the efforts of implementing a new string type.\n The current (allocatable) strings are rather flexible and serves at least\n my purposes very well.\n What is missing IMHO is a list type that can be used as a collection of\n arbitrary types. Strings of different length could be simply put in a list.\n That's how it is done in Python, where the a numpy string array is be also\n limited to strings of the same length.\n\n Instead of adding lists, maps, sets, &c. to Fortran, the language really\n needs the basic generic programming capabilities other languages have had\n since the 80's with which such data structures can be easily built. Maybe\n in this decade that will happen in the standard language, and then\n implementations will follow in the decade after.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#24 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3IWGHOUDNHBAYDDYE3TRZABBANCNFSM4JCNV2LA>\n ."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2019-10-18 22:27:58+00:00",
            "title": "Update the text in README",
            "text": "Let me know if you like the wording.",
            "is_open": false,
            "labels": [],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-21 18:36:15+00:00",
                    "text": "Thanks for the review, merging."
                }
            ]
        },
        {
            "number": 22,
            "user": "milancurcic",
            "date": "2019-10-18 21:30:45+00:00",
            "title": "Allow setting default value for optional dummy argument",
            "text": "Problem\nCurrently, Fortran doesn't allow setting a default value for optional dummy arguments. If declaring a dummy argument as optional, the user must:\n\nManually make appropriate checks about whether the actual argument is provided by the caller;\nUse a separate variable inside the procedure because the code must not reference the optional dummy argument if not present.\n\nExample\nExample of a quadratic function that optionally allows evaluation of its linear form:\nreal function quadratic(x, a, b, c)  \n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional :: c\n  real :: c_tmp ! use separate variable to avoid referencing non-present arg\n  if (present(c)) then\n    c_tmp = c\n  else\n    c_tmp = 0 ! default value if c is not present\n  end if\n  quadratic = a + b * x + c_tmp * x**2\nend function quadratic\nChecking for presence of the optional argument and using a temporary variable is cumbersome and error-prone, and it is even more so if the same needs to be done for many optional arguments.\nSolution\nAllow setting the default value of the optional argument in the function (or subroutine) statement by using the assignment operator =:\nreal function quadratic(x, a, b, c=0)\n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional :: c\n  quadratic = a + b * x + c * x**2\nend function quadratic\nThis is similar to how Python keyword arguments are defined.\nComments\n\nThe proposed syntax is complementary to the existing syntax, that is, it doesn't break existing code;\nIts style is more or less Fortranic and consistent with other syntax elements;\nSame syntax as Python keyword args, so it would be intuitive to Python developers learning Fortran;\nCould be implemented completely as a pre-processor, for a proof-of-concept.",
            "is_open": true,
            "labels": [
                "under consideration",
                "Fortran 202y",
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 21:38:49+00:00",
                    "text": "Yes, great idea. I usually do it like this:\nreal function quadratic(x, a, b, c)  \n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional :: c\n  real :: c_\n  c_ = 0\n  if (present(c)) c_ = c\n  quadratic = a + b * x + c_ * x**2\nend function quadratic\nWhich is simpler than your original code, but it's still cumbersome to always introduce the local variable and do the present(c) check.\nDoes Fortran support default non-optional arguments? My only suggestion would be to perhaps introduce default values for any arguments, not just optional."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-18 21:42:14+00:00",
                    "text": "What is the meaning of default non-optional arguments? If an argument is required, where does its default value come into play?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 21:43:19+00:00",
                    "text": "What is the meaning of default non-optional arguments? If an argument is required, where does its default value come into play?\n\nMy bad, I think you are right. It only makes sense for optional arguments."
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 21:44:07+00:00",
                    "text": "The other suggestion I have is that in Fortran one specifies all argument things in the declaration, not in the argument list so perhaps something like this:\nreal function quadratic(x, a, b, c)\n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional, default :: c = 0\n  quadratic = a + b * x + c * x**2\nend function quadratic\nWould be more consistent with Fortran conventions.\nThe new default attribute would specify that the = 0 does not imply the save attribute. The default attribute can then be used with any variable, not just arguments, like this:\ninteger, default :: n = 5\nPerhaps one could use init, or initialize instead of default."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-18 21:45:56+00:00",
                    "text": "I like the default attribute. Less Pythonic, but more Fortranic for sure.\nOf course, I had to use the more verbose variant to better sell the proposal. :D"
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 21:49:56+00:00",
                    "text": "I like the default attribute. Less Pythonic, but more Fortranic for sure.\n\nThe proposal can have both options, and the community and committee can discuss pros and cons of both, and then pick one.\n\nOf course, I had to use the more verbose variant to better sell the proposal. :D\n\nI would suggest you change it to the shorter version, as we want to compare against the best current practice, not a longer variant."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-18 21:50:50+00:00",
                    "text": "I'd be happy to prepare the first draft of the proposal, and you can take it from there. Does target for meeting #221 (February 2020) make sense?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 21:53:09+00:00",
                    "text": "I'd be happy to prepare the first draft of the proposal, and you can take it from there. Does target for meeting #221 (February 2020) make sense?\n\nYes! The October Committee Meeting ended, and what I would like to do differently than what the committee has been doing so far, is to prepare a very good proposal collaboratively on GitHub. Send a PR once you have a draft, let's work on it together and with others. And then once a good initial proposal is ready, I'll pitch it to the j3-members committee mailinglist, to get feedback from the committee, and that way we have a very solid proposal when the committee meets the next time and we'll take it from there. Finally, I would reiterate my invitation for you to join the committee. We need help."
                },
                {
                    "user": "certik",
                    "date": "2020-01-03 22:58:26+00:00",
                    "text": "This should be implemented in the language. It's a simple change and it would go a long way. In the meantime, we will implement a helper function in stdlib: fortran-lang/stdlib#62, here is a preliminary implementation: fortran-lang/stdlib#73. The above example would look:\nreal function quadratic(x, a, b, c)  \n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional :: c\n  real :: c_\n  c_ = optval(c, 0.)\n  quadratic = a + b * x + c_ * x**2\nend function quadratic\nWhich is not bad, but not as nice as having it in the language:\nreal function quadratic(x, a, b, c)\n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional, default :: c = 0\n  quadratic = a + b * x + c * x**2\nend function quadratic\nNote: in this particular case, since we need c exactly once, one can simplify it with stdlib to just:\nreal function quadratic(x, a, b, c)  \n  ! returns a + b * x + c * x**2 if c is present and a + b * x otherwise\n  real, intent(in) :: x, a, b\n  real, intent(in), optional :: c\n  quadratic = a + b * x + optval(c, 0.) * x**2\nend function quadratic\nbut this does not work well if c is needed more than once."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-05 15:28:41+00:00",
                    "text": "This proposal got some votes in the user survey for 202X, and it is one I personally like. It appeared on Data subgroup's wishlist at meeting 215 (see https://j3-fortran.org/doc/year/18/18-122r1.txt) https://j3-fortran.org/doc/year/18/18-136r1.txt with \"use cases\" was passed at meeting 216, but it didn't make it onto the \"official\" US request list - it's not clear to me if this was an oversight or the lack of a formal proposal. In either case, I would support this for 202Y."
                },
                {
                    "user": "zbeekman",
                    "date": "2020-01-06 17:56:24+00:00",
                    "text": "I too support this."
                },
                {
                    "user": "certik",
                    "date": "2020-01-06 19:26:48+00:00",
                    "text": "Ok, let's write a good proposal for this and submit for the February meeting (#122) to get initial feedback from the committee. As indicated at #122, the following people listed this proposal in their top 5:\n@milancurcic, @epagone, @zjibben, @qolin1. The following people mentioned it that they like it to be pursued: @jvdp1, @marshallward. And there are people who expressed support here directly, such as @zbeekman and others who liked the issue.\n@milancurcic would you be able to take a lead on writing a proposal for this? The others listed in this comment, if you could help Milan write it, that would be very helpful. (I'll try to help too, but there are other proposals that I want to help with also.)"
                },
                {
                    "user": "qolin1",
                    "date": "2020-01-07 16:08:18+00:00",
                    "text": "Yes I am in.\nWhile we are here, I have some questions & comments...\nFirstly, why should the DEFAULT keyword be needed? Seems to me that the mere presence of an equated value after the variable name will be sufficient, as in:\nreal function quadratic(x, a, b, c)\n! returns a + b * x + c * x2 if c is present and a + b * x otherwise\nreal, intent(in) :: x, a, b\nreal, intent(in), optional :: c = 0\nquadratic = a + b * x + c * x2\nend function quadratic\n\nAs far as I am aware, there is currently no way the language will allow an equated value for a variable declared as a dummy argument, so this seems sufficient to me. Also, providing a new keyword like DEFAULT might mislead folk into trying to put it on non-optional arguments and other (local variable) declarations. (If the intention is to distinguish this from the implicit save problem, then the name DEFAULT is not a good one, because it doesn't really mean \"do not save\". And I think we should keep this proposal well clear of any argument about implicit save.) Also also, when 2 or more arguments are declared in one statement, we would not wish to require them all to be given a default value, or none of them; this would be the implication of the presence of the DEFAULT keyword.\nSecond: do we allow the default value to change a simple variable into an array? Eg:\nSubroutine fred(a,b)\nreal, intent(in) :: a\nreal, intent(in), optional :: b = [1d0,2d0]\n\nNote that, absent the default, there is nothing in the declaration of B that makes it an array. IMO this should not be allowed, explicit shape information or the DIMENSION keyword should be required.\nThird: should the feature work for UDTs? Eg:\n\ntype t_stuff\nreal :: a = 22\nreal :: b = 33\nreal :: c = 44\nend type\nsubroutine uu(ff, st)\nreal, intent(in) :: ff\nreal, optional :: st = t_stuff(66,c=88)\n\n\nFourth: should it work on an OPTIONAL statement? eg:\nSubroutine fred(a,b)\nreal, intent(in) :: a, b\noptional :: b = [1d0,2d0]\n\nFifth: what about allocatables? eg:\nSubroutine fred(a,b)\nreal, intent(in) :: a\nreal, intent(in), allocatable, optional :: b(:) = [1d0,2d0]\n\nThis creates a default allocated array with 2 elements. I can't, however, see an obvious way to get an unallocated array as a default. Maybe it could be done by combining with the next one...\nSixth: should it allow initialization to a non-constant expression? eg:\nmodule jimmy\nreal :: ddd(100)\nend module\n! ...lots of lines of code later, after ddd has been set\nsubroutine billy(aaa,bbb)\nuse jimmy\nreal, intent(inout) :: aaa(20)\nreal, intent(inout), optional :: bbb(:) = ddd\n\n\n...That's probably more than enough for the moment."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-07 16:13:35+00:00",
                    "text": "@milancurcic would you be able to take a lead on writing a proposal for this? The others listed in this comment, if you could help Milan write it, that would be very helpful. (I'll try to help too, but there are other proposals that I want to help with also.)\n\nSure, I will submit an initial draft in a PR later this week and we can iterate on it together."
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 16:46:52+00:00",
                    "text": "@qolin1 thanks a lot for the feedback. Excellent ideas. Here are my comments.\n\nI think you are right, we don't need the default. Yes, I put it there to ensure no save, but as you said, the save would not be implied in this case anyway. I really like just this, exactly as you suggested:\n\nreal function quadratic(x, a, b, c)\n! returns a + b * x + c * x2 if c is present and a + b * x otherwise\nreal, intent(in) :: x, a, b\nreal, intent(in), optional :: c = 0\nquadratic = a + b * x + c * x2\nend function quadratic\n\n\nNo.\n\n\nYes.\n\n\nYes. I didn't even know about an optional statement.\n\n\nYes.\n\n\nI would say to start with requiring the expression to be constant. We can brainstorm if it makes sense for it to be variable. It seems it could create more confusion than it is worth it."
                },
                {
                    "user": "epagone",
                    "date": "2020-01-07 18:15:55+00:00",
                    "text": "@qolin1 these are my thoughts.\n\n\nI agree with you and @certik on this one but I already hear the objection that the same syntax in different scoping units meaning different things (i.e. implicit save in some contexts and optional default values in this case) should not be allowed. My best reply would be to deprecate in parallel implicit save with proposal #40. However, this carries the risk that if #40 is shot down, then also this one can be refused, so maybe a better strategy to respond to this objection must be thought...\n\n\nShould not be allowed, as you suggest.\n\n\nYes.\n\n\nYes.\n\n\nI don't fully understand what is the problem you're discussing here. I think\n\n\nSubroutine fred(a,b)\nreal, intent(in) :: a\nreal, intent(in), allocatable, optional :: b(:) = [1d0,2d0]\nshould be allowed with b allocated by default to [1d0,2d0] but it would be possible to set in subroutine fred b = [1d0,2d0,3d0,4d0,5d0] (i.e. fixed shape but any size, since b is an allocatable array).\n\nI understand @certik 's concerns about this but I think it should be allowed."
                },
                {
                    "user": "certik",
                    "date": "2020-01-07 18:23:54+00:00",
                    "text": "Regarding 1.: Note that, as I mention in #40, that \"One can apparently use integer :: a, b, c = 2 in the main program, in module variable and in derived types already, and it will not imply save.\" So this proposal #22 just adds another case: \"in optional arguments it will also not imply save\". So it's not unprecedented even if #40 is not (immediately) accepted.\nP.S. @milancurcic make sure you use this argument in the proposal."
                },
                {
                    "user": "epagone",
                    "date": "2020-01-07 18:29:36+00:00",
                    "text": "@certik I was looking for the fingers crossed emoji to be added next to the thumb up as a reaction to your post, but it's not available on GitHub... \ud83d\ude1c"
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-07 19:47:57+00:00",
                    "text": "Any proposal should specify whether the default value may be a specification expression or must be a constant expression. The latter would be consistent with initialization, but the former would be more useful. Note that the rules for specification expressions already prohibit an object designator with OPTIONAL or INTENT(OUT).\nSince a default value would be allowed only for optional arguments, that implies an explicit interface requirement."
                },
                {
                    "user": "qolin1",
                    "date": "2020-01-07 20:36:46+00:00",
                    "text": "Um Steve, Please clarify for us what is meant by an \"object designator\". If we have an example default initialization such as:\nreal, intent(out), optional :: aa = b+c*d\nMy understanding is that b, c and d are object designators, but aa is not. Please correct me."
                },
                {
                    "user": "sblionel",
                    "date": "2020-01-07 20:45:01+00:00",
                    "text": "Sorry, was quoting the standard regarding specification expressions. In your example, b, c and d are the object designators in question. The issue is what is allowed to appear in the default value expression. If it's a specification expression, it can reference things such as other dummy arguments and module variables. If it's a constant expression, it is restricted to only those things that can be evaluated at compile-time, which is the case for initialization. (Indeed these used to be called \"initialization expressions\".)\nThe more details worked out in advance for a proposal, the better chance it has to move forward. One can even propose edits (ideally including complete new wording to make it easier to understand and read.)\nWhat I envision for this is that the caller could evaluate and pass the default values, since it already needs to know how to do this for some specification expressions."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-23 18:05:40+00:00",
                    "text": "The proposal is now submitted:\nhttps://j3-fortran.org/doc/year/20/20-107.txt\nThank you all and especially @milancurcic and @jvdp1 for kicking off the proposal!"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-23 18:19:13+00:00",
                    "text": "Thank you all for pushing it through!\n\u2026\nOn Sun, Feb 23, 2020, 1:05 PM Zach Jibben ***@***.***> wrote:\n The proposal is now submitted:\n\n https://j3-fortran.org/doc/year/20/20-107.txt\n\n Thank you all and especially @milancurcic <https://github.com/milancurcic>\n and @jvdp1 <https://github.com/jvdp1> for kicking off the proposal!\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#22?email_source=notifications&email_token=AA7RDPUTA5BA3CY6I5XYO3DREK3HNA5CNFSM4JCMOXG2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEMWC4JA#issuecomment-590097956>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AA7RDPSLGCH7LLOVSL2F77LREK3HNANCNFSM4JCMOXGQ>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-02-26 18:15:09+00:00",
                    "text": "This proposal was discussed on Tuesday Feb 25 in the morning, I set the timer for 5 minutes, @zjibben gave an overview for about 3 minutes and then we discussed for about 20 minutes at the plenary. We took notes of the feedback and I summarized it below.\nOverall, we got excellent highly detailed feedback, and I would say the committee was generally positive about the idea. The approach suggested might not work directly, but the committee suggested an alternative approach that might work. Also lots of details must be figured out and fleshed out, and the proposal must be rewritten / improved accordingly.\nHere is the detailed feedback. I tried to summarize it first, but not all the comments are necessarily consistent, so I simply present the comments:\n\nwhat if the optional argument has the TARGET attribute?\nconsider VOLATILE and ASYNCHRONOUS attributes of dummy arguments\nconcerns with the paper\n\nsyntax: doesn't like assignment form\nconsider other syntax using keywords e.g., DEFAULT (0)\nPRESENT should continue to work\n\n\nretain semantics in chain of\n\nINTENT IN, OUT same semantics?\npaper needs to be rewritten\n\n\nfeature with no applicability\n\nachieves little for the complexibility\nadds no new capability\nadding new ATTRIBUTE e.g., DEFAULT rather than OPTIONAL\n\n\nretain PRESENT semantics\n\nconditional expressions proposal offers option here with reducing code\nverbosity\n\n\nPRESENT semantics must be retained\n\nthis paper has a lot of appeal to coders\n\n\nconcerns with the paper\n\nassignment (=) syntax a non-starter, makes it more confusing\nPRESENT semantics if retained this paper will add little value\nHowever it's too risky to change PRESENT\nnested subroutines with OPTIONAL will become confusing e.g., 4 levels lose track of what is actually present\nThe proposal for Fortran 202X had also failed because impact on PRESENT semantics was unclear\n\n\npushes responsibility on the compiler to introduce the equivalent of\nlocal temp variable, can impact performance\nidea:\n\ncaller provides default\nagrees on the DEFAULT\n\n\ncomments:\n\nuse cases can be supported by VALUE attribute\nbut most other committee members disagreed stating VALUE semantics has other implications\nsuch as copy-in, copy-out\n\n\n\nTo summarize, the issue is that we do not want to change the behavior of present(). But then the issue is that it becomes really complicated if the user provides the value high in the call chain, then the nested subroutines might change how they behave, thus potentially creating performance bottlenecks.\nThe best way forward seems to be not to tie the default value with optional arguments. Rather, to introduce \u201cinitial\u201d (or \u201cdefault\u201d) attribute that can be applied to both local variables, as well as dummy variables. If applied to dummy variables, it would have no change in the subroutine itself --- the dummy argument would always be provided. However, at the call site, the compiler would put in the default value if the user does not provide it. That way there is no performance hit, and from the user perspective it achieves the same."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-26 18:37:07+00:00",
                    "text": "Amazing, this is great feedback, I didn't expect that we'd get this much. Thanks @certik and @zjibben.\nI think we can work with this. I will take some time to digest and write what I think."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-26 19:16:34+00:00",
                    "text": "Thanks for polishing the notes and posting @certik!"
                },
                {
                    "user": "certik",
                    "date": "2020-02-26 19:59:37+00:00",
                    "text": "@milancurcic indeed, it went really well. We have done another one (#1) today, and in general I think we will be doing this from now on. So this is a great avenue how to have a discussion with the wider community and how the community can propose ideas for the language."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-02-26 20:26:38+00:00",
                    "text": "Thanks @certik and @zjibben for presenting and leading the discussion, and reporting back the discussion. It is really encouraging."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-10 20:25:29+00:00",
                    "text": "I have written a revision of the paper by @milancurcic, @jvdp1, and @zjibben that attempts to address most of the issues raised at the Feb. 25 meeting, and a few other issues that have come to my mind. The paper differs from the original primarily by:\n\n\nRestricting optional arguments to arguments with the INTENT(IN), VALUE, or no intent attributes.\n\n\nRequiring arguments with a default assignment to be explicitly given the DEFAULT attribute.\n\n\nForbidding arguments from having both the DEFAULT and OPTIONAL attributes so that the PRESENT function retains its semantics.\n\n\nAllowing the expression on the right of the default assignment be a restricted expression and not just a constant expression.\n\n\nStrongly encouraging that the default assignment be in the FUNCTION or SUBROUTINE statement (and not the TYPE declaration statement) as probably being easier to parse.\n\n\nDiscussing the implications of the constraints on intrinsic assignment, 10.2.1.2, their interpretation, 10.2.1.3, and the constraints on defined assignment, 10.2.1.4, and their interpretation, 10.2.1.5 on default array assignments.\n\n\nBriefly discussing the implications of an argument with the DEFAULT attribute also having any one of the POINTER, VOLATILE, ASYNCHRONOUS, or TARGET attributes."
                },
                {
                    "user": "sblionel",
                    "date": "2020-07-10 20:38:15+00:00",
                    "text": "This sounds great - when can we see the paper? The changes you propose are all those I support."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-10 20:45:03+00:00",
                    "text": "I am a novice to GitHub. The introductory material on GitHub does a good job of telling me how to start my own project, but not how to participate in someone else's project. What steps do I need to take to upload the paper named revised_proposal.txt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-10 21:05:28+00:00",
                    "text": "William, great. If you navigate here:\nhttps://github.com/j3-fortran/fortran_proposals/blob/master/proposals/default_optional_arguments/proposal.txt\nIn the upper right corner of the UI there is an \"Edit\" button. If you click on it, it will take you to an editor which you can use to replace the existing paper with yours. Submitting the change will open a new Pull Request in which we will then discuss and edit the revised version.\nThe above flow assumes that we edit existing proposal txt files. @certik @zjibben should we instead keep the old versions as separate files and add the new one in its own file (like J3 does)?"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-10 21:10:12+00:00",
                    "text": "FWIW I named my version revised_proposl.txt in the expectation that we would retain original, proposal.txt, for the records.\n\u2026\n On Jul 10, 2020, at 3:05 PM, Milan Curcic ***@***.***> wrote:\n\n\n William, great. If you navigate here:\n\n https://github.com/j3-fortran/fortran_proposals/blob/master/proposals/default_optional_arguments/proposal.txt <https://github.com/j3-fortran/fortran_proposals/blob/master/proposals/default_optional_arguments/proposal.txt>\n In the upper right corner of the UI there is an \"Edit\" button. If you click on it, it will take you to an editor which you can use to replace the existing paper with yours. Submitting the change will open a new Pull Request in which we will then discuss and edit the revised version.\n\n The above flow assumes that we edit existing proposal txt files. @certik <https://github.com/certik> @zjibben <https://github.com/zjibben> should we instead keep the old versions as separate files and add the new one in its own file (like J3 does)?\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#22 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDORHHFYI4SZXSHT3AGTR257CRANCNFSM4JCMOXGQ>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-11 02:21:22+00:00",
                    "text": "FWIW trying to add a file at https://github.com/j3-fortran/fortran_proposals/tree/master/proposals/default_optional_arguments\ngives the message: Uploads are disabled.\nFile uploads require push access to this repository."
                },
                {
                    "user": "certik",
                    "date": "2020-07-11 04:25:57+00:00",
                    "text": "I am thinking of preserving the original paper, as the discussion is based on that. But let's have a dedicated directory for all the papers and documents related to this feature.\n\u2026\nOn Fri, Jul 10, 2020, at 3:05 PM, Milan Curcic wrote:\n\n\n William, great. If you navigate here:\n\n https://github.com/j3-fortran/fortran_proposals/blob/master/proposals/default_optional_arguments/proposal.txt\n\n In the upper right corner of the UI there is an \"Edit\" button. If you\n click on it, it will take you to an editor which you can use to replace\n the existing paper with yours. Submitting the change will open a new\n Pull Request in which we will then discuss and edit the revised version.\n\n The above flow assumes that we edit existing proposal txt files.\n @certik <https://github.com/certik> @zjibben\n <https://github.com/zjibben> should we instead keep the old versions as\n separate files and add the new one in its own file (like J3 does)?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#22 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWFMV63Z2B7JFOA3NO3R257CPANCNFSM4JCMOXGQ>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-11 14:36:19+00:00",
                    "text": "You already have such a directory\nhttps://github.com/j3-fortran/fortran_proposals/tree/master/proposals/default_optional_arguments\nthe one I need push access to"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-11 16:36:43+00:00",
                    "text": "William, here's what you need to do:\n\nFork this repository by navigating to https://github.com/j3-fortran/fortran_proposals and clicking on \"Fork\" in the upper-right corner.\nYou now have a fork here: https://github.com/wclodius2/fortran_proposals. Add your paper here: https://github.com/wclodius2/fortran_proposals/tree/master/proposals/default_optional_arguments (you will have push access to your fork of this repo).\nNow navigate back to https://github.com/j3-fortran/fortran_proposals. Near the top of the page there will be a UI element asking if you want to submit a Pull Request with the changes in your fork. Click on it, edit if needed, and click on \"open pull request\" (or similar, I forget the exact words)."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-12 13:42:09+00:00",
                    "text": "The revised_proposal.txt has been checked into the repository."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 16:11:00+00:00",
                    "text": "Just a comment. Keeping old files around with a naming convention for revisions kind of misses the point of having a version control system (the old versions can still be accessed if desired). But since not everyone interested in the project will be familiar with git, it's probably best to do it anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 22:38:36+00:00",
                    "text": "@everythingfunctional I think we should work on just one file and add changes to it (e.g. in #175), but once we submit it to the J3 meeting for consideration, I think it's good to keep a copy around, so that you don't have to go into git history all the time to see what the original was that the J3 discussion is based upon."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-26 00:22:51+00:00",
                    "text": "FWIW I have changed how the proposal discusses arguments with no intent. Instead of assuming that such arguments will be treated the same as INTENT(IN) or VALUE, I call no intent out separately and note how the wording in the standard should be phrased to either treat them the same as INTENT(IN) or VALUE or treat them like INTENT(INOUT) or INTENT(OUT)."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-26 13:26:43+00:00",
                    "text": "My revised proposal was that default values are relevant for dummy arguments with INTENT(IN) or VALUE explicity specified. It originally had no intent as an option, but consistently repeating \u201cINTENT(IN), or, VALUE, or no intent\u201d was awkward, and there was the problem that many people assume the no intent was,ery similar to INtENT(INOUT). It did not propose to \u201cautomatically\u201d give some different attributes to no intent arguments. Users would have to explicitly give the DEFAULT attribute, and write out the DEFAULT assignment.\n\u2026\n On Jul 25, 2020, at 9:12 PM, septcolor ***@***.***> wrote:\n\n\n I was assuming that the default value is relevant only for dummy arguments with INTENT(IN) explicitly specified. On the other hand, if the dummy arguments with no intent are automatically given some different attributes in future (say, intent(OUT) or VALUE), doesn't it mean that it silently breaks existing codes? (For example, INTENT(OUT) deallocates allocatable dummy arrays automatically, while VALUE changes the semantics from pass-by-reference to pass-by-value (in practice), which is crucial for foreign language interface.\n\n I guess it would already be extremely useful to be able to specify the default value for only the case where INTENT(IN), VALUE is explicitly specified, while no default value is allowed otherwise. At the moment, I need to use PRESENT() and declare additional local variables to set the default value, which is very inconvenient (as compared to other languages).\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#22 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOVDYPMAWERFPLL6Q3TR5ONLBANCNFSM4JCMOXGQ>."
                },
                {
                    "user": "jvdp1",
                    "date": "2021-01-20 19:19:52+00:00",
                    "text": "Just to remember that a revised version of the proposal is in the MR: #175 . It doesn't appear clearly in this thread..."
                },
                {
                    "user": "vansnyder",
                    "date": "2021-01-21 02:09:49+00:00",
                    "text": "During the development of Fortran 90, back when it was still called Fortran 8x, there was a proposal for an AUTOMATIC attribute. When RECURSIVE was added, the argument was that every variable that isn't SAVE is automatic. The standard's definition of \"automatic variable\" was needlessly narrowed to one that used a variable to specify a bound or length parameter. I no longer have records from that time; I sent them to the Computer History Museum. Loren Meissner is the curator for them.\nHad the AUTOMATIC attribute been retained, an obvious definition of AUTOMATIC with initialization would have meant automatic initialization, not SAVE. Specifying the AUTOMATIC attribute without initialization would simply confirm what we already say now. Explicitly specifying AUTOMATIC and SAVE for a particular variable should be prohibited. Explicitly specified AUTOMATIC would override default SAVE. AUTOMATIC would naturally be prohibited for storage-associated variables.\nOnce AUTOMATIC is defined that way, all that is necessary to provide default values for absent optional arguments is to define an absent OPTIONAL argument that has initialization to be a local automatic variable.\nThe PRESENT intrinsic should still be available to inquire whether there was an associated actual argument. Even if there's a value for a local variable acting in lieu of the absent dummy argument, it's still useful to know whether the actual argument was present."
                },
                {
                    "user": "Youjunhu",
                    "date": "2022-03-25 06:22:16+00:00",
                    "text": "\"Same syntax as Python keyword args, so it would be intuitive to Python developers learning Fortran;\"\n\"keyword argument\" is only relevant when you call a function.\nThe definition of a function does not care which argument will be called with the arg=value style.\nThe correct word should be \"default argument\"."
                }
            ]
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2019-10-18 16:49:33+00:00",
            "title": "Interpretation request regarding host association",
            "text": "Latest paper: https://j3-fortran.org/doc/year/19/19-257.txt",
            "is_open": true,
            "labels": [
                "under consideration",
                "Fortran 2023"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 16:57:39+00:00",
                    "text": "Committee voted to proceed."
                }
            ]
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2019-10-18 16:22:10+00:00",
            "title": "Edits for Put with Notify",
            "text": "Latest paper: https://j3-fortran.org/doc/year/19/19-259.txt",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023",
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 16:25:06+00:00",
                    "text": "Committee voted to proceed."
                },
                {
                    "user": "gareth-d-ga",
                    "date": "2020-04-28 10:52:10+00:00",
                    "text": "While the notify_type is quite similar to the event_type, I notice the proposal doesn't have anything equivalent to the 'event_query' subroutine (say 'notify_query').\n'event_query' allows you check if the event has been received, but without necessarily waiting. If it hasn't been received you can potentially do other work, thus facilitating the overlap of communication and computation.\nAs far as I can see, this should be equally useful in the 'notify_type' case.  So my question: Should something like 'notify_query' be added to this proposal?"
                },
                {
                    "user": "zjibben",
                    "date": "2020-04-28 18:42:24+00:00",
                    "text": "That's a good idea. I recall there was lots of discussion, including adding to the capabilities of event_type instead of adding a new notify_type type, and the result was that it should be a distinct type with very limited uses, because the synchronization patterns are different (syncing threads between transfers rather than a sync all). But I don't recall why a notify_query subroutine was left out. Probably it had something to do with notify_type having a much more narrow use case than event_type, and all the uses we imagined for a notify_query ended up having better alternative approaches. Or it could have just been neglected. I wish that conversation was documented somewhere. @longb and @JonSteidel had lots of input here, do either of you recall?\nAside: here are the other papers on the feature. They also don't give the reasoning behind leaving out notify_query.\n\n(intro, use cases, requirements) https://j3-fortran.org/doc/year/18/18-277r1.txt\n(above + specifications) https://j3-fortran.org/doc/year/19/19-251.txt"
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2020-05-03 22:41:38+00:00",
                    "text": "Thanks for posting. It\u2019s the first time I see this, so it could be that my understanding is wrong. If my understanding is correct, the \u2018put with notify\u2019 is very different from events. My focus is currently not on the question if a \u2018notify_query' could make sense, but to basically understand this \u2018put with notify\u2019 feature.\nFrom my current understanding, I would say (- in parentheses there are statements from the J3 papers that may match with my point of view -):\nhttps://j3-fortran.org/doc/year/18/18-277r1.txt\nhttps://j3-fortran.org/doc/year/19/19-259.txt\n\n\nDATA TRANSFER AND SYNCHRONIZATION ARE THE SAME SINGLE OPERATION:\nThe notify-specifier makes data transfer and it\u2019s synchronization to be semantically the same single operation.\n(\u201c...the notify can be incorporated into the same data packet as the value of y.\u201d)\n\n\nTHAT OPERATION HAS NO IMPACT ON SEGMENT ORDERING:\nInternally, this may not require use of SYNC MEMORY, thus the operation has no impact on segment ordering.\n(\u201c...the synchronization is only on this particular transfer, and not all outstanding memory operations on this image. The put with notify operation does not constitute segment ordering, ...\u201d)\n\n\nTO CONTROL THE EXECUTION FLOW OF A PARALLEL APP:\nFrom my own experiences with customized synchronizations: if we can synchronize and do data transfer within the same single operation, we can use that operation not only for efficient data transfer, but also to easily control the execution flow of a parallel app. This is important to implement distributed objects without the need for Remote Procedure Calls (RPC).\n(\u201c\u2026 the NOTIFY WAIT statement is not an image control statement.\u201d, \u201c...the NOTIFY WAIT execution control statement.\u201d)"
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2020-05-04 11:39:50+00:00",
                    "text": "I agree with you, that a NOTIFY_QUERY could be an important enhancement to the \u2018put with notify\u2019 proposal. See  the following example programs. \nFirst, I took an EVENTS example program from gcc.gnu.org and did some modification:\n! original program: https://gcc.gnu.org/onlinedocs/gcc-6.1.0/gfortran/EVENT_005fQUERY.html\nprogram events\n! working Fortran 2018 example program using EVENTS\nuse iso_fortran_env\nimplicit none\ntype(event_type) :: event_value_has_been_set[*]\ninteger :: cnt\n!\nif (this_image() /= 1) then\n  event post (event_value_has_been_set[1])\nend if\n!\nsync all ! comment this out to see that event_query is non-blocking\n!\nif (this_image() == 1) then\n  call event_query (event_value_has_been_set, cnt)\n  if (cnt > 0) write(*,*) \"Value has been set\", cnt\nend if\n!\nend program events\nThe following is how a notify_query could look like in practice:\nprogram notify\n! how notify_query could look like,\n! no working Fortran 2018 program\nuse iso_fortran_env\nimplicit none\ntype(NOTIFY_TYPE) :: notify_value_has_been_set[*]\ninteger :: x [*]\ninteger :: cnt, y, z\n!\nif (this_image() == 2) then\n  y = 123\n  x[1, NOTIFY=notify_value_has_been_set] = y\nend if\n!\nsync all ! comment this out to see that notify_query is non-blocking\n!\nif (this_image() == 1) then\n  call NOTIFY_QUERY (notify_value_has_been_set, cnt) ! cnt can have values greater than 1 if x is an array;\n                                                     ! Else, if cnt is greater than 1 and x is a scalar,\n                                                     ! this could indicate a programmer's mistake: multiple\n                                                     ! images, other than image 1, do the same 'put with notify'\n                                                     ! operation and thus may overwrite each other's value on image 1.\n  if (cnt > 0) then\n    write(*,*) \"Value has been set\", cnt\n    WAIT NOTIFY (notify_value_has_been_set)\n    z = x\n    write(*,*) z\n  end if\nend if\n!\nend program notify\nAnother important point: if we\u2019d use the \u2018put with notify\u2019 feature to control the execution flow of a parallel app, the NOTIFY_QUERY could be used by the programmer to implement an abort timer for the WAIT NOTIFY synchronization and data transfer. In practice this could be used to prevent slow running parallel algorithms from further execution at all."
                },
                {
                    "user": "longb",
                    "date": "2020-05-04 12:46:31+00:00",
                    "text": "On May 4, 2020, at 6:40 AM, Michael Siehl ***@***.***> wrote:\n\n\n I agree with you, that a NOTIFY_QUERY could be an important enhancement to the \u2018put with notify\u2019 proposal. See the following example programs.\n\n First, I took an EVENTS example program from gcc.gnu.org and did some modification:\n\n\nYour program did not cut paste will (lots of spurious newline characters, I hope I fixed if correctly below, and I added some extra comments.\n\n\n\nThe following is how a notify_query could look like in practice:\n\nprogram notify\n! how notify_query could look like,\n! no working Fortran 202X program\n\nuse iso_fortran_env\n\nimplicit none\n\ntype(NOTIFY_TYPE) :: notify_value_has_been_set[*\n]\n\ninteger :: x [*]\n\ninteger ::  cnt, y, z\n!\n\nif (this_image() == 2) then\n  y = 123\n\n  x[ 1, NOTIFY=notify_value_has_been_set] = y\n\nend if\n\n!\nsync all ! comment this  out to see that notify_query is non-blocking\n!\n\n!!Not clear the point of the above statement and comment\n\nif (this_image() == 1) then\n\ncall NOTIFY_QUERY (notify_value_has_been_set, cnt) ! cnt can have values greater than 1 if x is an array;\n                                                     !  Else, if cnt is greater than 1 and x is a scalar,\n                                                     ! this could indicate a programmer's mistake: multiple\n                                                     ! images, other than image 1, do the same 'put with notify'\n                                                     ! operation and thus may overwrite each other's value on image 1\n!! Comments are muddles. If X is an array and the assignment in image 1 had been\n!!    x[ 1, NOTIFY=notify_value_has_been_set](:) = y\n!! then cnt would be 1 on completion.\n!! cnt is just a count of the number of assignment statements that completed execution and  that included NOTIFY= notify_value_has_been_srt  in the image selector.\n\n\n\nif (cnt > 0) then\n\n\nwrite(*,*) \"Value has been set\u201d , cnt\nWAIT NOTIFY (notify_value_has_been_set)\n  z = x\n\nwrite(*,*) z\n\n\n!! Normally you would do the the check the other way (and the statement is NOTIFY WAIT): as in\n\n!!  If (cnt == 0) then\n!!    ! Do something else during the waiting time, then loop back to the call to NOTIFY_QUERY\n!! else\n!!   notify wait (notify)value_has been_set)\n!!   z = x\n!!   write (*,*) z\n!!  end if\n\n\n\nend if\nend if\n\n!\n\nend program notify\n\n\nChees,\nBill\n Another important point: if we\u2019d use the \u2018put with notify\u2019 feature to control the execution flow of a parallel app, the NOTIFY_QUERY could be used by the programmer to implement an abort timer for the WAIT NOTIFY synchronization and data transfer. In practice this could be used to prevent slow running parallel algorithms from further execution at all.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n\nBill Long                                                                       longb@cray.com\nPrincipal Engineer, Fortran Technical Support &   voice:  651-605-9024\nBioinformatics Software Development                      fax:  651-605-9143\nCray, a Hewlett Packard Enterprise company/ 2131 Lindau Lane/  Suite 1000/  Bloomington, MN  55425"
                },
                {
                    "user": "gareth-d-ga",
                    "date": "2020-05-04 15:15:33+00:00",
                    "text": "!! Normally you would do the the check the other way (and the statement is NOTIFY WAIT): as in\n!!  If (cnt == 0) then\n!!    ! Do something else during the waiting time, then loop back to the call to NOTIFY_QUERY\n!! else\n!!   notify wait (notify)value_has been_set)\n!!   z = x\n!!   write (,) z\n!!  end if\n\nI agree the main point of notify_query is to do useful work if the notification hasn't occurred. Although there are differences between event_type and notify_type, a common use case for both is to confirm that a communication has finished. In this case, the notify_type should be more efficient, which I understand is the main justification for adding it to the standard.\nOne situation where notify_query would be useful is if we receive data from more than one image. Below is a sketch of how this might be important in a fairly typical halo-exchange type situation. With only notify_wait, we'd get stuck when checking the first halo buffer (left in the program below) -- and thus lose the opportunity to check/unpack the right halo buffer immediately.\nprogram notify\n! Concept around notify_query -- important bits have comment \"KEY STEP\"\n!\n! Suppose we have a 'halo-exchange' type program\n! For simplicity consider a 1-dimensional PDE domain decomposition. \n!\n! With notify_query, we can check for data arrival from the left/right\n! neighbours, and unpack as soon as it arrives, without any enforced wait.\n! This could help overlap communication with computation (in this case, unpack of halo buffers).\n\nuse iso_fortran_env\n\nimplicit none\n\ninteger, parameter :: N = 100, halo_width = 5, max_time = 1000 \nreal :: solution(N), data_send_to_left(halo_width), data_send_to_right(halo_width)\nreal :: data_received_from_left(halo_width)[*], data_received_from_right(halo_width)[*]\ntype(NOTIFY_TYPE) :: right_buffer_received[*], left_buffer_received[*]\n\n! Local variables \ninteger :: time_loop, left_nbr_image, right_nbr_image, cnt\nlogical :: left_received, right_received\n\n! Find images to the left/right\nleft_nbr_image  = this_image() - 1; if(left_nbr_image  == 0             ) left_nbr_image  = num_images()\nright_nbr_image = this_image() + 1; if(right_nbr_image == num_images()+1) right_nbr_image = 1\n\n! Initial conditions\ncall initialise(solution)\n\ndo time_loop = 1, max_time\n\n    ! Main update\n    call update_solution_locally(solution)\n\n    ! Create data that we should send to the left/right images\n    call pack_halos_to_send(solution, data_send_to_left, data_send_to_right)\n\n    ! KEY STEP: Initiate two put-with-notify communications, which send data to left/right images\n    data_received_from_right[left_nbr_image, NOTIFY=right_buffer_received] = data_send_to_left\n    data_received_from_left[right_nbr_image, NOTIFY=left_buffer_received] = data_send_to_right\n   \n    left_received = .FALSE.; right_received = .FALSE.\n    ! KEY STEP: Keep checking for the arrival of the left/right halo data. Unpack it immediately on\n    ! arrival. Notice we can do useful unpacking work as soon as a single halo is received. I do not \n    ! think this would be possible using only NOTIFY_WAIT, because we would get stuck on the first check. \n    ! So NOTIFY_QUERY seems important (?)\n    do while ( (.not. left_received) .or. (.not. right_received) )\n        if(.not. left_received) then\n            ! Check the left buffer - unpack if received\n            call notify_query(left_buffer_received, cnt)\n            if(cnt > 0) then\n                call unpack_left_buffer(data_received_from_left, solution)\n                left_received = .TRUE.\n            end if\n        end if\n        if(.not. right_received) then\n            ! Check the right buffer - unpack if received\n            call notify_query(right_buffer_received, cnt)\n            if(cnt > 0) then\n                call unpack_right_buffer(data_received_from_right, solution)\n                right_received = .TRUE.\n            end if\n        end if\n    end do \n\nend do\n\n!\n\nend program notify"
                },
                {
                    "user": "MichaelSiehl",
                    "date": "2020-05-04 21:15:17+00:00",
                    "text": "notify.txt\n@longb Thanks for the comments. According to your comments, I did modify my above example and made two versions of it. I did also attach these as notify.txt. Hope this could help. Feel free to use or further modify them.\nprogram notify\n! how notify_query could look like,\n! no working Fortran 202X program\nuse iso_fortran_env\nimplicit none\ntype(NOTIFY_TYPE) :: notify_value_has_been_set[*]\ninteger :: x [*]\ninteger :: cnt, y, z\n!\nif (this_image() == 2) then\n  y = 123\n  x[1, NOTIFY=notify_value_has_been_set] = y\nend if\n!\nif (this_image() == 1) then\n  spin_wait: do\n    call NOTIFY_QUERY (notify_value_has_been_set, cnt)\n    If (cnt == 0) then\n      ! Do something else during the waiting time, then loop back to the call to NOTIFY_QUERY\n      ! or exit (abort) the spin_wait loop if a time limit has been exceeded\n    else\n      write(*,*) \"Value has been set\", cnt\n      NOTIFY WAIT (notify_value_has_been_set)\n      z = x\n      write(*,*) z\n      exit spin_wait\n    end if\n  end do spin_wait\nend if\n!\nend program notify\nprogram notify\n! how notify_query could look like,\n! no working Fortran 202X program\nuse iso_fortran_env\nimplicit none\ntype(NOTIFY_TYPE) :: notify_value_has_been_set[*]\ninteger :: x [*]\ninteger :: cnt, y, z\n!\nif (this_image() == 2) then\n  y = 123\n  x[1, NOTIFY=notify_value_has_been_set] = y\nend if\n!\nsync all\n!\nif (this_image() == 1) then\n  call NOTIFY_QUERY (notify_value_has_been_set, cnt)\n  If (cnt == 0) then\n    ! Do something else during the waiting time, then loop back to the call to NOTIFY_QUERY\n  else\n    write(*,*) \"Value has been set\", cnt\n    NOTIFY WAIT (notify_value_has_been_set)\n    z = x\n    write(*,*) z\n  end if\nend if\n!\nend program notify\nIn case, further motivation is required:\nFollowing Robert Numrich's 'Parallel Programming with Co-Arrays' and go even a step further:\nHe makes extensive use of abstract classes for parallel programming and brings it to the point on page 79: \"After Fortran became an object-oriented language, the co-array model fit well into the design of distributed classes:\" \nI can confirm that the coarray model in Fortran 2018 does allow to implement (and extend) a fragmented objects model, a truly distributed object model, through use of abstract classes. The 'put with notify' feature could be an important addition for easy control of the execution flow with such distributed object programming.\nThe coarray model together with Fortran's OOP are already forming a new kind of programming language that may fit perfectly for upcoming EDGE. My current developments are still experimental, but you should expect some first example program in a couple of month. \ncheers,\nMichael"
                }
            ]
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2019-10-18 16:14:08+00:00",
            "title": "Short-circuiting logical expressions",
            "text": "Currently one cannot write things like:\nif (i < size(a) .and. a(i) == 0) ...\nBecause the compiler is free to evaluate a(i) first even if i is out of bounds. This proposal is to introduce .andthen. and .orelse. operators which will allow the above code to be written as:\nif (i < size(a) .andthen. a(i) == 0) ...\nAn alternative proposal to this is conditional expressions (#12) which got rejected.\nThere is also an option to make .andthen. just .and., the argument pro is that it does not introduce any new syntax, but an argument against it is that it would change the current freedom for compilers to re-arrange logical expressions.",
            "is_open": true,
            "labels": [
                "Clause 10"
            ],
            "comments": [
                {
                    "user": "zjibben",
                    "date": "2019-10-19 01:45:06+00:00",
                    "text": "Another option to consider is adding an optional keyphrase like shortcircuiting on, which might sit next to implicit none. This would require left-to-right short-circuiting behavior in the current scope for all logical operators. The benefit would be we can keep the .and. and .or. already in our codes, as opposed to adding the IMHO verbose .andthen. and .orelse. (which apparently mimics Ada and Pascal). It would also preserve the existing behavior for those who want it.\nPersonally I'd be happy to go as far as enforcing left-to-right short-circuiting in all logical expressions, which would adopt the behavior of other programming languages like C, C++, Python, Java, Lisp, Perl, JavaScript, Julia, R, Haskell, etc etc. My argument would be for more predictable codes and better programmer control. And, this wouldn't break existing programs because there currently isn't any standards-defined behavior for those programs to rely on (that I know of).\nOf course, as you mentioned this is controversial. Some Fortran programmers like that some compilers might rearrange their logical expressions and short-circuit in some optimal-ish order, though other compilers might evaluate the entire statement regardless. And, breaking troublesome if-statements into multiple lines as below is usually not very disruptive. So there is the question of whether this is really worth rocking the boat over.\nif (i < size(a)) then\n  if (a(i) == 0) ...\nend if"
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 02:01:52+00:00",
                    "text": "The way to move this forward would be to gather use cases from real codes, and see how many times the compiler can optimize the logical expression well, versus let the programmer do it explicitly. There might perhaps be a compiler option already to turn this on and off --- in which case one can measure the speed of the code / benchmark it. That would answer the question whether compilers should optimize the logical expression or not."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 23:52:51+00:00",
                    "text": "As an implementor, I think that it would increase portability to our new compiler if we were to always implement short-circuiting in specific cases, viz.: scalar left operand to .AND. and .OR, and scalar selector operand to MERGE when its other two operands have the same rank.  Most users are going to be far happier with me if IF (PRESENT(X) .AND. X > 10) doesn't mysteriously crash their code.  We are considering documenting some short-circuiting guarantees, but acknowledge that we don't want to encourage the development of less portable Fortran code.\nIf people want to invent explicit short-circuiting logical operators, I should point out that you don't have to necessarily give them their own new levels in the operator precedence hierarchy; e.g., .ANDTHEN. can have the same precedence as .AND., and would be least confusing if it did so."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-06 01:21:02+00:00",
                    "text": "I think introducing more and more switches like \"shortcircuting on\", \"implicit save off\" etc is a very dangerous practice and should be avoided. There should be one set of rules.\nIs the short circuting only a matter of introducing a new operator/function? From what I remember, this issue was brought up like 20 times on c.l.f, but problem was that the language does not guarantee the order or even fact of evaluation of any expression, therefore this one new operator would have to be one exception. Which makes me think that an entire new construct with defined execution order must be introduced to not rewrite half of existing standard. I don't think it should be an operator like .and_then. because when it gets mixed with non short-circuting operators by skilled programmer scientists that will be hell.\nI suggest something along the lines of:\n! what we want to do\nif (present(x) .and. x > 10) x = 10\n! warning: requires changing the standard\nif (provided(present(x), x > 10)) x = 10\n! will crash or not?\nif (present(x).and.present(z).and_then.x>z+3) ...\nOther option is, since 95% of examples I see are with present and optional arguments, maybe just introduce default value for optional arguments and most complaints will vanish. (In 99% of other cases the order of evaluation actually doesn't matter.)"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-13 09:16:07+00:00",
                    "text": "I'd also prefer, not to have an additional shortcircuiting on keyword. Adding newer and newer keywords like this would lead to having a longish block at the beginning of each module in order to enforce/support 'modern' programming practices:\nimplicit none(type, external, ...)\nshortcircuiting on\nimplicitsave off\n...\n\nI think the message such lines send are disastrous: 'You need to do a lot of gimmics to make sure, that Fortran feels like a modern language'. When teaching Fortran, I feel already ashamed for having to explain, why the implicit none line must be present in each module, and why student projects not having it would be rejected by me. A modern language should support / enforce modern programming techniques by default. I think, we should rather have a collective option to specify a certain language version the code in a given unit represents, which could then turn on all the beneficial options at once. (I actually created issue #83 for that)."
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-13 16:14:23+00:00",
                    "text": "The committee has discussed short-circuiting many times. The sentiment is generally against implicit short-circuiting, as the standard currently allows evaluation of any equivalent expression to any degree of completeness. Requiring short-circuiting would hinder some optimizations.\nInstead, WG5 has already approved for the 202X worklist explicit short-circuiting. The current proposal is 18-239."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-21 17:41:07+00:00",
                    "text": "How about a SIF statement? like IF, but impliments short-circuiting."
                },
                {
                    "user": "marshallward",
                    "date": "2019-12-22 00:34:50+00:00",
                    "text": "I have recently just fixed many short-circuit issues in our codebase which were dormant for years and were only discovered because we recently enabled more aggressive initialization.\nI mention this because people are already writing code as if it short circuits, and default behaviour often does not catch it as an issue."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 23:20:31+00:00",
                    "text": "Here are the papers that were planned for the February Meeting #155.\nhttps://j3-fortran.org/doc/year/18/18-274.txt\nhttps://j3-fortran.org/doc/year/18/18-239.txt\nhttps://j3-fortran.org/doc/year/18/18-152.txt"
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-28 23:25:57+00:00",
                    "text": "Note the above papers also discuss conditional expressions, such as a ternary operator which does not evaluate the arguments like merge."
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2019-10-18 16:06:47+00:00",
            "title": "Standardizing use of BOZ constants",
            "text": "The latest paper: https://j3-fortran.org/doc/year/19/19-256r1.txt",
            "is_open": true,
            "labels": [
                "under consideration",
                "Fortran 2023",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 16:20:38+00:00",
                    "text": "Committee voted to proceed."
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2019-10-17 16:20:21+00:00",
            "title": "Add reductions to DO CONCURRENT",
            "text": "The initial paper by @gklimowicz at: https://j3-fortran.org/doc/year/19/19-255.txt.\nThe latest paper: https://j3-fortran.org/doc/year/19/19-255r1.txt",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023",
                "Clause 11"
            ],
            "comments": []
        },
        {
            "number": 16,
            "user": "aradi",
            "date": "2019-10-17 12:13:30+00:00",
            "title": "Protected attribute for variables in derived types",
            "text": "It would be awesome, if the protected attribute could also be used in derived types:\n  type :: some_big_data_t\n    real, allocatable, protected :: data(:,:)\n  contains\n    procedure :: set_data\n    !procedure :: get_data\n  end type some_big_data_t\n\nIt would help to avoid unnecessary copies when retrieving data from a derived type instance and enable protection against unnoticed manipulation of that data.",
            "is_open": true,
            "labels": [
                "under consideration",
                "Fortran 202y",
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 22:07:15+00:00",
                    "text": "Thanks @aradi for the idea. Would you be interested in putting a proposal together for this? You can send a PR with the draft."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 08:14:32+00:00",
                    "text": "Yes, sure, why not. I'll make a proposal."
                },
                {
                    "user": "aradi",
                    "date": "2019-10-21 15:45:58+00:00",
                    "text": "Stupid question: How do you choose the file name for the proposal in the PR?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 17:12:44+00:00",
                    "text": "Just choose some, we can rename it later.\n\u2026\nOn Mon, Oct 21, 2019, at 8:45 AM, B\u00e1lint Aradi wrote:\n Stupid question: How do you choose the file name for the proposal in the PR?\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub <#16?email_source=notifications&email_token=AAAFAWH4VR64SMUAIC5D6GTQPXFDNA5CNFSM4JBYSARKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEB2ZI2Y#issuecomment-544576619>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWES5V2UJJH4E2PVMMTQPXFDNANCNFSM4JBYSARA>."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-23 18:04:31+00:00",
                    "text": "The proposal is now submitted:\nhttps://j3-fortran.org/doc/year/20/20-106.txt\nThanks @aradi!"
                },
                {
                    "user": "aradi",
                    "date": "2020-02-23 20:07:43+00:00",
                    "text": "Cool! Thanks @zjibben to support this!"
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 23:47:03+00:00",
                    "text": "@aradi the committee is actively developing a version of this proposal in #156. Unfortunately, it seems that currently there are some issues with the latest version. If you have time, I would encourage that you get involved there. We will happily channel your arguments."
                }
            ]
        },
        {
            "number": 15,
            "user": "Beliavsky",
            "date": "2019-10-17 02:39:26+00:00",
            "title": "Add an a0 edit descriptor analogous to the i0 descriptor",
            "text": "I suggest that an a0 edit descriptor be added that acts like the 'a' descriptor but TRIMs trailing spaces of a string. Because Fortran arrays of strings must have all strings the same size, many strings have redundant trailing spaces. Using the a0 descriptor you could print strings with the minimum size needed, analogous to i0 for integers. Below is an example of the requested feature.\nprogram main\nimplicit none\ninteger, parameter :: n = 4\ncharacter (len=10) :: c(n)\ninteger            :: i\nc = [\"one  \",\"two  \",\"three\",\"four \"]\nwrite (*,\"(1000(a,1x))\") (trim(c(i)),i=1,n) ! output: \"one two three four\"\n! desired syntax in line below, to do the same thing as line above:\n! write (*,\"(1000(a0,1x))\") c \nend program main",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023",
                "Clause 13"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-17 04:53:27+00:00",
                    "text": "@Beliavsky thanks a lot for submitting the request. I'll ask at the committee what they think."
                },
                {
                    "user": "gklimowicz",
                    "date": "2019-10-17 15:30:36+00:00",
                    "text": "If you look at the J3 standing document 013 (https://j3-fortran.org/doc/year/19/19-013.pdf), it has the list of things that were under consideration for the next rev of the standard, and the relevant papers where these are elaborated.\nThis item is listed as \"AT (was A0)\" for A with TRIM. It's last described in paper 19-137r2 (https://j3-fortran.org/doc/year/19/19-137r2.txt).\nMy recollection is that the last discussion included whether we should be including trimming blanks on the left as well as the right. That idea was popular with some people. And unpopular with other people."
                }
            ]
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2019-10-16 21:27:21+00:00",
            "title": "Efficient way to get/set the diagonal of a matrix",
            "text": "It would be really nice to have a built in (and so highly optimized) operation, as it is in Matlab: diag(A) to get or set the diagonal of a matrix A. Or, more generally, diagonal slices to get any diagonal (whether main or other) or even group of diagonals. Would be the perfect complement to current square submatrix slices.\nSee also the Matlab's diag function and Python Numpy's diag function.\nUse cases:\n\nGetting the diagonal\n\nreal(dp) :: A(n, n)\nprint *, diag(A)\n\nSetting the diagonal\n\nreal(dp) :: A(n, n)\nA = 0\ndiag(A) = 1\nNote: The diag(A) = 1 syntax is new, as we are setting something to a result of a function. The way it should be read is that diag(A) is not a function but rather an intrinsic operation that gives access to the main diagonal. An alternative notation that could be considered:\n\nGetting the diagonal\n\nreal(dp) :: A(n, n)\nprint *, A(\\)\n\nSetting the diagonal\n\nreal(dp) :: A(n, n)\nA = 0\nA(\\) = 1\nOr more generally A(start\\end\\skip) for the main diagonal and A(start/end/skip) for the anti-diagonal. In such case, an optional parameter could occur to denote which diagonal, as in Matlab, e.g., A(2\\4,0) gets 2nd thru 4th elements of the main diagonal, A(2\\4,1) gets 2nd thru 4th elements of diagonal above the main, etc.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Clause 16"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-16 21:33:29+00:00",
                    "text": "There is a way to do this using a pointer assignment statement, see the section 10.2.2.5 in the Fortran 2018 Standard, Note 2:\nIt is possible to obtain different-rank views of parts of an object by specifying upper bounds in pointer\nassignment statements. This requires that the object be either rank one or contiguous. Consider the\nfollowing example, in which a matrix is under consideration. The matrix is stored as a rank-one object in\nMYDATA because its diagonal is needed for some reason \u2013 the diagonal cannot be gotten as a single object from a rank-two representation. The matrix is represented as a rank-two view of MYDATA.\nreal, target :: MYDATA ( NR*NC )  ! An automatic array\nreal, pointer :: MATRIX ( :, : )  ! A rank-two view of MYDATA      \nreal, pointer :: VIEW_DIAG ( : )\nMATRIX (1:NR, 1:NC) => MYDATA     ! The MATRIX view of the data\nVIEW_DIAG => MYDATA (1::NR+1)     ! The diagonal of MATRIX"
                },
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:14:59+00:00",
                    "text": "I'm not sure I see how this is/would be optimized more than direct references to diagonal elements. I agree that it would be useful/convenient, but you're still effectively fetching an entire cache line for just a single element. And the access pattern is the same, unless you do some really fancy gather-scatter with a packed caching buffer."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 16:52:06+00:00",
                    "text": "I agree the compilers might not be able to optimize this more than developers already can by explicit for loop, although they might. I think the stronger argument is that both Matlab and NumPy have this function and it does simplify code."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-19 00:55:58+00:00",
                    "text": "ASSOCIATE facility in Fortran can be an option to consider for certain use cases involving operations on the diagonal elements of a matrix.  One advantage of this option is the ability to work with objects that do NOT  have the TARGET attribute, as TARGET can possibly hinder optimization:\n   integer, parameter :: N = 3\n   integer :: i\n   blk1: block\n      integer, target :: dat(N*N)  !<-- reguires TARGET attributel might hinder optimization\n      integer, pointer :: mat(:,:)\n      integer, pointer :: diag(:)\n      dat = [( i, i=1,size(dat) )]\n      mat(1:N,1:N) => dat\n      diag => dat(1::N+1)\n      print *, \"Approach 1: Matrix:\"\n      do i = 1, size(mat,dim=1)\n         print \"(*(g0,1x))\", mat(:,i)\n      end do\n      print *, \"Diagonal elements: \", diag\n      mat => null()\n      diag => null()\n   end block blk1\n   blk2: block\n      integer :: dat(1:N*N)        !<-- Note no TARGET attribute\n      dat = [( i, i=1,size(dat) )]\n      print *, \"Approach 2: Matrix:\"\n      do i = 1, N\n         print \"(*(g0,1x))\", dat((i-1)*N+1:(i-1)*N+N)\n      end do\n      associate ( diag => dat(1::N+1) )\n         print *, \"Diagonal elements: \", diag\n      end associate\n   end block blk2\n   stop\nend\nUpon compilation and execution, the above should output:\nApproach 1: Matrix:\n1 2 3\n4 5 6\n7 8 9\n Diagonal elements:  1 5 9\n Approach 2: Matrix:\n1 2 3\n4 5 6\n7 8 9\n Diagonal elements:  1 5 9"
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 01:08:34+00:00",
                    "text": "@FortranFan thanks! I was hoping that associate might be able to do it without the target attribute. However, your example is using a 1D array. If I do 2D array:\ninteger, parameter :: N = 3\ninteger :: dat(N,N), i\ndat = reshape([( i, i=1,size(dat) )], [N,N])\nprint *, \"Approach 2: Matrix:\"\ndo i = 1, 3\n    print \"(*(g0,1x))\", dat(i,:)\nend do\nassociate ( diag => dat(1::N+1) )\n    print *, \"Diagonal elements: \", diag\nend associate\nend\nThen gfortran gives an error:\na.f90:8:23:\n\n associate ( diag => dat(1::N+1) )\n                       1\nError: Rank mismatch in array reference at (1) (1/2)"
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 01:20:34+00:00",
                    "text": "Here is one way to do it without pointers:\ninteger, parameter :: N = 3\ninteger :: dat(N,N), i\ndat = reshape([( i, i=1,size(dat) )], [N,N])\nprint *, \"Approach 2: Matrix:\"\ndo i = 1, 3\n    print \"(*(g0,1x))\", dat(i,:)\nend do\nprint *, \"Diagonal elements: \", diag(dat)\n\ncontains\n\n    function diag(A) result(d)\n    integer, intent(in) :: A(:,:)\n    integer :: d(size(A,1))\n    d = diag1d(size(A,1), A)\n    end function\n\n    function diag1d(n, A) result(d)\n    integer, intent(in) :: n\n    integer, intent(in) :: A(n*n)\n    integer :: d(n)\n    d = A(1::n+1)\n    end function\n\nend\nBut at this point, even simpler and more straightforward is to just do:\n    function diag(A) result(d)\n    integer, intent(in) :: A(:,:)\n    integer :: d(size(A,1))\n    integer :: i\n    do i = 1, size(A,1)\n        d(i) = A(i,i)\n    end do\n    end function"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-19 17:21:06+00:00",
                    "text": "@FortranFan thanks! I was hoping that associate might be able to do it without the target attribute. However, your example is using a 1D array. If I do 2D array:\n..\nThen gfortran gives an error:\n..\nError: Rank mismatch in array reference at (1) (1/2)\n\nAgree, there are limitations with ASSOCIATE.  That's why I wrote \"an option to consider for certain use cases\"!\nWith so many aspects in Fortran (or for that matter, with other programming languages or paradigms), there simply are no \"perfect solutions\" for some coding needs.  A \"diag\" function might end up requiring expensive data copy operations and given how Fortran is structured, there can even be two sets of such operations, one to fetch the data from the matrix source in the first place followed then by another one during the assignment on the caller side!  So coders are left to pick the \"poison\" of their choice.\nIf better support for parameterized derived types (PDTs) toward Fortran 2003 and later revisions of the standard were available widely, coders wanting to work a lot with matrices and having to \"slice and dice\" the matrix \"data\" heavily might benefit from pursuing a coding design that uses a PDT as a 'class' for a matrix and having type-bound procedures (TBPs) to operate efficiently on the data.  For \"sliced and diced\" reference to matrix data, TBPs returning data pointers can prove really handy given the improvement introduced in the language starting with Fortran 2008 where pointers can be present in any variable-definition context including on the left-hand side of operations.\nReaders can note I point out different options due to the fact any changes in the Fortran language - say a DIAG(ONAL) utility, almost any simple trivial syntactic \"sugar\" for a coder to a semantic  improvement in language which improves coder productivity -  essentially take eons to take effect: first, an eon or more to influence and convince powers-that-be to even agree to add to the language standard, then a eon or more to work out the details, another X years for the standard containing that feature to go into \"official\" publication, followed by a decade or more for the facility to start appearing in enough compiler implementations so coders can confidently pursue the new facility in their code, but add another few years for the implementation bugs to be worked out for the facility to be robust from the most lax robustness and quality considerations for compilers (leave alone Six-sigma)!!!  Such considerations, unfortunately, need to be contemplated for all the \"wonderful\" ideas for Fortran that are going to pop up in this new GitHub issues respository!"
                },
                {
                    "user": "zbeekman",
                    "date": "2019-10-19 19:47:52+00:00",
                    "text": "Just to riff on the ideas here, you can use associate with multidimensional arrays, so long as you are happy with the result, diag being immutable and essentially a copy since it's an expression.\nprogram main\n  use iso_fortran_env, only : dp => real64\n  implicit none\n  integer, parameter :: N=9\n  integer :: i, j\n  real(dp), allocatable :: A(:,:)\n\n  A = reshape([ ( (10*j + i, i=1,N ), j=1,N) ], [N, N])\n\n  associate( diag => [ (A(i,i), i=1,N) ] )\n    write(*,'(\"diag: \",*(g0,:,\", \"))') nint(diag)\n    A(1,1) = 1010\n    write(*,'(\"diag: \",*(g0,:,\", \"))') nint(diag)\n  end associate\n  write(*,'(A)') \"A:\"\n  do j = 1, N\n     write(*,'(*(g0,:,\", \"))') nint(A(:,j))\n  end do\nend program\nThis gives the result:\ndiag: 11, 22, 33, 44, 55, 66, 77, 88, 99\ndiag: 11, 22, 33, 44, 55, 66, 77, 88, 99\nA:\n1010, 12, 13, 14, 15, 16, 17, 18, 19\n21, 22, 23, 24, 25, 26, 27, 28, 29\n31, 32, 33, 34, 35, 36, 37, 38, 39\n41, 42, 43, 44, 45, 46, 47, 48, 49\n51, 52, 53, 54, 55, 56, 57, 58, 59\n61, 62, 63, 64, 65, 66, 67, 68, 69\n71, 72, 73, 74, 75, 76, 77, 78, 79\n81, 82, 83, 84, 85, 86, 87, 88, 89\n91, 92, 93, 94, 95, 96, 97, 98, 99\n\nNotice that diag did not update with A."
                },
                {
                    "user": "milancurcic",
                    "date": "2021-10-27 19:51:20+00:00",
                    "text": "I marked this as Chapter 16: Intrinsic procedures and modules, as I think this is most likely way to add it to the language. Stdlib now provides diag to get a diagnoal, and a setter could be implemented there as well."
                }
            ]
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2019-10-16 20:49:57+00:00",
            "title": "REAL16 proposal",
            "text": "The document N2169 lists the approved items from the WG5 August 2019 Meeting in Tokyo, one of which is:\nUS08 - Additional named constant, REAL16, in ISO_FORTRAN_ENV to specify whether the processor supports a 16-bit REAL KIND. J3/19-139r1",
            "is_open": true,
            "labels": [
                "in progress",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-11-07 19:40:24+00:00",
                    "text": "I know there was a discussion about this point, as I asked the same question. @tclune do you remember what the arguments were?"
                },
                {
                    "user": "tclune",
                    "date": "2019-11-07 21:01:25+00:00",
                    "text": "I think I've missed something.   What is the question/position for which arguments are desired?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-07 21:31:43+00:00",
                    "text": "@klausler was asking why not to just use SELECTED_REAL_KIND instead of REAL16 from ISO_FORTRAN_ENV."
                },
                {
                    "user": "tclune",
                    "date": "2019-11-07 21:33:35+00:00",
                    "text": "Sorry  - I did not real the OP carefully enough.  Now I understand the context.\nAt the very least checking to see if two results from SELECTED_REAL_KIND differ is something that happens at run time, and sometimes one wants to know at compile time that some functionality is not available.\nThe question is really about why the existing standard has REAL32, REAL64, and REAL128.   These are much more practical for library developers that wish to overload their procedures for the supported kinds of REAL provided by a given implementation.       In that case it is not that the developer wants a certain amount of precision.   They are trying to support other users that get to choose precision on their own.     REAL16 is proposed just simply to be consistent for an increasingly common option on some hardware.\nNote that REAL32 et al are not quite sufficient in and of themselves to allow a portable implementation that covers all supported real kinds.    Generally some logic is still required in the build system to control which kinds are selected.\nNote also that REAL32 is not necessarily the same thing as default REAL.  Theoretically it can be tricky to distinguish such things.  In practice, all extant compilers have kind(1.) == REAL32"
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-08 14:41:57+00:00",
                    "text": "@klausler wrote:\n\nWhy not use SELECTED_REAL_KIND()?\n..\n\n@klausler, can you please explain your point here?\nAre you giving a \"thumbs down\" or suggesting the proposal involving a trivial effort to add another few named constants (e.g., REAL16, LOGICAL8, LOGICAL16, ..)) to the list of those introduced in the language starting Fortran 2008 (such as REAL32) in ISO_FORTRAN_ENV intrinsic module be removed from consideration?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-08 17:44:12+00:00",
                    "text": "@FortranFan I think @klausler is just asking a general question if user code should be using SELECTED_REAL_KIND or ISO_FORTRAN_ENV. Thanks @tclune for the answer."
                },
                {
                    "user": "certik",
                    "date": "2019-11-08 18:14:29+00:00",
                    "text": "@klausler this is a long standing issue in Fortran, how you are supposed to declare the precision of the real variable. With multiple opinions even on the committee itself. I personally actually just use dp = kind(1.d0) for double precision, as that is the shortest, and otherwise I use  SELECTED_REAL_KIND. I do not use ISO_FORTRAN_ENV. But I know several colleagues that use ISO_FORTRAN_ENV."
                },
                {
                    "user": "certik",
                    "date": "2019-11-08 18:48:16+00:00",
                    "text": "@klausler exactly. The other functions that go hand in hand with this are epsilon and tiny, both of which I use quite often. That way the numerical code is actually quite independent of the actual accuracy of the real type. In practice I only test with double precision, but I think the porting to single precision or quadruple precision would not be that hard with my codes."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2019-10-16 17:54:32+00:00",
            "title": "Conditional Expressions",
            "text": "Initial recent paper: https://j3-fortran.org/doc/year/18/18-274.txt (there is a long history of trying to get something like this standardized).\nMotivation\nCiting from the paper:\nPeople have wanted to write things like\n  IF (I<N .AND. A(I)==0) ...\nfor decades.  So far, we have fobbed them off and they have to write\n  IF (I<N) THEN\n    IF (A(I)) ...\n  END IF\nwhich is not just verbose but less convenient when wishing to test a series\nof conditions.\nSimilarly, writing\n  IF (PRESENT(D)) THEN\n    CALL SUB(A,B,C,D)\n  ELSE IF (X<1) THEN\n    CALL SUB(A,B,C,EPSILON(X))\n  ELSE\n    CALL SUB(A,B,C,SPACING(X))\n  END IF\nis verbose but usable when only one argument is conditional, but rapidly\ndegenerates when there are several arguments requiring similar handling.",
            "is_open": false,
            "labels": [
                "rejected"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-16 18:01:13+00:00",
                    "text": "The proposed syntax in 18-274 for the last example would be:\nCALL SUB(A,B,C,IF (PRESENT(D)) THEN (D) ELSE IF (X<1) THEN (EPSILON(X)) ELSE (SPACING(X)) END IF)\nHere is how Python does it: https://docs.python.org/3/reference/expressions.html#conditional-expressions"
                },
                {
                    "user": "victorsndvg",
                    "date": "2019-10-17 07:41:32+00:00",
                    "text": "Dear @certik ,\nI agree that short-circuit conditional evaluation could be an interesting feature.\nOn the other hand, Fortran provides the merge instrinsic that, I think, it covers the example (quoted) below (usually called ternary operator):\n\nCALL SUB(A,B,C,IF (PRESENT(D)) THEN (D) ELSE IF (X<1) THEN (EPSILON(X)) ELSE (SPACING(X)) END IF)"
                },
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:09:35+00:00",
                    "text": "Short circuit conditionals might alleviate a lot of segmentation faults; I know this would have saved my hide a few times."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 16:18:13+00:00",
                    "text": "@victorsndvg, @zbeekman thanks for the feedback. Note that this particular proposal began long before my time at the committee and I don't feel very strongly either way on this particular one. I am watching what the committee works on and discusses and I am trying to create issues here for each proposal, to track it and to enable discussions with the wider community outside the committee."
                },
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:24:57+00:00",
                    "text": "Yes weighing in here with community feedback! Thanks for doing this @certik! I'd love to see J3 put more proceedings/documents/etc. on GitHub or GitLab."
                },
                {
                    "user": "zjibben",
                    "date": "2019-10-17 17:00:16+00:00",
                    "text": "The difference with merge is 1) merge may evaluate all options regardless of the logical expression and 2) merge returns values, not variables. So merge(a, b, present(a)) is compiler-dependent; it might fail if a is not present, because as value could be accessed. By making the variable, not the value, the result of the expression, you can use this as an intent(out) argument. E.g., call get_x(if (l) then (a) else (b) endif) works to assign to either a or b.\nThough short-circuiting logical expressions appeared in the initial paper, it isn't really being pursued here. Which is unfortunate; I'm much more interested in short-circuiting logical expressions than conditional expressions."
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 16:03:35+00:00",
                    "text": "Latest syntax paper: https://j3-fortran.org/doc/year/19/19-247r1.txt\nThe main feedback from the committee seems to be that the conditional expression proposal above does not make things much simpler or clearer, and the new syntax does not seem appealing. The alternative is to short-circuit logical expressions, so this:\n  IF (I<N .AND. A(I)==0) ...\ncould be written, e.g., as:\n  IF (I<N .ANDTHEN. A(I)==0) ...\nThat way the old .and. works as before, and .andthen. short-circuits the conditional. I opened up #19 for this new proposal.\n(There is also an option to make .andthen. just .and., the argument pro is that it does not introduce any new syntax, but one argument against it is that it would change the current freedom for compilers to re-arrange logical expressions -- either way this can be discussed at #19.)"
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2019-10-16 15:51:08+00:00",
            "title": "Enumeration Type",
            "text": "This proposal is split into several papers, all under consideration:\nhttps://j3-fortran.org/doc/year/19/19-230r2.txt (Formal Requirements)\nhttps://j3-fortran.org/doc/year/19/19-231r2.txt (Formal Specifications)\nhttps://j3-fortran.org/doc/year/19/19-232.txt (Formal Syntax), new syntax paper: https://j3-fortran.org/doc/year/19/19-249.txt",
            "is_open": true,
            "labels": [
                "in progress",
                "Fortran 2023",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-18 15:31:49+00:00",
                    "text": "Latest syntax paper: https://j3-fortran.org/doc/year/19/19-249r1.txt\nThe main feedback from the committee is to include code examples in the use cases, so that we can better discuss the details of the proposal."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-26 20:41:23+00:00",
                    "text": "Here're the documents referenced in that first paper above that is labeled 19-230 on \"Formal Requirements\" toward enumeration types.  19-230 was discussed at the recent J3 committee meeting and the document 19-230r2 is the last revision of it from that meeting.\n\n19-216r1 Enumeration types [US21]\n18-256r1 enums\n18-114r1 Enumeration types"
                },
                {
                    "user": "certik",
                    "date": "2021-02-23 23:05:04+00:00",
                    "text": "New specs and syntax: https://j3-fortran.org/doc/year/21/21-110.txt"
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2019-10-16 15:16:45+00:00",
            "title": "Update the namepace modules paper for upload",
            "text": "The paper is now uploaded:\nhttps://j3-fortran.org/doc/year/19/19-246.txt",
            "is_open": false,
            "labels": [],
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2019-10-16 14:57:27+00:00",
            "title": "Automatically allocate character variable in read statement",
            "text": "Ability to write arbitrary long lines from files to avoid MAX_LINE_LENGTH etc. Should be possible with allocatable character variable. Asked by Pierre de Buyl. More details below.\nSimilar thing for allocatable array, per a comment below.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Clause 12"
            ],
            "comments": [
                {
                    "user": "pdebuyl",
                    "date": "2019-10-16 16:22:15+00:00",
                    "text": "In this example program, I set an arbitrary value MAX_LINE_LENGTH.\nprogram read_lines\n  implicit none\n\n  type string_t\n     character(len=:), allocatable :: s\n  end type string_t\n\n  integer, parameter :: MAX_LINE_LENGTH=32\n  integer :: i, u, n_lines\n  character(len=MAX_LINE_LENGTH) :: current_line\n  type(string_t), allocatable :: lines(:)\n\n  write(*,*) 'Number of lines to read?'\n  read(*,*) n_lines\n\n  open(newunit=u, file='lines.txt')\n\n  allocate(lines(n_lines))\n\n  do i = 1, n_lines\n     read(u, '(a)') current_line\n     lines(i)%s = trim(current_line)\n  end do\n\n  do i = 1, n_lines\n     write(*,'(a)') lines(i)%s\n  end do\n\nend program read_lines\nIdeally, I could replace this with an \"allocation on read\". The syntax below is just an example, of course.\nprogram read_lines\n  implicit none\n\n  type string_t\n     character(len=:), allocatable :: s\n  end type string_t\n\n  integer :: i, u, n_lines\n  type(string_t), allocatable :: lines(:)\n\n  write(*,*) 'Number of lines to read?'\n  read(*,*) n_lines\n\n  open(newunit=u, file='lines.txt')\n\n  allocate(lines(n_lines))\n\n  do i = 1, n_lines\n     read(u, '(a)', alloc_on_read=.true.) lines(i)%s\n  end do\n\n  do i = 1, n_lines\n     write(*,'(a)') lines(i)%s\n  end do\n\nend program read_lines"
                },
                {
                    "user": "certik",
                    "date": "2019-10-16 17:05:58+00:00",
                    "text": "@pdebuyl thank you. I think the proposal is for read() to automatically allocate your string variable to hold the full line, correct? I changed the title of the issue appropriately.\nLet me discuss this with the members of the committee and see if this has a chance of getting in, and if so, write a paper for this."
                },
                {
                    "user": "certik",
                    "date": "2019-10-16 23:40:19+00:00",
                    "text": "Here is a similar idea applied to a related problem: https://j3-fortran.org/doc/year/19/19-252.txt."
                },
                {
                    "user": "pdebuyl",
                    "date": "2019-10-17 07:52:10+00:00",
                    "text": "@certik Yes, the usage I have in mind is specifically for read statements.\nIn \"J3/19-252\", the automatic allocation is planned for error messages and function return values. I think that my proposal would come in addition to it."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 18:36:00+00:00",
                    "text": "@pdebuyl yes, your proposal would be in addition to it. I posted it as an example that your proposal is not something unprecedented."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-02 19:41:31+00:00",
                    "text": "VAX Fortran had an additional 'Q' descriptor that caused an integer variable to be assigned the length of the input line:\ncharacter*80 buffer\ninteger length\n\nread(u,'(Q,A)') length, buffer\n\nThe purpose of this extension was to solve the problem of dealing with trailing blanks, i.e. to distinguish between trailing blanks of the empty buffer and those which are actually written in the file. The length variable would contain the length of what was actually read, discounting carriage control characters.\nIt would also be convenient to have this functionality for reading from standard input. The case of trailing blanks should be handled as well (see related question here)."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-01-14 17:04:27+00:00",
                    "text": "@certik.\nFyi, you may have noticed the second-most popular item on the user feedback in 2017 to the WG5 survey for Fortran 2020 feature set was \"Automatic Allocation on READ into ALLOCATABLE character or array\".  That item looks very much similar to your proposal here.\nSome questions: the survey feedback item lists \"ALLOCATABLE character\" or \"ALLOCATABLE array\".  Would you consider both for your proposal or just the character type?  If both, would you lean toward opening a separate issue for ALLOCATABLE array or modify this one along the lines of the survey item?\nThanks,"
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 17:33:11+00:00",
                    "text": "@FortranFan thanks. For now I just put a comment in the issue description above. Once somebody starts drafting a proposal for this, we can decide if we should split it into two, or put everything into just one proposal."
                },
                {
                    "user": "qolin1",
                    "date": "2020-01-15 20:16:01+00:00",
                    "text": "There is a current thread in comp.lang.fortran that discusses this,\nhttps://groups.google.com/forum/#!topic/comp.lang.fortran/9_0q0dBRzpk\nThe discussion starts off talking about stack sizes, but later (message of Ian Harvey, 9 jan) it verges into this proposal. Ian and Ron Shepard have an interesting exchange, wherein Ian expands on some of the problems it would cause. Alas I expect the Fortran standards committee will do the same, because AFAICS the problems are very real."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-02-03 03:11:04+00:00",
                    "text": "Are you looking to just be able to read a line of arbitrary length into a CHARACTER variable or looking to be able to read other arrays like an arbitrary number of numeric values?  Is this something like\nhttp://fortranwiki.org/fortran/show/readline\nor something like the routines in\nhttps://urbanjost.github.io/general-purpose-fortran/download/tmp/html/man3.html in the M_io module that read a file or numeric table into an array?\nI started looking at the discussion referenced above but it drifts thru quite a few topics."
                }
            ]
        },
        {
            "number": 8,
            "user": "certik",
            "date": "2019-10-16 06:24:59+00:00",
            "title": "Initial proposal for namespace for modules",
            "text": "Work on #1.\n@zingale, I talked about this with a few committee members, and they recommended to start collecting use cases first, then see what the reaction of the committee is, then go from there. So this is my initial draft, that I would like to submit tomorrow (the committee meeting is till this Friday). Do you have some use cases that I didn't mention in the proposal?",
            "is_open": false,
            "labels": [
                "unsubmitted",
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "zingale",
                    "date": "2019-10-16 12:42:37+00:00",
                    "text": "I think that looks great.  Both avoiding name clashes and making it easier to understand where a function / data is coming from are my motivation for wanting namespaces."
                },
                {
                    "user": "certik",
                    "date": "2019-10-16 15:06:42+00:00",
                    "text": "Thanks @zingale. I am going to merge this one and submit the paper."
                }
            ]
        },
        {
            "number": 7,
            "user": "zjibben",
            "date": "2019-10-16 04:41:33+00:00",
            "title": "Issue Labels",
            "text": "Should we have labels for stages of various issues? The readme suggests we'll be tracking proposals through to final standardization, or rejection. Labels along the lines of \"unsubmitted\", \"accepted\", \"rejected\", \"under consideration\", \"on hold\", and maybe \"in progress\" would help organize this. And perhaps a \"meta\" label for issues related to this repo. I imagine \"accepted\" and \"rejected\" labels would only be used for closed issues.",
            "is_open": false,
            "labels": [
                "meta"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-16 04:43:43+00:00",
                    "text": "I think that's a great idea. Go ahead and create such labels.\n\u2026\nOn Tue, Oct 15, 2019, at 9:41 PM, Zach Jibben wrote:\n Should we have labels for stages of various issues? The readme suggests we'll be tracking proposals through to final standardization, or rejection. Labels along the lines of \"unsubmitted\", \"accepted\", \"rejected\", \"under consideration\", \"on hold\", and maybe \"in progress\" would help organize this. And perhaps a \"meta\" label for issues related to this repo. I imagine \"accepted\" and \"rejected\" labels would only be used for closed issues.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub <#7>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGF4PF42ZOAWBHYECTQO2LP3ANCNFSM4JBGCBGA>."
                },
                {
                    "user": "zjibben",
                    "date": "2019-10-16 15:20:01+00:00",
                    "text": "I added labels and assigned them to existing issues, feel free to modify as needed."
                },
                {
                    "user": "pdebuyl",
                    "date": "2019-10-16 16:23:01+00:00",
                    "text": "What does \"unsubmitted\" mean?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-16 16:40:05+00:00",
                    "text": "@pdebuyl I just added a remark for the label (\"Has not been submitted to the committee yet\")."
                },
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:17:32+00:00",
                    "text": "You might want to pin this issue; or a similar one discussing labeling."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-27 21:32:08+00:00",
                    "text": "Now that we have the meta label, we don't need [META] in meta issue titles, correct? I did some tidying up with meta labels, then stumbled upon this. I'll revert if you disagree."
                },
                {
                    "user": "certik",
                    "date": "2019-10-27 21:58:30+00:00",
                    "text": "That's fine with me, you can remove the [META] label."
                },
                {
                    "user": "Leonard-Reuter",
                    "date": "2020-06-04 16:08:55+00:00",
                    "text": "What about adding labels for different types of proposals (i.e. 'syntactic sugar', 'C interoperability', 'coding convention', 'efficiency improvement', 'new feature', 'enhanced feature'...)? In a way, this has already been done with the 'meta' label."
                },
                {
                    "user": "certik",
                    "date": "2022-04-23 20:07:46+00:00",
                    "text": "We have issue labels now, so I am going to close this issue."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2019-10-16 04:10:09+00:00",
            "title": "Better error handling",
            "text": "A common request is to improve how error handling is done.\nWhether exceptions, or some other mechanism.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Clause 11"
            ],
            "comments": [
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:20:52+00:00",
                    "text": "I often roll-my-own error stack, which is a pain, but let's you pass it in to elemental and pure procedures. It would be nice to have at least a pre-defined object with similar capabilities---something that can carry around state and provenance of errors so that computationally intensive code regions can remain pure/elemental etc. and don't need to interact or abort on errors, but can pass back meta data about when and where an error occurred.\nAlso, the try...except syntax convention of other languages feels natural and appeals to me."
                },
                {
                    "user": "milancurcic",
                    "date": "2019-10-17 17:30:11+00:00",
                    "text": "Relevant: https://j3-fortran.org/doc/year/19/19-224.pdf\nI am not convinced that the proposed solution is a step in the right direction. Specifically:\n\nDetection of all exceptions that are identified by enumerators of the type EXCEPTION defined in the intrinsic module ISO_FORTRAN_ENV, is always enabled.\n\nThis approach necessarily implies that every statement runs (internally) in an if/then/goto block, a common criticism of try/except in Python, for example. There are many applications (most HPC software) in which exception handling would be preferred to be disabled by the user in production.\nFurther, the example (Section 6) seems to me as verbose as if it was handled with C-style exception handling, but with new syntax for the programmer to learn."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 17:37:47+00:00",
                    "text": "@milancurcic yes, the most common objection from the committee is that exception handling like that can easily cause missed optimization opportunities, and thus any proposal that could be put forward should not hamper performance.\nThe syntax issue you mention is also a problem. Another issue is what kind of exceptions should be handled, and whether floating point exceptions fall in that category."
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2019-10-16 04:06:12+00:00",
            "title": "Allowing \"const\" on pointed to data",
            "text": "Currently one can enforce \"const\" using intent(in) for the pointer itself, but not the data it points to. One request we got was to also allow enforcing \"const\" on the data itself.",
            "is_open": true,
            "labels": [
                "Fortran 2023",
                "Clause 8"
            ],
            "comments": [
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:23:40+00:00",
                    "text": "In what context? Are you referring to the actual arguments associated with procedure dummy arguments? The current semantics of intent(in) on pointers gives a lot of flexibility and I would be upset if it was simply extended to apply to the target as well as the pointer allocation/association status."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 17:22:45+00:00",
                    "text": "I am just relying a request that we got: my understanding of the request was some mechanism to (optionally) request also const on the pointed to data, not that intent(in) was simply extended to apply to the target as well.\nThe answer might still be no."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-18 14:36:19+00:00",
                    "text": "I don't see very many cases where this would be useful. If you are using intent(in) then you can't change the destination of the pointer and all that is available is to enquire about it's association status or to use it as a target. The latter could be achieved while keeping the value itself constant by changing the variable attributes to target, intent(in). The remaining case of checking association status does not seem particularly useful to me. I suppose it could allow the pointer to be used in a way sort of like an optional value, with the procedure using its value if it is associated and otherwise using a default. However, that would certainly not be worth losing the flexibility the current behaviour gives. Maybe it would be worth adding some additional intent (e.g., fixed or const), which wouldn't do any harm, but I can't see a huge amount of benefit either."
                },
                {
                    "user": "zjibben",
                    "date": "2019-10-21 16:19:39+00:00",
                    "text": "The way I understood the request was that it was loosely related to #16. As it stands, there's no way to pass a read-only pointer or target into a function--the data is always mutable when it gets one of those attributes. But you might want to share a data pointer or target without sharing write access. I don't think the suggestion was to modify current behavior of pointer or target, just to offer some kind of mechanism to safeguard against unwanted modification. The protected attribute referenced in #16 gives read-only access to non-pointer data, but pointer data is still mutable."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-21 21:15:04+00:00",
                    "text": "Is it the case that one can change the value of arguments with intent(in)\nbut the target attribute? I was not aware of that. What is the reason for\nit?\n\u2026\nOn Mon, 21 Oct 2019, 17:19 Zach Jibben, ***@***.***> wrote:\n The way I understood the request was that it was loosely related to #16\n <#16>. As it\n stands, there's no way to pass a read-only pointer or target into a\n function--the data is always mutable when it gets one of those attributes.\n But you might want to share a data pointer or target without sharing write\n access. I don't think the suggestion was to modify current behavior of\n pointer or target, just to offer some kind of mechanism to safeguard\n against unwanted modification. The protected attribute referenced in #16\n <#16> gives\n read-only access to non-pointer data, but pointer data is still mutable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#5?email_source=notifications&email_token=AB6ESPN2E5DYVHLHQV5L36TQPXJBZA5CNFSM4JBF3PVKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEB25CXI#issuecomment-544592221>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPLKMTIBJXDLQR5XF3TQPXJBZANCNFSM4JBF3PVA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 23:28:27+00:00",
                    "text": "This was submitted as https://j3-fortran.org/doc/year/18/18-144r1.txt, and also there is a new proposal on the way."
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 15:22:09+00:00",
                    "text": "@klausler had a nice draft of how this can work including syntax. Peter, do you recommend to base the new paper for the next meeting off of your draft, or start from 18-144r1?"
                },
                {
                    "user": "tclune",
                    "date": "2020-03-02 16:04:40+00:00",
                    "text": "Tuning in late.   For those that don't want to read the paper cited above, I want to point out that the initial part of the thread was on the wrong track.    The idea is not to change the existing implications of INTENT for dummy pointer arguments, but rather to allow additional specification for the TARGET.     The usual case would presumably be to prevent a subroutine from altering the values of the target.\nThis could be either by something like\nreal, pointer, INTENT(IN), TINTENT(IN) :: x\nor\nreal, pointer, INTENT(IN,TARGETIN) :: x\nI'm increasingly in favor of an entirely different approach which would be more general.  Namely, a feature that would allow declaring a pointer for which one cannot modify the target through that pointer.   This is roughly analogous to a const pointer in C.  And it could be used beyond dummy arguments."
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 16:11:08+00:00",
                    "text": "@tclune thanks for the clarification. Yes, I think the feature that people asked me to advocate for is something like real, pointer, INTENT(IN,TARGETIN) :: x, as you mentioned. (Update: although as Zach mentions below, it's possible the more general feature is in fact what they asked us for.)\nWhy don't you open a new issue for the more general \"const pointer\" approach? Let's discuss it there."
                },
                {
                    "user": "zjibben",
                    "date": "2020-03-02 16:16:39+00:00",
                    "text": "@tclune this more general approach would be great. I know multiple teams at LANL are very interested in such a feature. In fact it's possible that's what was intended by this issue, given that it derived from conversations with people at LANL."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-03-02 17:01:45+00:00",
                    "text": "@certik wrote:\n\n@tclune , ..\nWhy don't you open a new issue for the more general \"const pointer\" approach? Let's discuss it there.\n\nFortran has named constants which it attributes as PARAMETERs and which can go into the READONLY area of a program memory and be absolutely immutable from compile-time onward.  But then Fortran also has PROTECTED attribute  for which a module scope comes into play in terms of being definable/modifiable.  With pointers, the scope of the target cannot be limited to a particular module and it can very well be global.\nSo for a more general feature, perhaps Fortran can consider the notion of, say:\n  <some type>, POINTER, CONST_TARGET :: foo\nthat can apply to dummy arguments as well as variables?  And the semantics can be the same (or very similar) to \"constant pointers\" in C?\nAnd for generality, it will be convenient if named constants can take the TARGET attribute with the restriction only constant pointers can point to them.  There have been discussions on comp.lang.fortran where Fortran practitioners have expressed a strong interent in being able to point constant pointers to constant targets such as named constants."
                },
                {
                    "user": "tclune",
                    "date": "2020-03-02 17:36:41+00:00",
                    "text": "@tclune thanks for the clarification. Yes, I think the feature that people asked me to advocate for is something like real, pointer, INTENT(IN,TARGETIN) :: x, as you mentioned. (Update: although as Zach mentions below, it's possible the more general feature is in fact what they asked us for.)\nWhy don't you open a new issue for the more general \"const pointer\" approach? Let's discuss it there.\n\nI'm not so certain a new issue is warranted.   The title of this issue seems quite appropriate.   Indeed, a better argument could be made to open a new issue that restricts the discussion to just dummy pointers."
                },
                {
                    "user": "certik",
                    "date": "2020-03-02 20:19:20+00:00",
                    "text": "Thanks Peter. @tclune that's fine, we can discuss both proposals here."
                },
                {
                    "user": "aradi",
                    "date": "2021-11-25 10:46:48+00:00",
                    "text": "Is there any progress here? Maybe, the following example may serve as a further argument, why the target-constantness should be considered by the language in some form. Currently, you can easily change intent(in) dummy arguments within a subroutine:\nmodule test\n  implicit none\n\ncontains\n\n  subroutine sub1(val)\n    integer, target, intent(in) :: val\n    call sub2(val)\n  end subroutine sub1\n\n  subroutine sub2(ptr)\n    integer, pointer, intent(in) :: ptr\n    ptr = 42\n  end subroutine sub2\nend module test\n\nprogram testprog\n  use test\n  implicit none\n\n  integer :: val = 0\n  print *, \"VAL BEFORE:\", val  !<-- prints \"0\"\n  call sub1(val)\n  print *, \"VAL AFTER :\", val   !<-- prints \"42\"\n\nend program testprog\nI am kind of inclined to think, that is is more a bug than a feature of the language."
                },
                {
                    "user": "sblionel",
                    "date": "2021-11-26 01:46:56+00:00",
                    "text": "At the October 2021 meeting, J3 voted to ask WG5 to drop \"pointer intent\" from 202X, with the hope of getting it in for 202Y. There has been lots of discussion, but time ran out on coming up with a solid proposal. I do think that most members are aligned on what is ultimately wanted. See https://j3-fortran.org/doc/year/21/21-195.txt"
                },
                {
                    "user": "aradi",
                    "date": "2021-11-26 07:10:08+00:00",
                    "text": "@sblionel Thanks for the feedback. It is promising, that at least there seems to be consensus, that this should be considered in some form. \ud83d\ude04"
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2019-10-16 03:40:07+00:00",
            "title": "Templates for functions/subroutines",
            "text": "A very common request is to allow templates for subroutines or functions, in order to allow code like the following:\n    <T> function f(x)\n    <T>, intent(in) :: x\n    f = x + 1\n    end function\ninstead of\ninterface f\n    module procedure f_int\n    module procedure f_single\n    module procedure f_double\nend interface\n\ncontains\n\n    integer function f_int(x) result(f)\n    integer, intent(in) :: x\n    f = x + 1\n    end function\n\n    real function f_single(x) result(f)\n    real, intent(in) :: x\n    f = x + 1\n    end function\n\n    real(dp) function f_double(x) result(f)\n    real(dp), intent(in) :: x\n    f = x + 1\n    end function\nMore use cases available at https://github.com/certik/fortran-generics.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Fortran 202y",
                "Clause 15"
            ],
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-17 14:44:51+00:00",
                    "text": "I have written a proposal on templates that uses a very different approach. It was inspired by a note on the subject of generic programming features already in Fortran (to be published with ACM Fortran Forum, but a draft can be found at http://flibs.sourceforge.net/generic_programming_features.pdf). I will add the note as a new issue."
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 15:09:06+00:00",
                    "text": "@arjenmarkus thank you, that would be great if you send it. There are a lot of approaches here, and the committee is looking at all approaches and it wants to get something done for 202y (the standard that comes after 202x, which will be the next standard)"
                },
                {
                    "user": "certik",
                    "date": "2019-10-17 16:10:51+00:00",
                    "text": "@arjenmarkus your pdf references the paper from Magne Haveraaen, who sits next to me right now. We'll discuss your paper today and I'll report back."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2019-10-17 20:44:43+00:00",
                    "text": "Small world :).\n\nRegards,\n\nArjen\n\nOp do 17 okt. 2019 om 18:10 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n @arjenmarkus <https://github.com/arjenmarkus> your pdf references the\n paper from Magne Haveraaen, who sits next to me right now. We'll discuss\n your paper today and I'll report back.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#4?email_source=notifications&email_token=AAN6YR6FS6TXJRCF3XIORLTQPCFAZA5CNFSM4JBFWSXKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBQVAQQ#issuecomment-543248450>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7O7Q2NYEBKG5L2M5DQPCFAZANCNFSM4JBFWSXA>\n ."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-18 14:49:39+00:00",
                    "text": "I agree that templates are desperately needed. They should be applied to derived types as well as to procedures. I remember coming across a proposal from some time ago for \"parameterised modules\", which I thought looked quite promising, but nothing ever came of it I guess. (I see you have an example of something like that in your fortran-generics repository and it is by far the cleanest syntax of those you show).\nI will say that I'm rather tired of the committee perpetually pushing this onto the standard after next. The two most recent releases have been relatively minor revisions, so it's not as though the decision was made to focus elsewhere. People have been wanting this feature for years and it really is crippling to development. If this is pushed back until 202y then we likely won't see widespread compiler support until the 2030s. We'd almost be better off trying to back a newer language like Chapel, which does include these features, in that case."
                },
                {
                    "user": "certik",
                    "date": "2019-10-18 15:25:03+00:00",
                    "text": "@cmacmackin thanks for the feedback here and the other issues, we really appreciate it. I am new to the committee, this is my second meeting. I am still learning about what the committee did in the past and the history behind various proposals. The way I see it is that this is a requested feature, and we should try to get it right and included. If the committee wasn't moving as fast in the past, then here is what we can all do to help:\n\n\nJoin the committee (like I did --- if you can at all, please join, so that you can help push these proposals forward)\n\n\nHelp us figure out a good way to do generics in Fortran, then help us write a good proposal, and help us advocate for it\n\n\nTo help with 2., I created this repository, and we are trying to keep it updated with the proposals that the committee is considering. Regarding generics in particular, I will keep updating this issue on the latest status. This will go into 202y, as we do not have any good proposal that is ready to go into 202x, and it is important to get this right. The committee needs help, and my experience with organizing open source communities such as SymPy makes me hopeful that opening up the commitee's work to the wider community will allow us to organize ourselves more efficiently. If you have other ideas what the committee can do to improve, please let us know."
                },
                {
                    "user": "marshallward",
                    "date": "2019-10-19 19:29:44+00:00",
                    "text": "Templating would strongly support our current development efforts at GFDL.  I am a contributor to the FMS framework used by weather and climate models at GFDL (including my main job of MOM6 development), and it relies heavily on preprocessing of template-like code for many interface functions, such as for MPI operations.\nSome example code is below, where a file is #included multiple times, each time replacing MPP_TYPE_ and similar macros with different types, size, and rank (scalar, 2d, 3d, etc.):\n\n\nInterface definitions:\nhttps://github.com/NOAA-GFDL/FMS/blob/2cd5dc6dc601c1238bbabdf1440b2057f957795b/mpp/mpp.F90#L680-L725\n\n\nRepeat #include statements of the above functions\nhttps://github.com/NOAA-GFDL/FMS/blob/2cd5dc6dc601c1238bbabdf1440b2057f957795b/mpp/include/mpp_comm_mpi.inc#L1033-L1159\n\n\nThe low-level call to MPI:\nhttps://github.com/NOAA-GFDL/FMS/blob/master/mpp/include/mpp_sum_mpi.h\n\n\nMid-level interface for different array ranks:\nhttps://github.com/NOAA-GFDL/FMS/blob/master/mpp/include/mpp_sum.inc\n\n\nThis does work, and has worked for a long time, but it's a lot of bloat and gets even more complicated when trying to manage some of the conditional support for things like complex numbers and non-default kinds for integers or reals.\nI feel like this must be a common problem, and it would be great to find a template-like solution which can unify this sort of code."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-19 21:04:51+00:00",
                    "text": "@cmacmackin thanks for the feedback here and the other issues, ..\n\nThanks to @cmacmackin  for frank comments.\n@certik, it'll be most useful and beneficial if there is a way to (almost) force WG5 and ALL its member body representatives to read user feedback.  You may note your great initiative for GitHub Fortran proposals was immediately noticed online e.g., comp.lang.fortran - see this thread there:\nAnd some of the comments there:\n\n\"Personally, it's very sad that various features are postponed or even rejected for this round of revision (which may be reasonable for the committee for various reasons), and I'm (very personally) sad that a builtin \"string\" type seems not considered even as a revision candidate\n\"in 2019, people will use C++ instead\"\n\"Exception handling was planned to be introduced in Fortran 90 (called then Fortran 8X) but was rejected due to complexity. Since then, this feature has been proposed several times but never accepted.\"\n\"I was expecting that these two features (at least, generic programming) were the main target of F202X (according to the last survey and some documents available online).\"\n\"my question is: What is the set of \"most compilers\" supposed in ..?\"  That is, in WG5 papers N2167 and N2168\n\"My concern is that some compilers seem very slow to catch up with new features. Initially, I imagined that this may be due to the difficulty of implementation. But more recently, I strongly feel that this is also due to the policy or direction of a company (e.g., investment). If the latter is a more major factor for one compiler, I am afraid that \"waiting for most compilers to catch up\" could mean \"forever\" in practice...\"\n\nThere is a lot to learn from the comments by practitioners of Fortran."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-19 21:48:58+00:00",
                    "text": "A very common request is to allow templates for subroutines or functions, in order to allow code like the following:\n    <T> function f(x)\n    <T>, intent(in) :: x\n    f = x + 1\n    end function\n\ninstead of\ninterface f\n    module procedure f_int\n    module procedure f_single\n    module procedure f_double\nend interface\n\ncontains\n\n    integer function f_int(x) result(f)\n    integer, intent(in) :: x\n    f = x + 1\n    end function\n\n    real function f_single(x) result(f)\n    real, intent(in) :: x\n    f = x + 1\n    end function\n\n    real(dp) function f_double(x) result(f)\n    real(dp), intent(in) :: x\n    f = x + 1\n    end function\n\nMore use cases available at https://github.com/certik/fortran-generics.\n\nConsidering the semantics and syntax for generic interfaces were introduced way back in Fortran 90 and were simplified further in the latest 2018 revision as follows:\n  generic :: f => f_int, f_single, f_double\n\ncontains\n\n  integer function f_int(x) result(f)\n     integer, intent(in) :: x\n     f = x + 1\n  end function\n\n  real function f_single(x) result(f)\n     real, intent(in) :: x\n     f = x + 1\n  end function\n\n  real(dp) function f_double(x) result(f)\n     real(dp), intent(in) :: x\n     f = x + 1\n  end function\n\nand keeping in mind how much of the semantics for PGAS SPMD approach toward parallel computing was achieved using [..] notation in COARRAYS. a key aspect to deduce perhaps is the importance of conveying semantics via syntax and focusing on the latter.  Sure this can run counter to the current work process of Fortran standard development: get the use cases, generate requirements, then develop specifications, and finally the syntax.  For concepts that are well-established in computer engineering widely such as generics and that are so well-known now and where every new language that crops up has sophisticated support for generics from the get-go or soon thereafter (e.g., Julia and Haskell), may be the approach should be the other way around?  Settle on syntax that conveys to the coders and processors of Fortran all they need and allow the semantics to simply fall out of that?\nSay the language introduces an attribute 'TYPE' with the existing statement of GENERIC: why can't the following convey for a processor everything it needs to setup generic interfaces for the 3 types shown in the original post here?\n  function f(x) result(r)\n     generic, type :: T => int, real, real(dp)\n     type(T), intent(in) :: x\n     type(T) :: r\n     x = x + 1 \n  end function\n\nIs committee overthinking this and needlessly procrastinating the development of generics in Fortran?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 22:53:11+00:00",
                    "text": "@marshallward thanks for the feedback! Yes, every code has an MPI layer like yours and we all struggle with the lack of templates for this one. We might not need full templates for this one, perhaps just some better way to handle arbitrary arrays and types. But the committee is well aware of this use case, as almost any parallel Fortran MPI code faces the exact same issue.\nI will keep you involved on this effort if you are interested. Tom Clune is leading this template effort, he will send instructions soon and I will update this issue once he does."
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 22:59:19+00:00",
                    "text": "@FortranFan thanks for the encouragement. If you don't mind, why don't you open a new issue or new issues, put [META] in the title and let's discuss there how to best organize ourselves. So that we can keep issues like this one for pure technical content regarding this particular issue."
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 23:37:43+00:00",
                    "text": "@FortranFan I created the meta issue at #26. Let's discuss the workflow there."
                },
                {
                    "user": "marshallward",
                    "date": "2019-10-21 14:21:19+00:00",
                    "text": "@certik Thanks, I am very interested to hear about progress on this issue.  I was not sure how to best use these GitHub issues, but hoped that pointing to additional example might help in some small way.\nThanks as well for creating this repo, I hope it will help to streamline the process for working with the J3 committee!"
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 18:24:45+00:00",
                    "text": "@marshallward you are welcome. I am excited that people want to collaborate this way.\n@tclune is leading an effort on templates. He just posted instructions how people can get involved:\nhttps://mailman.j3-fortran.org/pipermail/j3/2019-October/011704.html\nTom, do you want to take it from here and coordinate with all the people who expressed interest in this thread?"
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 18:33:51+00:00",
                    "text": "One idea how you can collaborate on this is to use @tclune's repository to work deeply on the various ideas, and then we can use this https://github.com/j3-fortran/fortran_proposals repository to just keep track of a summary as well as how each template proposal goes through the committee."
                },
                {
                    "user": "certik",
                    "date": "2019-11-05 19:52:12+00:00",
                    "text": "@klausler this is an interesting idea, different from any other idea so far proposed (we discussed parametrized modules before, but not in this way). It deserves its own issue, so I created #74 for this."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-09 19:34:18+00:00",
                    "text": "I'm curious to know why the template work repo is under a different GitHub account? Not a good sign for the future... Why not put it here on the j3-fortran one?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-09 21:26:26+00:00",
                    "text": "@jacobwilliams The repository that I linked to (https://github.com/certik/fortran-generics) was created long before this j3-fortran GitHub repository. So I just linked it. As we develop these ideas more, it should all happen here.\nIf you are talking about @tclune's repository at https://github.com/sourceryinstitute/generics, that repository was created by @tclune to more efficiently collaborate just on templates. As they make progress, I will make sure to update this j3-fortran repository with any big updates and proposals."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-09 22:13:49+00:00",
                    "text": "I was referring to the sourceryinstitute one. It just seems like it makes more sense to put that here."
                },
                {
                    "user": "certik",
                    "date": "2019-11-09 23:49:29+00:00",
                    "text": "@jacobwilliams Yes, it would be nice to at least have the discussions here, and we can also move the repository under the j3-fortran github group."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-11 15:37:10+00:00",
                    "text": "Just to add another proposal to the mix...\nAs I've reflected upon previously, one of the issues with templates in Fortran is how the type system really consists of four different aspects:\n\nType (e.g., real, integer, a derived type, etc.)\nKind (how values are stored in memory)\nRank (the number of dimensions of an array)\nSize/length (the number of elements in each dimension of an array, or the number of characters in a string)\n\nIn most programming languages these would all be grouped together to define a single type, but in Fortran they are semi-independent.  What's more, there are different approaches for what needs to be known at compile-time and what can be deferred to run-time. At one extreme is kind, which must be known at compile-time (even for parameterised derived types), and at the other is size/length, which can be deferred to run-time via allocatable and assumed-shape variables.\nIn C++ a single brief string can specify all of this information (e.g., double[10][20]), making it easy to template over all of it at once. In Fortran this would be more difficult. Currently, parameterised derived types (PDTs) attempt to provide some features along these lines for kind and size. While I haven't personally made use of them, its approach to parameterising size actually looks pretty good. However, parameterising kind is not very useful because all kinds must be known at compile-time. This means that we can't defer the kind until run-time, even for dummy arguments of procedures. It is this last bit which is really crippling, because it means that the user must write separate implementations of a procedure for each kind parameter value, making PDTs essentially worthless.\nIt would be nice if a new templating system could both fix this shortcoming and build on the current PDT syntax. I think there could be a relatively straightforward way to achieve the first of these: the introduction of parameterised procedures. The syntax could be something like the following:\nsubroutine example(a, b, c) parameters(k, l)\n  integer, kind :: k\n  integer, len :: l\n  real(k), dimension(l), intent(in) :: a, b\n  real(k), dimension(2*l), intent(out) :: c\n  \n  c(1:l) = a\n  c(l+1:2*l) = b\nend subroutine example\nType-bound procedures, finalisers, and abstract interfaces can also be made parameterised, allowing PDTs to be used in object-oriented manner. Unlike with PDTs, where the kinds get specified by the user when declaring a variable (or revert to a default value), for parameterised procedures the compiler would be required to determine the parameter values from the arguments which are passed in. If they are invalid (e.g, if the above subroutine were called with inconsistent kinds) then it should produce a compile-time error or (for len parameters, where this may not be possible) a run-time error.\nIt would then just be a matter of defining two additional sorts of type/procedure parameters, corresponding to type and rank. The exact syntax of this is a matter for further discussion, especially with regards to rank where I can't see an obvious approach. For types it could look something like this:\nsubroutine example(a, b, c) parameters(t, k, l)\n  typespec :: t\n  integer, kind :: k\n  integer, len :: l\n  t(k), dimension(l), intent(in) :: a, b\n  t(k), dimension(2*l), intent(out) :: c\n  \n  c(1:l) = a\n  c(l+1:2*l) = b\nend subroutine example\nIt might be possible to restrict the type-spec somewhat by allowing some sort of \"concepts\" or \"typeclasses\" to be defined in advance, as suggested by @arjenmarkus in #29."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-11 17:59:46+00:00",
                    "text": "Yes it would and more concisely. The reason I'm proposing parameterising\nprocedures is it would fit in better with the existing parameterised\nderived types. If you parameterised the module as well as derived types,\nthen that would create the question of which should be used.\n\u2026\nOn Mon, 11 Nov 2019, 17:37 Peter Klausler, ***@***.***> wrote:\n @cmacmackin <https://github.com/cmacmackin> Would a parameterized *module*\n facility cover the same use cases?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#4?email_source=notifications&email_token=AB6ESPLDW3JRXZYJREKAIUTQTGJ4FA5CNFSM4JBFWSXKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEDXRSVY#issuecomment-552540503>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AB6ESPJS2PSHFYVJSOWULIDQTGJ4FANCNFSM4JBFWSXA>\n ."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2019-11-11 18:30:08+00:00",
                    "text": "Can't we all just pretend PDTs never happened. I know I have. \ud83d\ude06"
                },
                {
                    "user": "aradi",
                    "date": "2019-11-19 15:26:12+00:00",
                    "text": "@cmacmackin  I like your approach a lot, as it looks like an extension of the parameterized types.\nWhat is not clear to me (in none of the presented approaches), in what scope the generated routines will be embedded? Do they have their own scope? How do we pass operators (e.g. assignment) if they are not implemented as type bound procedures?\nGiven the following hypothetical code:\nmodule testmod\ncontains\n\n  subroutine swap(a, b) generators(T, R)\n    generator, type :: T\n    generator, rank :: R\n    T, dimension(R), intent(inout) :: a, b\n\n    T, dimension(R), allocatable :: buffer\n\n    allocate(buffer, mold=a)\n    buffer = a\n    a = b\n    b = buffer\n\n  end subroutine swap\n\nend module testmod\n\n\nmodule typedef\n\n  type :: mytype\n    integer :: a\n  end type mytype\n\n  interface assignment(=)\n    module procedure assign_mytype\n  end interface assignment(=)\n\ncontains\n\n  subroutine assign_mytype(a, b)\n    type(mytype), intent(inout) :: a, b\n    a%a = b%a\n  end subroutine assign_mytype\n\nend module typedef\n\n\nprogram testprog\n  use testmod\n  use typedef\n  implicit none\n\n  integer :: a(:,:), b(:,:)\n  type(mytype) :: ta, tb\n\n  call swap(a, b)    ! should generate swap with T=integer, R=2, everything OK.\n  call swap(ta, tb)  ! Would it call assign_mytype at assignment???\n\nend program testprog\n\nWould it be possible, that the swap() routine calls the user defined assignment? How do we achieve that?\nI think, it would be nice, if we could come up with a simple example (like the swap above) as a proof-of-concept test for generics. Then, every suggested approach should show how it would deal with it, so that we can discuss possible pitfalls more concrete."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-19 23:15:52+00:00",
                    "text": "What is not clear to me (in none of the presented approaches), in what scope the generated routines will be embedded? Do they have their own scope? How do we pass operators (e.g. assignment) if they are not implemented as type bound procedures?\n\nDoes anyone know how other languages handle this? Here is one approach I've seen: https://nim-lang.org/docs/manual.html#generics-symbol-lookup-in-generics. So the Fortran equivalent would be for any generic interface identifier to wait to be bound until the function is called, whereupon it would search through the calling scope."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-11-22 14:07:54+00:00",
                    "text": "@aradi I've thought some more about the scoping issue and have a proposal. Any calls to non-generic procedures in a parameterised function would use the scope of the parameterised module/procedure. If a generic operator/function is used then the compiler will search through the scope of the defining parameterised module and then the scope of the module useing/calling it. A parameterised procedure would be implicitely implicit none(external) (or else require that to be stated explicitly), to avoid any confusion. If it uses a generic interface which has not been defined within its own scope, that generic could be declared as follows:\ngeneric :: function_or_operator_name\n\nBecause defined-assignment is already generic that wouldn't strictly be necessary in your example above. However, to give a more concrete example, I'll do it explicitly:\nmodule testmod\ncontains\n\n  subroutine swap(a, b) generators(T, R)\n    generator, type :: T\n    generator, rank :: R\n\n    generic :: assignment(=)\n\n    T, dimension(R), intent(inout) :: a, b\n\n    T, dimension(R), allocatable :: buffer\n\n    allocate(buffer, mold=a)\n    buffer = a\n    a = b\n    b = buffer\n\n  end subroutine swap\n\nend module testmod"
                },
                {
                    "user": "sblionel",
                    "date": "2019-11-23 00:42:11+00:00",
                    "text": "I think a lot of us on the committee were disappointed that this got deferred, but pretty much everyone agreed it was important to get it right. The main problem was that there was not anything close to a consensus on an approach and there was real worry that we'd rush into a design that ultimately didn't meet enough needs. That we said we wanted to start work on it now and not wait for the next round of work-list decisions was unusual and important.\nBy all means, please submit papers with proposals. Ideally these should include examples of real-world problems and how the proposal would address them with code (or pseudo-code) samples. Many of us need to see these to understand the issues."
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2019-10-16 03:28:27+00:00",
            "title": "bfloat16 proposal",
            "text": "The latest proposal is at https://j3-fortran.org/doc/year/19/19-221r1.txt.",
            "is_open": true,
            "labels": [
                "on hold",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-16 03:33:10+00:00",
                    "text": "Regarding the vote from the proposal:\nStraw votes:\n  1) Y/N  Should we proceed with with specs and syntax?\n  2) If (1) is YES:  how should BFLOAT16 be described?\n     (a) unspecified (aside from 16 bits)\n     (b) reference non iso (probably not allowed)\n     (c) explicit definition in terms of bits?\n\nThe committee voted on 10/15/2019 as No on 1), with the reasoning that the arithmetic is not well specified yet (each hardware vendor can implement it differently), so currently the bfloat16 would act as a \"placeholder\" in Fortran. And that is not a good enough reason. As bfloat16 usage is more common, the committee can revisit adding it to the language."
                },
                {
                    "user": "certik",
                    "date": "2020-02-27 19:42:02+00:00",
                    "text": "The committee discussed https://j3-fortran.org/doc/year/20/20-118.txt on Thursday 2/27/2020."
                },
                {
                    "user": "zjibben",
                    "date": "2020-02-27 19:47:05+00:00",
                    "text": "As per the paper, JoR recommends not pursuing BFLOAT16 for now. The sentiment was echoed, especially concerning lack of a standardized definition for BFLOAT16, and the paper was passed unanimously. The conclusion (to my understanding) is that the committee will not proceed with BFLOAT16."
                },
                {
                    "user": "klausler",
                    "date": "2020-02-27 19:56:18+00:00",
                    "text": "If your environment supports bfloat16, you should be able to get at it via SELECTED_REAL_KIND(2,37) and confirm it via DIGITS() == 8."
                }
            ]
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2019-10-16 03:24:27+00:00",
            "title": "Unsigned integers",
            "text": "All integers in Fortran are signed. It is a common request to include unsigned integers. At the very least to help with the interoperation with the C API that uses unsigned integers.\nThe best approach currently is to use signed integers of the same size, and then convert them to unsigned Fortran integers of a bigger size appropriately.",
            "is_open": true,
            "labels": [
                "unsubmitted",
                "Clause 7"
            ],
            "comments": [
                {
                    "user": "zbeekman",
                    "date": "2019-10-17 16:28:05+00:00",
                    "text": "Yes, for certain algorithms (hash functions) the wrap around nature of unsigned ints is convenient and it would lead to less confusion with C interop. I do not believe the standard requires integers to be implemented as two's complement, but I do not know of a compiler that uses a different convention. This means that the underlying machinery for unsigned integers is already in place. (And that programmers can \"roll their own\" but this can be confusing or less clear/explicit in the source code."
                },
                {
                    "user": "certik",
                    "date": "2019-10-19 00:28:06+00:00",
                    "text": "After talking about this with a few members on the committee, it seems most are in agreement that having this in the C interop might be a good idea, but allowing this in the Fortran language itself would do more harm than good (vendors don't like it; it's easy to have all kinds of subtle bugs with unsigned integers such as comparing subtracting etc.).\nPython does not have unsigned integers, although NumPy does, and so does Julia.\nIt is true that it would be useful for hash functions. Numerical computational code does not seem to need them.\nI can personally see very good arguments both for and against having this in the language itself.\nI am leaning towards against, as it keeps the language smaller and excludes many kinds of possible bugs and warnings.\nWe can start with the C interop, where it should be easier to get agreement, to see if there is anything that would make sense to propose."
                },
                {
                    "user": "gronki",
                    "date": "2019-10-28 16:02:57+00:00",
                    "text": "I wanted to chime in and say that one important use case of unsigned integers is handling images. To store a monochrome 8-bit image, one either has to use twice-as-large 16 bit integer or store it as 8 bit unsigned int and deal with wrapping modulo 128 which makes any arithmetic operation impossible. This is true for any binary data, not only images. So I think the issue is not stricly C-interop related."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 18:24:45+00:00",
                    "text": "I wanted to chime in and say that one important use case of unsigned integers is handling images. To store a monochrome 8-bit image, one either has to use twice-as-large 16 bit integer or store it as 8 bit unsigned int and deal with wrapping modulo 128 which makes any arithmetic operation impossible. This is true for any binary data, not only images. So I think the issue is not stricly C-interop related.\n\nI agree with this: unsigned integers can be of great help in any systems programming context, handling of binary data of any form (images or otherwise) can be a use case within this space.  Though some will argue unsigned integers are not an absolute must for systems programming, the fact is this facility can really make coders' lives easier.  If Fortran intends to be taken truly seriously as a general-purpose language, it should consider including unsigned integers; its type system is general and it does not in any way appear to interfere with its introduction.\nInterestingly, unsigned integers feature was 4th on the top 6 list of desired features by users in the WG5 survey for Fortran 202X.  Ignoring this any longer feels like suppression of the voice of the customers!"
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 21:31:37+00:00",
                    "text": "I just want to react to this particular point:\n\nIf Fortran intends to be taken truly seriously as a general-purpose language\n\nFortran is not a general-purpose language. Rather, it is a domain specific language for array oriented scientific computing.\nAs a larger point, it touches what we want Fortran to be, see #59."
                },
                {
                    "user": "gronki",
                    "date": "2019-10-28 21:36:42+00:00",
                    "text": "Fortran is not a general-purpose language. Rather, it is a domain\nspecific language for array oriented scientific computing.\n\nI agree with this and with that direction, however reading/writing binary\ndata is often a part of it, and this is the place where lack of byte/uint\nreally bit me as very often data is stored as uint16 FITS/TIFF files.\n\nDominik\n\npon., 28 pa\u017a 2019 o 22:31 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n I just want to react to this particular point:\n\n If Fortran intends to be taken truly seriously as a general-purpose\n language\n\n Fortran is not a general-purpose language. Rather, it is a domain specific\n language for array oriented scientific computing.\n\n As a larger point, it touches what we want Fortran to be, see #59\n <#59>.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#2?email_source=notifications&email_token=AC4NA3N4HGNT7GC7E7BKHMDQQ5K3XA5CNFSM4JBFTXZKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOECOOZEY#issuecomment-547155091>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3LG6CZDOIS7GUO7UIDQQ5K3XANCNFSM4JBFTXZA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-10-28 21:42:52+00:00",
                    "text": "@gronki I think you are right about the use case of reading binary data files. Let's collect such use cases. I think we want to be able to write readers and writers for binary files in Fortran."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-10-28 22:32:03+00:00",
                    "text": "I just want to react to this particular point:\n\nIf Fortran intends to be taken truly seriously as a general-purpose language\n\nFortran is not a general-purpose language. Rather, it is a domain specific language for array oriented scientific computing.\n..\n\nThat may be the current reality with Fortran, but almost everyone who have worked on its language design and continue to do so will greatly dislike being reduced as such and would very much want Fortran to be seen as a general-purpose language.  It's a different matter whether the words are backed up by actions!"
                },
                {
                    "user": "certik",
                    "date": "2019-10-29 13:51:04+00:00",
                    "text": "Let's continue the discussion what Fortran should become here: #59. I started in this comment: #59 (comment)."
                },
                {
                    "user": "klausler",
                    "date": "2019-11-05 00:49:23+00:00",
                    "text": "I'm not sure that Fortran needs an unsigned type so much as it actually needs some unsigned operations and relations.  Be wary of simply copying-and-pasting C's unsigned types into Fortran, for they are full of pitfalls that shouldn't be perpetuated, mostly around their interactions with signed types and conversions."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2019-10-16 03:10:47+00:00",
            "title": "Namespace for modules",
            "text": "So you can require module data to be referenced like module.var:\nuse, namespace :: utils\n...\ncall utils%savetxt()\nOne issue with just use utils is that it still pollutes your local namespace with savetxt, so that's the reason for use, namespace :: utils.\nOther alternatives for syntax: use utils, only (or perhaps use utils, only:). Another alternative is use namespace utils (suggested by Milan Curcic). Or perhaps use, namespace :: utils, to by compatible with the existing syntax like use, intrinsic :: iso_fortran_env.\nInitially proposed by Michael Zingale and further discussed at Twitter.",
            "is_open": true,
            "labels": [
                "under consideration",
                "Fortran 202y",
                "Clause 14"
            ],
            "comments": [
                {
                    "user": "certik",
                    "date": "2019-10-16 15:18:47+00:00",
                    "text": "The paper is submitted at https://j3-fortran.org/doc/year/19/19-246.txt. I will try to get feedback on it from the committee. CC @zingale."
                },
                {
                    "user": "cmacmackin",
                    "date": "2019-10-18 14:53:50+00:00",
                    "text": "Agree, this seems like a good feature."
                },
                {
                    "user": "certik",
                    "date": "2019-10-21 18:55:46+00:00",
                    "text": "So the committee unfortunately did not consider this proposal at the meeting last week. I was hoping to get at least a general \"yes\" or \"no\" direction from the committee. But I talked to a few members directly, and I did not hear any \"this is a bad idea\", or \"this should not be done\".\nHere is my plan:\n\n\nWrite a high quality full proposal for this. This means more use cases, we have to brainstorm any possible issues, and some members of the committee like to structure any new features as \"requirements\", \"specification\" and \"syntax\", so we should incorporate all that.\n\n\nI will ask on the j3 mailinglist once a more complete proposal is ready to get some feedback\n\n\nI will ensure that this gets to the committee program for next meeting to be officially considered for the 202y standard."
                },
                {
                    "user": "certik",
                    "date": "2019-10-23 18:12:55+00:00",
                    "text": "@septcolor that's a valid concern. My plan to overcome this is to use this github repository to get support for proposals. If the Fortran community puts thumbs up for a proposal, or otherwise expresses strong interest, then relatively to other ideas proposed here it will be obvious which proposals are high priority, and which are low priority. And then it will be easier to argue for a particular proposal at the committee."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-03 02:22:54+00:00",
                    "text": "Fyi a new thread at comp.lang.fortran inquiring of a missing feature in current Fortran which can be met by the proposal here:\nhttps://groups.google.com/d/msg/comp.lang.fortran/nYdFG0PCTWo/rjjLlAteDgAJ\nBy the way, I had a similar interest along the lines of this proposal several years ago:\nhttps://groups.google.com/forum/#!msg/comp.lang.fortran/sNNnQaoqC9I/JFAEgsbeAPMJ"
                },
                {
                    "user": "certik",
                    "date": "2019-11-03 04:34:57+00:00",
                    "text": "Thanks @FortranFan. This is one of the popular issues in here and I am going to insist for the committee to consider it at the next meeting. However, I welcome any help with improving the current proposal (linked above)."
                },
                {
                    "user": "FortranFan",
                    "date": "2019-11-06 15:31:35+00:00",
                    "text": "@certik wrote:\n\n..However, I welcome any help with improving the current proposal (linked above).\n\n@certik and others interested in this, if you haven't already please take a note of comments online, especially by Ian Harvey at comp.lang.fortran such as this one:\nLook at the last 3 questions in that comment: addressing these questions suitably will strengthen the proposal.  Some aspects that come to my mind with these questions include:\n\nUSE statements can include unnamed operators (+,-*,/, etc.), assignment(=), etc.  What is the impact of this proposal on their semantics?\nWhat about named entities which are operators in USE statements e.g., operator(.cross_product.)?  Does x .cross_product. y become x foo::operator(.cross_product.) y a la C++?\nWhat about generic interfaces and their extension via USE statements?\nCurrent standard has scoping unit semantics with MODULE subroutines/functions (e.g., for use in SUBMODULEs), INTERFACEs. BLOCK constructs, etc. that can be impacted by USE statements.  What happens with them?"
                },
                {
                    "user": "certik",
                    "date": "2019-11-06 15:43:43+00:00",
                    "text": "@FortranFan thanks a lot for pointing these potential issues out. Let's address them."
                },
                {
                    "user": "gronki",
                    "date": "2019-11-19 14:16:28+00:00",
                    "text": "I think calling DRY good and WET bad is rather arbitrary and not a good\nargument. More explicit programming can help avoid some mistakes. In python\nI prefer importing explicitly all names that I use in the code I write. If\nI feel lazy or only do fast prototyping I import the whole module.\n\nI don't see the discussed feature as necessary but that's because I\nprobably will not use it. But for those who prefer that programming style\nit might be good to have that option.\n\nDominik\n\npon., 18 lis 2019, 18:19 u\u017cytkownik septcolor <notifications@github.com>\nnapisa\u0142:\n\u2026\n As for why a more explicit namespace control is useful (and so commonly\n used by other languages), I think there may be at least several reasons:\n\n    - Minimize the degree of symbol/name contamination in the current scope\n    - Enhance the readability of a code via explicit qualifiers (no need\n    to search for\n    \"where this variable comes from\")\n    - DRY (don't repeat yourself)\n    https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\n    - Potentially benefit from a convenient feature for code completion by\n    modern editors and IDEs (e.g. \"Intellisense\"\n    https://docs.microsoft.com/en-us/visualstudio/ide/using-intellisense?view=vs-2019\n    )\n\n ------------------------------\n\n Reference a module like a global \"object\"\n\n In object-oriented (OO) programing, we know that it is very convenient to\n have the ability to refer to components and TBP via the \"%\" symbol. What we\n want is close to this ability for a module, such that we can reference an\n entire module as a global object (like \"singleton\"). We could mimic its\n behavior by creating a dummy type that provides aliases to all module\n variables and contained routines (e.g., via pointers and TBP with NOPASS),\n but this approach is sometimes rather tedious and may not be\n straightforward for 3rd-party libraries. I think this kind of extra work\n becomes unnecessary when a qualifier-based module access is provided at the\n language level.\n ------------------------------\n\n About DRY vs WET\n\n The DRY Wiki page mentions WET as an anti-pattern (i.e., not good\n practice), e.g. \"write everything twice\" and \"we enjoy typing\". To import a\n routine with a long name, I have to type it twice in current Fortran (i.e.,\n once for a USE statement and once for actuall CALL statement). I often find\n this frustrating when I need to import many routines with long names.\n Sometimes, it is suggested to use the rename facility of USE (e.g., use\n foo_mod, only: shortname => long_routine_name), but I feel this approach\n is often not ideal because of the need to consider yet another name for\n each imported routine and also because the reader needs to search for their\n local definition at the top of the current scope.\n ------------------------------\n\n Matplotlib may be a good \"use case\" of an explicit qualifier (mpl, plt,\n etc)\n\n I think a good \"real-world\" use case may be Python/matplotlib, which\n commonly use the qualifier \"mpl\", \"plt\", and so on. Because Matplotlib\n contains tons of names/symbols inside, it is clearly not good practice to\n import all symbols at the same time (via star import). On the other hand,\n if Python had only Fortran-like import facility, it would have to type\n every routine names twice, which is very tedious and lengthy in practice.\n\n In addition to the case of Lapack and redundantly named routines (as\n described in https://j3-fortran.org/doc/year/19/19-246.txt),\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#1?email_source=notifications&email_token=AC4NA3IACAIES5ITFULEN3LQULFB5A5CNFSM4JBFRGNKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEELG26Q#issuecomment-555117946>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3IAD5NPU5VPGKDAU3TQULFB5ANCNFSM4JBFRGNA>\n ."
                },
                {
                    "user": "qolin1",
                    "date": "2019-12-21 17:15:58+00:00",
                    "text": "Gets my vote FWIW. I have wanted this for some time, without knowing its name was \"namespaces\"."
                },
                {
                    "user": "certik",
                    "date": "2019-12-22 04:53:01+00:00",
                    "text": "@qolin1 I just called it \"namespaces\" for a lack of a better name. We will keep pushing for this at our next committee meeting. I think this is a popular feature."
                },
                {
                    "user": "gronki",
                    "date": "2019-12-23 17:36:19+00:00",
                    "text": "I would personally deem this low priority too.\n\npon., 23 gru 2019, 18:00 u\u017cytkownik Peter Klausler <notifications@github.com>\nnapisa\u0142:\n\u2026\n @qolin1 <https://github.com/qolin1> I just called it \"namespaces\" for a\n lack of a better name. We will keep pushing for this at our next committee\n meeting. I think this is a popular feature.\n\n But we need to prioritize. This change is a convenience, not a fix or an\n enabling feature.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#1?email_source=notifications&email_token=AC4NA3LKUEOVUQP4OQOAL5TQ2DVEJA5CNFSM4JBFRGNKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEHRQP5Y#issuecomment-568526839>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3PAMUL3LSMMTI42HE3Q2DVEJANCNFSM4JBFRGNA>\n ."
                },
                {
                    "user": "certik",
                    "date": "2019-12-23 17:49:45+00:00",
                    "text": "@klausler, @gronki make sure you put thumbs up on issues that you find high priority, and let's collaborate on the top priority issues. I just created #122 for that purpose, let's discuss the list of top priority issues there.\nRegarding this issue #1, for me personally this is a huge quality of life improvement, that is a relatively simple feature, and yet it allows to use Fortran modules more like Python. How this stacks up against some other features that we want to push in terms of prioity, that's for a discussion to be had at #122."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 14:17:03+00:00",
                    "text": "I think this is a good idea.\nI worked for many years in a code where policy was that module procedures needed to start with the name or the acronym of the module.  This would make that code neater.\n\n\nI like the use, namespace :: utils syntax.  I think namespace should be optional and disabled by default for backwards compatibility (sorry if I am stating the obvious).\n\n\nI agree that % is the fortranic syntax.  However, its use may increase the complexity of the rules about scope of identifiers, which will need to be significantly rewritten.\n\n\nWould it be possible to simultaneously add the possibility of renaming modules (namespaces) as part of the use declaration?\nuse, non_intrinsic, namespace :: eh => electronic_history\nimplicit none\ncall eh%initialise_method"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-16 15:36:30+00:00",
                    "text": "I like the idea of namespaces, and I like @jme52 syntax example, use, namespace :: sm => some_module, but one thing that should be pointed out is that you would not then be able to do use, namespace :: sm => some_module, only: thing1, thing2. Or at least I don't think you should be able to. Just thought this should be made explicit.\n@jme52 , Why do you think using % increases the complexity of rules about scope? Do you have an example of that?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 16:17:46+00:00",
                    "text": "@jme52, @everythingfunctional thanks for the feedback, I'll update the proposal.\nYes, use, namespace :: eh => electronic_history should be allowed. And use, namespace :: sm => some_module, only: thing1, thing2 would not be allowed.\nAs part of this proposal, we also need to ensure we leave the door open if #86 is implemented, so that the syntax could be kept consistent."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 16:50:19+00:00",
                    "text": "@everythingfunctional, @certik: I don't know why renaming the namespace and specifying some of its names, or even renaming some of its names, should not be allowed, would you mind to elaborate?  I cannot see anything wrong in\nuse, namespace :: eh=>electronic_history, only: init=>default_initialisation_method\ncall eh%init"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-16 17:14:12+00:00",
                    "text": "@jme52 , would that imply the following?\nuse, namespace :: sm => some_module, only: t1 => thing1\ncall sm%t1\ncall sm%thing2 ! this would not be allowed because thing2 wasn't brought into scope\ncall sm%thing1 ! this would not be allowed because thing1 was renamed"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 17:49:55+00:00",
                    "text": "The general idea that I have about this is the following equivalence between Python / Fortran:\n\n\n\nPython\nFortran\n\n\n\n\nimport A\nuse, namespace :: A\n\n\nimport A as B\nuse, namespace :: B => A\n\n\nfrom A import x\nuse A, only: x\n\n\nfrom A import x as y\nuse A, only: y => x\n\n\nfrom A import *\nuse A\n\n\n\nIf we allow use, namespace :: sm => some_module, only: t1 => thing1, then it should be a shortcut for:\n! Fortran\nuse, namespace :: sm => some_module\nuse some_module, only: t1 => thing1\n\n# Python\nimport some_module as sm\nfrom some_module import thing1 as t1\n\nWhich answers @everythingfunctional's question. But I would not allow it, it seems confusing. One can always write the two statements as I did."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-01-16 18:13:33+00:00",
                    "text": "Given that\nuse, namespace :: sm => some_module, only: t1 => thing1\n\nwould be equivalent (if we allowed it) to\nuse, namespace :: sm => some_module\nuse some_module, only: t1 => thing1\n\nthen\ncall t1 ! this works\ncall sm%t1 ! this doesn't work because thing1 still has it's original name through the namespace\ncall sm%thing1 ! so this works\ncall sm%thing2 ! and this works"
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 20:15:11+00:00",
                    "text": "@everythingfunctional yes, exactly."
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 21:54:54+00:00",
                    "text": "@certik, @everythingfunctional: that's not what I was trying to propose.  To me,\nuse, namespace :: sm => some_module, only: t1 => thing1\nmeant \"from module some_module, which will be accessed through the sm name, import only thing1, which will be accessed through the name t1.  So only sm%t1 would be available (nothing else sm%<...>, and nothing directly from some_module).\nForgetting about the only, do you envision being able to write something like this?\nuse :: some_module\nuse, namespace :: sm1 => some_module\nuse, namespace :: sm2 => some_module\nI am not strong on the theory of namespaces, so I don't know if this should be allowed, if it is a good idea, or something to be avoided."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 21:58:40+00:00",
                    "text": "To me,\nuse, namespace :: sm => some_module, only: t1 => thing1\nmeant \"from module some_module, which will be accessed through the sm name, import only thing1, which will be accessed through the name t1. So only sm%t1 would be available (nothing else sm%<...>, and nothing directly from some_module).\n\nI would not do that. Just like you cannot import a derived type and rename or hide some of its parts. Python cannot do this either.\nHowever, I agree that this syntax is confusing and meant a different thing to you than me. That's another reason not to allow it.\n\nForgetting about the only, do you envision being able to write something like this?\nuse :: some_module\nuse, namespace :: sm1 => some_module\nuse, namespace :: sm2 => some_module\nI am not strong on the theory of namespaces, so I don't know if this should be allowed, if it is a good idea, or something to be avoided.\n\nYes, that should be perfectly fine. An equivalent Python code would be:\nfrom some_module import *\nimport some_module as sm1\nimport some_module as sm2"
                },
                {
                    "user": "jme52",
                    "date": "2020-01-16 22:16:08+00:00",
                    "text": "To me,\nuse, namespace :: sm => some_module, only: t1 => thing1\nmeant \"from module some_module, which will be accessed through the sm name, import only thing1, which will be accessed through the name t1. So only sm%t1 would be available (nothing else sm%<...>, and nothing directly from some_module).\n\nI would not do that. Just like you cannot import a derived type and rename or hide some of its parts.\n\nThe difference is that we can already rename in use statements via rename-list's and only-list's.  So if we want to allow for renaming namespaces (which you seem to support), I cannot see a reason why it should not be allowed.\n\nPython cannot do this either.\n\nFor any particular reason?\n\nHowever, I agree that this syntax is confusing and meant a different thing to you than me. That's another reason not to allow it.\n\nI completely understand this meant something different to you, but I think that if any interpretation was included to the standard it would be crystal clear to users with a couple of examples.\nTo me it's rather the other way: the moment that fortraners who are already used to renaming variables see they can also rename modules they will try to do both at the same time, and they won't understand why they cannot do this.\n\n\nForgetting about the only, do you envision being able to write something like this?\nuse :: some_module\nuse, namespace :: sm1 => some_module\nuse, namespace :: sm2 => some_module\nI am not strong on the theory of namespaces, so I don't know if this should be allowed, if it is a good idea, or something to be avoided.\n\nYes, that should be perfectly fine. An equivalent Python code would be:\nfrom some_module import *\nimport some_module as sm1\nimport some_module as sm2\n\nTo me, multiple namespaces out of a single module sound more complicated: what happens to variables that are save'd inside of the module, does each of the namespaces get a copy of it, or do they share it?\nA final comment: I am not sure that something being available or not in Python will be a strong argument for the committee.  I think it would be much more helpful to everybody if an example could be presented where this is useful."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 22:47:48+00:00",
                    "text": "For any particular reason?\n\nYes --- I think the reason is that it fundamentally does not make sense. See below.\n\nTo me it's rather the other way: the moment that fortraners who are already used to renaming variables see they can also rename modules they will try to do both at the same time, and they won't understand why they cannot do this.\n\nThere are two kinds of imports: one imports symbols from a module. We can do that already:\n\n\n\nPython\nFortran\n\n\n\n\nfrom A import x\nuse A, only: x\n\n\nfrom A import x as y\nuse A, only: y => x\n\n\nfrom A import *\nuse A\n\n\n\nOne can either import all symbols, or just some. And one can also rename symbols on import. I think there is no disagreement here. However, notice that neither Python nor Fortran allows you to import a derived type x and somehow rename its members. That fundamentally does not make sense. You can access the member a as x%a, or if you rename x at import time using y%a. But you cannot rename a to b. If you want to do that, you have to assign it as a variable:\ninteger :: b\nb = x%a\nThe other kind of import is to import the whole module as a namespace:\n\n\n\nPython\nFortran\n\n\n\n\nimport A\nuse, namespace :: A\n\n\nimport A as B\nuse, namespace :: B => A\n\n\n\nOne can import it, and optionally rename it. You can view the module A as a derived type. Just like in the previous case it does not make sense to rename members of the derived type, it does not make sense to rename members of the module A if you are accessing them via A%x. If you want to use a different name, you have to do it using a variable, as in the previous case:\ntype(x_t) :: y\ny = A%x\nOr you can use associate.\nRegarding using Python as an argument --- Python is just an example (but a good one!). Do you know of any language that would allow you to do what you are asking for? Also, do you have any use cases for it?\nThe use cases for my proposal above are many, e.g., fortran-lang/stdlib#49, fortran-lang/stdlib#99 as well as all the precedents in other languages. I think even you agree with my limited proposal based on your comments above. We are just catching up with other languages and we are not designing something new and untested.\nThe feature use, namespace :: sm => some_module, only: t1 => thing1 on the other hand does not seem to have precedent in another language and it does not seem to be consistent with Fortran either, per my comment above. As such, that should give us a pause and we should step back and ask if it makes sense what we are designing. If you or others can motivate very well how this make sense and use cases, etc., and can convince the community that we should have it, I am not going to be blocking it. All I am saying is that this seems new and untested and seems inconsistent, so we better be sure we want that."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 23:12:27+00:00",
                    "text": "The proposal was submitted as https://j3-fortran.org/doc/year/20/20-108.txt and it was discussed on Wednesday 2/26/2020 at the plenary meeting. I briefly described the feature in 2 minutes and we discussed for about 15 minutes. Here is the feedback from various members of the committee (thus not necessarily consistent):\n\n\n\ncomment on SIN function: use GENERIC facility in current standard (can't you just make conflicting functions generic and rename on use?)\nNo big difference between module%foo and module_foo\nthis idea is not very compelling\ndo not like '%'; use ':' instead (do not like '.') possibly. Some compilers use colon in error messages and wouldn't use percent to indicate a name inside a module.\nbut colon probably can't be used either. backtick? apostrophe? Period won't work because use might not be private, and we might want nested modules in the future.\nprefers rename on use over namespacing anyways, even if it is there.\n\n\n\nthis is great, fortran doesn't have great mechanisms for this.\n\n\n\nuse Haskell language a lot which has this feature and it is useful\nthis idea should work for derived types and other entities also?\nmight be better as a \"seller\" of this idea to use entities other than procedures in use cases (derived type might be a better use case for this)\n\n\n\n\nWhile working with Modula: did something similar\nbut the main attraction of this idea is for compiler to track where an entity comes from\n\n\n\n\nnot very compelling; renaming facility in current Fortran is ok\nsomething like this might be more relevant in Python world where packages come from disparate places\nstylistically nice, preferable if we have it, but hard to come up with a compelling use case. This is useful in python where there's lots of packages which might conflict, might be useful more as time goes on--we may have a future with packages & libraries. you can almost do everything now if you twist things to work, but it's not as convenient.\n\n\n\n\nthis looks like a solution in search of a problem\n\n\n\n\nin relation to nesting of module entities, will direct qualification be possible? if you allow nesting there may be more than one unique way to get to the object you want.\n\n\n\nthis promotes collaboration, and we have a hidden need for this. the language needs to evolve to facilitate collaboration.\n\n\nIt seems the main conclusion is to provide better use cases (with derived types, and other things) and to address the above objections in the proposal and resubmit next time."
                },
                {
                    "user": "certik",
                    "date": "2020-02-28 23:13:33+00:00",
                    "text": "@zingale, @milancurcic I posted the Committee's feedback on this proposal above."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-05-03 22:20:20+00:00",
                    "text": "Would wrapping all public subroutines and functions inside a module into a derived type be a simple way of achieving this \"namespace\" kind of functionality?\nmodule m_foo\n    implicit none\n    private\n\n    public :: foo\n\n    type :: t_foo\n    contains\n        procedure :: sqrt => sqrt_\n        procedure :: cbrt => cbrt_\n    end type\n\n    type(t_foo), protected :: foo = t_foo()\n\ncontains\n\n    function sqrt_(this,x) result(res)\n        class(t_foo), intent(in) :: this\n        real, intent(in) :: x\n        real :: res\n        res = sqrt(x)\n    end function\n\n    function cbrt_(this,x) result(res)\n        class(t_foo), intent(in) :: this\n        real, intent(in) :: x\n        real :: res\n        res = x**(1./3.)\n    end function\n\nend module\n\nprogram test_foo\n    use m_foo\n    implicit none\n    print *, foo%sqrt(4.), foo%cbrt(27.) !    2.00000000       3.00000000 \nend program\nApart from functions under a generic interface or intrinsic functions, I think it would be doable with some smart preprocessing. There are some problems with this approach, e.g. the module and the type instance which wraps the module functionality must have different names (hence m_foo, t_foo, and foo); the type-bound procedures can in principle reuse intrinsic function names, but the function implementation requires a different name.\nThe most annoying thing is that you have to duplicate all functions, if you want to have the possibility to call both specific functions or the type-bound procedures:\nuse m_foo, only: foo, cbrt  ! separate function needed for cbrt\n\n\nThe alternative route using abstract interfaces and procedure pointers doesn't seem to work, as the procedure pointer must be initialized with a variable that reduces to a constant expression.\nmodule m_foo\nimplicit none\nabstract interface\n  function sqrt_if(x) result(res)\n    real, intent(in) :: x\n    real :: res\n  end function\nend interface\n\nprocedure(sqrt_if), pointer :: psqrt => sqrt_ ! allowed\n\ntype :: t_foo\n  procedure(sqrt_if), pointer, nopass :: sqrt => sqrt_ ! not allowed\nend type\ntype(t_foo), protected :: foo = t_foo()\n\ncontains\n  function sqrt_(x) result(res)\n    real, intent(in) :: x\n    real :: res\n    res = sqrt(x)\n  end function\nend module\nIt is also not possible to use the structure constructor within a module as in type(t_foo), protected :: foo = t_foo(sqrt=sqrt_). It works however if called in the main program as type(t_foo) :: foo; foo = t_foo(sqrt=sqrt_)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-03 22:36:15+00:00",
                    "text": "How would you do it for derived types, global arrays and other entities?\n\nBesides that, your approach would work, but it is so complicated that it's better to not do it at all. For example this proposal allows to use a function both directly or via the module qualifier. In your approach I think you have to use different names.\n\u2026\nOn Sun, May 3, 2020, at 4:20 PM, Ivan wrote:\n\n\n Would wrapping all public subroutines and functions inside a module\n into a derived type be a simple way of achieving this \"namespace\" kind\n of functionality?\n\n module m_foo\n     implicit none\n     private\n\n     public :: foo\n\n     type :: t_foo\n     contains\n         procedure :: sqrt => sqrt_\n         procedure :: cbrt => cbrt_\n     end type\n\n     type(t_foo), protected :: foo = t_foo()\n\n contains\n\n     function sqrt_(this,x) result(res)\n         class(t_foo), intent(in) :: this\n         real, intent(in) :: x\n         real :: res\n         res = sqrt(x)\n     end function\n\n     function cbrt_(this,x) result(res)\n         class(t_foo), intent(in) :: this\n         real, intent(in) :: x\n         real :: res\n         res = x**(1./3.)\n     end function\n\n end module\n\n program test_foo\n     use m_foo\n     implicit none\n     print *, foo%sqrt(4.), foo%cbrt(27.) !    2.00000000\n 3.00000000\n end program\n Apart from functions under a generic interface or intrinsic functions,\n I think it would be doable with some smart preprocessing. There are\n some problems with this approach, e.g. the module and the type instance\n which wraps the module functionality must have different names (hence\n `m_foo`, `t_foo`, and `foo`); the type-bound procedures can in\n principle reuse intrinsic function names, but the function\n implementation requires a different name.\n\n The most annoying thing is that you have to duplicate all functions, if\n you want to have the possibility to call both specific functions or the\n type-bound procedures:\n\n `use m_foo, only: foo, cbrt  ! separate function needed for cbrt\n `\n The alternative route using abstract interfaces and procedure pointers\n doesn't seem to work, as the procedure pointer must be initialized with\n a variable that reduces to a constant expression.\n\n module m_foo\n implicit none\n abstract interface\n   function sqrt_if(x) result(res)\n     real, intent(in) :: x\n     real :: res\n   end function\n end interface\n\n procedure(sqrt_if), pointer :: psqrt => sqrt_ ! allowed\n\n type :: t_foo\n   procedure(sqrt_if), pointer, nopass :: sqrt => sqrt_ ! not allowed\n end type\n type(t_foo), protected :: foo = t_foo()\n\n contains\n   function sqrt_(x) result(res)\n     real, intent(in) :: x\n     real :: res\n     res = sqrt(x)\n   end function\n end module\n It is also not possible to use the structure constructor within a\n module as in `type(t_foo), protected :: foo = t_foo(sqrt=sqrt_)`. It\n works however if called in the main program as `type(t_foo) :: foo; foo\n = t_foo(sqrt=sqrt_)`.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE2WBFWDPBTX2QR5GDRPXU27ANCNFSM4JBFRGNA>."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-05-03 22:57:58+00:00",
                    "text": "Essentially, you would need to place the entire contents of the module in the derived type and bind all the procedures. For derived types it does not work, if you mean something like:\nuse, namespace :: m_foo\ntype(m_foo%t_foo) :: foo\n\nIt is not a good solution, but for modules which only declare functions (e.g. blas or lapack) the functionality is similar (if you can live without being able to import the procedures directly).\nI was hoping to show with my example, that similar functionality can already be achieved in Fortran by \"misusing\" derived types, but as you say the approach is complicated, and it would be nice to develop this into a true language feature which also supported retrieving global entities and derived types."
                },
                {
                    "user": "certik",
                    "date": "2020-05-03 23:13:04+00:00",
                    "text": "Yes, I agree. Thanks for bringing this idea up.\n\u2026\nOn Sun, May 3, 2020, at 4:58 PM, Ivan wrote:\n\n\n Essentially, you would need to place the entire contents of the module\n in the derived type and bind all the procedures. It is not a good\n solution, but for modules which only declare functions (e.g. blas or\n lapack) the functionality is similar (if you can live without being\n able to import the procedures directly).\n\n I was hoping to show with my example, that similar functionality can\n already be achieved in Fortran by \"misusing\" derived types, but as you\n say the approach is so complicated, it would be better off to develop\n this into a true language feature.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBMCPSFPBANRU3LGQDRPXZIDANCNFSM4JBFRGNA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-16 00:09:44+00:00",
                    "text": "I have written a modified version of your 20-108.txt proposal. While I added some words that I think more clearly expressed the intent of the proposal, and added some use cases, the main change is I have replaced the NAMESPACE attribute for modules with a WITH attribute. I find WITH to be at least as intuitive as NAMESPACE and its brevity more user friendly FWIW I took the WITH attribute from Ada. Is it OK if I upload the revision as revised_namespace_proposal.txt?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-16 00:12:28+00:00",
                    "text": "@wclodius2 yes, please do! Upload it as a new merge request. Let me know if you need any help with git or github. Thanks for bringing fresh ideas into this."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-17 17:02:59+00:00",
                    "text": "How do I do a merge request?\n\u2026\n On Jul 15, 2020, at 6:12 PM, Ond\u0159ej \u010cert\u00edk ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> yes, please do! Upload it as a new merge request. Let me know if you need any help with git or github. Thanks for bringing fresh ideas into this.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOWDISOFCNLTHXJGMULR3ZAXXANCNFSM4JBFRGNA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-17 17:07:51+00:00",
                    "text": "@wclodius2 Follow steps 2 and 3 from here, but adjust the filename/directory for this proposal.\n(merge request is same as pull request--the former is git/GitLab jargon, the latter is GitHub jargon \ud83e\udd2a)"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-17 18:34:10+00:00",
                    "text": "I thought I did that properly, but I am having the following oddities:\n\n1. My list of pull requests is showing one request with two files: proposals/default_optional_arguments/revised_proposal.txt, and proposals/namespace_modules/revised_namespace_proposal.txt,\n2. The master directory for proposals/default_optional_arguments/ is not showing revised_proposal.txt though I thought Ond\u0159ej approved its pull request.\n\u0161. The list of pull request is showing not only my request, but an old one from February by Marshallward.\n\u2026\n On Jul 17, 2020, at 11:08 AM, Milan Curcic ***@***.***> wrote:\n\n\n @wclodius2 Follow steps 2 and 3 from here, but adjust the filename/directory for this proposal.\n\n (merge request is same as pull request--the former is git/GitLab jargon, the latter is GitHub jargon \ud83e\udd2a)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-18 17:26:16+00:00",
                    "text": "My list of pull requests is showing one request with two files: proposals/default_optional_arguments/revised_proposal.txt, and proposals/namespace_modules/revised_namespace_proposal.txt,\n\n\n@wclodius2 I'm sorry. You did that properly, but my instructions were incorrect in the sense that they don't work if you have 2 concurrent PRs open. I only realize this now. To have 2 or more concurrent PRs, the commits (file additions) you made to your fork need to be made to separate branches. Currently, both proposals you committed to the master branch on your fork, and that's why both proposals now appear in #175.\n\n\nThe master directory for proposals/default_optional_arguments/ is not showing revised_proposal.txt though I thought Ond\u0159ej approved its pull request.\n\n\nThis is expected. The PR has not been merged yet, so the file still exists only in your fork. The PR will stay open while we discuss it and edit it in the PR thread, and it will only be merged when it's ready to be uploaded to J3. @certik is this the correct workflow?\n\n\nThe list of pull request is showing not only my request, but an old one from February by Marshallward.\n\n\nThis is also expected. There can be many open PRs at any time.\nSo, how do you proceed? You need to commit the revised namespace proposal to a new branch on your fork. Perhaps the easiest way to do this is from the GitHub UI. Navigate here and in the upper-right corner click on Add file -> Upload files. Because you don't have write permissions to this repo, GitHub will automatically create a new branch on your fork to which the files will be uploaded. Once done, navigate to https://github.com/j3-fortran/fortran_proposals and near the top there should be a yellow prompt from GitHub asking if you want to open a new PR from the new branch on your fork.\nGive it a try, and if there are issues I'd be happy to get on a Zoom call with you to do it together via shared screen."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-19 19:06:50+00:00",
                    "text": "Don\u2019t I have to first remove /revised_namespace_proposal.txt, from the initial PR?\n\u2026\n On Jul 18, 2020, at 11:26 AM, Milan Curcic ***@***.***> wrote:\n\n\n My list of pull requests is showing one request with two files: proposals/default_optional_arguments/revised_proposal.txt, and proposals/namespace_modules/revised_namespace_proposal.txt,\n @wclodius2 <https://github.com/wclodius2> I'm sorry. You did that properly, but my instructions were incorrect in the sense that they don't work if you have 2 concurrent PRs open. I only realize this now. To have 2 or more concurrent PRs, the commits (file additions) you made to your fork need to be made from separate branches. Currently, both proposals you committed to the master branch on your fork, and that's why both proposals now appear in #175 <#175>.\n\n The master directory for proposals/default_optional_arguments/ is not showing revised_proposal.txt though I thought Ond\u0159ej approved its pull request.\n This is expected. The PR has not been merged yet, so the file still exists only in your fork. The PR will stay open while we discuss it and edit it in the PR thread, and it will only be merged when it's ready to be uploaded to J3. @certik <https://github.com/certik> is this the correct workflow?\n\n The list of pull request is showing not only my request, but an old one from February by Marshallward.\n This is also expected. There can be many open PRs at any time.\n\n So, how do you proceed? You need to commit the revised namespace proposal to a new branch on your fork. Perhaps the easiest way to do this is from the GitHub UI. Navigate here <https://github.com/j3-fortran/fortran_proposals/tree/master/proposals/namespace_modules> and in the upper-right corner click on Add file -> Upload files. Because you don't have write permissions to this repo, GitHub will automatically create a new branch on your fork to which the files will be uploaded. Once done, navigate to https://github.com/j3-fortran/fortran_proposals <https://github.com/j3-fortran/fortran_proposals> and near the top there should be a yellow prompt from GitHub asking if you want to open a new PR from the new branch on your fork.\n\n Give it a try, and if there are issues I'd be happy to get on a Zoom call with you to do it together via shared screen.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOSAJ5KXMKH4XQSZFYLR4HLMNANCNFSM4JBFRGNA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 17:22:28+00:00",
                    "text": "@wclodius2 You don't have to do it first, but yes, revised_namespace_proposal.txt should be removed from the master branch in your fork (wcloudius2/fortran_proposals)."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-20 21:20:01+00:00",
                    "text": "On Jul 18, 2020, at 11:26 AM, Milan Curcic ***@***.***> wrote:\n\n So, how do you proceed? You need to commit the revised namespace proposal to a new branch on your fork. Perhaps the easiest way to do this is from the GitHub UI. Navigate here <https://github.com/j3-fortran/fortran_proposals/tree/master/proposals/namespace_modules> and in the upper-right corner click on Add file -> Upload files.\n\nDid that and get the error message\nUploads are disabled.\nFile uploads require push access to this repository.\n\nI didn\u2019t see anything indicating that GitHub automatically created a branch.\n Because you don't have write permissions to this repo, GitHub will automatically create a new branch on your fork to which the files will be uploaded. Once done, navigate to https://github.com/j3-fortran/fortran_proposals <https://github.com/j3-fortran/fortran_proposals> and near the top there should be a yellow prompt from GitHub asking if you want to open a new PR from the new branch on your fork.\n\n\nNavigated to https://github.com/j3-fortran/fortran_proposals <https://github.com/j3-fortran/fortran_proposals> and didn\u2019t see a yellow prompt.\n\nNavigated to https://github.com/wclodius2/fortran_proposals/tree/master/proposals/namespace_modules <https://github.com/wclodius2/fortran_proposals/tree/master/proposals/namespace_modules> and there is no option to create a new branch and creating a new fork is disabled with the message \u201cCannot fork because you own this repository and are not a member of any organizations\""
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 22:40:00+00:00",
                    "text": "@wclodius2 Sorry, I thought that would work but it seems like GitHub UI is not as flexible for uploading new files as for editing files in-browser. I went ahead and uploaded your revision in #176 ."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-20 23:11:53+00:00",
                    "text": "Thanks!\n\u2026\n On Jul 20, 2020, at 4:40 PM, Milan Curcic ***@***.***> wrote:\n\n\n @wclodius2 <https://github.com/wclodius2> Sorry, I thought that would work but it seems like GitHub UI is not as flexible for uploading new files as for editing files in-browser. I went ahead and uploaded your revision in #176 <#176> .\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOWMMNFFRMDYRGV2CG3R4TBU7ANCNFSM4JBFRGNA>."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-07-31 17:03:48+00:00",
                    "text": "FWIW I have not seen any further response to this submission. I wonder whether that is because there has been no response or because @milancurcic made the submission and I cannot see responses to submissions by people other than myself? I noticed that some of the participants are labeled Collaborators or Contributors, but I lack such a label and wonder whether it affects what I see?"
                },
                {
                    "user": "septcolor",
                    "date": "2020-07-31 19:47:56+00:00",
                    "text": "Though I'm not sure if this has been discussed already, is it another approach to include the module name itself in the ONLY list (in a way similar to Julia)? For example, assuming that mymod has integer :: foo, baa, this statement\nuse mymod, only: mymod\n\nallows only a qualified access to foo as\nprint *, mymod % foo   !! OK\nprint *, foo   !! error\n\nAt the same time, one can also import multiple entities as\nuse mymod, only: mymod, baa\nuse mymod, only: m => mymod, b => baa    !! rename\n\n(The corresponding syntax in Julia is like using Printf: Printf and using Printf: Printf, @printf.)\n\nThe above approach may help reserve the keyword namespace and with for other purposes. For example, with could be used for importing some components of a derived type into the current scope (to allow unqualified access), e.g.,\nwith ( myobj : foo, baa, baz )\n    print *, foo\n    ...\nend with\n\nThe D language has a similar with statement (https://dlang.org/spec/statement.html#WithStatement)."
                },
                {
                    "user": "klausler",
                    "date": "2020-07-31 19:55:27+00:00",
                    "text": "I like septcolor's suggestion.  Would it be transitive -- i.e., if mymod has a use hismod, only: hismod, would mymod%hismod%baz work?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-31 20:11:34+00:00",
                    "text": "I like @septcolor's suggestion also, I haven't thought of that before.\n@klausler yes, it would make sense to me for it to be transitive."
                },
                {
                    "user": "septcolor",
                    "date": "2020-07-31 20:23:14+00:00",
                    "text": "@Klauser I think the \"transitive\" behavior would be very natural and intuitive. For comparison, I've tried this code in Julia, and it seems to behave as expected.\nmodule mymod1\n  foo = 100\nend\n\nmodule mymod2\n  using ..mymod1: mymod1\n\n  @show mymod1.foo   # OK: 100\n  # @show foo        # Error: foo not defined\nend\n\nmodule mymod3\n  using ..mymod2: mymod2\n\n  @show mymod2.mymod1.foo   # OK: 100\n  # @show mymod1.foo        # Error: mymod1 not defined\nend"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-08-01 00:00:21+00:00",
                    "text": "I am unenthusiastic about overloading the meaning of a keyword like ONLY, but do like the syntactic position of your suggestion. say\nUSE module-name, WITH: module-rename\nstrikes me as relatively intuitive\n\u2026\n On Jul 31, 2020, at 1:48 PM, septcolor ***@***.***> wrote:\n\n\n Though I'm not sure if this has been discussed already, is it another approach to include the module name itself in the ONLY list (in a way similar to Julia)? For example, assuming that mymod has integer :: foo, baa, this statement\n\n use mymod, only: mymod\n allows only a qualified access to foo as\n\n print *, mymod % foo   !! OK\n print *, foo   !! error\n At the same time, one can also import multiple entities as\n\n use mymod, only: mymod, baa\n use mymod, only: m => mymod, b => baa    !! rename\n (The corresponding syntax in Julia is like using Printf: Printf and using Printf: Printf, @printf.)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/APTQDOXGR7MDH4YNKA2NBI3R6MNXZANCNFSM4JBFRGNA>."
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-23 00:09:31+00:00",
                    "text": "(I am sorry if the following has already been discussed in other posts or thread...)\nAnother popular keyword used for this purpose is import (most notably Python), though this keyword is already used for different purposes (interface blocks) in Fortran. Because import is very common in other languages for importing modules, I guess another approach may be to \"reuse\" that keyword for importing a module name only (as a namespace), like import mylib at the top of a given scope (which I think corresponds to use, with :: mylib and use, namespace :: mylib)."
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 00:44:15+00:00",
                    "text": "I like the word import the most. But as you said, it might be technically infeasible to use import for both. We need to see.\n\u2026\nOn Tue, Sep 22, 2020, at 6:09 PM, septcolor wrote:\n\n\n (I am sorry if the following has already been discussed in other posts\n or thread...)\n\n Another popular keyword used for this purpose is `import` (most notably\n Python), though this keyword is already used for different purposes\n (interface blocks) in Fortran. Because `import` is very common in other\n languages for importing modules, I guess another approach may be to\n \"reuse\" that keyword for importing a module name only (as a namespace),\n like `import mylib` at a top of a given scope (which I think\n corresponds to `use, with :: mylib` and `use, namespace :: mylib`).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#1 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWDYE32IZ2CVYXTGUILSHE4EPANCNFSM4JBFRGNA>."
                },
                {
                    "user": "gronki",
                    "date": "2020-09-23 21:12:53+00:00",
                    "text": "My opinion is that it is a bad idea to use word \"import\" for a completely\ndifferent meaning just because other languages do that. In Fortran as of\nnow including modules is accomplished by \"use\", not \"import\", and i think\nit's important to stick to that to not introduce confusion.\n\nDominik\n\n\u015br., 23 wrz 2020 o 02:44 Ond\u0159ej \u010cert\u00edk <notifications@github.com>\nnapisa\u0142(a):\n\u2026\n I like the word import the most. But as you said, it might be technically\n infeasible to use import for both. We need to see.\n\n On Tue, Sep 22, 2020, at 6:09 PM, septcolor wrote:\n >\n >\n > (I am sorry if the following has already been discussed in other posts\n > or thread...)\n >\n > Another popular keyword used for this purpose is `import` (most notably\n > Python), though this keyword is already used for different purposes\n > (interface blocks) in Fortran. Because `import` is very common in other\n > languages for importing modules, I guess another approach may be to\n > \"reuse\" that keyword for importing a module name only (as a namespace),\n > like `import mylib` at a top of a given scope (which I think\n > corresponds to `use, with :: mylib` and `use, namespace :: mylib`).\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <\n #1 (comment)>,\n or unsubscribe <\n https://github.com/notifications/unsubscribe-auth/AAAFAWDYE32IZ2CVYXTGUILSHE4EPANCNFSM4JBFRGNA\n >.\n >\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#1 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3MES2W4RU7XMH4HOILSHFAGZANCNFSM4JBFRGNA>\n ."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-23 21:28:41+00:00",
                    "text": "import conflicts with existing usage; with doesn't make immediate sense to the new reader.\nConsider something like use :: mylib, ns => * or use, as(ns) :: mylib.\n(Edit: see below, I think use :: ns => mylib is better.)"
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 22:13:57+00:00",
                    "text": "Here are the options proposed so far, by category:\nAdd a keyword after use in line with the existing syntax for intrinsic:\n\nuse, namespace :: mylib\nuse, import :: mylib\nuse, with :: mylib\nuse, as(ns) :: mylib\n\nExtend the only keyword:\n\nuse mylib, only\nuse mylib, only:\nuse mylib, only: mylib\n\nExtend the renaming => syntax:\n\nuse :: mylib, ns => *\n\nUse two keywords:\n\nuse namespace mylib\n\nUse a new keyword entirely:\n\nwith mylib"
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 22:20:10+00:00",
                    "text": "I think we need to implement this in a compiler and actually use it.\nLooking at these alternatives, the following starts to look nice:\n\nuse namespace mylib\n\nEasy to type, no ::, no ,, and this will be the most common use case. Maybe even like this:\n\nuse module mylib"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-23 22:24:03+00:00",
                    "text": "I think we need to implement this in a compiler and actually use it.\nLooking at these alternatives, the following starts to look nice:\n\nuse namespace mylib\n\nEasy to type, no ::, no ,, and this will be the most common use case. Maybe even like this:\n\nuse module mylib\n\n\nDoesn't work with fixed-form source, unfortunately.  USENAMESPACEMYLIB is ambiguous, and unlike MODULEPROCEDUREFOO, not clear from the context."
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 22:56:32+00:00",
                    "text": "Doesn't work with fixed-form source, unfortunately. USENAMESPACEMYLIB is ambiguous, and unlike MODULEPROCEDUREFOO, not clear from the context.\n\nI forgot about that. Another example for #108. One option would be to only introduce this syntax in free form, it would not be available in fixed form --- but that's a bigger decision to be made separately."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-23 23:03:02+00:00",
                    "text": "Doesn't work with fixed-form source, unfortunately. USENAMESPACEMYLIB is ambiguous, and unlike MODULEPROCEDUREFOO, not clear from the context.\n\nI forgot about that. Another example for #108. One option would be to only introduce this syntax in free form, it would not be available in fixed form --- but that's a bigger decision to be made separately.\n\nAll Fortran semantics are orthogonal to the source form.  And it's easy to accommodate fixed form here -- you listed many workable alternatives above."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-24 03:43:28+00:00",
                    "text": "Before implementing it it needs to be specified well enough that you know what you are implementing. First in Fortran punctuation is very useful, particularly to remove ambiguities in fixed source form. Second you will want to accommodate the module-nature keywords: intrinsic and the rarely used nonintrinsic. You will also probably want to accommodate module renaming. I am inclined to a single new keyword as it can be unambiguous and reduces typing\n\nnamespace, intrinsic:: iso_fortran_env => iso\nwith, intrinsic:: iso_fortran_env => iso\nusing, intrinsic:: iso_fortran_env => iso"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-25 18:48:08+00:00",
                    "text": "Here's one more, inspired by @klausler but consistent with use ..., only::\nuse iso_fortran_env, as: env\n\nIf you want to use the namespace as is, then it needs some extra typing:\nuse iso_fortran_env, as: iso_fortran_env\n\nNote that use iso_fortran_env, as: env is similar to Python's import numpy as np."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-09-25 19:01:56+00:00",
                    "text": "Stavros (can't find his github name) left a comment in the monthly call, how would the namespace syntax work together with submodules?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 19:05:28+00:00",
                    "text": "Here's one more, inspired by @klausler but consistent with use ..., only::\nuse iso_fortran_env, as: env\n\n\nStylistically I prefer use iso_fortran_env, as: env over use, namespace :: env => iso_fortran_env, but the later is more consistent with existing syntax, and simplifies in a more consistent and concise way."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 19:07:55+00:00",
                    "text": "Stavros (can't find his github name) left a comment in the monthly call, how would the namespace syntax work together with submodules?\n\nWould it be relevant? Currently, consumers of a module can't tell if it uses submodules, so there's no issue on that side. And anything in scope in a module is implicitly in scope in a submodule, so I don't think there's an issue on that side either."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-25 19:09:44+00:00",
                    "text": "Tagging @smeskos here."
                },
                {
                    "user": "certik",
                    "date": "2020-09-25 19:21:37+00:00",
                    "text": "I like use iso_fortran_env, as: env, I think we all do.\nThe question is how to simplify:\nuse iso_fortran_env, as: iso_fortran_env\n\nSome options:\n\nuse iso_fortran_env, as\nuse iso_fortran_env, as:\nuse iso_fortran_env, as: *\nuse iso_fortran_env, as is\nuse iso_fortran_env, as module\nuse iso_fortran_env, as namespace"
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-25 19:26:11+00:00",
                    "text": "Just FWIW, Chapel uses an empty identifier list after only (https://chapel-lang.org/docs/primers/modules.html) to import only the module name, which may translate to\n  use mymod, only:   !! nothing written here\n\n(which is equal to import mymod; that allows only a qualified access of module entities).\nNim uses a similar approach by excluding all entities in the module via the keyword nil (e.g., from mymod import nil), which may correspond to\n  use mymod, only: none\n\n(but this approach needs an additional keyword like \"none\" etc...)\nJulia uses both using and import, where using imports all the exported module entities by default, while import imports only the module name."
                },
                {
                    "user": "certik",
                    "date": "2020-09-25 19:45:09+00:00",
                    "text": "@septcolor you are right. Here is a comparison table:\n\n\n\nPython\nJulia\nChapel\nFortran\n\n\n\n\nimport A\nimport A\nuse A only\nuse A, only:\n\n\nimport A as B\nimport A as B\nuse A as B only\nuse B => A, only:\n\n\nfrom A import x\nusing A: x\nuse A only x\nuse A, only: x\n\n\nfrom A import x as y\nimport A: x as y\nuse A only x as y\nuse A, only: y => x\n\n\nfrom A import *\nusing A\nuse A\nuse A\n\n\n\nNote 1: Julia's syntax for import A as B and import A: x as y is only implemented as a PR (JuliaLang/julia#37396) from 3 weeks ago (!), but not merged yet.\nNote 2: One can use import A: x instead of using A: x in Julia.\nNote 3: Chapel's syntax use A as B only isn't mentioned in the docs, but it seems that would be the natural way (I haven't tested it).\nNote 4: Chapel also has an import syntax, but it seems redundant (?) to the use syntax above.\nGiven this and the Chapel's precedent, I now prefer:\n\nuse A, only:\nuse B => A, only:"
                },
                {
                    "user": "klausler",
                    "date": "2020-09-25 19:51:36+00:00",
                    "text": "use A, only: ! empty to get a namespace is not at all clear, and it doesn't allow for the otherwise orthogonal creation of both a namespace as well as unqualified importation of some names."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-25 19:53:51+00:00",
                    "text": "I don't like use A, only:  because to a naive reader, it's not clear what it means. To me (experienced reader), it's still awkward and seems like it's trying to fit an existing syntax that is used for something else.\nOf @certik's alternative syntaxes, I like this one best:\nuse iso_fortran_env, as is"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-25 19:54:37+00:00",
                    "text": "FWIW having a keyword after only: is prone to namespace conflicts. For example, my stdlib_bitsets module defines a function none."
                },
                {
                    "user": "septcolor",
                    "date": "2020-09-25 20:13:35+00:00",
                    "text": "@klausler As far as I experimented, it seems possible to import the module name as well as module entities by writing two statements, e.g. (in Chapel's case):\nuse Time only;\nuse Time only Timer as Foo;\n\nproc test()\n{\n    var timer = new Time.Timer();\n    writeln( timer.type:string );  // Timer\n\n    var foo = new Foo();\n    writeln( foo.type:string );  // Timer\n}\n\ntest();\n\nbut I agree that use mymod, only:  !! nothing here looks somewhat awkward (at least initially). If there were some keyword representing \"nothing\", we could use it here, but as @wclodius2 says, none etc can conflict with existing symbols.\nPersonally, I prefer using the keyword import most (which is very natural in its meaning), but it is \"reserved\" by the use in interface blocks. I think one could define \"except this, except that\" rules to enable overloading the meaning of import, but I'm afraid this would introduce additional complications (possibly both for compiler implementation and user experiences)..."
                },
                {
                    "user": "klausler",
                    "date": "2020-09-25 20:14:29+00:00",
                    "text": "For what it's worth, Haskell has import [qualified] ModuleName [as Alias] [[hiding] (names)].\nQualified names are available with and without qualified -- the module name or its alias always becomes available as what you all are calling a \"namespace\".  When qualified doesn't appear, the imported names are also available without qualification.\nThe list of imported names can be absent, in which case all exported names from the module are imported.  And it can be negated with hiding to import everything but some names.\nHaskell also allows multiple modules to be imported into the same alias, so long as there are no conflicts.  And module aliases can be exported, too, for use in other modules.  This is useful -- it lets one compose a new module using names imported from others."
                },
                {
                    "user": "smeskos",
                    "date": "2020-09-25 20:19:09+00:00",
                    "text": "@everythingfunctional:\n\nWould it be relevant?\n\nPerhaps not. I am trying to figure this out. Please see the two examples below. Do they make any sense or my confusion is irrelevant to the namespace proposal?\nFirst example with submodules;\nWe have the following module/submodule system:\nmodule Base\nsubmodule A,                                                                                           submodule B\nsubmodule A1,   submodule A2\nDeclaration:\nsubmodule (Base)A,            submodule(Base)B\nsubmodule(Base : A)A1,\nsubmodule(Base : A)A2\nprogram main\nuse, namespace :: Base\n!will Base be able to see every submodule?\ncall Base%A%A1%mySubroutine(args, ...)\nend program\nSecond example:\nmodule All, module A, module B, module C, module D, etc...\nmodule All\nuse, namespace :: A, B, C, D,...\nend module All\n! Is the following correct?\nprogram main\nuse, namespace ::all\ncall all%A%mySubroutineA()\nend program main"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:30:25+00:00",
                    "text": "Submodules aren't supposed to be publicly knowable, so if mySubroutine is publicly available from Base, then it would be accessible as Base%mySubroutine and there would be no need for any reference to the submodule. If something is not declared in the module, it is not publicly accessible."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-25 20:35:13+00:00",
                    "text": "As is common with arguments about syntax, we are \"bike shedding\". Everyone understands syntax, so everyone has a different opinion on it. I can come up with a large number of syntaxes. For example a standalone keyword:\nnamespace, intrinsic:: env=>iso_fortran_env\nwith, intrinsic::  env=>iso_fortran_env\nusing, intrinsic:: env=>iso_fortran_env\nimport, intrinsic:: env=>iso_fortran_env\nemploy, intrinsic:: env=>iso_fortran_env\nsource, intrinsic:: env=>iso_fortran_env\nqualified, intrinsic:: env=>iso_fortran_env\nas is, intrinsic:: env=>iso_fortran_env\n\nmany of the same keywords could be used as attributes in the early part of a use statement, but then the standard has to explain why there is no rename or only list;\nuse, namespace, intrinsic:: env=>iso_fortran_env\nuse, with, intrinsic :: env=>iso_fortran_env\nuse, source, intrinsic :: env=>iso_fortran_env\nuse, qualified, intrinsic :: env=>iso_fortran_env\nuse, as is, intrinsic :: env=>iso_fortran_env\n\nor they could be used as replacements for only\nuse, intrinsic:: iso_fortran_env, namespace: env\nuse, intrinsic:: iso_fortran_env, with: env\nuse, intrinsic:: iso_fortran_env, as is: env\nuse, intrinsic:: iso_fortran_env, qualified: env\n\nI am sure that with more time I could come up with more examples."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-25 20:45:53+00:00",
                    "text": "@wclodius2 I don't think we're bike shedding. Syntax and choice of keywords are not irrelevant details. They have a direct impact on the programmer, what they're writing, and how they feel about it. I think that the new syntax should:\n\nBe as minimal as possible\nBe as intuitive as it can be to a naive reader\nBe as consistent with existing syntax as possible\nSpark joy\n\nThe optimal solution is not easy to come up with and it's impossible to make everybody happy. All these tedious discussions about words and punctuation and what's intuitive or not are necessary and important part of the work. The more people that provide feedback the more clear we will get about the top candidates."
                },
                {
                    "user": "certik",
                    "date": "2020-09-25 20:54:26+00:00",
                    "text": "it doesn't allow for the otherwise orthogonal creation of both a namespace as well as unqualified importation of some names.\n\nNeither Python, Julia or Chapel allow that as far as I know with a single statement. @septcolor gave an example in Chapel, in Python you have to do:\nimport numpy\nfrom numpy import sin\n\nSo in Fortran it would become:\nuse numpy, only:\nuse numpy, only: sin\n\nI agree with @klausler that it looks a bit confusing. Even without the : it looks weird to me: use numpy, only. The Chapel version, on the other hand, looks good: use numpy only and use numpy only x, but we can't use this without a comma due to ambiguities in the fixed form.\n@wclodius2 is right that it might seem like we are \"bike shedding\", but in order to move this proposal further, the syntax is important. @milancurcic just replied above in similar spirit.\nWe agreed at the call that we will do a survey at the Fortran Discourse and ask people for preferences."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-09-26 03:16:59+00:00",
                    "text": "There are two orthogonal choices in the syntax: first what word to use as the keyword, and second where to put the keyword. So far I have seen the following suggestions for keywords:\nnamespace - main problem is its length, but users of C++, where namespace behaves like Fortran's use, may find this usage counterintuitive\nwith - main advantage is its length, some find it unintuitive\nusing - similar to use, slightly suggests requiring the module name to access\nimport - used for this in Python, but already a keyword with different semantics\nemploy - a synonym to use\nsource - slightly suggestive of the semantics\nqualified - one of its meanings is suggestive of the semantics, but not the most commonly used meaning, as long as namespace\nas with as is - one for renaming the other for non-renaming. What happens if you want to rename to is?\nns - an abbreviation for namespace that is similar to nanosecond\nonly - only as a use statement terminator, overloads its current meaning\nAre there any names I missed?\nI know of three possible places to put the keyword\nAt the beginning, making its own statement, i.e,\nkeyword[[, module-nature]::] [local-module-name=>]module-name\nthis is what most of the languages cited do\nAfter the use keyword\nuse [[, keyword][, module-nature]::] [local-module-name=>]module-name\nor\nuse [[, module-nature][, keyword]::] [local-module-name=>]module-name\nIt will be tempting to lump the keyword with intrinsic and nonintrinsic in module-nature, in which case the standard needs to explain that there is no only or rename list.\nReplacing the only keyword\nuse[[, module-nature]::] module-name, keyword[:local-module-name]\nmaking a third form of a use statement"
                },
                {
                    "user": "smeskos",
                    "date": "2020-09-26 07:11:52+00:00",
                    "text": "@wclodius2\n\nAre there any names I missed?\n\nThe word name itself as a verb or the word rename.\nHowever, I find all of the proposed keywords as non-Fortranic way of doing things. With the only exception perhaps of the original proposal of namespace.\nAn example of my personal favorite style of implementing this:\nuse mathematics, only: cdif=>central_difference\ncall cdif()\n!to\nuse, namespace, math=>mathematics, only:cdif=>central_difference\ncall math%cdif()\nThe keyword namespace will be employed to distinguish between using or not using the name of the module and the symbol => optionally if we want to rename locally the name of the module.\nAnother alternative to namespace could be modulename, only because the former may cause confusion with the C++ keyword, and why not to reserve it for a possible future similar implementation.\nTherefore, the alternative to my previous example:\nuse, modulename, math=>mathematics, only:cdif=>central_difference\ncall math%cdif()"
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-26 17:30:32+00:00",
                    "text": "I will request everyone to take a look at my comment in another thread #86, a thread with another proposal that I think is along the same lines as this one.  As I suggest therein, I personally would preface NAMESPACE to reflect a formal concept that is waiting to be introduced in the Fortran standard at some later stage in the advancement of this language.  Fortran being a language that always holds tremendous promise as a tool for scientists and engineers but which is perpetually trying to \"catch up\" to the state-of-the-art in technical computing.  Meaning the language and its bearers haven't fully caught up yet to the concept of namespace and its benefits though Fortran did a take a big step toward it with MODULEs introduced back in 1991 with the Fortran 90 publication.\nIn the context of this particular proposal in this thread, I think the search is for a way to decorate module entities suitably during their \"consumption\" via USE association.\nAnd I think the Fortrannic way will be to introduce both an ATTRIBUTE and a STATEMENT for the same.  And where the options gain a FUNCTION-like syntax with optional arguments within parenthesis.\nThere are several examples of this in the Fortran standard: ALLOCATABLE, BIND, etc.  BIND seems to me to be quite apt here for understanding a facility that is both an ATTRIBUTE and a STATEMENT.  Note the token BIND in my simple-minded thinking can be viewed as a verb or a command or an instruction which is what seems to be the need here.\nSo thinking along the same lines, an alternate suggestion will be to use DECORATE as the token:\nuse, decorate :: utils \n..\ncall utilsXsavetxt(..)\nwhere X is the separator yet to be decided; it can be % (as in call utils%savetxt(..)) or it might be double-colon (as in call utils::savetxt(..)), etc.\nAnd additional options with (re)naming can be introduced as\nuse, decorate( name=\"ut\" ) :: utils \n..\ncall utXsavetxt(..)\nWith the STATEMENT form, the expected syntax is\nuse utils\n..\ndecorate :: utils\n..\ncall utilsXsavetxt(..)\nApplying the same to @smeskos 's examples above, I would expect the syntax to be\nuse, decorate(name=\"math\") :: mathematics, only : cdif => central_difference\ncall mathXcdif()\nAnd if the optional name is not employed,\nuse, decorate :: mathematics, only : cdif => central_difference\ncall mathematicsXcdif()\nWith the example in the J3 paper (https://j3-fortran.org/doc/year/19/19-246.txt), the syntax can look like so:\n    use, decorate :: math\n    use, decorate( name=\"np\" ) :: numpy\n    use, decorate( name=\"sym\") :: sympy\n    ...\n    e1 = npXsin(npXpi)      ! NumPy expression\n    e2 = mathXsin(mathXpi)  ! Built-in Python math expression\n    e3 = symXsin(symXpi)    ! SymPy expression\nand\n    use, decorate :: lapack\n    ..\n    call lapackXdgeev('N', 'V', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &\n     work, lwork, info)\n    ..\n    call lapackXdgetrf(n, n, Amt, lda, ipiv, info)\n    .."
                },
                {
                    "user": "gronki",
                    "date": "2020-09-27 13:52:04+00:00",
                    "text": "I find \"decorate\" concept elegant, except I am not sure why the alternative\nname is to be put in quotes. In free form, spaces or special characters are\nnot allowed in names afaik, while string literal implies that any\ncharacters should be valid. I think that\n\nuse, decorate(name = lpk) :: lapack\n\nwould be more logical.\n\nWhen I look at this syntax, it really looks like Fortran to me. Good shot\nFortranFan.\nAlso because one USE is needed to include one module, while => operator\nusually appears in constructs that can be used in sequences separated by a\ncomma. So\n\nuse, namespace :: np => numpy\n\nnaturally encourages user to do\n\nuse, namespace :: np => numpy, lpk => lapack\n\nwhich would be too much of a stretch considering current USE syntax.\n\nI also would agree that using % (so the same operator used to access\nderived type components) should be very carefully discussed. I would also\nprefer to have a distinguishment between accessing module and derived type\ncomponents. :: seems to be another good candidate. While I love Python and\nin that language no distinguishment makes sense (its an interpreted\nlanguage), I would say in Fortran I would rather know whether it's a\nderived type or just a namespace. There is enough confusion as is with\nparethesis () used both for functions and arrays. Let's not repeat that\nmistake.\n\nDominik\n\nsob., 26 wrz 2020 o 19:30 FortranFan <notifications@github.com> napisa\u0142(a):\n\u2026\n I will request everyone to take a look at my *comment*\n <#86 (comment)>in\n another thread #86\n <#86> that I think\n is related to this one. As I suggest therein, I personally would preface\n NAMESPACE to reflect a *formal* concept to be introduced in the Fortran\n standard at some later stage in the advancement of this language that\n always holds tremendous promise as a tool for scientists and engineers but\n which is perpetually trying to \"catch up\" to the state-of-the-art in\n technical computing. Meaning the language and its bearers haven't fully\n caught up yet to the concept of namespace and its benefits though Fortran\n took a big step toward it with MODULEs back in 1991 with Fortran 90\n publication.\n\n In the context of this particular proposal in this thread, I think the\n search is for a way to *decorate* module entities suitably during their\n \"consumption\" via USE association.\n\n And I think the *Fortrannic way* will be to introduce both an ATTRIBUTE\n and a STATEMENT for the same. And where the options gain a FUNCTION-like\n syntax with optional arguments within parenthesis.\n\n There are several examples of this in the Fortran standard: ALLOCATABLE,\n BIND, etc. BIND seems to me to be quite apt here for understanding a\n facility that is both an ATTRIBUTE and a STATEMENT. Note the token BIND\n in my simple-minded thinking can be viewed as a verb or a command or an\n instruction which is what seems to be the need here.\n\n So thinking along the same lines, an alternate suggestion will be to use\n DECORATE as the token:\n\n use, decorate :: utils\n ..call utilsXsavetxt(..)\n\n where X is the separator yet to be decided; it can be % (as in call\n utils%savetxt(..)) or it might be double-colon (as in call\n utils::savetxt(..)), etc.\n\n And additional options with (re)naming can be introduced as\n\n use, decorate( name=\"ut\" ) :: utils\n ..call utXsavetxt(..)\n\n With the STATEMENT form, the expected syntax is\n\n use utils\n ..\n decorate :: utils\n ..call utilsXsavetxt(..)\n\n Applying the same to @smeskos <https://github.com/smeskos> 's examples\n above, I would expect the syntax to be\n\n use, decorate(name=\"math\") :: mathematics, only : cdif => central_differencecall mathXcdif()\n\n And if the optional name is not employed,\n\n use, decorate :: mathematics, only : cdif => central_differencecall mathematicsXcdif()\n\n With the example in the J3 paper (\n https://j3-fortran.org/doc/year/19/19-246.txt), the syntax can look like\n so:\n\n     use, decorate :: math\n     use, decorate(name=\"np\") :: numpy\n     use, decorate( name=\"sym\") :: sympy\n     ...\n     e1 = npXsin(npXpi)      ! NumPy expression\n     e2 = mathXsin(mathXpi)  ! Built-in Python math expression\n     e3 = symXsin(symXpi)    ! SymPy expression\n\n and\n\n     use, decorate :: lapack\n     ..\n     call lapackXdgeev('N', 'V', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &\n      work, lwork, info)\n     ..\n     call lapackXdgetrf(n, n, Amt, lda, ipiv, info)\n     ..\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#1 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AC4NA3O3N7FNNZ3GMNFHHO3SHYQMNANCNFSM4JBFRGNA>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-27 15:31:53+00:00",
                    "text": "I also like @FortranFan's idea of specifying the namespace name in parentheses following the keyword. Also with @gronki that the new name shouldn't be a string literal.\nI don't like the word \"decorate\" here. To me it means to add functionality to something which I don't think is what we're doing."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-27 17:02:46+00:00",
                    "text": "@gronki, @milancurcic ,\nI'm ok with the synonym to be not a string literal i.e., a default-char-constant-expr per the standard.  I had suggested as much based on what I thought I had heard previously with certain compiler implementations and how they parse the FUNCTION-like approach with the use of parenthesis in ATTRIBUTEs and STATEMENTs.   This is where an implementation or two, as suggested by @certik, will come in handy: it can help work through such options.\n@milancurcic ,\nRe: \"I don't like the word \"decorate\" here. To me it means to add functionality to something which I don't think is what we're doing.\":\n\nnote this proposal is indeed adding a functionality, albeit it is in the form of an adornment or an embellishment that makes something distinguished.  What might previously be a use-associated entity FOO from MY_MOD module will no longer have its first-class (or an independent) identity that it has with current standard.  Meaning, there can no longer be a reference to FOO in that scope.  It must be \"adorned\" as something like MY_MOD::FOO (or MY_MOD%FOO, depending on the separator chosen.)\n\nThen, in the dictionary sense of the term, this is nothing but decoration.  That's why I suggested that token.  It seems to better capture the essence of the functionality being proposed here than all the alternatives suggested upthread.\nBut if it's too verbose, another alternative is ADORN.\nBy the way, I had thought of DISTINGUISH and EMBELLISH also because in a sense with the PI example shown above with Python packages, this proposal is in a way seeking an easier way to distinguish/embellish the entities from each other in a given scope.  It seemed even more verbose or negative-sounding, so I decided against it.\nNow, if people starting getting too much into further nits with the choice of the word, that will confirm @wclodius2 's point earlier about the bikeshedding here."
                },
                {
                    "user": "gronki",
                    "date": "2020-09-27 17:28:01+00:00",
                    "text": "Yeah perharps the choice of a word is a bit of a detail. From my\nperspective as a non-native English speaker, the word should be\ncommonly used in international English (never seen \"adorn\" before) and\nnot to be confused with something else (like IMPORT proposed in\nanother context). I am sure there is one than more word that fits this\ncriteria :)\n\nDominik\n\nniedz., 27 wrz 2020 o 19:02 FortranFan <notifications@github.com> napisa\u0142(a):\n\u2026\n\n @gronki, @milancurcic ,\n\n I'm ok with the synonym to be not a string literal i.e., a default-char-constant-expr per the standard. I had suggested as much based on what I thought I had heard previously with certain compiler implementations and how they parse the FUNCTION-like approach with the use of parenthesis in ATTRIBUTEs and STATEMENTs. This is where an implementation or two, as suggested by @certik, will come in handy: it can help work through such options.\n\n @milancurcic ,\n\n Re: \"I don't like the word \"decorate\" here. To me it means to add functionality to something which I don't think is what we're doing.\":\n\n note this proposal is indeed adding a functionality, albeit it is in the form of an adornment or an embellishment. What might previously be a use-associated entity FOO from MY_MOD module will no longer have its first-class (or an independent) identity that it has with current standard. Meaning, there can no longer be a reference to FOO in that scope. It must be \"adorned\" as something like MY_MOD::FOO (or MY_MOD%FOO, depending on the separator chosen.)\n\n Then, in the dictionary sense of the term, this is nothing but decoration. That's why I suggested that token. It seems to better capture the essence of the functionality being proposed here than all the alternatives suggested upthread.\n\n But if it's too verbose, another alternative is ADORN. But if people starting getting into further nits with the choice of the word, that will confirm @wclodius2 's point earlier about the bikeshedding here.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-27 17:52:48+00:00",
                    "text": "@FortranFan Thank you, only after your detailed explanation I was able to understand--you're not decorating the module itself, but the public entities in the module. Now it makes more sense.\nI'd still advise against it because of how easily it can be confused with decorating as a software design pattern. For example, if I was teaching this concept, I'd have to caveat it with something like \"If you've used decorators in other languages before, be careful--this does something completely different\", and then refer to it as \"namespace\" in the rest of the material. :)\nThis is also a good example of why I think the choice of the word is important."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-09-27 19:31:34+00:00",
                    "text": "@septcolor wrote:\n\n..\nAnd one more possibility may be this form? ..\n.. USE hitechlib AS ht\n\nAs mentioned upthread, punctuation or a separator between conjunctions is needed to support the 2 sources forms in Fortran, and that's why this does not work."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:52:41+00:00",
                    "text": "Thanks everybody for your input and making progress on this issue.\n@septcolor raises an important thing to consider: #86 (nested modules). As posted there, this might work:\nuse, namespace :: mylib%a\n...\ncall mylib%a%something()\n\nI like the :: option instead of % also, but I don't know if it will work syntax wise for nested modules:\nuse, namespace :: mylib::a\n...\ncall mylib::a::something()\n\nDon't know if there could be issues parsing it.\nAnother issue to consider is nested modules (proposed feature as in #86) versus modules using other modules (existing feature) with regards to syntax and importing. E.g., does call mylib::a::something() work for both a being a nested module, versus a being used inside mylib?"
                },
                {
                    "user": "wclodius2",
                    "date": "2020-10-01 17:14:09+00:00",
                    "text": "There seems to have been a consensus that there should be a poll/vote on the preferred syntax. As there has been a significant pause in postings on this issue, I think it is an appropriate to summarize our current syntactic options to prompt more suggestions for options. There are four orthogonal choices in the syntax:\n\nWhat word to use as the keyword\nWhere to put the keyword\nHow to do module renaming\nWhat to use as the accessor \"operator\"\n\nWhat word to use\nSo far I have seen the following suggestions for keywords:\n\nadorn - a shorter version of decorate\nas or as is - one for renaming the other for non-renaming. What happens if you want to rename to is?\ndecorate - slightly long, has a dirfferent meaning in software engineering\nemploy - a synonym to use\nimport - used for this in Python, but already a keyword with different semantics\nnamespace - main problem is its length, but users of C++, where namespace behaves like Fortran's use, may find this usage counterintuitive\nns - an abbreviation for namespace that is similar to nanosecond\nonly - only as a use statement terminator, overloads its current meaning\nqualified - one of its meanings is suggestive of the semantics, but not the most commonly used meaning, as long as namespace\nsource - slightly suggestive of the semantics\nusing - similar to use, slightly suggests requiring the module name to access\nwith - main advantage is its length, some find it unintuitive\n\nAre there any names I missed? With this many options it might be best to do a ranked choice vote.\nWhere to put the keyword\nI know of three possible places to put the keyword\n\nAt the beginning, making its own statement, i.e, keyword[[, module-nature]::] .... This is what most of the languages cited do.\nAfter the use keyword: use [[, keyword][, module-nature]::] ... or use [[, module-nature][, keyword]::] .... It will be tempting to lump the keyword with intrinsic and nonintrinsic in module-nature, in which case the standard needs to explain that there is no only or rename list.\nReplacing the only keyword: use[[, module-nature]::] module-name, keyword[:local-module-name]\nmaking a third form of a use statement.\n\nHow to rename modules\nI have noted three ways to do module renaming:\n\nUse a syntax based on the rename list of the use statement [local-module-name=>]module-name, e.g.,\n\n\nkeyword[[, module-nature]::] [local-module-name=>]module-name\nuse [[, keyword][, module-nature]::] [local-module-name=>]module-name\nuse [[,module-nature]::][local-module-name=>]module-name, keyword\n\n\nAfter the colon after the module name where the keyword replaces only: use [[,module-nature]::]module-name, keyword[: local-module-name]\nIn a parenthesized rename after the keyword\n\n\nkeyword[([name=]local-module-name)][[, module-nature]::] module-name\nuse [[, keyword[([name=]local-module-name)]][, module-nature]::] module-name\nuse [[,module-nature]::]module-name, keyword[([name=]local-module-name)]\n\nWhat to use as accessor operator\nI have noted two suggestions for the accessor operator\n\n%, used as the accessor for derived types\n::, used extensively in the specification-part, but not in the execution-part of Fortran programs/subprograms. The main question is would its use cause what is intended to be an executable statement, to be interpreted as a specification statement, i.e., could a module name be the same as the start of a specification statement.\n\nIn principle other characters could also be used: backtick, ~, @, ^, |, and \\ are ASCII characters not used by Fortran, and, I believe, not used by the common pre-processors.\nFWIW I tend to prefer the shorter keywords, but dislike overloading the meaning of \"only\" and \"import\". So my first preference is with followed by using and adorn. I believe modifying the use statement to incorporate the keyword, will more complicate the standard than having a keyword statement, so I prefer a keyword statement. Because I don't want a modified use statement, I don't want the rename after the colon after the keyword. I don't have strong feelings about keyword[([name=]local-module-name)] versus [local-module-name=>]module-name. I prefer the accessor to be the same as for derived types, i.e., %, but :: would also be acceptable.\nEdit: Formatting by @milancurcic for readability"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-01 19:35:50+00:00",
                    "text": "Thank you for the summary @wclodius2, it's very helpful. Here's my current preference:\n\nWhat word to use: as (renaming) and as is (non-renaming)\nWhere to put the keyword: Option 3: use[[, module-nature]::] module-name, as[: local-module-name]\nHow to rename modules: use[[, module-nature]::] module-name, as is\nWhat to use as accessor operator: Aesthetically I like :: best. If it's problematic due to issues you raise, I like either % or @. Others I don't like.\n\nExamples:\n\nuse stdlib_stats, as: stats\nuse stdlib_stats, as is\n\nAddendum to the syntax proposal which would allow orthogonal imports as @klausler suggested: It's possible to use the only keyword following the as: local-module-name, so the syntax becomes:\nuse[[, module-nature]::] module-name, as[: local-module-name][, only: [local-entity-name =>] entity-name]\n\nExample:\nuse stdlib_stats, as: stats, only: mean, var\n\nThis statement would import stdlib_stats as a stats namespace (with all public entities therein available via the namespace), and also import mean and var into the global namespace.\nTo prevent writing confusing code, as would have to appear before only if both are used. So\nuse stdlib_stats, only: mean, var, as: stats\n\nshouldn't be allowed IMO."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-01 19:50:38+00:00",
                    "text": "I didn't think about that. It does seem like the most elegant solution. Simply make it available as a namespace if you don't need it renamed. It's backward compatible because, as you say, it has been impossible to reference a module name after a use statement. I like it."
                },
                {
                    "user": "wclodius2",
                    "date": "2020-10-01 20:01:51+00:00",
                    "text": "First Fortran module names tend to be long to reduce the possibility of name clashes so most of the time users would find renaming useful though it could be\n\nuse[(name=local-module-name)][[,module-nature]::]module-name..;.\n\nSecond some users will want the processor to enforce the use of the module name as a qualifier which in turn requires the use of a different syntax to let the processor know that that is a requirement."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-10-01 20:11:53+00:00",
                    "text": "some users will want the processor to enforce the use of the module name as a qualifier which in turn requires the use of a different syntax to let the processor know that that is a requirement.\n\nIndeed, once you can namespace, simple and common names will proliferate in modules and the user should have a way to not have them pollute the global namespace."
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 21:03:19+00:00",
                    "text": "@klausler That seems to be a very similar idea to what I proposed above #1 (comment), but I thought you didn't like it. Are you proposing exactly the table in that comment, or are you proposing the following table (in other words, do you want to allow use A, only: or not):\n\n\n\nCase\nPython\nJulia\nChapel\nFortran\n\n\n\n\n1.\nimport A\nimport A\nuse A only\nuse A\n\n\n2.\nimport A as B\nimport A as B\nuse A as B only\nuse B => A\n\n\n3.\nfrom A import x\nusing A: x\nuse A only x\nuse A, only: x\n\n\n4.\nfrom A import x as y\nimport A: x as y\nuse A only x as y\nuse A, only: y => x\n\n\n5.\nfrom A import *\nusing A\nuse A\nuse A\n\n\n\nFurthermore, in all cases 1.-5., the module name A (or B in 2.) will always be created as a namespace, in addition to importing all the symbols from it in 1., 2. and 5. (and only x or y in 3. and 4.).\nIf the above is what you are proposing, I can see all kinds of extensions in the compiler, for example with an option the compiler can start warning (by supplying -Wimplicit-use) if you do use A but use any implicitly imported symbol from the module (in case 1.), and if you want to use case 5. and not get a warning, you can do use A, only: *. The syntax would be natural, and I would enable that -Wimplicit-use warning option for my codes (I currently never use use A anyway). In this case, it would make sense to consider adding the syntax use A, only: * into this proposal also, to make it standardized: in other words, use A, only: * would be equivalent to use A, but the compiler would only warn if you use some symbol implicitly in the latter case. That should be strictly backwards compatible, and yet doing exactly what I would like. People who don't like this (or for older codes) would just not enable the -Wimplicit-use compiler warning."
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 21:37:43+00:00",
                    "text": "Ok, so to summarize, you are proposing this:\n\n\n\nCase\nPython\nJulia\nChapel\nFortran\n\n\n\n\n1.\nimport A\nimport A\nuse A only\nuse A, only:\n\n\n2.\nimport A as B\nimport A as B\nuse A as B only\nuse B => A, only:\n\n\n3.\nfrom A import x\nusing A: x\nuse A only x\nuse A, only: x\n\n\n4.\nfrom A import x as y\nimport A: x as y\nuse A only x as y\nuse A, only: y => x\n\n\n5.\nfrom A import *\nusing A\nuse A\nuse A\n\n\n\nWhere the cases 1. and 2. are exactly equivalent to Python, but cases 3., 4. and 5. are a \"superset\" of Python: they import the x, y or all symbols as in Python respectively, but also in addition make the module name A available as a namespace in Fortran (which does not happen in Python).\nI like this proposal."
                },
                {
                    "user": "certik",
                    "date": "2020-10-01 23:06:02+00:00",
                    "text": "Thanks Peter. My goal is to get it pre-approved by the committee, saying \"yes, we want this feature, as long as all the issues can be satisfactorily resolved\". The minute it does, I am sure multiple people from the community will help. Obviously nobody wants to put in weeks of work if the committee decides they don't want this feature in the first place.\nI plan to prototype this in a compiler."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-10-01 23:11:12+00:00",
                    "text": "@klausler  wrote Oct. 1, 2020 6:48 PM EDT:\n\nThe harder part of this proposal remains to be discussed, too. ..\n\nI agree.\nAs I alluded to earlier, Fortran language can do better by gaining the formal concept of namespaces.  Ideally, features such as this are best handled as part of that effort.\nConsidering the complexities and constraints involved with piecemeal attempts, a prototype implementation for the formal namespace concept itself will be nice.  The aspects such as this thread can be subparts of such an initiative."
                },
                {
                    "user": "certik",
                    "date": "2020-10-02 22:33:42+00:00",
                    "text": "I personally feel we don't need namespaces, but I agree with Vipul that we should keep it in mind and not close doors by introducing something that would make it very hard to introduce namespaces later if the community wishes that.\nModules and a well designed \"import\" is what I personally would like to see. Fortran is very close.\n@septcolor regarding who can contribute: I strongly encourage you and anyone else to contribute. The committee and the community is composed of both users and compiler vendors / experts, and we need both to collaborate on new features. Leaving things just to compiler vendors, or just to users to design is not optimal, we need a healthy collaboration of both groups."
                },
                {
                    "user": "FortranFan",
                    "date": "2020-10-03 03:25:31+00:00",
                    "text": "@wclodius2 wrote Oct. 1, 2020\n\nThere seems to have been a consensus that there should be a poll/vote on the preferred syntax. As there has been a significant pause in postings on this issue, I think it is an appropriate to summarize our current syntactic options to prompt more suggestions for options. There are four orthogonal choices in the syntax:\nWhat word to use as the keyword\n..\n\nIf there are folks who aren't enthused by any of the keywords thus far, here's another one that can perhaps considered for the poll?  PREFIX:\nuse, prefix(ut) :: utils, only : savetxt\n..\ncall utXsavetxt(..)"
                }
            ]
        }
    ],
    "issue_labels": {
        "Clause 16": "Standard Clause 16: Intrinsic procedures and modules",
        "Clause 8": "Standard Clause 8: Attribute declarations and specifications",
        "unsubmitted": "Has not been submitted to the committee yet",
        "Fortran 202y": "Proposals targeting the standard after F2023",
        "Clause 7": "Standard Clause 7: Types",
        "Clause 18": "Interoperability with C",
        "Clause 10": "Standard Clause 10: Expressions and assignment",
        "Clause 9": "Standard Clause 9: Use of data objects",
        "Clause 11": "Standard Clause 11: Execution control",
        "Clause 14": "Standard Clause 14: Program units",
        "Clause 15": "Standard Clause 15: Procedures",
        "Clause 13": "Standard Clause 13: Input/output editing",
        "Clause 6": "Standard Clause 6: Lexical tokens and source form",
        "Clause 12": "Standard Clause 12: Input/output statements",
        "Fortran 2023": "Proposal targeting the next Fortran standard F2023 (previously called F202X)",
        "accepted": "Has been added to the standard",
        "duplicate": "This issue or pull request already exists",
        "meta": "Related to this repository",
        "in progress": "J3 is moving forward",
        "under consideration": "Has been submitted to the committee",
        "rejected": "",
        "on hold": "J3 has said no, for now"
    }
}